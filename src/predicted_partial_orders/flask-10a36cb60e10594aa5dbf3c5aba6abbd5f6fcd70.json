{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical structural transformation on similar method signatures within the same class. They both change the return type annotation from a generic 't.Callable' to a more specific parameterized callable type, and both apply the same formatting change (splitting the signature across multiple lines). This represents a uniform refactoring pattern being applied to related methods in the same codebase - both are template-related decorator methods in the Flask class. The edits follow the same before\u2192after pattern on the same type of syntactic construct (method signatures with return type annotations)."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical structural transformation on similar method signatures within the same class. They both change the return type annotation from a generic 't.Callable' to a more specific parameterized callable type, and both apply the same formatting change (splitting the signature across multiple lines). This represents a uniform refactoring pattern being applied to related methods in the same codebase - both are template-related decorator methods in the Flask class. The edits follow the same before\u2192after pattern on the same type of syntactic construct (method signatures with return type annotations)."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform identical structural transformations on different methods within the same class. Each edit changes a method signature from a single-line format to a multi-line format and updates the return type annotation from a generic 't.Callable' to a more specific parameterized type. The pattern is: single-line signature with generic return type \u2192 multi-line signature with specific parameterized return type. This represents a bulk refactoring operation applying the same before\u2192after pattern to the same type of syntactic construct (method signatures), making them part of a single contiguous refactor sweep."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform identical structural transformations on different methods within the same class. Each edit changes a method signature from a single-line format to a multi-line format and updates the return type annotation from a generic 't.Callable' to a more specific parameterized type. The pattern is: single-line signature with generic return type \u2192 multi-line signature with specific parameterized return type. This represents a bulk refactoring operation applying the same before\u2192after pattern to the same type of syntactic construct (method signatures), making them part of a single contiguous refactor sweep."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform identical structural changes to method signatures - they both change the return type annotation from 't.Callable' to 't.Callable[[TemplateFilterCallable], TemplateFilterCallable]' and reformat the method signature with the same line-breaking pattern. This represents a bulk uniform substitution where the same before\u2192after pattern is applied to the same type of syntactic construct (method signatures with return type annotations). Both edits are part of what appears to be a single refactoring operation to improve type annotations across related template filter methods. Either edit could be made first, and after making either one, the other would be the natural next step to maintain consistency in the codebase."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform identical structural changes to method signatures - they both change the return type annotation from 't.Callable' to 't.Callable[[TemplateFilterCallable], TemplateFilterCallable]' and reformat the method signature with the same line-breaking pattern. This represents a bulk uniform substitution where the same before\u2192after pattern is applied to the same type of syntactic construct (method signatures with return type annotations). Both edits are part of what appears to be a single refactoring operation to improve type annotations across related template filter methods. Either edit could be made first, and after making either one, the other would be the natural next step to maintain consistency in the codebase."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform identical structural and type annotation changes to different methods within the same Flask class. Edit 0 changes the template_filter method signature by splitting parameters across multiple lines and updating the return type from 't.Callable' to 't.Callable[[TemplateFilterCallable], TemplateFilterCallable]'. Edit 1 applies the exact same pattern to the template_test method, changing the return type from 't.Callable' to 't.Callable[[TemplateTestCallable], TemplateTestCallable]'. This represents a bulk uniform substitution where both edits follow the identical before\u2192after pattern (generic Callable \u2192 specific parameterized Callable) on the same type of syntactic construct (method signatures). The edits reference different symbols (template_filter vs template_test) but apply synchronized formatting and type annotation improvements as part of what appears to be a single refactoring sweep."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform identical structural and type annotation changes to different methods within the same Flask class. Edit 0 changes the template_filter method signature by splitting parameters across multiple lines and updating the return type from 't.Callable' to 't.Callable[[TemplateFilterCallable], TemplateFilterCallable]'. Edit 1 applies the exact same pattern to the template_test method, changing the return type from 't.Callable' to 't.Callable[[TemplateTestCallable], TemplateTestCallable]'. This represents a bulk uniform substitution where both edits follow the identical before\u2192after pattern (generic Callable \u2192 specific parameterized Callable) on the same type of syntactic construct (method signatures). The edits reference different symbols (template_filter vs template_test) but apply synchronized formatting and type annotation improvements as part of what appears to be a single refactoring sweep."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution on method signatures: changing the return type annotation from `-> t.Callable` to `-> t.Callable[[TemplateGlobalCallable], TemplateGlobalCallable]` and reformatting the signature across multiple lines. This is a uniform pattern applied to the same type of syntactic construct (method signatures) in what appears to be a single refactoring operation to improve type annotations. The edits reference different methods (template_global vs app_template_global) but follow the exact same before\u2192after transformation pattern on the same construct type."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical structural substitution on method signatures: changing the return type annotation from `-> t.Callable` to `-> t.Callable[[TemplateGlobalCallable], TemplateGlobalCallable]` and reformatting the signature across multiple lines. This is a uniform pattern applied to the same type of syntactic construct (method signatures) in what appears to be a single refactoring operation to improve type annotations. The edits reference different methods (template_global vs app_template_global) but follow the exact same before\u2192after transformation pattern on the same construct type."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical structural transformation on similar method signatures within the same class. They both change the return type annotation from a generic `t.Callable` to a more specific parameterized callable type, and both apply the same formatting change (splitting the signature across multiple lines). This represents a uniform refactoring pattern being applied to the same type of syntactic construct (method signatures with callable return types) within the same class context. The edits are part of a single, contiguous refactoring task to improve type annotations consistency."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical structural transformation on similar method signatures within the same class. They both change the return type annotation from a generic `t.Callable` to a more specific parameterized callable type, and both apply the same formatting change (splitting the signature across multiple lines). This represents a uniform refactoring pattern being applied to the same type of syntactic construct (method signatures with callable return types) within the same class context. The edits are part of a single, contiguous refactoring task to improve type annotations consistency."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical structural transformation on method signatures within the same class (Blueprint). They both change the return type annotation from a simple 't.Callable' to a more specific generic type annotation with the same pattern: 't.Callable[[XCallable], XCallable]' where X differs only by the method name. Both edits also apply identical formatting changes (multi-line parameter formatting). This represents a uniform, synchronized refactoring pattern applied to the same type of syntactic construct (method signatures) within the same class context."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical structural transformation on method signatures within the same class (Blueprint). They both change the return type annotation from a simple 't.Callable' to a more specific generic type annotation with the same pattern: 't.Callable[[XCallable], XCallable]' where X differs only by the method name. Both edits also apply identical formatting changes (multi-line parameter formatting). This represents a uniform, synchronized refactoring pattern applied to the same type of syntactic construct (method signatures) within the same class context."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform identical structural substitutions on method return type annotations, changing from `t.Callable` to `t.Callable[[SpecificCallable], SpecificCallable]`. However, they modify different methods in different classes - `app_template_filter` in the Blueprint class and `errorhandler` in the Scaffold class. While the pattern of change is identical (same before\u2192after substitution on the same type of syntactic construct), the changed lines reference completely different symbols/methods. This appears to be part of a bulk refactoring to improve type annotations across the codebase, but the methods themselves are unrelated."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform identical structural substitutions on method return type annotations, changing from `t.Callable` to `t.Callable[[SpecificCallable], SpecificCallable]`. However, they modify different methods in different classes - `app_template_filter` in the Blueprint class and `errorhandler` in the Scaffold class. While the pattern of change is identical (same before\u2192after substitution on the same type of syntactic construct), the changed lines reference completely different symbols/methods. This appears to be part of a bulk refactoring to improve type annotations across the codebase, but the methods themselves are unrelated."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform identical structural transformations on method signatures within the same class (Blueprint). They both: (1) split single-line method signatures into multi-line format, and (2) change the return type from generic 't.Callable' to a more specific parameterized callable type. This represents a uniform refactoring pattern applied to similar methods in the same class - both are template-related methods being updated with the same formatting and type annotation improvements. The edits reference different symbols (app_template_filter vs app_template_global) but follow the exact same before\u2192after transformation pattern on the same type of syntactic construct (method signatures). This is a clear case of bulk-edit synchronization where both changes would naturally occur in a single, contiguous refactoring sweep."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform identical structural transformations on method signatures within the same class (Blueprint). They both: (1) split single-line method signatures into multi-line format, and (2) change the return type from generic 't.Callable' to a more specific parameterized callable type. This represents a uniform refactoring pattern applied to similar methods in the same class - both are template-related methods being updated with the same formatting and type annotation improvements. The edits reference different symbols (app_template_filter vs app_template_global) but follow the exact same before\u2192after transformation pattern on the same type of syntactic construct (method signatures). This is a clear case of bulk-edit synchronization where both changes would naturally occur in a single, contiguous refactoring sweep."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits are making identical structural changes to method return type annotations - changing from `t.Callable` to `t.Callable[[SomeCallable], SomeCallable]` pattern. However, they are modifying different methods in different classes (Blueprint.app_template_global vs Scaffold.errorhandler) and different files. While the pattern of change is identical, the changed lines reference completely different symbols/methods. There is no direct code dependency between these specific methods - they are separate symbols despite following the same refactoring pattern. This appears to be part of a bulk type annotation improvement across the codebase, but the methods themselves are unrelated."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits are making identical structural changes to method return type annotations - changing from `t.Callable` to `t.Callable[[SomeCallable], SomeCallable]` pattern. However, they are modifying different methods in different classes (Blueprint.app_template_global vs Scaffold.errorhandler) and different files. While the pattern of change is identical, the changed lines reference completely different symbols/methods. There is no direct code dependency between these specific methods - they are separate symbols despite following the same refactoring pattern. This appears to be part of a bulk type annotation improvement across the codebase, but the methods themselves are unrelated."
        }
    ],
    "allowed_init_edits": [
        1,
        4,
        6
    ]
}