{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'feat_dim' within the same function. Edit 0 introduces the variable by getting it from the model, and Edit 1 modifies the logic that assigns a value to this same variable. The changed lines in both edits explicitly reference the same 'feat_dim' symbol, creating a direct code dependency where either edit naturally prompts consideration of the other as part of the same micro-task of handling feature dimension logic."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'feat_dim' within the same function. Edit 0 introduces the variable by getting it from the model, and Edit 1 modifies the logic that assigns a value to this same variable. The changed lines in both edits explicitly reference the same 'feat_dim' symbol, creating a direct code dependency where either edit naturally prompts consideration of the other as part of the same micro-task of handling feature dimension logic."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform identical structural substitutions on the same variable 'feat_dim' within the same function. Each edit replaces the direct assignment 'feat_dim = -1 if outputs.ndim == 3 else 1' with a conditional check 'if feat_dim is None:' followed by the same assignment. This is a uniform pattern substitution targeting the same syntactic construct (feat_dim assignment logic) in two different locations within the same function scope. Both edits reference and modify the exact same symbol 'feat_dim' and apply the identical before\u2192after transformation pattern."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform identical structural substitutions on the same variable 'feat_dim' within the same function. Each edit replaces the direct assignment 'feat_dim = -1 if outputs.ndim == 3 else 1' with a conditional check 'if feat_dim is None:' followed by the same assignment. This is a uniform pattern substitution targeting the same syntactic construct (feat_dim assignment logic) in two different locations within the same function scope. Both edits reference and modify the exact same symbol 'feat_dim' and apply the identical before\u2192after transformation pattern."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical structural transformation on the same variable `feat_dim` within the same function. They both wrap the existing assignment `feat_dim = -1 if outputs.ndim == 3 else 1` with a conditional check `if feat_dim is None:`. This is a uniform pattern substitution where the same before\u2192after transformation is applied to the same syntactic construct (variable assignment) in two different locations within the same function scope. Both edits reference the exact same symbol `feat_dim` and represent a synchronized refactoring operation that would naturally be performed as part of a single, contiguous micro-task."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical structural transformation on the same variable `feat_dim` within the same function. They both wrap the existing assignment `feat_dim = -1 if outputs.ndim == 3 else 1` with a conditional check `if feat_dim is None:`. This is a uniform pattern substitution where the same before\u2192after transformation is applied to the same syntactic construct (variable assignment) in two different locations within the same function scope. Both edits reference the exact same symbol `feat_dim` and represent a synchronized refactoring operation that would naturally be performed as part of a single, contiguous micro-task."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitution on the same type of syntactic construct. They both replace the line 'feat_dim = -1 if outputs.ndim == 3 else 1' with the same conditional check 'if feat_dim is None: feat_dim = -1 if outputs.ndim == 3 else 1'. This is a uniform pattern substitution within the same test function, where both changes apply the exact same before\u2192after transformation to identical code constructs. This represents a bulk edit or pattern synchronization where either change could be made first and would naturally prompt making the identical change to the other location as part of the same contiguous refactoring task."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitution on the same type of syntactic construct. They both replace the line 'feat_dim = -1 if outputs.ndim == 3 else 1' with the same conditional check 'if feat_dim is None: feat_dim = -1 if outputs.ndim == 3 else 1'. This is a uniform pattern substitution within the same test function, where both changes apply the exact same before\u2192after transformation to identical code constructs. This represents a bulk edit or pattern synchronization where either change could be made first and would naturally prompt making the identical change to the other location as part of the same contiguous refactoring task."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 introduces a new variable `feat_dim` by getting it from the model attribute, and Edit 1 modifies the existing logic to check if this `feat_dim` variable is None before setting it. The changed lines in both edits reference the exact same symbol `feat_dim`. Edit 0 creates the variable assignment, and Edit 1 uses that variable in a conditional check. This creates an immediate code dependency where after making Edit 0, Edit 1 becomes the natural next step to handle the case where `feat_dim` might be None. Both edits can be staged in either order without parser errors, making this bi-directional."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 introduces a new variable `feat_dim` by getting it from the model attribute, and Edit 1 modifies the existing logic to check if this `feat_dim` variable is None before setting it. The changed lines in both edits reference the exact same symbol `feat_dim`. Edit 0 creates the variable assignment, and Edit 1 uses that variable in a conditional check. This creates an immediate code dependency where after making Edit 0, Edit 1 becomes the natural next step to handle the case where `feat_dim` might be None. Both edits can be staged in either order without parser errors, making this bi-directional."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 introduces a new variable `feat_dim` by getting it from the model attribute, and Edit 1 modifies the logic that was previously assigning `feat_dim` to now check if `feat_dim is None` first. The changed lines in both edits reference the exact same symbol `feat_dim` - Edit 0 defines/assigns it, and Edit 1 uses it in a conditional check. This creates a direct code dependency where Edit 0's introduction of `feat_dim` from the model attribute makes Edit 1's conditional check (`if feat_dim is None`) meaningful. Either edit could be made first since both are syntactically valid, but they form a logical pair where one naturally prompts the other as the next step in the same micro-task of refactoring how `feat_dim` is determined."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 introduces a new variable `feat_dim` by getting it from the model attribute, and Edit 1 modifies the logic that was previously assigning `feat_dim` to now check if `feat_dim is None` first. The changed lines in both edits reference the exact same symbol `feat_dim` - Edit 0 defines/assigns it, and Edit 1 uses it in a conditional check. This creates a direct code dependency where Edit 0's introduction of `feat_dim` from the model attribute makes Edit 1's conditional check (`if feat_dim is None`) meaningful. Either edit could be made first since both are syntactically valid, but they form a logical pair where one naturally prompts the other as the next step in the same micro-task of refactoring how `feat_dim` is determined."
        }
    ],
    "allowed_init_edits": [
        4,
        5
    ]
}