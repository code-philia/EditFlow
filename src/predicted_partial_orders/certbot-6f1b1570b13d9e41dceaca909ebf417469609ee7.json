{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits change references to the exact same symbol - the class name 'Authenticator' being renamed to 'ManualAuthenticator'. Edit 0 changes the class definition itself, while Edit 1 updates the super() call within that same class to reference the new name. These edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a single refactoring task. The super() call must be updated when the class name changes to maintain correct inheritance behavior."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits change references to the exact same symbol - the class name 'Authenticator' being renamed to 'ManualAuthenticator'. Edit 0 changes the class definition itself, while Edit 1 updates the super() call within that same class to reference the new name. These edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a single refactoring task. The super() call must be updated when the class name changes to maintain correct inheritance behavior."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits are changing references to the same class from 'Authenticator' to 'ManualAuthenticator'. Edit 0 changes the super() call within the class definition itself, while Edit 1 updates the entry point reference to use the new class name. These edits reference the exact same symbol (the class being renamed) and represent a coordinated rename operation where both changes must happen together for the code to work correctly. Either edit can be made first since both are valid Python syntax, but after making either edit, the other becomes the immediate next step to complete the rename."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits are changing references to the same class from 'Authenticator' to 'ManualAuthenticator'. Edit 0 changes the super() call within the class definition itself, while Edit 1 updates the entry point reference to use the new class name. These edits reference the exact same symbol (the class being renamed) and represent a coordinated rename operation where both changes must happen together for the code to work correctly. Either edit can be made first since both are valid Python syntax, but after making either edit, the other becomes the immediate next step to complete the rename."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 renames the class from 'Authenticator' to 'ManualAuthenticator' in the definition file. Edit 1 updates the instantiation of that same class in the test file to use the new name 'ManualAuthenticator'. Both edits reference the exact same symbol - the class being renamed. After making either edit, the other becomes immediately necessary to maintain code consistency and avoid NameError at runtime. Since Python allows referencing undefined names at parse time (failing only at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 renames the class from 'Authenticator' to 'ManualAuthenticator' in the definition file. Edit 1 updates the instantiation of that same class in the test file to use the new name 'ManualAuthenticator'. Both edits reference the exact same symbol - the class being renamed. After making either edit, the other becomes immediately necessary to maintain code consistency and avoid NameError at runtime. Since Python allows referencing undefined names at parse time (failing only at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 changes the class name from 'Authenticator' to 'ManualAuthenticator' in a super() call within the class definition. Edit 1 changes the instantiation from 'Authenticator' to 'ManualAuthenticator' in a test file. Both edits reference the exact same symbol - the class name that was renamed. After making edit 0 (renaming the class), edit 1 becomes immediately necessary to update the test instantiation to use the new class name, otherwise the test would fail with a NameError. This is a classic definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 changes the class name from 'Authenticator' to 'ManualAuthenticator' in a super() call within the class definition. Edit 1 changes the instantiation from 'Authenticator' to 'ManualAuthenticator' in a test file. Both edits reference the exact same symbol - the class name that was renamed. After making edit 0 (renaming the class), edit 1 becomes immediately necessary to update the test instantiation to use the new class name, otherwise the test would fail with a NameError. This is a classic definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Edit 0 renames the class from 'Authenticator' to 'ManualAuthenticator' in the manual.py file. Edit 1 updates the entry point reference in setup.py to point to the renamed class 'ManualAuthenticator'. The changed lines reference the exact same symbol - the class that was renamed. After renaming the class in edit 0, the entry point in setup.py would reference a non-existent symbol, making edit 1 the immediate next step. However, both edits can be written and parsed in either order since Python allows referencing non-existent symbols at parse time (they only fail at import/runtime). This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Edit 0 renames the class from 'Authenticator' to 'ManualAuthenticator' in the manual.py file. Edit 1 updates the entry point reference in setup.py to point to the renamed class 'ManualAuthenticator'. The changed lines reference the exact same symbol - the class that was renamed. After renaming the class in edit 0, the entry point in setup.py would reference a non-existent symbol, making edit 1 the immediate next step. However, both edits can be written and parsed in either order since Python allows referencing non-existent symbols at parse time (they only fail at import/runtime). This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 renames the class from 'Authenticator' to 'ManualAuthenticator' in the definition, and Edit 1 updates the instantiation of that same class to use the new name 'ManualAuthenticator'. Both edits reference the exact same symbol - the class being renamed. After renaming the class definition, the instantiation must be updated to use the new name, making this a direct definition-usage relationship. Since this is Python, both edits can be parsed in either order (the old name would just cause a NameError at runtime, not a parse error), so the relationship is bi-directional."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 renames the class from 'Authenticator' to 'ManualAuthenticator' in the definition, and Edit 1 updates the instantiation of that same class to use the new name 'ManualAuthenticator'. Both edits reference the exact same symbol - the class being renamed. After renaming the class definition, the instantiation must be updated to use the new name, making this a direct definition-usage relationship. Since this is Python, both edits can be parsed in either order (the old name would just cause a NameError at runtime, not a parse error), so the relationship is bi-directional."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 renames the class from 'Authenticator' to 'ManualAuthenticator' in the definition file. Edit 1 updates the import statement in the test file to import the renamed class. Both edits reference the exact same symbol - the class being renamed. After making edit 0, the import in edit 1 would fail at runtime with an ImportError since 'Authenticator' no longer exists. After making edit 1, the import would fail since 'ManualAuthenticator' doesn't exist yet. However, in Python, both edits can be written and parsed in either order - the failure only occurs at import/runtime, not at parse time. This makes it a bi-directional relationship where either edit naturally prompts the other as the immediate next step."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 renames the class from 'Authenticator' to 'ManualAuthenticator' in the definition file. Edit 1 updates the import statement in the test file to import the renamed class. Both edits reference the exact same symbol - the class being renamed. After making edit 0, the import in edit 1 would fail at runtime with an ImportError since 'Authenticator' no longer exists. After making edit 1, the import would fail since 'ManualAuthenticator' doesn't exist yet. However, in Python, both edits can be written and parsed in either order - the failure only occurs at import/runtime, not at parse time. This makes it a bi-directional relationship where either edit naturally prompts the other as the immediate next step."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 changes the class name from 'Authenticator' to 'ManualAuthenticator' in the super() call within the class definition. Edit 1 updates the import statement to import 'ManualAuthenticator' instead of 'Authenticator' from the same module. These edits reference the exact same symbol - the class that was renamed from 'Authenticator' to 'ManualAuthenticator'. After renaming the class in edit 0, the import in edit 1 must be updated to reference the new name, and vice versa. Both edits can be staged in either order since Python allows importing non-existent names (resulting in ImportError at runtime, not parse error), making this a bi-directional relationship where either edit creates an immediate prompt for the other."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 changes the class name from 'Authenticator' to 'ManualAuthenticator' in the super() call within the class definition. Edit 1 updates the import statement to import 'ManualAuthenticator' instead of 'Authenticator' from the same module. These edits reference the exact same symbol - the class that was renamed from 'Authenticator' to 'ManualAuthenticator'. After renaming the class in edit 0, the import in edit 1 must be updated to reference the new name, and vice versa. Both edits can be staged in either order since Python allows importing non-existent names (resulting in ImportError at runtime, not parse error), making this a bi-directional relationship where either edit creates an immediate prompt for the other."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits are part of a uniform renaming operation changing 'Authenticator' to 'ManualAuthenticator'. Edit 0 renames the test class and its docstring, while Edit 1 updates the import statement to match the renamed class. Both changed lines reference the exact same symbol being renamed (the Authenticator/ManualAuthenticator class), making this a synchronized substitution pattern where either edit can be made first and naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits are part of a uniform renaming operation changing 'Authenticator' to 'ManualAuthenticator'. Edit 0 renames the test class and its docstring, while Edit 1 updates the import statement to match the renamed class. Both changed lines reference the exact same symbol being renamed (the Authenticator/ManualAuthenticator class), making this a synchronized substitution pattern where either edit can be made first and naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits are part of renaming the same class from 'Authenticator' to 'ManualAuthenticator'. Edit 0 renames the test class and its docstring, while Edit 1 updates the instantiation of the class being tested. The changed lines reference the exact same symbol (the Authenticator class) - Edit 0 renames the test class that tests this symbol, and Edit 1 updates the instantiation of this same symbol. This is a synchronized renaming operation where both edits must reference the same underlying class symbol for the rename to be complete and consistent."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits are part of renaming the same class from 'Authenticator' to 'ManualAuthenticator'. Edit 0 renames the test class and its docstring, while Edit 1 updates the instantiation of the class being tested. The changed lines reference the exact same symbol (the Authenticator class) - Edit 0 renames the test class that tests this symbol, and Edit 1 updates the instantiation of this same symbol. This is a synchronized renaming operation where both edits must reference the same underlying class symbol for the rename to be complete and consistent."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits involve renaming the same class from 'Authenticator' to 'ManualAuthenticator'. Edit 0 renames the test class from 'AuthenticatorTest' to 'ManualAuthenticatorTest' and updates its docstring, while Edit 1 updates the instantiation of the class being tested from 'Authenticator' to 'ManualAuthenticator'. These are part of a uniform substitution pattern where the same symbol (the class name) is being renamed consistently across different usage contexts. Both edits reference the exact same underlying class symbol and represent a synchronized refactoring operation that would naturally occur as part of a single, contiguous micro-task."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits involve renaming the same class from 'Authenticator' to 'ManualAuthenticator'. Edit 0 renames the test class from 'AuthenticatorTest' to 'ManualAuthenticatorTest' and updates its docstring, while Edit 1 updates the instantiation of the class being tested from 'Authenticator' to 'ManualAuthenticator'. These are part of a uniform substitution pattern where the same symbol (the class name) is being renamed consistently across different usage contexts. Both edits reference the exact same underlying class symbol and represent a synchronized refactoring operation that would naturally occur as part of a single, contiguous micro-task."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits change references to the exact same symbol - they both update 'Authenticator' to 'ManualAuthenticator' in the letsencrypt.plugins.manual module. Edit 0 changes the import statement in a test file, while Edit 1 changes the entry point reference in setup.py. Both changed lines reference the same fully qualified symbol (letsencrypt.plugins.manual.Authenticator \u2192 letsencrypt.plugins.manual.ManualAuthenticator). This appears to be part of a uniform refactoring operation where a class was renamed from 'Authenticator' to 'ManualAuthenticator', requiring synchronized updates across all references. Either edit can be made first without causing parse errors, and after making either edit, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits change references to the exact same symbol - they both update 'Authenticator' to 'ManualAuthenticator' in the letsencrypt.plugins.manual module. Edit 0 changes the import statement in a test file, while Edit 1 changes the entry point reference in setup.py. Both changed lines reference the same fully qualified symbol (letsencrypt.plugins.manual.Authenticator \u2192 letsencrypt.plugins.manual.ManualAuthenticator). This appears to be part of a uniform refactoring operation where a class was renamed from 'Authenticator' to 'ManualAuthenticator', requiring synchronized updates across all references. Either edit can be made first without causing parse errors, and after making either edit, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Authenticator(' to 'ManualAuthenticator(' in constructor calls within the same setUp method of the same test class. This is a uniform refactoring operation where both changes target the same type of syntactic construct (constructor calls) with the exact same before\u2192after pattern. The edits are part of a single, contiguous refactor to rename the class being instantiated, and either edit can be made first as both are mechanically independent substitutions that would naturally occur together in one uninterrupted micro-task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Authenticator(' to 'ManualAuthenticator(' in constructor calls within the same setUp method of the same test class. This is a uniform refactoring operation where both changes target the same type of syntactic construct (constructor calls) with the exact same before\u2192after pattern. The edits are part of a single, contiguous refactor to rename the class being instantiated, and either edit can be made first as both are mechanically independent substitutions that would naturally occur together in one uninterrupted micro-task."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits change references from 'Authenticator' to 'ManualAuthenticator' for the exact same symbol. Edit 0 changes the class instantiation in a test file, while Edit 1 changes the entry point configuration in setup.py. Both changed lines reference the same class symbol that was renamed from 'Authenticator' to 'ManualAuthenticator'. This is a bi-directional relationship because both edits are part of the same refactoring operation - renaming a class and updating all references to it. Either edit can be made first, and after making either edit, the other becomes the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits change references from 'Authenticator' to 'ManualAuthenticator' for the exact same symbol. Edit 0 changes the class instantiation in a test file, while Edit 1 changes the entry point configuration in setup.py. Both changed lines reference the same class symbol that was renamed from 'Authenticator' to 'ManualAuthenticator'. This is a bi-directional relationship because both edits are part of the same refactoring operation - renaming a class and updating all references to it. Either edit can be made first, and after making either edit, the other becomes the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol - they are changing 'Authenticator' to 'ManualAuthenticator' in both the import statement and its usage. Edit 0 changes the import from 'Authenticator' to 'ManualAuthenticator', and Edit 1 changes the usage of that imported symbol from 'Authenticator' to 'ManualAuthenticator'. This is a classic import-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step. The edits are part of a single refactoring operation to rename the class, and both can be staged in either order since Python allows referencing undefined names at parse time (only failing at runtime)."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol - they are changing 'Authenticator' to 'ManualAuthenticator' in both the import statement and its usage. Edit 0 changes the import from 'Authenticator' to 'ManualAuthenticator', and Edit 1 changes the usage of that imported symbol from 'Authenticator' to 'ManualAuthenticator'. This is a classic import-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step. The edits are part of a single refactoring operation to rename the class, and both can be staged in either order since Python allows referencing undefined names at parse time (only failing at runtime)."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits change references from 'Authenticator' to 'ManualAuthenticator' for the exact same symbol. Edit 0 changes the instantiation in a test file from 'Authenticator' to 'ManualAuthenticator', while Edit 1 changes the entry point configuration in setup.py to reference the same class. Both changed lines reference the exact same symbol (the ManualAuthenticator class from letsencrypt.plugins.manual), creating a direct code dependency. This appears to be part of a uniform refactoring where a class was renamed from 'Authenticator' to 'ManualAuthenticator' and all references needed to be updated. Either edit could be made first and would create an immediate prompt for the other to maintain consistency."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits change references from 'Authenticator' to 'ManualAuthenticator' for the exact same symbol. Edit 0 changes the instantiation in a test file from 'Authenticator' to 'ManualAuthenticator', while Edit 1 changes the entry point configuration in setup.py to reference the same class. Both changed lines reference the exact same symbol (the ManualAuthenticator class from letsencrypt.plugins.manual), creating a direct code dependency. This appears to be part of a uniform refactoring where a class was renamed from 'Authenticator' to 'ManualAuthenticator' and all references needed to be updated. Either edit could be made first and would create an immediate prompt for the other to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits change references to the exact same symbol from 'Authenticator' to 'ManualAuthenticator' within the same test class setUp method. Edit 0 changes the import statement, and Edit 1 changes the usage of that imported symbol. This creates a direct code dependency - after making either edit, the other becomes immediately necessary to maintain consistency between the import and its usage. The changed lines reference the exact same symbol, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits change references to the exact same symbol from 'Authenticator' to 'ManualAuthenticator' within the same test class setUp method. Edit 0 changes the import statement, and Edit 1 changes the usage of that imported symbol. This creates a direct code dependency - after making either edit, the other becomes immediately necessary to maintain consistency between the import and its usage. The changed lines reference the exact same symbol, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        }
    ],
    "allowed_init_edits": [
        2
    ]
}