{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 adds 'DYNAMODB_LOCAL_PORT' to a configuration list, while Edit 1 creates a new method that uses 'config.DYNAMODB_LOCAL_PORT'. The changed lines reference the exact same symbol - the DYNAMODB_LOCAL_PORT configuration variable. Edit 0 makes the configuration available, and Edit 1 uses that configuration. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in implementing DynamoDB local port configuration."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 adds 'DYNAMODB_LOCAL_PORT' to a configuration list, while Edit 1 creates a new method that uses 'config.DYNAMODB_LOCAL_PORT'. The changed lines reference the exact same symbol - the DYNAMODB_LOCAL_PORT configuration variable. Edit 0 makes the configuration available, and Edit 1 uses that configuration. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in implementing DynamoDB local port configuration."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 defines the configuration variable DYNAMODB_LOCAL_PORT in the config module, while Edit 1 uses that exact same symbol (config.DYNAMODB_LOCAL_PORT) in the provider module. The changed lines reference the exact same symbol - DYNAMODB_LOCAL_PORT from the config module. After defining the configuration variable in Edit 0, Edit 1 becomes the immediate next step to use that configuration. This is a classic definition-usage pattern where both edits reference the same fully qualified symbol, making either edit prompt the other as the next mechanical step in the development flow."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 defines the configuration variable DYNAMODB_LOCAL_PORT in the config module, while Edit 1 uses that exact same symbol (config.DYNAMODB_LOCAL_PORT) in the provider module. The changed lines reference the exact same symbol - DYNAMODB_LOCAL_PORT from the config module. After defining the configuration variable in Edit 0, Edit 1 becomes the immediate next step to use that configuration. This is a classic definition-usage pattern where both edits reference the same fully qualified symbol, making either edit prompt the other as the next mechanical step in the development flow."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 defines a new configuration variable DYNAMODB_LOCAL_PORT, and Edit 1 adds this exact same symbol to what appears to be a list or collection (likely CONFIG_VARS or similar). The changed lines reference the exact same symbol 'DYNAMODB_LOCAL_PORT'. After defining the variable in Edit 0, adding it to the configuration list in Edit 1 would be the immediate next mechanical step to make it available in the configuration system. Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 defines a new configuration variable DYNAMODB_LOCAL_PORT, and Edit 1 adds this exact same symbol to what appears to be a list or collection (likely CONFIG_VARS or similar). The changed lines reference the exact same symbol 'DYNAMODB_LOCAL_PORT'. After defining the variable in Edit 0, adding it to the configuration list in Edit 1 would be the immediate next mechanical step to make it available in the configuration system. Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution, changing 'DynamodbServer()' to 'self._new_dynamodb_server()' in two different methods of the same class. This is a uniform refactoring pattern where the same constructor call is being replaced with a method call in multiple locations. Both changed lines reference the exact same type of syntactic construct (constructor/method calls) and apply the identical before\u2192after pattern. Either edit can be made first, and after making one, the other becomes an obvious next step to complete the uniform substitution across the class."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution, changing 'DynamodbServer()' to 'self._new_dynamodb_server()' in two different methods of the same class. This is a uniform refactoring pattern where the same constructor call is being replaced with a method call in multiple locations. Both changed lines reference the exact same type of syntactic construct (constructor/method calls) and apply the identical before\u2192after pattern. Either edit can be made first, and after making one, the other becomes an obvious next step to complete the uniform substitution across the class."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'DynamodbServer()' with 'self._new_dynamodb_server()' in the same class. This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (assignment statements) within the same class context. Both changed lines reference the same method '_new_dynamodb_server()' and perform structurally identical substitutions as part of a single, contiguous refactor."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'DynamodbServer()' with 'self._new_dynamodb_server()' in the same class. This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (assignment statements) within the same class context. Both changed lines reference the same method '_new_dynamodb_server()' and perform structurally identical substitutions as part of a single, contiguous refactor."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'DynamodbServer()' to 'self._new_dynamodb_server()' in the same class (DynamoDBProvider). This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (method calls) within the same class context. Both changed lines reference the exact same transformation pattern and would naturally be part of a single, contiguous refactor operation."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'DynamodbServer()' to 'self._new_dynamodb_server()' in the same class (DynamoDBProvider). This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (method calls) within the same class context. Both changed lines reference the exact same transformation pattern and would naturally be part of a single, contiguous refactor operation."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 1 defines a new method `_new_dynamodb_server` and Edit 0 calls that exact same method in the constructor. The changed line in Edit 0 references `self._new_dynamodb_server()` which is the exact same symbol being defined in Edit 1. After making Edit 1 (defining the method), Edit 0 becomes the immediate next step to use it. After making Edit 0 (calling the method), Edit 1 becomes necessary to provide the definition. Both edits can be written and parsed in either order in Python (calling an undefined method only fails at runtime), making this a bi-directional definition-usage relationship."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 1 defines a new method `_new_dynamodb_server` and Edit 0 calls that exact same method in the constructor. The changed line in Edit 0 references `self._new_dynamodb_server()` which is the exact same symbol being defined in Edit 1. After making Edit 1 (defining the method), Edit 0 becomes the immediate next step to use it. After making Edit 0 (calling the method), Edit 1 becomes necessary to provide the definition. Both edits can be written and parsed in either order in Python (calling an undefined method only fails at runtime), making this a bi-directional definition-usage relationship."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 changes a direct instantiation of DynamodbServer() to a method call self._new_dynamodb_server(), while Edit 1 defines that exact method _new_dynamodb_server(). The changed line in Edit 0 calls the method that Edit 1 defines. This creates an immediate code dependency where Edit 0 references the exact same symbol (_new_dynamodb_server) that Edit 1 defines. After making Edit 0, the method call would be undefined until Edit 1 is applied, making Edit 1 the mechanically obvious next step. However, since this is Python and method calls can be written before the method is defined (only failing at runtime), both edits can be staged in either order, making this bi-directional rather than ordered."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 changes a direct instantiation of DynamodbServer() to a method call self._new_dynamodb_server(), while Edit 1 defines that exact method _new_dynamodb_server(). The changed line in Edit 0 calls the method that Edit 1 defines. This creates an immediate code dependency where Edit 0 references the exact same symbol (_new_dynamodb_server) that Edit 1 defines. After making Edit 0, the method call would be undefined until Edit 1 is applied, making Edit 1 the mechanically obvious next step. However, since this is Python and method calls can be written before the method is defined (only failing at runtime), both edits can be staged in either order, making this bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 changes a direct assignment to call `self._new_dynamodb_server()` method, while Edit 1 defines that exact same method `_new_dynamodb_server`. The changed line in Edit 0 explicitly calls the method that Edit 1 defines. This creates an immediate code dependency where Edit 0 cannot execute successfully without Edit 1's definition, but both edits can be written and parsed in either order (Python allows calling undefined methods at parse time, only failing at runtime). This is a classic definition-usage relationship for the exact same symbol."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 changes a direct assignment to call `self._new_dynamodb_server()` method, while Edit 1 defines that exact same method `_new_dynamodb_server`. The changed line in Edit 0 explicitly calls the method that Edit 1 defines. This creates an immediate code dependency where Edit 0 cannot execute successfully without Edit 1's definition, but both edits can be written and parsed in either order (Python allows calling undefined methods at parse time, only failing at runtime). This is a classic definition-usage relationship for the exact same symbol."
        }
    ],
    "allowed_init_edits": [
        6
    ]
}