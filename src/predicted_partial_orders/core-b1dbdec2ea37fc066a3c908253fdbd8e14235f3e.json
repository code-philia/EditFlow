{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution (STATE_CLASS_TOTAL_INCREASING \u2192 STATE_CLASS_TOTAL) on the same type of syntactic construct (import statements). This is a uniform bulk substitution pattern where both files are being updated to reference the same renamed symbol. The edits reference the exact same symbol and appear to be part of a single, contiguous refactor operation. Either edit can be staged first, and after making either, the other becomes the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution (STATE_CLASS_TOTAL_INCREASING \u2192 STATE_CLASS_TOTAL) on the same type of syntactic construct (import statements). This is a uniform bulk substitution pattern where both files are being updated to reference the same renamed symbol. The edits reference the exact same symbol and appear to be part of a single, contiguous refactor operation. Either edit can be staged first, and after making either, the other becomes the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits change the exact same symbol 'STATE_CLASS_TOTAL_INCREASING' to 'STATE_CLASS_TOTAL' in different locations within the same file. Edit 0 changes the import statement, while Edit 1 changes the usage of that imported symbol. This creates a direct code dependency - after making either edit, the other becomes immediately necessary to maintain consistency. The import and usage reference the exact same symbol, making this a bi-directional relationship where either edit can be made first and naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits change the exact same symbol 'STATE_CLASS_TOTAL_INCREASING' to 'STATE_CLASS_TOTAL' in different locations within the same file. Edit 0 changes the import statement, while Edit 1 changes the usage of that imported symbol. This creates a direct code dependency - after making either edit, the other becomes immediately necessary to maintain consistency. The import and usage reference the exact same symbol, making this a bi-directional relationship where either edit can be made first and naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits involve changing the exact same symbol 'STATE_CLASS_TOTAL_INCREASING' to 'STATE_CLASS_TOTAL'. Edit 0 changes the assignment of this symbol in the production code, while Edit 1 changes the import of this symbol in the test file. The changed lines in both edits reference the exact same symbol, creating a direct code dependency - after making either edit, the other becomes the immediate next step to maintain consistency. This is a bi-directional relationship because either edit can be made first without causing parse errors, but both reference the same symbol and form part of a single refactoring operation."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits involve changing the exact same symbol 'STATE_CLASS_TOTAL_INCREASING' to 'STATE_CLASS_TOTAL'. Edit 0 changes the assignment of this symbol in the production code, while Edit 1 changes the import of this symbol in the test file. The changed lines in both edits reference the exact same symbol, creating a direct code dependency - after making either edit, the other becomes the immediate next step to maintain consistency. This is a bi-directional relationship because either edit can be made first without causing parse errors, but both reference the same symbol and form part of a single refactoring operation."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits change the exact same symbol reference from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the import statement in the production code, while Edit 1 updates the test assertion that verifies the state_class attribute. These edits reference the exact same symbol and form a definition-usage relationship where the production code imports the constant and the test code asserts against it. After making either edit, the other becomes the immediate next step to maintain consistency between the production code and its corresponding test. This is a bi-directional relationship since both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits change the exact same symbol reference from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the import statement in the production code, while Edit 1 updates the test assertion that verifies the state_class attribute. These edits reference the exact same symbol and form a definition-usage relationship where the production code imports the constant and the test code asserts against it. After making either edit, the other becomes the immediate next step to maintain consistency between the production code and its corresponding test. This is a bi-directional relationship since both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits change the exact same constant value from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the implementation in the IntegrationSensor constructor, while edit 1 updates the corresponding test assertion that verifies this state_class attribute. The test is directly asserting on the same attribute being modified in the production code, creating a direct code dependency where both edits reference the same symbol (STATE_CLASS_TOTAL) and the test validates the exact behavior being changed in the implementation."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits change the exact same constant value from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the implementation in the IntegrationSensor constructor, while edit 1 updates the corresponding test assertion that verifies this state_class attribute. The test is directly asserting on the same attribute being modified in the production code, creating a direct code dependency where both edits reference the same symbol (STATE_CLASS_TOTAL) and the test validates the exact behavior being changed in the implementation."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (STATE_CLASS_TOTAL_INCREASING \u2192 STATE_CLASS_TOTAL) on the exact same symbol. Edit 0 changes the import statement to import STATE_CLASS_TOTAL instead of STATE_CLASS_TOTAL_INCREASING, while Edit 1 updates the test assertion to expect STATE_CLASS_TOTAL instead of STATE_CLASS_TOTAL_INCREASING. This is a synchronized bulk substitution where both changed lines reference the exact same symbol and represent a uniform refactoring pattern. Either edit can be made first, and after making either edit, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution (STATE_CLASS_TOTAL_INCREASING \u2192 STATE_CLASS_TOTAL) on the exact same symbol. Edit 0 changes the import statement to import STATE_CLASS_TOTAL instead of STATE_CLASS_TOTAL_INCREASING, while Edit 1 updates the test assertion to expect STATE_CLASS_TOTAL instead of STATE_CLASS_TOTAL_INCREASING. This is a synchronized bulk substitution where both changed lines reference the exact same symbol and represent a uniform refactoring pattern. Either edit can be made first, and after making either edit, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution, changing 'STATE_CLASS_TOTAL_INCREASING' to 'STATE_CLASS_TOTAL'. Edit 0 changes an import statement, while Edit 1 changes a test assertion that references the same imported constant. This is a uniform substitution pattern where both edits reference the exact same symbol (STATE_CLASS_TOTAL_INCREASING being replaced by STATE_CLASS_TOTAL) and are part of a single refactoring operation. The import change and the test assertion update are mechanically linked - after making either edit, the other becomes the immediate next step to maintain consistency. Both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution, changing 'STATE_CLASS_TOTAL_INCREASING' to 'STATE_CLASS_TOTAL'. Edit 0 changes an import statement, while Edit 1 changes a test assertion that references the same imported constant. This is a uniform substitution pattern where both edits reference the exact same symbol (STATE_CLASS_TOTAL_INCREASING being replaced by STATE_CLASS_TOTAL) and are part of a single refactoring operation. The import change and the test assertion update are mechanically linked - after making either edit, the other becomes the immediate next step to maintain consistency. Both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits change the exact same constant value from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the implementation in the IntegrationSensor class constructor, while Edit 1 updates the corresponding test assertion that verifies this state_class attribute. The test is directly asserting on the same attribute being modified in the production code. This creates a bi-directional relationship where either edit can be made first, but after making one, the other becomes the immediate next step to maintain code-test synchronization."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits change the exact same constant value from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the implementation in the IntegrationSensor class constructor, while Edit 1 updates the corresponding test assertion that verifies this state_class attribute. The test is directly asserting on the same attribute being modified in the production code. This creates a bi-directional relationship where either edit can be made first, but after making one, the other becomes the immediate next step to maintain code-test synchronization."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits change the exact same constant value from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the implementation in the IntegrationSensor constructor where self._attr_state_class is assigned, and Edit 1 updates the corresponding test assertion that verifies this state_class attribute. The test is directly asserting on the behavior being modified in the production code - they reference the same semantic symbol (the state_class attribute value). This is a classic test-production synchronization pattern where changing the implementation naturally prompts updating the test that verifies that exact behavior, and vice versa."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits change the exact same constant value from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the implementation in the IntegrationSensor constructor where self._attr_state_class is assigned, and Edit 1 updates the corresponding test assertion that verifies this state_class attribute. The test is directly asserting on the behavior being modified in the production code - they reference the same semantic symbol (the state_class attribute value). This is a classic test-production synchronization pattern where changing the implementation naturally prompts updating the test that verifies that exact behavior, and vice versa."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol - they are changing from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the import statement to import the new symbol, while Edit 1 changes the usage of that symbol in the test assertion. This is a classic import-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step. In Python, both edits can be staged in either order since the usage before import would only cause a runtime NameError, not a parse error."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol - they are changing from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the import statement to import the new symbol, while Edit 1 changes the usage of that symbol in the test assertion. This is a classic import-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step. In Python, both edits can be staged in either order since the usage before import would only cause a runtime NameError, not a parse error."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits change references to the exact same symbol from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the import statement, while edit 1 changes the usage of that imported symbol in a test assertion. This creates a direct code dependency - after making either edit, the other becomes immediately necessary to maintain consistency. The import and usage reference the same symbol, making this a classic import-usage relationship that is bi-directional since both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits change references to the exact same symbol from STATE_CLASS_TOTAL_INCREASING to STATE_CLASS_TOTAL. Edit 0 changes the import statement, while edit 1 changes the usage of that imported symbol in a test assertion. This creates a direct code dependency - after making either edit, the other becomes immediately necessary to maintain consistency. The import and usage reference the same symbol, making this a classic import-usage relationship that is bi-directional since both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (STATE_CLASS_TOTAL_INCREASING \u2192 STATE_CLASS_TOTAL) on the exact same symbol within the same file. Edit 0 changes the import statement to import STATE_CLASS_TOTAL instead of STATE_CLASS_TOTAL_INCREASING, and Edit 1 updates the usage of that same symbol in a test assertion. This creates a direct code dependency where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a single refactoring task. The relationship is bi-directional because both edits can be staged in either order without causing parse errors - Python allows referencing undefined imports (causing runtime NameError) but doesn't prevent the code from being written or parsed."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution (STATE_CLASS_TOTAL_INCREASING \u2192 STATE_CLASS_TOTAL) on the exact same symbol within the same file. Edit 0 changes the import statement to import STATE_CLASS_TOTAL instead of STATE_CLASS_TOTAL_INCREASING, and Edit 1 updates the usage of that same symbol in a test assertion. This creates a direct code dependency where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a single refactoring task. The relationship is bi-directional because both edits can be staged in either order without causing parse errors - Python allows referencing undefined imports (causing runtime NameError) but doesn't prevent the code from being written or parsed."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'STATE_CLASS_TOTAL_INCREASING' to 'STATE_CLASS_TOTAL' in test assertion lines. Both changed lines have the same syntactic structure (assert statements checking state_class attributes) and apply the exact same before\u2192after pattern to the same type of construct. This represents a bulk uniform substitution that would naturally occur as part of a single, contiguous refactor operation where the developer systematically updates all references to the old constant with the new one."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'STATE_CLASS_TOTAL_INCREASING' to 'STATE_CLASS_TOTAL' in test assertion lines. Both changed lines have the same syntactic structure (assert statements checking state_class attributes) and apply the exact same before\u2192after pattern to the same type of construct. This represents a bulk uniform substitution that would naturally occur as part of a single, contiguous refactor operation where the developer systematically updates all references to the old constant with the new one."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (STATE_CLASS_TOTAL_INCREASING \u2192 STATE_CLASS_TOTAL) on the same type of syntactic construct (test assertions checking state_class attributes) within the same test function. This is a clear bulk-edit pattern where both changes are part of a single, contiguous refactor updating test expectations. The edits reference the same symbols and perform synchronized substitutions that would naturally occur together in one uninterrupted micro-task."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution (STATE_CLASS_TOTAL_INCREASING \u2192 STATE_CLASS_TOTAL) on the same type of syntactic construct (test assertions checking state_class attributes) within the same test function. This is a clear bulk-edit pattern where both changes are part of a single, contiguous refactor updating test expectations. The edits reference the same symbols and perform synchronized substitutions that would naturally occur together in one uninterrupted micro-task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution (STATE_CLASS_TOTAL_INCREASING \u2192 STATE_CLASS_TOTAL) on the same type of syntactic construct (test assertion lines checking state_class attributes). This represents a bulk uniform substitution pattern where both edits are part of the same refactoring operation to update state class constants across test files. The changes are mechanically identical and would naturally occur as part of a single, contiguous search-and-replace operation."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (STATE_CLASS_TOTAL_INCREASING \u2192 STATE_CLASS_TOTAL) on the same type of syntactic construct (test assertion lines checking state_class attributes). This represents a bulk uniform substitution pattern where both edits are part of the same refactoring operation to update state class constants across test files. The changes are mechanically identical and would naturally occur as part of a single, contiguous search-and-replace operation."
        }
    ],
    "allowed_init_edits": [
        5
    ]
}