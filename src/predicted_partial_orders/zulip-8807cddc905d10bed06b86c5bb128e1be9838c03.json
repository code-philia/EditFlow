{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct - they both add the parameter 'acting_user=None' to calls to the bulk_remove_subscriptions function. This represents a uniform, synchronized multi-file substitution where the same before\u2192after pattern is applied to the same function calls across different files. The edits are part of a single refactoring operation to update the function signature consistently."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct - they both add the parameter 'acting_user=None' to calls to the bulk_remove_subscriptions function. This represents a uniform, synchronized multi-file substitution where the same before\u2192after pattern is applied to the same function calls across different files. The edits are part of a single refactoring operation to update the function signature consistently."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds an 'acting_user' parameter to a RealmAuditLog constructor call within the bulk_remove_subscriptions function. Edit 1 updates a call to bulk_remove_subscriptions to include the acting_user parameter. These edits reference the exact same function (bulk_remove_subscriptions) and the same parameter (acting_user). After making edit 0, the function signature effectively changes to expect an acting_user parameter, making edit 1 the immediate next step to update the call site. This is a classic function signature change followed by call-site update pattern for the same function."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds an 'acting_user' parameter to a RealmAuditLog constructor call within the bulk_remove_subscriptions function. Edit 1 updates a call to bulk_remove_subscriptions to include the acting_user parameter. These edits reference the exact same function (bulk_remove_subscriptions) and the same parameter (acting_user). After making edit 0, the function signature effectively changes to expect an acting_user parameter, making edit 1 the immediate next step to update the call site. This is a classic function signature change followed by call-site update pattern for the same function."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds an 'acting_user' parameter to a RealmAuditLog constructor call within the bulk_remove_subscriptions function. Edit 1 adds the same 'acting_user=None' parameter to a call to bulk_remove_subscriptions. These edits reference the exact same symbol (the acting_user parameter of bulk_remove_subscriptions function) and form a definition-usage relationship. After adding the parameter to the function signature/implementation in edit 0, the call site in edit 1 must be updated to match, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds an 'acting_user' parameter to a RealmAuditLog constructor call within the bulk_remove_subscriptions function. Edit 1 adds the same 'acting_user=None' parameter to a call to bulk_remove_subscriptions. These edits reference the exact same symbol (the acting_user parameter of bulk_remove_subscriptions function) and form a definition-usage relationship. After adding the parameter to the function signature/implementation in edit 0, the call site in edit 1 must be updated to match, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds an 'acting_user' parameter to a RealmAuditLog constructor call within the bulk_remove_subscriptions function. Edit 1 updates a call to bulk_remove_subscriptions to include the new 'acting_user=None' parameter. This is a classic function signature change followed by call-site update pattern. The changed lines reference the exact same function symbol (bulk_remove_subscriptions) and the exact same parameter (acting_user). After making edit 0 (adding the parameter to the function signature), edit 1 becomes the immediate next step to update the call site, and vice versa. Both edits can be staged in either order in Python since the call with the missing parameter would only cause a runtime TypeError, not a parse error."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds an 'acting_user' parameter to a RealmAuditLog constructor call within the bulk_remove_subscriptions function. Edit 1 updates a call to bulk_remove_subscriptions to include the new 'acting_user=None' parameter. This is a classic function signature change followed by call-site update pattern. The changed lines reference the exact same function symbol (bulk_remove_subscriptions) and the exact same parameter (acting_user). After making edit 0 (adding the parameter to the function signature), edit 1 becomes the immediate next step to update the call site, and vice versa. Both edits can be staged in either order in Python since the call with the missing parameter would only cause a runtime TypeError, not a parse error."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits are adding the same parameter 'acting_user' to calls of the same function 'bulk_remove_subscriptions'. This represents a bulk uniform substitution pattern where the exact same function signature change is being applied consistently across multiple call sites. The changed lines in both edits reference the exact same symbol (bulk_remove_subscriptions function) and perform identical structural modifications (adding the acting_user parameter). This creates a bi-directional relationship where either edit could be made first, and after making one, the other becomes an immediate, mechanically obvious next step to maintain consistency across the codebase."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits are adding the same parameter 'acting_user' to calls of the same function 'bulk_remove_subscriptions'. This represents a bulk uniform substitution pattern where the exact same function signature change is being applied consistently across multiple call sites. The changed lines in both edits reference the exact same symbol (bulk_remove_subscriptions function) and perform identical structural modifications (adding the acting_user parameter). This creates a bi-directional relationship where either edit could be made first, and after making one, the other becomes an immediate, mechanically obvious next step to maintain consistency across the codebase."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 defines the variable 'acting_user' by assigning it the value 'self.example_user('iago')'. Edit 1 then uses this exact same variable 'acting_user' in the filter parameters. The changed lines reference the exact same symbol - the 'acting_user' variable. After making edit 0, edit 1 becomes the immediate next step to use the newly defined variable. This is a classic definition-usage pattern within the same function scope where both edits reference the same symbol."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 defines the variable 'acting_user' by assigning it the value 'self.example_user('iago')'. Edit 1 then uses this exact same variable 'acting_user' in the filter parameters. The changed lines reference the exact same symbol - the 'acting_user' variable. After making edit 0, edit 1 becomes the immediate next step to use the newly defined variable. This is a classic definition-usage pattern within the same function scope where both edits reference the same symbol."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits are adding the same parameter 'acting_user' to calls of the exact same function 'bulk_remove_subscriptions'. Edit 0 adds 'acting_user=None' and Edit 1 adds 'acting_user=acting_user'. This represents a synchronized parameter addition across multiple call sites of the same function, which is a classic bi-directional relationship. Both edits reference the exact same symbol (bulk_remove_subscriptions function) and involve identical structural changes (adding the acting_user parameter). Either edit could be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to maintain consistency across all call sites of the function."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits are adding the same parameter 'acting_user' to calls of the exact same function 'bulk_remove_subscriptions'. Edit 0 adds 'acting_user=None' and Edit 1 adds 'acting_user=acting_user'. This represents a synchronized parameter addition across multiple call sites of the same function, which is a classic bi-directional relationship. Both edits reference the exact same symbol (bulk_remove_subscriptions function) and involve identical structural changes (adding the acting_user parameter). Either edit could be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to maintain consistency across all call sites of the function."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Edit 0 defines the variable 'acting_user' by assigning it the value 'self.example_user('iago')'. Edit 1 then uses this exact same variable 'acting_user' in a filter query. The changed lines reference the exact same symbol - the 'acting_user' variable defined in edit 0 is directly referenced in edit 1. This creates an immediate code dependency where defining the variable naturally prompts its usage as the next step within the same test method. Both edits are part of a single micro-task of adding acting_user parameter support to the test."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 0 defines the variable 'acting_user' by assigning it the value 'self.example_user('iago')'. Edit 1 then uses this exact same variable 'acting_user' in a filter query. The changed lines reference the exact same symbol - the 'acting_user' variable defined in edit 0 is directly referenced in edit 1. This creates an immediate code dependency where defining the variable naturally prompts its usage as the next step within the same test method. Both edits are part of a single micro-task of adding acting_user parameter support to the test."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical structural substitution pattern on the same type of syntactic construct. Edit 0 adds the parameters 'acting_user=acting_user, modified_user=user[0], modified_stream=stream[0]' to a RealmAuditLog.objects.filter() call for SUBSCRIPTION_CREATED events, and Edit 1 adds the exact same parameters with identical syntax to another RealmAuditLog.objects.filter() call for SUBSCRIPTION_DEACTIVATED events. This represents a bulk-edit pattern where the same before\u2192after transformation (adding the same filter parameters) is being applied to multiple similar filter calls within the same test method. Both edits are part of a single, contiguous refactor to add consistent filtering parameters to related audit log queries."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical structural substitution pattern on the same type of syntactic construct. Edit 0 adds the parameters 'acting_user=acting_user, modified_user=user[0], modified_stream=stream[0]' to a RealmAuditLog.objects.filter() call for SUBSCRIPTION_CREATED events, and Edit 1 adds the exact same parameters with identical syntax to another RealmAuditLog.objects.filter() call for SUBSCRIPTION_DEACTIVATED events. This represents a bulk-edit pattern where the same before\u2192after transformation (adding the same filter parameters) is being applied to multiple similar filter calls within the same test method. Both edits are part of a single, contiguous refactor to add consistent filtering parameters to related audit log queries."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 defines the variable 'acting_user' by assigning it the value 'self.example_user('iago')'. Edit 1 uses this exact same variable 'acting_user' as a parameter in the bulk_remove_subscriptions function call. The changed lines reference the exact same symbol - the 'acting_user' variable defined in edit 0 and used in edit 1. This creates an immediate code dependency where edit 0 must occur before edit 1, as edit 1 references a variable that doesn't exist until edit 0 defines it. However, since this is Python and variable references are resolved at runtime rather than parse time, both edits can be written and parsed in either order - edit 1 would only fail at runtime with a NameError if executed before edit 0. Therefore, this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step within the same micro-task."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 defines the variable 'acting_user' by assigning it the value 'self.example_user('iago')'. Edit 1 uses this exact same variable 'acting_user' as a parameter in the bulk_remove_subscriptions function call. The changed lines reference the exact same symbol - the 'acting_user' variable defined in edit 0 and used in edit 1. This creates an immediate code dependency where edit 0 must occur before edit 1, as edit 1 references a variable that doesn't exist until edit 0 defines it. However, since this is Python and variable references are resolved at runtime rather than parse time, both edits can be written and parsed in either order - edit 1 would only fail at runtime with a NameError if executed before edit 0. Therefore, this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step within the same micro-task."
        }
    ],
    "allowed_init_edits": [
        4,
        6
    ]
}