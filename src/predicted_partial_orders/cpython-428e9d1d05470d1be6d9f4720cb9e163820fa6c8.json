{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits add the exact same line 'req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT' to different locations within the same test method (test_redirect). This appears to be part of a uniform pattern where the same timeout assignment is being added to multiple request objects in the same test context. The edits involve identical code additions with the same structure and purpose, making them part of a synchronized bulk edit pattern within the same function scope."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits add the exact same line 'req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT' to different locations within the same test method (test_redirect). This appears to be part of a uniform pattern where the same timeout assignment is being added to multiple request objects in the same test context. The edits involve identical code additions with the same structure and purpose, making them part of a synchronized bulk edit pattern within the same function scope."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits add the exact same line 'req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT' to different locations within the same test method (test_redirect). This appears to be part of a uniform pattern where the same timeout assignment is being added to multiple request objects or locations within the test. The edits involve identical code additions with the same structure and purpose, making them part of a synchronized bulk edit pattern within the same test context."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits add the exact same line 'req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT' to different locations within the same test method (test_redirect). This appears to be part of a uniform pattern where the same timeout assignment is being added to multiple request objects or locations within the test. The edits involve identical code additions with the same structure and purpose, making them part of a synchronized bulk edit pattern within the same test context."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits add the exact same line 'req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT' to different Request objects within the same test method. This appears to be a uniform pattern application where the same attribute assignment is being added to multiple Request objects as part of a single refactoring task. The edits involve identical structural substitution (adding the same timeout assignment) to the same type of syntactic construct (Request object attribute assignment). Both edits can be applied in either order without any parsing or syntactic dependencies."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits add the exact same line 'req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT' to different Request objects within the same test method. This appears to be a uniform pattern application where the same attribute assignment is being added to multiple Request objects as part of a single refactoring task. The edits involve identical structural substitution (adding the same timeout assignment) to the same type of syntactic construct (Request object attribute assignment). Both edits can be applied in either order without any parsing or syntactic dependencies."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitution (adding 'req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT') at the same structural location within the same test method. They appear to be part of a bulk edit or pattern synchronization where the same line is being added to multiple similar code blocks within the same function. The edits target the same type of syntactic construct (assignment statements) with identical before\u2192after patterns, making this a clear case of synchronized additions within the same context."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitution (adding 'req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT') at the same structural location within the same test method. They appear to be part of a bulk edit or pattern synchronization where the same line is being added to multiple similar code blocks within the same function. The edits target the same type of syntactic construct (assignment statements) with identical before\u2192after patterns, making this a clear case of synchronized additions within the same context."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'req.timeout' - edit 0 sets this attribute on the request object, and edit 1 uses this attribute when calling parent.open(). The changed lines in both edits explicitly reference the same symbol. Edit 0 adds the timeout attribute to the request object, and edit 1 uses that timeout attribute in the redirect handler. This creates a direct code dependency where the timeout value set in the test flows through to the redirect handler's use of it. Both edits can be staged in either order since Python allows attribute assignment and access without parse-time errors."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'req.timeout' - edit 0 sets this attribute on the request object, and edit 1 uses this attribute when calling parent.open(). The changed lines in both edits explicitly reference the same symbol. Edit 0 adds the timeout attribute to the request object, and edit 1 uses that timeout attribute in the redirect handler. This creates a direct code dependency where the timeout value set in the test flows through to the redirect handler's use of it. Both edits can be staged in either order since Python allows attribute assignment and access without parse-time errors."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits add the exact same line 'req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT' to different Request objects within the same test method. This appears to be a bulk edit pattern where the same attribute assignment is being added to multiple Request objects in the same test context. The edits perform identical structural substitutions (adding the same timeout assignment) and target the same type of syntactic construct (attribute assignment to Request objects). This represents a synchronized pattern addition within the same test method context, making either edit naturally prompt for the other as part of the same contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits add the exact same line 'req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT' to different Request objects within the same test method. This appears to be a bulk edit pattern where the same attribute assignment is being added to multiple Request objects in the same test context. The edits perform identical structural substitutions (adding the same timeout assignment) and target the same type of syntactic construct (attribute assignment to Request objects). This represents a synchronized pattern addition within the same test method context, making either edit naturally prompt for the other as part of the same contiguous refactoring task."
        },
        {
            "src": 1,
            "tgt": 8,
            "reason": "Edit 0 adds a timeout attribute to a request object (req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT), while Edit 1 modifies a method call to use that timeout attribute (timeout=req.timeout). Both edits reference the exact same symbol 'req.timeout' - Edit 0 assigns to it and Edit 1 reads from it. This creates a direct code dependency where setting the timeout attribute in one edit enables its usage in the other edit. The relationship is bi-directional because either edit can be made first without causing parse errors, and making either edit creates an immediate, mechanically obvious prompt for the other as part of implementing timeout support across the urllib2 module."
        },
        {
            "src": 8,
            "tgt": 1,
            "reason": "Edit 0 adds a timeout attribute to a request object (req.timeout = socket._GLOBAL_DEFAULT_TIMEOUT), while Edit 1 modifies a method call to use that timeout attribute (timeout=req.timeout). Both edits reference the exact same symbol 'req.timeout' - Edit 0 assigns to it and Edit 1 reads from it. This creates a direct code dependency where setting the timeout attribute in one edit enables its usage in the other edit. The relationship is bi-directional because either edit can be made first without causing parse errors, and making either edit creates an immediate, mechanically obvious prompt for the other as part of implementing timeout support across the urllib2 module."
        },
        {
            "src": 5,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)' and 'self.parent.open(new)' to 'self.parent.open(new, timeout=req.timeout)'. This is a uniform bulk substitution adding the same timeout parameter to calls to the parent.open() method across different locations in the codebase. Both edits target the same type of syntactic construct (method calls to parent.open) and apply the same before\u2192after pattern as part of what appears to be a single refactoring operation to consistently add timeout handling."
        },
        {
            "src": 8,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)' and 'self.parent.open(new)' to 'self.parent.open(new, timeout=req.timeout)'. This is a uniform bulk substitution adding the same timeout parameter to calls to the parent.open() method across different locations in the codebase. Both edits target the same type of syntactic construct (method calls to parent.open) and apply the same before\u2192after pattern as part of what appears to be a single refactoring operation to consistently add timeout handling."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical structural substitution on the same type of syntactic construct. They both change calls to 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)' - adding the exact same parameter with the exact same value pattern. This represents a uniform, synchronized modification across multiple locations in the same codebase, applying the same before\u2192after pattern to the same method call structure. This is a clear case of bulk-edit synchronization where both edits are part of a single, contiguous refactor to add timeout parameter support to parent.open() calls."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution on the same type of syntactic construct. They both change calls to 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)' - adding the exact same parameter with the exact same value pattern. This represents a uniform, synchronized modification across multiple locations in the same codebase, applying the same before\u2192after pattern to the same method call structure. This is a clear case of bulk-edit synchronization where both edits are part of a single, contiguous refactor to add timeout parameter support to parent.open() calls."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)' and 'self.parent.open(new)' to 'self.parent.open(new, timeout=req.timeout)'. This is a uniform bulk edit applying the same before\u2192after pattern to the same type of syntactic construct (method calls to self.parent.open). Both edits are adding the same timeout parameter to method calls of the same parent method, representing a single contiguous refactor to consistently pass timeout parameters. Either edit can be made first, and after making either, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)' and 'self.parent.open(new)' to 'self.parent.open(new, timeout=req.timeout)'. This is a uniform bulk edit applying the same before\u2192after pattern to the same type of syntactic construct (method calls to self.parent.open). Both edits are adding the same timeout parameter to method calls of the same parent method, representing a single contiguous refactor to consistently pass timeout parameters. Either edit can be made first, and after making either, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)'. This is a uniform, synchronized modification applying the same before\u2192after pattern to the same type of syntactic construct (method calls to self.parent.open). Both edits are part of a single refactoring operation to add timeout parameter support to parent.open() calls across different authentication handler classes. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the codebase."
        },
        {
            "src": 8,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)'. This is a uniform, synchronized modification applying the same before\u2192after pattern to the same type of syntactic construct (method calls to self.parent.open). Both edits are part of a single refactoring operation to add timeout parameter support to parent.open() calls across different authentication handler classes. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the codebase."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)'. This is a uniform, synchronized modification applying the same before\u2192after pattern to the same type of syntactic construct (method calls to self.parent.open). Both edits are part of what appears to be a single refactoring operation to add timeout parameter support across multiple locations in the codebase. Either edit can be made first, and both represent the same mechanical change being applied consistently."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)'. This is a uniform, synchronized modification applying the same before\u2192after pattern to the same type of syntactic construct (method calls to self.parent.open). Both edits are part of what appears to be a single refactoring operation to add timeout parameter support across multiple locations in the codebase. Either edit can be made first, and both represent the same mechanical change being applied consistently."
        },
        {
            "src": 6,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)'. This is a uniform, synchronized modification applying the same before\u2192after pattern to the same type of syntactic construct (method calls to self.parent.open). Both edits are part of what appears to be a single refactoring operation to add timeout parameter support across multiple locations in the codebase. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 8,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'self.parent.open(req)' to 'self.parent.open(req, timeout=req.timeout)'. This is a uniform, synchronized modification applying the same before\u2192after pattern to the same type of syntactic construct (method calls to self.parent.open). Both edits are part of what appears to be a single refactoring operation to add timeout parameter support across multiple locations in the codebase. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}