{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution (changing 'hass.create_task(' to 'hass.async_create_task(') on the same type of syntactic construct (method calls on the hass object). This is a clear bulk-edit pattern where the same before\u2192after transformation is being applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update method calls, and either edit could be made first as they are independent substitutions of the same pattern."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution (changing 'hass.create_task(' to 'hass.async_create_task(') on the same type of syntactic construct (method calls on the hass object). This is a clear bulk-edit pattern where the same before\u2192after transformation is being applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update method calls, and either edit could be made first as they are independent substitutions of the same pattern."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' on the same type of syntactic construct (method calls on the hass object). This is a uniform refactoring pattern applied across multiple files, where both edits target the exact same method name change on the same object type. This represents a bulk-edit synchronization where the same before\u2192after pattern is applied to the same construct type across different locations."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' on the same type of syntactic construct (method calls on the hass object). This is a uniform refactoring pattern applied across multiple files, where both edits target the exact same method name change on the same object type. This represents a bulk-edit synchronization where the same before\u2192after pattern is applied to the same construct type across different locations."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across multiple locations. The edits target the same type of syntactic construct (method calls on the hass object) and apply the exact same before\u2192after transformation pattern. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single contiguous refactoring task."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across multiple locations. The edits target the same type of syntactic construct (method calls on the hass object) and apply the exact same before\u2192after transformation pattern. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single contiguous refactoring task."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across the codebase. Both changed lines reference the same method signature pattern on the same type of object (hass), making this a synchronized pattern substitution that would naturally occur as part of a single, contiguous refactoring sweep."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across the codebase. Both changed lines reference the same method signature pattern on the same type of object (hass), making this a synchronized pattern substitution that would naturally occur as part of a single, contiguous refactoring sweep."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across multiple locations. The edits target the same type of syntactic construct (method calls on the hass object) and apply the exact same before\u2192after transformation pattern. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single contiguous refactoring task."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across multiple locations. The edits target the same type of syntactic construct (method calls on the hass object) and apply the exact same before\u2192after transformation pattern. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single contiguous refactoring task."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in method calls. This is a uniform, synchronized refactor across multiple files targeting the same type of syntactic construct (method calls on the hass object). The edits represent a bulk substitution pattern where the same before\u2192after transformation is applied consistently across the codebase, making them part of a single contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in method calls. This is a uniform, synchronized refactor across multiple files targeting the same type of syntactic construct (method calls on the hass object). The edits represent a bulk substitution pattern where the same before\u2192after transformation is applied consistently across the codebase, making them part of a single contiguous refactoring task."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across multiple locations. The edits target the same type of syntactic construct (method calls on the hass object) and apply the exact same before\u2192after transformation pattern. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single contiguous refactoring task."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across multiple locations. The edits target the same type of syntactic construct (method calls on the hass object) and apply the exact same before\u2192after transformation pattern. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single contiguous refactoring task."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a uniform, synchronized multi-file refactoring operation where the same method call pattern is being updated across the codebase. The changed lines in both edits reference the exact same method call pattern on the same object type (hass), making this a bulk-edit synchronization pattern. Either edit could be made first as part of this refactoring sweep, and both represent the same mechanical substitution operation."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a uniform, synchronized multi-file refactoring operation where the same method call pattern is being updated across the codebase. The changed lines in both edits reference the exact same method call pattern on the same object type (hass), making this a bulk-edit synchronization pattern. Either edit could be made first as part of this refactoring sweep, and both represent the same mechanical substitution operation."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task(' to 'hass.async_create_task(' on the same type of syntactic construct (method calls on the hass object). This is a clear bulk-edit pattern where the same before\u2192after transformation is being applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update the method name consistently. Either edit could be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task(' to 'hass.async_create_task(' on the same type of syntactic construct (method calls on the hass object). This is a clear bulk-edit pattern where the same before\u2192after transformation is being applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update the method name consistently. Either edit could be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' on the same type of syntactic construct (method calls on hass objects). This is a clear bulk refactoring pattern where the same before\u2192after transformation is being applied uniformly across multiple files. The edits are part of a single, contiguous refactor to update the method name consistently throughout the codebase. Either edit could be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' on the same type of syntactic construct (method calls on hass objects). This is a clear bulk refactoring pattern where the same before\u2192after transformation is being applied uniformly across multiple files. The edits are part of a single, contiguous refactor to update the method name consistently throughout the codebase. Either edit could be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a uniform, synchronized refactoring operation targeting the same type of syntactic construct (method calls on the hass object). The edits are part of a single, contiguous refactor to update the API usage across the codebase. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a uniform, synchronized refactoring operation targeting the same type of syntactic construct (method calls on the hass object). The edits are part of a single, contiguous refactor to update the API usage across the codebase. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk uniform substitution pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (method calls on the hass object). Both changed lines reference the exact same method call pattern and would naturally be part of a single, contiguous refactor to update the deprecated create_task method to async_create_task across the codebase."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk uniform substitution pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (method calls on the hass object). Both changed lines reference the exact same method call pattern and would naturally be part of a single, contiguous refactor to update the deprecated create_task method to async_create_task across the codebase."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task(' to 'hass.async_create_task(' on the same type of syntactic construct (method calls on hass objects). This represents a bulk refactoring operation where the same API migration is being applied consistently across the codebase. The edits are part of a single, contiguous refactor to update deprecated method calls to their newer async equivalents. Either edit could be made first, and both follow the same mechanical substitution pattern."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task(' to 'hass.async_create_task(' on the same type of syntactic construct (method calls on hass objects). This represents a bulk refactoring operation where the same API migration is being applied consistently across the codebase. The edits are part of a single, contiguous refactor to update deprecated method calls to their newer async equivalents. Either edit could be made first, and both follow the same mechanical substitution pattern."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' on lines that call hass.services.async_call. This is a uniform refactoring pattern applied to the same type of syntactic construct (method calls on the hass object). The edits are part of a single, contiguous refactor to update the API usage across the codebase. Either edit could be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' on lines that call hass.services.async_call. This is a uniform refactoring pattern applied to the same type of syntactic construct (method calls on the hass object). The edits are part of a single, contiguous refactor to update the API usage across the codebase. Either edit could be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across the codebase. Both changed lines target the same type of syntactic construct (method calls on the hass object) and apply the exact same before\u2192after pattern. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single contiguous refactoring task."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across the codebase. Both changed lines target the same type of syntactic construct (method calls on the hass object) and apply the exact same before\u2192after pattern. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single contiguous refactoring task."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a uniform, synchronized multi-file refactoring operation where the same method call pattern is being updated across the codebase. Both changed lines target the same type of syntactic construct (method calls on the hass object) with the exact same before\u2192after pattern. This represents a bulk edit/pattern synchronization that would naturally occur as part of a single, contiguous refactoring sweep."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a uniform, synchronized multi-file refactoring operation where the same method call pattern is being updated across the codebase. Both changed lines target the same type of syntactic construct (method calls on the hass object) with the exact same before\u2192after pattern. This represents a bulk edit/pattern synchronization that would naturally occur as part of a single, contiguous refactoring sweep."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across multiple locations. The edits target the same type of syntactic construct (method calls on the hass object) and apply the exact same before\u2192after transformation pattern. This represents a uniform, synchronized multi-file substitution that would naturally be performed as part of a single contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution: changing 'hass.create_task(' to 'hass.async_create_task(' in different files. This is a bulk refactoring operation where the same method call pattern is being updated across multiple locations. The edits target the same type of syntactic construct (method calls on the hass object) and apply the exact same before\u2192after transformation pattern. This represents a uniform, synchronized multi-file substitution that would naturally be performed as part of a single contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task' to 'hass.async_create_task' on the same type of syntactic construct (method calls on the hass object). This is a clear bulk refactoring operation where the same before\u2192after pattern is being applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update the method name consistently. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task' to 'hass.async_create_task' on the same type of syntactic construct (method calls on the hass object). This is a clear bulk refactoring operation where the same before\u2192after pattern is being applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update the method name consistently. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task' to 'hass.async_create_task' on the same type of syntactic construct (method calls on the hass object). This is a bulk refactoring operation where the same before\u2192after pattern is applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update the method name consistently. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task' to 'hass.async_create_task' on the same type of syntactic construct (method calls on the hass object). This is a bulk refactoring operation where the same before\u2192after pattern is applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update the method name consistently. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task' to 'hass.async_create_task' on the same type of syntactic construct (method calls on the hass object). This is a clear bulk refactoring operation where the same before\u2192after pattern is being applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update the method name consistently. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task' to 'hass.async_create_task' on the same type of syntactic construct (method calls on the hass object). This is a clear bulk refactoring operation where the same before\u2192after pattern is being applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update the method name consistently. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task(' to 'hass.async_create_task(' on the same type of syntactic construct (method calls on the hass object). This is a clear bulk refactoring operation where the same before\u2192after pattern is being applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update the method name consistently. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'hass.create_task(' to 'hass.async_create_task(' on the same type of syntactic construct (method calls on the hass object). This is a clear bulk refactoring operation where the same before\u2192after pattern is being applied uniformly across multiple locations in the same file. The edits are part of a single, contiguous refactor to update the method name consistently. Either edit can be made first, and both represent the same mechanical substitution pattern."
        }
    ],
    "allowed_init_edits": [
        1,
        2,
        0,
        6,
        5,
        3,
        4
    ]
}