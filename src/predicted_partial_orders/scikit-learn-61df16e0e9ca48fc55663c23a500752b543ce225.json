{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform identical structural changes to the same class (RobustScaler) by removing the same conditional logic pattern and replacing it with the same simplified call to inplace_column_scale. The edits are part of a uniform refactoring that removes the X.shape[0] == 1 condition and axis == 0 checks in favor of always using inplace_column_scale. This represents a synchronized pattern substitution where both methods are being updated with the same before\u2192after transformation as part of a single refactoring task."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform identical structural changes to the same class (RobustScaler) by removing the same conditional logic pattern and replacing it with the same simplified call to inplace_column_scale. The edits are part of a uniform refactoring that removes the X.shape[0] == 1 condition and axis == 0 checks in favor of always using inplace_column_scale. This represents a synchronized pattern substitution where both methods are being updated with the same before\u2192after transformation as part of a single refactoring task."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 removes 'inplace_row_scale' from an import statement, while Edit 1 removes the usage of 'inplace_row_scale' function and simplifies the scaling logic. These edits reference the exact same symbol 'inplace_row_scale' - one removes it from the import and the other removes its usage. After removing the usage in Edit 1, the import in Edit 0 becomes unnecessary and should be removed. Conversely, if the import is removed first in Edit 0, the usage in Edit 1 would cause a NameError at runtime (but not a parse error in Python). Since both edits can be parsed and staged in either order, and both reference the same symbol with one creating an immediate prompt for the other, this is bi-directional."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 removes 'inplace_row_scale' from an import statement, while Edit 1 removes the usage of 'inplace_row_scale' function and simplifies the scaling logic. These edits reference the exact same symbol 'inplace_row_scale' - one removes it from the import and the other removes its usage. After removing the usage in Edit 1, the import in Edit 0 becomes unnecessary and should be removed. Conversely, if the import is removed first in Edit 0, the usage in Edit 1 would cause a NameError at runtime (but not a parse error in Python). Since both edits can be parsed and staged in either order, and both reference the same symbol with one creating an immediate prompt for the other, this is bi-directional."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 removes 'inplace_row_scale' from an import statement, while Edit 1 removes the usage of 'inplace_row_scale' function and simplifies the scaling logic. Both edits reference the exact same symbol 'inplace_row_scale' - Edit 0 removes it from the import, and Edit 1 removes its usage. This creates a direct code dependency where removing the usage (Edit 1) makes the import unnecessary (Edit 0), or vice versa. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step in removing this unused function."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 removes 'inplace_row_scale' from an import statement, while Edit 1 removes the usage of 'inplace_row_scale' function and simplifies the scaling logic. Both edits reference the exact same symbol 'inplace_row_scale' - Edit 0 removes it from the import, and Edit 1 removes its usage. This creates a direct code dependency where removing the usage (Edit 1) makes the import unnecessary (Edit 0), or vice versa. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step in removing this unused function."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: converting triple-quoted docstrings to single-line comments. Edit 0 changes '\"\"\"Check MaxAbsScaler on toy data with a large negative value\"\"\"' to '# Check MaxAbsScaler on toy data with a large negative value', and edit 1 changes '\"\"\"Check MaxAbsScaler on transforming csr matrix with one row\"\"\"' to '# Check MaxAbsScaler on transforming csr matrix with one row'. This is a uniform bulk substitution where both edits apply the same before\u2192after pattern (docstring \u2192 comment) to the same type of syntactic construct (function documentation). Both edits would naturally occur as part of a single, contiguous refactoring operation to standardize documentation format across test functions."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: converting triple-quoted docstrings to single-line comments. Edit 0 changes '\"\"\"Check MaxAbsScaler on toy data with a large negative value\"\"\"' to '# Check MaxAbsScaler on toy data with a large negative value', and edit 1 changes '\"\"\"Check MaxAbsScaler on transforming csr matrix with one row\"\"\"' to '# Check MaxAbsScaler on transforming csr matrix with one row'. This is a uniform bulk substitution where both edits apply the same before\u2192after pattern (docstring \u2192 comment) to the same type of syntactic construct (function documentation). Both edits would naturally occur as part of a single, contiguous refactoring operation to standardize documentation format across test functions."
        }
    ],
    "allowed_init_edits": [
        3,
        4,
        7
    ]
}