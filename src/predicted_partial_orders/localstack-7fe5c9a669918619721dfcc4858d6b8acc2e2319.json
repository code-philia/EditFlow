{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds a check `if self.contains(port): return` to the `add` method of `PortMappings` class to prevent duplicate port additions. Edit 1 adds a test method `test_overlapping_port_ranges` that specifically tests the behavior of adding duplicate ports (line 70: `port_mappings.add(4593)` is called twice) and verifies the resulting string format. The test directly exercises the exact code path that edit 0 modifies - the duplicate port handling logic. Both edits reference the same `PortMappings.add` method, with edit 1 testing the specific functionality that edit 0 implements. This creates a bi-directional relationship where either edit could prompt the other as the next logical step in the same development session."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds a check `if self.contains(port): return` to the `add` method of `PortMappings` class to prevent duplicate port additions. Edit 1 adds a test method `test_overlapping_port_ranges` that specifically tests the behavior of adding duplicate ports (line 70: `port_mappings.add(4593)` is called twice) and verifies the resulting string format. The test directly exercises the exact code path that edit 0 modifies - the duplicate port handling logic. Both edits reference the same `PortMappings.add` method, with edit 1 testing the specific functionality that edit 0 implements. This creates a bi-directional relationship where either edit could prompt the other as the next logical step in the same development session."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 1 defines a new method 'contains' in the PortMappings class, and Edit 0 calls this exact same method with 'self.contains(port)'. The changed lines reference the exact same symbol - the 'contains' method of the PortMappings class. After defining the method in Edit 1, calling it in Edit 0 becomes the immediate next step, and vice versa - after adding the call in Edit 0, defining the method becomes immediately necessary. Both edits can be written and parsed in either order (the call would just result in a runtime AttributeError if the method doesn't exist yet), making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 1 defines a new method 'contains' in the PortMappings class, and Edit 0 calls this exact same method with 'self.contains(port)'. The changed lines reference the exact same symbol - the 'contains' method of the PortMappings class. After defining the method in Edit 1, calling it in Edit 0 becomes the immediate next step, and vice versa - after adding the call in Edit 0, defining the method becomes immediately necessary. Both edits can be written and parsed in either order (the call would just result in a runtime AttributeError if the method doesn't exist yet), making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 imports the threading module, and Edit 1 uses threading.RLock() in the changed lines. This is a classic import-usage pattern where the exact same symbol 'threading' is being imported in one edit and referenced in another edit within the same file. After importing threading in Edit 0, using threading.RLock() in Edit 1 becomes the natural next step. Both edits reference the exact same symbol and either could be staged first in Python (import before usage would work, and usage before import would only cause a runtime NameError, not a parse error)."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 imports the threading module, and Edit 1 uses threading.RLock() in the changed lines. This is a classic import-usage pattern where the exact same symbol 'threading' is being imported in one edit and referenced in another edit within the same file. After importing threading in Edit 0, using threading.RLock() in Edit 1 becomes the natural next step. Both edits reference the exact same symbol and either could be staged first in Python (import before usage would work, and usage before import would only cause a runtime NameError, not a parse error)."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 defines two global variables SSL_CONTEXTS and SSL_LOCK, while Edit 1 uses these exact same symbols in its implementation. The changed lines in Edit 1 explicitly reference SSL_LOCK (line 58) and SSL_CONTEXTS (lines 60, 61, 62) that are defined in Edit 0. This creates a direct definition-usage relationship where both edits reference the exact same symbols. Since this is Python, both edits can be parsed and staged in either order (usage before definition only causes runtime NameError, not parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 defines two global variables SSL_CONTEXTS and SSL_LOCK, while Edit 1 uses these exact same symbols in its implementation. The changed lines in Edit 1 explicitly reference SSL_LOCK (line 58) and SSL_CONTEXTS (lines 60, 61, 62) that are defined in Edit 0. This creates a direct definition-usage relationship where both edits reference the exact same symbols. Since this is Python, both edits can be parsed and staged in either order (usage before definition only causes runtime NameError, not parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        }
    ],
    "allowed_init_edits": [
        5,
        1,
        2,
        4
    ]
}