{
    "partial_orders": [
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits are adding parameters to the same test method. Edit 0 adds a pytest.mark.parametrize decorator that defines parameters 'file_path' and 'should_except', while Edit 1 adds these exact same parameter names to the test method signature. This creates a direct code dependency where the parametrize decorator provides values that must be received by the test method parameters. The changed lines reference the exact same symbols (file_path and should_except parameters), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits are adding parameters to the same test method. Edit 0 adds a pytest.mark.parametrize decorator that defines parameters 'file_path' and 'should_except', while Edit 1 adds these exact same parameter names to the test method signature. This creates a direct code dependency where the parametrize decorator provides values that must be received by the test method parameters. The changed lines reference the exact same symbols (file_path and should_except parameters), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 imports AirflowException and edit 1 uses AirflowException in a pytest.raises() call. The changed lines reference the exact same symbol - AirflowException. After importing AirflowException in edit 0, edit 1 becomes the immediate next step to use that imported symbol. This is a classic import-usage pattern within the same file where both edits reference the same symbol."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 imports AirflowException and edit 1 uses AirflowException in a pytest.raises() call. The changed lines reference the exact same symbol - AirflowException. After importing AirflowException in edit 0, edit 1 becomes the immediate next step to use that imported symbol. This is a classic import-usage pattern within the same file where both edits reference the same symbol."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbol 'should_except' within the same test method. Edit 0 adds 'should_except' as a parameter to the test function signature, and Edit 1 uses that same parameter in a conditional statement within the function body. This creates a direct definition-usage relationship where the parameter defined in the signature is immediately referenced in the function implementation. Both edits can be staged in either order without causing parse errors (the usage before definition would only cause a runtime NameError in Python), making this a bi-directional relationship."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'should_except' within the same test method. Edit 0 adds 'should_except' as a parameter to the test function signature, and Edit 1 uses that same parameter in a conditional statement within the function body. This creates a direct definition-usage relationship where the parameter defined in the signature is immediately referenced in the function implementation. Both edits can be staged in either order without causing parse errors (the usage before definition would only cause a runtime NameError in Python), making this a bi-directional relationship."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits modify code that uses the same `file_url` variable within the same method execution flow. Edit 0 adds a security check to validate the URL scheme before it's used, while Edit 1 adds a `# nosec` comment to suppress security warnings when opening the URL. The security check in Edit 0 creates an immediate code-driven prompt for Edit 1 - after adding validation to prevent local file access, the next logical step is to acknowledge that the remaining urllib.request.urlopen usage is intentionally allowed by adding the nosec comment. Both edits reference the exact same `file_url` symbol and are part of a single security-focused micro-task."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'file_path' within the same test function. Edit 0 adds 'file_path' as a parameter to the test method signature, and Edit 1 uses that same 'file_path' parameter in the test body by replacing a hardcoded string with the parameter reference. This creates a direct definition-usage relationship where the parameter defined in Edit 0 is immediately used in Edit 1. Since this is Python, both edits can be written and parsed in either order (the parameter reference in the body won't cause a syntax error even if the parameter isn't in the signature yet - it would only cause a runtime NameError when executed). This makes it a bi-directional relationship where either edit naturally prompts the other as the next mechanical step in the same micro-task of parameterizing the test."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'file_path' within the same test function. Edit 0 adds 'file_path' as a parameter to the test method signature, and Edit 1 uses that same 'file_path' parameter in the test body by replacing a hardcoded string with the parameter reference. This creates a direct definition-usage relationship where the parameter defined in Edit 0 is immediately used in Edit 1. Since this is Python, both edits can be written and parsed in either order (the parameter reference in the body won't cause a syntax error even if the parameter isn't in the signature yet - it would only cause a runtime NameError when executed). This makes it a bi-directional relationship where either edit naturally prompts the other as the next mechanical step in the same micro-task of parameterizing the test."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 adds a pytest parametrize decorator that introduces a 'file_path' parameter with test values. Edit 1 uses this 'file_path' parameter in the test method body by replacing a hardcoded 'TEST' value with the parameterized 'file_path' variable. The changed lines reference the exact same symbol (file_path parameter), creating a direct code dependency where the parametrize decorator provides the value that is consumed in the test body. This is a classic definition-usage pattern within the same test function context."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 adds a pytest parametrize decorator that introduces a 'file_path' parameter with test values. Edit 1 uses this 'file_path' parameter in the test method body by replacing a hardcoded 'TEST' value with the parameterized 'file_path' variable. The changed lines reference the exact same symbol (file_path parameter), creating a direct code dependency where the parametrize decorator provides the value that is consumed in the test body. This is a classic definition-usage pattern within the same test function context."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "These edits are part of a synchronized test modification within the same test method. Edit 0 adds a pytest parametrize decorator that introduces the 'should_except' parameter with test cases, and Edit 1 uses that exact same 'should_except' parameter in the test logic to conditionally expect an exception. The changed lines reference the same symbol ('should_except') and both edits are mechanically linked - adding the parametrize decorator creates an immediate need to use the parameter in the test body, and using the parameter requires it to be defined in the parametrize decorator. This is a bi-directional relationship where either edit naturally prompts the other as the next contiguous action within the same micro-task of modifying the test method."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "These edits are part of a synchronized test modification within the same test method. Edit 0 adds a pytest parametrize decorator that introduces the 'should_except' parameter with test cases, and Edit 1 uses that exact same 'should_except' parameter in the test logic to conditionally expect an exception. The changed lines reference the same symbol ('should_except') and both edits are mechanically linked - adding the parametrize decorator creates an immediate need to use the parameter in the test body, and using the parameter requires it to be defined in the parametrize decorator. This is a bi-directional relationship where either edit naturally prompts the other as the next contiguous action within the same micro-task of modifying the test method."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}