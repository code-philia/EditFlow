{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the exact same syntactic construct and transformation, making this a clear case of bulk-edit pattern synchronization that would naturally occur in a single contiguous refactoring session."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the exact same syntactic construct and transformation, making this a clear case of bulk-edit pattern synchronization that would naturally occur in a single contiguous refactoring session."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.train_crop_size)' to '[int(sz) for sz in FLAGS.train_crop_size]' in the same file. This is a uniform refactoring operation replacing map() calls with list comprehensions for the exact same expression (FLAGS.train_crop_size). Both edits target the same type of syntactic construct (function call arguments) and apply the identical before\u2192after transformation pattern. This represents a bulk-edit synchronization where both changes would naturally occur as part of a single, contiguous refactoring sweep."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.train_crop_size)' to '[int(sz) for sz in FLAGS.train_crop_size]' in the same file. This is a uniform refactoring operation replacing map() calls with list comprehensions for the exact same expression (FLAGS.train_crop_size). Both edits target the same type of syntactic construct (function call arguments) and apply the identical before\u2192after transformation pattern. This represents a bulk-edit synchronization where both changes would naturally occur as part of a single, contiguous refactoring sweep."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the exact same syntactic construct and transformation, making this a clear case of bulk-edit synchronization that would naturally occur in a single, contiguous refactoring session."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the exact same syntactic construct and transformation, making this a clear case of bulk-edit synchronization that would naturally occur in a single, contiguous refactoring session."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring that replaces the map() function with a list comprehension across multiple files. Both edits target the same type of syntactic construct (parameter assignment in function calls) and apply the exact same before\u2192after transformation pattern. This represents a bulk edit/pattern synchronization where both changes would naturally occur as part of a single, contiguous refactoring sweep to modernize the codebase from map() to list comprehensions."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring that replaces the map() function with a list comprehension across multiple files. Both edits target the same type of syntactic construct (parameter assignment in function calls) and apply the exact same before\u2192after transformation pattern. This represents a bulk edit/pattern synchronization where both changes would naturally occur as part of a single, contiguous refactoring sweep to modernize the codebase from map() to list comprehensions."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.eval_crop_size)' to '[int(sz) for sz in FLAGS.eval_crop_size]'. This is a uniform refactoring operation that replaces the same construct (map function call) with the same alternative (list comprehension) in two different locations within the same file. Both changed lines reference the exact same symbol 'FLAGS.eval_crop_size' and apply the identical transformation pattern. This represents a bulk edit where either change could be made first, and after making one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.eval_crop_size)' to '[int(sz) for sz in FLAGS.eval_crop_size]'. This is a uniform refactoring operation that replaces the same construct (map function call) with the same alternative (list comprehension) in two different locations within the same file. Both changed lines reference the exact same symbol 'FLAGS.eval_crop_size' and apply the identical transformation pattern. This represents a bulk edit where either change could be made first, and after making one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across different files, replacing the same construct type (function call with map) with the same alternative pattern (list comprehension). Both changed lines target the same syntactic construct and apply the identical before\u2192after transformation pattern. This represents a bulk-edit synchronization where both edits are part of a single, contiguous refactor to modernize Python code style."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across different files, replacing the same construct type (function call with map) with the same alternative pattern (list comprehension). Both changed lines target the same syntactic construct and apply the identical before\u2192after transformation pattern. This represents a bulk-edit synchronization where both edits are part of a single, contiguous refactor to modernize Python code style."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the same syntactic construct (crop_size parameter assignments) and apply the identical transformation from map() to list comprehension. This represents a single, contiguous refactoring operation where both changes would naturally occur together as part of the same micro-task."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the same syntactic construct (crop_size parameter assignments) and apply the identical transformation from map() to list comprehension. This represents a single, contiguous refactoring operation where both changes would naturally occur together as part of the same micro-task."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the same syntactic construct (crop_size parameter assignments in ModelOptions calls) and appear to be part of a single, contiguous refactor to modernize Python 2 map() usage to list comprehensions. This fits the bulk-edit pattern synchronization criteria."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the same syntactic construct (crop_size parameter assignments in ModelOptions calls) and appear to be part of a single, contiguous refactor to modernize Python 2 map() usage to list comprehensions. This fits the bulk-edit pattern synchronization criteria."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across different files, replacing the same syntactic construct (map function call) with the same alternative construct (list comprehension) for the same purpose. Both edits target the exact same type of syntactic construct and apply the identical before\u2192after transformation pattern. This represents a bulk-edit synchronization where both changes would naturally occur as part of a single, contiguous refactoring sweep to modernize Python 2 map() usage to Python 3 list comprehensions."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across different files, replacing the same syntactic construct (map function call) with the same alternative construct (list comprehension) for the same purpose. Both edits target the exact same type of syntactic construct and apply the identical before\u2192after transformation pattern. This represents a bulk-edit synchronization where both changes would naturally occur as part of a single, contiguous refactoring sweep to modernize Python 2 map() usage to Python 3 list comprehensions."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across two different files, replacing the same syntactic construct (map function call) with the same alternative construct (list comprehension) in both locations. The edits target the same type of syntactic construct and apply the identical before\u2192after transformation pattern. This represents a bulk-edit synchronization where both changes would naturally occur as part of a single, contiguous refactoring sweep to modernize the codebase from map() to list comprehensions."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across two different files, replacing the same syntactic construct (map function call) with the same alternative construct (list comprehension) in both locations. The edits target the same type of syntactic construct and apply the identical before\u2192after transformation pattern. This represents a bulk-edit synchronization where both changes would naturally occur as part of a single, contiguous refactoring sweep to modernize the codebase from map() to list comprehensions."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same syntactic construct (map function call) with the same alternative construct (list comprehension) in the same structural context (crop_size parameter in ModelOptions calls). The edits target the same type of syntactic construct and apply the identical before\u2192after transformation pattern, making this a clear case of bulk-edit synchronization that would naturally occur in a single contiguous refactoring session."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same syntactic construct (map function call) with the same alternative construct (list comprehension) in the same structural context (crop_size parameter in ModelOptions calls). The edits target the same type of syntactic construct and apply the identical before\u2192after transformation pattern, making this a clear case of bulk-edit synchronization that would naturally occur in a single contiguous refactoring session."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring that replaces the map() function with a list comprehension across multiple files. Both edits target the same type of syntactic construct (function call arguments) and apply the exact same before\u2192after transformation pattern. This represents a bulk edit/pattern synchronization where both changes would naturally occur as part of a single, contiguous refactoring sweep to modernize the codebase from map() to list comprehensions."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring that replaces the map() function with a list comprehension across multiple files. Both edits target the same type of syntactic construct (function call arguments) and apply the exact same before\u2192after transformation pattern. This represents a bulk edit/pattern synchronization where both changes would naturally occur as part of a single, contiguous refactoring sweep to modernize the codebase from map() to list comprehensions."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the exact same syntactic construct (crop_size parameter assignment in ModelOptions calls) and apply the identical transformation. This represents a bulk edit/pattern synchronization that would naturally occur as part of a single, contiguous refactoring sweep to modernize Python 2 map() usage to list comprehensions."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the exact same syntactic construct (crop_size parameter assignment in ModelOptions calls) and apply the identical transformation. This represents a bulk edit/pattern synchronization that would naturally occur as part of a single, contiguous refactoring sweep to modernize Python 2 map() usage to list comprehensions."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the exact same syntactic pattern and transformation, making this a clear case of bulk-edit synchronization where both changes would naturally occur in a single, contiguous refactoring sweep."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.*_crop_size)' to '[int(sz) for sz in FLAGS.*_crop_size]'. This is a uniform refactoring across multiple files, replacing the same construct type (function call expressions) with the same before\u2192after pattern. Both edits target the exact same syntactic pattern and transformation, making this a clear case of bulk-edit synchronization where both changes would naturally occur in a single, contiguous refactoring sweep."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.vis_crop_size)' to '[int(sz) for sz in FLAGS.vis_crop_size]'. This is a uniform refactoring operation that replaces the same construct (map function call) with the same alternative (list comprehension) in two different locations within the same file. Both changed lines reference the exact same symbol 'FLAGS.vis_crop_size' and apply the identical transformation pattern. This represents a bulk edit/pattern synchronization where both edits are part of a single, contiguous refactor to modernize Python 2 map() usage to Python 3 list comprehensions."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'map(int, FLAGS.vis_crop_size)' to '[int(sz) for sz in FLAGS.vis_crop_size]'. This is a uniform refactoring operation that replaces the same construct (map function call) with the same alternative (list comprehension) in two different locations within the same file. Both changed lines reference the exact same symbol 'FLAGS.vis_crop_size' and apply the identical transformation pattern. This represents a bulk edit/pattern synchronization where both edits are part of a single, contiguous refactor to modernize Python 2 map() usage to Python 3 list comprehensions."
        }
    ],
    "allowed_init_edits": [
        2,
        4,
        3,
        1,
        0,
        5
    ]
}