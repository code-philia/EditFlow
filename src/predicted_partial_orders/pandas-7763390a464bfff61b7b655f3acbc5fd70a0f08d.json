{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(X.__doc__)' to '@doc(X)' on decorator lines. This is a uniform refactoring pattern applied to the same type of syntactic construct (method decorators) across different files. Both edits are part of the same bulk substitution operation to modernize decorator usage, making them mechanically linked as part of a single, contiguous refactor sweep."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(X.__doc__)' to '@doc(X)' on decorator lines. This is a uniform refactoring pattern applied to the same type of syntactic construct (method decorators) across different files. Both edits are part of the same bulk substitution operation to modernize decorator usage, making them mechanically linked as part of a single, contiguous refactor sweep."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits are part of a uniform substitution pattern replacing '@Appender' decorator with '@doc' decorator across the codebase. Edit 0 changes the decorator usage from '@Appender(ExtensionArray.searchsorted.__doc__)' to '@doc(ExtensionArray.searchsorted)', while Edit 1 updates the import statement to replace 'Appender' with 'doc' in the import list. Both edits involve the exact same symbols ('Appender' being removed, 'doc' being added) and represent identical before\u2192after patterns on the same type of syntactic constructs (decorator usage and import statements). This is a synchronized refactoring operation where both changes are part of the same contiguous micro-task."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits are part of a uniform substitution pattern replacing '@Appender' decorator with '@doc' decorator across the codebase. Edit 0 changes the decorator usage from '@Appender(ExtensionArray.searchsorted.__doc__)' to '@doc(ExtensionArray.searchsorted)', while Edit 1 updates the import statement to replace 'Appender' with 'doc' in the import list. Both edits involve the exact same symbols ('Appender' being removed, 'doc' being added) and represent identical before\u2192after patterns on the same type of syntactic constructs (decorator usage and import statements). This is a synchronized refactoring operation where both changes are part of the same contiguous micro-task."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol being changed from 'Appender' to 'doc'. Edit 0 changes the import statement to import 'doc' instead of 'Appender', and Edit 1 changes the usage of the decorator from '@Appender' to '@doc'. These edits reference the same symbol and create a direct code dependency - after making either edit, the other becomes the immediate next step to maintain code consistency. The import change and usage change are mechanically linked through the exact same symbol."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol being changed from 'Appender' to 'doc'. Edit 0 changes the import statement to import 'doc' instead of 'Appender', and Edit 1 changes the usage of the decorator from '@Appender' to '@doc'. These edits reference the same symbol and create a direct code dependency - after making either edit, the other becomes the immediate next step to maintain code consistency. The import change and usage change are mechanically linked through the exact same symbol."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(X.__doc__)' to '@doc(X)' where X is a class method. This is a uniform refactoring pattern applied to the same type of syntactic construct (decorator lines). Both edits are part of what appears to be a single, contiguous refactor to standardize decorator usage across the codebase. The substitution pattern is mechanically identical and targets the same construct type, making either edit naturally prompt the other as part of the same refactoring sweep."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(X.__doc__)' to '@doc(X)' where X is a class method. This is a uniform refactoring pattern applied to the same type of syntactic construct (decorator lines). Both edits are part of what appears to be a single, contiguous refactor to standardize decorator usage across the codebase. The substitution pattern is mechanically identical and targets the same construct type, making either edit naturally prompt the other as part of the same refactoring sweep."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(X.__doc__)' to '@doc(X)' where X is a parent class method. This is a uniform refactoring pattern applied to the same type of syntactic construct (decorator lines) across different files. Both edits are part of the same bulk refactoring operation to standardize decorator usage, making them bi-directional neighbours as either edit naturally prompts the continuation of the same substitution pattern."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(X.__doc__)' to '@doc(X)' where X is a parent class method. This is a uniform refactoring pattern applied to the same type of syntactic construct (decorator lines) across different files. Both edits are part of the same bulk refactoring operation to standardize decorator usage, making them bi-directional neighbours as either edit naturally prompts the continuation of the same substitution pattern."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Appender' to 'doc' in decorator usage. Edit 0 changes the import statement from 'from pandas.util._decorators import Appender' to 'from pandas.util._decorators import doc', while Edit 1 changes the decorator usage from '@Appender(Index.astype.__doc__)' to '@doc(Index.astype)'. This represents a bulk refactoring operation where the same symbol substitution is being applied across multiple files - the import change and the usage change are part of the same synchronized refactoring task. Both edits reference the exact same symbol being renamed (Appender \u2192 doc) and represent a uniform substitution pattern across the same type of syntactic construct (decorator-related code)."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Appender' to 'doc' in decorator usage. Edit 0 changes the import statement from 'from pandas.util._decorators import Appender' to 'from pandas.util._decorators import doc', while Edit 1 changes the decorator usage from '@Appender(Index.astype.__doc__)' to '@doc(Index.astype)'. This represents a bulk refactoring operation where the same symbol substitution is being applied across multiple files - the import change and the usage change are part of the same synchronized refactoring task. Both edits reference the exact same symbol being renamed (Appender \u2192 doc) and represent a uniform substitution pattern across the same type of syntactic construct (decorator-related code)."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Appender' to 'doc' in decorator usage. Edit 0 changes the import statement from 'from pandas.util._decorators import Appender' to 'from pandas.util._decorators import doc', while Edit 1 changes the decorator usage from '@Appender(Index.map.__doc__)' to '@doc(Index.map)'. This represents a bulk refactoring operation where the same symbol ('Appender' \u2192 'doc') is being replaced across multiple files as part of a single, contiguous refactor. Both edits target the same type of syntactic construct (decorator-related code) and follow the same before\u2192after pattern, making them part of a synchronized multi-file substitution."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Appender' to 'doc' in decorator usage. Edit 0 changes the import statement from 'from pandas.util._decorators import Appender' to 'from pandas.util._decorators import doc', while Edit 1 changes the decorator usage from '@Appender(Index.map.__doc__)' to '@doc(Index.map)'. This represents a bulk refactoring operation where the same symbol ('Appender' \u2192 'doc') is being replaced across multiple files as part of a single, contiguous refactor. Both edits target the same type of syntactic construct (decorator-related code) and follow the same before\u2192after pattern, making them part of a synchronized multi-file substitution."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'Appender' with 'doc' in import statements from 'pandas.util._decorators'. This is a bulk refactoring operation where the same symbol substitution is being applied across multiple files to the same type of syntactic construct (import statements). The edits are part of a single, contiguous refactor operation and either can be staged first as they are independent changes to different files performing the same substitution pattern."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'Appender' with 'doc' in import statements from 'pandas.util._decorators'. This is a bulk refactoring operation where the same symbol substitution is being applied across multiple files to the same type of syntactic construct (import statements). The edits are part of a single, contiguous refactor operation and either can be staged first as they are independent changes to different files performing the same substitution pattern."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(X.__doc__)' to '@doc(X)' where X is a method reference. This is a uniform refactoring pattern applied to the same type of syntactic construct (decorator lines). Both edits are part of what appears to be a single, contiguous refactor to standardize decorator usage across the codebase. The substitution pattern is mechanically identical and targets the same construct type, making either edit naturally prompt the other as part of the same refactoring sweep."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(X.__doc__)' to '@doc(X)' where X is a method reference. This is a uniform refactoring pattern applied to the same type of syntactic construct (decorator lines). Both edits are part of what appears to be a single, contiguous refactor to standardize decorator usage across the codebase. The substitution pattern is mechanically identical and targets the same construct type, making either edit naturally prompt the other as part of the same refactoring sweep."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(Index.method.__doc__)' to '@doc(Index.method)' on decorator lines. This is a uniform refactoring operation targeting the same type of syntactic construct (method decorators) within the same class. Both edits are part of a single, contiguous refactor to standardize decorator usage. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform pattern substitution."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(Index.method.__doc__)' to '@doc(Index.method)' on decorator lines. This is a uniform refactoring operation targeting the same type of syntactic construct (method decorators) within the same class. Both edits are part of a single, contiguous refactor to standardize decorator usage. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform pattern substitution."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol change: replacing 'Appender' with 'doc' from pandas.util._decorators. Edit 0 changes the import statement to remove 'Appender' and add 'doc', while Edit 1 changes the decorator usage from '@Appender' to '@doc'. These edits are part of a single refactoring operation where the same symbol substitution is being applied consistently. After making either edit, the other becomes the immediate next step to maintain code consistency - if you change the import without updating the usage, you get a NameError, and if you change the usage without updating the import, you also get a NameError. Both edits can be staged in either order (both would parse successfully), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol change: replacing 'Appender' with 'doc' from pandas.util._decorators. Edit 0 changes the import statement to remove 'Appender' and add 'doc', while Edit 1 changes the decorator usage from '@Appender' to '@doc'. These edits are part of a single refactoring operation where the same symbol substitution is being applied consistently. After making either edit, the other becomes the immediate next step to maintain code consistency - if you change the import without updating the usage, you get a NameError, and if you change the usage without updating the import, you also get a NameError. Both edits can be staged in either order (both would parse successfully), making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(Index.method.__doc__)' to '@doc(Index.method)' on decorator lines. This is a uniform refactoring operation targeting the same type of syntactic construct (method decorators) within the same class. Both edits are part of a single, contiguous refactor to standardize decorator usage. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform pattern substitution."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(Index.method.__doc__)' to '@doc(Index.method)' on decorator lines. This is a uniform refactoring operation targeting the same type of syntactic construct (method decorators) within the same class. Both edits are part of a single, contiguous refactor to standardize decorator usage. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform pattern substitution."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(Index.method.__doc__)' to '@doc(Index.method)' on decorator lines. This is a uniform refactoring operation targeting the same type of syntactic construct (method decorators) within the same class. The edits are part of a single, contiguous refactor to standardize decorator usage. Either edit can be made first, and both follow the exact same before\u2192after pattern on the same construct type."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(Index.method.__doc__)' to '@doc(Index.method)' on decorator lines. This is a uniform refactoring operation targeting the same type of syntactic construct (method decorators) within the same class. The edits are part of a single, contiguous refactor to standardize decorator usage. Either edit can be made first, and both follow the exact same before\u2192after pattern on the same construct type."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol change: replacing 'Appender' with 'doc' from pandas.util._decorators. Edit 0 changes the import statement to remove 'Appender' and add 'doc', while Edit 1 changes the usage of '@Appender' to '@doc' in the decorator. These edits are part of a single refactoring operation where the same symbol substitution is being applied consistently. After making either edit, the other becomes the immediate next step to maintain code consistency - if you change the import without updating the usage, you get a NameError, and if you change the usage without updating the import, you also get a NameError. Both edits can be staged in either order (both are syntactically valid), but they form a natural pair where one mechanically prompts the other."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol change: replacing 'Appender' with 'doc' from pandas.util._decorators. Edit 0 changes the import statement to remove 'Appender' and add 'doc', while Edit 1 changes the usage of '@Appender' to '@doc' in the decorator. These edits are part of a single refactoring operation where the same symbol substitution is being applied consistently. After making either edit, the other becomes the immediate next step to maintain code consistency - if you change the import without updating the usage, you get a NameError, and if you change the usage without updating the import, you also get a NameError. Both edits can be staged in either order (both are syntactically valid), but they form a natural pair where one mechanically prompts the other."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing '@Appender(Index.{method}.__doc__)' with '@doc(Index.{method})' on decorator lines. This is a uniform refactoring operation targeting the same type of syntactic construct (method decorators) within the same class. The edits are part of a single, contiguous refactor to change the documentation decorator pattern across multiple methods. Either edit can be made first, and both represent the same mechanical substitution being applied consistently."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: replacing '@Appender(Index.{method}.__doc__)' with '@doc(Index.{method})' on decorator lines. This is a uniform refactoring operation targeting the same type of syntactic construct (method decorators) within the same class. The edits are part of a single, contiguous refactor to change the documentation decorator pattern across multiple methods. Either edit can be made first, and both represent the same mechanical substitution being applied consistently."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol change: replacing 'Appender' with 'doc' from pandas.util._decorators. Edit 0 changes the import statement to remove 'Appender' and add 'doc', while Edit 1 changes the usage of '@Appender' to '@doc' as a decorator. These edits are part of a single refactoring operation where the same symbol substitution (Appender \u2192 doc) is being applied consistently. After making either edit, the other becomes the immediate next step to maintain code consistency - if you change the import without updating the usage, you get a NameError at runtime, and if you change the usage without updating the import, you also get a NameError. Both edits can be staged in either order since Python allows referencing undefined names at parse time (they only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol change: replacing 'Appender' with 'doc' from pandas.util._decorators. Edit 0 changes the import statement to remove 'Appender' and add 'doc', while Edit 1 changes the usage of '@Appender' to '@doc' as a decorator. These edits are part of a single refactoring operation where the same symbol substitution (Appender \u2192 doc) is being applied consistently. After making either edit, the other becomes the immediate next step to maintain code consistency - if you change the import without updating the usage, you get a NameError at runtime, and if you change the usage without updating the import, you also get a NameError. Both edits can be staged in either order since Python allows referencing undefined names at parse time (they only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbol change: replacing 'Appender' with 'doc' from pandas.util._decorators. Edit 0 changes the import statement to remove 'Appender' and add 'doc', while Edit 1 changes the decorator usage from '@Appender' to '@doc'. These edits are part of a single refactoring operation where the same symbol substitution is being applied consistently. After making either edit, the other becomes immediately necessary to maintain code consistency - if you change the import without updating the usage, you get a NameError, and if you change the usage without updating the import, you also get a NameError. Both edits can be staged in either order (both are syntactically valid), but they form a synchronized pair targeting the same symbol replacement."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol change: replacing 'Appender' with 'doc' from pandas.util._decorators. Edit 0 changes the import statement to remove 'Appender' and add 'doc', while Edit 1 changes the decorator usage from '@Appender' to '@doc'. These edits are part of a single refactoring operation where the same symbol substitution is being applied consistently. After making either edit, the other becomes immediately necessary to maintain code consistency - if you change the import without updating the usage, you get a NameError, and if you change the usage without updating the import, you also get a NameError. Both edits can be staged in either order (both are syntactically valid), but they form a synchronized pair targeting the same symbol replacement."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Appender' to 'doc' in decorator usage. Edit 0 changes the import statement from 'from pandas.util._decorators import Appender' to 'from pandas.util._decorators import doc', while Edit 1 changes the decorator usage from '@Appender(Index.dropna.__doc__)' to '@doc(Index.dropna)'. This represents a synchronized refactoring where the import change and usage change are part of the same contiguous micro-task. Both edits reference the exact same symbol being renamed (Appender \u2192 doc) and represent a uniform substitution pattern across import and usage contexts. Either edit could be made first, and after making either one, the other becomes the immediate next step to complete the refactoring."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Appender' to 'doc' in decorator usage. Edit 0 changes the import statement from 'from pandas.util._decorators import Appender' to 'from pandas.util._decorators import doc', while Edit 1 changes the decorator usage from '@Appender(Index.dropna.__doc__)' to '@doc(Index.dropna)'. This represents a synchronized refactoring where the import change and usage change are part of the same contiguous micro-task. Both edits reference the exact same symbol being renamed (Appender \u2192 doc) and represent a uniform substitution pattern across import and usage contexts. Either edit could be made first, and after making either one, the other becomes the immediate next step to complete the refactoring."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(Index.method.__doc__)' to '@doc(Index.method)' on decorator lines. This is a uniform refactoring operation targeting the same type of syntactic construct (method decorators) with the exact same before\u2192after pattern. Both edits are part of a single, contiguous refactor to standardize decorator usage across methods in the same class. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@Appender(Index.method.__doc__)' to '@doc(Index.method)' on decorator lines. This is a uniform refactoring operation targeting the same type of syntactic construct (method decorators) with the exact same before\u2192after pattern. Both edits are part of a single, contiguous refactor to standardize decorator usage across methods in the same class. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: replacing '@Appender(Index.METHOD.__doc__)' with '@doc(Index.METHOD)' on decorator lines within the same class (ExtensionIndex). This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (method decorators). Both edits are part of a single, contiguous refactor to change the documentation decorator pattern throughout the class. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the decorator pattern."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: replacing '@Appender(Index.METHOD.__doc__)' with '@doc(Index.METHOD)' on decorator lines within the same class (ExtensionIndex). This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (method decorators). Both edits are part of a single, contiguous refactor to change the documentation decorator pattern throughout the class. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the decorator pattern."
        }
    ],
    "allowed_init_edits": [
        4,
        0
    ]
}