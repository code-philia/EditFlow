{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution, replacing 'rapidjson.NM_NATIVE | rapidjson.NM_NAN' and 'rapidjson.NM_NATIVE' with 'HYPER_PARAMS_FILE_FORMAT'. This is a uniform refactoring pattern where the same constant is being introduced to replace hardcoded rapidjson number mode values across multiple locations in the same file. Both edits target the same type of syntactic construct (rapidjson number_mode parameters) and represent a single, contiguous refactor to standardize the number mode configuration. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution, replacing 'rapidjson.NM_NATIVE | rapidjson.NM_NAN' and 'rapidjson.NM_NATIVE' with 'HYPER_PARAMS_FILE_FORMAT'. This is a uniform refactoring pattern where the same constant is being introduced to replace hardcoded rapidjson number mode values across multiple locations in the same file. Both edits target the same type of syntactic construct (rapidjson number_mode parameters) and represent a single, contiguous refactor to standardize the number mode configuration. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'HYPER_PARAMS_FILE_FORMAT' in their changed lines. Edit 0 replaces a hardcoded rapidjson number mode with this constant, while Edit 1 adds a new method that uses the same constant for loading parameters. The constant must be defined somewhere for both edits to work, and both edits are part of creating a consistent parameter serialization/deserialization pattern using the same format constant. Either edit can be made first since both reference the same symbol and create a mechanically obvious prompt for the other as part of maintaining format consistency."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'HYPER_PARAMS_FILE_FORMAT' in their changed lines. Edit 0 replaces a hardcoded rapidjson number mode with this constant, while Edit 1 adds a new method that uses the same constant for loading parameters. The constant must be defined somewhere for both edits to work, and both edits are part of creating a consistent parameter serialization/deserialization pattern using the same format constant. Either edit can be made first since both reference the same symbol and create a mechanically obvious prompt for the other as part of maintaining format consistency."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 defines a new constant HYPER_PARAMS_FILE_FORMAT with the value 'rapidjson.NM_NATIVE | rapidjson.NM_NAN', and Edit 1 replaces the inline usage of that exact same expression with the newly defined constant. The changed lines reference the exact same symbol (HYPER_PARAMS_FILE_FORMAT) - Edit 0 creates it and Edit 1 uses it. This is a classic definition-usage pattern where making either edit creates an immediate, mechanically obvious prompt for the other as the next contiguous action. Both edits can be staged in either order without parser errors, making this bi-directional."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 defines a new constant HYPER_PARAMS_FILE_FORMAT with the value 'rapidjson.NM_NATIVE | rapidjson.NM_NAN', and Edit 1 replaces the inline usage of that exact same expression with the newly defined constant. The changed lines reference the exact same symbol (HYPER_PARAMS_FILE_FORMAT) - Edit 0 creates it and Edit 1 uses it. This is a classic definition-usage pattern where making either edit creates an immediate, mechanically obvious prompt for the other as the next contiguous action. Both edits can be staged in either order without parser errors, making this bi-directional."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 defines the constant HYPER_PARAMS_FILE_FORMAT at module level, and edit 1 uses this exact same symbol in the rapidjson.load() call within the load_params method. The changed lines reference the exact same symbol - HYPER_PARAMS_FILE_FORMAT. After defining the constant in edit 0, using it in edit 1 becomes the immediate next step. Both edits can be staged in either order since Python allows referencing undefined names at parse time (would only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 defines the constant HYPER_PARAMS_FILE_FORMAT at module level, and edit 1 uses this exact same symbol in the rapidjson.load() call within the load_params method. The changed lines reference the exact same symbol - HYPER_PARAMS_FILE_FORMAT. After defining the constant in edit 0, using it in edit 1 becomes the immediate next step. Both edits can be staged in either order since Python allows referencing undefined names at parse time (would only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 defines a constant HYPER_PARAMS_FILE_FORMAT with the value 'rapidjson.NM_NATIVE | rapidjson.NM_NAN', and Edit 1 uses this exact same constant to replace the hardcoded 'rapidjson.NM_NATIVE' in a function call. The changed lines reference the exact same symbol (HYPER_PARAMS_FILE_FORMAT), creating a direct definition-usage relationship. After defining the constant in Edit 0, using it in Edit 1 becomes the immediate next step to replace the hardcoded value. This is a classic extract-constant refactoring pattern where both edits can be staged in either order since Python allows referencing undefined names at parse time (only failing at runtime)."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 defines a constant HYPER_PARAMS_FILE_FORMAT with the value 'rapidjson.NM_NATIVE | rapidjson.NM_NAN', and Edit 1 uses this exact same constant to replace the hardcoded 'rapidjson.NM_NATIVE' in a function call. The changed lines reference the exact same symbol (HYPER_PARAMS_FILE_FORMAT), creating a direct definition-usage relationship. After defining the constant in Edit 0, using it in Edit 1 becomes the immediate next step to replace the hardcoded value. This is a classic extract-constant refactoring pattern where both edits can be staged in either order since Python allows referencing undefined names at parse time (only failing at runtime)."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'HYPER_PARAMS_FILE_FORMAT'. Edit 0 adds a new method that uses this constant in line 89, while Edit 1 replaces 'rapidjson.NM_NATIVE' with 'HYPER_PARAMS_FILE_FORMAT' in line 202. This appears to be part of a uniform substitution pattern where the codebase is being refactored to use a consistent constant for the rapidjson number_mode parameter. Both edits can be applied in either order since they reference the same symbol and are part of the same refactoring effort to standardize the number_mode usage."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'HYPER_PARAMS_FILE_FORMAT'. Edit 0 adds a new method that uses this constant in line 89, while Edit 1 replaces 'rapidjson.NM_NATIVE' with 'HYPER_PARAMS_FILE_FORMAT' in line 202. This appears to be part of a uniform substitution pattern where the codebase is being refactored to use a consistent constant for the rapidjson number_mode parameter. Both edits can be applied in either order since they reference the same symbol and are part of the same refactoring effort to standardize the number_mode usage."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 defines a new static method `load_params` in the `HyperoptTools` class, and edit 1 replaces inline file loading code with a call to that exact same method `HyperoptTools.load_params`. The changed lines reference the exact same symbol - the `load_params` method. After defining the method in edit 0, edit 1 becomes the immediate next step to use it, and vice versa - after seeing the usage in edit 1, defining the method in edit 0 becomes the natural next step. This is a classic definition-usage relationship where both edits can be staged in either order (no parse errors), making it bi-directional."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 defines a new static method `load_params` in the `HyperoptTools` class, and edit 1 replaces inline file loading code with a call to that exact same method `HyperoptTools.load_params`. The changed lines reference the exact same symbol - the `load_params` method. After defining the method in edit 0, edit 1 becomes the immediate next step to use it, and vice versa - after seeing the usage in edit 1, defining the method in edit 0 becomes the natural next step. This is a classic definition-usage relationship where both edits can be staged in either order (no parse errors), making it bi-directional."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Edit 0 adds a new static method `load_params` to the `HyperoptTools` class. Edit 1 updates a test mock to patch `freqtrade.strategy.hyper.HyperoptTools.load_params` instead of `freqtrade.strategy.hyper.json_load`. The changed lines reference the exact same symbol - the `load_params` method being defined in edit 0 and being mocked in edit 1. This creates a direct code dependency where after adding the method definition, the test needs to be updated to mock the new method instead of the old one. Both edits can be staged in either order (the test mock can reference a method that doesn't exist yet without causing a parse error), making this bi-directional."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Edit 0 adds a new static method `load_params` to the `HyperoptTools` class. Edit 1 updates a test mock to patch `freqtrade.strategy.hyper.HyperoptTools.load_params` instead of `freqtrade.strategy.hyper.json_load`. The changed lines reference the exact same symbol - the `load_params` method being defined in edit 0 and being mocked in edit 1. This creates a direct code dependency where after adding the method definition, the test needs to be updated to mock the new method instead of the old one. Both edits can be staged in either order (the test mock can reference a method that doesn't exist yet without causing a parse error), making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 8,
            "reason": "Edit 0 adds a new static method `load_params` to the `HyperoptTools` class. Edit 1 updates a test mock to patch `freqtrade.strategy.hyper.HyperoptTools.load_params` instead of `freqtrade.strategy.hyper.json_load`. The changed line in edit 1 directly references the exact same method (`HyperoptTools.load_params`) that is being defined in edit 0. This creates an immediate code dependency where defining the method enables the test to properly mock it. Either edit can be staged first since both are syntactically valid, but they form a natural pair where one defines the method and the other uses it in testing."
        },
        {
            "src": 8,
            "tgt": 2,
            "reason": "Edit 0 adds a new static method `load_params` to the `HyperoptTools` class. Edit 1 updates a test mock to patch `freqtrade.strategy.hyper.HyperoptTools.load_params` instead of `freqtrade.strategy.hyper.json_load`. The changed line in edit 1 directly references the exact same method (`HyperoptTools.load_params`) that is being defined in edit 0. This creates an immediate code dependency where defining the method enables the test to properly mock it. Either edit can be staged first since both are syntactically valid, but they form a natural pair where one defines the method and the other uses it in testing."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 adds a new static method `load_params` to the `HyperoptTools` class. Edit 1 updates a mock patch to use this newly added method (`HyperoptTools.load_params`) instead of the previous `json_load`. The changed lines reference the exact same symbol - the `load_params` method that was just defined. This creates an immediate code-driven relationship where defining the method naturally prompts updating the test to use it, and both edits can be staged in either order since the test mock will work regardless of whether the actual method exists yet."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 adds a new static method `load_params` to the `HyperoptTools` class. Edit 1 updates a mock patch to use this newly added method (`HyperoptTools.load_params`) instead of the previous `json_load`. The changed lines reference the exact same symbol - the `load_params` method that was just defined. This creates an immediate code-driven relationship where defining the method naturally prompts updating the test to use it, and both edits can be staged in either order since the test mock will work regardless of whether the actual method exists yet."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 removes the import of 'json_load' from freqtrade.misc, while Edit 1 removes the usage of that same 'json_load' function and replaces it with HyperoptTools.load_params(). Both edits reference the exact same symbol 'json_load' - one removes its import and the other removes its usage. This creates a direct code dependency where removing the import makes the usage invalid, and removing the usage makes the import unnecessary. Either edit can be made first since Python allows undefined symbols at parse time (they only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step in removing the json_load dependency."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 removes the import of 'json_load' from freqtrade.misc, while Edit 1 removes the usage of that same 'json_load' function and replaces it with HyperoptTools.load_params(). Both edits reference the exact same symbol 'json_load' - one removes its import and the other removes its usage. This creates a direct code dependency where removing the import makes the usage invalid, and removing the usage makes the import unnecessary. Either edit can be made first since Python allows undefined symbols at parse time (they only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step in removing the json_load dependency."
        },
        {
            "src": 5,
            "tgt": 8,
            "reason": "Both edits reference the exact same code change: replacing a direct json_load call with HyperoptTools.load_params. Edit 0 changes the production code to use HyperoptTools.load_params instead of json_load, and Edit 1 updates the corresponding test mock to patch the new method being called. The test mock in Edit 1 must be updated to match the implementation change in Edit 0, as it's mocking the exact same method call that was changed. This creates a direct, mechanical dependency where either edit prompts the other as the immediate next step to maintain test-production synchronization."
        },
        {
            "src": 8,
            "tgt": 5,
            "reason": "Both edits reference the exact same code change: replacing a direct json_load call with HyperoptTools.load_params. Edit 0 changes the production code to use HyperoptTools.load_params instead of json_load, and Edit 1 updates the corresponding test mock to patch the new method being called. The test mock in Edit 1 must be updated to match the implementation change in Edit 0, as it's mocking the exact same method call that was changed. This creates a direct, mechanical dependency where either edit prompts the other as the immediate next step to maintain test-production synchronization."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 changes the implementation from using 'json_load(f)' to 'HyperoptTools.load_params(filename)' in the production code. Edit 1 updates the corresponding test mock from patching 'freqtrade.strategy.hyper.json_load' to patching 'freqtrade.strategy.hyper.HyperoptTools.load_params'. Both edits reference the exact same code path and symbol being changed - the method call that loads parameters in the HyperStrategyMixin class. The test mock must be updated to match the new implementation, creating a direct code dependency where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 changes the implementation from using 'json_load(f)' to 'HyperoptTools.load_params(filename)' in the production code. Edit 1 updates the corresponding test mock from patching 'freqtrade.strategy.hyper.json_load' to patching 'freqtrade.strategy.hyper.HyperoptTools.load_params'. Both edits reference the exact same code path and symbol being changed - the method call that loads parameters in the HyperStrategyMixin class. The test mock must be updated to match the new implementation, creating a direct code dependency where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution within the same test function, changing 'freqtrade.strategy.hyper.json_load' to 'freqtrade.strategy.hyper.HyperoptTools.load_params' in mocker.patch calls. This is a bulk-edit pattern where the same before\u2192after substitution is applied to the same type of syntactic construct (mocker.patch calls) within the same function context. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency within the same test function."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution within the same test function, changing 'freqtrade.strategy.hyper.json_load' to 'freqtrade.strategy.hyper.HyperoptTools.load_params' in mocker.patch calls. This is a bulk-edit pattern where the same before\u2192after substitution is applied to the same type of syntactic construct (mocker.patch calls) within the same function context. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency within the same test function."
        },
        {
            "src": 6,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern within the same test function. They both change 'freqtrade.strategy.hyper.json_load' to 'freqtrade.strategy.hyper.HyperoptTools.load_params' in mocker.patch calls. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (mocker.patch calls) within the same function context. Both edits reference the exact same API change and would naturally be performed as part of a single, contiguous refactoring sweep."
        },
        {
            "src": 8,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern within the same test function. They both change 'freqtrade.strategy.hyper.json_load' to 'freqtrade.strategy.hyper.HyperoptTools.load_params' in mocker.patch calls. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (mocker.patch calls) within the same function context. Both edits reference the exact same API change and would naturally be performed as part of a single, contiguous refactoring sweep."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern within the same test function. They both change 'freqtrade.strategy.hyper.json_load' to 'freqtrade.strategy.hyper.HyperoptTools.load_params' in mocker.patch calls. This is a bulk uniform substitution where both edits target the same type of syntactic construct (mocker.patch calls) with the exact same before\u2192after pattern. The edits are part of a single, contiguous refactor to update the mocked function path throughout the test. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the refactoring pattern."
        },
        {
            "src": 8,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern within the same test function. They both change 'freqtrade.strategy.hyper.json_load' to 'freqtrade.strategy.hyper.HyperoptTools.load_params' in mocker.patch calls. This is a bulk uniform substitution where both edits target the same type of syntactic construct (mocker.patch calls) with the exact same before\u2192after pattern. The edits are part of a single, contiguous refactor to update the mocked function path throughout the test. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the refactoring pattern."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Edit 0 changes the implementation from using `json_load(f)` to `HyperoptTools.load_params(filename)` in the production code. Edit 1 updates the corresponding test mock from patching `json_load` to patching `HyperoptTools.load_params` with the same return value. Both edits reference the exact same code change - replacing the json_load call with HyperoptTools.load_params - and the test edit is updating its mock to match the new implementation. This is a classic test-production synchronization where the test mock needs to be updated to reflect the implementation change for the same method being tested."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Edit 0 changes the implementation from using `json_load(f)` to `HyperoptTools.load_params(filename)` in the production code. Edit 1 updates the corresponding test mock from patching `json_load` to patching `HyperoptTools.load_params` with the same return value. Both edits reference the exact same code change - replacing the json_load call with HyperoptTools.load_params - and the test edit is updating its mock to match the new implementation. This is a classic test-production synchronization where the test mock needs to be updated to reflect the implementation change for the same method being tested."
        }
    ],
    "allowed_init_edits": [
        4
    ]
}