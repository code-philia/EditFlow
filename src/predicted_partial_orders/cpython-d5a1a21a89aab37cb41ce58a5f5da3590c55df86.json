{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 removes the code that creates the 'tb' variable (lines 43-46), while Edit 1 removes code that references this same 'tb' variable (line 97). The 'tb' variable is the exact same symbol referenced in both edits. After removing the definition in Edit 0, the reference in Edit 1 becomes undefined, making Edit 1's removal the immediate next step to clean up the dangling reference. However, both edits can be staged in either order since Python allows undefined variable references at parse time (they only fail at runtime). This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical cleanup step."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 removes the code that creates the 'tb' variable (lines 43-46), while Edit 1 removes code that references this same 'tb' variable (line 97). The 'tb' variable is the exact same symbol referenced in both edits. After removing the definition in Edit 0, the reference in Edit 1 becomes undefined, making Edit 1's removal the immediate next step to clean up the dangling reference. However, both edits can be staged in either order since Python allows undefined variable references at parse time (they only fail at runtime). This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical cleanup step."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 adds 'global tb' declaration at the beginning of the test method, while Edit 1 creates and uses the 'tb' variable within a try-except block. The changed lines reference the exact same symbol 'tb' - Edit 0 declares it as global and Edit 1 assigns to it and uses it. Edit 0 must come before Edit 1 because without the global declaration, the assignment 'tb = sys.exc_info()[2]' in Edit 1 would create a local variable instead of the intended global variable. The global declaration is required for the assignment to affect the global scope."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 adds 'global tb' declaration at the beginning of the test method, while Edit 1 removes the line 'self.istest(inspect.istraceback, 'tb')' that tests the 'tb' variable. These edits reference the exact same symbol 'tb' - Edit 0 declares it as global and Edit 1 removes the test that uses it. The global declaration in Edit 0 creates an immediate code-driven prompt to handle the usage of 'tb', and removing the test in Edit 1 is the natural next step when the 'tb' variable is being refactored or removed. Both edits are part of the same micro-task of handling the 'tb' symbol in this test method."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 adds 'global tb' declaration at the beginning of the test method, while Edit 1 removes the line 'self.istest(inspect.istraceback, 'tb')' that tests the 'tb' variable. These edits reference the exact same symbol 'tb' - Edit 0 declares it as global and Edit 1 removes the test that uses it. The global declaration in Edit 0 creates an immediate code-driven prompt to handle the usage of 'tb', and removing the test in Edit 1 is the natural next step when the 'tb' variable is being refactored or removed. Both edits are part of the same micro-task of handling the 'tb' symbol in this test method."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 removes the code that creates the 'tb' variable (lines 43-46: try/except block that assigns sys.exc_info()[2] to tb). Edit 1 removes the test line that uses this 'tb' variable (line 89: self.istest(inspect.istraceback, 'tb')). Both edits reference the exact same symbol 'tb' - one removes its definition and the other removes its usage. This creates a direct code dependency where removing the definition makes the usage reference an undefined variable. However, in Python, both edits can be parsed and staged in either order since referencing an undefined variable only causes a runtime NameError, not a parse-time syntax error. After making either edit, the other becomes the immediate next step to maintain code consistency."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 removes the code that creates the 'tb' variable (lines 43-46: try/except block that assigns sys.exc_info()[2] to tb). Edit 1 removes the test line that uses this 'tb' variable (line 89: self.istest(inspect.istraceback, 'tb')). Both edits reference the exact same symbol 'tb' - one removes its definition and the other removes its usage. This creates a direct code dependency where removing the definition makes the usage reference an undefined variable. However, in Python, both edits can be parsed and staged in either order since referencing an undefined variable only causes a runtime NameError, not a parse-time syntax error. After making either edit, the other becomes the immediate next step to maintain code consistency."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 removes the code that creates and assigns the 'tb' variable (lines 43-46), while Edit 1 adds 'global tb' declaration. The 'tb' variable referenced in Edit 1's global declaration is the exact same symbol that was being created in Edit 0's removed code. However, since Edit 0 removes the definition of 'tb' and Edit 1 declares it as global (expecting it to exist), Edit 0 must come before Edit 1 - otherwise Edit 1 would reference a non-existent global variable. This creates a direct code dependency where the removal of the tb assignment must happen before the global declaration."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 adds a try/except block that creates a traceback object 'tb' and includes the exact same code that Edit 1 removes (lines testing inspect.isgetsetdescriptor with 'type(tb.tb_frame).f_locals'). This is a code movement where the same functionality is being relocated from one part of the function to another. The removal in Edit 1 must happen after the addition in Edit 0 to avoid losing the functionality entirely, making this an ordered relationship where Edit 0 (addition) must come before Edit 1 (removal)."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds a try-except block that creates a traceback object 'tb' and includes the line 'self.istest(inspect.istraceback, 'tb')' within that block. Edit 1 removes the exact same line 'self.istest(inspect.istraceback, 'tb')' from its original location outside the try-except block. This is a clear case of moving a line of code from one location to another - the line must first be removed from its original location (edit 1) before it can be properly placed in the new location within the try-except block (edit 0). The changed lines reference the exact same test call with the same parameters."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}