{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits change 'ETC/BTC' to 'DOGE/BTC' within the same function (leverage_trade). This is a bulk uniform substitution where both edits perform the identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals representing trading pairs). The edits are part of a single, contiguous refactor to change the trading pair throughout the function. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits change 'ETC/BTC' to 'DOGE/BTC' within the same function (leverage_trade). This is a bulk uniform substitution where both edits perform the identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals representing trading pairs). The edits are part of a single, contiguous refactor to change the trading pair throughout the function. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') within the same function context (leverage_trade). This is a bulk-edit pattern where the same trading pair symbol is being updated consistently across multiple locations in the same function. The edits are part of a single, contiguous refactor to change the trading pair from ETC/BTC to DOGE/BTC throughout the function. Either edit can be made first, and after making either one, the other becomes the natural next step to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') within the same function context (leverage_trade). This is a bulk-edit pattern where the same trading pair symbol is being updated consistently across multiple locations in the same function. The edits are part of a single, contiguous refactor to change the trading pair from ETC/BTC to DOGE/BTC throughout the function. Either edit can be made first, and after making either one, the other becomes the natural next step to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals representing trading pairs). This appears to be part of a single, contiguous refactor to change the test data from ETC/BTC to DOGE/BTC across the test configuration. The edits target the same conceptual entity (trading pair symbol) in related test fixtures, making either edit a natural prompt for the other as part of the same bulk substitution task."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals representing trading pairs). This appears to be part of a single, contiguous refactor to change the test data from ETC/BTC to DOGE/BTC across the test configuration. The edits target the same conceptual entity (trading pair symbol) in related test fixtures, making either edit a natural prompt for the other as part of the same bulk substitution task."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') and are part of a single, contiguous refactor to change the trading pair symbol. Edit 0 changes the symbol in the leverage_order_sell() function's return data, and Edit 1 changes the symbol parameter passed to Order.parse_from_ccxt_object() when calling leverage_order_sell(). Both changed lines reference the same symbol value and are part of a synchronized pattern substitution within the same test configuration context. Either edit can be made first, and after making either one, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') and are part of a single, contiguous refactor to change the trading pair symbol. Edit 0 changes the symbol in the leverage_order_sell() function's return data, and Edit 1 changes the symbol parameter passed to Order.parse_from_ccxt_object() when calling leverage_order_sell(). Both changed lines reference the same symbol value and are part of a synchronized pattern substitution within the same test configuration context. Either edit can be made first, and after making either one, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals representing trading pairs). Edit 0 changes the 'symbol' field in what appears to be an order/trade data structure, while Edit 1 changes the 'pair' field in a Trade object constructor. Both are part of the same refactoring operation to change the trading pair from ETC/BTC to DOGE/BTC across test fixtures. This represents a bulk-edit pattern where the same substitution is being applied uniformly across related test data structures."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals representing trading pairs). Edit 0 changes the 'symbol' field in what appears to be an order/trade data structure, while Edit 1 changes the 'pair' field in a Trade object constructor. Both are part of the same refactoring operation to change the trading pair from ETC/BTC to DOGE/BTC across test fixtures. This represents a bulk-edit pattern where the same substitution is being applied uniformly across related test data structures."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals representing trading symbols). Edit 0 changes the symbol in a test fixture function leverage_order(), while Edit 1 changes the same symbol in a function call within leverage_trade(). This appears to be part of a single, contiguous refactor to update the trading symbol consistently across related test code. The edits represent a bulk-edit pattern with identical before\u2192after substitution targeting the same construct type."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals representing trading symbols). Edit 0 changes the symbol in a test fixture function leverage_order(), while Edit 1 changes the same symbol in a function call within leverage_trade(). This appears to be part of a single, contiguous refactor to update the trading symbol consistently across related test code. The edits represent a bulk-edit pattern with identical before\u2192after substitution targeting the same construct type."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution (changing 'ETC/BTC' to 'DOGE/BTC') on the same type of syntactic construct (symbol field in dictionary literals within test fixture functions). This appears to be part of a single, contiguous refactor to update test data from ETC/BTC to DOGE/BTC across multiple test fixtures. The edits represent a bulk-edit pattern where the same before\u2192after substitution is applied to the same construct type, making either edit naturally prompt the other as part of the same mechanical refactoring task."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution (changing 'ETC/BTC' to 'DOGE/BTC') on the same type of syntactic construct (symbol field in dictionary literals within test fixture functions). This appears to be part of a single, contiguous refactor to update test data from ETC/BTC to DOGE/BTC across multiple test fixtures. The edits represent a bulk-edit pattern where the same before\u2192after substitution is applied to the same construct type, making either edit naturally prompt the other as part of the same mechanical refactoring task."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals representing trading symbols). Edit 0 changes the symbol in a test fixture function leverage_order_sell(), while Edit 1 changes the same symbol in a function call parameter within leverage_trade(). This appears to be part of a single, contiguous refactor to update test data from ETC/BTC to DOGE/BTC across related test fixtures. Both edits can be applied in either order without causing parse errors, and either edit naturally prompts the other as part of maintaining consistency in the test suite's symbol references."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals representing trading symbols). Edit 0 changes the symbol in a test fixture function leverage_order_sell(), while Edit 1 changes the same symbol in a function call parameter within leverage_trade(). This appears to be part of a single, contiguous refactor to update test data from ETC/BTC to DOGE/BTC across related test fixtures. Both edits can be applied in either order without causing parse errors, and either edit naturally prompts the other as part of maintaining consistency in the test suite's symbol references."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits change the same symbol 'ETC/BTC' to 'DOGE/BTC' in the same test file. Edit 0 changes the symbol in the leverage_order() fixture definition, while Edit 1 changes the symbol parameter passed to Order.parse_from_ccxt_object() which uses the leverage_order() fixture. The changed lines reference the exact same symbol value and represent a synchronized substitution pattern - both are part of updating the test data from ETC/BTC to DOGE/BTC. This is a uniform textual substitution across related test code that would naturally be done together in a single refactoring action."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits change the same symbol 'ETC/BTC' to 'DOGE/BTC' in the same test file. Edit 0 changes the symbol in the leverage_order() fixture definition, while Edit 1 changes the symbol parameter passed to Order.parse_from_ccxt_object() which uses the leverage_order() fixture. The changed lines reference the exact same symbol value and represent a synchronized substitution pattern - both are part of updating the test data from ETC/BTC to DOGE/BTC. This is a uniform textual substitution across related test code that would naturally be done together in a single refactoring action."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals as parameters to Order.parse_from_ccxt_object calls) within the same function context. This represents a bulk-edit pattern where both changes are part of a single, contiguous refactor operation to change the trading pair from ETC/BTC to DOGE/BTC. The edits can be made in either order since they are independent substitutions of the same pattern."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution ('ETC/BTC' \u2192 'DOGE/BTC') on the same type of syntactic construct (string literals as parameters to Order.parse_from_ccxt_object calls) within the same function context. This represents a bulk-edit pattern where both changes are part of a single, contiguous refactor operation to change the trading pair from ETC/BTC to DOGE/BTC. The edits can be made in either order since they are independent substitutions of the same pattern."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits change 'ETC/BTC' to 'DOGE/BTC', but they reference different symbols in different contexts. Edit 0 changes the pair parameter in a Trade constructor within a test fixture, while Edit 1 changes an assertion value in a different test function. Although both involve the same string substitution, the changed lines reference different occurrences of the trading pair - one is a parameter value being set, the other is an expected assertion value being checked. These are different symbols (different string literals in different scopes) despite having identical content. There is no direct code dependency between these specific changed lines - they are part of a bulk substitution pattern but reference different symbols."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits change 'ETC/BTC' to 'DOGE/BTC', but they reference different symbols in different contexts. Edit 0 changes the pair parameter in a Trade constructor within a test fixture, while Edit 1 changes an assertion value in a different test function. Although both involve the same string substitution, the changed lines reference different occurrences of the trading pair - one is a parameter value being set, the other is an expected assertion value being checked. These are different symbols (different string literals in different scopes) despite having identical content. There is no direct code dependency between these specific changed lines - they are part of a bulk substitution pattern but reference different symbols."
        }
    ],
    "allowed_init_edits": [
        5
    ]
}