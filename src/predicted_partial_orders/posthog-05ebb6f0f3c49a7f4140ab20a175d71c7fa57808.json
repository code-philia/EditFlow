{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds a new 'parent' attribute to the SelectQueryType class, and Edit 1 uses that exact same 'parent' attribute in the lookup_field_by_name function. The changed lines in Edit 1 explicitly reference the same 'parent' symbol that was defined in Edit 0. After adding the parent attribute in Edit 0, using it in Edit 1 becomes a natural next step. Both edits can be staged in either order since accessing an undefined attribute in Python only causes a runtime AttributeError, not a parse-time syntax error."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds a new 'parent' attribute to the SelectQueryType class, and Edit 1 uses that exact same 'parent' attribute in the lookup_field_by_name function. The changed lines in Edit 1 explicitly reference the same 'parent' symbol that was defined in Edit 0. After adding the parent attribute in Edit 0, using it in Edit 1 becomes a natural next step. Both edits can be staged in either order since accessing an undefined attribute in Python only causes a runtime AttributeError, not a parse-time syntax error."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 modifies the SelectQueryType constructor in visit_lambda to include a parent parameter, while Edit 1 adds a test that specifically verifies this parent parameter functionality. The test directly asserts that lambda_type.parent equals node.type, which is exactly the behavior introduced by the parent parameter addition in Edit 0. Both edits reference the exact same symbol (SelectQueryType constructor and its parent attribute) and the test validates the specific code change made in Edit 0."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 modifies the SelectQueryType constructor in visit_lambda to include a parent parameter, while Edit 1 adds a test that specifically verifies this parent parameter functionality. The test directly asserts that lambda_type.parent equals node.type, which is exactly the behavior introduced by the parent parameter addition in Edit 0. Both edits reference the exact same symbol (SelectQueryType constructor and its parent attribute) and the test validates the specific code change made in Edit 0."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds a new 'parent' attribute to the SelectQueryType class, while Edit 1 adds a test that specifically tests this new 'parent' attribute functionality. The test code in Edit 1 directly references and asserts on the 'parent' attribute that was added in Edit 0 (lines 931 and 933 use 'lambda_type.parent'). This creates a direct code dependency where the test cannot function without the attribute definition, and the attribute was likely added to support this exact functionality. Both edits reference the exact same symbol ('parent' attribute of SelectQueryType), making this a clear definition-usage relationship within what appears to be the same development session."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds a new 'parent' attribute to the SelectQueryType class, while Edit 1 adds a test that specifically tests this new 'parent' attribute functionality. The test code in Edit 1 directly references and asserts on the 'parent' attribute that was added in Edit 0 (lines 931 and 933 use 'lambda_type.parent'). This creates a direct code dependency where the test cannot function without the attribute definition, and the attribute was likely added to support this exact functionality. Both edits reference the exact same symbol ('parent' attribute of SelectQueryType), making this a clear definition-usage relationship within what appears to be the same development session."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 adds a 'parent' parameter to the SelectQueryType constructor, setting it to the current scope if available. Edit 1 adds logic to recursively look up fields in the parent scope using the newly added 'parent' attribute. The changed lines reference the exact same symbol - the 'parent' attribute of SelectQueryType. Edit 0 creates the parent attribute that Edit 1 immediately uses, making them part of a single micro-task implementing parent scope lookup functionality. Either edit could be staged first without parser errors, but they form a natural bi-directional pair where one prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 adds a 'parent' parameter to the SelectQueryType constructor, setting it to the current scope if available. Edit 1 adds logic to recursively look up fields in the parent scope using the newly added 'parent' attribute. The changed lines reference the exact same symbol - the 'parent' attribute of SelectQueryType. Edit 0 creates the parent attribute that Edit 1 immediately uses, making them part of a single micro-task implementing parent scope lookup functionality. Either edit could be staged first without parser errors, but they form a natural bi-directional pair where one prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds a new 'parent' parameter to the SelectQueryType class constructor, and Edit 1 immediately uses this new parameter when creating a SelectQueryType instance. The changed lines reference the exact same symbol (the SelectQueryType constructor and its parent parameter). After adding the parameter in Edit 0, Edit 1 becomes the immediate next step to utilize this new functionality. Both edits can be staged in either order since Python allows calling constructors with keyword arguments that don't exist yet (would only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds a new 'parent' parameter to the SelectQueryType class constructor, and Edit 1 immediately uses this new parameter when creating a SelectQueryType instance. The changed lines reference the exact same symbol (the SelectQueryType constructor and its parent parameter). After adding the parameter in Edit 0, Edit 1 becomes the immediate next step to utilize this new functionality. Both edits can be staged in either order since Python allows calling constructors with keyword arguments that don't exist yet (would only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds 'cast' to the import statement from typing, and Edit 1 uses that exact same 'cast' symbol in the changed lines by calling 'cast(ast.SelectQuery, ...)'. This creates an immediate, mechanically obvious code-driven prompt - after adding the import, the usage becomes available, and after adding the usage, the import becomes necessary. Both edits reference the exact same symbol 'cast' and either can be staged first since Python allows usage before import (runtime NameError only, not parse error)."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds 'cast' to the import statement from typing, and Edit 1 uses that exact same 'cast' symbol in the changed lines by calling 'cast(ast.SelectQuery, ...)'. This creates an immediate, mechanically obvious code-driven prompt - after adding the import, the usage becomes available, and after adding the usage, the import becomes necessary. Both edits reference the exact same symbol 'cast' and either can be staged first since Python allows usage before import (runtime NameError only, not parse error)."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 adds 'cast' to the import statement from typing, and Edit 1 uses the 'cast' function multiple times in the new test method. The changed line in Edit 0 imports the exact same symbol 'cast' that is referenced multiple times in the changed lines of Edit 1. This creates an immediate code dependency where importing 'cast' enables its usage in the test method. Either edit can be staged first since Python allows usage of undefined symbols at parse time (only failing at runtime), making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 adds 'cast' to the import statement from typing, and Edit 1 uses the 'cast' function multiple times in the new test method. The changed line in Edit 0 imports the exact same symbol 'cast' that is referenced multiple times in the changed lines of Edit 1. This creates an immediate code dependency where importing 'cast' enables its usage in the test method. Either edit can be staged first since Python allows usage of undefined symbols at parse time (only failing at runtime), making this a bi-directional relationship."
        }
    ],
    "allowed_init_edits": [
        4
    ]
}