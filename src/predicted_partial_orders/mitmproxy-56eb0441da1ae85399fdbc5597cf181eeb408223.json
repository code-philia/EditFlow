{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution pattern: changing '*spec: typing.Sequence[str]' to '*spec: str' and '*cmd: typing.Sequence[str]' to '*cmd: str'. This represents a uniform refactoring pattern applied to the same type of syntactic construct (variadic parameter type annotations) across different files. The edits are part of a single, contiguous refactor to simplify type annotations for variadic string parameters. Either edit could be made first, and both follow the exact same before\u2192after transformation pattern."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical structural substitution pattern: changing '*spec: typing.Sequence[str]' to '*spec: str' and '*cmd: typing.Sequence[str]' to '*cmd: str'. This represents a uniform refactoring pattern applied to the same type of syntactic construct (variadic parameter type annotations) across different files. The edits are part of a single, contiguous refactor to simplify type annotations for variadic string parameters. Either edit could be made first, and both follow the exact same before\u2192after transformation pattern."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 renames the variable 'spec' to 'strspec' on line 20, and Edit 1 updates the usage of that same variable from 'spec' to 'strspec' on line 22. Both edits reference the exact same symbol within the same function scope. After making either edit, the other becomes immediately necessary to maintain code consistency - if only Edit 0 is made, line 22 would still reference the old variable name 'spec', and if only Edit 1 is made, it would reference an undefined variable 'strspec'. This is a classic variable rename pattern where both the assignment and usage of the same symbol must be updated together."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 renames the variable 'spec' to 'strspec' on line 20, and Edit 1 updates the usage of that same variable from 'spec' to 'strspec' on line 22. Both edits reference the exact same symbol within the same function scope. After making either edit, the other becomes immediately necessary to maintain code consistency - if only Edit 0 is made, line 22 would still reference the old variable name 'spec', and if only Edit 1 is made, it would reference an undefined variable 'strspec'. This is a classic variable rename pattern where both the assignment and usage of the same symbol must be updated together."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 changes the parameter type annotation from `*spec: typing.Sequence[str]` to `*spec: str` in the function signature. Edit 1 changes the usage of this parameter from `spec = \" \".join(spec)` to `strspec = \" \".join(spec)` in the function body. Both edits reference the exact same symbol `spec` - the parameter defined in the function signature. The parameter type change in edit 0 creates an immediate code-driven prompt to update its usage in edit 1, as the parameter behavior has changed. This represents a definition-usage relationship for the same symbol within the same function, making either edit naturally prompt the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 changes the parameter type annotation from `*spec: typing.Sequence[str]` to `*spec: str` in the function signature. Edit 1 changes the usage of this parameter from `spec = \" \".join(spec)` to `strspec = \" \".join(spec)` in the function body. Both edits reference the exact same symbol `spec` - the parameter defined in the function signature. The parameter type change in edit 0 creates an immediate code-driven prompt to update its usage in edit 1, as the parameter behavior has changed. This represents a definition-usage relationship for the same symbol within the same function, making either edit naturally prompt the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '*spec: typing.Sequence[str]' to '*spec: str' and '*cmd: typing.Sequence[str]' to '*cmd: str'. This represents a uniform refactoring across the codebase to simplify variadic parameter type annotations. Both edits target the same type of syntactic construct (function parameter type annotations) and apply the exact same before\u2192after transformation pattern. This appears to be part of a single, contiguous refactoring operation to standardize parameter typing across multiple functions."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing '*spec: typing.Sequence[str]' to '*spec: str' and '*cmd: typing.Sequence[str]' to '*cmd: str'. This represents a uniform refactoring across the codebase to simplify variadic parameter type annotations. Both edits target the same type of syntactic construct (function parameter type annotations) and apply the exact same before\u2192after transformation pattern. This appears to be part of a single, contiguous refactoring operation to standardize parameter typing across multiple functions."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits perform an identical structural substitution pattern: changing '*param: typing.Sequence[str]' to '*param: str' in method signatures within the same class (ConsoleAddon). This represents a uniform refactoring operation where the same type annotation change is being applied to multiple variadic parameters of the same syntactic construct type (method signatures). The edits are part of a single, contiguous refactor to update type annotations consistently across related methods."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution pattern: changing '*param: typing.Sequence[str]' to '*param: str' in method signatures within the same class (ConsoleAddon). This represents a uniform refactoring operation where the same type annotation change is being applied to multiple variadic parameters of the same syntactic construct type (method signatures). The edits are part of a single, contiguous refactor to update type annotations consistently across related methods."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '*cmd: typing.Sequence[str]' to '*cmd: str' in function signatures. This is a bulk uniform substitution targeting the same type of syntactic construct (parameter type annotations) with the exact same before\u2192after pattern. Both edits are part of a single, contiguous refactor to change the type annotation for variadic parameters from Sequence[str] to str across multiple methods in the same class. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the codebase."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing '*cmd: typing.Sequence[str]' to '*cmd: str' in function signatures. This is a bulk uniform substitution targeting the same type of syntactic construct (parameter type annotations) with the exact same before\u2192after pattern. Both edits are part of a single, contiguous refactor to change the type annotation for variadic parameters from Sequence[str] to str across multiple methods in the same class. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the codebase."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing '*param: typing.Sequence[str]' to '*param: str' in method signatures within the same class (ConsoleAddon). This is a bulk refactoring operation where the same type annotation change is being applied uniformly across multiple method signatures of the same syntactic construct type. The edits represent a synchronized pattern substitution that would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '*param: typing.Sequence[str]' to '*param: str' in method signatures within the same class (ConsoleAddon). This is a bulk refactoring operation where the same type annotation change is being applied uniformly across multiple method signatures of the same syntactic construct type. The edits represent a synchronized pattern substitution that would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 6,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing '*var: typing.Sequence[str]' to '*var: str' in function parameter lists. This is a uniform refactoring operation targeting the same type of syntactic construct (variadic parameter type annotations) with the exact same before\u2192after pattern. However, the changed lines reference different symbols - 'cmd' in edit 0 and 'var' in edit 1 - which are parameters in completely different functions in different files. While this appears to be part of a bulk type annotation cleanup, the symbols being modified are different despite the identical substitution pattern."
        },
        {
            "src": 8,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '*var: typing.Sequence[str]' to '*var: str' in function parameter lists. This is a uniform refactoring operation targeting the same type of syntactic construct (variadic parameter type annotations) with the exact same before\u2192after pattern. However, the changed lines reference different symbols - 'cmd' in edit 0 and 'var' in edit 1 - which are parameters in completely different functions in different files. While this appears to be part of a bulk type annotation cleanup, the symbols being modified are different despite the identical substitution pattern."
        }
    ],
    "allowed_init_edits": [
        3,
        4
    ]
}