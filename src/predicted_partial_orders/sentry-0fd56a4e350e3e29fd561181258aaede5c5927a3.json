{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 defines a new constant DURATION_PATTERN in constants.py, and Edit 1 uses that exact same DURATION_PATTERN symbol in fields.py. The changed lines in Edit 1 explicitly reference the DURATION_PATTERN symbol that was added in Edit 0. This creates a definition-usage relationship where both edits reference the exact same symbol. Since this is Python, the usage can be written before the definition (it would only fail at import/runtime, not at parse time), making this a bi-directional relationship where either edit can be made first and naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 defines a new constant DURATION_PATTERN in constants.py, and Edit 1 uses that exact same DURATION_PATTERN symbol in fields.py. The changed lines in Edit 1 explicitly reference the DURATION_PATTERN symbol that was added in Edit 0. This creates a definition-usage relationship where both edits reference the exact same symbol. Since this is Python, the usage can be written before the definition (it would only fail at import/runtime, not at parse time), making this a bi-directional relationship where either edit can be made first and naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 imports `InvalidQuery` and `parse_duration` from `sentry.search.utils`, while Edit 1 uses these exact same imported symbols in the changed lines (lines 359 and 360). The import in Edit 0 makes these symbols available for use, and Edit 1 directly references them. This creates an immediate code dependency where Edit 0 must occur before Edit 1 can be parsed successfully, as the symbols would be undefined without the import."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 defines a new constant DURATION_PATTERN in constants.py, and Edit 1 imports that exact same DURATION_PATTERN symbol in fields.py. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. After defining DURATION_PATTERN in constants.py, importing it in fields.py becomes the immediate next step to use it. Since this is Python, the import can be written before the definition exists (it would only fail at runtime/import time, not at parse time), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 defines a new constant DURATION_PATTERN in constants.py, and Edit 1 imports that exact same DURATION_PATTERN symbol in fields.py. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. After defining DURATION_PATTERN in constants.py, importing it in fields.py becomes the immediate next step to use it. Since this is Python, the import can be written before the definition exists (it would only fail at runtime/import time, not at parse time), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 modifies the normalize_count_if_value function to add duration parsing functionality using DURATION_PATTERN.match() and parse_duration(). Edit 1 adds a test case that specifically tests count_if functionality with a duration value ('10d') that would exercise this new duration parsing code. The test expects the duration '10d' to be parsed into 864000000 (milliseconds), which directly validates the duration parsing logic added in edit 0. Both edits reference the same functionality - duration parsing in count_if operations - where edit 0 implements the feature and edit 1 tests that exact implementation."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 modifies the normalize_count_if_value function to add duration parsing functionality using DURATION_PATTERN.match() and parse_duration(). Edit 1 adds a test case that specifically tests count_if functionality with a duration value ('10d') that would exercise this new duration parsing code. The test expects the duration '10d' to be parsed into 864000000 (milliseconds), which directly validates the duration parsing logic added in edit 0. Both edits reference the same functionality - duration parsing in count_if operations - where edit 0 implements the feature and edit 1 tests that exact implementation."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 modifies the normalize_count_if_value function to add duration parsing logic with DURATION_PATTERN.match() and parse_duration(), which can raise InvalidQuery exceptions that get converted to InvalidSearchQuery with str(exc). Edit 1 adds a test that specifically validates this new behavior by testing that 'count_if(transaction.duration, equals, 10wow)' raises an InvalidSearchQuery with the message 'wow is not a valid duration type'. The test directly exercises the exact code path and error handling logic added in edit 0, making them part of the same micro-task of implementing and validating duration parsing functionality."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 modifies the normalize_count_if_value function to add duration parsing logic with DURATION_PATTERN.match() and parse_duration(), which can raise InvalidQuery exceptions that get converted to InvalidSearchQuery with str(exc). Edit 1 adds a test that specifically validates this new behavior by testing that 'count_if(transaction.duration, equals, 10wow)' raises an InvalidSearchQuery with the message 'wow is not a valid duration type'. The test directly exercises the exact code path and error handling logic added in edit 0, making them part of the same micro-task of implementing and validating duration parsing functionality."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 adds DURATION_PATTERN to the imports at the top of the file, while Edit 1 uses DURATION_PATTERN in the normalize_count_if_value function. The changed lines reference the exact same symbol (DURATION_PATTERN). After making either edit, the other becomes the immediate next step - if you add the import first, you can then use it in the function; if you add the usage first, you need to import it to avoid a NameError. In Python, both edits can be written and parsed in either order (the usage before import would only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 adds DURATION_PATTERN to the imports at the top of the file, while Edit 1 uses DURATION_PATTERN in the normalize_count_if_value function. The changed lines reference the exact same symbol (DURATION_PATTERN). After making either edit, the other becomes the immediate next step - if you add the import first, you can then use it in the function; if you add the usage first, you need to import it to avoid a NameError. In Python, both edits can be written and parsed in either order (the usage before import would only fail at runtime), making this a bi-directional relationship."
        }
    ],
    "allowed_init_edits": [
        2
    ]
}