{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 changes the implementation of the `state` method in `HueLightLevel` class from returning `self.sensor.lightlevel` directly to returning a calculated value `10 ** ((self.sensor.lightlevel - 1) / 10000)`. Edit 1 updates a test assertion for the same light level sensor's state from expecting '0' to expecting '1.0'. These edits are bi-directional because they both reference the exact same method's behavior - the test is asserting on the state property of the same HueLightLevel sensor that was modified in edit 0. The implementation change necessitates updating the test expectation, and either edit could be made first since both can be parsed and staged independently (the test would just fail until both changes are complete)."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 changes the implementation of the `state` method in `HueLightLevel` class from returning `self.sensor.lightlevel` directly to returning a calculated value `10 ** ((self.sensor.lightlevel - 1) / 10000)`. Edit 1 updates a test assertion for the same light level sensor's state from expecting '0' to expecting '1.0'. These edits are bi-directional because they both reference the exact same method's behavior - the test is asserting on the state property of the same HueLightLevel sensor that was modified in edit 0. The implementation change necessitates updating the test expectation, and either edit could be made first since both can be parsed and staged independently (the test would just fail until both changes are complete)."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Edit 0 changes the implementation of the `state` method in `HueLightLevel` class from returning `self.sensor.lightlevel` directly to returning a calculated value `10 ** ((self.sensor.lightlevel - 1) / 10000)`. Edit 1 updates a test assertion for `light_level_sensor_2.state` from expecting '100' to expecting '10.0'. These edits are bi-directional neighbours because they both reference the exact same functionality - the state property of the light level sensor. The implementation change in edit 0 directly necessitates updating the test expectation in edit 1 to match the new calculated return value, and vice versa - if the test expectation changes, the implementation must be updated accordingly. This is a classic test-production code synchronization where both edits reference the same method's behavior."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Edit 0 changes the implementation of the `state` method in `HueLightLevel` class from returning `self.sensor.lightlevel` directly to returning a calculated value `10 ** ((self.sensor.lightlevel - 1) / 10000)`. Edit 1 updates a test assertion for `light_level_sensor_2.state` from expecting '100' to expecting '10.0'. These edits are bi-directional neighbours because they both reference the exact same functionality - the state property of the light level sensor. The implementation change in edit 0 directly necessitates updating the test expectation in edit 1 to match the new calculated return value, and vice versa - if the test expectation changes, the implementation must be updated accordingly. This is a classic test-production code synchronization where both edits reference the same method's behavior."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (changing 'lightlevel': 0 to 'lightlevel': 1) on the same type of syntactic construct (dictionary value assignments within 'state' dictionaries). This appears to be part of a single, contiguous refactor or search-and-replace operation within the same test file. The edits represent a bulk uniform substitution pattern where the same change is being applied to multiple test data structures."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution (changing 'lightlevel': 0 to 'lightlevel': 1) on the same type of syntactic construct (dictionary value assignments within 'state' dictionaries). This appears to be part of a single, contiguous refactor or search-and-replace operation within the same test file. The edits represent a bulk uniform substitution pattern where the same change is being applied to multiple test data structures."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits modify test data related to the same lightlevel sensor test. Edit 0 changes the mock data's lightlevel value from 0 to 1, and Edit 1 updates the corresponding test assertion to expect '1.0' instead of '0'. These edits reference the same test scenario and the same lightlevel property - the mock data change creates an immediate need to update the assertion that validates against that data. This is a direct test data synchronization where both changed lines relate to the exact same lightlevel value being tested."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits modify test data related to the same lightlevel sensor test. Edit 0 changes the mock data's lightlevel value from 0 to 1, and Edit 1 updates the corresponding test assertion to expect '1.0' instead of '0'. These edits reference the same test scenario and the same lightlevel property - the mock data change creates an immediate need to update the assertion that validates against that data. This is a direct test data synchronization where both changed lines relate to the exact same lightlevel value being tested."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits are part of the same test file and appear to be updating test data and corresponding assertions for the same light level sensor test. Edit 0 changes the mock data's 'lightlevel' value from 0 to 1, and Edit 1 updates the corresponding assertion to expect '1.0' instead of '0'. These edits reference the same conceptual entity (light level value) and form a synchronized test data/assertion pair where changing the mock data naturally prompts updating the corresponding assertion. Both edits can be made in either order since they are both valid Python code that will parse successfully."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits are part of the same test file and appear to be updating test data and corresponding assertions for the same light level sensor test. Edit 0 changes the mock data's 'lightlevel' value from 0 to 1, and Edit 1 updates the corresponding assertion to expect '1.0' instead of '0'. These edits reference the same conceptual entity (light level value) and form a synchronized test data/assertion pair where changing the mock data naturally prompts updating the corresponding assertion. Both edits can be made in either order since they are both valid Python code that will parse successfully."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits are changing test assertions for light level sensor states within the same test function. They follow an identical pattern of changing string values to float string representations ('0' to '1.0' and '100' to '10.0'). This appears to be part of a single, contiguous refactoring task to update expected sensor state formats from integers to floats. The edits are structurally identical substitutions on the same type of syntactic construct (test assertions) and would naturally be performed together as part of the same micro-task."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits are changing test assertions for light level sensor states within the same test function. They follow an identical pattern of changing string values to float string representations ('0' to '1.0' and '100' to '10.0'). This appears to be part of a single, contiguous refactoring task to update expected sensor state formats from integers to floats. The edits are structurally identical substitutions on the same type of syntactic construct (test assertions) and would naturally be performed together as part of the same micro-task."
        }
    ],
    "allowed_init_edits": [
        0,
        3
    ]
}