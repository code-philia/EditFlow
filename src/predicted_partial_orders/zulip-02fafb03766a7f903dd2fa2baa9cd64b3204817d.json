{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 1 renames a class from 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict', and Edit 0 imports this exact same renamed class 'APIScheduledStreamMessageDict'. The changed lines reference the exact same symbol - the class being renamed in Edit 1 is the same class being imported in Edit 0. After renaming the class in Edit 1, the import in Edit 0 becomes the immediate next step to use the newly renamed class. This is a classic definition-usage relationship where both edits reference the same symbol."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 1 renames a class from 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict', and Edit 0 imports this exact same renamed class 'APIScheduledStreamMessageDict'. The changed lines reference the exact same symbol - the class being renamed in Edit 1 is the same class being imported in Edit 0. After renaming the class in Edit 1, the import in Edit 0 becomes the immediate next step to use the newly renamed class. This is a classic definition-usage relationship where both edits reference the same symbol."
        },
        {
            "src": 0,
            "tgt": 7,
            "reason": "Both edits involve renaming the exact same symbol 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. Edit 0 changes the import statement to import the new name, while Edit 1 changes the usage/return statement to use the new name. This is a classic definition-usage relationship where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a rename refactor. The relationship is bi-directional because in Python, both the import and usage can be staged in either order without causing parse errors (only potential runtime NameError)."
        },
        {
            "src": 7,
            "tgt": 0,
            "reason": "Both edits involve renaming the exact same symbol 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. Edit 0 changes the import statement to import the new name, while Edit 1 changes the usage/return statement to use the new name. This is a classic definition-usage relationship where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a rename refactor. The relationship is bi-directional because in Python, both the import and usage can be staged in either order without causing parse errors (only potential runtime NameError)."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'DirectScheduledMessageAPI' in their changed lines. Edit 0 changes the import statement from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict', while Edit 1 changes the type annotation usage from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. This is a classic definition-usage relationship where the import defines what symbol is available and the type annotation uses that symbol. In Python, both edits can be staged in either order since type annotations don't cause parse errors when referencing undefined symbols (they only cause runtime errors during type checking). After making either edit, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'DirectScheduledMessageAPI' in their changed lines. Edit 0 changes the import statement from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict', while Edit 1 changes the type annotation usage from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. This is a classic definition-usage relationship where the import defines what symbol is available and the type annotation uses that symbol. In Python, both edits can be staged in either order since type annotations don't cause parse errors when referencing undefined symbols (they only cause runtime errors during type checking). After making either edit, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol: DirectScheduledMessageAPI is being renamed to APIScheduledDirectMessageDict. Edit 1 changes the class definition, and Edit 0 updates the import statement to use the new name. These edits reference the same symbol and either can be made first - the import will work with either name as long as the corresponding class exists. This is a bi-directional relationship because both edits are part of a single rename refactoring operation where the changed lines reference the exact same symbol."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol: DirectScheduledMessageAPI is being renamed to APIScheduledDirectMessageDict. Edit 1 changes the class definition, and Edit 0 updates the import statement to use the new name. These edits reference the same symbol and either can be made first - the import will work with either name as long as the corresponding class exists. This is a bi-directional relationship because both edits are part of a single rename refactoring operation where the changed lines reference the exact same symbol."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits perform identical textual substitutions on the same type of syntactic construct (type annotations). Edit 0 changes 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' in an import statement, while Edit 1 changes the same symbol name in a type annotation from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. Additionally, both edits add 'APIScheduledStreamMessageDict' in the same pattern. This represents a uniform refactoring operation where the same before\u2192after pattern is being applied to the same type of syntactic construct across multiple locations. The edits reference the exact same symbols and are clearly part of a single, contiguous rename/refactor operation."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits perform identical textual substitutions on the same type of syntactic construct (type annotations). Edit 0 changes 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' in an import statement, while Edit 1 changes the same symbol name in a type annotation from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. Additionally, both edits add 'APIScheduledStreamMessageDict' in the same pattern. This represents a uniform refactoring operation where the same before\u2192after pattern is being applied to the same type of syntactic construct across multiple locations. The edits reference the exact same symbols and are clearly part of a single, contiguous rename/refactor operation."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits are part of the same import statement block and involve renaming/removing related API classes. Edit 0 renames 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' and adds 'APIScheduledStreamMessageDict', while Edit 1 removes 'StreamScheduledMessageAPI'. These appear to be part of a coordinated refactoring of the scheduled message API classes, where the old naming convention (ending with 'API') is being replaced with a new one (starting with 'API' and ending with 'Dict'). Both edits modify the same import statement and are part of the same structural change, making them part of a single, contiguous refactoring task. Either edit can be applied first without causing parse errors, as they are independent import modifications."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits are part of the same import statement block and involve renaming/removing related API classes. Edit 0 renames 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' and adds 'APIScheduledStreamMessageDict', while Edit 1 removes 'StreamScheduledMessageAPI'. These appear to be part of a coordinated refactoring of the scheduled message API classes, where the old naming convention (ending with 'API') is being replaced with a new one (starting with 'API' and ending with 'Dict'). Both edits modify the same import statement and are part of the same structural change, making them part of a single, contiguous refactoring task. Either edit can be applied first without causing parse errors, as they are independent import modifications."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 removes the import of 'StreamScheduledMessageAPI' from the imports section, while Edit 1 removes the usage of 'StreamScheduledMessageAPI' in a type annotation and replaces it with a different type. Both edits reference the exact same symbol 'StreamScheduledMessageAPI' - one removes its import and the other removes its usage. This creates a direct code dependency where removing the import (Edit 0) makes the usage (Edit 1) invalid, but both edits can be staged in either order since Python allows referencing undefined symbols at parse time (they only fail at runtime/import time). This is a bi-directional relationship as either edit naturally prompts the other as the next mechanical step in removing this symbol from the codebase."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 removes the import of 'StreamScheduledMessageAPI' from the imports section, while Edit 1 removes the usage of 'StreamScheduledMessageAPI' in a type annotation and replaces it with a different type. Both edits reference the exact same symbol 'StreamScheduledMessageAPI' - one removes its import and the other removes its usage. This creates a direct code dependency where removing the import (Edit 0) makes the usage (Edit 1) invalid, but both edits can be staged in either order since Python allows referencing undefined symbols at parse time (they only fail at runtime/import time). This is a bi-directional relationship as either edit naturally prompts the other as the next mechanical step in removing this symbol from the codebase."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'DirectScheduledMessageAPI' in their changed lines. Edit 0 changes the import from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict', while Edit 1 changes the type annotation from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. This is a classic definition-usage relationship where the import defines what symbol is available and the type annotation uses that symbol. After making either edit, the other becomes the immediate next step to maintain code consistency - if you change the import without updating the usage, you get a NameError at runtime, and if you change the usage without updating the import, you reference an undefined symbol. Since Python allows both edits to be parsed and staged in either order (the error only occurs at runtime/import time), this is bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'DirectScheduledMessageAPI' in their changed lines. Edit 0 changes the import from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict', while Edit 1 changes the type annotation from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. This is a classic definition-usage relationship where the import defines what symbol is available and the type annotation uses that symbol. After making either edit, the other becomes the immediate next step to maintain code consistency - if you change the import without updating the usage, you get a NameError at runtime, and if you change the usage without updating the import, you reference an undefined symbol. Since Python allows both edits to be parsed and staged in either order (the error only occurs at runtime/import time), this is bi-directional rather than ordered."
        },
        {
            "src": 0,
            "tgt": 8,
            "reason": "Both edits involve renaming the exact same symbol 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' and 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict'. Edit 0 updates the import statement to use the new names, while Edit 1 updates the usage of one of these symbols in a return statement. This is a classic definition-usage relationship where both edits reference the exact same symbols and are part of a coordinated rename refactor. After making either edit, the other becomes immediately necessary to maintain code consistency and avoid NameError at runtime. Since Python allows referencing undefined symbols at parse time (they only fail at runtime/import), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 8,
            "tgt": 0,
            "reason": "Both edits involve renaming the exact same symbol 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' and 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict'. Edit 0 updates the import statement to use the new names, while Edit 1 updates the usage of one of these symbols in a return statement. This is a classic definition-usage relationship where both edits reference the exact same symbols and are part of a coordinated rename refactor. After making either edit, the other becomes immediately necessary to maintain code consistency and avoid NameError at runtime. Since Python allows referencing undefined symbols at parse time (they only fail at runtime/import), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 1 renames the class from 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict', while Edit 0 removes the import of 'StreamScheduledMessageAPI'. These edits reference the exact same symbol - the class being renamed in Edit 1 is the same class being removed from the import in Edit 0. After renaming the class, the old import name becomes invalid and must be removed, making Edit 0 the immediate next step after Edit 1. Both edits can be staged in either order without parser errors, but they form a natural bi-directional relationship where either edit prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 1 renames the class from 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict', while Edit 0 removes the import of 'StreamScheduledMessageAPI'. These edits reference the exact same symbol - the class being renamed in Edit 1 is the same class being removed from the import in Edit 0. After renaming the class, the old import name becomes invalid and must be removed, making Edit 0 the immediate next step after Edit 1. Both edits can be staged in either order without parser errors, but they form a natural bi-directional relationship where either edit prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'DirectScheduledMessageAPI' which is being renamed to 'APIScheduledDirectMessageDict'. Edit 1 changes the class definition while edit 0 updates the type annotation that references this class. This is a classic definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step to maintain code consistency."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'DirectScheduledMessageAPI' which is being renamed to 'APIScheduledDirectMessageDict'. Edit 1 changes the class definition while edit 0 updates the type annotation that references this class. This is a classic definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step to maintain code consistency."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'StreamScheduledMessageAPI' which is being renamed to 'APIScheduledStreamMessageDict'. Edit 1 changes the class definition, while edit 0 updates the type annotation that references this class. This is a classic definition-usage relationship where both edits reference the same symbol. In Python, type annotations are processed at parse time, so either edit can be made first without causing a syntax error - the other would just result in a NameError at runtime/import time. This makes it bi-directional rather than ordered."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'StreamScheduledMessageAPI' which is being renamed to 'APIScheduledStreamMessageDict'. Edit 1 changes the class definition, while edit 0 updates the type annotation that references this class. This is a classic definition-usage relationship where both edits reference the same symbol. In Python, type annotations are processed at parse time, so either edit can be made first without causing a syntax error - the other would just result in a NameError at runtime/import time. This makes it bi-directional rather than ordered."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits perform identical textual substitutions on the same type of syntactic construct (function return type annotations). Edit 0 changes 'DirectScheduledMessageAPI, StreamScheduledMessageAPI' to 'APIScheduledDirectMessageDict, APIScheduledStreamMessageDict' in a function signature, and Edit 1 makes the exact same substitution pattern in another function signature. This is a uniform bulk substitution where both edits apply the same before\u2192after pattern to the same construct type (type annotations), making them part of a single contiguous refactoring operation where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitutions on the same type of syntactic construct (function return type annotations). Edit 0 changes 'DirectScheduledMessageAPI, StreamScheduledMessageAPI' to 'APIScheduledDirectMessageDict, APIScheduledStreamMessageDict' in a function signature, and Edit 1 makes the exact same substitution pattern in another function signature. This is a uniform bulk substitution where both edits apply the same before\u2192after pattern to the same construct type (type annotations), making them part of a single contiguous refactoring operation where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Both edits are performing identical textual substitutions as part of a coordinated refactoring: Edit 0 changes 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' in a return type annotation, while Edit 1 changes 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' in a return statement. This represents a uniform rename/refactoring operation where the same type name is being changed consistently across the codebase. Both edits reference the exact same symbol (DirectScheduledMessageAPI) and perform the same before\u2192after pattern substitution. Either edit can be made first, and after making either one, the other becomes an immediate next step to maintain consistency in the refactoring."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Both edits are performing identical textual substitutions as part of a coordinated refactoring: Edit 0 changes 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' in a return type annotation, while Edit 1 changes 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' in a return statement. This represents a uniform rename/refactoring operation where the same type name is being changed consistently across the codebase. Both edits reference the exact same symbol (DirectScheduledMessageAPI) and perform the same before\u2192after pattern substitution. Either edit can be made first, and after making either one, the other becomes an immediate next step to maintain consistency in the refactoring."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitution of the same type annotation pattern within the same function. Edit 0 changes the return type annotation from 'DirectScheduledMessageAPI, StreamScheduledMessageAPI' to 'APIScheduledDirectMessageDict, APIScheduledStreamMessageDict', and Edit 1 makes the exact same substitution on a variable type annotation. This is a uniform refactoring pattern where the same type names are being consistently renamed throughout the function. Both edits reference the exact same symbols (the type names) and represent a single, contiguous refactoring task where either edit naturally prompts the other as the next mechanical step to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitution of the same type annotation pattern within the same function. Edit 0 changes the return type annotation from 'DirectScheduledMessageAPI, StreamScheduledMessageAPI' to 'APIScheduledDirectMessageDict, APIScheduledStreamMessageDict', and Edit 1 makes the exact same substitution on a variable type annotation. This is a uniform refactoring pattern where the same type names are being consistently renamed throughout the function. Both edits reference the exact same symbols (the type names) and represent a single, contiguous refactoring task where either edit naturally prompts the other as the next mechanical step to maintain consistency."
        },
        {
            "src": 2,
            "tgt": 8,
            "reason": "Both edits are performing identical textual substitutions as part of a coordinated refactoring. Edit 0 changes 'DirectScheduledMessageAPI, StreamScheduledMessageAPI' to 'APIScheduledDirectMessageDict, APIScheduledStreamMessageDict' in a function return type annotation. Edit 1 changes 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict' in a return statement. These are part of the same bulk rename operation where the API type names are being systematically changed across the codebase. Both edits involve the same type of syntactic construct (type references) and follow the same before\u2192after pattern (old API type names \u2192 new API type names). Either edit can be made first as both are valid Python code that will parse correctly, and making either edit creates an immediate prompt to complete the remaining instances of the same substitution pattern."
        },
        {
            "src": 8,
            "tgt": 2,
            "reason": "Both edits are performing identical textual substitutions as part of a coordinated refactoring. Edit 0 changes 'DirectScheduledMessageAPI, StreamScheduledMessageAPI' to 'APIScheduledDirectMessageDict, APIScheduledStreamMessageDict' in a function return type annotation. Edit 1 changes 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict' in a return statement. These are part of the same bulk rename operation where the API type names are being systematically changed across the codebase. Both edits involve the same type of syntactic construct (type references) and follow the same before\u2192after pattern (old API type names \u2192 new API type names). Either edit can be made first as both are valid Python code that will parse correctly, and making either edit creates an immediate prompt to complete the remaining instances of the same substitution pattern."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'StreamScheduledMessageAPI' which is being renamed to 'APIScheduledStreamMessageDict'. Edit 1 changes the class definition/name, while Edit 0 updates the type annotation that references this same class. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain code consistency. The changed lines in both edits explicitly reference the same symbol, making this a bi-directional relationship where either edit can be made first and naturally prompts the other."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'StreamScheduledMessageAPI' which is being renamed to 'APIScheduledStreamMessageDict'. Edit 1 changes the class definition/name, while Edit 0 updates the type annotation that references this same class. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain code consistency. The changed lines in both edits explicitly reference the same symbol, making this a bi-directional relationship where either edit can be made first and naturally prompts the other."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 1 renames the class from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict', and Edit 0 updates the type annotation to use the new name 'APIScheduledDirectMessageDict'. Both edits reference the exact same symbol - the class being renamed. After renaming the class in Edit 1, Edit 0 becomes the immediate next step to update the type annotation to use the new name, or vice versa. This is a classic definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 1 renames the class from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict', and Edit 0 updates the type annotation to use the new name 'APIScheduledDirectMessageDict'. Both edits reference the exact same symbol - the class being renamed. After renaming the class in Edit 1, Edit 0 becomes the immediate next step to update the type annotation to use the new name, or vice versa. This is a classic definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 8,
            "reason": "Both edits reference the exact same symbol - they are renaming the class 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict'. Edit 0 changes the class definition, and edit 1 changes a usage of that class in a return statement. After making either edit, the other becomes immediately necessary to maintain code consistency, as they both reference the same symbol that is being renamed."
        },
        {
            "src": 8,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol - they are renaming the class 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict'. Edit 0 changes the class definition, and edit 1 changes a usage of that class in a return statement. After making either edit, the other becomes immediately necessary to maintain code consistency, as they both reference the same symbol that is being renamed."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "These edits are performing a synchronized type name refactoring across two files. Edit 0 changes the type annotation from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' in the return type hint, while Edit 1 changes the actual return statement from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. Both edits reference the exact same symbol (the class name being renamed) and represent identical textual substitutions (DirectScheduledMessageAPI \u2192 APIScheduledDirectMessageDict) as part of a single refactoring operation. This is a clear case of bulk-edit pattern synchronization where both edits can be applied in either order since they're both valid Python code that will parse successfully regardless of order."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "These edits are performing a synchronized type name refactoring across two files. Edit 0 changes the type annotation from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' in the return type hint, while Edit 1 changes the actual return statement from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. Both edits reference the exact same symbol (the class name being renamed) and represent identical textual substitutions (DirectScheduledMessageAPI \u2192 APIScheduledDirectMessageDict) as part of a single refactoring operation. This is a clear case of bulk-edit pattern synchronization where both edits can be applied in either order since they're both valid Python code that will parse successfully regardless of order."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform identical structural substitutions on the same type of syntactic construct (TypedDict class definitions). Edit 0 renames 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict' and edit 1 renames 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. This follows the same renaming pattern (moving 'API' to the front and changing 'API' to 'Dict') applied to related but distinct TypedDict classes. This represents a bulk refactoring operation with identical before\u2192after transformation patterns on the same construct type, making either edit a natural prompt for the other as part of the same contiguous renaming task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform identical structural substitutions on the same type of syntactic construct (TypedDict class definitions). Edit 0 renames 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict' and edit 1 renames 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. This follows the same renaming pattern (moving 'API' to the front and changing 'API' to 'Dict') applied to related but distinct TypedDict classes. This represents a bulk refactoring operation with identical before\u2192after transformation patterns on the same construct type, making either edit a natural prompt for the other as part of the same contiguous renaming task."
        },
        {
            "src": 3,
            "tgt": 8,
            "reason": "Both edits are part of the same refactoring operation that renames type aliases from 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict' and 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. Edit 0 changes the type annotation in a function signature, while Edit 1 changes the return type constructor call in the method implementation. Both edits reference the exact same symbols being renamed as part of a uniform substitution pattern. This is a synchronized bulk edit where both changes are mechanically required as part of the same refactoring operation - either edit can be made first, and after making either one, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 8,
            "tgt": 3,
            "reason": "Both edits are part of the same refactoring operation that renames type aliases from 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict' and 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. Edit 0 changes the type annotation in a function signature, while Edit 1 changes the return type constructor call in the method implementation. Both edits reference the exact same symbols being renamed as part of a uniform substitution pattern. This is a synchronized bulk edit where both changes are mechanically required as part of the same refactoring operation - either edit can be made first, and after making either one, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits change type annotations from the old type names (DirectScheduledMessageAPI, StreamScheduledMessageAPI) to new type names (APIScheduledDirectMessageDict, APIScheduledStreamMessageDict). Edit 1 changes the return type annotation of the to_dict() method, and Edit 0 changes the type annotation of a variable that stores the result of calling to_dict(). These edits reference the exact same symbols in their type annotations and represent a synchronized bulk substitution pattern - both are part of the same refactoring operation to rename these type aliases. Either edit can be made first since both are valid type annotations that will only cause issues at type-checking time, not at parse time."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits change type annotations from the old type names (DirectScheduledMessageAPI, StreamScheduledMessageAPI) to new type names (APIScheduledDirectMessageDict, APIScheduledStreamMessageDict). Edit 1 changes the return type annotation of the to_dict() method, and Edit 0 changes the type annotation of a variable that stores the result of calling to_dict(). These edits reference the exact same symbols in their type annotations and represent a synchronized bulk substitution pattern - both are part of the same refactoring operation to rename these type aliases. Either edit can be made first since both are valid type annotations that will only cause issues at type-checking time, not at parse time."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits reference the exact same symbol - the class name being renamed from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. Edit 0 changes the class definition, and edit 1 changes a usage of that class in a return statement. After making either edit, the other becomes immediately necessary to maintain code consistency, as they both reference the same symbol that is being renamed. This is a classic definition-usage relationship where both edits must be synchronized."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol - the class name being renamed from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict'. Edit 0 changes the class definition, and edit 1 changes a usage of that class in a return statement. After making either edit, the other becomes immediately necessary to maintain code consistency, as they both reference the same symbol that is being renamed. This is a classic definition-usage relationship where both edits must be synchronized."
        },
        {
            "src": 5,
            "tgt": 8,
            "reason": "Both edits are part of a coordinated renaming pattern where TypedDict class names are being changed from '*API' suffix to 'API*Dict' format. Edit 0 renames DirectScheduledMessageAPI to APIScheduledDirectMessageDict, and Edit 1 renames StreamScheduledMessageAPI to APIScheduledStreamMessageDict. These are identical textual substitutions (removing 'API' suffix and adding 'API' prefix + 'Dict' suffix) applied to the same type of syntactic construct (TypedDict class names). This represents a bulk refactoring operation that would naturally be performed as a single, contiguous task."
        },
        {
            "src": 8,
            "tgt": 5,
            "reason": "Both edits are part of a coordinated renaming pattern where TypedDict class names are being changed from '*API' suffix to 'API*Dict' format. Edit 0 renames DirectScheduledMessageAPI to APIScheduledDirectMessageDict, and Edit 1 renames StreamScheduledMessageAPI to APIScheduledStreamMessageDict. These are identical textual substitutions (removing 'API' suffix and adding 'API' prefix + 'Dict' suffix) applied to the same type of syntactic construct (TypedDict class names). This represents a bulk refactoring operation that would naturally be performed as a single, contiguous task."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbol 'DirectScheduledMessageAPI' being renamed to 'APIScheduledDirectMessageDict'. Edit 0 changes the class definition, and edit 1 updates the type annotation that references this same class. After making either edit, the other becomes immediately necessary to maintain code consistency - if you rename the class definition without updating its usage in the type annotation, you get a NameError at runtime, and vice versa. Both edits can be parsed and staged in either order since Python allows referencing undefined symbols in type annotations (they're only resolved at runtime/import time), making this a bi-directional relationship."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'DirectScheduledMessageAPI' being renamed to 'APIScheduledDirectMessageDict'. Edit 0 changes the class definition, and edit 1 updates the type annotation that references this same class. After making either edit, the other becomes immediately necessary to maintain code consistency - if you rename the class definition without updating its usage in the type annotation, you get a NameError at runtime, and vice versa. Both edits can be parsed and staged in either order since Python allows referencing undefined symbols in type annotations (they're only resolved at runtime/import time), making this a bi-directional relationship."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Both edits perform identical textual substitutions within the same method (to_dict) of the same class (ScheduledMessage). Edit 0 changes 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' and edit 1 changes 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict'. These are part of a uniform refactoring pattern where API class names are being renamed following the same before\u2192after pattern (moving 'API' prefix and changing 'API' suffix to 'Dict'). Both target the same type of syntactic construct (return statements with constructor calls) and appear to be part of a single, contiguous refactor operation. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 8,
            "tgt": 7,
            "reason": "Both edits perform identical textual substitutions within the same method (to_dict) of the same class (ScheduledMessage). Edit 0 changes 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict' and edit 1 changes 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict'. These are part of a uniform refactoring pattern where API class names are being renamed following the same before\u2192after pattern (moving 'API' prefix and changing 'API' suffix to 'Dict'). Both target the same type of syntactic construct (return statements with constructor calls) and appear to be part of a single, contiguous refactor operation. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits are part of a synchronized type name refactoring within the same method. Edit 0 changes the return type annotation from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict', and edit 1 changes the actual return statement constructor call from 'DirectScheduledMessageAPI(' to 'APIScheduledDirectMessageDict('. These edits reference the exact same symbol (the type/class name) and represent a uniform substitution pattern where the type annotation and its usage must be kept in sync. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt to update the other to maintain consistency."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits are part of a synchronized type name refactoring within the same method. Edit 0 changes the return type annotation from 'DirectScheduledMessageAPI' to 'APIScheduledDirectMessageDict', and edit 1 changes the actual return statement constructor call from 'DirectScheduledMessageAPI(' to 'APIScheduledDirectMessageDict('. These edits reference the exact same symbol (the type/class name) and represent a uniform substitution pattern where the type annotation and its usage must be kept in sync. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt to update the other to maintain consistency."
        },
        {
            "src": 6,
            "tgt": 8,
            "reason": "Both edits are part of a synchronized type name refactoring within the same method. Edit 0 changes the return type annotation from 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict', and edit 1 changes the actual return statement constructor call from 'StreamScheduledMessageAPI(' to 'APIScheduledStreamMessageDict('. These edits reference the exact same symbol (the class name being renamed) and represent a uniform substitution pattern where both the type annotation and the constructor call must be updated together for the refactoring to be complete. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain consistency."
        },
        {
            "src": 8,
            "tgt": 6,
            "reason": "Both edits are part of a synchronized type name refactoring within the same method. Edit 0 changes the return type annotation from 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict', and edit 1 changes the actual return statement constructor call from 'StreamScheduledMessageAPI(' to 'APIScheduledStreamMessageDict('. These edits reference the exact same symbol (the class name being renamed) and represent a uniform substitution pattern where both the type annotation and the constructor call must be updated together for the refactoring to be complete. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 removes the import of 'StreamScheduledMessageAPI' from the imports section, while Edit 1 removes the usage of 'StreamScheduledMessageAPI' from a type annotation in the same file. These edits reference the exact same symbol - 'StreamScheduledMessageAPI'. After making either edit, the other becomes the immediate next step to maintain code consistency. If the import is removed first, the type annotation usage becomes undefined; if the usage is removed first, the import becomes unused. Both edits can be parsed and staged in either order (Python allows undefined symbols in type annotations), making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 removes the import of 'StreamScheduledMessageAPI' from the imports section, while Edit 1 removes the usage of 'StreamScheduledMessageAPI' from a type annotation in the same file. These edits reference the exact same symbol - 'StreamScheduledMessageAPI'. After making either edit, the other becomes the immediate next step to maintain code consistency. If the import is removed first, the type annotation usage becomes undefined; if the usage is removed first, the import becomes unused. Both edits can be parsed and staged in either order (Python allows undefined symbols in type annotations), making this a bi-directional relationship."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits change references to the exact same symbol 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict'. Edit 0 renames the class definition itself, while edit 1 updates the type annotation that references this same class. This creates a direct code dependency - after renaming the class in edit 0, the type annotation in edit 1 would reference a non-existent symbol if not updated. Similarly, if edit 1 is made first, it would reference a symbol that doesn't exist until edit 0 renames it. Both edits reference the exact same symbol and either edit naturally prompts the other as the immediate next mechanical step in a single refactoring task."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits change references to the exact same symbol 'StreamScheduledMessageAPI' to 'APIScheduledStreamMessageDict'. Edit 0 renames the class definition itself, while edit 1 updates the type annotation that references this same class. This creates a direct code dependency - after renaming the class in edit 0, the type annotation in edit 1 would reference a non-existent symbol if not updated. Similarly, if edit 1 is made first, it would reference a symbol that doesn't exist until edit 0 renames it. Both edits reference the exact same symbol and either edit naturally prompts the other as the immediate next mechanical step in a single refactoring task."
        }
    ],
    "allowed_init_edits": [
        1
    ]
}