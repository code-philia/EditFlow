{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform identical import restructuring - changing from importing HTTPError directly from requests to importing both HTTPError and SSLError from requests.exceptions. This is a uniform, synchronized multi-file substitution where both edits apply the same before\u2192after pattern (moving HTTPError import and adding SSLError) to the same type of syntactic construct (import statements). The edits reference the exact same symbols (HTTPError, SSLError) and appear to be part of a single refactoring operation to standardize import paths across the codebase."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform identical import restructuring - changing from importing HTTPError directly from requests to importing both HTTPError and SSLError from requests.exceptions. This is a uniform, synchronized multi-file substitution where both edits apply the same before\u2192after pattern (moving HTTPError import and adding SSLError) to the same type of syntactic construct (import statements). The edits reference the exact same symbols (HTTPError, SSLError) and appear to be part of a single refactoring operation to standardize import paths across the codebase."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 imports SSLError and HTTPError from requests.exceptions, and Edit 1 uses these exact same imported symbols (SSLError and HTTPError) in an exception handling clause. The changed lines in both edits reference the exact same symbols - SSLError and HTTPError. After importing these symbols in Edit 0, Edit 1 becomes the immediate next step to use them in the exception handling. This is a classic import-usage pattern where both edits can be staged in either order (Python allows usage before import at parse time, only failing at runtime), making it bi-directional."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 imports SSLError and HTTPError from requests.exceptions, and Edit 1 uses these exact same imported symbols (SSLError and HTTPError) in an exception handling clause. The changed lines in both edits reference the exact same symbols - SSLError and HTTPError. After importing these symbols in Edit 0, Edit 1 becomes the immediate next step to use them in the exception handling. This is a classic import-usage pattern where both edits can be staged in either order (Python allows usage before import at parse time, only failing at runtime), making it bi-directional."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 removes the import of 'requests' module, while Edit 1 changes an exception handler from catching 'requests.HTTPError' to catching '(SSLError, HTTPError, ApiError)'. The changed line in Edit 1 references the exact same 'requests' symbol that is being removed in Edit 0. After removing the import in Edit 0, the reference to 'requests.HTTPError' in Edit 1's original code would cause a NameError at runtime. However, Edit 1 replaces this reference with different exception types that don't depend on the requests module. This creates a direct code dependency where Edit 0 (removing the import) must happen before Edit 1 (updating the exception handling) to avoid referencing an undefined symbol, even though Edit 1 removes the dependency on requests."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits add identical import statements for the same symbol 'ApiError' from 'sentry.integrations.exceptions'. This represents a bulk-edit pattern where the same import is being added to multiple files as part of a single refactoring task. The changed lines in both edits reference the exact same symbol (ApiError) through identical import statements. This creates a bi-directional relationship where either import can be added first, and both are part of the same contiguous micro-task of adding the ApiError import across the codebase."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits add identical import statements for the same symbol 'ApiError' from 'sentry.integrations.exceptions'. This represents a bulk-edit pattern where the same import is being added to multiple files as part of a single refactoring task. The changed lines in both edits reference the exact same symbol (ApiError) through identical import statements. This creates a bi-directional relationship where either import can be added first, and both are part of the same contiguous micro-task of adding the ApiError import across the codebase."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 imports ApiError from sentry.integrations.exceptions, and Edit 1 uses ApiError in an except clause. This is a classic import-usage relationship where the changed lines reference the exact same symbol (ApiError). After making the import in Edit 0, using ApiError in Edit 1 becomes the immediate next step. In Python, using an undefined symbol in an except clause is allowed at parse time and only fails at runtime with a NameError, so both edits can be staged in either order. This makes it bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 imports ApiError from sentry.integrations.exceptions, and Edit 1 uses ApiError in an except clause. This is a classic import-usage relationship where the changed lines reference the exact same symbol (ApiError). After making the import in Edit 0, using ApiError in Edit 1 becomes the immediate next step. In Python, using an undefined symbol in an except clause is allowed at parse time and only fails at runtime with a NameError, so both edits can be staged in either order. This makes it bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds ApiError to an exception handling clause, while Edit 1 imports ApiError. The changed line in Edit 0 references the exact same symbol (ApiError) that is being imported in Edit 1. This creates a direct code dependency where the import in Edit 1 makes the ApiError symbol available for use in Edit 0. However, in Python, using an undefined symbol in an exception clause is allowed at parse time and only fails at runtime with a NameError. Both edits can be written and staged in either order without causing parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds ApiError to an exception handling clause, while Edit 1 imports ApiError. The changed line in Edit 0 references the exact same symbol (ApiError) that is being imported in Edit 1. This creates a direct code dependency where the import in Edit 1 makes the ApiError symbol available for use in Edit 0. However, in Python, using an undefined symbol in an exception clause is allowed at parse time and only fails at runtime with a NameError. Both edits can be written and staged in either order without causing parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 imports ApiError from sentry.integrations.exceptions, and Edit 1 uses ApiError in the test code on line 30. This is a classic import-usage relationship where the changed lines reference the exact same symbol (ApiError). The import makes the symbol available, and the usage references that imported symbol. In Python, usage before import would cause a NameError at runtime but both edits can be parsed and staged in either order, making this bi-directional rather than ordered."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 imports ApiError from sentry.integrations.exceptions, and Edit 1 uses ApiError in the test code on line 30. This is a classic import-usage relationship where the changed lines reference the exact same symbol (ApiError). The import makes the symbol available, and the usage references that imported symbol. In Python, usage before import would cause a NameError at runtime but both edits can be parsed and staged in either order, making this bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Edit 0 changes the exception handling in the notify method to catch (SSLError, HTTPError, ApiError) instead of just HTTPError. Edit 1 updates the corresponding test to verify that all three exception types (ApiError, SSLError, HTTPError) are properly handled by the notify method. The test directly exercises the exact same exception handling code that was modified in edit 0. Both edits reference the same symbols (SSLError, HTTPError, ApiError) and the test is specifically designed to verify the behavior change made in the production code. This is a classic test-production synchronization where the test needs to be updated to match the expanded exception handling in the implementation."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 0 changes the exception handling in the notify method to catch (SSLError, HTTPError, ApiError) instead of just HTTPError. Edit 1 updates the corresponding test to verify that all three exception types (ApiError, SSLError, HTTPError) are properly handled by the notify method. The test directly exercises the exact same exception handling code that was modified in edit 0. Both edits reference the same symbols (SSLError, HTTPError, ApiError) and the test is specifically designed to verify the behavior change made in the production code. This is a classic test-production synchronization where the test needs to be updated to match the expanded exception handling in the implementation."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 imports SSLError from requests.exceptions, and Edit 1 uses SSLError in the test code. The changed lines reference the exact same symbol (SSLError) - Edit 0 makes it available via import, and Edit 1 uses it in the errors tuple. This creates an immediate code dependency where importing SSLError enables its usage in the test. Both edits also reference HTTPError, but the key relationship is established through SSLError. Either edit could be staged first in Python (usage before import would cause a runtime NameError, not a parse error), making this bi-directional."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 imports SSLError from requests.exceptions, and Edit 1 uses SSLError in the test code. The changed lines reference the exact same symbol (SSLError) - Edit 0 makes it available via import, and Edit 1 uses it in the errors tuple. This creates an immediate code dependency where importing SSLError enables its usage in the test. Both edits also reference HTTPError, but the key relationship is established through SSLError. Either edit could be staged first in Python (usage before import would cause a runtime NameError, not a parse error), making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 adds an import for 'ApiError' from 'sentry.integrations.exceptions', and Edit 1 uses 'ApiError' in the test code by creating an instance 'ApiError('The server is sad')'. The changed lines reference the exact same symbol - ApiError. Edit 0 makes the symbol available for import, and Edit 1 uses that exact symbol. This creates an immediate code dependency where using ApiError in the test requires the import to be present. However, in Python, the usage can be written before the import is added since it won't cause a parse error (only a runtime NameError when executed). Both edits can be staged in either order, making this bi-directional."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 adds an import for 'ApiError' from 'sentry.integrations.exceptions', and Edit 1 uses 'ApiError' in the test code by creating an instance 'ApiError('The server is sad')'. The changed lines reference the exact same symbol - ApiError. Edit 0 makes the symbol available for import, and Edit 1 uses that exact symbol. This creates an immediate code dependency where using ApiError in the test requires the import to be present. However, in Python, the usage can be written before the import is added since it won't cause a parse error (only a runtime NameError when executed). Both edits can be staged in either order, making this bi-directional."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}