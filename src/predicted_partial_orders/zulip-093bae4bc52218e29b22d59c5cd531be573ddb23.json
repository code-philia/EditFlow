{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the string literal \"\" (empty string) with the constant Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. Both changed lines involve the same type of syntactic construct (string comparison expressions) and appear to be part of a single, contiguous refactor to replace hardcoded empty string literals with a named constant. This creates a bulk-edit pattern where both edits apply the same before\u2192after transformation to the same construct type, making them part of a synchronized substitution sweep."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the string literal \"\" (empty string) with the constant Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. Both changed lines involve the same type of syntactic construct (string comparison expressions) and appear to be part of a single, contiguous refactor to replace hardcoded empty string literals with a named constant. This creates a bulk-edit pattern where both edits apply the same before\u2192after transformation to the same construct type, making them part of a synchronized substitution sweep."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the string literal \"\" (empty string) with the constant Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string literal comparisons with get_subdomain() results). Both edits are part of a single, contiguous refactor to replace hardcoded empty string literals with a named constant. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the string literal \"\" (empty string) with the constant Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string literal comparisons with get_subdomain() results). Both edits are part of a single, contiguous refactor to replace hardcoded empty string literals with a named constant. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded empty string \"\" with the symbolic constant Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string comparisons in conditional statements). Both changed lines reference the exact same symbol (Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) and represent a synchronized code improvement to replace magic strings with named constants. Either edit could be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 8,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded empty string \"\" with the symbolic constant Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string comparisons in conditional statements). Both changed lines reference the exact same symbol (Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) and represent a synchronized code improvement to replace magic strings with named constants. Either edit could be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded empty string \"\" with the constant Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string comparisons in conditional statements). Both changed lines reference the exact same symbol (Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) and represent a synchronized substitution that would naturally occur as part of a single, contiguous refactoring task to replace magic strings with named constants."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded empty string \"\" with the constant Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string comparisons in conditional statements). Both changed lines reference the exact same symbol (Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) and represent a synchronized substitution that would naturally occur as part of a single, contiguous refactoring task to replace magic strings with named constants."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits replace hardcoded string literals with the same constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Edit 0 replaces `not subdomain` (which checks for empty string) with `subdomain == Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`, and Edit 1 replaces `subdomain != \"\"` with `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This is a bulk uniform substitution pattern where both edits perform the identical conceptual transformation (replacing hardcoded empty string checks with a named constant) on the same type of syntactic construct (string comparison expressions). Both edits reference the exact same symbol `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN` and appear to be part of a single refactoring operation to eliminate magic strings."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits replace hardcoded string literals with the same constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Edit 0 replaces `not subdomain` (which checks for empty string) with `subdomain == Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`, and Edit 1 replaces `subdomain != \"\"` with `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This is a bulk uniform substitution pattern where both edits perform the identical conceptual transformation (replacing hardcoded empty string checks with a named constant) on the same type of syntactic construct (string comparison expressions). Both edits reference the exact same symbol `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN` and appear to be part of a single refactoring operation to eliminate magic strings."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits are part of a uniform refactoring pattern that replaces hardcoded empty string checks with a symbolic constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Edit 0 changes `get_subdomain(request) == \"\"` to `get_subdomain(request) == Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`, while Edit 1 changes `not subdomain` (which is equivalent to checking for empty string in this context) to `subdomain == Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Both edits perform the same conceptual substitution - replacing direct empty string checks with the symbolic constant - and target the same type of syntactic construct (subdomain comparison logic). This represents a synchronized, bulk refactoring operation where both changes implement identical before\u2192after patterns as part of a single contiguous refactor."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits are part of a uniform refactoring pattern that replaces hardcoded empty string checks with a symbolic constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Edit 0 changes `get_subdomain(request) == \"\"` to `get_subdomain(request) == Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`, while Edit 1 changes `not subdomain` (which is equivalent to checking for empty string in this context) to `subdomain == Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Both edits perform the same conceptual substitution - replacing direct empty string checks with the symbolic constant - and target the same type of syntactic construct (subdomain comparison logic). This represents a synchronized, bulk refactoring operation where both changes implement identical before\u2192after patterns as part of a single contiguous refactor."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 references the constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN` in its changed line, while Edit 1 adds `Realm` to the import statement. This creates a direct code dependency where Edit 1 must occur before Edit 0 can be parsed successfully, as Edit 0 references a symbol (`Realm`) that would be undefined without the import in Edit 1. Without the import, Edit 0 would cause a NameError when the code is executed or imported."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'Realm.SUBDOMAIN_FOR_ROOT_DOMAIN' in their changed lines. Edit 0 adds a comparison using this constant, while edit 1 replaces a string literal comparison with the same constant. This appears to be part of a uniform refactoring to replace hardcoded empty string checks with the named constant. Both edits can be staged in either order since they are syntactically valid independently, and either edit would prompt the other as part of the same refactoring task."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'Realm.SUBDOMAIN_FOR_ROOT_DOMAIN' in their changed lines. Edit 0 adds a comparison using this constant, while edit 1 replaces a string literal comparison with the same constant. This appears to be part of a uniform refactoring to replace hardcoded empty string checks with the named constant. Both edits can be staged in either order since they are syntactically valid independently, and either edit would prompt the other as part of the same refactoring task."
        },
        {
            "src": 0,
            "tgt": 7,
            "reason": "Both edits are performing the same type of refactoring - replacing hardcoded empty string comparisons with `get_subdomain(request)` with the constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This is a uniform substitution pattern where both edits change conditional logic that checks for the root domain subdomain. Edit 0 changes `get_subdomain(request) == \"\"` to `get_subdomain(request) == Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`, while Edit 1 changes the logic from `subdomain` (truthy check) to `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Both are part of the same refactoring effort to replace hardcoded empty string checks with a named constant, targeting the same type of syntactic construct (conditional expressions involving subdomain checks). This represents a bulk refactoring operation that would naturally be done in one contiguous micro-task."
        },
        {
            "src": 7,
            "tgt": 0,
            "reason": "Both edits are performing the same type of refactoring - replacing hardcoded empty string comparisons with `get_subdomain(request)` with the constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This is a uniform substitution pattern where both edits change conditional logic that checks for the root domain subdomain. Edit 0 changes `get_subdomain(request) == \"\"` to `get_subdomain(request) == Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`, while Edit 1 changes the logic from `subdomain` (truthy check) to `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Both are part of the same refactoring effort to replace hardcoded empty string checks with a named constant, targeting the same type of syntactic construct (conditional expressions involving subdomain checks). This represents a bulk refactoring operation that would naturally be done in one contiguous micro-task."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'Realm.SUBDOMAIN_FOR_ROOT_DOMAIN' in their changed lines. Edit 0 adds a comparison using this constant, while edit 1 replaces a string literal comparison with the same constant. This appears to be part of a uniform refactoring to replace hardcoded empty string checks with a named constant. Both edits can be staged in either order without causing parse errors, and making either edit would naturally prompt updating other similar comparisons as part of the same refactoring task."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'Realm.SUBDOMAIN_FOR_ROOT_DOMAIN' in their changed lines. Edit 0 adds a comparison using this constant, while edit 1 replaces a string literal comparison with the same constant. This appears to be part of a uniform refactoring to replace hardcoded empty string checks with a named constant. Both edits can be staged in either order without causing parse errors, and making either edit would naturally prompt updating other similar comparisons as part of the same refactoring task."
        },
        {
            "src": 1,
            "tgt": 8,
            "reason": "Both edits reference the exact same symbol 'Realm.SUBDOMAIN_FOR_ROOT_DOMAIN' in their changed lines. Edit 0 adds a comparison using this constant, while edit 1 replaces a hardcoded empty string with the same constant. This appears to be part of a refactoring to replace magic values with a named constant. Both edits can be made in either order since they don't create syntax dependencies - they're both valid substitutions that reference the same symbol and appear to be part of the same refactoring task."
        },
        {
            "src": 8,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'Realm.SUBDOMAIN_FOR_ROOT_DOMAIN' in their changed lines. Edit 0 adds a comparison using this constant, while edit 1 replaces a hardcoded empty string with the same constant. This appears to be part of a refactoring to replace magic values with a named constant. Both edits can be made in either order since they don't create syntax dependencies - they're both valid substitutions that reference the same symbol and appear to be part of the same refactoring task."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 adds 'Realm' to the import statement from zerver.models, while Edit 1 uses 'Realm.SUBDOMAIN_FOR_ROOT_DOMAIN' in a conditional check. The changed lines reference the exact same symbol 'Realm' - Edit 0 imports it and Edit 1 uses it. After importing Realm in Edit 0, using Realm.SUBDOMAIN_FOR_ROOT_DOMAIN in Edit 1 becomes the natural next step. However, in Python, the usage in Edit 1 would cause a NameError at runtime if Edit 0 hasn't been applied, but both edits can be written and parsed in either order since Python allows referencing undefined names at parse time. This creates a bi-directional relationship where either edit naturally prompts the other as the immediate next mechanical step."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 adds 'Realm' to the import statement from zerver.models, while Edit 1 uses 'Realm.SUBDOMAIN_FOR_ROOT_DOMAIN' in a conditional check. The changed lines reference the exact same symbol 'Realm' - Edit 0 imports it and Edit 1 uses it. After importing Realm in Edit 0, using Realm.SUBDOMAIN_FOR_ROOT_DOMAIN in Edit 1 becomes the natural next step. However, in Python, the usage in Edit 1 would cause a NameError at runtime if Edit 0 hasn't been applied, but both edits can be written and parsed in either order since Python allows referencing undefined names at parse time. This creates a bi-directional relationship where either edit naturally prompts the other as the immediate next mechanical step."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Edit 0 adds 'Realm' to the import statement in zerver/middleware.py, while Edit 1 uses 'Realm.SUBDOMAIN_FOR_ROOT_DOMAIN' in zerver/views/integrations.py. These edits reference the exact same symbol 'Realm' - Edit 0 makes it available by importing it, and Edit 1 uses it. However, since this is Python, the usage in Edit 1 can be written and parsed even before the import in Edit 0 exists (it would only fail at runtime with a NameError). Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Edit 0 adds 'Realm' to the import statement in zerver/middleware.py, while Edit 1 uses 'Realm.SUBDOMAIN_FOR_ROOT_DOMAIN' in zerver/views/integrations.py. These edits reference the exact same symbol 'Realm' - Edit 0 makes it available by importing it, and Edit 1 uses it. However, since this is Python, the usage in Edit 1 can be written and parsed even before the import in Edit 0 exists (it would only fail at runtime with a NameError). Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "Both edits perform the same structural substitution pattern: replacing a direct comparison with an empty string (`subdomain != \"\"` and `subdomain`) with a comparison against the same constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This represents a uniform refactoring operation where the same before\u2192after pattern is being applied to the same type of syntactic construct (subdomain comparisons) across multiple files. Both edits are part of a single, contiguous refactor to standardize how subdomain checks are performed by using a named constant instead of magic strings or implicit empty checks."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "Both edits perform the same structural substitution pattern: replacing a direct comparison with an empty string (`subdomain != \"\"` and `subdomain`) with a comparison against the same constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This represents a uniform refactoring operation where the same before\u2192after pattern is being applied to the same type of syntactic construct (subdomain comparisons) across multiple files. Both edits are part of a single, contiguous refactor to standardize how subdomain checks are performed by using a named constant instead of magic strings or implicit empty checks."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing `subdomain != \"\"` to `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This is a uniform refactoring operation replacing a hardcoded empty string with a named constant across multiple locations. Both edits target the same type of syntactic construct (conditional expressions) and apply the exact same before\u2192after transformation. This represents a bulk substitution pattern where either edit could be made first, and after making one, the other becomes an obvious next step to maintain consistency across the codebase."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing `subdomain != \"\"` to `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This is a uniform refactoring operation replacing a hardcoded empty string with a named constant across multiple locations. Both edits target the same type of syntactic construct (conditional expressions) and apply the exact same before\u2192after transformation. This represents a bulk substitution pattern where either edit could be made first, and after making one, the other becomes an obvious next step to maintain consistency across the codebase."
        },
        {
            "src": 3,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the string literal \"\" with Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string comparison expressions). Both changed lines involve the exact same substitution pattern and appear to be part of a single, contiguous refactor to replace hardcoded empty string literals with a named constant. This creates a bi-directional relationship where either edit could be made first as part of the same bulk substitution operation."
        },
        {
            "src": 8,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the string literal \"\" with Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string comparison expressions). Both changed lines involve the exact same substitution pattern and appear to be part of a single, contiguous refactor to replace hardcoded empty string literals with a named constant. This creates a bi-directional relationship where either edit could be made first as part of the same bulk substitution operation."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing `subdomain != \"\"` to `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This is a bulk refactoring operation where the same string literal is being replaced with a named constant across multiple locations. Both edits target the same type of syntactic construct (conditional expressions comparing subdomain values) and represent a single, contiguous refactoring task to replace hardcoded empty strings with a symbolic constant. Either edit could be made first, and after making one, the other would be the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing `subdomain != \"\"` to `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This is a bulk refactoring operation where the same string literal is being replaced with a named constant across multiple locations. Both edits target the same type of syntactic construct (conditional expressions comparing subdomain values) and represent a single, contiguous refactoring task to replace hardcoded empty strings with a symbolic constant. Either edit could be made first, and after making one, the other would be the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: replacing hardcoded empty string comparisons with `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Edit 0 changes `subdomain != \"\"` to `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`, and Edit 1 changes `subdomain` (which was being evaluated as truthy/falsy, equivalent to `!= \"\"`) to `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This is a uniform refactoring pattern applied to the same type of syntactic construct (subdomain comparisons) across multiple files, representing a single contiguous search-and-replace operation to eliminate magic strings."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: replacing hardcoded empty string comparisons with `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Edit 0 changes `subdomain != \"\"` to `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`, and Edit 1 changes `subdomain` (which was being evaluated as truthy/falsy, equivalent to `!= \"\"`) to `subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This is a uniform refactoring pattern applied to the same type of syntactic construct (subdomain comparisons) across multiple files, representing a single contiguous search-and-replace operation to eliminate magic strings."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution, changing the string literal \"\" to Realm.SUBDOMAIN_FOR_ROOT_DOMAIN in conditional statements. This is a uniform refactoring pattern where the same before\u2192after substitution is applied to the same type of syntactic construct (conditional expressions) across multiple files. Both changed lines reference the exact same symbol (Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) and represent a synchronized bulk edit operation that would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution, changing the string literal \"\" to Realm.SUBDOMAIN_FOR_ROOT_DOMAIN in conditional statements. This is a uniform refactoring pattern where the same before\u2192after substitution is applied to the same type of syntactic construct (conditional expressions) across multiple files. Both changed lines reference the exact same symbol (Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) and represent a synchronized bulk edit operation that would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits perform the same structural substitution pattern: replacing a direct comparison with an empty string (`subdomain != \"\"` and `subdomain`) with a comparison against the same constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This represents a uniform refactoring operation where the same before\u2192after pattern is being applied to the same type of syntactic construct (conditional expressions involving subdomain checks). Both edits are part of a single, contiguous refactor to standardize how subdomain comparisons are performed across the codebase."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits perform the same structural substitution pattern: replacing a direct comparison with an empty string (`subdomain != \"\"` and `subdomain`) with a comparison against the same constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. This represents a uniform refactoring operation where the same before\u2192after pattern is being applied to the same type of syntactic construct (conditional expressions involving subdomain checks). Both edits are part of a single, contiguous refactor to standardize how subdomain comparisons are performed across the codebase."
        },
        {
            "src": 4,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded empty string \"\" with the constant Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string comparison expressions) across multiple files. Both changed lines reference the exact same symbol (Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) and represent a synchronized code improvement to replace magic strings with named constants. Either edit could be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 8,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded empty string \"\" with the constant Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string comparison expressions) across multiple files. Both changed lines reference the exact same symbol (Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) and represent a synchronized code improvement to replace magic strings with named constants. Either edit could be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 6,
            "tgt": 8,
            "reason": "Edit 0 imports the Realm class, and Edit 1 uses that exact same Realm class (specifically Realm.SUBDOMAIN_FOR_ROOT_DOMAIN). The changed lines reference the exact same symbol - the Realm class. After importing Realm in Edit 0, Edit 1 becomes the immediate next step to use that imported symbol. This is a classic import-usage pattern within the same file where both edits reference the same symbol."
        },
        {
            "src": 8,
            "tgt": 6,
            "reason": "Edit 0 imports the Realm class, and Edit 1 uses that exact same Realm class (specifically Realm.SUBDOMAIN_FOR_ROOT_DOMAIN). The changed lines reference the exact same symbol - the Realm class. After importing Realm in Edit 0, Edit 1 becomes the immediate next step to use that imported symbol. This is a classic import-usage pattern within the same file where both edits reference the same symbol."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 imports the Realm class, and Edit 1 uses that exact same Realm class (specifically Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) in the changed lines. This creates a direct import-usage relationship where the imported symbol is immediately referenced. After making the import in Edit 0, using Realm in Edit 1 becomes the natural next step. Conversely, if Edit 1 were made first, it would create an undefined name error prompting the import. However, since Python allows referencing undefined names at parse time (only failing at runtime), both edits can be staged in either order, making this bi-directional."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 imports the Realm class, and Edit 1 uses that exact same Realm class (specifically Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) in the changed lines. This creates a direct import-usage relationship where the imported symbol is immediately referenced. After making the import in Edit 0, using Realm in Edit 1 becomes the natural next step. Conversely, if Edit 1 were made first, it would create an undefined name error prompting the import. However, since Python allows referencing undefined names at parse time (only failing at runtime), both edits can be staged in either order, making this bi-directional."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Both edits are part of a uniform substitution pattern within the same function, replacing hardcoded empty string comparisons with the constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Edit 0 changes the condition from checking if subdomain is truthy to comparing it against the constant, while Edit 1 changes a direct string comparison to use the same constant. Both edits reference the exact same symbol `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN` and represent identical refactoring operations (replacing hardcoded values with a named constant) on the same type of syntactic construct (conditional expressions). This is a clear case of bulk-edit pattern synchronization where both edits can be applied in either order as part of the same contiguous refactoring task."
        },
        {
            "src": 8,
            "tgt": 7,
            "reason": "Both edits are part of a uniform substitution pattern within the same function, replacing hardcoded empty string comparisons with the constant `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN`. Edit 0 changes the condition from checking if subdomain is truthy to comparing it against the constant, while Edit 1 changes a direct string comparison to use the same constant. Both edits reference the exact same symbol `Realm.SUBDOMAIN_FOR_ROOT_DOMAIN` and represent identical refactoring operations (replacing hardcoded values with a named constant) on the same type of syntactic construct (conditional expressions). This is a clear case of bulk-edit pattern synchronization where both edits can be applied in either order as part of the same contiguous refactoring task."
        },
        {
            "src": 5,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the string literal \"\" with Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string comparison expressions) across multiple files. Both changed lines reference the exact same symbol (Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) and represent a synchronized multi-file substitution that would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 8,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the string literal \"\" with Realm.SUBDOMAIN_FOR_ROOT_DOMAIN. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string comparison expressions) across multiple files. Both changed lines reference the exact same symbol (Realm.SUBDOMAIN_FOR_ROOT_DOMAIN) and represent a synchronized multi-file substitution that would naturally occur as part of a single, contiguous refactoring task."
        }
    ],
    "allowed_init_edits": [
        2,
        6
    ]
}