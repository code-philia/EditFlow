{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits modify the same logger.error() call within the same function _async_loop_exception_handler. Edit 0 adds context.get('task') as an additional argument to the logging call, while Edit 1 updates the format string from 'Error doing job: %s' to 'Error doing job: %s (%s)' to accommodate the additional argument. These edits reference the exact same logger.error statement and form a direct code dependency - adding an argument requires updating the format string to match. Either edit creates an immediate, mechanically obvious prompt for the other as the next step to maintain proper logging format consistency."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits modify the same logger.error() call within the same function _async_loop_exception_handler. Edit 0 adds context.get('task') as an additional argument to the logging call, while Edit 1 updates the format string from 'Error doing job: %s' to 'Error doing job: %s (%s)' to accommodate the additional argument. These edits reference the exact same logger.error statement and form a direct code dependency - adding an argument requires updating the format string to match. Either edit creates an immediate, mechanically obvious prompt for the other as the next step to maintain proper logging format consistency."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits add the exact same line 'context.get(\"task\")' to the same logger.error() call within the same function _async_loop_exception_handler. The structural paths show these are two different branches of the same conditional logging statement (one with stack_summary, one without). This is a synchronized pattern addition where the same parameter is being added to parallel logging calls in the same function context. Both edits reference the same 'context' parameter and add identical functionality, making this a mirrored structural change within the same function scope."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits add the exact same line 'context.get(\"task\")' to the same logger.error() call within the same function _async_loop_exception_handler. The structural paths show these are two different branches of the same conditional logging statement (one with stack_summary, one without). This is a synchronized pattern addition where the same parameter is being added to parallel logging calls in the same function context. Both edits reference the same 'context' parameter and add identical functionality, making this a mirrored structural change within the same function scope."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits modify the same logger.error() call within the same function. Edit 0 changes the format string from 2 placeholders to 3 placeholders ('Error doing job: %s: %s' to 'Error doing job: %s (%s): %s'), and Edit 1 adds the corresponding third argument (context.get('task')) to match the new format string. The changed lines reference the exact same logger.error call, and making either edit creates an immediate code-driven prompt for the other - adding a placeholder requires adding the corresponding argument, and vice versa. This is a direct syntactic dependency where both edits must be applied together for the code to function correctly."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits modify the same logger.error() call within the same function. Edit 0 changes the format string from 2 placeholders to 3 placeholders ('Error doing job: %s: %s' to 'Error doing job: %s (%s): %s'), and Edit 1 adds the corresponding third argument (context.get('task')) to match the new format string. The changed lines reference the exact same logger.error call, and making either edit creates an immediate code-driven prompt for the other - adding a placeholder requires adding the corresponding argument, and vice versa. This is a direct syntactic dependency where both edits must be applied together for the code to function correctly."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits are making identical structural changes to logger.error format strings within the same function (_async_loop_exception_handler). Edit 0 changes 'Error doing job: %s: %s' to 'Error doing job: %s (%s): %s' and Edit 1 changes 'Error doing job: %s' to 'Error doing job: %s (%s)'. Both are adding '(%s)' to their respective format strings in a uniform pattern. This represents a bulk-edit pattern where the same textual substitution (adding '(%s)' after the first %s) is being applied to the same type of syntactic construct (logger.error format strings) within the same function context. This is clearly part of a single, contiguous refactor to standardize the error message format."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits are making identical structural changes to logger.error format strings within the same function (_async_loop_exception_handler). Edit 0 changes 'Error doing job: %s: %s' to 'Error doing job: %s (%s): %s' and Edit 1 changes 'Error doing job: %s' to 'Error doing job: %s (%s)'. Both are adding '(%s)' to their respective format strings in a uniform pattern. This represents a bulk-edit pattern where the same textual substitution (adding '(%s)' after the first %s) is being applied to the same type of syntactic construct (logger.error format strings) within the same function context. This is clearly part of a single, contiguous refactor to standardize the error message format."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits modify the same logger.error() call within the same function. Edit 0 changes the format string from 2 placeholders to 3 placeholders ('Error doing job: %s: %s' to 'Error doing job: %s (%s): %s'), and Edit 1 adds the corresponding third argument 'context.get(\"task\")' to match the new format string. These edits reference the exact same logger.error statement and create a direct syntactic dependency - the format string change creates an immediate need for the matching argument, making them part of a single contiguous micro-task. Either edit can be made first without causing a parse error, but after making either edit, the other becomes the mechanically obvious next step to maintain the format string/argument alignment."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits modify the same logger.error() call within the same function. Edit 0 changes the format string from 2 placeholders to 3 placeholders ('Error doing job: %s: %s' to 'Error doing job: %s (%s): %s'), and Edit 1 adds the corresponding third argument 'context.get(\"task\")' to match the new format string. These edits reference the exact same logger.error statement and create a direct syntactic dependency - the format string change creates an immediate need for the matching argument, making them part of a single contiguous micro-task. Either edit can be made first without causing a parse error, but after making either edit, the other becomes the mechanically obvious next step to maintain the format string/argument alignment."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits modify the same logger.error() call within the same function. Edit 0 changes the format string from '%s' to '%s (%s)' to accommodate an additional parameter, and edit 1 adds that additional parameter 'context.get(\"task\")'. These edits are directly linked - the format string change creates an immediate need for the additional parameter to match the format placeholders. Either edit can be made first (both are syntactically valid), but after making either edit, the other becomes the immediate next step to complete the logging statement modification."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits modify the same logger.error() call within the same function. Edit 0 changes the format string from '%s' to '%s (%s)' to accommodate an additional parameter, and edit 1 adds that additional parameter 'context.get(\"task\")'. These edits are directly linked - the format string change creates an immediate need for the additional parameter to match the format placeholders. Either edit can be made first (both are syntactically valid), but after making either edit, the other becomes the immediate next step to complete the logging statement modification."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 adds a name parameter 'name_of_task' to the asyncio.create_task() call, and Edit 1 adds an assertion to verify that 'name_of_task' appears in the captured log text. Both edits reference the exact same string literal 'name_of_task' - one edit introduces it as a task name, and the other edit tests for its presence in the logs. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step within the same test function. The relationship is bi-directional because both edits can be staged in either order without causing parse errors, and both reference the same literal value."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 adds a name parameter 'name_of_task' to the asyncio.create_task() call, and Edit 1 adds an assertion to verify that 'name_of_task' appears in the captured log text. Both edits reference the exact same string literal 'name_of_task' - one edit introduces it as a task name, and the other edit tests for its presence in the logs. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step within the same test function. The relationship is bi-directional because both edits can be staged in either order without causing parse errors, and both reference the same literal value."
        }
    ],
    "allowed_init_edits": [
        4,
        5
    ]
}