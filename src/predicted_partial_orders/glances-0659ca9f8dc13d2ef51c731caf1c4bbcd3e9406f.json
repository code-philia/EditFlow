{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 adds the instance variable 'self.no_kernel_threads = False' in what appears to be the constructor/initialization method. Edit 1 adds a method 'disable_kernel_threads()' that sets 'self.no_kernel_threads = True'. Both edits reference the exact same symbol (the instance variable self.no_kernel_threads). After adding the instance variable in edit 0, adding a method that manipulates that variable becomes a natural next step. Similarly, after adding the method in edit 1, having the instance variable it references becomes necessary. This is a bi-directional definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 adds the instance variable 'self.no_kernel_threads = False' in what appears to be the constructor/initialization method. Edit 1 adds a method 'disable_kernel_threads()' that sets 'self.no_kernel_threads = True'. Both edits reference the exact same symbol (the instance variable self.no_kernel_threads). After adding the instance variable in edit 0, adding a method that manipulates that variable becomes a natural next step. Similarly, after adding the method in edit 1, having the instance variable it references becomes necessary. This is a bi-directional definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 defines the instance attribute 'self.no_kernel_threads = False' in the class constructor, and Edit 1 uses this exact same attribute in a conditional statement 'if (self.no_kernel_threads and...)'. The changed lines reference the exact same symbol - the instance attribute 'no_kernel_threads'. After defining the attribute in Edit 0, using it in Edit 1 becomes a natural next step, and vice versa - if you're using the attribute in Edit 1, you need it defined in Edit 0. This is a classic definition-usage relationship where both edits can be staged in either order (the usage won't cause a parse error, only a potential runtime AttributeError), making it bi-directional."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 defines the instance attribute 'self.no_kernel_threads = False' in the class constructor, and Edit 1 uses this exact same attribute in a conditional statement 'if (self.no_kernel_threads and...)'. The changed lines reference the exact same symbol - the instance attribute 'no_kernel_threads'. After defining the attribute in Edit 0, using it in Edit 1 becomes a natural next step, and vice versa - if you're using the attribute in Edit 1, you need it defined in Edit 0. This is a classic definition-usage relationship where both edits can be staged in either order (the usage won't cause a parse error, only a potential runtime AttributeError), making it bi-directional."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 adds a command-line argument '--hide-kernel-threads' that sets the destination 'no_kernel_threads'. Edit 1 then uses 'args.no_kernel_threads' to conditionally call 'glances_processes.disable_kernel_threads()'. This is a classic definition-usage pattern where the exact same symbol 'no_kernel_threads' is being defined in one edit and referenced in another. The changed lines reference the exact same symbol, creating an immediate code-driven linkage where defining the argument naturally prompts its usage, and using the argument requires its definition. Both edits can be staged in either order without parser errors (the usage would only fail at runtime if the argument wasn't defined), making this bi-directional."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 adds a command-line argument '--hide-kernel-threads' that sets the destination 'no_kernel_threads'. Edit 1 then uses 'args.no_kernel_threads' to conditionally call 'glances_processes.disable_kernel_threads()'. This is a classic definition-usage pattern where the exact same symbol 'no_kernel_threads' is being defined in one edit and referenced in another. The changed lines reference the exact same symbol, creating an immediate code-driven linkage where defining the argument naturally prompts its usage, and using the argument requires its definition. Both edits can be staged in either order without parser errors (the usage would only fail at runtime if the argument wasn't defined), making this bi-directional."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 imports the symbol 'is_windows' from glances_globals, and Edit 1 uses that exact same symbol 'is_windows' in a conditional statement. This creates a direct definition-usage relationship where the import makes the symbol available for use in the same file. After making the import edit, using the symbol becomes the next natural step, and after using the symbol, ensuring it's imported becomes necessary. Both edits reference the exact same symbol and either can be staged first in Python (usage before import only causes runtime NameError, not parse error)."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 imports the symbol 'is_windows' from glances_globals, and Edit 1 uses that exact same symbol 'is_windows' in a conditional statement. This creates a direct definition-usage relationship where the import makes the symbol available for use in the same file. After making the import edit, using the symbol becomes the next natural step, and after using the symbol, ensuring it's imported becomes necessary. Both edits reference the exact same symbol and either can be staged first in Python (usage before import only causes runtime NameError, not parse error)."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 defines a new method `disable_kernel_threads` in the `GlancesProcesses` class, while Edit 1 calls this exact same method (`glances_processes.disable_kernel_threads()`). The changed lines reference the exact same symbol - the `disable_kernel_threads` method. After defining the method in Edit 0, calling it in Edit 1 becomes the immediate next step to actually use the newly created functionality. This is a classic definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 defines a new method `disable_kernel_threads` in the `GlancesProcesses` class, while Edit 1 calls this exact same method (`glances_processes.disable_kernel_threads()`). The changed lines reference the exact same symbol - the `disable_kernel_threads` method. After defining the method in Edit 0, calling it in Edit 1 becomes the immediate next step to actually use the newly created functionality. This is a classic definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 defines a method `disable_kernel_threads()` that sets the instance attribute `self.no_kernel_threads = True`. Edit 1 uses this exact same attribute `self.no_kernel_threads` in a conditional check within the `update()` method. The changed lines reference the exact same symbol (`self.no_kernel_threads`), creating a direct definition-usage relationship. After defining the attribute in edit 0, edit 1 becomes the natural next step to use that attribute, and vice versa - if you're adding the usage logic in edit 1, you need the attribute definition from edit 0. Both edits can be staged in either order without parser errors (the attribute access in edit 1 would only cause a runtime AttributeError if the attribute doesn't exist, not a parse-time error)."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 defines a method `disable_kernel_threads()` that sets the instance attribute `self.no_kernel_threads = True`. Edit 1 uses this exact same attribute `self.no_kernel_threads` in a conditional check within the `update()` method. The changed lines reference the exact same symbol (`self.no_kernel_threads`), creating a direct definition-usage relationship. After defining the attribute in edit 0, edit 1 becomes the natural next step to use that attribute, and vice versa - if you're adding the usage logic in edit 1, you need the attribute definition from edit 0. Both edits can be staged in either order without parser errors (the attribute access in edit 1 would only cause a runtime AttributeError if the attribute doesn't exist, not a parse-time error)."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}