{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:'. This is a uniform refactoring operation that removes the same conditional check across multiple files. Both edits target the same type of syntactic construct (conditional statements) and apply the exact same before\u2192after transformation. This represents a bulk edit pattern where both changes are part of a single, contiguous refactor to remove references to ZULIP_COM_STAGING throughout the codebase."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:'. This is a uniform refactoring operation that removes the same conditional check across multiple files. Both edits target the same type of syntactic construct (conditional statements) and apply the exact same before\u2192after transformation. This represents a bulk edit pattern where both changes are part of a single, contiguous refactor to remove references to ZULIP_COM_STAGING throughout the codebase."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: removing '&& not ZULIP_COM_STAGING' or 'and not ZULIP_COM_STAGING' from conditional expressions that check ZULIP_COM. This is a bulk refactoring operation where the same logical change (eliminating references to ZULIP_COM_STAGING) is being applied uniformly across multiple files. The edits target the same type of syntactic construct (boolean conditional expressions) and apply the same before\u2192after pattern. This represents a single, contiguous refactor to remove ZULIP_COM_STAGING references throughout the codebase."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: removing '&& not ZULIP_COM_STAGING' or 'and not ZULIP_COM_STAGING' from conditional expressions that check ZULIP_COM. This is a bulk refactoring operation where the same logical change (eliminating references to ZULIP_COM_STAGING) is being applied uniformly across multiple files. The edits target the same type of syntactic construct (boolean conditional expressions) and apply the same before\u2192after pattern. This represents a single, contiguous refactor to remove ZULIP_COM_STAGING references throughout the codebase."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'settings.ZULIP_COM or settings.ZULIP_COM_STAGING' to 'settings.ZULIP_COM'. This is a uniform refactoring operation that removes the same conditional check across multiple files. Both edits target the same type of syntactic construct (conditional expressions) and apply the exact same before\u2192after transformation. This represents a bulk edit pattern where either change could be made first, and after making one, the other becomes an obvious next step to maintain consistency across the codebase."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'settings.ZULIP_COM or settings.ZULIP_COM_STAGING' to 'settings.ZULIP_COM'. This is a uniform refactoring operation that removes the same conditional check across multiple files. Both edits target the same type of syntactic construct (conditional expressions) and apply the exact same before\u2192after transformation. This represents a bulk edit pattern where either change could be made first, and after making one, the other becomes an obvious next step to maintain consistency across the codebase."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:'. This is a uniform, synchronized refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (conditional statements) across multiple files. Both changed lines reference the exact same symbols (settings.ZULIP_COM and settings.ZULIP_COM_STAGING) and perform the identical transformation. This represents a single, contiguous refactoring task where either edit naturally prompts the other as part of the same search-and-replace operation."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:'. This is a uniform, synchronized refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (conditional statements) across multiple files. Both changed lines reference the exact same symbols (settings.ZULIP_COM and settings.ZULIP_COM_STAGING) and perform the identical transformation. This represents a single, contiguous refactoring task where either edit naturally prompts the other as part of the same search-and-replace operation."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "These edits are directly related through the ZULIP_COM symbol. Edit 1 changes the definition of ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM true when either prod or staging is true), while Edit 0 removes the explicit ZULIP_COM_STAGING check since it's now redundant (ZULIP_COM already covers both cases). The changed lines reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING), and making either edit creates an immediate prompt for the other to maintain logical consistency. This is a bi-directional relationship because both edits can be staged in either order without parse errors, and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "These edits are directly related through the ZULIP_COM symbol. Edit 1 changes the definition of ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM true when either prod or staging is true), while Edit 0 removes the explicit ZULIP_COM_STAGING check since it's now redundant (ZULIP_COM already covers both cases). The changed lines reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING), and making either edit creates an immediate prompt for the other to maintain logical consistency. This is a bi-directional relationship because both edits can be staged in either order without parse errors, and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "These edits are directly related through the ZULIP_COM setting. Edit 1 changes the definition of ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM true when either prod or staging), while Edit 0 removes the explicit ZULIP_COM_STAGING check since it's now redundant (ZULIP_COM will be true for staging). The changed lines reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING), and making either edit creates an immediate prompt for the other to maintain logical consistency. This is a bi-directional relationship where either edit can be made first, and the other naturally follows as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "These edits are directly related through the ZULIP_COM setting. Edit 1 changes the definition of ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM true when either prod or staging), while Edit 0 removes the explicit ZULIP_COM_STAGING check since it's now redundant (ZULIP_COM will be true for staging). The changed lines reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING), and making either edit creates an immediate prompt for the other to maintain logical consistency. This is a bi-directional relationship where either edit can be made first, and the other naturally follows as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:'. This is a uniform refactoring operation that removes the same conditional check across multiple files. Both changed lines reference the exact same symbols (settings.ZULIP_COM and settings.ZULIP_COM_STAGING) and apply the same before\u2192after pattern to the same type of syntactic construct (conditional statements). This represents a bulk edit where either change could be made first, and after making one, the other becomes an immediate next step in completing the uniform substitution across the codebase."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:'. This is a uniform refactoring operation that removes the same conditional check across multiple files. Both changed lines reference the exact same symbols (settings.ZULIP_COM and settings.ZULIP_COM_STAGING) and apply the same before\u2192after pattern to the same type of syntactic construct (conditional statements). This represents a bulk edit where either change could be made first, and after making one, the other becomes an immediate next step in completing the uniform substitution across the codebase."
        },
        {
            "src": 0,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: removing 'or ZULIP_COM_STAGING' from boolean expressions that include 'ZULIP_COM'. Edit 0 changes 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:', while Edit 1 changes 'USING_STATSD = ZULIP_COM or ZULIP_COM_STAGING or LOCAL_STATSD' to 'USING_STATSD = ZULIP_COM or LOCAL_STATSD'. This represents a bulk uniform substitution where both edits apply the same before\u2192after pattern (removing the ZULIP_COM_STAGING reference) to the same type of syntactic construct (boolean expressions). This appears to be part of a single, contiguous refactor to remove ZULIP_COM_STAGING references throughout the codebase."
        },
        {
            "src": 7,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: removing 'or ZULIP_COM_STAGING' from boolean expressions that include 'ZULIP_COM'. Edit 0 changes 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:', while Edit 1 changes 'USING_STATSD = ZULIP_COM or ZULIP_COM_STAGING or LOCAL_STATSD' to 'USING_STATSD = ZULIP_COM or LOCAL_STATSD'. This represents a bulk uniform substitution where both edits apply the same before\u2192after pattern (removing the ZULIP_COM_STAGING reference) to the same type of syntactic construct (boolean expressions). This appears to be part of a single, contiguous refactor to remove ZULIP_COM_STAGING references throughout the codebase."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: removing '|| settings.ZULIP_COM_STAGING' from conditional expressions that check 'settings.ZULIP_COM or settings.ZULIP_COM_STAGING'. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (conditional expressions) across multiple files. Both edits are part of a single, contiguous refactor to remove references to the ZULIP_COM_STAGING setting. Either edit can be made first, and after making either one, the other becomes a natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: removing '|| settings.ZULIP_COM_STAGING' from conditional expressions that check 'settings.ZULIP_COM or settings.ZULIP_COM_STAGING'. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (conditional expressions) across multiple files. Both edits are part of a single, contiguous refactor to remove references to the ZULIP_COM_STAGING setting. Either edit can be made first, and after making either one, the other becomes a natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 changes a conditional check from 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:'. Edit 1 redefines ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM = prod OR staging) and updates a related conditional from 'if not ZULIP_COM and not ZULIP_COM_STAGING:' to 'if not ZULIP_COM:'. Both edits reference the exact same symbol 'ZULIP_COM' and work together to refactor the logic - instead of checking 'ZULIP_COM or ZULIP_COM_STAGING' in multiple places, ZULIP_COM is redefined to encompass both cases. This creates a direct code dependency where both edits are part of the same refactoring pattern and either edit naturally prompts the other as the next mechanical step to maintain consistent logic."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 changes a conditional check from 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:'. Edit 1 redefines ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM = prod OR staging) and updates a related conditional from 'if not ZULIP_COM and not ZULIP_COM_STAGING:' to 'if not ZULIP_COM:'. Both edits reference the exact same symbol 'ZULIP_COM' and work together to refactor the logic - instead of checking 'ZULIP_COM or ZULIP_COM_STAGING' in multiple places, ZULIP_COM is redefined to encompass both cases. This creates a direct code dependency where both edits are part of the same refactoring pattern and either edit naturally prompts the other as the next mechanical step to maintain consistent logic."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 1 changes the definition of ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM true when either the original condition OR ZULIP_COM_STAGING is true), while Edit 0 removes the '|| settings.ZULIP_COM_STAGING' check from a conditional that uses ZULIP_COM. These edits reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING) and appear to be part of a coordinated refactor where the logic for checking staging environments is being consolidated into the ZULIP_COM definition rather than being checked separately at usage sites. After making either edit, the other becomes the immediate next step to maintain consistent behavior - if you change the definition without updating the usage, or vice versa, the logic would be inconsistent."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 1 changes the definition of ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM true when either the original condition OR ZULIP_COM_STAGING is true), while Edit 0 removes the '|| settings.ZULIP_COM_STAGING' check from a conditional that uses ZULIP_COM. These edits reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING) and appear to be part of a coordinated refactor where the logic for checking staging environments is being consolidated into the ZULIP_COM definition rather than being checked separately at usage sites. After making either edit, the other becomes the immediate next step to maintain consistent behavior - if you change the definition without updating the usage, or vice versa, the logic would be inconsistent."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: removing '&& not ZULIP_COM_STAGING' or 'and not ZULIP_COM_STAGING' from conditional expressions that check ZULIP_COM. This is a bulk refactoring operation where the same logical change (eliminating references to ZULIP_COM_STAGING) is being applied uniformly across multiple locations. The edits target the same type of syntactic construct (boolean conditional expressions) and follow the same before\u2192after pattern, making them part of a single, contiguous refactor to remove ZULIP_COM_STAGING references throughout the codebase."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: removing '&& not ZULIP_COM_STAGING' or 'and not ZULIP_COM_STAGING' from conditional expressions that check ZULIP_COM. This is a bulk refactoring operation where the same logical change (eliminating references to ZULIP_COM_STAGING) is being applied uniformly across multiple locations. The edits target the same type of syntactic construct (boolean conditional expressions) and follow the same before\u2192after pattern, making them part of a single, contiguous refactor to remove ZULIP_COM_STAGING references throughout the codebase."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'settings.ZULIP_COM or settings.ZULIP_COM_STAGING' to 'settings.ZULIP_COM' in conditional statements. This is a uniform refactoring operation targeting the same type of syntactic construct (conditional expressions) with the exact same before\u2192after pattern. Both edits appear to be part of a single, contiguous refactor to remove references to ZULIP_COM_STAGING. Either edit could be made first, and after making either one, the other would be the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'settings.ZULIP_COM or settings.ZULIP_COM_STAGING' to 'settings.ZULIP_COM' in conditional statements. This is a uniform refactoring operation targeting the same type of syntactic construct (conditional expressions) with the exact same before\u2192after pattern. Both edits appear to be part of a single, contiguous refactor to remove references to ZULIP_COM_STAGING. Either edit could be made first, and after making either one, the other would be the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Both edits perform the identical textual substitution pattern: removing '|| ZULIP_COM_STAGING' from boolean expressions that include 'ZULIP_COM or ZULIP_COM_STAGING'. This is a uniform refactoring operation where the same symbol (ZULIP_COM_STAGING) is being removed from similar conditional expressions across different files. The edits target the same type of syntactic construct (boolean expressions) and apply the exact same before\u2192after pattern. This represents a single, contiguous refactor to eliminate references to ZULIP_COM_STAGING throughout the codebase."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Both edits perform the identical textual substitution pattern: removing '|| ZULIP_COM_STAGING' from boolean expressions that include 'ZULIP_COM or ZULIP_COM_STAGING'. This is a uniform refactoring operation where the same symbol (ZULIP_COM_STAGING) is being removed from similar conditional expressions across different files. The edits target the same type of syntactic construct (boolean expressions) and apply the exact same before\u2192after pattern. This represents a single, contiguous refactor to eliminate references to ZULIP_COM_STAGING throughout the codebase."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 1 redefines ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM = prod OR staging), while Edit 0 removes the explicit ZULIP_COM_STAGING check since it's now redundant (ZULIP_COM already includes staging cases). The changed lines reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING), and these edits form a coordinated refactoring where the logic change in Edit 1 enables the simplification in Edit 0. Either edit can be made first without causing parse errors, and after making either edit, the other becomes the immediate next step to complete the refactoring."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 1 redefines ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM = prod OR staging), while Edit 0 removes the explicit ZULIP_COM_STAGING check since it's now redundant (ZULIP_COM already includes staging cases). The changed lines reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING), and these edits form a coordinated refactoring where the logic change in Edit 1 enables the simplification in Edit 0. Either edit can be made first without causing parse errors, and after making either edit, the other becomes the immediate next step to complete the refactoring."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: removing '|| ZULIP_COM_STAGING' from boolean expressions that include 'ZULIP_COM'. Edit 0 changes 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:', while Edit 1 changes 'USING_STATSD = ZULIP_COM or ZULIP_COM_STAGING or LOCAL_STATSD' to 'USING_STATSD = ZULIP_COM or LOCAL_STATSD'. This represents a bulk refactoring operation where the same pattern (removing references to ZULIP_COM_STAGING) is being applied uniformly across the codebase to the same type of syntactic construct (boolean expressions). Both edits are part of a single, contiguous refactor to eliminate ZULIP_COM_STAGING references, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: removing '|| ZULIP_COM_STAGING' from boolean expressions that include 'ZULIP_COM'. Edit 0 changes 'if settings.ZULIP_COM or settings.ZULIP_COM_STAGING:' to 'if settings.ZULIP_COM:', while Edit 1 changes 'USING_STATSD = ZULIP_COM or ZULIP_COM_STAGING or LOCAL_STATSD' to 'USING_STATSD = ZULIP_COM or LOCAL_STATSD'. This represents a bulk refactoring operation where the same pattern (removing references to ZULIP_COM_STAGING) is being applied uniformly across the codebase to the same type of syntactic construct (boolean expressions). Both edits are part of a single, contiguous refactor to eliminate ZULIP_COM_STAGING references, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: removing '&& not ZULIP_COM_STAGING' or 'or settings.ZULIP_COM_STAGING' from conditional expressions that check ZULIP_COM. This is a uniform refactoring operation where the same symbol (ZULIP_COM_STAGING) is being removed from multiple locations as part of a single cleanup task. The edits target the same type of syntactic construct (conditional expressions) and apply the identical before\u2192after pattern of removing references to ZULIP_COM_STAGING."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: removing '&& not ZULIP_COM_STAGING' or 'or settings.ZULIP_COM_STAGING' from conditional expressions that check ZULIP_COM. This is a uniform refactoring operation where the same symbol (ZULIP_COM_STAGING) is being removed from multiple locations as part of a single cleanup task. The edits target the same type of syntactic construct (conditional expressions) and apply the identical before\u2192after pattern of removing references to ZULIP_COM_STAGING."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "These edits reference the exact same symbol `ZULIP_COM` and `ZULIP_COM_STAGING`. Edit 1 changes the definition of `ZULIP_COM` to include `ZULIP_COM_STAGING`, making `ZULIP_COM` true when either condition is met. Edit 0 then removes the explicit check for `ZULIP_COM_STAGING` in the conditional, relying on the fact that `ZULIP_COM` now encompasses both cases. This creates a direct code dependency where the logic change in edit 1 enables the simplification in edit 0. The edits reference the same symbols and form a coordinated refactoring where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "These edits reference the exact same symbol `ZULIP_COM` and `ZULIP_COM_STAGING`. Edit 1 changes the definition of `ZULIP_COM` to include `ZULIP_COM_STAGING`, making `ZULIP_COM` true when either condition is met. Edit 0 then removes the explicit check for `ZULIP_COM_STAGING` in the conditional, relying on the fact that `ZULIP_COM` now encompasses both cases. This creates a direct code dependency where the logic change in edit 1 enables the simplification in edit 0. The edits reference the same symbols and form a coordinated refactoring where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 removes the reference to `settings.ZULIP_COM_STAGING` from a conditional check, keeping only `settings.ZULIP_COM`. Edit 1 modifies the definition of `settings.ZULIP_COM` to include `ZULIP_COM_STAGING` in its logic. These edits reference the exact same symbols (`settings.ZULIP_COM` and `ZULIP_COM_STAGING`) and form a coordinated refactor where the logic for handling staging deployments is moved from the usage site to the definition site. The edits are mechanically linked - after making either edit, the other becomes the immediate next step to maintain the same overall behavior. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 removes the reference to `settings.ZULIP_COM_STAGING` from a conditional check, keeping only `settings.ZULIP_COM`. Edit 1 modifies the definition of `settings.ZULIP_COM` to include `ZULIP_COM_STAGING` in its logic. These edits reference the exact same symbols (`settings.ZULIP_COM` and `ZULIP_COM_STAGING`) and form a coordinated refactor where the logic for handling staging deployments is moved from the usage site to the definition site. The edits are mechanically linked - after making either edit, the other becomes the immediate next step to maintain the same overall behavior. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: removing 'and not ZULIP_COM_STAGING' from conditional expressions that check ZULIP_COM. This is a uniform, synchronized refactoring operation where the same structural change (removing the same clause from boolean expressions) is applied to the same type of syntactic construct (conditional statements) across multiple files. The edits are part of a single, contiguous refactor to eliminate references to ZULIP_COM_STAGING. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: removing 'and not ZULIP_COM_STAGING' from conditional expressions that check ZULIP_COM. This is a uniform, synchronized refactoring operation where the same structural change (removing the same clause from boolean expressions) is applied to the same type of syntactic construct (conditional statements) across multiple files. The edits are part of a single, contiguous refactor to eliminate references to ZULIP_COM_STAGING. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 removes the reference to `settings.ZULIP_COM_STAGING` from a conditional check, keeping only `settings.ZULIP_COM`. Edit 1 modifies the definition of `ZULIP_COM` to include `ZULIP_COM_STAGING` in its logic, making `ZULIP_COM` true when either the original condition OR `ZULIP_COM_STAGING` is true. These edits reference the exact same symbols (`ZULIP_COM` and `ZULIP_COM_STAGING`) and appear to be part of a coordinated refactoring where the logic for handling staging environments is consolidated into the `ZULIP_COM` setting. The edits can be applied in either order without causing parse errors, and either edit naturally prompts the other as the next mechanical step to maintain consistent behavior."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 removes the reference to `settings.ZULIP_COM_STAGING` from a conditional check, keeping only `settings.ZULIP_COM`. Edit 1 modifies the definition of `ZULIP_COM` to include `ZULIP_COM_STAGING` in its logic, making `ZULIP_COM` true when either the original condition OR `ZULIP_COM_STAGING` is true. These edits reference the exact same symbols (`ZULIP_COM` and `ZULIP_COM_STAGING`) and appear to be part of a coordinated refactoring where the logic for handling staging environments is consolidated into the `ZULIP_COM` setting. The edits can be applied in either order without causing parse errors, and either edit naturally prompts the other as the next mechanical step to maintain consistent behavior."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: removing 'or ZULIP_COM_STAGING' from boolean expressions that include 'ZULIP_COM or ZULIP_COM_STAGING'. This is a uniform refactoring operation where the same structural change (removing the ZULIP_COM_STAGING condition) is being applied to the same type of syntactic construct (boolean expressions) across multiple files. Both edits are part of a single, contiguous refactor to eliminate references to ZULIP_COM_STAGING throughout the codebase."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: removing 'or ZULIP_COM_STAGING' from boolean expressions that include 'ZULIP_COM or ZULIP_COM_STAGING'. This is a uniform refactoring operation where the same structural change (removing the ZULIP_COM_STAGING condition) is being applied to the same type of syntactic construct (boolean expressions) across multiple files. Both edits are part of a single, contiguous refactor to eliminate references to ZULIP_COM_STAGING throughout the codebase."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual and structural substitution on the same symbol ZULIP_COM. They change the same line of code from 'ZULIP_COM = PRODUCTION and config_file.get('machine', 'deploy_type') == 'zulip.com-prod'' to 'ZULIP_COM = ((PRODUCTION and config_file.get('machine', 'deploy_type') == 'zulip.com-prod') or ZULIP_COM_STAGING)' in two different files. This is a clear case of bulk-edit pattern synchronization where the same before\u2192after pattern is applied to the same type of syntactic construct (variable assignment) across multiple files. Both edits reference the exact same symbol (ZULIP_COM) and represent a uniform, synchronized multi-file substitution that would naturally occur in one contiguous refactoring task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual and structural substitution on the same symbol ZULIP_COM. They change the same line of code from 'ZULIP_COM = PRODUCTION and config_file.get('machine', 'deploy_type') == 'zulip.com-prod'' to 'ZULIP_COM = ((PRODUCTION and config_file.get('machine', 'deploy_type') == 'zulip.com-prod') or ZULIP_COM_STAGING)' in two different files. This is a clear case of bulk-edit pattern synchronization where the same before\u2192after pattern is applied to the same type of syntactic construct (variable assignment) across multiple files. Both edits reference the exact same symbol (ZULIP_COM) and represent a uniform, synchronized multi-file substitution that would naturally occur in one contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Both edits modify code that references the exact same symbol 'ZULIP_COM'. Edit 0 changes the definition/assignment of ZULIP_COM to include ZULIP_COM_STAGING in its logic, while Edit 1 updates the usage of ZULIP_COM by removing the redundant 'or ZULIP_COM_STAGING' since ZULIP_COM now encompasses that case. The changed lines in both edits explicitly reference the same symbol 'ZULIP_COM', creating a direct code dependency where modifying the definition naturally prompts updating the usage to reflect the new logic. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Both edits modify code that references the exact same symbol 'ZULIP_COM'. Edit 0 changes the definition/assignment of ZULIP_COM to include ZULIP_COM_STAGING in its logic, while Edit 1 updates the usage of ZULIP_COM by removing the redundant 'or ZULIP_COM_STAGING' since ZULIP_COM now encompasses that case. The changed lines in both edits explicitly reference the same symbol 'ZULIP_COM', creating a direct code dependency where modifying the definition naturally prompts updating the usage to reflect the new logic. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbol 'ZULIP_COM' in their changed lines. Edit 0 modifies the definition of ZULIP_COM to include ZULIP_COM_STAGING in its logic, and Edit 1 updates the usage of ZULIP_COM in the VOYAGER assignment by removing the redundant 'and not ZULIP_COM_STAGING' condition (since ZULIP_COM now encompasses ZULIP_COM_STAGING). This creates a direct code dependency where changing the definition of ZULIP_COM creates an immediate prompt to update its usage to reflect the new logic. Either edit can be made first without causing parse errors, making this bi-directional."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'ZULIP_COM' in their changed lines. Edit 0 modifies the definition of ZULIP_COM to include ZULIP_COM_STAGING in its logic, and Edit 1 updates the usage of ZULIP_COM in the VOYAGER assignment by removing the redundant 'and not ZULIP_COM_STAGING' condition (since ZULIP_COM now encompasses ZULIP_COM_STAGING). This creates a direct code dependency where changing the definition of ZULIP_COM creates an immediate prompt to update its usage to reflect the new logic. Either edit can be made first without causing parse errors, making this bi-directional."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Edit 0 changes the definition of ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM true when either the original condition OR ZULIP_COM_STAGING is true). Edit 1 removes the explicit ZULIP_COM_STAGING reference from USING_STATSD, leaving only ZULIP_COM or LOCAL_STATSD. Since ZULIP_COM now encompasses ZULIP_COM_STAGING after edit 0, the explicit ZULIP_COM_STAGING reference in edit 1 becomes redundant. Both edits reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING) and form a coordinated refactoring where the logic is consolidated. Either edit can be made first without causing parse errors, and after making either edit, the other becomes the natural next step to complete the refactoring."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Edit 0 changes the definition of ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM true when either the original condition OR ZULIP_COM_STAGING is true). Edit 1 removes the explicit ZULIP_COM_STAGING reference from USING_STATSD, leaving only ZULIP_COM or LOCAL_STATSD. Since ZULIP_COM now encompasses ZULIP_COM_STAGING after edit 0, the explicit ZULIP_COM_STAGING reference in edit 1 becomes redundant. Both edits reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING) and form a coordinated refactoring where the logic is consolidated. Either edit can be made first without causing parse errors, and after making either edit, the other becomes the natural next step to complete the refactoring."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 changes the definition of ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM true when either the original condition OR ZULIP_COM_STAGING is true). Edit 1 then simplifies the VOYAGER condition by removing the redundant 'and not ZULIP_COM_STAGING' check, since ZULIP_COM_STAGING is now included in ZULIP_COM. The changed lines reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING), and making edit 0 creates an immediate, mechanically obvious prompt to simplify the VOYAGER condition in edit 1. This is a direct code dependency where the redefinition in edit 0 makes the redundant check in edit 1 the next logical step."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 changes the definition of ZULIP_COM to include ZULIP_COM_STAGING (making ZULIP_COM true when either the original condition OR ZULIP_COM_STAGING is true). Edit 1 then simplifies the VOYAGER condition by removing the redundant 'and not ZULIP_COM_STAGING' check, since ZULIP_COM_STAGING is now included in ZULIP_COM. The changed lines reference the exact same symbols (ZULIP_COM and ZULIP_COM_STAGING), and making edit 0 creates an immediate, mechanically obvious prompt to simplify the VOYAGER condition in edit 1. This is a direct code dependency where the redefinition in edit 0 makes the redundant check in edit 1 the next logical step."
        }
    ],
    "allowed_init_edits": [
        6,
        7
    ]
}