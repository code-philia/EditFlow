{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds a new parameter 'wrap=True' to the notification method signature, while Edit 1 adds documentation for that exact same parameter. These edits reference the same symbol (the 'wrap' parameter) and are part of a single micro-task of adding a parameter with its documentation. After adding the parameter in the signature, documenting it becomes the immediate next step, and vice versa - they form a natural pair where either edit prompts the other as the next mechanical action."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds a new parameter 'wrap=True' to the notification method signature, while Edit 1 adds documentation for that exact same parameter. These edits reference the same symbol (the 'wrap' parameter) and are part of a single micro-task of adding a parameter with its documentation. After adding the parameter in the signature, documenting it becomes the immediate next step, and vice versa - they form a natural pair where either edit prompts the other as the next mechanical action."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'wrap' within the same function 'notification'. Edit 0 adds the 'wrap' parameter to the function signature, and Edit 1 uses that same 'wrap' parameter in a conditional statement within the function body. This creates a direct code dependency where the parameter defined in Edit 0 is immediately referenced in Edit 1. Since Python allows parameter usage before definition at parse time (no syntax error), either edit can be staged first, making this bi-directional. After making either edit, the other becomes the immediate next step to complete the parameter threading pattern."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'wrap' within the same function 'notification'. Edit 0 adds the 'wrap' parameter to the function signature, and Edit 1 uses that same 'wrap' parameter in a conditional statement within the function body. This creates a direct code dependency where the parameter defined in Edit 0 is immediately referenced in Edit 1. Since Python allows parameter usage before definition at parse time (no syntax error), either edit can be staged first, making this bi-directional. After making either edit, the other becomes the immediate next step to complete the parameter threading pattern."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits add identical documentation lines ':param bool wrap: Whether or not the application should wrap text' to the docstrings of notification methods in different classes (FileDisplay and NoninteractiveDisplay). This represents a synchronized documentation update where the same parameter documentation is being added to related methods that likely share the same interface or inheritance hierarchy. The edits perform identical textual substitution (adding the same docstring line) to the same type of syntactic construct (method docstrings), making this a bulk-edit pattern synchronization that would naturally occur in a single contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits add identical documentation lines ':param bool wrap: Whether or not the application should wrap text' to the docstrings of notification methods in different classes (FileDisplay and NoninteractiveDisplay). This represents a synchronized documentation update where the same parameter documentation is being added to related methods that likely share the same interface or inheritance hierarchy. The edits perform identical textual substitution (adding the same docstring line) to the same type of syntactic construct (method docstrings), making this a bulk-edit pattern synchronization that would naturally occur in a single contiguous refactoring task."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 1 adds a 'wrap=True' parameter to the notification method signature in the interface definition, while Edit 0 modifies the implementation of the same notification method to conditionally wrap the message based on a 'wrap' parameter. These edits reference the exact same method signature and the implementation change directly depends on the parameter added in the interface. The interface change creates an immediate code-driven prompt for the implementation to handle the new parameter, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 1 adds a 'wrap=True' parameter to the notification method signature in the interface definition, while Edit 0 modifies the implementation of the same notification method to conditionally wrap the message based on a 'wrap' parameter. These edits reference the exact same method signature and the implementation change directly depends on the parameter added in the interface. The interface change creates an immediate code-driven prompt for the implementation to handle the new parameter, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits add the exact same parameter 'wrap=True' to the notification method signature. Edit 0 modifies the concrete implementation in FileDisplay class, while Edit 1 modifies the interface definition in IDisplay. This represents a bi-directional relationship because both edits reference the exact same method signature pattern and are part of synchronizing an interface with its implementation. Either edit could be made first, and after making either one, the other becomes the immediate next step to maintain interface-implementation consistency."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits add the exact same parameter 'wrap=True' to the notification method signature. Edit 0 modifies the concrete implementation in FileDisplay class, while Edit 1 modifies the interface definition in IDisplay. This represents a bi-directional relationship because both edits reference the exact same method signature pattern and are part of synchronizing an interface with its implementation. Either edit could be made first, and after making either one, the other becomes the immediate next step to maintain interface-implementation consistency."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds a 'wrap=True' parameter to the notification method signature, and Edit 1 adds documentation for that exact same 'wrap' parameter in the docstring of the same method. These edits reference the same symbol (the 'wrap' parameter) and form a natural pair where adding a parameter typically prompts adding its documentation as part of the same micro-task. Either edit could be done first - the parameter can be added before its documentation or the documentation can be added before the parameter implementation."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds a 'wrap=True' parameter to the notification method signature, and Edit 1 adds documentation for that exact same 'wrap' parameter in the docstring of the same method. These edits reference the same symbol (the 'wrap' parameter) and form a natural pair where adding a parameter typically prompts adding its documentation as part of the same micro-task. Either edit could be done first - the parameter can be added before its documentation or the documentation can be added before the parameter implementation."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'wrap' within the same function. Edit 0 adds the 'wrap' parameter to the function signature, and Edit 1 uses that same 'wrap' parameter in the function body to conditionally wrap the message. This creates an immediate code dependency where adding the parameter naturally prompts its usage in the body as the next mechanical step. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'wrap' within the same function. Edit 0 adds the 'wrap' parameter to the function signature, and Edit 1 uses that same 'wrap' parameter in the function body to conditionally wrap the message. This creates an immediate code dependency where adding the parameter naturally prompts its usage in the body as the next mechanical step. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 1 adds a 'wrap=True' parameter to the interface method signature, while Edit 0 modifies the implementation to conditionally wrap messages based on a 'wrap' parameter. These edits reference the exact same method (notification) and the same parameter (wrap). The interface change in Edit 1 creates an immediate code-driven prompt for the implementation change in Edit 0, as the implementation must be updated to match the new interface signature. This is a classic signature-caller relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 1 adds a 'wrap=True' parameter to the interface method signature, while Edit 0 modifies the implementation to conditionally wrap messages based on a 'wrap' parameter. These edits reference the exact same method (notification) and the same parameter (wrap). The interface change in Edit 1 creates an immediate code-driven prompt for the implementation change in Edit 0, as the implementation must be updated to match the new interface signature. This is a classic signature-caller relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits modify the same method signature (`notification`) across two different classes that implement the same interface. Edit 1 adds the `wrap=True` parameter to the method signature in `NoninteractiveDisplay`, while Edit 0 uses this new parameter in the method implementation in `FileDisplay`. The parameter added in Edit 1 is directly referenced and used in Edit 0's conditional logic. This creates a direct code dependency where both edits reference the exact same parameter symbol `wrap` in the `notification` method interface. Either edit can be made first since Python allows method signatures to have unused parameters and conditional references to parameters that may not exist yet (runtime AttributeError only). This represents a bi-directional relationship where making either edit creates an immediate prompt for the other to maintain interface consistency."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits modify the same method signature (`notification`) across two different classes that implement the same interface. Edit 1 adds the `wrap=True` parameter to the method signature in `NoninteractiveDisplay`, while Edit 0 uses this new parameter in the method implementation in `FileDisplay`. The parameter added in Edit 1 is directly referenced and used in Edit 0's conditional logic. This creates a direct code dependency where both edits reference the exact same parameter symbol `wrap` in the `notification` method interface. Either edit can be made first since Python allows method signatures to have unused parameters and conditional references to parameters that may not exist yet (runtime AttributeError only). This represents a bi-directional relationship where making either edit creates an immediate prompt for the other to maintain interface consistency."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Both edits add identical documentation for a 'wrap' parameter to the same method 'notification' in related classes - one in the interface definition (IDisplay) and one in the implementation (NoninteractiveDisplay). This represents synchronized documentation updates for the same method signature across interface and implementation, which is a form of mirrored structural substitution. Both edits perform the identical textual addition ':param bool wrap: Whether or not the application should wrap text' to documentation for the same method, making this a bi-directional relationship where either edit naturally prompts the other as part of maintaining consistency between interface and implementation documentation."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Both edits add identical documentation for a 'wrap' parameter to the same method 'notification' in related classes - one in the interface definition (IDisplay) and one in the implementation (NoninteractiveDisplay). This represents synchronized documentation updates for the same method signature across interface and implementation, which is a form of mirrored structural substitution. Both edits perform the identical textual addition ':param bool wrap: Whether or not the application should wrap text' to documentation for the same method, making this a bi-directional relationship where either edit naturally prompts the other as part of maintaining consistency between interface and implementation documentation."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution pattern: replacing the unconditional call to `_wrap_lines(message)` with a conditional call `if wrap: message = _wrap_lines(message)`. This is a synchronized refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (method implementations) in two different classes that implement similar notification functionality. The edits are part of a single, contiguous refactor to add conditional wrapping behavior to both display classes."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical structural substitution pattern: replacing the unconditional call to `_wrap_lines(message)` with a conditional call `if wrap: message = _wrap_lines(message)`. This is a synchronized refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (method implementations) in two different classes that implement similar notification functionality. The edits are part of a single, contiguous refactor to add conditional wrapping behavior to both display classes."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits are adding the same parameter 'wrap=True' to the notification method signature. Edit 0 modifies the concrete implementation in NoninteractiveDisplay class, while Edit 1 modifies the interface definition in IDisplay. These represent the same symbol - the notification method that NoninteractiveDisplay implements from the IDisplay interface. The changes are synchronized additions of identical parameters to maintain interface compliance between the abstract interface and its concrete implementation. Either edit can be made first and both reference the same logical method signature that needs to stay synchronized."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits are adding the same parameter 'wrap=True' to the notification method signature. Edit 0 modifies the concrete implementation in NoninteractiveDisplay class, while Edit 1 modifies the interface definition in IDisplay. These represent the same symbol - the notification method that NoninteractiveDisplay implements from the IDisplay interface. The changes are synchronized additions of identical parameters to maintain interface compliance between the abstract interface and its concrete implementation. Either edit can be made first and both reference the same logical method signature that needs to stay synchronized."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits are modifying the same method signature `notification` but in different contexts - one is adding documentation for a `wrap` parameter in the NoninteractiveDisplay class implementation, while the other is adding the actual `wrap=True` parameter to the interface definition. These edits reference the exact same method signature across the interface-implementation relationship. The interface definition change (edit 1) and the documentation update (edit 0) are part of synchronizing the same method signature, making either edit prompt the other as the next mechanical step in maintaining consistency between interface and implementation."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits are modifying the same method signature `notification` but in different contexts - one is adding documentation for a `wrap` parameter in the NoninteractiveDisplay class implementation, while the other is adding the actual `wrap=True` parameter to the interface definition. These edits reference the exact same method signature across the interface-implementation relationship. The interface definition change (edit 1) and the documentation update (edit 0) are part of synchronizing the same method signature, making either edit prompt the other as the next mechanical step in maintaining consistency between interface and implementation."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 adds documentation for a 'wrap' parameter to the notification method's docstring, while Edit 1 adds the actual implementation logic that uses this 'wrap' parameter to conditionally call _wrap_lines(message). Both edits reference the exact same 'wrap' parameter symbol within the same method. Adding the parameter documentation naturally prompts adding the implementation logic that uses that parameter, and vice versa - they form a direct code dependency where both reference the same symbol."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 adds documentation for a 'wrap' parameter to the notification method's docstring, while Edit 1 adds the actual implementation logic that uses this 'wrap' parameter to conditionally call _wrap_lines(message). Both edits reference the exact same 'wrap' parameter symbol within the same method. Adding the parameter documentation naturally prompts adding the implementation logic that uses that parameter, and vice versa - they form a direct code dependency where both reference the same symbol."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 adds documentation for a 'wrap' parameter to the notification method's docstring, while Edit 1 adds the actual implementation logic that uses this 'wrap' parameter to conditionally wrap message text. Both edits reference the exact same 'wrap' parameter symbol - one documents it and the other implements its functionality. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in implementing a parameter-controlled feature."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 adds documentation for a 'wrap' parameter to the notification method's docstring, while Edit 1 adds the actual implementation logic that uses this 'wrap' parameter to conditionally wrap message text. Both edits reference the exact same 'wrap' parameter symbol - one documents it and the other implements its functionality. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in implementing a parameter-controlled feature."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits modify the same method signature and its documentation within the same interface class. Edit 0 adds a 'wrap=True' parameter to the notification method signature, and Edit 1 adds the corresponding documentation for that exact same parameter. These edits reference the exact same symbol (the notification method and its wrap parameter) and form a natural pair where adding a parameter to a method signature immediately prompts adding documentation for that parameter as the next contiguous action in the same micro-task."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits modify the same method signature and its documentation within the same interface class. Edit 0 adds a 'wrap=True' parameter to the notification method signature, and Edit 1 adds the corresponding documentation for that exact same parameter. These edits reference the exact same symbol (the notification method and its wrap parameter) and form a natural pair where adding a parameter to a method signature immediately prompts adding documentation for that parameter as the next contiguous action in the same micro-task."
        }
    ],
    "allowed_init_edits": [
        7
    ]
}