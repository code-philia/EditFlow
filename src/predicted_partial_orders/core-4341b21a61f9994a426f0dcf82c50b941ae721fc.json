{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits add the exact same import statement 'from homeassistant.helpers.importlib import async_import_module' at the same relative position (after line 15) in different files. This represents a bulk-edit pattern where identical textual substitution is being applied to the same type of syntactic construct (import statements) across multiple files. This appears to be part of a single, contiguous refactor to add the same import to related modules. Both edits can be staged in either order since they are independent additions to separate files."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits add the exact same import statement 'from homeassistant.helpers.importlib import async_import_module' at the same relative position (after line 15) in different files. This represents a bulk-edit pattern where identical textual substitution is being applied to the same type of syntactic construct (import statements) across multiple files. This appears to be part of a single, contiguous refactor to add the same import to related modules. Both edits can be staged in either order since they are independent additions to separate files."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 imports the symbol 'async_import_module' from homeassistant.helpers.importlib, and Edit 1 uses that exact same symbol in a function call. The changed lines reference the same symbol - Edit 0 makes it available via import, and Edit 1 uses it. This creates an immediate code dependency where importing the symbol naturally prompts its usage as the next step, or using the symbol requires it to be imported first. Both edits can be staged in either order in Python (the usage before import would only cause a runtime NameError, not a parse error), making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 imports the symbol 'async_import_module' from homeassistant.helpers.importlib, and Edit 1 uses that exact same symbol in a function call. The changed lines reference the same symbol - Edit 0 makes it available via import, and Edit 1 uses it. This creates an immediate code dependency where importing the symbol naturally prompts its usage as the next step, or using the symbol requires it to be imported first. Both edits can be staged in either order in Python (the usage before import would only cause a runtime NameError, not a parse error), making this a bi-directional relationship."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 removes the import of 'importlib' module, while Edit 1 changes the usage from 'importlib.import_module()' to 'await async_import_module()'. These edits reference the exact same symbol 'importlib' - Edit 0 removes its import and Edit 1 removes its usage. This creates a direct code dependency where removing the import (Edit 0) makes the usage change (Edit 1) necessary since 'importlib' is no longer available. However, both edits can be staged in either order without causing parse errors - the code will still parse successfully even if the import is removed before the usage is changed (it would just cause a runtime NameError). Since both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step in refactoring away from importlib, this is bi-directional."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 removes the import of 'importlib' module, while Edit 1 changes the usage from 'importlib.import_module()' to 'await async_import_module()'. These edits reference the exact same symbol 'importlib' - Edit 0 removes its import and Edit 1 removes its usage. This creates a direct code dependency where removing the import (Edit 0) makes the usage change (Edit 1) necessary since 'importlib' is no longer available. However, both edits can be staged in either order without causing parse errors - the code will still parse successfully even if the import is removed before the usage is changed (it would just cause a runtime NameError). Since both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step in refactoring away from importlib, this is bi-directional."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 adds an import for `async_import_module` from `homeassistant.helpers.importlib`, and Edit 1 uses that exact same imported function `async_import_module` in its changed lines. This creates a direct definition-usage relationship where the imported symbol in Edit 0 is immediately referenced in Edit 1. Both edits reference the exact same symbol `async_import_module`, making this a bi-directional relationship since either edit could be staged first (the import could exist before usage, or the usage could exist before import as Python allows runtime NameError)."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 adds an import for `async_import_module` from `homeassistant.helpers.importlib`, and Edit 1 uses that exact same imported function `async_import_module` in its changed lines. This creates a direct definition-usage relationship where the imported symbol in Edit 0 is immediately referenced in Edit 1. Both edits reference the exact same symbol `async_import_module`, making this a bi-directional relationship since either edit could be staged first (the import could exist before usage, or the usage could exist before import as Python allows runtime NameError)."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'importlib.import_module()' calls with 'await async_import_module(hass, ...)' calls. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (import module calls) across different files. Both changed lines reference the same function being replaced (importlib.import_module) and the same function being introduced (async_import_module), making this a synchronized bulk edit pattern. Either edit could be made first as part of this refactoring sweep, and after making either one, the other becomes a natural next step to complete the uniform substitution."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'importlib.import_module()' calls with 'await async_import_module(hass, ...)' calls. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (import module calls) across different files. Both changed lines reference the same function being replaced (importlib.import_module) and the same function being introduced (async_import_module), making this a synchronized bulk edit pattern. Either edit could be made first as part of this refactoring sweep, and after making either one, the other becomes a natural next step to complete the uniform substitution."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 removes the import of 'importlib' module, while Edit 1 changes the usage of 'importlib.import_module()' to use 'async_import_module()' instead. These edits reference the exact same symbol 'importlib' - Edit 0 removes its import and Edit 1 removes its usage. This creates a direct code dependency where removing the import (Edit 0) makes the usage change (Edit 1) necessary, and vice versa - changing the usage makes the import removal appropriate. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 removes the import of 'importlib' module, while Edit 1 changes the usage of 'importlib.import_module()' to use 'async_import_module()' instead. These edits reference the exact same symbol 'importlib' - Edit 0 removes its import and Edit 1 removes its usage. This creates a direct code dependency where removing the import (Edit 0) makes the usage change (Edit 1) necessary, and vice versa - changing the usage makes the import removal appropriate. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 imports the symbol 'async_import_module' from homeassistant.helpers.importlib, and Edit 1 uses that exact same symbol in a function call. The changed lines reference the same symbol - Edit 0 adds the import and Edit 1 uses the imported function. This creates an immediate code dependency where importing the symbol naturally prompts its usage as the next step, or using the symbol requires it to be imported first. Both edits can be staged in either order in Python (usage before import only causes a runtime NameError, not a parse error), making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 imports the symbol 'async_import_module' from homeassistant.helpers.importlib, and Edit 1 uses that exact same symbol in a function call. The changed lines reference the same symbol - Edit 0 adds the import and Edit 1 uses the imported function. This creates an immediate code dependency where importing the symbol naturally prompts its usage as the next step, or using the symbol requires it to be imported first. Both edits can be staged in either order in Python (usage before import only causes a runtime NameError, not a parse error), making this a bi-directional relationship."
        }
    ],
    "allowed_init_edits": [
        6
    ]
}