{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds a comment to the Indexer type alias definition, while Edit 1 changes a function parameter type from 'Tuple[int, ...]' to 'Indexer'. These edits reference the exact same symbol 'Indexer' - Edit 0 provides context/documentation for the Indexer type, and Edit 1 uses that same Indexer type in a function signature. The changed lines have a direct code relationship through the shared Indexer symbol, and both edits would naturally occur in the same micro-task of refactoring type annotations to use the Indexer alias. Either edit could be made first without causing parse errors."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds a comment to the Indexer type alias definition, while Edit 1 changes a function parameter type from 'Tuple[int, ...]' to 'Indexer'. These edits reference the exact same symbol 'Indexer' - Edit 0 provides context/documentation for the Indexer type, and Edit 1 uses that same Indexer type in a function signature. The changed lines have a direct code relationship through the shared Indexer symbol, and both edits would naturally occur in the same micro-task of refactoring type annotations to use the Indexer alias. Either edit could be made first without causing parse errors."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds a comment to the Indexer type alias definition, while Edit 1 changes a function parameter type from 'Tuple[Union[int, slice], ...]' to 'Indexer'. Both edits reference the exact same symbol 'Indexer' - Edit 0 modifies the type alias definition and Edit 1 uses that type alias. This creates a direct code dependency where the Indexer type alias is being refined/documented in one edit and then utilized in another edit. Either edit could be made first and would naturally prompt the other as the next step in improving the type system consistency."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds a comment to the Indexer type alias definition, while Edit 1 changes a function parameter type from 'Tuple[Union[int, slice], ...]' to 'Indexer'. Both edits reference the exact same symbol 'Indexer' - Edit 0 modifies the type alias definition and Edit 1 uses that type alias. This creates a direct code dependency where the Indexer type alias is being refined/documented in one edit and then utilized in another edit. Either edit could be made first and would naturally prompt the other as the next step in improving the type system consistency."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Tuple[int, ...]' to 'Indexer' in function parameter type annotations. They target the same type of syntactic construct (function signatures) and appear to be part of a single, contiguous refactor to update type annotations across related functions in the same file. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after pattern to the same construct type."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Tuple[int, ...]' to 'Indexer' in function parameter type annotations. They target the same type of syntactic construct (function signatures) and appear to be part of a single, contiguous refactor to update type annotations across related functions in the same file. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after pattern to the same construct type."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Tuple[Union[int, slice], ...]' or 'Tuple[int, ...]' to 'Indexer' in function parameter type annotations. This is a uniform type alias substitution across multiple function signatures of the same syntactic construct type (parameter type annotations). Both edits are part of the same refactoring operation to replace tuple-based indexing types with a unified 'Indexer' type alias. The substitution pattern is structurally identical and targets the same type of syntactic element, making this a clear bulk-edit synchronization case."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Tuple[Union[int, slice], ...]' or 'Tuple[int, ...]' to 'Indexer' in function parameter type annotations. This is a uniform type alias substitution across multiple function signatures of the same syntactic construct type (parameter type annotations). Both edits are part of the same refactoring operation to replace tuple-based indexing types with a unified 'Indexer' type alias. The substitution pattern is structurally identical and targets the same type of syntactic element, making this a clear bulk-edit synchronization case."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'idx: Tuple[int, ...]' to 'idx: Indexer' in function parameter type annotations. This is a uniform, synchronized type annotation change applied to the same syntactic construct (function parameter declarations) within the same file. Both edits are part of a single refactoring operation to update the type annotation for the idx parameter across related functions. Either edit can be made first, and both represent the same mechanical substitution pattern being applied consistently."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'idx: Tuple[int, ...]' to 'idx: Indexer' in function parameter type annotations. This is a uniform, synchronized type annotation change applied to the same syntactic construct (function parameter declarations) within the same file. Both edits are part of a single refactoring operation to update the type annotation for the idx parameter across related functions. Either edit can be made first, and both represent the same mechanical substitution pattern being applied consistently."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'idx: Tuple[int, ...]' to 'idx: Indexer' in function parameter type annotations. This is a uniform, synchronized type annotation update across multiple function signatures within the same file, targeting the same syntactic construct (parameter type annotations). Both edits are part of a single refactoring operation to update the type annotation for index parameters from the more specific Tuple[int, ...] to the more general Indexer type. Either edit could be made first, and both represent the same mechanical substitution pattern applied to different functions."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'idx: Tuple[int, ...]' to 'idx: Indexer' in function parameter type annotations. This is a uniform, synchronized type annotation update across multiple function signatures within the same file, targeting the same syntactic construct (parameter type annotations). Both edits are part of a single refactoring operation to update the type annotation for index parameters from the more specific Tuple[int, ...] to the more general Indexer type. Either edit could be made first, and both represent the same mechanical substitution pattern applied to different functions."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Tuple[Union[int, slice], ...]' or 'Tuple[int, ...]' to 'Indexer' in function parameter type annotations. This represents a uniform type refactoring across multiple function signatures in the same file, where both edits are part of the same contiguous refactor to standardize the indexing parameter type. The substitution pattern is structurally identical (replacing tuple-based type hints with a unified Indexer type) and targets the same type of syntactic construct (function parameter type annotations). This is a clear case of bulk-edit pattern synchronization where both changes would naturally occur together in a single uninterrupted micro-task."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Tuple[Union[int, slice], ...]' or 'Tuple[int, ...]' to 'Indexer' in function parameter type annotations. This represents a uniform type refactoring across multiple function signatures in the same file, where both edits are part of the same contiguous refactor to standardize the indexing parameter type. The substitution pattern is structurally identical (replacing tuple-based type hints with a unified Indexer type) and targets the same type of syntactic construct (function parameter type annotations). This is a clear case of bulk-edit pattern synchronization where both changes would naturally occur together in a single uninterrupted micro-task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 changes the function signature of `ref_set` by changing the parameter type from `Tuple[int, ...]` to `Indexer`. Edit 1 adds a new test that calls `state.ref_set` with specific arguments. Both edits reference the exact same symbol `ref_set` - edit 0 modifies its definition and edit 1 uses it in a test. However, the test in edit 1 can be written and parsed regardless of whether the signature change in edit 0 has been applied, since Python allows function calls with any arguments at parse time (type mismatches only cause runtime errors). The relationship is bi-directional because either edit can be staged first, and after making either edit, the other becomes a natural next step in the development flow."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 changes the function signature of `ref_set` by changing the parameter type from `Tuple[int, ...]` to `Indexer`. Edit 1 adds a new test that calls `state.ref_set` with specific arguments. Both edits reference the exact same symbol `ref_set` - edit 0 modifies its definition and edit 1 uses it in a test. However, the test in edit 1 can be written and parsed regardless of whether the signature change in edit 0 has been applied, since Python allows function calls with any arguments at parse time (type mismatches only cause runtime errors). The relationship is bi-directional because either edit can be staged first, and after making either edit, the other becomes a natural next step in the development flow."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing parameter type annotations from tuple-based indexing types to 'Indexer' type. Edit 0 changes 'idx: Tuple[Union[int, slice], ...]' to 'idx: Indexer' in the ref_get function signature, and Edit 1 changes 'idx: Tuple[int, ...]' to 'idx: Indexer' in the ref_set function signature. This represents a uniform refactoring operation where the same type substitution is being applied to the same parameter ('idx') across related function signatures within the same module. Both edits target the same syntactic construct (function parameter type annotations) and apply the same before\u2192after pattern (tuple-based indexing \u2192 Indexer type). This is a clear case of bulk-edit pattern synchronization where both changes would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing parameter type annotations from tuple-based indexing types to 'Indexer' type. Edit 0 changes 'idx: Tuple[Union[int, slice], ...]' to 'idx: Indexer' in the ref_get function signature, and Edit 1 changes 'idx: Tuple[int, ...]' to 'idx: Indexer' in the ref_set function signature. This represents a uniform refactoring operation where the same type substitution is being applied to the same parameter ('idx') across related function signatures within the same module. Both edits target the same syntactic construct (function parameter type annotations) and apply the same before\u2192after pattern (tuple-based indexing \u2192 Indexer type). This is a clear case of bulk-edit pattern synchronization where both changes would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 changes the signature of the ref_get function by changing the idx parameter type from 'Tuple[Union[int, slice], ...]' to 'Indexer'. Edit 1 adds a new test method that calls state.ref_get(ref, ...) on line 653. Both edits reference the exact same symbol 'ref_get' - edit 0 modifies its definition and edit 1 uses it in a test. However, the test code in edit 1 can be written and parsed regardless of whether the signature change in edit 0 has been applied, since Python allows function calls with any arguments at parse time (type mismatches only cause runtime errors). Therefore, either edit can be staged first, making this a bi-directional relationship where making either edit creates an immediate prompt for the other as part of maintaining code consistency."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 changes the signature of the ref_get function by changing the idx parameter type from 'Tuple[Union[int, slice], ...]' to 'Indexer'. Edit 1 adds a new test method that calls state.ref_get(ref, ...) on line 653. Both edits reference the exact same symbol 'ref_get' - edit 0 modifies its definition and edit 1 uses it in a test. However, the test code in edit 1 can be written and parsed regardless of whether the signature change in edit 0 has been applied, since Python allows function calls with any arguments at parse time (type mismatches only cause runtime errors). Therefore, either edit can be staged first, making this a bi-directional relationship where making either edit creates an immediate prompt for the other as part of maintaining code consistency."
        }
    ],
    "allowed_init_edits": [
        1
    ]
}