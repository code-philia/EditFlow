{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'View.search_count([' to 'View.with_context(active_test=False).search_count(['. This is a uniform refactoring operation applying the same before\u2192after pattern to the same type of syntactic construct (method calls on the View class). Both edits are within the same test method and represent a single, contiguous refactoring task to add the same context parameter to multiple View.search_count calls. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the refactoring pattern."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'View.search_count([' to 'View.with_context(active_test=False).search_count(['. This is a uniform refactoring operation applying the same before\u2192after pattern to the same type of syntactic construct (method calls on the View class). Both edits are within the same test method and represent a single, contiguous refactoring task to add the same context parameter to multiple View.search_count calls. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the refactoring pattern."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both change 'View.search_count([])' to 'View.with_context(active_test=False).search_count([])' on lines that are structurally identical (both are variable assignments using the same pattern). This represents a bulk uniform substitution within the same test class, where both edits apply the exact same before\u2192after pattern to the same construct type. This is clearly part of a single, contiguous refactor to add the context parameter to View.search_count calls."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both change 'View.search_count([])' to 'View.with_context(active_test=False).search_count([])' on lines that are structurally identical (both are variable assignments using the same pattern). This represents a bulk uniform substitution within the same test class, where both edits apply the exact same before\u2192after pattern to the same construct type. This is clearly part of a single, contiguous refactor to add the context parameter to View.search_count calls."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform identical textual substitutions on the same type of syntactic construct. Edit 0 changes 'View.search_count([])' to 'View.with_context(active_test=False).search_count([])' and Edit 1 makes the exact same substitution pattern. Both are modifying View.search_count calls within the same test method by adding the same context parameter. This represents a uniform, synchronized substitution pattern where both edits apply the identical before\u2192after transformation to the same construct type (View.search_count method calls). Either edit could be made first as part of this bulk refactoring operation."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform identical textual substitutions on the same type of syntactic construct. Edit 0 changes 'View.search_count([])' to 'View.with_context(active_test=False).search_count([])' and Edit 1 makes the exact same substitution pattern. Both are modifying View.search_count calls within the same test method by adding the same context parameter. This represents a uniform, synchronized substitution pattern where both edits apply the identical before\u2192after transformation to the same construct type (View.search_count method calls). Either edit could be made first as part of this bulk refactoring operation."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits modify calls to View.search_count([]) by adding the same .with_context(active_test=False) method call. This represents a synchronized pattern substitution where the exact same API call is being modified in the same way across multiple locations within the same test method. The edits are performing identical textual substitutions (adding .with_context(active_test=False) before .search_count([])) on the same type of syntactic construct (method calls on the View class). This appears to be part of a single, contiguous refactor to ensure the search_count calls include inactive records in the test. Either edit could be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the test method."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits modify calls to View.search_count([]) by adding the same .with_context(active_test=False) method call. This represents a synchronized pattern substitution where the exact same API call is being modified in the same way across multiple locations within the same test method. The edits are performing identical textual substitutions (adding .with_context(active_test=False) before .search_count([])) on the same type of syntactic construct (method calls on the View class). This appears to be part of a single, contiguous refactor to ensure the search_count calls include inactive records in the test. Either edit could be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the test method."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 assigns a value to the variable `specific_view` by searching for a view with specific criteria. Edit 1 then uses this exact same variable `specific_view` to set its `active` attribute to False. The changed lines reference the exact same symbol - the variable `specific_view` that is defined in edit 0 and used in edit 1. This creates an immediate, mechanically obvious code dependency where edit 0 must occur before edit 1 since edit 1 cannot reference an undefined variable. In Python, referencing an undefined variable would cause a NameError at runtime, but more importantly, the code would be semantically meaningless if `specific_view` is not defined first."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits modify test assertions that use `View.search_count([])` by adding `.with_context(active_test=False)` to the View query. This is a uniform substitution pattern where the same before\u2192after transformation (adding the context parameter) is applied to the same type of syntactic construct (View.search_count calls) in both locations. The edits are part of a single refactoring operation to ensure view counting works correctly when some views might be inactive. Either edit can be made first, and both represent the same mechanical change pattern."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits modify test assertions that use `View.search_count([])` by adding `.with_context(active_test=False)` to the View query. This is a uniform substitution pattern where the same before\u2192after transformation (adding the context parameter) is applied to the same type of syntactic construct (View.search_count calls) in both locations. The edits are part of a single refactoring operation to ensure view counting works correctly when some views might be inactive. Either edit can be made first, and both represent the same mechanical change pattern."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits modify View.search_count() calls to add .with_context(active_test=False) in the same test method. This is a uniform substitution pattern where the same modification (adding the context manager) is being applied to multiple View.search_count() calls within the same test. The edits reference the same View class and apply identical structural changes to the same type of method call. This appears to be part of a single refactoring task to ensure all View queries in this test properly handle inactive records."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits modify View.search_count() calls to add .with_context(active_test=False) in the same test method. This is a uniform substitution pattern where the same modification (adding the context manager) is being applied to multiple View.search_count() calls within the same test. The edits reference the same View class and apply identical structural changes to the same type of method call. This appears to be part of a single refactoring task to ensure all View queries in this test properly handle inactive records."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits modify View.search_count([]) calls to include .with_context(active_test=False), which is an identical textual substitution pattern applied to the same type of syntactic construct (method calls on the View model). This appears to be part of a single refactoring task to ensure consistent handling of active/inactive views in test assertions. The changes are structurally identical and would naturally be made together as part of one contiguous micro-task."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits modify View.search_count([]) calls to include .with_context(active_test=False), which is an identical textual substitution pattern applied to the same type of syntactic construct (method calls on the View model). This appears to be part of a single refactoring task to ensure consistent handling of active/inactive views in test assertions. The changes are structurally identical and would naturally be made together as part of one contiguous micro-task."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits modify calls to View.search_count([]) by adding .with_context(active_test=False) to the View object before calling search_count. This is a uniform substitution pattern where the same method call is being modified in the same way across multiple locations within the same test method. The changes are structurally identical (adding the same context modification) and target the same type of syntactic construct (View.search_count calls). This represents a single, contiguous refactoring operation where both changes would naturally be made together as part of the same micro-task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits modify calls to View.search_count([]) by adding .with_context(active_test=False) to the View object before calling search_count. This is a uniform substitution pattern where the same method call is being modified in the same way across multiple locations within the same test method. The changes are structurally identical (adding the same context modification) and target the same type of syntactic construct (View.search_count calls). This represents a single, contiguous refactoring operation where both changes would naturally be made together as part of the same micro-task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'View.search_count([' to 'View.with_context(active_test=False).search_count([' on the same type of syntactic construct (View.search_count method calls). This is a uniform refactoring operation within the same test method where both changes apply the exact same pattern to identical construct types. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the refactoring pattern."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'View.search_count([' to 'View.with_context(active_test=False).search_count([' on the same type of syntactic construct (View.search_count method calls). This is a uniform refactoring operation within the same test method where both changes apply the exact same pattern to identical construct types. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the refactoring pattern."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits apply the identical transformation pattern to the same type of syntactic construct: adding `.with_context(active_test=False)` to `View.search_count([])` calls. This represents a bulk uniform substitution where both changed lines perform the exact same before\u2192after pattern (View.search_count \u2192 View.with_context(active_test=False).search_count) on the same construct type (View search operations). Both edits are part of a single contiguous refactor to ensure inactive views are included in the search count, and either edit can be made first as they are independent applications of the same pattern."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits apply the identical transformation pattern to the same type of syntactic construct: adding `.with_context(active_test=False)` to `View.search_count([])` calls. This represents a bulk uniform substitution where both changed lines perform the exact same before\u2192after pattern (View.search_count \u2192 View.with_context(active_test=False).search_count) on the same construct type (View search operations). Both edits are part of a single contiguous refactor to ensure inactive views are included in the search count, and either edit can be made first as they are independent applications of the same pattern."
        }
    ],
    "allowed_init_edits": [
        2,
        0
    ]
}