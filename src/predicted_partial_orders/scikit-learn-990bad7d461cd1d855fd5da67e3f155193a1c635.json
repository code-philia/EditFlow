{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds a 'return self' statement to the fit method of LogisticRegression, enabling method chaining. Edit 1 modifies test code to use method chaining by calling .fit() directly on the constructor result. The changed lines reference the exact same method (fit) - edit 0 modifies the fit method implementation and edit 1 calls that same fit method. This creates a direct code dependency where the method chaining pattern in edit 1 relies on the return self behavior added in edit 0. Both edits are part of implementing the same feature (method chaining) and reference the same symbol."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds a 'return self' statement to the fit method of LogisticRegression, enabling method chaining. Edit 1 modifies test code to use method chaining by calling .fit() directly on the constructor result. The changed lines reference the exact same method (fit) - edit 0 modifies the fit method implementation and edit 1 calls that same fit method. This creates a direct code dependency where the method chaining pattern in edit 1 relies on the return self behavior added in edit 0. Both edits are part of implementing the same feature (method chaining) and reference the same symbol."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical structural transformation within the same test function: converting a two-line pattern of 'clf = LogisticRegression(...); clf.fit(X, Y1)' into a single-line method chaining pattern 'clf = LogisticRegression(...).fit(X, Y1)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (LogisticRegression instantiation and fitting) within the same function scope. The edits represent a synchronized bulk refactoring operation that would naturally be performed as part of a single, contiguous micro-task to clean up the code style."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical structural transformation within the same test function: converting a two-line pattern of 'clf = LogisticRegression(...); clf.fit(X, Y1)' into a single-line method chaining pattern 'clf = LogisticRegression(...).fit(X, Y1)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (LogisticRegression instantiation and fitting) within the same function scope. The edits represent a synchronized bulk refactoring operation that would naturally be performed as part of a single, contiguous micro-task to clean up the code style."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical structural transformation: changing from a two-line pattern of 'clf = logistic.LogisticRegression()' followed by 'clf.fit(X, Y)' to a single-line method chaining pattern 'clf = logistic.LogisticRegression().fit(X, Y)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (LogisticRegression instantiation and fitting) in different test functions. The edits represent the same before\u2192after substitution pattern and would naturally be part of a single, contiguous refactoring sweep to modernize the code style."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical structural transformation: changing from a two-line pattern of 'clf = logistic.LogisticRegression()' followed by 'clf.fit(X, Y)' to a single-line method chaining pattern 'clf = logistic.LogisticRegression().fit(X, Y)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (LogisticRegression instantiation and fitting) in different test functions. The edits represent the same before\u2192after substitution pattern and would naturally be part of a single, contiguous refactoring sweep to modernize the code style."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 adds a 'return self' statement to the fit() method of LogisticRegression, enabling method chaining. Edit 1 takes advantage of this change by chaining the fit() call directly in the constructor call (LogisticRegression().fit(X, Y2)). The changed lines reference the exact same method (fit) - edit 0 modifies the fit method to return self, and edit 1 uses that same fit method in a chained call. This creates a direct code dependency where edit 0 enables the pattern used in edit 1, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 adds a 'return self' statement to the fit() method of LogisticRegression, enabling method chaining. Edit 1 takes advantage of this change by chaining the fit() call directly in the constructor call (LogisticRegression().fit(X, Y2)). The changed lines reference the exact same method (fit) - edit 0 modifies the fit method to return self, and edit 1 uses that same fit method in a chained call. This creates a direct code dependency where edit 0 enables the pattern used in edit 1, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds a 'return self' statement to the LogisticRegression.fit() method, enabling method chaining. Edit 1 modifies test code to use method chaining by calling .fit() directly on the constructor result. The changed lines reference the exact same method (LogisticRegression.fit) - edit 0 modifies the method definition to return self, and edit 1 uses that exact same method in a chained call. This creates a direct code dependency where edit 0 enables the chaining pattern that edit 1 immediately utilizes. Both edits can be staged in either order (the chaining will work once both are present), making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds a 'return self' statement to the LogisticRegression.fit() method, enabling method chaining. Edit 1 modifies test code to use method chaining by calling .fit() directly on the constructor result. The changed lines reference the exact same method (LogisticRegression.fit) - edit 0 modifies the method definition to return self, and edit 1 uses that exact same method in a chained call. This creates a direct code dependency where edit 0 enables the chaining pattern that edit 1 immediately utilizes. Both edits can be staged in either order (the chaining will work once both are present), making this bi-directional."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical structural transformation: changing from a two-line pattern of 'clf = LogisticRegression()' followed by 'clf.fit(X, Y)' to a single-line pattern 'clf = LogisticRegression().fit(X, Y)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (variable assignment with method chaining) in two different test functions. The edits represent a bulk substitution with identical before\u2192after patterns on the same construct type, making them part of a single contiguous refactoring sweep. Either edit could be made first, and both represent the same mechanical transformation."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical structural transformation: changing from a two-line pattern of 'clf = LogisticRegression()' followed by 'clf.fit(X, Y)' to a single-line pattern 'clf = LogisticRegression().fit(X, Y)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (variable assignment with method chaining) in two different test functions. The edits represent a bulk substitution with identical before\u2192after patterns on the same construct type, making them part of a single contiguous refactoring sweep. Either edit could be made first, and both represent the same mechanical transformation."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds a 'return self' statement to the LogisticRegression.fit() method, enabling method chaining. Edit 1 modifies test code to use method chaining by calling .fit() directly on the constructor result. Both edits reference the exact same method (LogisticRegression.fit) - edit 0 modifies its implementation to support chaining, and edit 1 uses that chaining capability. This creates a direct code dependency where the test change relies on the implementation change, making them part of the same micro-task of enabling method chaining."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds a 'return self' statement to the LogisticRegression.fit() method, enabling method chaining. Edit 1 modifies test code to use method chaining by calling .fit() directly on the constructor result. Both edits reference the exact same method (LogisticRegression.fit) - edit 0 modifies its implementation to support chaining, and edit 1 uses that chaining capability. This creates a direct code dependency where the test change relies on the implementation change, making them part of the same micro-task of enabling method chaining."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical structural transformation: combining separate instantiation and fit() calls into a single chained method call. Edit 0 changes 'clf = logistic.LogisticRegression(intercept=False)' followed by 'clf.fit(X, Y1)' into 'clf = logistic.LogisticRegression(intercept=False).fit(X, Y1)'. Edit 1 makes the same pattern change: 'clf = logistic.LogisticRegression()' followed by 'clf.fit(X, Y2)' into 'clf = logistic.LogisticRegression().fit(X, Y2)'. This is a bulk-edit pattern where both edits apply the same before\u2192after transformation (separate instantiation+fit \u2192 chained method call) to the same type of syntactic construct (LogisticRegression instantiation and fitting). Both edits are clearly part of a single, contiguous refactoring operation to modernize the test code style. Neither edit references the exact same symbol, but they follow the identical substitution pattern on the same construct type, making them bi-directional neighbours in the refactoring flow."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical structural transformation: combining separate instantiation and fit() calls into a single chained method call. Edit 0 changes 'clf = logistic.LogisticRegression(intercept=False)' followed by 'clf.fit(X, Y1)' into 'clf = logistic.LogisticRegression(intercept=False).fit(X, Y1)'. Edit 1 makes the same pattern change: 'clf = logistic.LogisticRegression()' followed by 'clf.fit(X, Y2)' into 'clf = logistic.LogisticRegression().fit(X, Y2)'. This is a bulk-edit pattern where both edits apply the same before\u2192after transformation (separate instantiation+fit \u2192 chained method call) to the same type of syntactic construct (LogisticRegression instantiation and fitting). Both edits are clearly part of a single, contiguous refactoring operation to modernize the test code style. Neither edit references the exact same symbol, but they follow the identical substitution pattern on the same construct type, making them bi-directional neighbours in the refactoring flow."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical structural transformation: combining separate instantiation and fit() calls into a single chained method call. Edit 0 changes 'clf = logistic.LogisticRegression(intercept=False)' followed by 'clf.fit(X, Y1)' into 'clf = logistic.LogisticRegression(intercept=False).fit(X, Y1)'. Edit 1 makes the same pattern change with 'clf = logistic.LogisticRegression()' followed by 'clf.fit(X, Y2)' into 'clf = logistic.LogisticRegression().fit(X, Y2)'. This is a bulk-edit pattern where both edits apply the same before\u2192after transformation (separate instantiation+fit \u2192 chained method call) to the same type of syntactic construct (LogisticRegression instantiation and fitting). Both edits are clearly part of a single refactoring sweep to make the code more concise by using method chaining."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical structural transformation: combining separate instantiation and fit() calls into a single chained method call. Edit 0 changes 'clf = logistic.LogisticRegression(intercept=False)' followed by 'clf.fit(X, Y1)' into 'clf = logistic.LogisticRegression(intercept=False).fit(X, Y1)'. Edit 1 makes the same pattern change with 'clf = logistic.LogisticRegression()' followed by 'clf.fit(X, Y2)' into 'clf = logistic.LogisticRegression().fit(X, Y2)'. This is a bulk-edit pattern where both edits apply the same before\u2192after transformation (separate instantiation+fit \u2192 chained method call) to the same type of syntactic construct (LogisticRegression instantiation and fitting). Both edits are clearly part of a single refactoring sweep to make the code more concise by using method chaining."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical structural transformation within the same test function: converting the pattern 'clf = LogisticRegression(...); clf.fit(X, Y2)' to 'clf = LogisticRegression(...).fit(X, Y2)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (LogisticRegression instantiation and fitting) within the same function scope. The edits represent a single, contiguous micro-task of method chaining refactoring that would naturally be performed together in one sweep."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical structural transformation within the same test function: converting the pattern 'clf = LogisticRegression(...); clf.fit(X, Y2)' to 'clf = LogisticRegression(...).fit(X, Y2)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (LogisticRegression instantiation and fitting) within the same function scope. The edits represent a single, contiguous micro-task of method chaining refactoring that would naturally be performed together in one sweep."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical structural transformation: converting a two-line pattern of 'clf = LogisticRegression(...); clf.fit(X, Y2)' into a single-line method chaining pattern 'clf = LogisticRegression(...).fit(X, Y2)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (LogisticRegression instantiation and fitting) in different test functions. The edits represent the same before\u2192after substitution pattern and target identical construct types, making them part of a single contiguous refactoring sweep."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical structural transformation: converting a two-line pattern of 'clf = LogisticRegression(...); clf.fit(X, Y2)' into a single-line method chaining pattern 'clf = LogisticRegression(...).fit(X, Y2)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (LogisticRegression instantiation and fitting) in different test functions. The edits represent the same before\u2192after substitution pattern and target identical construct types, making them part of a single contiguous refactoring sweep."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'clf = logistic.LogisticRegression()' followed by 'clf.fit(X, Y2)' into 'clf = logistic.LogisticRegression().fit(X, Y2)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (variable assignment with method chaining) in both test functions. The edits are part of a single, contiguous refactor to make the code more concise by chaining the fit method call. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'clf = logistic.LogisticRegression()' followed by 'clf.fit(X, Y2)' into 'clf = logistic.LogisticRegression().fit(X, Y2)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (variable assignment with method chaining) in both test functions. The edits are part of a single, contiguous refactor to make the code more concise by chaining the fit method call. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical structural transformation: combining object instantiation and method call into a single chained expression. Edit 0 changes 'clf = logistic.LogisticRegression(intercept=False)' followed by 'clf.fit(X, Y1)' into 'clf = logistic.LogisticRegression(intercept=False).fit(X, Y1)'. Edit 1 makes the exact same pattern change with 'clf = logistic.LogisticRegression(penalty='l1')' followed by 'clf.fit(X, Y2)' into 'clf = logistic.LogisticRegression(penalty='l1').fit(X, Y2)'. This is a bulk-edit pattern synchronization where both edits apply the same before\u2192after transformation (separate instantiation+fit \u2192 chained instantiation.fit) to the same type of syntactic construct (LogisticRegression instantiation followed by fit call). Both edits are clearly part of a single refactoring sweep to make the test code more concise by using method chaining."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical structural transformation: combining object instantiation and method call into a single chained expression. Edit 0 changes 'clf = logistic.LogisticRegression(intercept=False)' followed by 'clf.fit(X, Y1)' into 'clf = logistic.LogisticRegression(intercept=False).fit(X, Y1)'. Edit 1 makes the exact same pattern change with 'clf = logistic.LogisticRegression(penalty='l1')' followed by 'clf.fit(X, Y2)' into 'clf = logistic.LogisticRegression(penalty='l1').fit(X, Y2)'. This is a bulk-edit pattern synchronization where both edits apply the same before\u2192after transformation (separate instantiation+fit \u2192 chained instantiation.fit) to the same type of syntactic construct (LogisticRegression instantiation followed by fit call). Both edits are clearly part of a single refactoring sweep to make the test code more concise by using method chaining."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical structural transformation: changing a two-line pattern of 'clf = LogisticRegression(...); clf.fit(X, Y)' into a single-line method chaining pattern 'clf = LogisticRegression(...).fit(X, Y)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (LogisticRegression instantiation and fitting) in different test functions. The edits represent the same before\u2192after substitution pattern and would naturally be part of a single, contiguous refactoring sweep to modernize the code style. Either edit could be made first, and both follow the same mechanical transformation rule."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical structural transformation: changing a two-line pattern of 'clf = LogisticRegression(...); clf.fit(X, Y)' into a single-line method chaining pattern 'clf = LogisticRegression(...).fit(X, Y)'. This is a uniform refactoring pattern applied to the same type of syntactic construct (LogisticRegression instantiation and fitting) in different test functions. The edits represent the same before\u2192after substitution pattern and would naturally be part of a single, contiguous refactoring sweep to modernize the code style. Either edit could be made first, and both follow the same mechanical transformation rule."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds a 'return self' statement to the fit() method of LogisticRegression, enabling method chaining. Edit 1 changes the test code to use method chaining by calling .fit() directly on the constructor result. The changed lines reference the exact same symbol (the fit method of LogisticRegression class) and create a direct code dependency - edit 0 enables the chaining pattern that edit 1 uses. Either edit could be made first since both are syntactically valid independently, but they form a natural pair where one enables the other's functionality."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds a 'return self' statement to the fit() method of LogisticRegression, enabling method chaining. Edit 1 changes the test code to use method chaining by calling .fit() directly on the constructor result. The changed lines reference the exact same symbol (the fit method of LogisticRegression class) and create a direct code dependency - edit 0 enables the chaining pattern that edit 1 uses. Either edit could be made first since both are syntactically valid independently, but they form a natural pair where one enables the other's functionality."
        }
    ],
    "allowed_init_edits": [
        0,
        1,
        2,
        4,
        3,
        5
    ]
}