{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 defines a new function `_assertNonEmpty` and Edit 1 calls that exact same function. The changed lines reference the same symbol - `_assertNonEmpty`. After defining the function in Edit 0, Edit 1 becomes the immediate next step to use it. However, since this is Python, the function call in Edit 1 can be written and parsed even before the function is defined (it would only fail at runtime with a NameError). Therefore, either edit can be staged first, making this bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 defines a new function `_assertNonEmpty` and Edit 1 calls that exact same function. The changed lines reference the same symbol - `_assertNonEmpty`. After defining the function in Edit 0, Edit 1 becomes the immediate next step to use it. However, since this is Python, the function call in Edit 1 can be written and parsed even before the function is defined (it would only fail at runtime with a NameError). Therefore, either edit can be staged first, making this bi-directional rather than ordered."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits add the exact same function call '_assertNonEmpty(a)' to different functions (svd and pinv) in the same file. This appears to be part of a uniform bulk edit pattern where the same validation check is being added to multiple functions. The edits involve identical textual substitution (adding the same line) and target the same type of syntactic construct (function call statements). This fits the criteria for bulk-edit synchronization where both edits perform an identical structural substitution as part of a single, contiguous refactor."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits add the exact same function call '_assertNonEmpty(a)' to different functions (svd and pinv) in the same file. This appears to be part of a uniform bulk edit pattern where the same validation check is being added to multiple functions. The edits involve identical textual substitution (adding the same line) and target the same type of syntactic construct (function call statements). This fits the criteria for bulk-edit synchronization where both edits perform an identical structural substitution as part of a single, contiguous refactor."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 defines a new function `_assertNonEmpty` and Edit 1 calls that exact same function. The changed lines reference the exact same symbol - the function `_assertNonEmpty`. After defining the function in Edit 0, Edit 1 becomes the immediate next step to use it. However, since this is Python, the function call in Edit 1 can be written and parsed even before the function is defined (it would only fail at runtime with a NameError). Therefore, either edit can be staged first, making this bi-directional rather than ordered."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 defines a new function `_assertNonEmpty` and Edit 1 calls that exact same function. The changed lines reference the exact same symbol - the function `_assertNonEmpty`. After defining the function in Edit 0, Edit 1 becomes the immediate next step to use it. However, since this is Python, the function call in Edit 1 can be written and parsed even before the function is defined (it would only fail at runtime with a NameError). Therefore, either edit can be staged first, making this bi-directional rather than ordered."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds 'size' to the import statement from numpy.core.numeric, while Edit 1 uses the 'size' function in a newly defined helper function. The changed lines reference the exact same symbol - the 'size' function. After importing 'size' in Edit 0, using it in Edit 1 becomes the immediate next step. Both edits can be staged in either order since Python allows referencing undefined symbols at parse time (would only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds 'size' to the import statement from numpy.core.numeric, while Edit 1 uses the 'size' function in a newly defined helper function. The changed lines reference the exact same symbol - the 'size' function. After importing 'size' in Edit 0, using it in Edit 1 becomes the immediate next step. Both edits can be staged in either order since Python allows referencing undefined symbols at parse time (would only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 adds 'atleast_2d' to the import statement, and Edit 1 uses 'atleast_2d' in the newly added check_empty method. The changed lines reference the exact same symbol - 'atleast_2d'. After making the import edit, using atleast_2d becomes the immediate next step, and after adding the usage, importing it becomes the immediate next step. This is a classic import-usage relationship within the same file where both edits reference the exact same symbol."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 adds 'atleast_2d' to the import statement, and Edit 1 uses 'atleast_2d' in the newly added check_empty method. The changed lines reference the exact same symbol - 'atleast_2d'. After making the import edit, using atleast_2d becomes the immediate next step, and after adding the usage, importing it becomes the immediate next step. This is a classic import-usage relationship within the same file where both edits reference the exact same symbol."
        }
    ],
    "allowed_init_edits": [
        0,
        4,
        5
    ]
}