{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 defines a new function `do_drop_all_analytics_tables()` and Edit 1 calls that exact same function. The changed lines reference the same symbol - Edit 0 creates the function definition and Edit 1 uses it by calling it. This creates an immediate code dependency where defining the function naturally prompts its usage, and using the function requires its definition. Since this is Python, both edits can be parsed and staged in either order (the call would only fail at runtime if the function isn't defined), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 defines a new function `do_drop_all_analytics_tables()` and Edit 1 calls that exact same function. The changed lines reference the same symbol - Edit 0 creates the function definition and Edit 1 uses it by calling it. This creates an immediate code dependency where defining the function naturally prompts its usage, and using the function requires its definition. Since this is Python, both edits can be parsed and staged in either order (the call would only fail at runtime if the function isn't defined), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 defines a new function `do_drop_all_analytics_tables` in the analytics/lib/counts.py file, while Edit 1 imports that exact same function in analytics/management/commands/clear_analytics_tables.py. The changed lines reference the exact same symbol - the function `do_drop_all_analytics_tables`. After defining the function in Edit 0, importing it in Edit 1 becomes a natural next step if that function needs to be used in the management command. Conversely, if the import is added first, defining the function becomes the immediate next step to satisfy the import. Both edits can be staged in either order (the import will cause a runtime ImportError but not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 defines a new function `do_drop_all_analytics_tables` in the analytics/lib/counts.py file, while Edit 1 imports that exact same function in analytics/management/commands/clear_analytics_tables.py. The changed lines reference the exact same symbol - the function `do_drop_all_analytics_tables`. After defining the function in Edit 0, importing it in Edit 1 becomes a natural next step if that function needs to be used in the management command. Conversely, if the import is added first, defining the function becomes the immediate next step to satisfy the import. Both edits can be staged in either order (the import will cause a runtime ImportError but not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 imports the function `do_drop_all_analytics_tables` from `analytics.lib.counts`, and Edit 1 calls that exact same function `do_drop_all_analytics_tables()` in the handle method. The changed lines reference the exact same symbol - the function being imported in edit 0 is the same function being called in edit 1. This creates an immediate code dependency where importing the function naturally prompts its usage, and using the function requires its import. Both edits can be staged in either order since Python allows calling undefined functions (runtime NameError only, not a parse error)."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 imports the function `do_drop_all_analytics_tables` from `analytics.lib.counts`, and Edit 1 calls that exact same function `do_drop_all_analytics_tables()` in the handle method. The changed lines reference the exact same symbol - the function being imported in edit 0 is the same function being called in edit 1. This creates an immediate code dependency where importing the function naturally prompts its usage, and using the function requires its import. Both edits can be staged in either order since Python allows calling undefined functions (runtime NameError only, not a parse error)."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 removes the CLEAR_QUERY constant definition and adds a typing import, while Edit 1 removes the usage of CLEAR_QUERY and replaces it with a function call. The changed lines in both edits reference the exact same symbol (CLEAR_QUERY) - Edit 0 removes its definition and Edit 1 removes its usage. This creates a direct code dependency where removing the definition naturally prompts removing its usage as the next mechanical step, or vice versa. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 removes the CLEAR_QUERY constant definition and adds a typing import, while Edit 1 removes the usage of CLEAR_QUERY and replaces it with a function call. The changed lines in both edits reference the exact same symbol (CLEAR_QUERY) - Edit 0 removes its definition and Edit 1 removes its usage. This creates a direct code dependency where removing the definition naturally prompts removing its usage as the next mechanical step, or vice versa. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitution (capitalizing 'Analytics' to lowercase 'analytics') on the same type of syntactic construct (help strings). This is a uniform pattern-based refactor where both changes are part of the same contiguous micro-task to standardize the capitalization of 'analytics' throughout the file. The edits are mechanically linked by the identical before\u2192after pattern and would naturally occur together in a single search-and-replace operation."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitution (capitalizing 'Analytics' to lowercase 'analytics') on the same type of syntactic construct (help strings). This is a uniform pattern-based refactor where both changes are part of the same contiguous micro-task to standardize the capitalization of 'analytics' throughout the file. The edits are mechanically linked by the identical before\u2192after pattern and would naturally occur together in a single search-and-replace operation."
        }
    ],
    "allowed_init_edits": [
        2,
        3,
        4
    ]
}