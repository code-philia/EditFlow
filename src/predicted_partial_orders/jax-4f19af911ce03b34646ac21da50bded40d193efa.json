{
    "partial_orders": [
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits modify the same test function and are directly related through the shape variable. Edit 0 changes the shape tuple from 3D to 4D by adding a new dimension (2) at index 1. Edit 1 updates the memref_slice calls to account for this new dimension by adding slice(None) to handle the additional dimension in the indexing. The changed lines in edit 1 directly reference and must accommodate the structural change made in edit 0 - the dst memref now has 4 dimensions instead of 3, requiring the indexing to be updated accordingly. This creates an immediate, mechanically obvious code dependency where edit 0's shape change necessitates edit 1's indexing updates."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits are part of the same test function and involve changing the same constant value from 32 to 16 in related calculations. Edit 0 changes the shape calculation from '32 * cluster[collective_dim]' to '16 * cluster[collective_dim]', and Edit 1 changes the slice calculation from 'c(32, index)' and slice size 32 to 'c(16, index)' and slice size 16. These are synchronized changes maintaining consistency between the shape definition and its usage in the kernel - both reference the same dimensional scaling factor that needs to be kept in sync. This represents a uniform substitution pattern where the same constant (32\u219216) is being updated across related calculations within the same test method."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits are part of the same test function and involve changing the same constant value from 32 to 16 in related calculations. Edit 0 changes the shape calculation from '32 * cluster[collective_dim]' to '16 * cluster[collective_dim]', and Edit 1 changes the slice calculation from 'c(32, index)' and slice size 32 to 'c(16, index)' and slice size 16. These are synchronized changes maintaining consistency between the shape definition and its usage in the kernel - both reference the same dimensional scaling factor that needs to be kept in sync. This represents a uniform substitution pattern where the same constant (32\u219216) is being updated across related calculations within the same test method."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 defines a new function `partition_dim` and introduces a variable `slice_size` in a loop. Edit 1 immediately uses both the `partition_dim` function (calling it) and the `slice_size` variable (referencing it multiple times) in the very next lines of code. The changed lines in edit 1 directly reference the exact same symbols that were defined in edit 0's changed lines. This creates an immediate, mechanically obvious code dependency where edit 0 must come first since edit 1 cannot be parsed without the `partition_dim` function definition, making this an ordered relationship."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 removes the old loop that defined and used the variable 'collective_slice_dim', replacing it with a new implementation using a 'partition_dim' function. Edit 1 removes code that references 'collective_slice_dim' multiple times. After edit 0 is applied, the variable 'collective_slice_dim' is no longer defined, making edit 1's removal of references to this undefined variable the immediate next step to avoid NameError. The edits reference the exact same symbol 'collective_slice_dim' - edit 0 removes its definition and edit 1 removes its usage."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}