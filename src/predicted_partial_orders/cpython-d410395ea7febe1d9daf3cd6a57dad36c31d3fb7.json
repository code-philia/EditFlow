{
    "partial_orders": [
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 introduces a variable 'before' that captures the length of the write buffer before extending it. Edit 1 then uses this exact same variable 'before' to calculate how much was written by subtracting it from the current buffer length. The variable 'before' defined in edit 0 is directly referenced in edit 1's changed line. Edit 1 cannot be parsed/executed without edit 0 first defining the 'before' variable, making this an ordered dependency where edit 0 must come before edit 1."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 defines a variable 'written' by calculating 'len(self._write_buf) - before', and Edit 1 uses that exact same variable 'written' in a return statement, replacing 'len(b)'. The changed lines reference the exact same symbol 'written'. After making Edit 0, the variable 'written' becomes available for use, making Edit 1 the immediate next step to utilize this newly defined variable. After making Edit 1, the return statement references 'written' which was defined in Edit 0, creating a direct dependency. This is a classic definition-usage relationship within the same function scope where both edits reference the exact same symbol."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 defines a variable 'written' by calculating 'len(self._write_buf) - before', and Edit 1 uses that exact same variable 'written' in a return statement, replacing 'len(b)'. The changed lines reference the exact same symbol 'written'. After making Edit 0, the variable 'written' becomes available for use, making Edit 1 the immediate next step to utilize this newly defined variable. After making Edit 1, the return statement references 'written' which was defined in Edit 0, creating a direct dependency. This is a classic definition-usage relationship within the same function scope where both edits reference the exact same symbol."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 imports the 'array' module, and Edit 1 uses that exact same 'array' module in the test function by calling 'array.array()'. The changed lines reference the exact same symbol - the 'array' module. After importing 'array' in Edit 0, using it in Edit 1 becomes the natural next step. Both edits can be staged in either order since Python allows usage before import (resulting in a runtime NameError only, not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the immediate next mechanical step."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 imports the 'array' module, and Edit 1 uses that exact same 'array' module in the test function by calling 'array.array()'. The changed lines reference the exact same symbol - the 'array' module. After importing 'array' in Edit 0, using it in Edit 1 becomes the natural next step. Both edits can be staged in either order since Python allows usage before import (resulting in a runtime NameError only, not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the immediate next mechanical step."
        }
    ],
    "allowed_init_edits": [
        3,
        0,
        1,
        2
    ]
}