{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 adds a 'home_finder' parameter to the AbstractNativeImageConfig.__init__ method signature. Edit 1 updates the super().__init__ call in LauncherConfig to explicitly pass the home_finder parameter. These edits reference the exact same symbol (the home_finder parameter) and create a direct code dependency - after adding the parameter to the parent class signature, the child class's super() call needs to be updated to handle the new parameter. This is a classic signature-caller relationship for the same method."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 adds a 'home_finder' parameter to the AbstractNativeImageConfig.__init__ method signature. Edit 1 updates the super().__init__ call in LauncherConfig to explicitly pass the home_finder parameter. These edits reference the exact same symbol (the home_finder parameter) and create a direct code dependency - after adding the parameter to the parent class signature, the child class's super() call needs to be updated to handle the new parameter. This is a classic signature-caller relationship for the same method."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits add the same parameter 'home_finder' to constructor signatures in a class hierarchy where LauncherConfig inherits from AbstractNativeImageConfig. Edit 0 adds 'home_finder=False' to the parent class constructor, while Edit 1 adds 'home_finder=True' to the child class constructor. This represents parameter threading through an inheritance hierarchy where both changed lines explicitly reference the same parameter symbol 'home_finder'. The edits are part of a synchronized parameter addition that maintains the constructor contract between parent and child classes. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain parameter consistency in the inheritance chain."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits add the same parameter 'home_finder' to constructor signatures in a class hierarchy where LauncherConfig inherits from AbstractNativeImageConfig. Edit 0 adds 'home_finder=False' to the parent class constructor, while Edit 1 adds 'home_finder=True' to the child class constructor. This represents parameter threading through an inheritance hierarchy where both changed lines explicitly reference the same parameter symbol 'home_finder'. The edits are part of a synchronized parameter addition that maintains the constructor contract between parent and child classes. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain parameter consistency in the inheritance chain."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds a 'home_finder' parameter to the AbstractNativeImageConfig constructor signature. Edit 1 uses this exact same parameter by accessing 'image_config.home_finder' in a conditional check. The changed lines reference the exact same symbol - the 'home_finder' attribute. After adding the parameter in edit 0, the usage in edit 1 becomes the immediate next step to utilize this new parameter. Both edits can be staged in either order since Python allows attribute access on objects even if the attribute was added later, and both reference the same symbol."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds a 'home_finder' parameter to the AbstractNativeImageConfig constructor signature. Edit 1 uses this exact same parameter by accessing 'image_config.home_finder' in a conditional check. The changed lines reference the exact same symbol - the 'home_finder' attribute. After adding the parameter in edit 0, the usage in edit 1 becomes the immediate next step to utilize this new parameter. Both edits can be staged in either order since Python allows attribute access on objects even if the attribute was added later, and both reference the same symbol."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 adds a 'home_finder' parameter assignment in the AbstractNativeImageConfig.__init__ method, while Edit 1 adds 'home_finder=home_finder' to the super() call in LauncherConfig.__init__. These edits reference the exact same symbol 'home_finder' and create a direct code dependency - after adding the parameter assignment in the parent class (Edit 0), the child class's super() call (Edit 1) needs to be updated to pass this parameter. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate, mechanically obvious prompt for the other to maintain proper parameter threading between parent and child constructors."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 adds a 'home_finder' parameter assignment in the AbstractNativeImageConfig.__init__ method, while Edit 1 adds 'home_finder=home_finder' to the super() call in LauncherConfig.__init__. These edits reference the exact same symbol 'home_finder' and create a direct code dependency - after adding the parameter assignment in the parent class (Edit 0), the child class's super() call (Edit 1) needs to be updated to pass this parameter. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate, mechanically obvious prompt for the other to maintain proper parameter threading between parent and child constructors."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'home_finder' within the same function. Edit 0 adds 'home_finder' as a parameter to the __init__ method signature, and Edit 1 adds the assignment 'self.home_finder = home_finder' in the function body. This creates a direct code dependency where the parameter added in Edit 0 is immediately used in Edit 1. After making either edit, the other becomes the mechanically obvious next step to complete the parameter threading pattern. Both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'home_finder' within the same function. Edit 0 adds 'home_finder' as a parameter to the __init__ method signature, and Edit 1 adds the assignment 'self.home_finder = home_finder' in the function body. This creates a direct code dependency where the parameter added in Edit 0 is immediately used in Edit 1. After making either edit, the other becomes the mechanically obvious next step to complete the parameter threading pattern. Both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 adds a 'home_finder' attribute to the AbstractNativeImageConfig class constructor, while Edit 1 uses that exact same 'home_finder' attribute by accessing 'image_config.home_finder'. The changed lines reference the exact same symbol - the 'home_finder' attribute of the image_config object. After adding the attribute in Edit 0, Edit 1 becomes the immediate next step to use that newly added attribute. This creates a direct code dependency where the usage in Edit 1 depends on the definition in Edit 0, making them neighbors in mental flow within a single micro-task of adding and immediately using a new attribute."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 adds a 'home_finder' attribute to the AbstractNativeImageConfig class constructor, while Edit 1 uses that exact same 'home_finder' attribute by accessing 'image_config.home_finder'. The changed lines reference the exact same symbol - the 'home_finder' attribute of the image_config object. After adding the attribute in Edit 0, Edit 1 becomes the immediate next step to use that newly added attribute. This creates a direct code dependency where the usage in Edit 1 depends on the definition in Edit 0, making them neighbors in mental flow within a single micro-task of adding and immediately using a new attribute."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits involve the exact same parameter 'home_finder' being added to the LauncherConfig class. Edit 0 adds 'home_finder=True' to the __init__ method signature, and Edit 1 passes that same parameter to the parent class constructor call via 'home_finder=home_finder'. This creates a direct code dependency where the parameter added in the signature (Edit 0) must be threaded through to the parent constructor (Edit 1). Both changed lines explicitly reference the same 'home_finder' symbol, making this a clear case of parameter threading within the same function. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate, mechanically obvious prompt for the other as the next step to complete the parameter threading."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits involve the exact same parameter 'home_finder' being added to the LauncherConfig class. Edit 0 adds 'home_finder=True' to the __init__ method signature, and Edit 1 passes that same parameter to the parent class constructor call via 'home_finder=home_finder'. This creates a direct code dependency where the parameter added in the signature (Edit 0) must be threaded through to the parent constructor (Edit 1). Both changed lines explicitly reference the same 'home_finder' symbol, making this a clear case of parameter threading within the same function. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate, mechanically obvious prompt for the other as the next step to complete the parameter threading."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 adds a 'home_finder=True' parameter to the LauncherConfig constructor, and Edit 1 uses this exact same parameter by accessing 'image_config.home_finder' in conditional logic. The changed lines reference the exact same symbol - the home_finder attribute of the LauncherConfig class. After adding the parameter in Edit 0, the usage in Edit 1 becomes the immediate next step to implement the functionality that parameter controls. Both edits can be staged in either order since Python allows attribute access on objects even if the attribute was added later, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 adds a 'home_finder=True' parameter to the LauncherConfig constructor, and Edit 1 uses this exact same parameter by accessing 'image_config.home_finder' in conditional logic. The changed lines reference the exact same symbol - the home_finder attribute of the LauncherConfig class. After adding the parameter in Edit 0, the usage in Edit 1 becomes the immediate next step to implement the functionality that parameter controls. Both edits can be staged in either order since Python allows attribute access on objects even if the attribute was added later, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "These edits involve moving the exact same two lines of code from one location to another within the same method. Edit 1 removes the HomeFinderFeature lines from their original location, while Edit 0 adds those identical lines to a new location under a different conditional block (if image_config.home_finder). This is a classic cut-and-paste move operation where the removal must occur before the relocation to avoid duplication. The changed lines reference the exact same code elements being relocated."
        }
    ],
    "allowed_init_edits": [
        6,
        4
    ]
}