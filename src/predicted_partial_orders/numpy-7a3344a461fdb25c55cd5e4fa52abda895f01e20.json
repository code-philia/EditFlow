{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 introduces a reference to 'StructuredVoidFormat' class in a conditional branch, while Edit 1 defines that exact same class by renaming 'StructureFormat' to 'StructuredVoidFormat'. The changed lines reference the exact same symbol - 'StructuredVoidFormat'. After making either edit, the other becomes the immediate next step: if you define the class first, you can then use it; if you reference it first, you need to define it. Both edits can be parsed and staged in either order in Python (referencing an undefined class only causes a runtime NameError, not a parse error), making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 introduces a reference to 'StructuredVoidFormat' class in a conditional branch, while Edit 1 defines that exact same class by renaming 'StructureFormat' to 'StructuredVoidFormat'. The changed lines reference the exact same symbol - 'StructuredVoidFormat'. After making either edit, the other becomes the immediate next step: if you define the class first, you can then use it; if you reference it first, you need to define it. Both edits can be parsed and staged in either order in Python (referencing an undefined class only causes a runtime NameError, not a parse error), making this a bi-directional relationship."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 removes a reference to 'StructureFormat' class, while Edit 1 renames the 'StructureFormat' class to 'StructuredVoidFormat'. These edits reference the exact same symbol - the StructureFormat class. After renaming the class in Edit 1, the reference in Edit 0 would become undefined, making the removal in Edit 0 necessary. Conversely, if Edit 0 removes the reference first, then Edit 1 can safely rename the class without breaking any existing references. Both edits are part of the same refactoring operation where a class is being renamed and its usage is being removed. Either edit can be performed first, and after making either edit, the other becomes the immediate next step to complete the refactoring."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 removes a reference to 'StructureFormat' class, while Edit 1 renames the 'StructureFormat' class to 'StructuredVoidFormat'. These edits reference the exact same symbol - the StructureFormat class. After renaming the class in Edit 1, the reference in Edit 0 would become undefined, making the removal in Edit 0 necessary. Conversely, if Edit 0 removes the reference first, then Edit 1 can safely rename the class without breaking any existing references. Both edits are part of the same refactoring operation where a class is being renamed and its usage is being removed. Either edit can be performed first, and after making either edit, the other becomes the immediate next step to complete the refactoring."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution, changing 'StructureFormat' to 'StructuredVoidFormat'. Edit 0 changes it in a docstring comment, while Edit 1 changes it in actual code that calls the class method. This represents a uniform find-and-replace operation targeting the same class name across different contexts. Both edits reference the exact same symbol (the class name) and appear to be part of a single refactoring task to rename the class consistently throughout the codebase."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution, changing 'StructureFormat' to 'StructuredVoidFormat'. Edit 0 changes it in a docstring comment, while Edit 1 changes it in actual code that calls the class method. This represents a uniform find-and-replace operation targeting the same class name across different contexts. Both edits reference the exact same symbol (the class name) and appear to be part of a single refactoring task to rename the class consistently throughout the codebase."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits are part of renaming the same class from 'StructureFormat' to 'StructuredVoidFormat'. Edit 0 changes the class name declaration, while edit 1 updates a docstring reference to use the new class name. Both edits reference the exact same symbol (the class name) and are part of a single refactoring operation. After making either edit, the other becomes immediately necessary to maintain consistency - if you rename the class but don't update the docstring reference, or vice versa, you have an inconsistent codebase. This is a bi-directional relationship as either edit can be made first and both reference the same symbol."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits are part of renaming the same class from 'StructureFormat' to 'StructuredVoidFormat'. Edit 0 changes the class name declaration, while edit 1 updates a docstring reference to use the new class name. Both edits reference the exact same symbol (the class name) and are part of a single refactoring operation. After making either edit, the other becomes immediately necessary to maintain consistency - if you rename the class but don't update the docstring reference, or vice versa, you have an inconsistent codebase. This is a bi-directional relationship as either edit can be made first and both reference the same symbol."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol - they are renaming the class 'StructureFormat' to 'StructuredVoidFormat'. Edit 0 changes the class definition/name, and edit 1 updates the usage of that same class name in a function call. This creates a direct code dependency where both edits reference the identical symbol, and making either edit creates an immediate prompt for the other to maintain code consistency. The relationship is bi-directional because both edits can be staged in either order without causing parse errors - the old name would still be valid until both changes are complete."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol - they are renaming the class 'StructureFormat' to 'StructuredVoidFormat'. Edit 0 changes the class definition/name, and edit 1 updates the usage of that same class name in a function call. This creates a direct code dependency where both edits reference the identical symbol, and making either edit creates an immediate prompt for the other to maintain code consistency. The relationship is bi-directional because both edits can be staged in either order without causing parse errors - the old name would still be valid until both changes are complete."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 renames the class from 'StructureFormat' to 'StructuredVoidFormat', while Edit 1 creates a new 'StructureFormat' class that inherits from 'StructuredVoidFormat'. The changed lines in both edits reference the exact same symbol 'StructuredVoidFormat' - Edit 0 defines it as the new class name, and Edit 1 uses it as the parent class in the inheritance declaration. This creates a direct code dependency where Edit 1 cannot be parsed without Edit 0 being present first, as 'StructuredVoidFormat' would be undefined. This is a classic definition-before-usage scenario where the second edit would cause a NameError if staged before the first."
        }
    ],
    "allowed_init_edits": [
        6
    ]
}