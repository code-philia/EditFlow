{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual and structural substitution within the same file and class. They both change the condition 'if not apps.ready:' to 'if not apps.ready and not apps.stored_app_configs:' and add the same explanatory comment. This is a clear case of bulk-edit pattern synchronization where the same before\u2192after pattern is applied to the same type of syntactic construct (conditional statements) in two different methods of the same class. Both edits reference the exact same symbols (apps.ready, apps.stored_app_configs) and represent a single, contiguous refactoring operation."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual and structural substitution within the same file and class. They both change the condition 'if not apps.ready:' to 'if not apps.ready and not apps.stored_app_configs:' and add the same explanatory comment. This is a clear case of bulk-edit pattern synchronization where the same before\u2192after pattern is applied to the same type of syntactic construct (conditional statements) in two different methods of the same class. Both edits reference the exact same symbols (apps.ready, apps.stored_app_configs) and represent a single, contiguous refactoring operation."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual and structural substitution on the same type of syntactic construct. They both change the condition 'if not apps.ready:' to 'if not apps.ready and not apps.stored_app_configs:' and add the same explanatory comment. This is a clear case of bulk-edit pattern synchronization where the same before\u2192after pattern is applied to identical construct types (conditional statements) within the same file. Both edits reference the exact same symbols (apps.ready, apps.stored_app_configs) and represent a single, contiguous refactor operation."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual and structural substitution on the same type of syntactic construct. They both change the condition 'if not apps.ready:' to 'if not apps.ready and not apps.stored_app_configs:' and add the same explanatory comment. This is a clear case of bulk-edit pattern synchronization where the same before\u2192after pattern is applied to identical construct types (conditional statements) within the same file. Both edits reference the exact same symbols (apps.ready, apps.stored_app_configs) and represent a single, contiguous refactor operation."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "These edits reference the exact same symbol 'apps.stored_app_configs' and are part of a synchronized change. Edit 0 adds a condition checking 'apps.stored_app_configs' in the warning logic, while Edit 1 restores the 'stored_app_configs' attribute in test cleanup. Both changed lines explicitly reference the same attribute symbol, and they appear to be implementing a coordinated feature where the test infrastructure sets up this attribute and the production code checks for it. This creates a direct code dependency where both edits work together to implement the same functionality."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "These edits reference the exact same symbol 'apps.stored_app_configs' and are part of a synchronized change. Edit 0 adds a condition checking 'apps.stored_app_configs' in the warning logic, while Edit 1 restores the 'stored_app_configs' attribute in test cleanup. Both changed lines explicitly reference the same attribute symbol, and they appear to be implementing a coordinated feature where the test infrastructure sets up this attribute and the production code checks for it. This creates a direct code dependency where both edits work together to implement the same functionality."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both change the condition 'if not apps.ready:' to 'if not apps.ready and not apps.stored_app_configs:' and add the same comment. This is a clear bulk-edit pattern where the same before\u2192after transformation is applied to two similar conditional statements within the same class. The edits are part of a single, contiguous refactor to modify the warning condition logic consistently across both methods."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both change the condition 'if not apps.ready:' to 'if not apps.ready and not apps.stored_app_configs:' and add the same comment. This is a clear bulk-edit pattern where the same before\u2192after transformation is applied to two similar conditional statements within the same class. The edits are part of a single, contiguous refactor to modify the warning condition logic consistently across both methods."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 assigns a value to the variable 'old_stored_app_configs' and edit 1 references that exact same variable. The changed lines reference the same symbol - 'old_stored_app_configs' is defined in edit 0 and used in edit 1. This creates an immediate code dependency where edit 0 must occur before edit 1, as edit 1 cannot reference an undefined variable. In Python, while referencing undefined variables doesn't cause parse errors, this appears to be a clear save-and-restore pattern within the same function where the variable assignment in edit 0 directly enables the usage in edit 1."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Edit 0 imports CaptureQueriesContext and override_settings from django.test.utils, and Edit 1 uses these exact same imported symbols in the new test method. The changed lines in Edit 1 directly reference the symbols that were imported in Edit 0's changed line. This creates an immediate code dependency where after importing these symbols, they can be used in the test method, and vice versa - if the test method is written first, the imports would be needed. Both edits reference the exact same symbols and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Edit 0 imports CaptureQueriesContext and override_settings from django.test.utils, and Edit 1 uses these exact same imported symbols in the new test method. The changed lines in Edit 1 directly reference the symbols that were imported in Edit 0's changed line. This creates an immediate code dependency where after importing these symbols, they can be used in the test method, and vice versa - if the test method is written first, the imports would be needed. Both edits reference the exact same symbols and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 imports the function `get_hstore_oids` from `django.contrib.postgres.signals`, and Edit 1 uses that exact same imported function by calling `get_hstore_oids.cache_clear()`. The changed lines reference the exact same symbol - the `get_hstore_oids` function. This creates an immediate code dependency where importing the function (Edit 0) enables its usage (Edit 1) within the same file. Both edits can be staged in either order since Python allows referencing undefined symbols at parse time (they only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 imports the function `get_hstore_oids` from `django.contrib.postgres.signals`, and Edit 1 uses that exact same imported function by calling `get_hstore_oids.cache_clear()`. The changed lines reference the exact same symbol - the `get_hstore_oids` function. This creates an immediate code dependency where importing the function (Edit 0) enables its usage (Edit 1) within the same file. Both edits can be staged in either order since Python allows referencing undefined symbols at parse time (they only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        }
    ],
    "allowed_init_edits": [
        3
    ]
}