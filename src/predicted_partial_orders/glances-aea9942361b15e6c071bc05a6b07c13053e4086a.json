{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds NoSectionError to the import statement from glances.compat, and Edit 1 uses that newly imported NoSectionError in an except clause. The changed lines reference the exact same symbol (NoSectionError) - Edit 0 imports it and Edit 1 uses it. After making Edit 0, the next immediate code-driven step would be to use the newly imported exception, which is exactly what Edit 1 does. This creates a direct definition-usage relationship where both edits reference the same symbol."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds NoSectionError to the import statement from glances.compat, and Edit 1 uses that newly imported NoSectionError in an except clause. The changed lines reference the exact same symbol (NoSectionError) - Edit 0 imports it and Edit 1 uses it. After making Edit 0, the next immediate code-driven step would be to use the newly imported exception, which is exactly what Edit 1 does. This creates a direct definition-usage relationship where both edits reference the same symbol."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same type of syntactic construct (exception handling blocks). This is a uniform refactoring operation where the same before\u2192after pattern is applied to multiple locations of the same construct type within the same class. Both edits are part of a single, contiguous refactor to improve exception handling consistency across similar methods in the Config class."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same type of syntactic construct (exception handling blocks). This is a uniform refactoring operation where the same before\u2192after pattern is applied to multiple locations of the same construct type within the same class. Both edits are part of a single, contiguous refactor to improve exception handling consistency across similar methods in the Config class."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same type of syntactic construct (exception handling blocks). This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same construct type across multiple locations in the same file. Both edits are part of a single, contiguous refactor to handle an additional exception type consistently throughout the Config class methods."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same type of syntactic construct (exception handling blocks). This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same construct type across multiple locations in the same file. Both edits are part of a single, contiguous refactor to handle an additional exception type consistently throughout the Config class methods."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same class (Config). This is a uniform bulk edit applying the same before\u2192after pattern to the same type of syntactic construct (exception handling clauses) within the same class context. Both edits are part of a single refactoring task to handle an additional exception type consistently across similar methods."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same class (Config). This is a uniform bulk edit applying the same before\u2192after pattern to the same type of syntactic construct (exception handling clauses) within the same class context. Both edits are part of a single refactoring task to handle an additional exception type consistently across similar methods."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds NoSectionError to the import statement, and Edit 1 uses that exact same NoSectionError symbol in an exception handler. The changed line in Edit 0 imports NoSectionError, and the changed line in Edit 1 references NoSectionError in the except clause. This creates a direct definition-usage relationship where both edits reference the exact same symbol. In Python, the usage can be written before the import (it would only fail at runtime), so either edit can be staged first, making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds NoSectionError to the import statement, and Edit 1 uses that exact same NoSectionError symbol in an exception handler. The changed line in Edit 0 imports NoSectionError, and the changed line in Edit 1 references NoSectionError in the except clause. This creates a direct definition-usage relationship where both edits reference the exact same symbol. In Python, the usage can be written before the import (it would only fail at runtime), so either edit can be staged first, making this bi-directional."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds NoSectionError to the import statement, and Edit 1 uses that exact same NoSectionError symbol in an exception handler. The changed lines reference the exact same symbol - NoSectionError. After importing NoSectionError in edit 0, it becomes available for use in edit 1. After using NoSectionError in edit 1, the import in edit 0 becomes necessary. This is a classic import-usage relationship within the same file where both edits reference the identical symbol."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds NoSectionError to the import statement, and Edit 1 uses that exact same NoSectionError symbol in an exception handler. The changed lines reference the exact same symbol - NoSectionError. After importing NoSectionError in edit 0, it becomes available for use in edit 1. After using NoSectionError in edit 1, the import in edit 0 becomes necessary. This is a classic import-usage relationship within the same file where both edits reference the identical symbol."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same type of syntactic construct (exception handling blocks). This is a uniform refactoring operation where the same before\u2192after pattern is applied to similar code structures within the same class. Both edits are part of a single, contiguous micro-task to improve exception handling consistency across similar methods."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same type of syntactic construct (exception handling blocks). This is a uniform refactoring operation where the same before\u2192after pattern is applied to similar code structures within the same class. Both edits are part of a single, contiguous micro-task to improve exception handling consistency across similar methods."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same type of syntactic construct (exception handling blocks). This is a uniform refactoring operation where the same before\u2192after pattern is applied to multiple similar code locations within the same class. Both edits target exception handling in getter methods of the Config class, making this a clear case of bulk-edit synchronization where either edit could be made first and would naturally prompt the developer to apply the same pattern to the other similar method."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same type of syntactic construct (exception handling blocks). This is a uniform refactoring operation where the same before\u2192after pattern is applied to multiple similar code locations within the same class. Both edits target exception handling in getter methods of the Config class, making this a clear case of bulk-edit synchronization where either edit could be made first and would naturally prompt the developer to apply the same pattern to the other similar method."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same file. This is a uniform bulk edit applying the same before\u2192after pattern to the same type of syntactic construct (exception handling clauses) within similar methods of the same class. Both edits are part of a single refactoring operation to handle an additional exception type consistently across similar methods."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'except NoOptionError:' to 'except (NoOptionError, NoSectionError):' in the same file. This is a uniform bulk edit applying the same before\u2192after pattern to the same type of syntactic construct (exception handling clauses) within similar methods of the same class. Both edits are part of a single refactoring operation to handle an additional exception type consistently across similar methods."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 adds NoSectionError to the import statement, and Edit 1 uses that exact same NoSectionError symbol in an exception handler. The changed line in Edit 0 imports NoSectionError, and the changed line in Edit 1 references NoSectionError in the except clause. This creates a direct definition-usage relationship where both edits reference the exact same symbol. After importing NoSectionError in Edit 0, using it in Edit 1 becomes the immediate next step. Since Python allows referencing undefined symbols at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 adds NoSectionError to the import statement, and Edit 1 uses that exact same NoSectionError symbol in an exception handler. The changed line in Edit 0 imports NoSectionError, and the changed line in Edit 1 references NoSectionError in the except clause. This creates a direct definition-usage relationship where both edits reference the exact same symbol. After importing NoSectionError in Edit 0, using it in Edit 1 becomes the immediate next step. Since Python allows referencing undefined symbols at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        }
    ],
    "allowed_init_edits": [
        5
    ]
}