{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits modify calls to the same function `export_archived_records` by adding the same parameter `needs_confirm`. Edit 0 adds `needs_confirm=not args.yes` to the actual function call in the production code, while Edit 1 adds `needs_confirm=True` to the test assertion that verifies this exact same function call. The changed lines in both edits reference the exact same symbol (the `export_archived_records` function) and the same parameter being added. This is a classic test-production code synchronization pattern where a parameter addition to a function call requires updating the corresponding test assertion to match the new signature. Either edit could be made first and would immediately prompt the other as the next mechanical step to maintain test-code consistency."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits modify calls to the same function `export_archived_records` by adding the same parameter `needs_confirm`. Edit 0 adds `needs_confirm=not args.yes` to the actual function call in the production code, while Edit 1 adds `needs_confirm=True` to the test assertion that verifies this exact same function call. The changed lines in both edits reference the exact same symbol (the `export_archived_records` function) and the same parameter being added. This is a classic test-production code synchronization pattern where a parameter addition to a function call requires updating the corresponding test assertion to match the new signature. Either edit could be made first and would immediately prompt the other as the next mechanical step to maintain test-code consistency."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds ARG_YES parameter to the export-archived CLI command configuration, while Edit 1 updates the corresponding test assertion to include needs_confirm=True parameter. These edits reference the same CLI command functionality - the export_archived function - where adding the ARG_YES argument in the CLI configuration requires updating the test to expect the corresponding needs_confirm parameter. The changed lines in both edits are directly related to the same command's parameter signature, making one edit immediately prompt for the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds ARG_YES parameter to the export-archived CLI command configuration, while Edit 1 updates the corresponding test assertion to include needs_confirm=True parameter. These edits reference the same CLI command functionality - the export_archived function - where adding the ARG_YES argument in the CLI configuration requires updating the test to expect the corresponding needs_confirm parameter. The changed lines in both edits are directly related to the same command's parameter signature, making one edit immediately prompt for the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits modify calls to the same function `export_archived_records`. Edit 0 adds the `needs_confirm=not args.yes` parameter to the function call in the production code, while Edit 1 adds the `needs_confirm=True` parameter to the mock assertion in the test code that verifies the same function call. The changed lines in both edits reference the exact same function symbol and the same parameter being added. After making either edit, the other becomes immediately necessary to maintain consistency between the production code and its corresponding test assertion. This is a classic test-production code synchronization pattern where both edits reference the exact same method call."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits modify calls to the same function `export_archived_records`. Edit 0 adds the `needs_confirm=not args.yes` parameter to the function call in the production code, while Edit 1 adds the `needs_confirm=True` parameter to the mock assertion in the test code that verifies the same function call. The changed lines in both edits reference the exact same function symbol and the same parameter being added. After making either edit, the other becomes immediately necessary to maintain consistency between the production code and its corresponding test assertion. This is a classic test-production code synchronization pattern where both edits reference the exact same method call."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds ARG_YES to the CLI command arguments for export-archived, while Edit 1 adds needs_confirm=True to the test assertion for the same export_archived function call. These edits are synchronizing the CLI interface with its test - when ARG_YES is added to the command arguments, the corresponding test needs to be updated to expect the needs_confirm parameter. Both edits reference the same export_archived function and are part of adding confirmation functionality to the same command. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain test-code synchronization."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds ARG_YES to the CLI command arguments for export-archived, while Edit 1 adds needs_confirm=True to the test assertion for the same export_archived function call. These edits are synchronizing the CLI interface with its test - when ARG_YES is added to the command arguments, the corresponding test needs to be updated to expect the needs_confirm parameter. Both edits reference the same export_archived function and are part of adding confirmation functionality to the same command. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain test-code synchronization."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits modify calls to the same function `export_archived_records` by adding the same parameter `needs_confirm`. Edit 0 adds `needs_confirm=not args.yes` to the actual function call in the production code, while Edit 1 adds `needs_confirm=True` to the mock assertion that verifies this exact same function call. The changed lines in both edits reference the exact same symbol (the `export_archived_records` function) and the same parameter being added. This creates a direct code dependency where modifying the function signature in one location requires updating the test assertion for that same function call. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt to update the other to maintain test-code synchronization."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits modify calls to the same function `export_archived_records` by adding the same parameter `needs_confirm`. Edit 0 adds `needs_confirm=not args.yes` to the actual function call in the production code, while Edit 1 adds `needs_confirm=True` to the mock assertion that verifies this exact same function call. The changed lines in both edits reference the exact same symbol (the `export_archived_records` function) and the same parameter being added. This creates a direct code dependency where modifying the function signature in one location requires updating the test assertion for that same function call. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt to update the other to maintain test-code synchronization."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "These edits show a function signature change and corresponding call-site update for the exact same function 'export_archived_records'. Edit 1 adds a 'needs_confirm' parameter to the function signature, and Edit 0 adds the same parameter to the function call. Both edits reference the exact same symbol and create an immediate code-driven prompt for each other - after adding the parameter to either the signature or the call site, the other edit becomes the next mechanically required step to maintain consistency."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "These edits show a function signature change and corresponding call-site update for the exact same function 'export_archived_records'. Edit 1 adds a 'needs_confirm' parameter to the function signature, and Edit 0 adds the same parameter to the function call. Both edits reference the exact same symbol and create an immediate code-driven prompt for each other - after adding the parameter to either the signature or the call site, the other edit becomes the next mechanically required step to maintain consistency."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'args.yes' - edit 0 adds ARG_YES to the CLI parser configuration for the export-archived command, and edit 1 uses 'args.yes' in the corresponding command function. This creates a direct definition-usage relationship where the CLI argument defined in edit 0 is immediately consumed in edit 1. After adding the ARG_YES argument to the parser, the natural next step is to use that argument in the command implementation, making this a bi-directional relationship since either edit could be made first and would prompt the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'args.yes' - edit 0 adds ARG_YES to the CLI parser configuration for the export-archived command, and edit 1 uses 'args.yes' in the corresponding command function. This creates a direct definition-usage relationship where the CLI argument defined in edit 0 is immediately consumed in edit 1. After adding the ARG_YES argument to the parser, the natural next step is to use that argument in the command implementation, making this a bi-directional relationship since either edit could be made first and would prompt the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'needs_confirm' within the same function. Edit 0 adds the 'needs_confirm' parameter to the function signature, and Edit 1 uses that same parameter in a conditional expression. After adding the parameter in Edit 0, the natural next step would be to use it in the function body as shown in Edit 1. This creates an immediate, mechanically obvious code-driven prompt where either edit can be made first (the parameter can be added before being used, or the usage can be written before the parameter is formally added to the signature, as Python allows referencing parameters in function bodies even if they're not yet in the signature during development)."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'needs_confirm' within the same function. Edit 0 adds the 'needs_confirm' parameter to the function signature, and Edit 1 uses that same parameter in a conditional expression. After adding the parameter in Edit 0, the natural next step would be to use it in the function body as shown in Edit 1. This creates an immediate, mechanically obvious code-driven prompt where either edit can be made first (the parameter can be added before being used, or the usage can be written before the parameter is formally added to the signature, as Python allows referencing parameters in function bodies even if they're not yet in the signature during development)."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 adds a new parameter 'needs_confirm=True' to the export_archived_records function signature. Edit 1 updates a test assertion that calls this exact same function to include the new 'needs_confirm=True' parameter. The changed lines in both edits reference the exact same function symbol (export_archived_records) and the same parameter (needs_confirm). After adding the parameter to the function signature, the test assertion becomes the immediate next step to maintain test correctness. This is a classic function signature change \u2194 call-site update pattern for the same function, making it bi-directional since either edit can be staged first without causing parse errors."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 adds a new parameter 'needs_confirm=True' to the export_archived_records function signature. Edit 1 updates a test assertion that calls this exact same function to include the new 'needs_confirm=True' parameter. The changed lines in both edits reference the exact same function symbol (export_archived_records) and the same parameter (needs_confirm). After adding the parameter to the function signature, the test assertion becomes the immediate next step to maintain test correctness. This is a classic function signature change \u2194 call-site update pattern for the same function, making it bi-directional since either edit can be staged first without causing parse errors."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds a new parameter 'needs_confirm' to the conditional logic in the export_archived_records function. Edit 1 updates the test assertion to include this same 'needs_confirm=True' parameter in the expected function call. Both edits reference the exact same symbol (the needs_confirm parameter) and are part of synchronizing the test expectations with the updated function signature/behavior. After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the parameter to the function logic, you need to update the test assertion, and vice versa."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds a new parameter 'needs_confirm' to the conditional logic in the export_archived_records function. Edit 1 updates the test assertion to include this same 'needs_confirm=True' parameter in the expected function call. Both edits reference the exact same symbol (the needs_confirm parameter) and are part of synchronizing the test expectations with the updated function signature/behavior. After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the parameter to the function logic, you need to update the test assertion, and vice versa."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 adds a new parameter 'needs_confirm=True' to the export_archived_records function signature. Edit 1 updates the test assertion to include this same new parameter 'needs_confirm=True' when verifying the function call. Both edits reference the exact same function (export_archived_records) and the exact same parameter (needs_confirm). After adding the parameter to the function signature, the test assertion needs to be updated to match, and vice versa - either edit creates an immediate, mechanically obvious prompt for the other as the next step to maintain test-production synchronization."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 adds a new parameter 'needs_confirm=True' to the export_archived_records function signature. Edit 1 updates the test assertion to include this same new parameter 'needs_confirm=True' when verifying the function call. Both edits reference the exact same function (export_archived_records) and the exact same parameter (needs_confirm). After adding the parameter to the function signature, the test assertion needs to be updated to match, and vice versa - either edit creates an immediate, mechanically obvious prompt for the other as the next step to maintain test-production synchronization."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Edit 0 adds a new parameter 'needs_confirm' to the conditional logic in the export_archived_records function. Edit 1 adds the same 'needs_confirm=True' parameter to the mock assertion call for that exact same function. These edits reference the same function and the same parameter - when the function signature or behavior changes to include needs_confirm, the test assertion must be updated to match. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 0 adds a new parameter 'needs_confirm' to the conditional logic in the export_archived_records function. Edit 1 adds the same 'needs_confirm=True' parameter to the mock assertion call for that exact same function. These edits reference the same function and the same parameter - when the function signature or behavior changes to include needs_confirm, the test assertion must be updated to match. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 adds a new parameter 'needs_confirm=True' to the function signature of export_archived_records. Edit 1 updates a test assertion that calls this exact same function to include the new 'needs_confirm=True' parameter. The changed lines in both edits reference the exact same function symbol (export_archived_records) and the same parameter (needs_confirm). After adding the parameter to the function signature, the test assertion becomes the immediate next step to maintain test correctness. This is a classic function signature change \u2194 call-site update pattern for the same function, making it bi-directional since either edit can be staged first without causing parse errors."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 adds a new parameter 'needs_confirm=True' to the function signature of export_archived_records. Edit 1 updates a test assertion that calls this exact same function to include the new 'needs_confirm=True' parameter. The changed lines in both edits reference the exact same function symbol (export_archived_records) and the same parameter (needs_confirm). After adding the parameter to the function signature, the test assertion becomes the immediate next step to maintain test correctness. This is a classic function signature change \u2194 call-site update pattern for the same function, making it bi-directional since either edit can be staged first without causing parse errors."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 adds a new parameter 'needs_confirm' to the conditional logic in the export_archived_records function. Edit 1 adds the same 'needs_confirm=True' parameter to a mock assertion that tests calls to export_archived_records. Both edits reference the exact same parameter symbol 'needs_confirm' - one adds it to the function's conditional logic, and the other adds it to the test assertion for that same function. This creates a direct code dependency where the test needs to be updated to match the new parameter usage in the production code. Either edit could be made first and would prompt the other as the immediate next step to maintain test-code synchronization."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 adds a new parameter 'needs_confirm' to the conditional logic in the export_archived_records function. Edit 1 adds the same 'needs_confirm=True' parameter to a mock assertion that tests calls to export_archived_records. Both edits reference the exact same parameter symbol 'needs_confirm' - one adds it to the function's conditional logic, and the other adds it to the test assertion for that same function. This creates a direct code dependency where the test needs to be updated to match the new parameter usage in the production code. Either edit could be made first and would prompt the other as the immediate next step to maintain test-code synchronization."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits are adding the exact same parameter 'needs_confirm=True' to mock assertion calls for the same function 'export_archived_mock.assert_called_once_with'. This represents a synchronized parameter addition pattern where both test methods are being updated to expect the same new parameter in their assertions. The edits reference the same mock object and are part of the same type of syntactic construct (mock assertions), making this a bulk-edit pattern synchronization. Either edit could be made first, and after making one, the other becomes an immediate next step to maintain consistency across the test suite."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits are adding the exact same parameter 'needs_confirm=True' to mock assertion calls for the same function 'export_archived_mock.assert_called_once_with'. This represents a synchronized parameter addition pattern where both test methods are being updated to expect the same new parameter in their assertions. The edits reference the same mock object and are part of the same type of syntactic construct (mock assertions), making this a bulk-edit pattern synchronization. Either edit could be made first, and after making one, the other becomes an immediate next step to maintain consistency across the test suite."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits are adding the exact same parameter 'needs_confirm=True' to mock assertion calls for the same function 'export_archived_mock.assert_called_once_with'. This represents a synchronized parameter addition pattern where both test methods are being updated to include the same new parameter in their assertions. The edits reference the same mock object and are part of a uniform substitution pattern - adding identical parameter-value pairs to multiple assertion calls of the same type. Either edit can be made first, and after making one, the other becomes an immediate next step to maintain consistency across the test suite."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits are adding the exact same parameter 'needs_confirm=True' to mock assertion calls for the same function 'export_archived_mock.assert_called_once_with'. This represents a synchronized parameter addition pattern where both test methods are being updated to include the same new parameter in their assertions. The edits reference the same mock object and are part of a uniform substitution pattern - adding identical parameter-value pairs to multiple assertion calls of the same type. Either edit can be made first, and after making one, the other becomes an immediate next step to maintain consistency across the test suite."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits are making identical structural changes to mock assertion calls for the same method (export_archived_mock.assert_called_once_with). They both: (1) reformat the function call from single-line to multi-line format, and (2) add the exact same new parameter 'needs_confirm=True'. This represents a bulk-edit pattern where the same before\u2192after transformation is being applied to the same type of syntactic construct (mock assertion calls). The edits are part of a single, contiguous refactor to update the API contract for the export_archived method across multiple test cases. Either edit could be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to maintain consistency in the test suite."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits are making identical structural changes to mock assertion calls for the same method (export_archived_mock.assert_called_once_with). They both: (1) reformat the function call from single-line to multi-line format, and (2) add the exact same new parameter 'needs_confirm=True'. This represents a bulk-edit pattern where the same before\u2192after transformation is being applied to the same type of syntactic construct (mock assertion calls). The edits are part of a single, contiguous refactor to update the API contract for the export_archived method across multiple test cases. Either edit could be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to maintain consistency in the test suite."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 adds a 'needs_confirm=not args.yes' parameter to the export_archived_records function call, but Edit 1 references a 'needs_confirm' variable that is not defined in the function signature shown. The function signature in Edit 1 shows 'def export_archived_records(export_format, output_path, table_names=None, drop_archives=False, session: Session = NEW_SESSION)' which does not include a 'needs_confirm' parameter. This means Edit 1 is referencing an undefined variable 'needs_confirm' that would only be available after Edit 0's corresponding function signature change (not shown but implied). Since Edit 1 cannot work without the function signature being updated to accept the needs_confirm parameter that Edit 0 is trying to pass, Edit 0 (and the implied signature change) must come before Edit 1."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}