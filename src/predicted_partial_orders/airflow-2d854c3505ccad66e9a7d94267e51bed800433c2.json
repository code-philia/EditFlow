{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 adds '_service_account' to a list of template fields, while Edit 1 adds code that uses 'self._service_account' in a conditional statement. The changed lines reference the exact same symbol '_service_account' - Edit 0 makes it available as a template field and Edit 1 uses that same attribute. This creates a direct code dependency where both edits reference the same symbol, making either edit prompt the other as the next logical step in implementing service account functionality."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 adds '_service_account' to a list of template fields, while Edit 1 adds code that uses 'self._service_account' in a conditional statement. The changed lines reference the exact same symbol '_service_account' - Edit 0 makes it available as a template field and Edit 1 uses that same attribute. This creates a direct code dependency where both edits reference the same symbol, making either edit prompt the other as the next logical step in implementing service account functionality."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol '_service_account'. Edit 0 adds '_service_account' to what appears to be a template_fields list, while Edit 1 assigns the service_account parameter to self._service_account. These edits are part of adding service_account functionality to the class - one edit handles the template field registration while the other handles the instance variable assignment. Both reference the same symbol and would naturally occur together when adding this parameter to the class, making either edit prompt the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol '_service_account'. Edit 0 adds '_service_account' to what appears to be a template_fields list, while Edit 1 assigns the service_account parameter to self._service_account. These edits are part of adding service_account functionality to the class - one edit handles the template field registration while the other handles the instance variable assignment. Both reference the same symbol and would naturally occur together when adding this parameter to the class, making either edit prompt the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "These edits are bi-directional neighbours because they both reference the exact same symbol `service_account` in the context of the MLEngineStartTrainingJobOperator class. Edit 0 adds documentation for the `service_account` parameter, while Edit 1 adds the implementation logic that uses `self._service_account` (which corresponds to the same parameter). The changed lines in both edits are directly related to the same feature - the service_account parameter - where one edit documents it and the other implements its usage. After making either edit, the other becomes a natural next step to complete the service_account functionality."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "These edits are bi-directional neighbours because they both reference the exact same symbol `service_account` in the context of the MLEngineStartTrainingJobOperator class. Edit 0 adds documentation for the `service_account` parameter, while Edit 1 adds the implementation logic that uses `self._service_account` (which corresponds to the same parameter). The changed lines in both edits are directly related to the same feature - the service_account parameter - where one edit documents it and the other implements its usage. After making either edit, the other becomes a natural next step to complete the service_account functionality."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits are adding documentation and parameter definition for the exact same symbol 'service_account' within the same class MLEngineStartTrainingJobOperator. Edit 0 adds the docstring documentation for the service_account parameter, while Edit 1 adds the actual parameter to the __init__ method signature. These edits reference the same symbol and are part of a single micro-task of adding a new parameter to the class. Either edit can be made first and both would naturally prompt the other as the next mechanical step - adding the parameter documentation naturally leads to adding the parameter itself, and vice versa."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits are adding documentation and parameter definition for the exact same symbol 'service_account' within the same class MLEngineStartTrainingJobOperator. Edit 0 adds the docstring documentation for the service_account parameter, while Edit 1 adds the actual parameter to the __init__ method signature. These edits reference the same symbol and are part of a single micro-task of adding a new parameter to the class. Either edit can be made first and both would naturally prompt the other as the next mechanical step - adding the parameter documentation naturally leads to adding the parameter itself, and vice versa."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'service_account' within the same function context. Edit 0 adds 'service_account' as a parameter to the __init__ method signature, and Edit 1 assigns that parameter to an instance variable 'self._service_account'. This creates a direct code dependency where the parameter added in Edit 0 is immediately referenced and used in Edit 1. This is a classic parameter definition \u2192 parameter usage pattern within the same function, making either edit naturally prompt the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'service_account' within the same function context. Edit 0 adds 'service_account' as a parameter to the __init__ method signature, and Edit 1 assigns that parameter to an instance variable 'self._service_account'. This creates a direct code dependency where the parameter added in Edit 0 is immediately referenced and used in Edit 1. This is a classic parameter definition \u2192 parameter usage pattern within the same function, making either edit naturally prompt the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol `self._service_account` within the same class `MLEngineStartTrainingJobOperator`. Edit 0 assigns a value to `self._service_account` in the constructor, while Edit 1 uses that same attribute in the `execute` method. After making either edit, the other becomes the immediate next step to complete the functionality - if you add the assignment without the usage, the attribute is unused; if you add the usage without the assignment, you're referencing an undefined attribute. This creates a direct code dependency between the changed lines referencing the exact same symbol."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol `self._service_account` within the same class `MLEngineStartTrainingJobOperator`. Edit 0 assigns a value to `self._service_account` in the constructor, while Edit 1 uses that same attribute in the `execute` method. After making either edit, the other becomes the immediate next step to complete the functionality - if you add the assignment without the usage, the attribute is unused; if you add the usage without the assignment, you're referencing an undefined attribute. This creates a direct code dependency between the changed lines referencing the exact same symbol."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits are adding the same service account parameter ('test@serviceaccount.com') within the same test method. Edit 0 adds it to the expected training_input dictionary that will be used for assertion, while Edit 1 adds it as a parameter to the MLEngineStartTrainingJobOperator constructor call. These are synchronized additions within the same test context where the operator parameter needs to match the expected training input for the test to pass. Both edits reference the same service account value and are part of the same test validation pattern - either edit can be made first and naturally prompts the other as the next step to maintain test consistency."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits are adding the same service account parameter ('test@serviceaccount.com') within the same test method. Edit 0 adds it to the expected training_input dictionary that will be used for assertion, while Edit 1 adds it as a parameter to the MLEngineStartTrainingJobOperator constructor call. These are synchronized additions within the same test context where the operator parameter needs to match the expected training input for the test to pass. Both edits reference the same service account value and are part of the same test validation pattern - either edit can be made first and naturally prompts the other as the next step to maintain test consistency."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits are adding the service_account parameter to the same class (MLEngineStartTrainingJobOperator). Edit 0 adds the parameter documentation in the docstring, while Edit 1 adds '_service_account' to what appears to be a template_fields list. These edits reference the exact same parameter concept and are part of the same micro-task of adding service_account functionality to the class. The changed lines in both edits are directly related to the same service_account parameter - one documents it and the other makes it templatable. Either edit could be made first, and after making either edit, the other would be the natural next step to complete the parameter addition."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits are adding the service_account parameter to the same class (MLEngineStartTrainingJobOperator). Edit 0 adds the parameter documentation in the docstring, while Edit 1 adds '_service_account' to what appears to be a template_fields list. These edits reference the exact same parameter concept and are part of the same micro-task of adding service_account functionality to the class. The changed lines in both edits are directly related to the same service_account parameter - one documents it and the other makes it templatable. Either edit could be made first, and after making either edit, the other would be the natural next step to complete the parameter addition."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 adds a 'service_account' parameter to the MLEngineStartTrainingJobOperator constructor signature, while Edit 1 adds the same 'service_account' parameter to a test instantiation of that exact same class. These edits reference the exact same symbol (the service_account parameter of MLEngineStartTrainingJobOperator) and represent a classic definition-usage pattern where adding a parameter to a constructor naturally prompts updating test code that instantiates that constructor. Both edits can be staged in either order without parse errors, making this a bi-directional relationship where either edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 adds a 'service_account' parameter to the MLEngineStartTrainingJobOperator constructor signature, while Edit 1 adds the same 'service_account' parameter to a test instantiation of that exact same class. These edits reference the exact same symbol (the service_account parameter of MLEngineStartTrainingJobOperator) and represent a classic definition-usage pattern where adding a parameter to a constructor naturally prompts updating test code that instantiates that constructor. Both edits can be staged in either order without parse errors, making this a bi-directional relationship where either edit creates an immediate, mechanically obvious prompt for the other."
        }
    ],
    "allowed_init_edits": [
        5
    ]
}