{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution (changing 'executable=executable_path' to 'executable_path=executable_path') on the same type of syntactic construct (super().__init__() parameter assignments). This is a bulk-edit pattern where the same before\u2192after pattern is being applied to multiple locations of the same construct type as part of a single, contiguous refactor. The edits are clearly part of the same systematic change to fix parameter naming across multiple service classes."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution (changing 'executable=executable_path' to 'executable_path=executable_path') on the same type of syntactic construct (super().__init__() parameter assignments). This is a bulk-edit pattern where the same before\u2192after pattern is being applied to multiple locations of the same construct type as part of a single, contiguous refactor. The edits are clearly part of the same systematic change to fix parameter naming across multiple service classes."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. Edit 0 changes 'executable=executable_path' to 'executable_path=executable_path' in a super().__init__() call, while Edit 1 changes 'executable_path' to 'executable_path=executable_path' in a super().__init__() call. This represents a uniform refactoring pattern where parameter passing is being standardized to use explicit keyword arguments. Both edits target the same construct type (super().__init__() parameter lists) and appear to be part of a single, contiguous refactor to ensure consistent parameter naming across similar service classes."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. Edit 0 changes 'executable=executable_path' to 'executable_path=executable_path' in a super().__init__() call, while Edit 1 changes 'executable_path' to 'executable_path=executable_path' in a super().__init__() call. This represents a uniform refactoring pattern where parameter passing is being standardized to use explicit keyword arguments. Both edits target the same construct type (super().__init__() parameter lists) and appear to be part of a single, contiguous refactor to ensure consistent parameter naming across similar service classes."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution (changing 'executable=executable_path' to 'executable_path=executable_path') on the same type of syntactic construct (super().__init__() parameter passing). This is a bulk uniform substitution pattern where the same before\u2192after change is applied to structurally identical code locations. Both edits are part of what appears to be a single refactoring operation to fix parameter naming consistency across multiple service classes. Either edit can be made first, and after making one, the other becomes an obvious next step to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution (changing 'executable=executable_path' to 'executable_path=executable_path') on the same type of syntactic construct (super().__init__() parameter passing). This is a bulk uniform substitution pattern where the same before\u2192after change is applied to structurally identical code locations. Both edits are part of what appears to be a single refactoring operation to fix parameter naming consistency across multiple service classes. Either edit can be made first, and after making one, the other becomes an obvious next step to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. Edit 0 changes 'executable_path,' to 'executable_path=executable_path,' in a super().__init__() call, while Edit 1 changes 'executable=executable_path,' to 'executable_path=executable_path,' in a super().__init__() call. This represents a uniform refactoring pattern where parameter passing is being standardized across multiple service classes. Both edits target the same construct type (super().__init__() parameter lists) and appear to be part of a single, contiguous refactor to ensure consistent parameter naming. The changes are mirrored structural modifications that would naturally occur together in one editing session."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. Edit 0 changes 'executable_path,' to 'executable_path=executable_path,' in a super().__init__() call, while Edit 1 changes 'executable=executable_path,' to 'executable_path=executable_path,' in a super().__init__() call. This represents a uniform refactoring pattern where parameter passing is being standardized across multiple service classes. Both edits target the same construct type (super().__init__() parameter lists) and appear to be part of a single, contiguous refactor to ensure consistent parameter naming. The changes are mirrored structural modifications that would naturally occur together in one editing session."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. Edit 0 changes 'executable_path,' to 'executable_path=executable_path,' in a super().__init__() call, and Edit 1 changes 'executable=executable_path,' to 'executable_path=executable_path,' in a super().__init__() call. This represents a uniform refactoring pattern where parameter passing is being standardized across multiple service classes. Both edits target the same construct type (super().__init__() parameter lists) and appear to be part of a single, contiguous refactor to ensure consistent parameter naming. The changes are mirrored structural modifications that would naturally occur together in one editing session."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. Edit 0 changes 'executable_path,' to 'executable_path=executable_path,' in a super().__init__() call, and Edit 1 changes 'executable=executable_path,' to 'executable_path=executable_path,' in a super().__init__() call. This represents a uniform refactoring pattern where parameter passing is being standardized across multiple service classes. Both edits target the same construct type (super().__init__() parameter lists) and appear to be part of a single, contiguous refactor to ensure consistent parameter naming. The changes are mirrored structural modifications that would naturally occur together in one editing session."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (changing 'executable=executable_path' to 'executable_path=executable_path') on the same type of syntactic construct (super().__init__() parameter assignments). This represents a bulk uniform substitution pattern where the same parameter name correction is being applied across multiple similar service classes. The edits are clearly part of a single, contiguous refactor to fix parameter naming consistency across the codebase."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution (changing 'executable=executable_path' to 'executable_path=executable_path') on the same type of syntactic construct (super().__init__() parameter assignments). This represents a bulk uniform substitution pattern where the same parameter name correction is being applied across multiple similar service classes. The edits are clearly part of a single, contiguous refactor to fix parameter naming consistency across the codebase."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. Edit 0 changes 'executable_path,' to 'executable_path=executable_path,' in a super().__init__() call, while Edit 1 changes 'executable=executable_path,' to 'executable_path=executable_path,' in a super().__init__() call. Both are making parameter passing explicit by adding the parameter name, and both target the same construct type (super().__init__() calls). This appears to be part of a single, contiguous refactor to standardize parameter passing across similar service classes. The edits reference different symbols (different Service classes in different files), but they follow the bulk-edit pattern of identical structural substitution on the same construct type."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. Edit 0 changes 'executable_path,' to 'executable_path=executable_path,' in a super().__init__() call, while Edit 1 changes 'executable=executable_path,' to 'executable_path=executable_path,' in a super().__init__() call. Both are making parameter passing explicit by adding the parameter name, and both target the same construct type (super().__init__() calls). This appears to be part of a single, contiguous refactor to standardize parameter passing across similar service classes. The edits reference different symbols (different Service classes in different files), but they follow the bulk-edit pattern of identical structural substitution on the same construct type."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'executable=executable_path' to 'executable_path=executable_path' in super().__init__() calls. This is a uniform parameter name correction across multiple Service class implementations, targeting the same type of syntactic construct (super() call parameter). Both edits are part of a single, contiguous refactor to fix parameter naming consistency across the codebase."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'executable=executable_path' to 'executable_path=executable_path' in super().__init__() calls. This is a uniform parameter name correction across multiple Service class implementations, targeting the same type of syntactic construct (super() call parameter). Both edits are part of a single, contiguous refactor to fix parameter naming consistency across the codebase."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution (changing 'executable=executable_path' to 'executable_path=executable_path') on the same type of syntactic construct (super().__init__() parameter passing). This is a bulk uniform substitution pattern where both edits apply the exact same before\u2192after transformation to structurally identical code locations. The edits appear to be part of a single, contiguous refactor to fix parameter naming consistency across multiple service classes. Either edit can be made first, and after making either, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution (changing 'executable=executable_path' to 'executable_path=executable_path') on the same type of syntactic construct (super().__init__() parameter passing). This is a bulk uniform substitution pattern where both edits apply the exact same before\u2192after transformation to structurally identical code locations. The edits appear to be part of a single, contiguous refactor to fix parameter naming consistency across multiple service classes. Either edit can be made first, and after making either, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution (changing 'executable=executable_path' to 'executable_path=executable_path') on the same type of syntactic construct (parameter assignment in super().__init__ calls). This is a clear case of bulk-edit pattern synchronization where both edits are part of a single, contiguous refactor to fix parameter naming across multiple similar service classes. The changes are mechanically identical and would naturally occur together in one uninterrupted micro-task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (changing 'executable=executable_path' to 'executable_path=executable_path') on the same type of syntactic construct (parameter assignment in super().__init__ calls). This is a clear case of bulk-edit pattern synchronization where both edits are part of a single, contiguous refactor to fix parameter naming across multiple similar service classes. The changes are mechanically identical and would naturally occur together in one uninterrupted micro-task."
        }
    ],
    "allowed_init_edits": [
        2,
        6
    ]
}