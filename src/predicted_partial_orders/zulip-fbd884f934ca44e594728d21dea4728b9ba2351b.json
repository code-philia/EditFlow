{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX' in test assertion lines. This is a bulk uniform substitution pattern where both edits target the same type of syntactic construct (assertEqual statements) with the exact same before\u2192after pattern. The edits appear to be part of a single, contiguous refactor to rename a constant across the codebase. Either edit can be made first, and after making either one, the other becomes an immediate next step to maintain consistency."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX' in test assertion lines. This is a bulk uniform substitution pattern where both edits target the same type of syntactic construct (assertEqual statements) with the exact same before\u2192after pattern. The edits appear to be part of a single, contiguous refactor to rename a constant across the codebase. Either edit can be made first, and after making either one, the other becomes an immediate next step to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol - a class constant in the Realm class. Edit 1 renames the constant from MAX_INVITES_PREMIUM to INVITES_PREMIUM_REALM_DAILY_MAX in the definition, while Edit 0 updates the usage of that same constant in the do_change_plan_type function. This is a classic definition-usage relationship where both edits reference the same fully qualified symbol (Realm.MAX_INVITES_PREMIUM \u2192 Realm.INVITES_PREMIUM_REALM_DAILY_MAX). After making either edit, the other becomes the immediate next step to maintain code consistency. Since Python allows referencing undefined attributes at parse time (only failing at runtime), both edits can be staged in either order, making this bi-directional."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol - a class constant in the Realm class. Edit 1 renames the constant from MAX_INVITES_PREMIUM to INVITES_PREMIUM_REALM_DAILY_MAX in the definition, while Edit 0 updates the usage of that same constant in the do_change_plan_type function. This is a classic definition-usage relationship where both edits reference the same fully qualified symbol (Realm.MAX_INVITES_PREMIUM \u2192 Realm.INVITES_PREMIUM_REALM_DAILY_MAX). After making either edit, the other becomes the immediate next step to maintain code consistency. Since Python allows referencing undefined attributes at parse time (only failing at runtime), both edits can be staged in either order, making this bi-directional."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX'. This is a bulk uniform substitution pattern where the same symbol (Realm.MAX_INVITES_PREMIUM) is being replaced with the same new symbol (Realm.INVITES_PREMIUM_REALM_DAILY_MAX) across different files. Both changed lines reference the exact same symbols and represent a synchronized refactoring operation that would naturally occur as part of a single, contiguous micro-task. Either edit can be made first, and after making either one, the other becomes an immediate next step to maintain consistency."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX'. This is a bulk uniform substitution pattern where the same symbol (Realm.MAX_INVITES_PREMIUM) is being replaced with the same new symbol (Realm.INVITES_PREMIUM_REALM_DAILY_MAX) across different files. Both changed lines reference the exact same symbols and represent a synchronized refactoring operation that would naturally occur as part of a single, contiguous micro-task. Either edit can be made first, and after making either one, the other becomes an immediate next step to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution (Realm.MAX_INVITES_PREMIUM \u2192 Realm.INVITES_PREMIUM_REALM_DAILY_MAX) on the same type of syntactic construct (attribute assignment to realm.max_invites) within the same function. This is a clear bulk-edit pattern where both changes are part of a single, contiguous refactor operation. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution (Realm.MAX_INVITES_PREMIUM \u2192 Realm.INVITES_PREMIUM_REALM_DAILY_MAX) on the same type of syntactic construct (attribute assignment to realm.max_invites) within the same function. This is a clear bulk-edit pattern where both changes are part of a single, contiguous refactor operation. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol - a class constant in the Realm class. Edit 1 renames the constant from MAX_INVITES_PREMIUM to INVITES_PREMIUM_REALM_DAILY_MAX in the definition, while Edit 0 updates the usage of that same constant in a test assertion. This creates a direct code dependency where both edits reference the identical symbol, and making either edit creates an immediate prompt for the other to maintain code consistency. The relationship is bi-directional because either edit can be made first - both the old and new names can be parsed and staged in either order, with only a runtime NameError occurring if they become mismatched."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol - a class constant in the Realm class. Edit 1 renames the constant from MAX_INVITES_PREMIUM to INVITES_PREMIUM_REALM_DAILY_MAX in the definition, while Edit 0 updates the usage of that same constant in a test assertion. This creates a direct code dependency where both edits reference the identical symbol, and making either edit creates an immediate prompt for the other to maintain code consistency. The relationship is bi-directional because either edit can be made first - both the old and new names can be parsed and staged in either order, with only a runtime NameError occurring if they become mismatched."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX'. Edit 0 changes the assignment in the production code, while Edit 1 updates the corresponding test assertion that verifies this exact same assignment. The changed lines reference the exact same symbol (the Realm constant) and this appears to be a synchronized refactoring where renaming the constant requires updating both its usage in production code and the test that validates that usage. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain consistency between the implementation and its test."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX'. Edit 0 changes the assignment in the production code, while Edit 1 updates the corresponding test assertion that verifies this exact same assignment. The changed lines reference the exact same symbol (the Realm constant) and this appears to be a synchronized refactoring where renaming the constant requires updating both its usage in production code and the test that validates that usage. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain consistency between the implementation and its test."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitution of the same constant name: changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX'. Edit 0 changes the assignment in the implementation code, while Edit 1 updates the corresponding test assertion that verifies this exact behavior. This is a bulk uniform substitution pattern where both changed lines reference the exact same symbol (the Realm constant), and the test directly asserts on the behavior being modified in the production code. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain consistency between implementation and test."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitution of the same constant name: changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX'. Edit 0 changes the assignment in the implementation code, while Edit 1 updates the corresponding test assertion that verifies this exact behavior. This is a bulk uniform substitution pattern where both changed lines reference the exact same symbol (the Realm constant), and the test directly asserts on the behavior being modified in the production code. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain consistency between implementation and test."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits change references to the exact same symbol from `Realm.MAX_INVITES_PREMIUM` to `Realm.INVITES_PREMIUM_REALM_DAILY_MAX`. Edit 0 changes the assignment in the production code, while Edit 1 updates the corresponding test assertion that verifies this exact behavior. This is a bi-directional relationship because: (1) both changed lines reference the exact same symbol, (2) the test directly asserts on the behavior being modified in production code, and (3) either edit can be made first since both are valid syntactically, but making either edit creates an immediate prompt for the other to maintain test-production synchronization."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits change references to the exact same symbol from `Realm.MAX_INVITES_PREMIUM` to `Realm.INVITES_PREMIUM_REALM_DAILY_MAX`. Edit 0 changes the assignment in the production code, while Edit 1 updates the corresponding test assertion that verifies this exact behavior. This is a bi-directional relationship because: (1) both changed lines reference the exact same symbol, (2) the test directly asserts on the behavior being modified in production code, and (3) either edit can be made first since both are valid syntactically, but making either edit creates an immediate prompt for the other to maintain test-production synchronization."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits involve renaming the exact same class attribute symbol from 'MAX_INVITES_PREMIUM' to 'INVITES_PREMIUM_REALM_DAILY_MAX'. Edit 1 changes the definition of this class attribute in the Realm model, while Edit 0 changes the usage of this same attribute in a function. This is a classic definition-usage relationship where both edits reference the exact same symbol (Realm.MAX_INVITES_PREMIUM / Realm.INVITES_PREMIUM_REALM_DAILY_MAX). In Python, both edits can be staged in either order since the usage would only fail at runtime, not at parse time. After making either edit, the other becomes the immediate next step to maintain code consistency."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits involve renaming the exact same class attribute symbol from 'MAX_INVITES_PREMIUM' to 'INVITES_PREMIUM_REALM_DAILY_MAX'. Edit 1 changes the definition of this class attribute in the Realm model, while Edit 0 changes the usage of this same attribute in a function. This is a classic definition-usage relationship where both edits reference the exact same symbol (Realm.MAX_INVITES_PREMIUM / Realm.INVITES_PREMIUM_REALM_DAILY_MAX). In Python, both edits can be staged in either order since the usage would only fail at runtime, not at parse time. After making either edit, the other becomes the immediate next step to maintain code consistency."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX' in test assertion lines. This is a bulk uniform substitution pattern where both edits target the same type of syntactic construct (assertEqual test assertions) with the exact same before\u2192after pattern. The edits reference the exact same symbol (the Realm class constant) and appear to be part of a single, contiguous refactor to rename this constant across the codebase. Either edit can be staged first, and after making either, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX' in test assertion lines. This is a bulk uniform substitution pattern where both edits target the same type of syntactic construct (assertEqual test assertions) with the exact same before\u2192after pattern. The edits reference the exact same symbol (the Realm class constant) and appear to be part of a single, contiguous refactor to rename this constant across the codebase. Either edit can be staged first, and after making either, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX' in assignment contexts. This is a bulk refactoring operation where the same constant name is being updated across multiple files. The edits reference the exact same symbol (the Realm constant) and represent a synchronized pattern substitution that would naturally occur as part of a single, contiguous refactor. Either edit can be made first, and after making either one, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX' in assignment contexts. This is a bulk refactoring operation where the same constant name is being updated across multiple files. The edits reference the exact same symbol (the Realm constant) and represent a synchronized pattern substitution that would naturally occur as part of a single, contiguous refactor. Either edit can be made first, and after making either one, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX'. Edit 0 changes the assignment in the production code, while Edit 1 updates the corresponding test assertion that verifies this exact same assignment. The changed lines reference the exact same symbol (the realm constant) and both edits are part of a single refactoring operation to rename this constant. After making either edit, the other becomes the immediate next step to maintain consistency between production code and its test."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution, changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX'. Edit 0 changes the assignment in the production code, while Edit 1 updates the corresponding test assertion that verifies this exact same assignment. The changed lines reference the exact same symbol (the realm constant) and both edits are part of a single refactoring operation to rename this constant. After making either edit, the other becomes the immediate next step to maintain consistency between production code and its test."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol - a class attribute of the Realm class. Edit 0 renames the attribute from MAX_INVITES_PREMIUM to INVITES_PREMIUM_REALM_DAILY_MAX in the class definition, and Edit 1 updates the reference to use the new name in a test assertion. This is a classic definition-usage relationship where both changed lines reference the same symbol. After making either edit, the other becomes the immediate next step to maintain code consistency - if you rename the attribute definition, you must update all references, and vice versa. Both edits can be staged in either order without causing parse errors (the test would just fail at runtime if staged before the definition change), making this bi-directional."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol - a class attribute of the Realm class. Edit 0 renames the attribute from MAX_INVITES_PREMIUM to INVITES_PREMIUM_REALM_DAILY_MAX in the class definition, and Edit 1 updates the reference to use the new name in a test assertion. This is a classic definition-usage relationship where both changed lines reference the same symbol. After making either edit, the other becomes the immediate next step to maintain code consistency - if you rename the attribute definition, you must update all references, and vice versa. Both edits can be staged in either order without causing parse errors (the test would just fail at runtime if staged before the definition change), making this bi-directional."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution (changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX') on the same type of syntactic construct (test assertion lines) within the same test method. This is a clear case of bulk-edit pattern synchronization where both edits are part of a single, contiguous refactor to update the constant name across multiple test assertions. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to maintain consistency in the same test method."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (changing 'Realm.MAX_INVITES_PREMIUM' to 'Realm.INVITES_PREMIUM_REALM_DAILY_MAX') on the same type of syntactic construct (test assertion lines) within the same test method. This is a clear case of bulk-edit pattern synchronization where both edits are part of a single, contiguous refactor to update the constant name across multiple test assertions. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to maintain consistency in the same test method."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol: a class attribute of the Realm class. Edit 0 renames the attribute from MAX_INVITES_PREMIUM to INVITES_PREMIUM_REALM_DAILY_MAX in the class definition, while edit 1 updates the reference to use the new name in a test assertion. This is a classic definition-usage relationship where both changed lines reference the same symbol (Realm.MAX_INVITES_PREMIUM \u2192 Realm.INVITES_PREMIUM_REALM_DAILY_MAX). After making either edit, the other becomes the immediate next step to maintain code consistency - if you rename the attribute definition, you must update all references, and vice versa. Since Python allows referencing undefined attributes at parse time (only failing at runtime), either edit can be staged first."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol: a class attribute of the Realm class. Edit 0 renames the attribute from MAX_INVITES_PREMIUM to INVITES_PREMIUM_REALM_DAILY_MAX in the class definition, while edit 1 updates the reference to use the new name in a test assertion. This is a classic definition-usage relationship where both changed lines reference the same symbol (Realm.MAX_INVITES_PREMIUM \u2192 Realm.INVITES_PREMIUM_REALM_DAILY_MAX). After making either edit, the other becomes the immediate next step to maintain code consistency - if you rename the attribute definition, you must update all references, and vice versa. Since Python allows referencing undefined attributes at parse time (only failing at runtime), either edit can be staged first."
        }
    ],
    "allowed_init_edits": [
        0,
        5,
        1,
        3,
        2,
        4
    ]
}