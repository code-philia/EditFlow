{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits add the exact same line 'start_time': time.time()' to dictionary structures in similar wrapper functions within different client classes. This represents an identical textual substitution (adding the same key-value pair) applied to the same type of syntactic construct (dictionary literals in wrapper methods). Both edits appear to be part of a single, contiguous refactor to add timing functionality across multiple client implementations. The changes follow the bulk-edit pattern where the same before\u2192after pattern is applied to the same construct type."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits add the exact same line 'start_time': time.time()' to dictionary structures in similar wrapper functions within different client classes. This represents an identical textual substitution (adding the same key-value pair) applied to the same type of syntactic construct (dictionary literals in wrapper methods). Both edits appear to be part of a single, contiguous refactor to add timing functionality across multiple client implementations. The changes follow the bulk-edit pattern where the same before\u2192after pattern is applied to the same construct type."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 removes the definition of 'start_time' variable (line 21), while Edit 1 changes the usage of 'start_time' to 'start_perf_counter' (line 34). These edits reference the exact same symbol 'start_time' - one removes its definition and the other changes its usage. However, since Edit 1 changes the reference to a different variable name ('start_perf_counter'), this suggests the variable was renamed. For the code to remain functional, the definition must be removed before the usage is changed to the new variable name, otherwise there would be an undefined 'start_perf_counter' reference. This creates an ordered dependency where the removal of the old definition should happen before the usage is updated to reference the new variable."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits add the exact same line 'start_perf_counter = time.perf_counter()' at the same structural position within similar wrapper functions in different files. This represents a bulk-edit pattern where identical code is being added to multiple locations as part of a single refactoring operation. The edits perform an identical textual addition (same before\u2192after pattern) and target the same type of syntactic construct (variable assignment within wrapper functions). This is clearly part of a contiguous refactor to add performance timing to multiple client implementations."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits add the exact same line 'start_perf_counter = time.perf_counter()' at the same structural position within similar wrapper functions in different files. This represents a bulk-edit pattern where identical code is being added to multiple locations as part of a single refactoring operation. The edits perform an identical textual addition (same before\u2192after pattern) and target the same type of syntactic construct (variable assignment within wrapper functions). This is clearly part of a contiguous refactor to add performance timing to multiple client implementations."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 introduces a new variable 'start_perf_counter' and edit 1 uses that exact same variable in a calculation. The changed lines reference the exact same symbol - 'start_perf_counter'. Edit 0 defines/assigns the variable, and edit 1 references it in an expression. This creates an immediate code dependency where after making edit 0 (introducing the variable), edit 1 becomes the natural next step to use that variable. Both edits are part of the same micro-task of refactoring the timing measurement code. Since this is Python, both edits can be parsed in either order (referencing an undefined variable only causes a runtime NameError, not a parse error), making this bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 introduces a new variable 'start_perf_counter' and edit 1 uses that exact same variable in a calculation. The changed lines reference the exact same symbol - 'start_perf_counter'. Edit 0 defines/assigns the variable, and edit 1 references it in an expression. This creates an immediate code dependency where after making edit 0 (introducing the variable), edit 1 becomes the natural next step to use that variable. Both edits are part of the same micro-task of refactoring the timing measurement code. Since this is Python, both edits can be parsed in either order (referencing an undefined variable only causes a runtime NameError, not a parse error), making this bi-directional rather than ordered."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Edit 0 removes the definition of 'start_time' variable, while Edit 1 changes the usage of 'start_time' to 'start_perf_counter'. These edits reference the exact same symbol ('start_time') - one removes its definition and the other changes its usage to a different variable name. However, Edit 1 can be made independently since it's changing the reference to a different variable name, and Edit 0 can also be made independently since it's just removing a line. The relationship is bi-directional because either edit can be made first, and after making either edit, the other becomes a natural next step to complete the variable rename refactoring."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Edit 0 removes the definition of 'start_time' variable, while Edit 1 changes the usage of 'start_time' to 'start_perf_counter'. These edits reference the exact same symbol ('start_time') - one removes its definition and the other changes its usage to a different variable name. However, Edit 1 can be made independently since it's changing the reference to a different variable name, and Edit 0 can also be made independently since it's just removing a line. The relationship is bi-directional because either edit can be made first, and after making either edit, the other becomes a natural next step to complete the variable rename refactoring."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution, changing 'start_time' to 'start_perf_counter' in the exact same line of code structure (calculating response_time using time.perf_counter()). This appears to be part of a bulk refactoring operation where the same variable name is being updated across multiple files for consistency. Both edits target the same type of syntactic construct (variable reference in a calculation) and apply the identical before\u2192after pattern. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution, changing 'start_time' to 'start_perf_counter' in the exact same line of code structure (calculating response_time using time.perf_counter()). This appears to be part of a bulk refactoring operation where the same variable name is being updated across multiple files for consistency. Both edits target the same type of syntactic construct (variable reference in a calculation) and apply the identical before\u2192after pattern. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 introduces a new variable 'start_perf_counter' by assigning time.perf_counter() to it. Edit 1 uses this exact same variable 'start_perf_counter' in a calculation to compute response_time. The changed lines reference the exact same symbol - the variable 'start_perf_counter' that is defined in edit 0 and used in edit 1. This creates an immediate code dependency where defining the variable naturally prompts its usage in the calculation, and both edits are part of the same micro-task of measuring elapsed time. Since Python allows referencing undefined variables at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 introduces a new variable 'start_perf_counter' by assigning time.perf_counter() to it. Edit 1 uses this exact same variable 'start_perf_counter' in a calculation to compute response_time. The changed lines reference the exact same symbol - the variable 'start_perf_counter' that is defined in edit 0 and used in edit 1. This creates an immediate code dependency where defining the variable naturally prompts its usage in the calculation, and both edits are part of the same micro-task of measuring elapsed time. Since Python allows referencing undefined variables at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}