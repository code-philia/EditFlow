{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitution (removing 'scipy_base.' prefix from 'fastumath' references) on the same type of syntactic construct (module attribute access). This is a uniform refactoring pattern where both changed lines reference the same module 'fastumath' and apply the same before\u2192after transformation. Either edit can be made first, and both are part of the same contiguous refactoring task to simplify module references."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform identical textual substitution (removing 'scipy_base.' prefix from 'fastumath' references) on the same type of syntactic construct (module attribute access). This is a uniform refactoring pattern where both changed lines reference the same module 'fastumath' and apply the same before\u2192after transformation. Either edit can be made first, and both are part of the same contiguous refactoring task to simplify module references."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitutions within the same file and context - changing 'scipy_base.fastumath' to 'fastumath' in consecutive lines of the same try-except block. This is a uniform pattern substitution where both edits are part of the same refactoring operation to remove the 'scipy_base.' prefix. The edits reference the same module (fastumath) and apply the identical before\u2192after pattern to the same type of syntactic construct (module attribute access). Either edit can be made first, and both are part of a single, contiguous refactor."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitutions within the same file and context - changing 'scipy_base.fastumath' to 'fastumath' in consecutive lines of the same try-except block. This is a uniform pattern substitution where both edits are part of the same refactoring operation to remove the 'scipy_base.' prefix. The edits reference the same module (fastumath) and apply the identical before\u2192after pattern to the same type of syntactic construct (module attribute access). Either edit can be made first, and both are part of a single, contiguous refactor."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitution (removing 'scipy_base.' prefix from module references) on the same type of syntactic construct (module attribute access). Edit 0 changes 'scipy_base.fastumath.PINF' to 'fastumath.PINF' and Edit 1 changes 'scipy_base.fastumath.NAN' to 'fastumath.NAN'. This is a clear bulk-edit pattern where both edits apply the same before\u2192after transformation ('scipy_base.fastumath' \u2192 'fastumath') to similar constructs within the same file. Both edits are part of a single, contiguous refactor to simplify module references, and either edit can be made first as they are independent transformations of the same pattern."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform identical textual substitution (removing 'scipy_base.' prefix from module references) on the same type of syntactic construct (module attribute access). Edit 0 changes 'scipy_base.fastumath.PINF' to 'fastumath.PINF' and Edit 1 changes 'scipy_base.fastumath.NAN' to 'fastumath.NAN'. This is a clear bulk-edit pattern where both edits apply the same before\u2192after transformation ('scipy_base.fastumath' \u2192 'fastumath') to similar constructs within the same file. Both edits are part of a single, contiguous refactor to simplify module references, and either edit can be made first as they are independent transformations of the same pattern."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'scipy_base.fastumath' to 'fastumath'. Edit 0 changes the import statement from 'import scipy_base.fastumath' to 'import fastumath', and Edit 1 changes the usage from 'scipy_base.fastumath.PINF' to 'fastumath.PINF'. This is a synchronized refactoring where the import change and the corresponding usage update reference the exact same module symbol and follow the same before\u2192after pattern. Both edits are part of a single contiguous refactor to simplify the module reference, and either edit naturally prompts the other as the next mechanical step to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'scipy_base.fastumath' to 'fastumath'. Edit 0 changes the import statement from 'import scipy_base.fastumath' to 'import fastumath', and Edit 1 changes the usage from 'scipy_base.fastumath.PINF' to 'fastumath.PINF'. This is a synchronized refactoring where the import change and the corresponding usage update reference the exact same module symbol and follow the same before\u2192after pattern. Both edits are part of a single contiguous refactor to simplify the module reference, and either edit naturally prompts the other as the next mechanical step to maintain consistency."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'scipy_base.fastumath' to 'fastumath'. Edit 0 changes the import statement from 'import scipy_base.fastumath' to 'import fastumath', and Edit 1 changes the usage from 'scipy_base.fastumath.PINF' to 'fastumath.PINF'. This is a uniform refactoring where the import change in Edit 0 makes the usage change in Edit 1 necessary (and vice versa - if you change the usage, you need to change the import). Both edits reference the exact same module symbol 'fastumath' and are part of a single, contiguous refactor to simplify the module reference. Either edit can be made first, and after making either one, the other becomes the immediate next step to maintain code consistency."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'scipy_base.fastumath' to 'fastumath'. Edit 0 changes the import statement from 'import scipy_base.fastumath' to 'import fastumath', and Edit 1 changes the usage from 'scipy_base.fastumath.PINF' to 'fastumath.PINF'. This is a uniform refactoring where the import change in Edit 0 makes the usage change in Edit 1 necessary (and vice versa - if you change the usage, you need to change the import). Both edits reference the exact same module symbol 'fastumath' and are part of a single, contiguous refactor to simplify the module reference. Either edit can be made first, and after making either one, the other becomes the immediate next step to maintain code consistency."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 changes the import statement from 'import scipy_base.fastumath' to 'import fastumath', which changes how the fastumath module is referenced. Edit 1 updates the usage of this module from 'scipy_base.fastumath.NAN' to 'fastumath.NAN'. Both edits reference the exact same symbol (the fastumath module) - edit 0 changes how it's imported and edit 1 updates the reference to match the new import style. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain code consistency. The changed lines in both edits explicitly reference the same fastumath module symbol."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 changes the import statement from 'import scipy_base.fastumath' to 'import fastumath', which changes how the fastumath module is referenced. Edit 1 updates the usage of this module from 'scipy_base.fastumath.NAN' to 'fastumath.NAN'. Both edits reference the exact same symbol (the fastumath module) - edit 0 changes how it's imported and edit 1 updates the reference to match the new import style. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain code consistency. The changed lines in both edits explicitly reference the same fastumath module symbol."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 adds 'disp' to the __all__ list, while Edit 1 defines the disp function. Both edits reference the exact same symbol 'disp'. Adding a symbol to __all__ and defining that symbol are bi-directional because __all__ is processed during import resolution (not execution), so either edit can be staged first without causing a parser error. After making either edit, the other becomes the immediate next step to complete the symbol's introduction to the module."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 adds 'disp' to the __all__ list, while Edit 1 defines the disp function. Both edits reference the exact same symbol 'disp'. Adding a symbol to __all__ and defining that symbol are bi-directional because __all__ is processed during import resolution (not execution), so either edit can be staged first without causing a parser error. After making either edit, the other becomes the immediate next step to complete the symbol's introduction to the module."
        }
    ],
    "allowed_init_edits": [
        4,
        5
    ]
}