{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'InvalidModeException' - edit 0 imports it and edit 1 uses it in an exception handler. After importing InvalidModeException in edit 0, it becomes immediately available for use in edit 1's exception handling. This creates a direct import-usage relationship where both changed lines reference the same symbol, making either edit naturally prompt the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'InvalidModeException' - edit 0 imports it and edit 1 uses it in an exception handler. After importing InvalidModeException in edit 0, it becomes immediately available for use in edit 1's exception handling. This creates a direct import-usage relationship where both changed lines reference the same symbol, making either edit naturally prompt the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 1 defines a new exception class 'InvalidModeException' in cookiecutter/exceptions.py, and Edit 0 imports that exact same exception class in cookiecutter/cli.py. The changed lines reference the exact same symbol - InvalidModeException. After defining the exception class, importing it becomes the immediate next step to make it available for use. Both edits can be staged in either order since Python allows importing undefined symbols (they only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 1 defines a new exception class 'InvalidModeException' in cookiecutter/exceptions.py, and Edit 0 imports that exact same exception class in cookiecutter/cli.py. The changed lines reference the exact same symbol - InvalidModeException. After defining the exception class, importing it becomes the immediate next step to make it available for use. Both edits can be staged in either order since Python allows importing undefined symbols (they only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Edit 0 imports InvalidModeException from cookiecutter.exceptions, and Edit 1 uses InvalidModeException by raising it in the cookiecutter function. The changed lines reference the exact same symbol - InvalidModeException. After importing the exception in Edit 0, Edit 1 becomes the natural next step to use that imported exception. However, both edits can be staged in either order since Python allows referencing undefined symbols at parse time (they only fail at runtime/import time), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Edit 0 imports InvalidModeException from cookiecutter.exceptions, and Edit 1 uses InvalidModeException by raising it in the cookiecutter function. The changed lines reference the exact same symbol - InvalidModeException. After importing the exception in Edit 0, Edit 1 becomes the natural next step to use that imported exception. However, both edits can be staged in either order since Python allows referencing undefined symbols at parse time (they only fail at runtime/import time), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 adds a 'replay' parameter to the main function signature, and Edit 1 uses that exact same 'replay' parameter in the cookiecutter function call within the same function body. The changed lines reference the exact same symbol - the 'replay' parameter. After adding the parameter to the function signature (Edit 0), the next immediate, mechanically obvious step is to use that parameter in the function body (Edit 1). This creates a direct code dependency where both edits reference the same symbol and either edit naturally prompts the other as the next contiguous action within the same micro-task."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 adds a 'replay' parameter to the main function signature, and Edit 1 uses that exact same 'replay' parameter in the cookiecutter function call within the same function body. The changed lines reference the exact same symbol - the 'replay' parameter. After adding the parameter to the function signature (Edit 0), the next immediate, mechanically obvious step is to use that parameter in the function body (Edit 1). This creates a direct code dependency where both edits reference the same symbol and either edit naturally prompts the other as the next contiguous action within the same micro-task."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits import the exact same symbol 'InvalidModeException' from the same module 'cookiecutter.exceptions'. Edit 0 adds InvalidModeException to an existing import statement in cli.py, while Edit 1 adds a new import statement for InvalidModeException in main.py. These are independent import operations that can be performed in either order - both files can successfully import the same exception class regardless of which import is added first. This represents a bulk/pattern synchronization where the same symbol is being imported across multiple files as part of what appears to be the same development task."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits import the exact same symbol 'InvalidModeException' from the same module 'cookiecutter.exceptions'. Edit 0 adds InvalidModeException to an existing import statement in cli.py, while Edit 1 adds a new import statement for InvalidModeException in main.py. These are independent import operations that can be performed in either order - both files can successfully import the same exception class regardless of which import is added first. This represents a bulk/pattern synchronization where the same symbol is being imported across multiple files as part of what appears to be the same development task."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 1 defines a new exception class 'InvalidModeException' and edit 0 imports/uses that exact same exception class in a try-except block. The changed lines reference the exact same symbol - 'InvalidModeException'. After defining the exception in edit 1, edit 0 becomes the immediate next step to use it. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime), both edits can be staged in either order without causing parser errors. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 1 defines a new exception class 'InvalidModeException' and edit 0 imports/uses that exact same exception class in a try-except block. The changed lines reference the exact same symbol - 'InvalidModeException'. After defining the exception in edit 1, edit 0 becomes the immediate next step to use it. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime), both edits can be staged in either order without causing parser errors. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 adds a 'replay' parameter to the cookiecutter() function call, while Edit 1 adds validation logic that uses this same 'replay' parameter within the cookiecutter() function. The changed lines reference the exact same symbol 'replay' - Edit 0 passes it as an argument and Edit 1 uses it in validation logic. This creates a direct code dependency where adding the parameter in the call site (Edit 0) mechanically prompts the need to handle that parameter in the function body (Edit 1), or vice versa. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 adds a 'replay' parameter to the cookiecutter() function call, while Edit 1 adds validation logic that uses this same 'replay' parameter within the cookiecutter() function. The changed lines reference the exact same symbol 'replay' - Edit 0 passes it as an argument and Edit 1 uses it in validation logic. This creates a direct code dependency where adding the parameter in the call site (Edit 0) mechanically prompts the need to handle that parameter in the function body (Edit 1), or vice versa. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol - the 'cookiecutter' function. Edit 0 adds a 'replay' parameter to the function call, while Edit 1 adds the 'replay' parameter to the function signature. This is a classic function signature change paired with call-site update pattern. After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the parameter to the signature, you need to update the call site, and vice versa. Both edits can be staged in either order without causing parse errors (Python allows mismatched parameters at parse time, only failing at runtime), making this bi-directional."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol - the 'cookiecutter' function. Edit 0 adds a 'replay' parameter to the function call, while Edit 1 adds the 'replay' parameter to the function signature. This is a classic function signature change paired with call-site update pattern. After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the parameter to the signature, you need to update the call site, and vice versa. Both edits can be staged in either order without causing parse errors (Python allows mismatched parameters at parse time, only failing at runtime), making this bi-directional."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Edit 0 defines a new exception class 'InvalidModeException' in the exceptions module, while Edit 1 raises that exact same exception class in the main module. The changed lines reference the exact same symbol - 'InvalidModeException'. After defining the exception in Edit 0, Edit 1 becomes the immediate next step to use it. After adding the raise statement in Edit 1, Edit 0 becomes necessary to provide the exception definition. This is a classic definition-usage relationship where both edits reference the same symbol and either can prompt the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 0 defines a new exception class 'InvalidModeException' in the exceptions module, while Edit 1 raises that exact same exception class in the main module. The changed lines reference the exact same symbol - 'InvalidModeException'. After defining the exception in Edit 0, Edit 1 becomes the immediate next step to use it. After adding the raise statement in Edit 1, Edit 0 becomes necessary to provide the exception definition. This is a classic definition-usage relationship where both edits reference the same symbol and either can prompt the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 imports InvalidModeException and Edit 1 raises InvalidModeException. The changed lines reference the exact same symbol - InvalidModeException. After importing the exception in Edit 0, Edit 1 becomes the natural next step to use it. Conversely, if Edit 1 is written first, Edit 0 becomes necessary to resolve the undefined symbol. Both edits can be parsed and staged in either order (the usage would just cause a runtime NameError if imported first), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 imports InvalidModeException and Edit 1 raises InvalidModeException. The changed lines reference the exact same symbol - InvalidModeException. After importing the exception in Edit 0, Edit 1 becomes the natural next step to use it. Conversely, if Edit 1 is written first, Edit 0 becomes necessary to resolve the undefined symbol. Both edits can be parsed and staged in either order (the usage would just cause a runtime NameError if imported first), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 defines a new exception class 'InvalidModeException' in the exceptions.py file, while Edit 1 imports that exact same 'InvalidModeException' class in main.py. The changed lines reference the exact same symbol - the InvalidModeException class. This creates a definition-usage relationship where defining the exception class creates an immediate prompt to import it where it will be used. Since this is Python, the import can be written before the class definition exists (it would only fail at runtime/import time, not at parse time), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 defines a new exception class 'InvalidModeException' in the exceptions.py file, while Edit 1 imports that exact same 'InvalidModeException' class in main.py. The changed lines reference the exact same symbol - the InvalidModeException class. This creates a definition-usage relationship where defining the exception class creates an immediate prompt to import it where it will be used. Since this is Python, the import can be written before the class definition exists (it would only fail at runtime/import time, not at parse time), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 adds a 'replay' parameter to the function signature, and Edit 1 uses both 'no_input' and 'replay' parameters in a validation check within the same function body. The changed lines in Edit 1 explicitly reference the exact same 'replay' parameter symbol that was added in Edit 0's signature change. This creates a direct code dependency where adding the parameter naturally prompts its usage in validation logic as the next mechanical step. Both edits reference the same symbols within the same function scope."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 adds a 'replay' parameter to the function signature, and Edit 1 uses both 'no_input' and 'replay' parameters in a validation check within the same function body. The changed lines in Edit 1 explicitly reference the exact same 'replay' parameter symbol that was added in Edit 0's signature change. This creates a direct code dependency where adding the parameter naturally prompts its usage in validation logic as the next mechanical step. Both edits reference the same symbols within the same function scope."
        }
    ],
    "allowed_init_edits": [
        1
    ]
}