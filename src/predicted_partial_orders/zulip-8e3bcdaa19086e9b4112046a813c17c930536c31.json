{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits are adding handling for the 'user_created' message type within the same function `restore_saved_messages()`. Edit 0 adds a new elif branch specifically for 'user_created' messages, while Edit 1 modifies an existing condition to also handle 'user_created' messages alongside 'user_activated' messages. Both edits reference the exact same string literal 'user_created' and are part of the same logical change to add support for this message type. The edits represent a coordinated modification where both locations need to handle the same new message type, making either edit naturally prompt the other as the next mechanical step in implementing complete support for 'user_created' messages."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits are adding handling for the 'user_created' message type within the same function `restore_saved_messages()`. Edit 0 adds a new elif branch specifically for 'user_created' messages, while Edit 1 modifies an existing condition to also handle 'user_created' messages alongside 'user_activated' messages. Both edits reference the exact same string literal 'user_created' and are part of the same logical change to add support for this message type. The edits represent a coordinated modification where both locations need to handle the same new message type, making either edit naturally prompt the other as the next mechanical step in implementing complete support for 'user_created' messages."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 1 defines a function `do_create_user` that logs an event with type 'user_created', and Edit 0 adds handling for message_type 'user_created' in a message restoration function. The changed lines reference the exact same string literal 'user_created' - Edit 1 creates/logs this message type, and Edit 0 handles/processes it. This creates a direct code linkage where the message type logged in Edit 1 is the same message type being handled in Edit 0. Both edits can be staged in either order since they don't create parse-time dependencies, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 1 defines a function `do_create_user` that logs an event with type 'user_created', and Edit 0 adds handling for message_type 'user_created' in a message restoration function. The changed lines reference the exact same string literal 'user_created' - Edit 1 creates/logs this message type, and Edit 0 handles/processes it. This creates a direct code linkage where the message type logged in Edit 1 is the same message type being handled in Edit 0. Both edits can be staged in either order since they don't create parse-time dependencies, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 defines a new function 'do_create_user' in zephyr/models.py, and Edit 1 imports that exact same function 'do_create_user' in zephyr/views.py by adding it to the import statement. The changed lines reference the exact same symbol - the function 'do_create_user'. In Python, both edits can be written and parsed in either order since import statements are resolved at runtime, not parse time. After making either edit, the other becomes the immediate next step to complete the definition-usage relationship."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 defines a new function 'do_create_user' in zephyr/models.py, and Edit 1 imports that exact same function 'do_create_user' in zephyr/views.py by adding it to the import statement. The changed lines reference the exact same symbol - the function 'do_create_user'. In Python, both edits can be written and parsed in either order since import statements are resolved at runtime, not parse time. After making either edit, the other becomes the immediate next step to complete the definition-usage relationship."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbols in their changed lines. Edit 0 changes the import statement from 'create_user' to 'do_create_user', and edit 1 changes the function call from 'create_user(...)' to 'do_create_user(...)'. The changed lines in both edits reference the same symbol being renamed. This creates a direct code dependency where either edit prompts the other as the immediate next step - if you change the import, you need to update the usage, and vice versa. Both edits can be staged in either order without causing parse errors (Python allows importing non-existent functions and calling undefined functions at parse time, with errors only occurring at runtime)."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbols in their changed lines. Edit 0 changes the import statement from 'create_user' to 'do_create_user', and edit 1 changes the function call from 'create_user(...)' to 'do_create_user(...)'. The changed lines in both edits reference the same symbol being renamed. This creates a direct code dependency where either edit prompts the other as the immediate next step - if you change the import, you need to update the usage, and vice versa. Both edits can be staged in either order without causing parse errors (Python allows importing non-existent functions and calling undefined functions at parse time, with errors only occurring at runtime)."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 defines a new function `do_create_user` in zephyr/models.py, while Edit 1 replaces a call to `create_user` with a call to the newly defined `do_create_user` function in zephyr/views.py. The changed lines reference the exact same symbol - the `do_create_user` function. After defining the function in Edit 0, Edit 1 becomes the immediate next step to use this new function. However, since Edit 1 could theoretically be written before Edit 0 (it would just cause a runtime NameError in Python, not a parse error), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 defines a new function `do_create_user` in zephyr/models.py, while Edit 1 replaces a call to `create_user` with a call to the newly defined `do_create_user` function in zephyr/views.py. The changed lines reference the exact same symbol - the `do_create_user` function. After defining the function in Edit 0, Edit 1 becomes the immediate next step to use this new function. However, since Edit 1 could theoretically be written before Edit 0 (it would just cause a runtime NameError in Python, not a parse error), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'do_activate_user'. Edit 0 imports 'do_activate_user' in the import statement, and Edit 1 calls 'do_activate_user(user)' in the function body. This creates a direct definition-usage relationship where the import makes the function available for use, and the function call uses that imported symbol. In Python, both edits can be staged in either order since the usage before import would only cause a runtime NameError, not a parse error. After making either edit, the other becomes the immediate next step to complete the functionality."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'do_activate_user'. Edit 0 imports 'do_activate_user' in the import statement, and Edit 1 calls 'do_activate_user(user)' in the function body. This creates a direct definition-usage relationship where the import makes the function available for use, and the function call uses that imported symbol. In Python, both edits can be staged in either order since the usage before import would only cause a runtime NameError, not a parse error. After making either edit, the other becomes the immediate next step to complete the functionality."
        }
    ],
    "allowed_init_edits": [
        1,
        4
    ]
}