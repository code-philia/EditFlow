{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds two new command-line arguments '--vcodec' and '--pix_fmt' to the argument parser. Edit 1 uses these exact same arguments (args.vcodec and args.pix_fmt) in the configuration logic. The changed lines in edit 1 directly reference the arguments defined in edit 0's changed lines. This creates an immediate code dependency where after adding the argument definitions, the next logical step is to use those arguments in the configuration processing. Both edits reference the exact same symbols (the vcodec and pix_fmt arguments) and form a definition-usage pattern within the same file."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds two new command-line arguments '--vcodec' and '--pix_fmt' to the argument parser. Edit 1 uses these exact same arguments (args.vcodec and args.pix_fmt) in the configuration logic. The changed lines in edit 1 directly reference the arguments defined in edit 0's changed lines. This creates an immediate code dependency where after adding the argument definitions, the next logical step is to use those arguments in the configuration processing. Both edits reference the exact same symbols (the vcodec and pix_fmt arguments) and form a definition-usage pattern within the same file."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 changes the function to assign the dictionary to a variable named 'result' instead of directly returning it. Edit 1 then adds code that references this same 'result' variable multiple times to modify it before returning it. The changed lines in both edits reference the exact same symbol 'result'. Edit 0 creates the variable that Edit 1 immediately uses, making this a clear definition-usage relationship within the same function scope. However, since this is Python, Edit 1 could technically be written and parsed even if Edit 0 hadn't been made yet (it would just cause a NameError at runtime), so this is bi-directional rather than ordered."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 changes the function to assign the dictionary to a variable named 'result' instead of directly returning it. Edit 1 then adds code that references this same 'result' variable multiple times to modify it before returning it. The changed lines in both edits reference the exact same symbol 'result'. Edit 0 creates the variable that Edit 1 immediately uses, making this a clear definition-usage relationship within the same function scope. However, since this is Python, Edit 1 could technically be written and parsed even if Edit 0 hadn't been made yet (it would just cause a NameError at runtime), so this is bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbols (video_codec and pixel_format parameters). Edit 0 adds these parameters to the function signature, and Edit 1 assigns these parameters to instance variables within the same __init__ method. After adding parameters to a function signature, the immediate next step is typically to use those parameters in the function body. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbols (video_codec and pixel_format parameters). Edit 0 adds these parameters to the function signature, and Edit 1 assigns these parameters to instance variables within the same __init__ method. After adding parameters to a function signature, the immediate next step is typically to use those parameters in the function body. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 adds instance variables 'self.video_codec' and 'self.pixel_format' in the constructor, while Edit 1 adds a method 'use_fast_encoding()' that assigns values to these exact same instance variables. The changed lines in Edit 1 directly reference and assign to the same symbols (self.video_codec and self.pixel_format) that are being initialized in Edit 0. This creates a direct code dependency where either edit can be made first - if Edit 0 is made first, the instance variables exist for Edit 1 to use; if Edit 1 is made first, it will create the instance variables when the method is called. Both edits reference the exact same symbols and either naturally prompts the other as part of implementing a video encoding feature."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 adds instance variables 'self.video_codec' and 'self.pixel_format' in the constructor, while Edit 1 adds a method 'use_fast_encoding()' that assigns values to these exact same instance variables. The changed lines in Edit 1 directly reference and assign to the same symbols (self.video_codec and self.pixel_format) that are being initialized in Edit 0. This creates a direct code dependency where either edit can be made first - if Edit 0 is made first, the instance variables exist for Edit 1 to use; if Edit 1 is made first, it will create the instance variables when the method is called. Both edits reference the exact same symbols and either naturally prompts the other as part of implementing a video encoding feature."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 adds two new parameters 'video_codec' and 'pixel_format' to the __init__ method of SceneFileWriter class. Edit 1 modifies the open_movie_pipe method to use these exact same parameters (self.video_codec and self.pixel_format) that were added in Edit 0. The changed lines in Edit 1 directly reference the same symbols that were added as parameters in Edit 0. This creates a direct code dependency where adding the parameters in the constructor enables their usage in the method. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other as the next logical step in the same micro-task of refactoring video encoding configuration."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 adds two new parameters 'video_codec' and 'pixel_format' to the __init__ method of SceneFileWriter class. Edit 1 modifies the open_movie_pipe method to use these exact same parameters (self.video_codec and self.pixel_format) that were added in Edit 0. The changed lines in Edit 1 directly reference the same symbols that were added as parameters in Edit 0. This creates a direct code dependency where adding the parameters in the constructor enables their usage in the method. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other as the next logical step in the same micro-task of refactoring video encoding configuration."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Edit 0 adds two new parameters 'video_codec' and 'pixel_format' to the __init__ method signature. Edit 1 adds a new method 'use_fast_encoding' that assigns values to self.video_codec and self.pixel_format. The changed lines in edit 1 reference the exact same symbols (video_codec and pixel_format) that were added as parameters in edit 0. After adding the parameters in the constructor, adding a method that uses those parameters is a natural next step in the same development flow. Both edits can be staged in either order since Python allows method definitions that reference attributes not yet initialized."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 0 adds two new parameters 'video_codec' and 'pixel_format' to the __init__ method signature. Edit 1 adds a new method 'use_fast_encoding' that assigns values to self.video_codec and self.pixel_format. The changed lines in edit 1 reference the exact same symbols (video_codec and pixel_format) that were added as parameters in edit 0. After adding the parameters in the constructor, adding a method that uses those parameters is a natural next step in the same development flow. Both edits can be staged in either order since Python allows method definitions that reference attributes not yet initialized."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 changes the open_movie_pipe method to use self.video_codec and self.pixel_format attributes instead of hardcoded codec logic. Edit 1 adds a new method use_fast_encoding() that sets these exact same attributes (self.video_codec and self.pixel_format). The changed lines in edit 0 reference these attributes, and edit 1 defines/assigns values to these same attributes. This creates a direct code dependency where either edit could be made first, and after making either edit, the other becomes a natural next step - either to use the newly added attributes or to define the attributes being referenced."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 changes the open_movie_pipe method to use self.video_codec and self.pixel_format attributes instead of hardcoded codec logic. Edit 1 adds a new method use_fast_encoding() that sets these exact same attributes (self.video_codec and self.pixel_format). The changed lines in edit 0 reference these attributes, and edit 1 defines/assigns values to these same attributes. This creates a direct code dependency where either edit could be made first, and after making either edit, the other becomes a natural next step - either to use the newly added attributes or to define the attributes being referenced."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 adds two new instance attributes (self.video_codec and self.pixel_format) to the __init__ method, while Edit 1 uses these exact same attributes in the open_movie_pipe method. The changed lines in Edit 1 directly reference the attributes that are being assigned in Edit 0's changed lines. This creates an immediate code dependency where the attributes must be defined before they can be used. However, in Python, both edits can be written and parsed in either order since attribute access doesn't cause parse-time errors - it would only cause a runtime AttributeError if the attributes don't exist when accessed. Since both edits reference the exact same symbols (self.video_codec and self.pixel_format) and either edit naturally prompts the other as the next mechanical step in implementing this feature, this is a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 adds two new instance attributes (self.video_codec and self.pixel_format) to the __init__ method, while Edit 1 uses these exact same attributes in the open_movie_pipe method. The changed lines in Edit 1 directly reference the attributes that are being assigned in Edit 0's changed lines. This creates an immediate code dependency where the attributes must be defined before they can be used. However, in Python, both edits can be written and parsed in either order since attribute access doesn't cause parse-time errors - it would only cause a runtime AttributeError if the attributes don't exist when accessed. Since both edits reference the exact same symbols (self.video_codec and self.pixel_format) and either edit naturally prompts the other as the next mechanical step in implementing this feature, this is a bi-directional relationship."
        }
    ],
    "allowed_init_edits": [
        0,
        1
    ]
}