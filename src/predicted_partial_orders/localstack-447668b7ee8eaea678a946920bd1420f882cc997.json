{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: wrapping a 'Detail' field value with json.dumps(). Both target the same type of syntactic construct (dictionary entries in put_events calls) and apply the exact same before\u2192after transformation. This appears to be part of a single, contiguous refactor to ensure Detail fields are properly JSON-serialized across the test suite. The edits are mechanically identical and would naturally occur together in one uninterrupted micro-task."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: wrapping a 'Detail' field value with json.dumps(). Both target the same type of syntactic construct (dictionary entries in put_events calls) and apply the exact same before\u2192after transformation. This appears to be part of a single, contiguous refactor to ensure Detail fields are properly JSON-serialized across the test suite. The edits are mechanically identical and would naturally occur together in one uninterrupted micro-task."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits apply the same transformation pattern to the same data field: converting event['Detail'] from a string to a parsed JSON object using json.loads(). Edit 0 changes the production code to parse the Detail field, while Edit 1 updates the corresponding test assertion to expect the parsed JSON format instead of the raw string. These edits reference the exact same data field ('Detail') and apply identical json.loads() transformation, making them part of a synchronized change where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits apply the same transformation pattern to the same data field: converting event['Detail'] from a string to a parsed JSON object using json.loads(). Edit 0 changes the production code to parse the Detail field, while Edit 1 updates the corresponding test assertion to expect the parsed JSON format instead of the raw string. These edits reference the exact same data field ('Detail') and apply identical json.loads() transformation, making them part of a synchronized change where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: wrapping a 'Detail' field value with json.dumps(). Both are modifying the same type of syntactic construct (dictionary entries in put_events calls) with the exact same before\u2192after transformation pattern. This appears to be part of a single, contiguous refactor to ensure Detail fields are properly JSON-serialized across the test file. The edits represent a bulk uniform substitution where either could be made first, and after making one, the other becomes an obvious next step to maintain consistency."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: wrapping a 'Detail' field value with json.dumps(). Both are modifying the same type of syntactic construct (dictionary entries in put_events calls) with the exact same before\u2192after transformation pattern. This appears to be part of a single, contiguous refactor to ensure Detail fields are properly JSON-serialized across the test file. The edits represent a bulk uniform substitution where either could be made first, and after making one, the other becomes an obvious next step to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits are part of the same test method and involve changing how the 'Detail' field is handled - edit 0 changes the test to serialize the detail using json.dumps(), while edit 1 changes the assertion to deserialize it using json.loads(). These edits reference the exact same 'Detail' field and form a synchronized pair where the serialization in the test setup must match the deserialization in the assertion for the test to work correctly. Either edit can be made first since both are syntactically valid, but making one creates an immediate prompt for the other to maintain test consistency."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits are part of the same test method and involve changing how the 'Detail' field is handled - edit 0 changes the test to serialize the detail using json.dumps(), while edit 1 changes the assertion to deserialize it using json.loads(). These edits reference the exact same 'Detail' field and form a synchronized pair where the serialization in the test setup must match the deserialization in the assertion for the test to work correctly. Either edit can be made first since both are syntactically valid, but making one creates an immediate prompt for the other to maintain test consistency."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Detail': TEST_EVENT_PATTERN['Detail'] to 'Detail': json.dumps(TEST_EVENT_PATTERN['Detail']). They target the same type of syntactic construct (dictionary value assignment in event entries) and appear to be part of a single, contiguous refactor to ensure event details are properly JSON-serialized. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after transformation to structurally identical code locations."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Detail': TEST_EVENT_PATTERN['Detail'] to 'Detail': json.dumps(TEST_EVENT_PATTERN['Detail']). They target the same type of syntactic construct (dictionary value assignment in event entries) and appear to be part of a single, contiguous refactor to ensure event details are properly JSON-serialized. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after transformation to structurally identical code locations."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Detail': TEST_EVENT_PATTERN['Detail'] to 'Detail': json.dumps(TEST_EVENT_PATTERN['Detail']). This is a uniform bulk edit applying the same before\u2192after transformation to the same type of syntactic construct (dictionary value assignment) in two different test methods within the same file. Both edits are part of a single refactoring operation to ensure the Detail field is properly JSON-serialized. Either edit can be made first, and after making one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Detail': TEST_EVENT_PATTERN['Detail'] to 'Detail': json.dumps(TEST_EVENT_PATTERN['Detail']). This is a uniform bulk edit applying the same before\u2192after transformation to the same type of syntactic construct (dictionary value assignment) in two different test methods within the same file. Both edits are part of a single refactoring operation to ensure the Detail field is properly JSON-serialized. Either edit can be made first, and after making one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Detail': TEST_EVENT_PATTERN['Detail'] to 'Detail': json.dumps(TEST_EVENT_PATTERN['Detail']). This is a uniform bulk substitution targeting the same type of syntactic construct (dictionary value assignment) within similar test methods. Both edits are part of the same refactoring operation to ensure event details are properly JSON-serialized. Either edit can be made first, and after making one, the other becomes the natural next step to complete the uniform pattern application across the codebase."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'Detail': TEST_EVENT_PATTERN['Detail'] to 'Detail': json.dumps(TEST_EVENT_PATTERN['Detail']). This is a uniform bulk substitution targeting the same type of syntactic construct (dictionary value assignment) within similar test methods. Both edits are part of the same refactoring operation to ensure event details are properly JSON-serialized. Either edit can be made first, and after making one, the other becomes the natural next step to complete the uniform pattern application across the codebase."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: wrapping a 'Detail' field value with json.dumps(). Both target the same type of syntactic construct (dictionary entries in put_events calls) and apply the exact same before\u2192after transformation. This appears to be part of a single, contiguous refactor to ensure Detail fields are properly JSON-serialized across the test suite. The edits are mechanically identical and would naturally occur together in one uninterrupted micro-task."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: wrapping a 'Detail' field value with json.dumps(). Both target the same type of syntactic construct (dictionary entries in put_events calls) and apply the exact same before\u2192after transformation. This appears to be part of a single, contiguous refactor to ensure Detail fields are properly JSON-serialized across the test suite. The edits are mechanically identical and would naturally occur together in one uninterrupted micro-task."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}