{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform identical structural changes to calls of the same function `tex_content_to_svg_file`. Each edit removes the `with display_during_execution` wrapper and adds `self.tex_string` as a fourth parameter to the function call. This represents a uniform, synchronized substitution pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (function calls to the same function). Both edits reference the exact same function symbol and apply identical modifications as part of what appears to be a single refactoring operation."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform identical structural changes to calls of the same function `tex_content_to_svg_file`. Each edit removes the `with display_during_execution` wrapper and adds `self.tex_string` as a fourth parameter to the function call. This represents a uniform, synchronized substitution pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (function calls to the same function). Both edits reference the exact same function symbol and apply identical modifications as part of what appears to be a single refactoring operation."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitution - removing the same import line 'from manimlib.utils.tex_file_writing import display_during_execution' from different files. This is a bulk-edit pattern where the same construct type (import statement) is being modified with the same before\u2192after pattern (removal of the same import) across multiple files. This appears to be part of a single, contiguous refactor to remove unused imports. Either edit can be performed first, and after making either edit, the other becomes a natural next step in completing the same refactoring task."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform identical textual substitution - removing the same import line 'from manimlib.utils.tex_file_writing import display_during_execution' from different files. This is a bulk-edit pattern where the same construct type (import statement) is being modified with the same before\u2192after pattern (removal of the same import) across multiple files. This appears to be part of a single, contiguous refactor to remove unused imports. Either edit can be performed first, and after making either edit, the other becomes a natural next step in completing the same refactoring task."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 removes the import of `display_during_execution` from `manimlib.utils.tex_file_writing`, while Edit 1 removes the usage of that same `display_during_execution` function in a different file. The changed lines reference the exact same symbol - `display_during_execution` - where Edit 0 removes its import and Edit 1 removes its usage. This creates a direct code dependency where removing the usage (Edit 1) makes the import unnecessary, or removing the import (Edit 0) requires removing the usage to avoid a NameError. Both edits are part of the same refactoring task to eliminate the `display_during_execution` functionality. Either edit can be made first since Python allows undefined symbols at parse time (they only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 removes the import of `display_during_execution` from `manimlib.utils.tex_file_writing`, while Edit 1 removes the usage of that same `display_during_execution` function in a different file. The changed lines reference the exact same symbol - `display_during_execution` - where Edit 0 removes its import and Edit 1 removes its usage. This creates a direct code dependency where removing the usage (Edit 1) makes the import unnecessary, or removing the import (Edit 0) requires removing the usage to avoid a NameError. Both edits are part of the same refactoring task to eliminate the `display_during_execution` functionality. Either edit can be made first since Python allows undefined symbols at parse time (they only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 removes the import of 'display_during_execution' from the imports section, while Edit 1 removes the usage of that same 'display_during_execution' function in the method body. These edits reference the exact same symbol - the 'display_during_execution' function. After removing the usage in Edit 1, the import in Edit 0 becomes unused and should be removed as the next mechanical step. Conversely, after removing the import in Edit 0, the usage in Edit 1 would cause a NameError at runtime (though it would still parse). Since both edits can be written and parsed in either order (Python allows referencing undefined names at parse time), this is a bi-directional relationship where either edit naturally prompts the other as the immediate next step."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 removes the import of 'display_during_execution' from the imports section, while Edit 1 removes the usage of that same 'display_during_execution' function in the method body. These edits reference the exact same symbol - the 'display_during_execution' function. After removing the usage in Edit 1, the import in Edit 0 becomes unused and should be removed as the next mechanical step. Conversely, after removing the import in Edit 0, the usage in Edit 1 would cause a NameError at runtime (though it would still parse). Since both edits can be written and parsed in either order (Python allows referencing undefined names at parse time), this is a bi-directional relationship where either edit naturally prompts the other as the immediate next step."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 changes a function call to `tex_content_to_svg_file` by adding a fourth parameter `self.tex_string`, while Edit 1 changes the function signature of `tex_content_to_svg_file` by adding a fourth parameter `short_tex`. These edits reference the exact same function symbol and create a direct code dependency - the call site update in Edit 0 must be synchronized with the signature change in Edit 1. After making either edit, the other becomes the immediate next step to maintain code consistency. Both edits can be staged in either order without causing parse errors (the call with extra arguments or the function with unused parameter are both syntactically valid in Python), making this a bi-directional relationship."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 changes a function call to `tex_content_to_svg_file` by adding a fourth parameter `self.tex_string`, while Edit 1 changes the function signature of `tex_content_to_svg_file` by adding a fourth parameter `short_tex`. These edits reference the exact same function symbol and create a direct code dependency - the call site update in Edit 0 must be synchronized with the signature change in Edit 1. After making either edit, the other becomes the immediate next step to maintain code consistency. Both edits can be staged in either order without causing parse errors (the call with extra arguments or the function with unused parameter are both syntactically valid in Python), making this a bi-directional relationship."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 removes the import of 'display_during_execution' from the imports section, while Edit 1 removes the usage of that same 'display_during_execution' function in the method body. These edits reference the exact same symbol - the 'display_during_execution' function. After removing the usage in Edit 1, the import in Edit 0 becomes unused and should be removed as the next mechanical step. Conversely, after removing the import in Edit 0, the usage in Edit 1 would cause a NameError at runtime (though it would still parse). Since both edits can be written and parsed in either order (Python allows referencing undefined names at parse time), this is a bi-directional relationship where either edit naturally prompts the other as the immediate next step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 removes the import of 'display_during_execution' from the imports section, while Edit 1 removes the usage of that same 'display_during_execution' function in the method body. These edits reference the exact same symbol - the 'display_during_execution' function. After removing the usage in Edit 1, the import in Edit 0 becomes unused and should be removed as the next mechanical step. Conversely, after removing the import in Edit 0, the usage in Edit 1 would cause a NameError at runtime (though it would still parse). Since both edits can be written and parsed in either order (Python allows referencing undefined names at parse time), this is a bi-directional relationship where either edit naturally prompts the other as the immediate next step."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 removes a display_during_execution wrapper from get_file_path_by_content and adds a tex_string parameter to the tex_content_to_svg_file call. Edit 1 adds a display_during_execution wrapper around create_tex_svg in tex_content_to_svg_file. This appears to be moving the display functionality from the caller to the callee. The edits reference the exact same function (tex_content_to_svg_file) and form a coordinated refactor where the display logic is being relocated. Edit 0 must happen first because it adds the tex_string parameter that Edit 1's display message (short_tex) likely depends on, and removing the wrapper from the caller before adding it to the callee maintains the display functionality throughout the refactor."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 adds a parameter 'short_tex' to the function signature, and Edit 1 uses that exact same parameter in the function body. This creates a direct code dependency where the parameter must be defined in the signature before it can be referenced in the body. Both edits reference the exact same symbol 'short_tex' - one defines it as a parameter, the other uses it. This is a classic definition-usage relationship within the same function where the usage edit cannot be parsed/staged without the parameter definition being present first."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds a fourth parameter 'self.tex_string' to the call of tex_content_to_svg_file(), while Edit 1 adds the corresponding parameter 'short_tex' to the function signature of tex_content_to_svg_file(). These edits reference the exact same function symbol and create a direct code dependency - after making either edit, the other becomes the immediate next step to maintain syntactic consistency. The function call and signature must match for the code to work properly."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds a fourth parameter 'self.tex_string' to the call of tex_content_to_svg_file(), while Edit 1 adds the corresponding parameter 'short_tex' to the function signature of tex_content_to_svg_file(). These edits reference the exact same function symbol and create a direct code dependency - after making either edit, the other becomes the immediate next step to maintain syntactic consistency. The function call and signature must match for the code to work properly."
        }
    ],
    "allowed_init_edits": [
        2,
        4,
        5
    ]
}