{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 defines a variable 'max_files = 5000' and Edit 1 uses that exact same variable 'max_files' as a parameter in the MinimalUserBrainEntity constructor. The changed lines reference the exact same symbol - the variable 'max_files' defined in edit 0 is directly used in edit 1. This creates an immediate code dependency where defining the variable naturally prompts its usage as the next step in the same function context."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 defines a variable 'max_files = 5000' and Edit 1 uses that exact same variable 'max_files' as a parameter in the MinimalUserBrainEntity constructor. The changed lines reference the exact same symbol - the variable 'max_files' defined in edit 0 is directly used in edit 1. This creates an immediate code dependency where defining the variable naturally prompts its usage as the next step in the same function context."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 adds 'max_files' to the database query selection, while Edit 1 adds 'max_files=max_files' as a parameter to the MinimalUserBrainEntity constructor. These edits reference the exact same symbol 'max_files' and create a direct code dependency - the query must select the max_files field before it can be used in the entity construction. However, both edits can be written and parsed independently without syntax errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 adds 'max_files' to the database query selection, while Edit 1 adds 'max_files=max_files' as a parameter to the MinimalUserBrainEntity constructor. These edits reference the exact same symbol 'max_files' and create a direct code dependency - the query must select the max_files field before it can be used in the entity construction. However, both edits can be written and parsed independently without syntax errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'max_files' within the same method context. Edit 0 adds 'max_files' to the database query selection, and Edit 1 adds code to extract that 'max_files' value from the query result. These edits have a direct code dependency - adding 'max_files' to the query makes it available for extraction, and extracting it requires it to be in the query. Either edit can be made first without causing parse errors, but making either edit creates an immediate, mechanically obvious prompt for the other as the next step in the same micro-task."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'max_files' within the same method context. Edit 0 adds 'max_files' to the database query selection, and Edit 1 adds code to extract that 'max_files' value from the query result. These edits have a direct code dependency - adding 'max_files' to the query makes it available for extraction, and extracting it requires it to be in the query. Either edit can be made first without causing parse errors, but making either edit creates an immediate, mechanically obvious prompt for the other as the next step in the same micro-task."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits involve the same variable 'max_files' within the same function 'get_user_brains'. Edit 0 initializes max_files with a default value of 5000, and Edit 1 conditionally reassigns max_files from integration data. The changed lines in both edits reference the exact same symbol 'max_files'. This creates a direct code dependency where the initialization in Edit 0 provides a fallback value that can be overridden by the conditional assignment in Edit 1. Either edit can be made first - if Edit 0 comes first, it provides the default; if Edit 1 comes first, it would still work (though max_files would be undefined in the else case). This represents a bi-directional relationship where both edits are part of implementing the same max_files feature within the same micro-task."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits involve the same variable 'max_files' within the same function 'get_user_brains'. Edit 0 initializes max_files with a default value of 5000, and Edit 1 conditionally reassigns max_files from integration data. The changed lines in both edits reference the exact same symbol 'max_files'. This creates a direct code dependency where the initialization in Edit 0 provides a fallback value that can be overridden by the conditional assignment in Edit 1. Either edit can be made first - if Edit 0 comes first, it provides the default; if Edit 1 comes first, it would still work (though max_files would be undefined in the else case). This represents a bi-directional relationship where both edits are part of implementing the same max_files feature within the same micro-task."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits involve adding 'max_files' to the same data structure in the same file and class. Edit 0 adds 'max_files' to the SQL select query that retrieves brain data, while Edit 1 adds 'max_files=100' to the MinimalUserBrainEntity constructor that uses this data. These edits reference the same field ('max_files') and are part of a synchronized change to add this field to the brain data structure. The query modification in Edit 0 makes the field available, and the constructor modification in Edit 1 uses that field. Either edit could be made first since both are syntactically valid independently, but they form a natural pair where making one creates an immediate prompt for the other to complete the feature addition."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits involve adding 'max_files' to the same data structure in the same file and class. Edit 0 adds 'max_files' to the SQL select query that retrieves brain data, while Edit 1 adds 'max_files=100' to the MinimalUserBrainEntity constructor that uses this data. These edits reference the same field ('max_files') and are part of a synchronized change to add this field to the brain data structure. The query modification in Edit 0 makes the field available, and the constructor modification in Edit 1 uses that field. Either edit could be made first since both are syntactically valid independently, but they form a natural pair where making one creates an immediate prompt for the other to complete the feature addition."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds a new field 'max_files: int' to the MinimalUserBrainEntity class definition. Edit 1 adds the corresponding 'max_files=100' parameter to a MinimalUserBrainEntity constructor call in a different file. These edits reference the exact same symbol (the max_files field of MinimalUserBrainEntity) and create a direct code dependency - after adding the field to the class, the constructor call needs to be updated to provide this required parameter, and vice versa. This is a classic definition-usage relationship where both edits can be staged in either order (the constructor call with the extra parameter won't cause a parse error even if the field isn't defined yet in Python), making it bi-directional."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds a new field 'max_files: int' to the MinimalUserBrainEntity class definition. Edit 1 adds the corresponding 'max_files=100' parameter to a MinimalUserBrainEntity constructor call in a different file. These edits reference the exact same symbol (the max_files field of MinimalUserBrainEntity) and create a direct code dependency - after adding the field to the class, the constructor call needs to be updated to provide this required parameter, and vice versa. This is a classic definition-usage relationship where both edits can be staged in either order (the constructor call with the extra parameter won't cause a parse error even if the field isn't defined yet in Python), making it bi-directional."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds a new field 'max_files: int' to the MinimalUserBrainEntity class definition. Edit 1 adds the 'max_files=max_files' parameter to a MinimalUserBrainEntity constructor call in a different file. These edits reference the exact same symbol (the max_files field of MinimalUserBrainEntity). After adding the field to the class definition, the constructor call needs to be updated to include this new required parameter, making this a direct definition-usage relationship. Either edit can be staged first without causing a parse error - if the field is added first, the constructor call can be updated; if the constructor call is updated first, it will reference a field that doesn't exist yet but won't cause a syntax error until runtime/instantiation."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds a new field 'max_files: int' to the MinimalUserBrainEntity class definition. Edit 1 adds the 'max_files=max_files' parameter to a MinimalUserBrainEntity constructor call in a different file. These edits reference the exact same symbol (the max_files field of MinimalUserBrainEntity). After adding the field to the class definition, the constructor call needs to be updated to include this new required parameter, making this a direct definition-usage relationship. Either edit can be staged first without causing a parse error - if the field is added first, the constructor call can be updated; if the constructor call is updated first, it will reference a field that doesn't exist yet but won't cause a syntax error until runtime/instantiation."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits add the same parameter 'max_files' to MinimalUserBrainEntity constructor calls in the same file. This is a bulk-edit pattern where the same structural change (adding max_files parameter) is being applied to multiple instances of the same constructor call. The edits perform identical textual substitution (adding 'max_files=<value>') to the same type of syntactic construct (MinimalUserBrainEntity constructor calls). This represents a single, contiguous refactoring task where both changes would naturally be made together as part of the same micro-task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits add the same parameter 'max_files' to MinimalUserBrainEntity constructor calls in the same file. This is a bulk-edit pattern where the same structural change (adding max_files parameter) is being applied to multiple instances of the same constructor call. The edits perform identical textual substitution (adding 'max_files=<value>') to the same type of syntactic construct (MinimalUserBrainEntity constructor calls). This represents a single, contiguous refactoring task where both changes would naturally be made together as part of the same micro-task."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 defines a variable 'max_files' by extracting it from integration_user data, and Edit 1 uses that exact same variable 'max_files' as a parameter in the MinimalUserBrainEntity constructor. The changed lines reference the exact same symbol - the 'max_files' variable. After making Edit 0, the next immediate, mechanically obvious step would be to use that newly defined variable in the constructor call (Edit 1). Conversely, if Edit 1 were made first, it would reference an undefined variable, creating an immediate prompt to define 'max_files' (Edit 0). This is a classic definition-usage relationship within the same function scope."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 defines a variable 'max_files' by extracting it from integration_user data, and Edit 1 uses that exact same variable 'max_files' as a parameter in the MinimalUserBrainEntity constructor. The changed lines reference the exact same symbol - the 'max_files' variable. After making Edit 0, the next immediate, mechanically obvious step would be to use that newly defined variable in the constructor call (Edit 1). Conversely, if Edit 1 were made first, it would reference an undefined variable, creating an immediate prompt to define 'max_files' (Edit 0). This is a classic definition-usage relationship within the same function scope."
        }
    ],
    "allowed_init_edits": [
        2,
        0
    ]
}