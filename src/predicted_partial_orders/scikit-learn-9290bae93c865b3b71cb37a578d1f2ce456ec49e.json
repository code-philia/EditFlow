{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both add the exact same parameter 'orient=\"row\"' to pl.DataFrame() constructor calls. This represents a bulk uniform substitution pattern where the same before\u2192after change (adding orient=\"row\" parameter) is applied to multiple instances of the same construct type (pl.DataFrame calls). This appears to be part of a single, contiguous refactor to standardize DataFrame creation across the codebase."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both add the exact same parameter 'orient=\"row\"' to pl.DataFrame() constructor calls. This represents a bulk uniform substitution pattern where the same before\u2192after change (adding orient=\"row\" parameter) is applied to multiple instances of the same construct type (pl.DataFrame calls). This appears to be part of a single, contiguous refactor to standardize DataFrame creation across the codebase."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits add the exact same parameter 'orient=\"row\"' to pl.DataFrame() calls in different files. This appears to be part of a uniform, synchronized multi-file substitution where the same API change is being applied consistently across the codebase. Both edits involve identical textual substitution (adding ', orient=\"row\"') to the same type of syntactic construct (pl.DataFrame constructor calls). This creates a bi-directional relationship where either edit could be made first as part of the same contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits add the exact same parameter 'orient=\"row\"' to pl.DataFrame() calls in different files. This appears to be part of a uniform, synchronized multi-file substitution where the same API change is being applied consistently across the codebase. Both edits involve identical textual substitution (adding ', orient=\"row\"') to the same type of syntactic construct (pl.DataFrame constructor calls). This creates a bi-directional relationship where either edit could be made first as part of the same contiguous refactoring task."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits add the same parameter 'orient=\"row\"' to pl.DataFrame() constructor calls, but they reference different DataFrame constructor calls in different files and contexts. Edit 0 modifies a utility function that creates DataFrames generically, while Edit 1 modifies a specific test function. The changed lines do not reference the exact same symbol - they are separate pl.DataFrame constructor calls in different scopes. While both changes follow the same pattern (adding orient parameter), this represents a bulk substitution across different contexts rather than a direct code dependency where one edit creates an immediate prompt for the other."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits add the same parameter 'orient=\"row\"' to pl.DataFrame() constructor calls, but they reference different DataFrame constructor calls in different files and contexts. Edit 0 modifies a utility function that creates DataFrames generically, while Edit 1 modifies a specific test function. The changed lines do not reference the exact same symbol - they are separate pl.DataFrame constructor calls in different scopes. While both changes follow the same pattern (adding orient parameter), this represents a bulk substitution across different contexts rather than a direct code dependency where one edit creates an immediate prompt for the other."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits add the exact same parameter 'orient=\"row\"' to pl.DataFrame constructor calls. This appears to be a uniform substitution pattern where the same API change is being applied consistently across the codebase. The edits reference the same constructor (pl.DataFrame) and apply identical modifications (adding orient=\"row\" parameter). This represents a synchronized bulk edit where both changes are part of the same refactoring effort to update DataFrame constructor calls with the new parameter."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits add the exact same parameter 'orient=\"row\"' to pl.DataFrame constructor calls. This appears to be a uniform substitution pattern where the same API change is being applied consistently across the codebase. The edits reference the same constructor (pl.DataFrame) and apply identical modifications (adding orient=\"row\" parameter). This represents a synchronized bulk edit where both changes are part of the same refactoring effort to update DataFrame constructor calls with the new parameter."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits add the exact same parameter 'orient=\"row\"' to pl.DataFrame() calls. Edit 0 modifies the production code in PolarsAdapter.create_container(), while Edit 1 modifies the corresponding test code in test_polars_adapter(). This represents test-production code synchronization where both edits reference the same API (pl.DataFrame constructor) and apply identical parameter additions. The test is directly testing the behavior of the production code, making this a bi-directional relationship where either edit naturally prompts the other to maintain consistency between implementation and test."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits add the exact same parameter 'orient=\"row\"' to pl.DataFrame() calls. Edit 0 modifies the production code in PolarsAdapter.create_container(), while Edit 1 modifies the corresponding test code in test_polars_adapter(). This represents test-production code synchronization where both edits reference the same API (pl.DataFrame constructor) and apply identical parameter additions. The test is directly testing the behavior of the production code, making this a bi-directional relationship where either edit naturally prompts the other to maintain consistency between implementation and test."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both change 'pl.DataFrame(X_output, schema=columns)' to 'pl.DataFrame(X_output, schema=columns, orient=\"row\")' and 'pl.DataFrame(X, schema=columns)' to 'pl.DataFrame(X, schema=columns, orient=\"row\")' respectively. This is a uniform pattern substitution across multiple locations, adding the same parameter 'orient=\"row\"' to pl.DataFrame constructor calls. Both edits target the same syntactic construct (pl.DataFrame constructor calls) with the identical before\u2192after pattern, making this a clear case of bulk-edit synchronization that would naturally occur in a single contiguous refactor."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both change 'pl.DataFrame(X_output, schema=columns)' to 'pl.DataFrame(X_output, schema=columns, orient=\"row\")' and 'pl.DataFrame(X, schema=columns)' to 'pl.DataFrame(X, schema=columns, orient=\"row\")' respectively. This is a uniform pattern substitution across multiple locations, adding the same parameter 'orient=\"row\"' to pl.DataFrame constructor calls. Both edits target the same syntactic construct (pl.DataFrame constructor calls) with the identical before\u2192after pattern, making this a clear case of bulk-edit synchronization that would naturally occur in a single contiguous refactor."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits add the exact same parameter 'orient=\"row\"' to pl.DataFrame() calls with identical syntax and structure. This represents a bulk uniform substitution pattern where the same before\u2192after change (adding orient=\"row\" parameter) is applied to the same type of syntactic construct (pl.DataFrame constructor calls) across different files. Both edits are part of what appears to be a single refactoring operation to standardize polars DataFrame construction calls. Either edit could be made first, and after making one, the other would be the natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits add the exact same parameter 'orient=\"row\"' to pl.DataFrame() calls with identical syntax and structure. This represents a bulk uniform substitution pattern where the same before\u2192after change (adding orient=\"row\" parameter) is applied to the same type of syntactic construct (pl.DataFrame constructor calls) across different files. Both edits are part of what appears to be a single refactoring operation to standardize polars DataFrame construction calls. Either edit could be made first, and after making one, the other would be the natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both change 'pl.DataFrame(container/X, schema=columns_name/columns)' to 'pl.DataFrame(container/X, schema=columns_name/columns, orient=\"row\")' by adding the same parameter 'orient=\"row\"' to polars DataFrame constructor calls. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single contiguous refactor to update polars DataFrame creation calls across the codebase. The pattern is identical (adding the same parameter with the same value) and targets the same syntactic construct type (polars DataFrame constructor calls)."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both change 'pl.DataFrame(container/X, schema=columns_name/columns)' to 'pl.DataFrame(container/X, schema=columns_name/columns, orient=\"row\")' by adding the same parameter 'orient=\"row\"' to polars DataFrame constructor calls. This represents a uniform, synchronized multi-file substitution that would naturally occur as part of a single contiguous refactor to update polars DataFrame creation calls across the codebase. The pattern is identical (adding the same parameter with the same value) and targets the same syntactic construct type (polars DataFrame constructor calls)."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits make identical textual substitutions to the same type of syntactic construct - they both add the parameter 'orient=\"row\"' to pl.DataFrame constructor calls. This represents a bulk uniform substitution pattern where the same before\u2192after change (adding orient=\"row\" parameter) is applied to multiple pl.DataFrame calls across different files. The edits appear to be part of a single contiguous refactor to standardize DataFrame construction calls. Since both edits can be staged in either order and either edit naturally prompts the other as part of the same substitution pattern, this is bi-directional."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits make identical textual substitutions to the same type of syntactic construct - they both add the parameter 'orient=\"row\"' to pl.DataFrame constructor calls. This represents a bulk uniform substitution pattern where the same before\u2192after change (adding orient=\"row\" parameter) is applied to multiple pl.DataFrame calls across different files. The edits appear to be part of a single contiguous refactor to standardize DataFrame construction calls. Since both edits can be staged in either order and either edit naturally prompts the other as part of the same substitution pattern, this is bi-directional."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits add the exact same parameter `orient=\"row\"` to `pl.DataFrame` constructor calls. This represents a bulk uniform substitution pattern where the same before\u2192after change (adding `orient=\"row\"`) is applied to the same type of syntactic construct (pl.DataFrame constructor calls) across different files. This appears to be part of a single, contiguous refactor to standardize DataFrame creation calls. Either edit could be made first, and after making either one, the other would be the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits add the exact same parameter `orient=\"row\"` to `pl.DataFrame` constructor calls. This represents a bulk uniform substitution pattern where the same before\u2192after change (adding `orient=\"row\"`) is applied to the same type of syntactic construct (pl.DataFrame constructor calls) across different files. This appears to be part of a single, contiguous refactor to standardize DataFrame creation calls. Either edit could be made first, and after making either one, the other would be the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits add the same parameter 'orient=\"row\"' to pl.DataFrame() constructor calls, but they are in different files and different contexts. Edit 0 is in a helper function within estimator_checks.py, while Edit 1 is in a test function in test_utils.py. The changed lines reference different pl.DataFrame constructor calls - they are not the exact same symbol or function call. This appears to be a bulk refactoring pattern where the same parameter is being added to multiple DataFrame constructors, but since they are different constructor calls in different contexts, they reference different symbols despite using the same API."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits add the same parameter 'orient=\"row\"' to pl.DataFrame() constructor calls, but they are in different files and different contexts. Edit 0 is in a helper function within estimator_checks.py, while Edit 1 is in a test function in test_utils.py. The changed lines reference different pl.DataFrame constructor calls - they are not the exact same symbol or function call. This appears to be a bulk refactoring pattern where the same parameter is being added to multiple DataFrame constructors, but since they are different constructor calls in different contexts, they reference different symbols despite using the same API."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter `orient=\"row\"` to `pl.DataFrame()` constructor calls. They target the same type of syntactic construct (DataFrame constructor calls) and appear to be part of a single, contiguous refactor to standardize DataFrame creation with explicit orientation specification. This is a bulk-edit pattern where the same modification is being applied uniformly across multiple locations in the same test function."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter `orient=\"row\"` to `pl.DataFrame()` constructor calls. They target the same type of syntactic construct (DataFrame constructor calls) and appear to be part of a single, contiguous refactor to standardize DataFrame creation with explicit orientation specification. This is a bulk-edit pattern where the same modification is being applied uniformly across multiple locations in the same test function."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter `orient=\"row\"` to `pl.DataFrame()` constructor calls. The edits target the same type of syntactic construct (DataFrame constructor calls) and apply the exact same before\u2192after transformation. This represents a uniform, contiguous refactor where both changes would naturally occur as part of a single micro-task to update all DataFrame constructor calls in the same test function with the new parameter. Either edit could be made first, and after making one, the other would be the immediate next step to complete the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter `orient=\"row\"` to `pl.DataFrame()` constructor calls. The edits target the same type of syntactic construct (DataFrame constructor calls) and apply the exact same before\u2192after transformation. This represents a uniform, contiguous refactor where both changes would naturally occur as part of a single micro-task to update all DataFrame constructor calls in the same test function with the new parameter. Either edit could be made first, and after making one, the other would be the immediate next step to complete the uniform substitution pattern."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits add the exact same parameter `orient=\"row\"` to `pl.DataFrame()` calls with identical structure (data as nested list, schema parameter). This represents a bulk uniform substitution pattern where the same before\u2192after change is applied to the same type of syntactic construct (pl.DataFrame constructor calls). Both edits are part of what appears to be a single refactoring operation to add the orient parameter consistently across the codebase. Either edit could be made first, and after making one, the other would be the natural next step to maintain consistency."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits add the exact same parameter `orient=\"row\"` to `pl.DataFrame()` calls with identical structure (data as nested list, schema parameter). This represents a bulk uniform substitution pattern where the same before\u2192after change is applied to the same type of syntactic construct (pl.DataFrame constructor calls). Both edits are part of what appears to be a single refactoring operation to add the orient parameter consistently across the codebase. Either edit could be made first, and after making one, the other would be the natural next step to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits add the same parameter 'orient=\"row\"' to pl.DataFrame() constructor calls in different test files. This represents a bulk/pattern synchronization where identical structural substitutions are being applied to the same type of syntactic construct (pl.DataFrame constructor calls). Both edits are part of what appears to be a uniform refactor to add the orient parameter to polars DataFrame constructors across the codebase. Either edit can be made first, and after making one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits add the same parameter 'orient=\"row\"' to pl.DataFrame() constructor calls in different test files. This represents a bulk/pattern synchronization where identical structural substitutions are being applied to the same type of syntactic construct (pl.DataFrame constructor calls). Both edits are part of what appears to be a uniform refactor to add the orient parameter to polars DataFrame constructors across the codebase. Either edit can be made first, and after making one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter `orient=\"row\"` to `pl.DataFrame()` constructor calls. They target the same type of syntactic construct (DataFrame constructor calls) within the same test function. This represents a uniform, synchronized modification where both changes are part of the same contiguous refactor to add the orient parameter consistently across all DataFrame creations in the test. Either edit can be made first, and after making either one, the other becomes the natural next step to maintain consistency in the test function."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter `orient=\"row\"` to `pl.DataFrame()` constructor calls. They target the same type of syntactic construct (DataFrame constructor calls) within the same test function. This represents a uniform, synchronized modification where both changes are part of the same contiguous refactor to add the orient parameter consistently across all DataFrame creations in the test. Either edit can be made first, and after making either one, the other becomes the natural next step to maintain consistency in the test function."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits add the exact same parameter `orient=\"row\"` to `pl.DataFrame` constructor calls. Edit 0 modifies the production code in the PolarsAdapter class, while Edit 1 modifies the corresponding test code that tests this exact functionality. The test code directly exercises the same DataFrame creation pattern that was modified in the production code. This creates a bi-directional relationship where either edit can be made first, but after making one, the other becomes the immediate next step to maintain consistency between the production implementation and its test. Both edits reference the same API pattern and the test specifically validates the behavior being modified in production."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits add the exact same parameter `orient=\"row\"` to `pl.DataFrame` constructor calls. Edit 0 modifies the production code in the PolarsAdapter class, while Edit 1 modifies the corresponding test code that tests this exact functionality. The test code directly exercises the same DataFrame creation pattern that was modified in the production code. This creates a bi-directional relationship where either edit can be made first, but after making one, the other becomes the immediate next step to maintain consistency between the production implementation and its test. Both edits reference the same API pattern and the test specifically validates the behavior being modified in production."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits add the exact same parameter 'orient=\"row\"' to pl.DataFrame() calls with identical structure (container/X_np, schema=columns_name/columns, orient=\"row\"). This represents a uniform substitution pattern where the same modification is being applied to the same type of syntactic construct (pl.DataFrame calls) across multiple locations. This appears to be part of a single refactoring operation to standardize DataFrame creation calls by adding the orient parameter. Both edits reference the same API (pl.DataFrame) and apply an identical before\u2192after pattern, making either edit naturally prompt the other as part of the same mechanical substitution task."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits add the exact same parameter 'orient=\"row\"' to pl.DataFrame() calls with identical structure (container/X_np, schema=columns_name/columns, orient=\"row\"). This represents a uniform substitution pattern where the same modification is being applied to the same type of syntactic construct (pl.DataFrame calls) across multiple locations. This appears to be part of a single refactoring operation to standardize DataFrame creation calls by adding the orient parameter. Both edits reference the same API (pl.DataFrame) and apply an identical before\u2192after pattern, making either edit naturally prompt the other as part of the same mechanical substitution task."
        }
    ],
    "allowed_init_edits": [
        6
    ]
}