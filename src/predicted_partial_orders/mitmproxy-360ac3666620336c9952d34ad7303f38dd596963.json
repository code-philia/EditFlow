{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits change references to the same attribute from `mode.type` to `mode.type_name`. In edit 0, the changed lines reference `mode.type` in both an assertion and dictionary assignment. In edit 1, the changed line references `mode.type` in a dictionary lookup. Both edits are accessing the exact same attribute of the same `mode` object and changing it to the same new attribute name `type_name`. This is a uniform substitution pattern where the same symbol reference is being updated across multiple locations as part of a single refactoring operation. Either edit could be made first, and after making either edit, the other becomes an immediate next step to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits change references to the same attribute from `mode.type` to `mode.type_name`. In edit 0, the changed lines reference `mode.type` in both an assertion and dictionary assignment. In edit 1, the changed line references `mode.type` in a dictionary lookup. Both edits are accessing the exact same attribute of the same `mode` object and changing it to the same new attribute name `type_name`. This is a uniform substitution pattern where the same symbol reference is being updated across multiple locations as part of a single refactoring operation. Either edit could be made first, and after making either edit, the other becomes an immediate next step to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits change the exact same attribute name from 'type' to 'type_name' on the ProxyMode class. Edit 1 changes the attribute definition in the ProxyMode class, while Edit 0 changes the usage of that same attribute (mode.type -> mode.type_name). These edits reference the exact same symbol and create a direct code dependency - after making either edit, the other becomes immediately necessary to maintain code consistency. The relationship is bi-directional because both edits can be staged in either order without causing parse errors, but either edit creates an immediate prompt for the other to maintain the rename consistently."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits change the exact same attribute name from 'type' to 'type_name' on the ProxyMode class. Edit 1 changes the attribute definition in the ProxyMode class, while Edit 0 changes the usage of that same attribute (mode.type -> mode.type_name). These edits reference the exact same symbol and create a direct code dependency - after making either edit, the other becomes immediately necessary to maintain code consistency. The relationship is bi-directional because both edits can be staged in either order without causing parse errors, but either edit creates an immediate prompt for the other to maintain the rename consistently."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "These edits are bi-directional neighbours because they perform a synchronized attribute rename from 'type' to 'type_name' on the same class (ProxyMode). Edit 0 changes the usage of the attribute (mode.type to mode.type_name) while Edit 1 changes the definition of that same attribute (cls.type to cls.type_name). Both edits reference the exact same symbol - the 'type'/'type_name' attribute of ProxyMode instances. After making either edit, the other becomes the immediate next step to maintain code consistency, as one edit changes the attribute name definition while the other updates its usage. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "These edits are bi-directional neighbours because they perform a synchronized attribute rename from 'type' to 'type_name' on the same class (ProxyMode). Edit 0 changes the usage of the attribute (mode.type to mode.type_name) while Edit 1 changes the definition of that same attribute (cls.type to cls.type_name). Both edits reference the exact same symbol - the 'type'/'type_name' attribute of ProxyMode instances. After making either edit, the other becomes the immediate next step to maintain code consistency, as one edit changes the attribute name definition while the other updates its usage. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing '.type' to '.type_name' on the same object type (self.mode/mode). This is a clear bulk refactoring operation where the same attribute name is being changed across multiple locations in the same file. Both changed lines reference the exact same type of operation (accessing an attribute on a mode object) and represent the same before\u2192after pattern. This would naturally occur as part of a single, contiguous refactoring task where a developer is systematically updating all references to the renamed attribute."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing '.type' to '.type_name' on the same object type (self.mode/mode). This is a clear bulk refactoring operation where the same attribute name is being changed across multiple locations in the same file. Both changed lines reference the exact same type of operation (accessing an attribute on a mode object) and represent the same before\u2192after pattern. This would naturally occur as part of a single, contiguous refactoring task where a developer is systematically updating all references to the renamed attribute."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitution of 'type' to 'type_name' on the same type of syntactic construct (attribute access and assignment). Edit 0 changes 'mode.type' to 'mode.type_name' in two locations, while Edit 1 changes 'cls.type' to 'cls.type_name' in three locations. This represents a uniform refactoring pattern where the same attribute name is being renamed across related code structures. The edits are part of a single, contiguous refactor to rename the 'type' attribute to 'type_name' throughout the codebase. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform identical textual substitution of 'type' to 'type_name' on the same type of syntactic construct (attribute access and assignment). Edit 0 changes 'mode.type' to 'mode.type_name' in two locations, while Edit 1 changes 'cls.type' to 'cls.type_name' in three locations. This represents a uniform refactoring pattern where the same attribute name is being renamed across related code structures. The edits are part of a single, contiguous refactor to rename the 'type' attribute to 'type_name' throughout the codebase. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits change references from `.type` to `.type_name` on what appears to be the same class or related classes in the proxy mode system. Edit 0 changes `mode.type` to `mode.type_name` in a dictionary lookup, while Edit 1 changes `cls.type` to `cls.type_name` in an error message. Both changed lines reference the same attribute name change (type \u2192 type_name) and appear to be part of a uniform refactoring where an attribute was renamed. This is a synchronized substitution pattern where the same textual change is being applied to references of the same conceptual attribute across the codebase."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits change references from `.type` to `.type_name` on what appears to be the same class or related classes in the proxy mode system. Edit 0 changes `mode.type` to `mode.type_name` in a dictionary lookup, while Edit 1 changes `cls.type` to `cls.type_name` in an error message. Both changed lines reference the same attribute name change (type \u2192 type_name) and appear to be part of a uniform refactoring where an attribute was renamed. This is a synchronized substitution pattern where the same textual change is being applied to references of the same conceptual attribute across the codebase."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing '.type' to '.type_name' on the same type of syntactic construct (attribute access on mode objects). This is a uniform refactoring operation where both changed lines reference the same attribute being renamed across the codebase. The edits are part of a single, contiguous refactor to rename the 'type' attribute to 'type_name' throughout the ServerInstance class. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing '.type' to '.type_name' on the same type of syntactic construct (attribute access on mode objects). This is a uniform refactoring operation where both changed lines reference the same attribute being renamed across the codebase. The edits are part of a single, contiguous refactor to rename the 'type' attribute to 'type_name' throughout the ServerInstance class. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution, changing 'type' to 'type_name' for the same attribute across different files. Edit 0 changes references to 'mode.type' to 'mode.type_name' in the ServerInstance class, while Edit 1 changes the attribute definition from 'type' to 'type_name' in the ProxyMode class. Since both edits reference the exact same symbol (the type/type_name attribute of ProxyMode) and perform the same substitution pattern, either edit can be made first and both are part of a single refactoring operation to rename this attribute throughout the codebase."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution, changing 'type' to 'type_name' for the same attribute across different files. Edit 0 changes references to 'mode.type' to 'mode.type_name' in the ServerInstance class, while Edit 1 changes the attribute definition from 'type' to 'type_name' in the ProxyMode class. Since both edits reference the exact same symbol (the type/type_name attribute of ProxyMode) and perform the same substitution pattern, either edit can be made first and both are part of a single refactoring operation to rename this attribute throughout the codebase."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 renames the attribute from 'type' to 'type_name' in the ProxyMode class __init_subclass__ method. Edit 1 updates a test assertion to use the new attribute name 'type_name' instead of 'type'. Both edits reference the exact same symbol (the class attribute that was renamed from 'type' to 'type_name'). After making either edit, the other becomes the immediate next step to maintain code consistency - if you rename the attribute in the class definition, you must update its usage in tests, and vice versa. This is a bi-directional relationship where both edits are part of the same refactoring operation."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 renames the attribute from 'type' to 'type_name' in the ProxyMode class __init_subclass__ method. Edit 1 updates a test assertion to use the new attribute name 'type_name' instead of 'type'. Both edits reference the exact same symbol (the class attribute that was renamed from 'type' to 'type_name'). After making either edit, the other becomes the immediate next step to maintain code consistency - if you rename the attribute in the class definition, you must update its usage in tests, and vice versa. This is a bi-directional relationship where both edits are part of the same refactoring operation."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol `cls.type` which is being renamed to `cls.type_name`. Edit 0 changes the assignment/definition of this attribute from `cls.type` to `cls.type_name`, while Edit 1 changes the usage of this same attribute from `cls.type` to `cls.type_name`. This is a classic definition-usage relationship where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a single refactoring task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol `cls.type` which is being renamed to `cls.type_name`. Edit 0 changes the assignment/definition of this attribute from `cls.type` to `cls.type_name`, while Edit 1 changes the usage of this same attribute from `cls.type` to `cls.type_name`. This is a classic definition-usage relationship where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a single refactoring task."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Edit 0 renames the class attribute from 'type' to 'type_name' in the ProxyMode class definition. Edit 1 updates a test assertion to use the new attribute name 'type_name' instead of 'type' when accessing the same attribute on a ProxyMode instance. Both edits reference the exact same symbol (the class attribute that was renamed), and after making either edit, the other becomes the immediate next step to maintain code consistency. The test would fail if only one edit were applied."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 0 renames the class attribute from 'type' to 'type_name' in the ProxyMode class definition. Edit 1 updates a test assertion to use the new attribute name 'type_name' instead of 'type' when accessing the same attribute on a ProxyMode instance. Both edits reference the exact same symbol (the class attribute that was renamed), and after making either edit, the other becomes the immediate next step to maintain code consistency. The test would fail if only one edit were applied."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol - they are changing from 'type' to 'type_name' on the same class attribute. Edit 1 changes the definition of the attribute from 'cls.type' to 'cls.type_name' in the ProxyMode class, while Edit 0 changes the usage of that same attribute from 'self.mode.type' to 'self.mode.type_name' in the ServerInstance class. This is a classic definition-usage relationship where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a single refactoring task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol - they are changing from 'type' to 'type_name' on the same class attribute. Edit 1 changes the definition of the attribute from 'cls.type' to 'cls.type_name' in the ProxyMode class, while Edit 0 changes the usage of that same attribute from 'self.mode.type' to 'self.mode.type_name' in the ServerInstance class. This is a classic definition-usage relationship where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a single refactoring task."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits change the exact same attribute name from 'type' to 'type_name' on the same class hierarchy. Edit 0 changes the usage of self.mode.type to self.mode.type_name, while Edit 1 changes the definition of the type attribute to type_name in the ProxyMode class. Since ServerInstance.mode is of type ProxyMode (as evidenced by the usage pattern), both edits reference the exact same symbol - the type/type_name attribute of ProxyMode. This creates a direct definition-usage relationship where either edit can be made first, and after making either edit, the other becomes the immediate next step to maintain code consistency. Both edits can be parsed and staged in either order without syntax errors."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits change the exact same attribute name from 'type' to 'type_name' on the same class hierarchy. Edit 0 changes the usage of self.mode.type to self.mode.type_name, while Edit 1 changes the definition of the type attribute to type_name in the ProxyMode class. Since ServerInstance.mode is of type ProxyMode (as evidenced by the usage pattern), both edits reference the exact same symbol - the type/type_name attribute of ProxyMode. This creates a direct definition-usage relationship where either edit can be made first, and after making either edit, the other becomes the immediate next step to maintain code consistency. Both edits can be parsed and staged in either order without syntax errors."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits are part of a single refactoring operation that renames the class attribute 'type' to 'type_name' throughout the ProxyMode class. Edit 0 changes the ClassVar declaration from 'type' to 'type_name', while Edit 1 updates all three references to this attribute in the __init_subclass__ method. The changed lines in both edits reference the exact same symbol (the class attribute being renamed), making this a synchronized substitution where either edit naturally prompts the other as the immediate next step to maintain code consistency."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits are part of a single refactoring operation that renames the class attribute 'type' to 'type_name' throughout the ProxyMode class. Edit 0 changes the ClassVar declaration from 'type' to 'type_name', while Edit 1 updates all three references to this attribute in the __init_subclass__ method. The changed lines in both edits reference the exact same symbol (the class attribute being renamed), making this a synchronized substitution where either edit naturally prompts the other as the immediate next step to maintain code consistency."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol: the class attribute that was renamed from 'type' to 'type_name'. Edit 0 changes the attribute definition from 'type' to 'type_name', and edit 1 updates the usage of that same attribute from 'cls.type' to 'cls.type_name'. This is a classic definition-usage relationship where both changed lines reference the exact same symbol. After making either edit, the other becomes the immediate next step to maintain code consistency - if you rename the attribute definition, you must update its usage, and vice versa. Both edits can be staged in either order without causing parse errors (Python allows referencing undefined attributes at parse time), making this bi-directional."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol: the class attribute that was renamed from 'type' to 'type_name'. Edit 0 changes the attribute definition from 'type' to 'type_name', and edit 1 updates the usage of that same attribute from 'cls.type' to 'cls.type_name'. This is a classic definition-usage relationship where both changed lines reference the exact same symbol. After making either edit, the other becomes the immediate next step to maintain code consistency - if you rename the attribute definition, you must update its usage, and vice versa. Both edits can be staged in either order without causing parse errors (Python allows referencing undefined attributes at parse time), making this bi-directional."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits change references from 'type' to 'type_name' on the same attribute/property of what appears to be the same class or related classes in the proxy mode system. Edit 0 changes 'cls.type' to 'cls.type_name' in the ProxyMode class, and Edit 1 changes 'm.type' to 'm.type_name' in a test that appears to be testing ProxyMode instances. This is a synchronized refactoring where the same attribute is being renamed across production code and test code. Both changed lines reference the exact same symbol (the type/type_name attribute), making this a bi-directional relationship where either edit could be made first and would prompt the other as the next mechanical step to maintain consistency."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits change references from 'type' to 'type_name' on the same attribute/property of what appears to be the same class or related classes in the proxy mode system. Edit 0 changes 'cls.type' to 'cls.type_name' in the ProxyMode class, and Edit 1 changes 'm.type' to 'm.type_name' in a test that appears to be testing ProxyMode instances. This is a synchronized refactoring where the same attribute is being renamed across production code and test code. Both changed lines reference the exact same symbol (the type/type_name attribute), making this a bi-directional relationship where either edit could be made first and would prompt the other as the next mechanical step to maintain consistency."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits change from accessing `.type` to accessing `.type_name` on what appears to be the same class or related classes in the proxy mode system. Edit 0 changes `self.mode.type` to `self.mode.type_name` in a JSON serialization method, while Edit 1 changes `cls.type` to `cls.type_name` in an error message. This represents a uniform substitution pattern where the same attribute name is being changed across multiple locations in the codebase, likely as part of a refactoring to rename the attribute from `type` to `type_name`. Both edits perform the identical textual substitution (`.type` \u2192 `.type_name`) and target the same type of syntactic construct (attribute access). This appears to be part of a single, contiguous refactor operation."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits change from accessing `.type` to accessing `.type_name` on what appears to be the same class or related classes in the proxy mode system. Edit 0 changes `self.mode.type` to `self.mode.type_name` in a JSON serialization method, while Edit 1 changes `cls.type` to `cls.type_name` in an error message. This represents a uniform substitution pattern where the same attribute name is being changed across multiple locations in the codebase, likely as part of a refactoring to rename the attribute from `type` to `type_name`. Both edits perform the identical textual substitution (`.type` \u2192 `.type_name`) and target the same type of syntactic construct (attribute access). This appears to be part of a single, contiguous refactor operation."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits change from accessing `.type` to accessing `.type_name` on what appears to be the same type of object (a mode object). Edit 0 changes `self.mode.type` to `self.mode.type_name` in a JSON serialization method, while Edit 1 changes `m.type` to `m.type_name` in a test assertion. This appears to be a uniform substitution pattern where the same attribute name is being changed across the codebase from `type` to `type_name`. Both edits involve the exact same textual substitution (`.type` \u2192 `.type_name`) on the same type of syntactic construct (attribute access), making this a bi-directional bulk edit pattern where either change could prompt the other as part of a single refactoring sweep."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits change from accessing `.type` to accessing `.type_name` on what appears to be the same type of object (a mode object). Edit 0 changes `self.mode.type` to `self.mode.type_name` in a JSON serialization method, while Edit 1 changes `m.type` to `m.type_name` in a test assertion. This appears to be a uniform substitution pattern where the same attribute name is being changed across the codebase from `type` to `type_name`. Both edits involve the exact same textual substitution (`.type` \u2192 `.type_name`) on the same type of syntactic construct (attribute access), making this a bi-directional bulk edit pattern where either change could prompt the other as part of a single refactoring sweep."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits change references from 'type' to 'type_name' on the same class (ProxyMode). Edit 0 changes ServerInstance code that accesses 'mode.type' to 'mode.type_name', while Edit 1 changes ProxyMode code that accesses 'cls.type' to 'cls.type_name'. Both edits are part of the same refactoring operation - renaming the 'type' attribute/property to 'type_name' on the ProxyMode class. This is a uniform substitution pattern where the exact same symbol (the 'type' attribute of ProxyMode) is being renamed to 'type_name' in both locations. Either edit can be made first since both are syntactically valid changes that reference the same underlying symbol being renamed."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits change references from 'type' to 'type_name' on the same class (ProxyMode). Edit 0 changes ServerInstance code that accesses 'mode.type' to 'mode.type_name', while Edit 1 changes ProxyMode code that accesses 'cls.type' to 'cls.type_name'. Both edits are part of the same refactoring operation - renaming the 'type' attribute/property to 'type_name' on the ProxyMode class. This is a uniform substitution pattern where the exact same symbol (the 'type' attribute of ProxyMode) is being renamed to 'type_name' in both locations. Either edit can be made first since both are syntactically valid changes that reference the same underlying symbol being renamed."
        }
    ],
    "allowed_init_edits": [
        6
    ]
}