{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 changes the parameter name from 'stream_map' to 'stream_id_map' in the teaser_data method signature. Edit 1 updates the call site to use the new parameter name 'stream_id_map' when calling the same teaser_data method. Both edits reference the exact same method symbol and the change creates an immediate code-driven prompt - after changing the parameter name in the method signature, the call site must be updated to match. This is a classic signature-caller relationship for the same function."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 changes the parameter name from 'stream_map' to 'stream_id_map' in the teaser_data method signature. Edit 1 updates the call site to use the new parameter name 'stream_id_map' when calling the same teaser_data method. Both edits reference the exact same method symbol and the change creates an immediate code-driven prompt - after changing the parameter name in the method signature, the call site must be updated to match. This is a classic signature-caller relationship for the same function."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitutions changing 'stream_map' to 'stream_id_map' in the same file. Edit 0 changes a parameter name in a function call, and Edit 1 changes a variable assignment. Both are part of the same refactoring operation to rename the variable/parameter consistently throughout the codebase. This represents a bulk uniform substitution pattern where the same before\u2192after pattern is applied to the same type of syntactic construct (variable/parameter references). Either edit can be made first as both are valid independently, and making either one creates an immediate prompt to make the corresponding change in the other location to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform identical textual substitutions changing 'stream_map' to 'stream_id_map' in the same file. Edit 0 changes a parameter name in a function call, and Edit 1 changes a variable assignment. Both are part of the same refactoring operation to rename the variable/parameter consistently throughout the codebase. This represents a bulk uniform substitution pattern where the same before\u2192after pattern is applied to the same type of syntactic construct (variable/parameter references). Either edit can be made first as both are valid independently, and making either one creates an immediate prompt to make the corresponding change in the other location to maintain consistency."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same parameter symbol within the same function. Edit 0 renames the parameter 'stream_map' to 'stream_id_map' in the function signature, and Edit 1 updates the usage of that same parameter in the function body from 'stream_map' to 'stream_id_map'. This is a classic parameter rename scenario where the changed lines in both edits reference the exact same symbol - the parameter being renamed. After making either edit, the other becomes the immediate next step to maintain consistency, as having mismatched parameter name and usage would create a NameError at runtime. Both edits can be staged in either order since Python allows parameter names and their usage to be temporarily inconsistent at parse time."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same parameter symbol within the same function. Edit 0 renames the parameter 'stream_map' to 'stream_id_map' in the function signature, and Edit 1 updates the usage of that same parameter in the function body from 'stream_map' to 'stream_id_map'. This is a classic parameter rename scenario where the changed lines in both edits reference the exact same symbol - the parameter being renamed. After making either edit, the other becomes the immediate next step to maintain consistency, as having mismatched parameter name and usage would create a NameError at runtime. Both edits can be staged in either order since Python allows parameter names and their usage to be temporarily inconsistent at parse time."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "These edits are part of a bulk refactoring operation that renames the parameter 'stream_map' to 'stream_id_map' across multiple functions. Edit 0 changes the parameter name in the function signature of DigestTopic.teaser_data(), while Edit 1 updates the usage of that parameter within the build_message_list() function. However, these are different symbols in different scopes - the parameter in DigestTopic.teaser_data() is a different symbol from the parameter used in build_message_list(), even though they have the same name. The changed lines reference different symbols (same name, different function scopes), so this is a uniform substitution pattern but not a direct symbol dependency."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "These edits are part of a bulk refactoring operation that renames the parameter 'stream_map' to 'stream_id_map' across multiple functions. Edit 0 changes the parameter name in the function signature of DigestTopic.teaser_data(), while Edit 1 updates the usage of that parameter within the build_message_list() function. However, these are different symbols in different scopes - the parameter in DigestTopic.teaser_data() is a different symbol from the parameter used in build_message_list(), even though they have the same name. The changed lines reference different symbols (same name, different function scopes), so this is a uniform substitution pattern but not a direct symbol dependency."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "These edits represent a function signature change and its corresponding call-site update for the exact same function `build_message_list`. Edit 1 changes the parameter name from `stream_map` to `stream_id_map` in the function signature, while Edit 0 updates the call site to use the new parameter name. Both edits reference the exact same symbol (the parameter of `build_message_list`) and either edit creates an immediate, mechanically obvious prompt for the other - changing the signature makes the call site incorrect, and changing the call site without updating the signature would cause a TypeError. This is a classic definition-usage relationship where both edits can be staged in either order (both are syntactically valid) but either one immediately prompts the need for the other."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "These edits represent a function signature change and its corresponding call-site update for the exact same function `build_message_list`. Edit 1 changes the parameter name from `stream_map` to `stream_id_map` in the function signature, while Edit 0 updates the call site to use the new parameter name. Both edits reference the exact same symbol (the parameter of `build_message_list`) and either edit creates an immediate, mechanically obvious prompt for the other - changing the signature makes the call site incorrect, and changing the call site without updating the signature would cause a TypeError. This is a classic definition-usage relationship where both edits can be staged in either order (both are syntactically valid) but either one immediately prompts the need for the other."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits change the parameter name from 'stream_map' to 'stream_id_map' in calls to the same method 'teaser_data'. Edit 0 changes the parameter in the call to 'build_message_list' within the 'teaser_data' method, while Edit 1 changes the parameter in the call to 'teaser_data' itself. Both edits are part of a uniform parameter name refactoring pattern, changing the same parameter name in related function calls. This represents a synchronized substitution where both edits perform the identical textual substitution (stream_map \u2192 stream_id_map) and would naturally occur as part of the same contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits change the parameter name from 'stream_map' to 'stream_id_map' in calls to the same method 'teaser_data'. Edit 0 changes the parameter in the call to 'build_message_list' within the 'teaser_data' method, while Edit 1 changes the parameter in the call to 'teaser_data' itself. Both edits are part of a uniform parameter name refactoring pattern, changing the same parameter name in related function calls. This represents a synchronized substitution where both edits perform the identical textual substitution (stream_map \u2192 stream_id_map) and would naturally occur as part of the same contiguous refactoring task."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits change references to the exact same parameter from 'stream_map' to 'stream_id_map'. Edit 0 changes the parameter name in a function call to build_message_list, while Edit 1 changes the usage of that same parameter within the build_message_list function body. This creates a direct code dependency - after making either edit, the parameter names would be mismatched between the call site and the function body, making the other edit the immediate next mechanical step to maintain consistency. The changed lines in both edits reference the exact same symbol (the stream_map/stream_id_map parameter)."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits change references to the exact same parameter from 'stream_map' to 'stream_id_map'. Edit 0 changes the parameter name in a function call to build_message_list, while Edit 1 changes the usage of that same parameter within the build_message_list function body. This creates a direct code dependency - after making either edit, the parameter names would be mismatched between the call site and the function body, making the other edit the immediate next mechanical step to maintain consistency. The changed lines in both edits reference the exact same symbol (the stream_map/stream_id_map parameter)."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 changes a parameter name from 'stream_map' to 'stream_id_map' in a function call to build_message_list(). Edit 1 renames the function 'get_slim_stream_map' to 'get_slim_stream_id_map'. These edits are part of a uniform renaming pattern where 'stream_map' is being changed to 'stream_id_map' throughout the codebase. Both edits involve the same textual substitution pattern (stream_map \u2192 stream_id_map) and are clearly part of a single, contiguous refactoring operation. The changed lines in both edits reference the same naming concept and follow identical before\u2192after substitution patterns on similar syntactic constructs (parameter name and function name). Either edit could be made first as part of this bulk renaming operation."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 changes a parameter name from 'stream_map' to 'stream_id_map' in a function call to build_message_list(). Edit 1 renames the function 'get_slim_stream_map' to 'get_slim_stream_id_map'. These edits are part of a uniform renaming pattern where 'stream_map' is being changed to 'stream_id_map' throughout the codebase. Both edits involve the same textual substitution pattern (stream_map \u2192 stream_id_map) and are clearly part of a single, contiguous refactoring operation. The changed lines in both edits reference the same naming concept and follow identical before\u2192after substitution patterns on similar syntactic constructs (parameter name and function name). Either edit could be made first as part of this bulk renaming operation."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform identical textual substitution (changing 'stream_map' to 'stream_id_map') on the same type of syntactic construct (parameter names in function signatures). This appears to be part of a single, contiguous refactoring operation to rename a parameter across multiple functions. The edits involve the exact same before\u2192after pattern and target the same construct type, making this a bulk-edit synchronization pattern where either edit could be made first as part of the same refactoring sweep."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitution (changing 'stream_map' to 'stream_id_map') on the same type of syntactic construct (parameter names in function signatures). This appears to be part of a single, contiguous refactoring operation to rename a parameter across multiple functions. The edits involve the exact same before\u2192after pattern and target the same construct type, making this a bulk-edit synchronization pattern where either edit could be made first as part of the same refactoring sweep."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution, changing 'stream_map' to 'stream_id_map' in variable references. This appears to be part of a single, contiguous refactoring operation where a variable is being renamed consistently across the codebase. The edits target the same type of syntactic construct (variable references) and follow the same before\u2192after pattern, making them part of a bulk uniform substitution that would naturally occur in one uninterrupted micro-task."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution, changing 'stream_map' to 'stream_id_map' in variable references. This appears to be part of a single, contiguous refactoring operation where a variable is being renamed consistently across the codebase. The edits target the same type of syntactic construct (variable references) and follow the same before\u2192after pattern, making them part of a bulk uniform substitution that would naturally occur in one uninterrupted micro-task."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 renames the function from 'get_slim_stream_map' to 'get_slim_stream_id_map', and Edit 1 updates the call site to use the new function name 'get_slim_stream_id_map' and assigns it to a variable with the corresponding new name 'stream_id_map'. Both edits reference the exact same symbol (the function being renamed), creating an immediate code-driven dependency where after renaming the function definition, the call site must be updated to use the new name. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 renames the function from 'get_slim_stream_map' to 'get_slim_stream_id_map', and Edit 1 updates the call site to use the new function name 'get_slim_stream_id_map' and assigns it to a variable with the corresponding new name 'stream_id_map'. Both edits reference the exact same symbol (the function being renamed), creating an immediate code-driven dependency where after renaming the function definition, the call site must be updated to use the new name. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution, changing 'stream_map' to 'stream_id_map' in function calls. This represents a uniform variable renaming across multiple files as part of a single refactoring operation. The changed lines in both edits reference the exact same type of operation (accessing a dictionary with .get() method) and apply the identical before\u2192after pattern. This is a clear case of bulk-edit synchronization where either edit could be made first, and after making one, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution, changing 'stream_map' to 'stream_id_map' in function calls. This represents a uniform variable renaming across multiple files as part of a single refactoring operation. The changed lines in both edits reference the exact same type of operation (accessing a dictionary with .get() method) and apply the identical before\u2192after pattern. This is a clear case of bulk-edit synchronization where either edit could be made first, and after making one, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same variable symbol within the same function scope. Edit 0 renames the variable from 'stream_map' to 'stream_id_map' at its assignment/definition point, while Edit 1 updates the usage of that same variable in a function call. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain consistency - if only one edit is made, there would be a NameError at runtime due to the variable name mismatch. This is a classic definition-usage relationship for the same symbol within the same function."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same variable symbol within the same function scope. Edit 0 renames the variable from 'stream_map' to 'stream_id_map' at its assignment/definition point, while Edit 1 updates the usage of that same variable in a function call. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain consistency - if only one edit is made, there would be a NameError at runtime due to the variable name mismatch. This is a classic definition-usage relationship for the same symbol within the same function."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbol - the parameter 'stream_map' being renamed to 'stream_id_map'. Edit 0 changes the parameter name in the function signature, and Edit 1 updates the usage of that same parameter within the function body. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain consistency. The changed lines in both edits reference the same symbol, making this a classic definition-usage relationship within the same function scope."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol - the parameter 'stream_map' being renamed to 'stream_id_map'. Edit 0 changes the parameter name in the function signature, and Edit 1 updates the usage of that same parameter within the function body. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain consistency. The changed lines in both edits reference the same symbol, making this a classic definition-usage relationship within the same function scope."
        }
    ],
    "allowed_init_edits": [
        2
    ]
}