{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol `_debuggertestHelpSuffix` being replaced with `_tckHelpSuffix`. Edit 0 changes the epilog parameter in the ArgumentParser constructor from `_debuggertestHelpSuffix` to `_tckHelpSuffix`. Edit 1 changes the help suffix in the mx.update_commands call from `_debuggertestHelpSuffix` to `_tckHelpSuffix`. This is a uniform substitution pattern where both changed lines reference the same symbols and perform identical before\u2192after replacements. Both edits are part of a single refactoring operation to rename the help suffix variable, and either edit can be made first without causing parsing issues."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol `_debuggertestHelpSuffix` being replaced with `_tckHelpSuffix`. Edit 0 changes the epilog parameter in the ArgumentParser constructor from `_debuggertestHelpSuffix` to `_tckHelpSuffix`. Edit 1 changes the help suffix in the mx.update_commands call from `_debuggertestHelpSuffix` to `_tckHelpSuffix`. This is a uniform substitution pattern where both changed lines reference the same symbols and perform identical before\u2192after replacements. Both edits are part of a single refactoring operation to rename the help suffix variable, and either edit can be made first without causing parsing issues."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol `_debuggertestHelpSuffix` being renamed to `_tckHelpSuffix`. Edit 0 changes the variable definition/assignment, while Edit 1 changes the usage of that same variable. This creates a direct code dependency where both edits must reference the same symbol for the code to remain consistent. After making either edit, the other becomes the immediate next step to maintain code correctness. Both edits can be staged in either order without causing parse errors (Python allows referencing undefined variables at parse time), making this a bi-directional relationship."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol `_debuggertestHelpSuffix` being renamed to `_tckHelpSuffix`. Edit 0 changes the variable definition/assignment, while Edit 1 changes the usage of that same variable. This creates a direct code dependency where both edits must reference the same symbol for the code to remain consistent. After making either edit, the other becomes the immediate next step to maintain code correctness. Both edits can be staged in either order without causing parse errors (Python allows referencing undefined variables at parse time), making this a bi-directional relationship."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol `_tckHelpSuffix`. Edit 0 renames the variable from `_debuggertestHelpSuffix` to `_tckHelpSuffix`, and Edit 1 updates the usage of this variable in the ArgumentParser call to use the new name. The changed lines in both edits explicitly reference the same symbol, creating a direct code dependency where either edit naturally prompts the other as the next mechanical step. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol `_tckHelpSuffix`. Edit 0 renames the variable from `_debuggertestHelpSuffix` to `_tckHelpSuffix`, and Edit 1 updates the usage of this variable in the ArgumentParser call to use the new name. The changed lines in both edits explicitly reference the same symbol, creating a direct code dependency where either edit naturally prompts the other as the next mechanical step. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. Edit 0 changes '{default|debugger}' to '{compiler|debugger|default}' in a help text/documentation line, and Edit 1 makes the exact same substitution pattern in a command configuration string. Both are updating the same configuration option specification with the same before\u2192after pattern, representing a synchronized update to maintain consistency between documentation and command definition. This is a clear case of bulk-edit pattern synchronization where both edits reference the same configuration parameter and apply identical changes."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. Edit 0 changes '{default|debugger}' to '{compiler|debugger|default}' in a help text/documentation line, and Edit 1 makes the exact same substitution pattern in a command configuration string. Both are updating the same configuration option specification with the same before\u2192after pattern, representing a synchronized update to maintain consistency between documentation and command definition. This is a clear case of bulk-edit pattern synchronization where both edits reference the same configuration parameter and apply identical changes."
        }
    ],
    "allowed_init_edits": [
        3,
        5
    ]
}