{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits change the exact same import/function name from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement, while Edit 1 changes the function call. These reference the exact same symbol and create a direct code dependency - after making either edit, the other becomes immediately necessary to maintain consistency. The import change and usage change are mechanically linked and would naturally occur in the same contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits change the exact same import/function name from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement, while Edit 1 changes the function call. These reference the exact same symbol and create a direct code dependency - after making either edit, the other becomes immediately necessary to maintain consistency. The import change and usage change are mechanically linked and would naturally occur in the same contiguous refactoring task."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "These edits show a function rename from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the function definition, and Edit 1 updates the call site to use the new function name. Both edits reference the exact same symbol - the function being renamed. This creates an immediate code dependency where after renaming the function definition, the call site must be updated to use the new name, or vice versa. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "These edits show a function rename from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the function definition, and Edit 1 updates the call site to use the new function name. Both edits reference the exact same symbol - the function being renamed. This creates an immediate code dependency where after renaming the function definition, the call site must be updated to use the new name, or vice versa. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol: they change the function name from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement to import the new function name, while Edit 1 changes the function call to use the new function name. This is a classic definition-usage pattern where both edits reference the same symbol. After making either edit, the other becomes the immediate next step to maintain code consistency. Since Python allows both imports and function calls to be written in either order (the call would only fail at runtime if the import is missing), this is bi-directional rather than ordered."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol: they change the function name from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement to import the new function name, while Edit 1 changes the function call to use the new function name. This is a classic definition-usage pattern where both edits reference the same symbol. After making either edit, the other becomes the immediate next step to maintain code consistency. Since Python allows both imports and function calls to be written in either order (the call would only fail at runtime if the import is missing), this is bi-directional rather than ordered."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits change the exact same symbol reference from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement, while Edit 1 changes the function call site. These edits reference the exact same symbol and create a direct code dependency - after making either edit, the other becomes the immediate next step to maintain code consistency. The import and usage are in the same file, and both can be staged in either order without causing parse errors (Python allows undefined symbol references at parse time)."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits change the exact same symbol reference from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement, while Edit 1 changes the function call site. These edits reference the exact same symbol and create a direct code dependency - after making either edit, the other becomes the immediate next step to maintain code consistency. The import and usage are in the same file, and both can be staged in either order without causing parse errors (Python allows undefined symbol references at parse time)."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 renames the function from 'get_user_status_dict' to 'get_all_users_status_dict' in the definition. Edit 1 updates the import statement to use the new function name 'get_all_users_status_dict'. Both edits reference the exact same symbol - the function being renamed. After making either edit, the other becomes immediately necessary to maintain code consistency, as the import and definition must match. This is a classic definition-usage relationship where both edits can be staged in either order (Python allows importing non-existent names, causing only runtime errors), making it bi-directional."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 renames the function from 'get_user_status_dict' to 'get_all_users_status_dict' in the definition. Edit 1 updates the import statement to use the new function name 'get_all_users_status_dict'. Both edits reference the exact same symbol - the function being renamed. After making either edit, the other becomes immediately necessary to maintain code consistency, as the import and definition must match. This is a classic definition-usage relationship where both edits can be staged in either order (Python allows importing non-existent names, causing only runtime errors), making it bi-directional."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits change the exact same function call from 'get_user_status_dict' to 'get_all_users_status_dict' with identical parameters (realm=realm, user_profile=user_profile/hamlet). This is a uniform textual substitution pattern where the same symbol is being renamed across multiple files. Both edits reference the exact same function symbol and perform identical before\u2192after transformations. Either edit can be made first, and after making one, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits change the exact same function call from 'get_user_status_dict' to 'get_all_users_status_dict' with identical parameters (realm=realm, user_profile=user_profile/hamlet). This is a uniform textual substitution pattern where the same symbol is being renamed across multiple files. Both edits reference the exact same function symbol and perform identical before\u2192after transformations. Either edit can be made first, and after making one, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "These edits involve renaming the exact same function symbol from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement to reference the new function name, while Edit 1 changes the actual function definition. Both edits reference the exact same symbol and create an immediate code dependency - after renaming either the import or the definition, the other edit becomes the mechanically obvious next step to maintain code consistency. This is a classic definition-usage relationship where both edits can be staged in either order (the import of a renamed function won't cause a parser error, only a runtime ImportError), making it bi-directional."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "These edits involve renaming the exact same function symbol from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement to reference the new function name, while Edit 1 changes the actual function definition. Both edits reference the exact same symbol and create an immediate code dependency - after renaming either the import or the definition, the other edit becomes the mechanically obvious next step to maintain code consistency. This is a classic definition-usage relationship where both edits can be staged in either order (the import of a renamed function won't cause a parser error, only a runtime ImportError), making it bi-directional."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "These edits show a function rename from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 1 changes the function definition, while Edit 0 changes the call site to use the new function name. Both edits reference the exact same symbol - the function being renamed. This creates an immediate, mechanically obvious code dependency: after renaming the function definition, the call site must be updated to use the new name, and vice versa. Either edit can be made first since Python allows referencing undefined functions at parse time (they only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "These edits show a function rename from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 1 changes the function definition, while Edit 0 changes the call site to use the new function name. Both edits reference the exact same symbol - the function being renamed. This creates an immediate, mechanically obvious code dependency: after renaming the function definition, the call site must be updated to use the new name, and vice versa. Either edit can be made first since Python allows referencing undefined functions at parse time (they only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol - they are changing the function name from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement to import the new function name, while Edit 1 changes the usage/call site to use the new function name. This creates a direct code dependency where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step. In Python, both edits can be staged in either order without causing parse errors (the usage before import would only cause a runtime NameError), making this bi-directional."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol - they are changing the function name from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement to import the new function name, while Edit 1 changes the usage/call site to use the new function name. This creates a direct code dependency where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step. In Python, both edits can be staged in either order without causing parse errors (the usage before import would only cause a runtime NameError), making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 renames the function from `get_user_status_dict` to `get_all_users_status_dict` in the function definition. Edit 1 updates the call site to use the new function name `get_all_users_status_dict`. Both edits reference the exact same symbol (the function name), and after renaming the function in edit 0, the call site in edit 1 becomes immediately necessary to fix the undefined reference. This is a classic definition-usage relationship where both edits can be staged in either order (the old call would result in a runtime NameError, not a parse error), making it bi-directional."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 renames the function from `get_user_status_dict` to `get_all_users_status_dict` in the function definition. Edit 1 updates the call site to use the new function name `get_all_users_status_dict`. Both edits reference the exact same symbol (the function name), and after renaming the function in edit 0, the call site in edit 1 becomes immediately necessary to fix the undefined reference. This is a classic definition-usage relationship where both edits can be staged in either order (the old call would result in a runtime NameError, not a parse error), making it bi-directional."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits change the exact same function call from 'get_user_status_dict' to 'get_all_users_status_dict' within the same file. This represents a bulk uniform substitution where both changed lines reference the exact same symbol (the function being called) and perform identical textual substitution (same before\u2192after pattern). The edits are part of a single refactoring operation to rename/replace function calls, making either edit naturally prompt the other as part of the same contiguous micro-task. Both edits can be staged in either order without causing parser errors."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits change the exact same function call from 'get_user_status_dict' to 'get_all_users_status_dict' within the same file. This represents a bulk uniform substitution where both changed lines reference the exact same symbol (the function being called) and perform identical textual substitution (same before\u2192after pattern). The edits are part of a single refactoring operation to rename/replace function calls, making either edit naturally prompt the other as part of the same contiguous micro-task. Both edits can be staged in either order without causing parser errors."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution, changing 'get_user_status_dict' to 'get_all_users_status_dict' in function calls with the same parameter pattern (realm, user_profile/acting_user). This is a bulk refactoring operation where the same function name is being updated across multiple call sites. The changed lines reference the exact same symbol being renamed, making this a synchronized pattern substitution that would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution, changing 'get_user_status_dict' to 'get_all_users_status_dict' in function calls with the same parameter pattern (realm, user_profile/acting_user). This is a bulk refactoring operation where the same function name is being updated across multiple call sites. The changed lines reference the exact same symbol being renamed, making this a synchronized pattern substitution that would naturally occur as part of a single, contiguous refactoring task."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution, changing 'get_user_status_dict' to 'get_all_users_status_dict' in import statements. This is a bulk refactoring operation where the same symbol is being renamed across multiple files. The changed lines in both edits reference the exact same symbol (the function being imported), and this appears to be part of a single, contiguous refactor to rename this function. Either edit can be staged first, and after making either edit, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution, changing 'get_user_status_dict' to 'get_all_users_status_dict' in import statements. This is a bulk refactoring operation where the same symbol is being renamed across multiple files. The changed lines in both edits reference the exact same symbol (the function being imported), and this appears to be part of a single, contiguous refactor to rename this function. Either edit can be staged first, and after making either edit, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits change references to the exact same function symbol from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes a function call in zerver/lib/events.py, while edit 1 updates the import statement in zerver/tests/test_user_status.py. This appears to be a function rename refactoring where the same symbol is being updated across multiple files. Both edits reference the exact same symbol and would naturally occur together as part of a single refactoring operation. Either edit could be made first since both files can be parsed independently, but after making either edit, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits change references to the exact same function symbol from 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes a function call in zerver/lib/events.py, while edit 1 updates the import statement in zerver/tests/test_user_status.py. This appears to be a function rename refactoring where the same symbol is being updated across multiple files. Both edits reference the exact same symbol and would naturally occur together as part of a single refactoring operation. Either edit could be made first since both files can be parsed independently, but after making either edit, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits change references to the exact same symbol 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement and Edit 1 changes the usage of that function. This is a classic import-usage relationship where both edits reference the same fully qualified symbol. In Python, either edit can be staged first - if the import is changed first, the usage will reference the new function name; if the usage is changed first, it will create a NameError at runtime but can still be parsed and staged. After making either edit, the other becomes the immediate next mechanical step to maintain code consistency."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits change references to the exact same symbol 'get_user_status_dict' to 'get_all_users_status_dict'. Edit 0 changes the import statement and Edit 1 changes the usage of that function. This is a classic import-usage relationship where both edits reference the same fully qualified symbol. In Python, either edit can be staged first - if the import is changed first, the usage will reference the new function name; if the usage is changed first, it will create a NameError at runtime but can still be parsed and staged. After making either edit, the other becomes the immediate next mechanical step to maintain code consistency."
        }
    ],
    "allowed_init_edits": [
        0,
        4,
        2,
        5,
        1,
        3
    ]
}