{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 changes the docstring return type description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 adds a test assertion 'self.assertIsInstance(total_loss, tf.Tensor)' that directly validates the return type change described in the docstring. Both edits reference the exact same method's behavior - the return type of LossesContainer.__call__ - where the documentation change in edit 0 directly corresponds to the test validation added in edit 1. This creates a bi-directional relationship where either edit naturally prompts the other as the next step in ensuring the method's return type is properly documented and tested."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 changes the docstring return type description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 adds a test assertion 'self.assertIsInstance(total_loss, tf.Tensor)' that directly validates the return type change described in the docstring. Both edits reference the exact same method's behavior - the return type of LossesContainer.__call__ - where the documentation change in edit 0 directly corresponds to the test validation added in edit 1. This creates a bi-directional relationship where either edit naturally prompts the other as the next step in ensuring the method's return type is properly documented and tested."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits add identical assertion lines `self.assertIsInstance(total_loss, tf.Tensor)` in different test methods within the same test class. This represents a bulk-edit pattern where the same structural substitution (adding the same type assertion) is being applied to multiple test methods that follow the same pattern. Both edits target the same type of syntactic construct (test assertions) and perform an identical before\u2192after pattern (adding the same assertion line). This appears to be part of a single, contiguous refactor to add type checking assertions across multiple test methods."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits add identical assertion lines `self.assertIsInstance(total_loss, tf.Tensor)` in different test methods within the same test class. This represents a bulk-edit pattern where the same structural substitution (adding the same type assertion) is being applied to multiple test methods that follow the same pattern. Both edits target the same type of syntactic construct (test assertions) and perform an identical before\u2192after pattern (adding the same assertion line). This appears to be part of a single, contiguous refactor to add type checking assertions across multiple test methods."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Edit 0 changes the docstring return description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 updates a test to capture the return value as 'total_loss = loss_container(y_t, y_p)' instead of just calling 'loss_container(y_t, y_p)'. Both edits reference the exact same method (LossesContainer.__call__) - edit 0 modifies its documentation and edit 1 updates test code that calls this method. The documentation change describes the actual return behavior, and the test change captures that return value, creating a direct linkage where both edits involve the same symbol and the test update reflects the documented behavior change."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Edit 0 changes the docstring return description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 updates a test to capture the return value as 'total_loss = loss_container(y_t, y_p)' instead of just calling 'loss_container(y_t, y_p)'. Both edits reference the exact same method (LossesContainer.__call__) - edit 0 modifies its documentation and edit 1 updates test code that calls this method. The documentation change describes the actual return behavior, and the test change captures that return value, creating a direct linkage where both edits involve the same symbol and the test update reflects the documented behavior change."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits add identical assertion lines `self.assertIsInstance(total_loss, tf.Tensor)` in different test methods within the same test class. They follow the same pattern of adding the same type check assertion after checking the length of losses and before checking the numerical value. This represents a synchronized pattern addition where the same assertion is being added to multiple test methods that test similar functionality (loss container behavior). The edits reference the same variable name `total_loss` and add identical assertion logic, making this a mirrored structural substitution within the same testing context."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits add identical assertion lines `self.assertIsInstance(total_loss, tf.Tensor)` in different test methods within the same test class. They follow the same pattern of adding the same type check assertion after checking the length of losses and before checking the numerical value. This represents a synchronized pattern addition where the same assertion is being added to multiple test methods that test similar functionality (loss container behavior). The edits reference the same variable name `total_loss` and add identical assertion logic, making this a mirrored structural substitution within the same testing context."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 changes the docstring return description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 adds a test assertion 'self.assertIsInstance(total_loss, tf.Tensor)' that directly validates the return type described in the updated docstring. Both edits reference the exact same method (LossesContainer.__call__) and the test assertion directly corresponds to the documentation change - the test verifies that total_loss is indeed a tf.Tensor as now documented. This is a clear case of test-production code synchronization where the test assertion validates the exact behavior described in the updated documentation."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 changes the docstring return description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 adds a test assertion 'self.assertIsInstance(total_loss, tf.Tensor)' that directly validates the return type described in the updated docstring. Both edits reference the exact same method (LossesContainer.__call__) and the test assertion directly corresponds to the documentation change - the test verifies that total_loss is indeed a tf.Tensor as now documented. This is a clear case of test-production code synchronization where the test assertion validates the exact behavior described in the updated documentation."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 changes the docstring return description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 adds a test assertion 'self.assertIsInstance(total_loss, tf.Tensor)' that directly validates the return type described in the updated docstring. Both edits reference the exact same method (LossesContainer.__call__) and the test assertion directly corresponds to the documented behavior change. The test validates that total_loss is indeed a tf.Tensor, which aligns with the updated documentation. This represents test-production code synchronization where the documentation change and test assertion both relate to the same method's return type specification."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 changes the docstring return description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 adds a test assertion 'self.assertIsInstance(total_loss, tf.Tensor)' that directly validates the return type described in the updated docstring. Both edits reference the exact same method (LossesContainer.__call__) and the test assertion directly corresponds to the documented behavior change. The test validates that total_loss is indeed a tf.Tensor, which aligns with the updated documentation. This represents test-production code synchronization where the documentation change and test assertion both relate to the same method's return type specification."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 changes the docstring return description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 adds a test assertion 'self.assertIsInstance(total_loss, tf.Tensor)' in the test for this same method. Both edits reference the exact same symbol (the total_loss return value from LossesContainer.__call__) and the test assertion directly validates the updated return type specification from the docstring change. The docstring change specifies that total_loss should be a tf.Tensor, and the test change adds an assertion to verify this exact behavior. This creates a direct code linkage where both edits reference the same symbol and the test change validates the specification change."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 changes the docstring return description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 adds a test assertion 'self.assertIsInstance(total_loss, tf.Tensor)' in the test for this same method. Both edits reference the exact same symbol (the total_loss return value from LossesContainer.__call__) and the test assertion directly validates the updated return type specification from the docstring change. The docstring change specifies that total_loss should be a tf.Tensor, and the test change adds an assertion to verify this exact behavior. This creates a direct code linkage where both edits reference the same symbol and the test change validates the specification change."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 changes the docstring return type description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 adds a test assertion 'self.assertIsInstance(total_loss, tf.Tensor)' which directly validates the new return type specification. Both edits reference the exact same concept - the return type of the LossesContainer.__call__ method's total_loss value. The documentation change in edit 0 specifies that total_loss should be a tf.Tensor, and edit 1 adds a test assertion to verify this exact specification. This creates a direct code-driven linkage where the documentation change naturally prompts the corresponding test update to validate the documented behavior."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 changes the docstring return type description for the LossesContainer.__call__ method from 'Tuple of (total_loss, per_output_loss_list)' to 'The total loss as a tf.Tensor, or None if no loss results.' Edit 1 adds a test assertion 'self.assertIsInstance(total_loss, tf.Tensor)' which directly validates the new return type specification. Both edits reference the exact same concept - the return type of the LossesContainer.__call__ method's total_loss value. The documentation change in edit 0 specifies that total_loss should be a tf.Tensor, and edit 1 adds a test assertion to verify this exact specification. This creates a direct code-driven linkage where the documentation change naturally prompts the corresponding test update to validate the documented behavior."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits add identical assertion lines `self.assertIsInstance(total_loss, tf.Tensor)` in different test methods within the same test class. This represents a bulk-edit pattern where the same structural change (adding the same type assertion for the `total_loss` variable) is being applied to multiple test methods. Both edits target the same type of syntactic construct (test assertions) and perform an identical addition pattern. This appears to be part of a single, contiguous refactor to add type checking assertions across multiple test methods that verify `total_loss` behavior."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits add identical assertion lines `self.assertIsInstance(total_loss, tf.Tensor)` in different test methods within the same test class. This represents a bulk-edit pattern where the same structural change (adding the same type assertion for the `total_loss` variable) is being applied to multiple test methods. Both edits target the same type of syntactic construct (test assertions) and perform an identical addition pattern. This appears to be part of a single, contiguous refactor to add type checking assertions across multiple test methods that verify `total_loss` behavior."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 assigns the result of loss_container(y_t, y_p) to a new variable 'total_loss', and Edit 1 immediately uses that exact same 'total_loss' variable in an assertion. The changed lines reference the exact same symbol - the 'total_loss' variable. After making Edit 0, the natural next step would be to use the newly captured return value, which is exactly what Edit 1 does. This creates an immediate, mechanically obvious code-driven prompt where either edit can be made first (both are syntactically valid), but they form a natural pair within the same test method."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 assigns the result of loss_container(y_t, y_p) to a new variable 'total_loss', and Edit 1 immediately uses that exact same 'total_loss' variable in an assertion. The changed lines reference the exact same symbol - the 'total_loss' variable. After making Edit 0, the natural next step would be to use the newly captured return value, which is exactly what Edit 1 does. This creates an immediate, mechanically obvious code-driven prompt where either edit can be made first (both are syntactically valid), but they form a natural pair within the same test method."
        }
    ],
    "allowed_init_edits": [
        4,
        5,
        7
    ]
}