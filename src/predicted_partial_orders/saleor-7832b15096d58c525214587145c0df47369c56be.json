{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitution (logger.warning \u2192 logger.info) on the same type of syntactic construct (logger method calls) within the same file. This appears to be part of a single, contiguous refactoring operation to change the logging level for certain webhook-related messages. The edits follow the bulk-edit pattern where the same before\u2192after transformation is applied to multiple locations of the same construct type."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform identical textual substitution (logger.warning \u2192 logger.info) on the same type of syntactic construct (logger method calls) within the same file. This appears to be part of a single, contiguous refactoring operation to change the logging level for certain webhook-related messages. The edits follow the bulk-edit pattern where the same before\u2192after transformation is applied to multiple locations of the same construct type."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (changing 'logger.warning' to 'logger.info') on the same type of syntactic construct (logger method calls). This appears to be part of a single, contiguous refactor to change the logging level from warning to info across multiple locations in the same file. The edits follow the bulk-edit pattern where both perform the same before\u2192after pattern substitution on the same construct type, making either edit naturally prompt the other as part of the same mechanical refactoring task."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution (changing 'logger.warning' to 'logger.info') on the same type of syntactic construct (logger method calls). This appears to be part of a single, contiguous refactor to change the logging level from warning to info across multiple locations in the same file. The edits follow the bulk-edit pattern where both perform the same before\u2192after pattern substitution on the same construct type, making either edit naturally prompt the other as part of the same mechanical refactoring task."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'warning' to 'info' in logger method calls) and target the same type of syntactic construct (logger method calls). Both are part of what appears to be a single, contiguous refactor to change the log level for webhook failure messages from warning to info across the codebase. This represents a bulk-edit pattern synchronization where the same before\u2192after pattern is applied to the same construct type."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'warning' to 'info' in logger method calls) and target the same type of syntactic construct (logger method calls). Both are part of what appears to be a single, contiguous refactor to change the log level for webhook failure messages from warning to info across the codebase. This represents a bulk-edit pattern synchronization where the same before\u2192after pattern is applied to the same construct type."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution (changing 'logger.warning' to 'logger.info') on the same type of syntactic construct (logger method calls) within the same function. This represents a bulk-edit pattern where the same refactoring operation is being applied consistently across multiple locations. The edits are part of a single, contiguous refactor to change the logging level from warning to info for webhook-related messages. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the logging approach."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution (changing 'logger.warning' to 'logger.info') on the same type of syntactic construct (logger method calls) within the same function. This represents a bulk-edit pattern where the same refactoring operation is being applied consistently across multiple locations. The edits are part of a single, contiguous refactor to change the logging level from warning to info for webhook-related messages. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the logging approach."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (changing 'logger.warning' to 'logger.info') on the same type of syntactic construct (logger method calls) within the same file. This appears to be part of a single, contiguous refactor to change the logging level for webhook-related messages from warning to info. The edits represent a uniform pattern substitution that would naturally occur together in one micro-task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution (changing 'logger.warning' to 'logger.info') on the same type of syntactic construct (logger method calls) within the same file. This appears to be part of a single, contiguous refactor to change the logging level for webhook-related messages from warning to info. The edits represent a uniform pattern substitution that would naturally occur together in one micro-task."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'logger.warning(' to 'logger.info(') on the same type of syntactic construct (logger method calls). This appears to be part of a single, contiguous refactor to change the log level from warning to info for webhook-related error messages. The edits target structurally identical constructs and follow the same before\u2192after pattern, making them part of a bulk substitution operation where either edit could be made first and would naturally prompt the other as part of the same refactoring task."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'logger.warning(' to 'logger.info(') on the same type of syntactic construct (logger method calls). This appears to be part of a single, contiguous refactor to change the log level from warning to info for webhook-related error messages. The edits target structurally identical constructs and follow the same before\u2192after pattern, making them part of a bulk substitution operation where either edit could be made first and would naturally prompt the other as part of the same refactoring task."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits change the same logging method call from 'warning' to 'info'. Edit 0 changes the actual logging call in the production code from task_logger.warning to task_logger.info. Edit 1 changes the corresponding test mock from patching logger.warning to patching logger.info. These edits reference the exact same symbol change (the logging method) and form a synchronized test-production code pair where the test mock must match the production implementation. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain test-code synchronization."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits change the same logging method call from 'warning' to 'info'. Edit 0 changes the actual logging call in the production code from task_logger.warning to task_logger.info. Edit 1 changes the corresponding test mock from patching logger.warning to patching logger.info. These edits reference the exact same symbol change (the logging method) and form a synchronized test-production code pair where the test mock must match the production implementation. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain test-code synchronization."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 changes a logger.warning call to logger.info in the production code. Edit 1 changes a test mock from patching logger.warning to logger.info. Both edits reference the exact same logger method being changed - they are synchronizing the test mock with the production code change. The test mock needs to be updated to match the new logging level used in the production code, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 changes a logger.warning call to logger.info in the production code. Edit 1 changes a test mock from patching logger.warning to logger.info. Both edits reference the exact same logger method being changed - they are synchronizing the test mock with the production code change. The test mock needs to be updated to match the new logging level used in the production code, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 changes a logger.warning call to logger.info in the production code, while Edit 1 changes a test mock from patching logger.warning to logger.info. Both edits reference the exact same logger method being changed - they are synchronizing the test mock to match the production code change. The test is directly mocking the same logger call that was modified in the production code, creating an immediate code-driven dependency where changing the production logging level requires updating the corresponding test mock."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 changes a logger.warning call to logger.info in the production code, while Edit 1 changes a test mock from patching logger.warning to logger.info. Both edits reference the exact same logger method being changed - they are synchronizing the test mock to match the production code change. The test is directly mocking the same logger call that was modified in the production code, creating an immediate code-driven dependency where changing the production logging level requires updating the corresponding test mock."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits reference the exact same logger object and change the same method call from 'warning' to 'info'. Edit 0 changes the actual logger.warning() call to logger.info() in the production code, while Edit 1 updates the corresponding test mock from patching logger.warning to patching logger.info. These edits reference the same symbol (the logger's warning/info method) and form a direct definition-usage relationship where the test must be updated to match the production code change. Either edit can be made first since both are syntactically valid, but making either edit creates an immediate prompt for the other to maintain test-code synchronization."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits reference the exact same logger object and change the same method call from 'warning' to 'info'. Edit 0 changes the actual logger.warning() call to logger.info() in the production code, while Edit 1 updates the corresponding test mock from patching logger.warning to patching logger.info. These edits reference the same symbol (the logger's warning/info method) and form a direct definition-usage relationship where the test must be updated to match the production code change. Either edit can be made first since both are syntactically valid, but making either edit creates an immediate prompt for the other to maintain test-code synchronization."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (changing 'logger.warning' to 'logger.info') on the same type of syntactic construct (logger method calls) within the same file. This represents a bulk refactoring operation where the same pattern is being applied consistently across multiple locations. The edits are part of a single, contiguous micro-task to change the logging level from warning to info for webhook-related messages. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the logging approach."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution (changing 'logger.warning' to 'logger.info') on the same type of syntactic construct (logger method calls) within the same file. This represents a bulk refactoring operation where the same pattern is being applied consistently across multiple locations. The edits are part of a single, contiguous micro-task to change the logging level from warning to info for webhook-related messages. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the logging approach."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 changes a logger.warning call to logger.info in the production code, while Edit 1 changes a test mock from patching logger.warning to logger.info. Both edits reference the exact same logger method being changed - they are synchronizing the test mock to match the production code change. The test is mocking the same logger method that was modified in the production code, creating a direct code dependency where the test needs to be updated to match the production change."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 changes a logger.warning call to logger.info in the production code, while Edit 1 changes a test mock from patching logger.warning to logger.info. Both edits reference the exact same logger method being changed - they are synchronizing the test mock to match the production code change. The test is mocking the same logger method that was modified in the production code, creating a direct code dependency where the test needs to be updated to match the production change."
        }
    ],
    "allowed_init_edits": [
        0,
        1
    ]
}