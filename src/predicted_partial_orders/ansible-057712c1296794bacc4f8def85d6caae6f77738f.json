{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'action_loader' to 'self._shared_loader_obj.action_loader'. This is a uniform refactoring operation where the same symbol reference is being updated in the same way across multiple locations within the same class. Both changed lines reference the exact same symbol (action_loader) and apply the same transformation pattern. This represents a single, contiguous refactoring task where both changes would naturally be made together as part of the same micro-task."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'action_loader' to 'self._shared_loader_obj.action_loader'. This is a uniform refactoring operation where the same symbol reference is being updated in the same way across multiple locations within the same class. Both changed lines reference the exact same symbol (action_loader) and apply the same transformation pattern. This represents a single, contiguous refactoring task where both changes would naturally be made together as part of the same micro-task."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 removes 'action_loader' from the import statement, while Edit 1 changes the usage of 'action_loader' to 'self._shared_loader_obj.action_loader'. Both edits reference the exact same symbol 'action_loader' - one removes its import and the other changes how it's accessed. This creates a direct code dependency where removing the import (Edit 0) makes the old usage pattern (Edit 1's before state) invalid, requiring the usage to be updated to the new pattern. The edits are part of a single refactoring task to change how action_loader is accessed."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 removes 'action_loader' from the import statement, while Edit 1 changes the usage of 'action_loader' to 'self._shared_loader_obj.action_loader'. Both edits reference the exact same symbol 'action_loader' - one removes its import and the other changes how it's accessed. This creates a direct code dependency where removing the import (Edit 0) makes the old usage pattern (Edit 1's before state) invalid, requiring the usage to be updated to the new pattern. The edits are part of a single refactoring task to change how action_loader is accessed."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical structural substitution pattern: changing direct loader access (e.g., 'action_loader.get' and 'connection_loader.get') to access through the shared loader object (e.g., 'self._shared_loader_obj.action_loader.get' and 'self._shared_loader_obj.connection_loader.get'). This represents a uniform refactoring pattern applied to the same type of syntactic construct (loader access calls) within the same class. Both edits are part of a single, contiguous refactor to standardize loader access through the shared loader object. Either edit can be made first, and both follow the exact same before\u2192after transformation pattern."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical structural substitution pattern: changing direct loader access (e.g., 'action_loader.get' and 'connection_loader.get') to access through the shared loader object (e.g., 'self._shared_loader_obj.action_loader.get' and 'self._shared_loader_obj.connection_loader.get'). This represents a uniform refactoring pattern applied to the same type of syntactic construct (loader access calls) within the same class. Both edits are part of a single, contiguous refactor to standardize loader access through the shared loader object. Either edit can be made first, and both follow the exact same before\u2192after transformation pattern."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 removes 'action_loader' from the import statement, while Edit 1 changes a usage of 'action_loader' to 'self._shared_loader_obj.action_loader'. These edits reference the exact same symbol 'action_loader' - one removes its import and the other changes how it's accessed. The removal of the import must happen before or simultaneously with changing the usage, as the usage edit replaces the direct reference with an attribute access. Since both edits can be staged in either order (the usage change doesn't depend on the import removal being completed first), this is bi-directional - either edit naturally prompts the other as the next mechanical step in refactoring how action_loader is accessed."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 removes 'action_loader' from the import statement, while Edit 1 changes a usage of 'action_loader' to 'self._shared_loader_obj.action_loader'. These edits reference the exact same symbol 'action_loader' - one removes its import and the other changes how it's accessed. The removal of the import must happen before or simultaneously with changing the usage, as the usage edit replaces the direct reference with an attribute access. Since both edits can be staged in either order (the usage change doesn't depend on the import removal being completed first), this is bi-directional - either edit naturally prompts the other as the next mechanical step in refactoring how action_loader is accessed."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 removes 'action_loader' from the import statement, while Edit 1 changes the usage of 'action_loader' to 'self._shared_loader_obj.action_loader'. These edits reference the exact same symbol 'action_loader' - one removes its import and the other changes how it's accessed. This creates a direct code dependency where removing the import (Edit 0) makes the old usage pattern (Edit 1's before state) invalid, requiring the usage to be updated to the new pattern. Both edits are part of refactoring how action_loader is accessed, moving from a direct import to accessing it through a shared loader object. Either edit can be made first and would prompt the other as the immediate next step."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 removes 'action_loader' from the import statement, while Edit 1 changes the usage of 'action_loader' to 'self._shared_loader_obj.action_loader'. These edits reference the exact same symbol 'action_loader' - one removes its import and the other changes how it's accessed. This creates a direct code dependency where removing the import (Edit 0) makes the old usage pattern (Edit 1's before state) invalid, requiring the usage to be updated to the new pattern. Both edits are part of refactoring how action_loader is accessed, moving from a direct import to accessing it through a shared loader object. Either edit can be made first and would prompt the other as the immediate next step."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 removes the import of 'connection_loader' from the imports section, while Edit 1 changes the usage of 'connection_loader' from the imported symbol to accessing it via 'self._shared_loader_obj.connection_loader'. Both edits reference the exact same symbol 'connection_loader'. After removing the import in Edit 0, the usage in Edit 1 becomes necessary to avoid a NameError. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime), both edits can be staged in either order without causing parser errors. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step - removing the import creates an immediate need to update the usage, and changing the usage creates an immediate opportunity to remove the now-unused import."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 removes the import of 'connection_loader' from the imports section, while Edit 1 changes the usage of 'connection_loader' from the imported symbol to accessing it via 'self._shared_loader_obj.connection_loader'. Both edits reference the exact same symbol 'connection_loader'. After removing the import in Edit 0, the usage in Edit 1 becomes necessary to avoid a NameError. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime), both edits can be staged in either order without causing parser errors. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step - removing the import creates an immediate need to update the usage, and changing the usage creates an immediate opportunity to remove the now-unused import."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'action_loader.get(' to 'self._shared_loader_obj.action_loader.get(' in the same file. This is a uniform refactoring operation where the same symbol reference (action_loader) is being replaced with the same new reference pattern (self._shared_loader_obj.action_loader) across multiple locations. Both changed lines reference the exact same symbol being modified and represent the same type of syntactic construct (method calls). This fits the bulk-edit pattern synchronization criteria where both edits are part of a single, contiguous refactor with identical before\u2192after patterns."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'action_loader.get(' to 'self._shared_loader_obj.action_loader.get(' in the same file. This is a uniform refactoring operation where the same symbol reference (action_loader) is being replaced with the same new reference pattern (self._shared_loader_obj.action_loader) across multiple locations. Both changed lines reference the exact same symbol being modified and represent the same type of syntactic construct (method calls). This fits the bulk-edit pattern synchronization criteria where both edits are part of a single, contiguous refactor with identical before\u2192after patterns."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical structural substitution pattern: changing bare loader references (connection_loader, action_loader) to use the same qualified path (self._shared_loader_obj.connection_loader, self._shared_loader_obj.action_loader). This represents a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (loader.get() calls) within the same class. Both edits are part of a single, contiguous refactor to consistently access loaders through the shared loader object rather than using bare references."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical structural substitution pattern: changing bare loader references (connection_loader, action_loader) to use the same qualified path (self._shared_loader_obj.connection_loader, self._shared_loader_obj.action_loader). This represents a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (loader.get() calls) within the same class. Both edits are part of a single, contiguous refactor to consistently access loaders through the shared loader object rather than using bare references."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical structural substitution pattern: changing direct access to loader objects (connection_loader, action_loader) to access through self._shared_loader_obj. This is a uniform refactoring pattern applied to the same type of syntactic construct (loader object access) within the same class. The edits are part of a single, contiguous refactor to centralize loader access through a shared loader object. Either edit can be made first, and both follow the exact same before\u2192after transformation pattern."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical structural substitution pattern: changing direct access to loader objects (connection_loader, action_loader) to access through self._shared_loader_obj. This is a uniform refactoring pattern applied to the same type of syntactic construct (loader object access) within the same class. The edits are part of a single, contiguous refactor to centralize loader access through a shared loader object. Either edit can be made first, and both follow the exact same before\u2192after transformation pattern."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 1 adds the action_loader attribute to the SharedPluginLoaderObj class, and Edit 0 changes code to reference self._shared_loader_obj.action_loader instead of the global action_loader. The changed line in Edit 0 directly references the exact same symbol (action_loader) that is being added as an attribute in Edit 1. This creates a direct code dependency where Edit 1 must occur before Edit 0, as Edit 0 would fail with an AttributeError if the action_loader attribute doesn't exist on the shared loader object."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 changes a line to use `self._shared_loader_obj.connection_loader.get()` instead of `connection_loader.get()`, referencing the `connection_loader` attribute. Edit 1 adds the line `self.connection_loader = connection_loader` to the SharedPluginLoaderObj class constructor, creating the exact attribute that Edit 0 references. The changed lines reference the exact same symbol (`connection_loader` attribute of SharedPluginLoaderObj), and Edit 1 must occur before Edit 0 because without the attribute assignment in Edit 1, Edit 0 would cause an AttributeError at runtime when trying to access `self._shared_loader_obj.connection_loader`."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Edit 0 changes a reference from 'action_loader' to 'self._shared_loader_obj.action_loader', while Edit 1 adds 'self.action_loader = action_loader' to the SharedPluginLoaderObj class. These edits reference the exact same symbol (action_loader) and create a direct code dependency - Edit 1 creates the attribute that Edit 0 references. However, both edits can be written and parsed independently without syntax errors. Edit 0 would cause a runtime AttributeError if Edit 1 hasn't been applied, but this is not a parse-time error in Python. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step in refactoring from direct loader access to shared loader object access."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Edit 0 changes a reference from 'action_loader' to 'self._shared_loader_obj.action_loader', while Edit 1 adds 'self.action_loader = action_loader' to the SharedPluginLoaderObj class. These edits reference the exact same symbol (action_loader) and create a direct code dependency - Edit 1 creates the attribute that Edit 0 references. However, both edits can be written and parsed independently without syntax errors. Edit 0 would cause a runtime AttributeError if Edit 1 hasn't been applied, but this is not a parse-time error in Python. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step in refactoring from direct loader access to shared loader object access."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits change references to 'action_loader' to 'self._shared_loader_obj.action_loader' within the same method (_get_action_handler). The changed lines in both edits reference the exact same symbol (action_loader) and perform identical textual substitution (action_loader \u2192 self._shared_loader_obj.action_loader). This is a bulk uniform substitution pattern where both edits are part of the same refactoring task to replace direct references to action_loader with the shared loader object reference. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits change references to 'action_loader' to 'self._shared_loader_obj.action_loader' within the same method (_get_action_handler). The changed lines in both edits reference the exact same symbol (action_loader) and perform identical textual substitution (action_loader \u2192 self._shared_loader_obj.action_loader). This is a bulk uniform substitution pattern where both edits are part of the same refactoring task to replace direct references to action_loader with the shared loader object reference. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbols: `action_loader` and `connection_loader`. Edit 0 imports these symbols from `ansible.plugins`, and edit 1 immediately uses these imported symbols by assigning them to instance attributes in the `__init__` method. After making edit 0 (adding the imports), edit 1 becomes the mechanically obvious next step to use these newly imported symbols. This is a classic import-usage pattern within the same file where the changed lines reference the exact same symbols."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbols: `action_loader` and `connection_loader`. Edit 0 imports these symbols from `ansible.plugins`, and edit 1 immediately uses these imported symbols by assigning them to instance attributes in the `__init__` method. After making edit 0 (adding the imports), edit 1 becomes the mechanically obvious next step to use these newly imported symbols. This is a classic import-usage pattern within the same file where the changed lines reference the exact same symbols."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 changes a reference from 'action_loader' to 'self._shared_loader_obj.action_loader', while Edit 1 adds 'self.action_loader = action_loader' to the SharedPluginLoaderObj class. These edits reference the exact same symbol (action_loader) and create a direct code dependency - Edit 1 creates the attribute that Edit 0 references. However, both edits can be written and parsed independently without syntax errors. Edit 0 would cause a runtime AttributeError if Edit 1 hasn't been applied, but this is not a parse-time error in Python. Therefore, this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 changes a reference from 'action_loader' to 'self._shared_loader_obj.action_loader', while Edit 1 adds 'self.action_loader = action_loader' to the SharedPluginLoaderObj class. These edits reference the exact same symbol (action_loader) and create a direct code dependency - Edit 1 creates the attribute that Edit 0 references. However, both edits can be written and parsed independently without syntax errors. Edit 0 would cause a runtime AttributeError if Edit 1 hasn't been applied, but this is not a parse-time error in Python. Therefore, this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        }
    ],
    "allowed_init_edits": [
        5
    ]
}