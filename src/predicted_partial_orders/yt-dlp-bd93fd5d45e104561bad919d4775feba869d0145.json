{
    "partial_orders": [
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 adds a new key 'fragment_started' to the ctx dictionary with the value 'start'. Edit 1 then uses this exact same 'fragment_started' key from the ctx dictionary in a calculation for speed. The changed lines reference the exact same symbol - ctx['fragment_started']. After making edit 0, edit 1 becomes the immediate next step to utilize the newly added fragment_started timestamp. This creates a direct code dependency where one edit defines/adds the symbol and the other edit uses it."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 adds a new key 'fragment_started' to the ctx dictionary with the value 'start'. Edit 1 then uses this exact same 'fragment_started' key from the ctx dictionary in a calculation for speed. The changed lines reference the exact same symbol - ctx['fragment_started']. After making edit 0, edit 1 becomes the immediate next step to utilize the newly added fragment_started timestamp. This creates a direct code dependency where one edit defines/adds the symbol and the other edit uses it."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits modify the exact same code pattern within the same function context. Edit 0 replaces the speed calculation logic with a call to `self.calc_speed()` and assigns the result to both `ctx['speed']` and `state['speed']`. Edit 1 performs an identical transformation - it removes the old speed assignment logic and replaces it with the same `self.calc_speed()` call pattern, assigning to both `ctx['speed']` and `state['speed']`. This represents a uniform, synchronized substitution where the same before\u2192after pattern is applied to the same type of syntactic construct (speed calculation assignments) within the same function. Both edits are part of a single refactoring operation to standardize speed calculations using the `calc_speed` method."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits modify the exact same code pattern within the same function context. Edit 0 replaces the speed calculation logic with a call to `self.calc_speed()` and assigns the result to both `ctx['speed']` and `state['speed']`. Edit 1 performs an identical transformation - it removes the old speed assignment logic and replaces it with the same `self.calc_speed()` call pattern, assigning to both `ctx['speed']` and `state['speed']`. This represents a uniform, synchronized substitution where the same before\u2192after pattern is applied to the same type of syntactic construct (speed calculation assignments) within the same function. Both edits are part of a single refactoring operation to standardize speed calculations using the `calc_speed` method."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds 'fragment_started': start to the ctx dictionary initialization, and Edit 1 uses ctx['fragment_started'] in two places: first to calculate speed using self.calc_speed(), and then reassigns it to time.time(). The changed lines in both edits reference the exact same symbol 'fragment_started' in the same ctx dictionary. Edit 0 defines/initializes this key, and Edit 1 uses it for calculations and updates it. This creates a direct code dependency where the usage in Edit 1 depends on the initialization in Edit 0, making them bi-directional neighbours in mental flow - either edit naturally prompts the other as the next mechanical step when working with fragment timing functionality."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds 'fragment_started': start to the ctx dictionary initialization, and Edit 1 uses ctx['fragment_started'] in two places: first to calculate speed using self.calc_speed(), and then reassigns it to time.time(). The changed lines in both edits reference the exact same symbol 'fragment_started' in the same ctx dictionary. Edit 0 defines/initializes this key, and Edit 1 uses it for calculations and updates it. This creates a direct code dependency where the usage in Edit 1 depends on the initialization in Edit 0, making them bi-directional neighbours in mental flow - either edit naturally prompts the other as the next mechanical step when working with fragment timing functionality."
        }
    ],
    "allowed_init_edits": [
        0,
        1,
        2
    ]
}