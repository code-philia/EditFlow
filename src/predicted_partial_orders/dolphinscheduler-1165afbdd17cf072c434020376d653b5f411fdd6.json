{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'worker_group' within the same function context. Edit 0 adds 'worker_group' as a parameter to the __init__ method signature, and Edit 1 assigns that parameter to self.worker_group in the constructor body. This creates a direct code dependency where the parameter defined in Edit 0 is immediately used in Edit 1. This is a classic parameter definition \u2192 parameter usage pattern within the same function, making either edit naturally prompt the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'worker_group' within the same function context. Edit 0 adds 'worker_group' as a parameter to the __init__ method signature, and Edit 1 assigns that parameter to self.worker_group in the constructor body. This creates a direct code dependency where the parameter defined in Edit 0 is immediately used in Edit 1. This is a classic parameter definition \u2192 parameter usage pattern within the same function, making either edit naturally prompt the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 adds a worker_group parameter to the ProcessDefinition constructor, and Edit 1 uses that exact same worker_group attribute (self.worker_group) in the start() method. The changed lines reference the same symbol - the worker_group attribute of the ProcessDefinition class. After adding the parameter in the constructor, using it in the start() method becomes the natural next step to complete the implementation. This is a classic definition-usage pattern where both edits reference the exact same symbol."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 adds a worker_group parameter to the ProcessDefinition constructor, and Edit 1 uses that exact same worker_group attribute (self.worker_group) in the start() method. The changed lines reference the same symbol - the worker_group attribute of the ProcessDefinition class. After adding the parameter in the constructor, using it in the start() method becomes the natural next step to complete the implementation. This is a classic definition-usage pattern where both edits reference the exact same symbol."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'worker_group' within the same class ProcessDefinition. Edit 0 adds 'worker_group' to what appears to be a list of attributes or parameters, while Edit 1 adds 'self.worker_group' as a parameter in a method call. The changed lines in both edits explicitly reference the same symbol, creating a direct code dependency where adding the attribute in one location naturally prompts adding its usage in the method call as the next mechanical step. This represents a definition-usage relationship for the same symbol within the same class context."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'worker_group' within the same class ProcessDefinition. Edit 0 adds 'worker_group' to what appears to be a list of attributes or parameters, while Edit 1 adds 'self.worker_group' as a parameter in a method call. The changed lines in both edits explicitly reference the same symbol, creating a direct code dependency where adding the attribute in one location naturally prompts adding its usage in the method call as the next mechanical step. This represents a definition-usage relationship for the same symbol within the same class context."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits add 'worker_group' to the same class (ProcessDefinition) in identical positions relative to existing parameters. Edit 0 adds 'worker_group' to what appears to be a list of attribute names or parameters (between '_tenant' and 'timeout'), while Edit 1 adds the same parameter to the constructor signature (between 'queue' and 'timeout'). Both edits reference the exact same symbol 'worker_group' and appear to be part of a synchronized addition of a new parameter to the class - adding it to both the attribute list and constructor signature. This creates a direct structural dependency where both changes are mechanically required as part of the same micro-task of adding the worker_group parameter to the ProcessDefinition class."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits add 'worker_group' to the same class (ProcessDefinition) in identical positions relative to existing parameters. Edit 0 adds 'worker_group' to what appears to be a list of attribute names or parameters (between '_tenant' and 'timeout'), while Edit 1 adds the same parameter to the constructor signature (between 'queue' and 'timeout'). Both edits reference the exact same symbol 'worker_group' and appear to be part of a synchronized addition of a new parameter to the class - adding it to both the attribute list and constructor signature. This creates a direct structural dependency where both changes are mechanically required as part of the same micro-task of adding the worker_group parameter to the ProcessDefinition class."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds 'worker_group' to what appears to be a list of attributes or parameters in the ProcessDefinition class. Edit 1 replaces the hardcoded string 'default' with 'self.worker_group' in a method call. Both edits reference the exact same symbol 'worker_group' - one adds it as an attribute and the other uses that attribute. This creates a direct code dependency where the attribute must be available for the usage to work properly. Either edit can be made first since Python allows referencing undefined attributes at parse time (would only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds 'worker_group' to what appears to be a list of attributes or parameters in the ProcessDefinition class. Edit 1 replaces the hardcoded string 'default' with 'self.worker_group' in a method call. Both edits reference the exact same symbol 'worker_group' - one adds it as an attribute and the other uses that attribute. This creates a direct code dependency where the attribute must be available for the usage to work properly. Either edit can be made first since Python allows referencing undefined attributes at parse time (would only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'ProcessDefinitionDefault.WORKER_GROUP'. Edit 0 adds a worker_group parameter to the ProcessDefinition constructor using this default value, while Edit 1 adds a test case that validates this same default value. These edits are part of synchronized parameter addition - adding the parameter to the constructor and adding corresponding test coverage for that parameter. Either edit can be made first and both reference the same symbol, making this a bi-directional relationship where making either edit creates an immediate prompt for the other as part of the same feature implementation."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'ProcessDefinitionDefault.WORKER_GROUP'. Edit 0 adds a worker_group parameter to the ProcessDefinition constructor using this default value, while Edit 1 adds a test case that validates this same default value. These edits are part of synchronized parameter addition - adding the parameter to the constructor and adding corresponding test coverage for that parameter. Either edit can be made first and both reference the same symbol, making this a bi-directional relationship where making either edit creates an immediate prompt for the other as part of the same feature implementation."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'worker_group' within the same class ProcessDefinition. Edit 0 adds worker_group as a parameter to the __init__ method, and Edit 1 uses self.worker_group in the submit method. After adding the parameter in __init__, using it in submit becomes the natural next step. However, both edits can be staged in either order without causing parse errors - the parameter can be added to __init__ without immediate usage, and self.worker_group can be referenced in submit (though it would cause a runtime AttributeError if __init__ doesn't set it). Since both reference the same symbol and either edit naturally prompts the other as the next mechanical step in implementing the worker_group feature, this is bi-directional."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'worker_group' within the same class ProcessDefinition. Edit 0 adds worker_group as a parameter to the __init__ method, and Edit 1 uses self.worker_group in the submit method. After adding the parameter in __init__, using it in submit becomes the natural next step. However, both edits can be staged in either order without causing parse errors - the parameter can be added to __init__ without immediate usage, and self.worker_group can be referenced in submit (though it would cause a runtime AttributeError if __init__ doesn't set it). Since both reference the same symbol and either edit naturally prompts the other as the next mechanical step in implementing the worker_group feature, this is bi-directional."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'worker_group' - edit 0 assigns it as an instance attribute (self.worker_group = worker_group) and edit 1 uses that same attribute in a method call (self.worker_group). This creates a direct code dependency where the assignment in edit 0 makes the attribute available for use in edit 1. Either edit can be made first since Python allows referencing undefined attributes (resulting in AttributeError at runtime, not parse error), making this a bi-directional relationship where each edit naturally prompts the other as part of adding worker_group support to the ProcessDefinition class."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'worker_group' - edit 0 assigns it as an instance attribute (self.worker_group = worker_group) and edit 1 uses that same attribute in a method call (self.worker_group). This creates a direct code dependency where the assignment in edit 0 makes the attribute available for use in edit 1. Either edit can be made first since Python allows referencing undefined attributes (resulting in AttributeError at runtime, not parse error), making this a bi-directional relationship where each edit naturally prompts the other as part of adding worker_group support to the ProcessDefinition class."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'worker_group' as an attribute of the same class instance (self.worker_group). Edit 0 assigns a value to this attribute in the constructor, while Edit 1 uses this attribute in the start() method. After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the attribute assignment, you need to use it where it was previously hardcoded as 'default', and vice versa. This creates a direct, mechanically obvious code dependency between the changed lines referencing the same symbol."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'worker_group' as an attribute of the same class instance (self.worker_group). Edit 0 assigns a value to this attribute in the constructor, while Edit 1 uses this attribute in the start() method. After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the attribute assignment, you need to use it where it was previously hardcoded as 'default', and vice versa. This creates a direct, mechanically obvious code dependency between the changed lines referencing the same symbol."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "These edits are adding the same parameter 'worker_group' to related components - one adds it to the ProcessDefinition constructor signature, and the other adds the corresponding 'workerGroup' field to a test dictionary that validates the ProcessDefinition's to_dict output. Both edits reference the same symbol ProcessDefinitionDefault.WORKER_GROUP and are part of synchronizing the parameter addition between the implementation and its test validation. This creates a bi-directional relationship where either edit naturally prompts the other as the next step to maintain consistency between the constructor and its test validation."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "These edits are adding the same parameter 'worker_group' to related components - one adds it to the ProcessDefinition constructor signature, and the other adds the corresponding 'workerGroup' field to a test dictionary that validates the ProcessDefinition's to_dict output. Both edits reference the same symbol ProcessDefinitionDefault.WORKER_GROUP and are part of synchronizing the parameter addition between the implementation and its test validation. This creates a bi-directional relationship where either edit naturally prompts the other as the next step to maintain consistency between the constructor and its test validation."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits involve adding the same attribute 'self.worker_group' as a parameter to different method calls within the same class (ProcessDefinition). Edit 0 adds it to the createOrUpdateProcessDefinition call in the submit() method, while Edit 1 adds it to the execProcessInstance call in the start() method, replacing the hardcoded 'default' value. These are part of a synchronized refactoring pattern where the same attribute is being consistently added to multiple method calls within the same class, representing identical structural substitutions of the same type of syntactic construct (method parameter additions). This creates a bi-directional relationship as either edit could be made first, and both are part of the same contiguous micro-task of adding worker_group support throughout the class."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits involve adding the same attribute 'self.worker_group' as a parameter to different method calls within the same class (ProcessDefinition). Edit 0 adds it to the createOrUpdateProcessDefinition call in the submit() method, while Edit 1 adds it to the execProcessInstance call in the start() method, replacing the hardcoded 'default' value. These are part of a synchronized refactoring pattern where the same attribute is being consistently added to multiple method calls within the same class, representing identical structural substitutions of the same type of syntactic construct (method parameter additions). This creates a bi-directional relationship as either edit could be made first, and both are part of the same contiguous micro-task of adding worker_group support throughout the class."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits add the same parameter 'worker_group' to different parametrize decorators within the same test file. Edit 0 adds a tuple with 'worker_group' and its default value to one parametrize decorator, while Edit 1 adds a tuple with 'worker_group', its type (str), and expected string to another parametrize decorator. These are synchronized additions of the same parameter name to related test configurations within the same file, following the same structural pattern of adding tuples to parametrize lists. This represents a mirrored/synchronized addition within the same test context where both edits reference the same parameter concept and follow identical structural patterns."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits add the same parameter 'worker_group' to different parametrize decorators within the same test file. Edit 0 adds a tuple with 'worker_group' and its default value to one parametrize decorator, while Edit 1 adds a tuple with 'worker_group', its type (str), and expected string to another parametrize decorator. These are synchronized additions of the same parameter name to related test configurations within the same file, following the same structural pattern of adding tuples to parametrize lists. This represents a mirrored/synchronized addition within the same test context where both edits reference the same parameter concept and follow identical structural patterns."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits add references to ProcessDefinitionDefault.WORKER_GROUP in the same test file. Edit 0 adds it to a parametrized test data structure, while Edit 1 adds it to an expected dictionary in a test assertion. Both changed lines reference the exact same symbol (ProcessDefinitionDefault.WORKER_GROUP) and appear to be part of the same development task of adding worker_group support to the test suite. Either edit could be made first, and after making either one, the other would be the natural next step to ensure test consistency."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits add references to ProcessDefinitionDefault.WORKER_GROUP in the same test file. Edit 0 adds it to a parametrized test data structure, while Edit 1 adds it to an expected dictionary in a test assertion. Both changed lines reference the exact same symbol (ProcessDefinitionDefault.WORKER_GROUP) and appear to be part of the same development task of adding worker_group support to the test suite. Either edit could be made first, and after making either one, the other would be the natural next step to ensure test consistency."
        }
    ],
    "allowed_init_edits": [
        6
    ]
}