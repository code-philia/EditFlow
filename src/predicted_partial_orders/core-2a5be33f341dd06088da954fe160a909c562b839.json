{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on dataclass decorators. This represents a uniform, synchronized pattern substitution across multiple files as part of what appears to be a single refactoring operation to add the kw_only=True parameter to dataclass decorators throughout the codebase. The edits target the exact same construct type (dataclass decorators) with the identical before\u2192after pattern, making this a clear case of bulk-edit synchronization."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on dataclass decorators. This represents a uniform, synchronized pattern substitution across multiple files as part of what appears to be a single refactoring operation to add the kw_only=True parameter to dataclass decorators throughout the codebase. The edits target the exact same construct type (dataclass decorators) with the identical before\u2192after pattern, making this a clear case of bulk-edit synchronization."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a uniform refactoring operation where the same parameter addition is being applied consistently across multiple dataclass definitions in the same codebase. The edits are part of a single, contiguous refactor to add the kw_only=True parameter to dataclass decorators, making them bi-directional neighbours as either edit could be made first and would naturally prompt the other as part of the same bulk substitution pattern."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a uniform refactoring operation where the same parameter addition is being applied consistently across multiple dataclass definitions in the same codebase. The edits are part of a single, contiguous refactor to add the kw_only=True parameter to dataclass decorators, making them bi-directional neighbours as either edit could be made first and would naturally prompt the other as part of the same bulk substitution pattern."
        },
        {
            "src": 0,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only=True parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactor sweep."
        },
        {
            "src": 8,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only=True parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactor sweep."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: adding ', kw_only=True' to @dataclass(frozen=True) decorators. This is a uniform, mechanical change applied to the same type of syntactic construct (dataclass decorators) across different files. The edits appear to be part of a single refactoring sweep to add the kw_only parameter to dataclass definitions. Either edit can be made first, and after making one, the other would be the natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding ', kw_only=True' to @dataclass(frozen=True) decorators. This is a uniform, mechanical change applied to the same type of syntactic construct (dataclass decorators) across different files. The edits appear to be part of a single refactoring sweep to add the kw_only parameter to dataclass definitions. Either edit can be made first, and after making one, the other would be the natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This appears to be part of a single, contiguous refactor applying the same change across multiple entity description classes in the Synology DSM component. The edits target the same construct type and use identical before\u2192after patterns, making this a bulk-edit synchronization where either edit could be made first as part of the same refactoring sweep."
        },
        {
            "src": 7,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This appears to be part of a single, contiguous refactor applying the same change across multiple entity description classes in the Synology DSM component. The edits target the same construct type and use identical before\u2192after patterns, making this a bulk-edit synchronization where either edit could be made first as part of the same refactoring sweep."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical structural transformation on dataclass decorators: adding 'kw_only=True' parameter and changing class names from mixin pattern to description pattern that inherits from base entity descriptions. The changes follow the exact same before\u2192after pattern (@dataclass(frozen=True) \u2192 @dataclass(frozen=True, kw_only=True)) and target the same type of syntactic construct (dataclass decorators). This appears to be part of a single, contiguous refactoring operation to standardize dataclass definitions across the codebase. However, the changed lines reference different symbols (SynologyDSMbuttonDescriptionMixin vs SynologyDSMRequiredKeysMixin) in different files, so there is no direct code dependency between them."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical structural transformation on dataclass decorators: adding 'kw_only=True' parameter and changing class names from mixin pattern to description pattern that inherits from base entity descriptions. The changes follow the exact same before\u2192after pattern (@dataclass(frozen=True) \u2192 @dataclass(frozen=True, kw_only=True)) and target the same type of syntactic construct (dataclass decorators). This appears to be part of a single, contiguous refactoring operation to standardize dataclass definitions across the codebase. However, the changed lines reference different symbols (SynologyDSMbuttonDescriptionMixin vs SynologyDSMRequiredKeysMixin) in different files, so there is no direct code dependency between them."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 changes the class definition from 'SynologyDSMbuttonDescriptionMixin' to 'SynologyDSMbuttonDescription' and modifies its inheritance. Edit 1 removes the old 'SynologyDSMbuttonDescription' class that was inheriting from both 'ButtonEntityDescription' and 'SynologyDSMbuttonDescriptionMixin'. These edits are part of a single refactoring operation where the mixin pattern is being eliminated - the mixin class is being converted into the final class directly, and the old composite class is being removed. The changed lines reference the exact same symbol 'SynologyDSMbuttonDescriptionMixin' - edit 0 renames it and edit 1 removes its usage. This is a coordinated refactoring where both changes work together to eliminate the mixin pattern, making them bi-directional neighbours in the same micro-task."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 changes the class definition from 'SynologyDSMbuttonDescriptionMixin' to 'SynologyDSMbuttonDescription' and modifies its inheritance. Edit 1 removes the old 'SynologyDSMbuttonDescription' class that was inheriting from both 'ButtonEntityDescription' and 'SynologyDSMbuttonDescriptionMixin'. These edits are part of a single refactoring operation where the mixin pattern is being eliminated - the mixin class is being converted into the final class directly, and the old composite class is being removed. The changed lines reference the exact same symbol 'SynologyDSMbuttonDescriptionMixin' - edit 0 renames it and edit 1 removes its usage. This is a coordinated refactoring where both changes work together to eliminate the mixin pattern, making them bi-directional neighbours in the same micro-task."
        },
        {
            "src": 1,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: adding ', kw_only=True' to @dataclass(frozen=True) decorators. They target the same type of syntactic construct (dataclass decorators) and appear to be part of a single, contiguous refactor to add kw_only=True to dataclass definitions across the codebase. This is a bulk-edit pattern where both edits apply the same before\u2192after transformation to the same construct type."
        },
        {
            "src": 8,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding ', kw_only=True' to @dataclass(frozen=True) decorators. They target the same type of syntactic construct (dataclass decorators) and appear to be part of a single, contiguous refactor to add kw_only=True to dataclass definitions across the codebase. This is a bulk-edit pattern where both edits apply the same before\u2192after transformation to the same construct type."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: adding ', kw_only=True' to @dataclass(frozen=True) decorators. This is a uniform, mechanical change applied to the same type of syntactic construct (dataclass decorators) across different files. The edits are part of a single refactoring operation to add the kw_only parameter to dataclass definitions. Either edit can be made first, and after making one, the other becomes a natural continuation of the same substitution pattern."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding ', kw_only=True' to @dataclass(frozen=True) decorators. This is a uniform, mechanical change applied to the same type of syntactic construct (dataclass decorators) across different files. The edits are part of a single refactoring operation to add the kw_only parameter to dataclass definitions. Either edit can be made first, and after making one, the other becomes a natural continuation of the same substitution pattern."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits remove identical @dataclass(frozen=True) decorators from class definitions in the same codebase. This appears to be part of a uniform refactoring operation where the same structural change (removing the dataclass decorator) is being applied to multiple similar class definitions. The edits follow the same before\u2192after pattern (removing @dataclass(frozen=True) and the following class definition) and target the same type of syntactic construct (dataclass decorators on entity description classes). This represents a bulk substitution pattern where either edit could be made first as part of the same refactoring sweep."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits remove identical @dataclass(frozen=True) decorators from class definitions in the same codebase. This appears to be part of a uniform refactoring operation where the same structural change (removing the dataclass decorator) is being applied to multiple similar class definitions. The edits follow the same before\u2192after pattern (removing @dataclass(frozen=True) and the following class definition) and target the same type of syntactic construct (dataclass decorators on entity description classes). This represents a bulk substitution pattern where either edit could be made first as part of the same refactoring sweep."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactor sweep. Either edit can be made first, and after making one, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactor sweep. Either edit can be made first, and after making one, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only parameter to dataclass decorators. The edits can be applied in either order since they are independent changes to different files, and making either edit would naturally prompt completing the same substitution pattern in other similar locations as part of the same contiguous refactoring task."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only parameter to dataclass decorators. The edits can be applied in either order since they are independent changes to different files, and making either edit would naturally prompt completing the same substitution pattern in other similar locations as part of the same contiguous refactoring task."
        },
        {
            "src": 3,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only=True parameter to dataclass decorators. The edits can be applied in either order as they are independent changes to different files, but they form a synchronized pattern that would naturally be done together in a single contiguous refactoring task."
        },
        {
            "src": 8,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only=True parameter to dataclass decorators. The edits can be applied in either order as they are independent changes to different files, but they form a synchronized pattern that would naturally be done together in a single contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)'. This is a uniform, synchronized modification across multiple dataclass decorators in the same codebase. The edits target the same type of syntactic construct (dataclass decorators) and apply the exact same before\u2192after pattern. This represents a bulk refactoring operation that would naturally be performed as part of a single, contiguous micro-task to consistently add the kw_only parameter across all relevant dataclasses."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)'. This is a uniform, synchronized modification across multiple dataclass decorators in the same codebase. The edits target the same type of syntactic construct (dataclass decorators) and apply the exact same before\u2192after pattern. This represents a bulk refactoring operation that would naturally be performed as part of a single, contiguous micro-task to consistently add the kw_only parameter across all relevant dataclasses."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 transforms the SynologyDSMRequiredKeysMixin class into SynologyDSMEntityDescription, while Edit 1 removes the old SynologyDSMEntityDescription class that inherited from both EntityDescription and SynologyDSMRequiredKeysMixin. This is a refactoring where the mixin is being eliminated and its functionality consolidated into a single class. Edit 0 must happen first because it creates the new consolidated class definition, and then Edit 1 removes the old class that depended on the mixin. If Edit 1 happened first, the SynologyDSMEntityDescription class would be completely removed, leaving no class with that name, which would break any code that references it."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)'. This is a uniform, synchronized modification across multiple dataclass decorators in the same codebase, representing a single refactoring operation to add the kw_only parameter to dataclass definitions. Both edits target the same type of syntactic construct (dataclass decorators) with the exact same before\u2192after pattern, making this a clear case of bulk-edit synchronization where either edit could be made first as part of the same contiguous refactoring task."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)'. This is a uniform, synchronized modification across multiple dataclass decorators in the same codebase, representing a single refactoring operation to add the kw_only parameter to dataclass definitions. Both edits target the same type of syntactic construct (dataclass decorators) with the exact same before\u2192after pattern, making this a clear case of bulk-edit synchronization where either edit could be made first as part of the same contiguous refactoring task."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: adding ', kw_only=True' to @dataclass(frozen=True) decorators. They target the same type of syntactic construct (dataclass decorators) and appear to be part of a single, contiguous refactor to add the kw_only parameter to dataclass definitions across the codebase. This is a bulk-edit pattern where either edit could be made first, and after making either, the other would be a natural continuation of the same mechanical substitution task."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding ', kw_only=True' to @dataclass(frozen=True) decorators. They target the same type of syntactic construct (dataclass decorators) and appear to be part of a single, contiguous refactor to add the kw_only parameter to dataclass definitions across the codebase. This is a bulk-edit pattern where either edit could be made first, and after making either, the other would be a natural continuation of the same mechanical substitution task."
        },
        {
            "src": 4,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)'. This is a uniform, synchronized modification across multiple files targeting the same type of syntactic construct (dataclass decorators). Both edits are part of what appears to be a single refactoring operation to add the kw_only=True parameter to dataclass decorators throughout the codebase. Either edit can be made first, and after making one, the other becomes a natural continuation of the same mechanical substitution pattern."
        },
        {
            "src": 8,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)'. This is a uniform, synchronized modification across multiple files targeting the same type of syntactic construct (dataclass decorators). Both edits are part of what appears to be a single refactoring operation to add the kw_only=True parameter to dataclass decorators throughout the codebase. Either edit can be made first, and after making one, the other becomes a natural continuation of the same mechanical substitution pattern."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactor sweep. Either edit can be made first, and after making one, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactor sweep. Either edit can be made first, and after making one, the other becomes an immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 6,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactor sweep. Either edit could be made first, and after making one, the other would be the natural next step to maintain consistency across the codebase."
        },
        {
            "src": 8,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactor sweep. Either edit could be made first, and after making one, the other would be the natural next step to maintain consistency across the codebase."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactor sweep. Either edit could be made first, and after making one, the other would be the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactor sweep. Either edit could be made first, and after making one, the other would be the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a uniform refactoring operation where the same parameter addition is being applied consistently across multiple dataclass definitions. The edits are part of a single, contiguous refactor to add the kw_only=True parameter to dataclass decorators throughout the codebase. Either edit could be made first, and after making either one, the other would be the natural next step to maintain consistency in the refactoring pattern."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a uniform refactoring operation where the same parameter addition is being applied consistently across multiple dataclass definitions. The edits are part of a single, contiguous refactor to add the kw_only=True parameter to dataclass decorators throughout the codebase. Either edit could be made first, and after making either one, the other would be the natural next step to maintain consistency in the refactoring pattern."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a uniform, synchronized multi-file refactor where the same structural change is being applied consistently across different entity description classes in the same codebase. The edits are part of a single contiguous refactoring task to add the kw_only parameter to dataclass decorators, making either edit naturally prompt the other as part of the same bulk substitution pattern."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a uniform, synchronized multi-file refactor where the same structural change is being applied consistently across different entity description classes in the same codebase. The edits are part of a single contiguous refactoring task to add the kw_only parameter to dataclass decorators, making either edit naturally prompt the other as part of the same bulk substitution pattern."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only=True parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous search-and-replace or refactoring sweep."
        },
        {
            "src": 8,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing '@dataclass(frozen=True)' to '@dataclass(frozen=True, kw_only=True)' on the same type of syntactic construct (dataclass decorators). This represents a bulk uniform substitution across multiple files, where both edits are part of the same refactoring operation to add the kw_only=True parameter to dataclass decorators. The changes are mechanically identical and would naturally occur as part of a single, contiguous search-and-replace or refactoring sweep."
        }
    ],
    "allowed_init_edits": [
        2,
        5
    ]
}