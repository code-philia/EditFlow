{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 6,
            "reason": "Edit 0 imports the function `mail_new_test_user` from `odoo.addons.test_mail.tests.common`, and Edit 1 uses this exact same function `mail_new_test_user` in its changed lines. After making Edit 0 (the import), Edit 1 becomes the immediate next step to use the newly imported function. The changed lines reference the exact same symbol `mail_new_test_user`, creating a direct definition-usage relationship where the import enables the usage."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution - adding the exact same import line 'from odoo.addons.test_mail.tests.common import mail_new_test_user' at the same structural location (line 3) in different files. This represents a bulk-edit pattern where the same import is being added to multiple test files as part of a single, contiguous refactor. The edits target the same type of syntactic construct (import statements) with identical before\u2192after patterns, making them part of a synchronized multi-file substitution that would naturally occur in one uninterrupted micro-task."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution - adding the exact same import line 'from odoo.addons.test_mail.tests.common import mail_new_test_user' at the same structural location (line 3) in different files. This represents a bulk-edit pattern where the same import is being added to multiple test files as part of a single, contiguous refactor. The edits target the same type of syntactic construct (import statements) with identical before\u2192after patterns, making them part of a synchronized multi-file substitution that would naturally occur in one uninterrupted micro-task."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits perform identical structural substitutions, replacing manual user creation code with calls to the same helper function `mail_new_test_user`. They follow the exact same pattern: removing verbose user creation dictionaries and replacing them with concise helper function calls using the same parameters (login, groups). This represents a uniform refactoring pattern applied to the same type of syntactic construct (user creation code) across different files, making them part of a single contiguous refactor operation."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits perform identical structural substitutions, replacing manual user creation code with calls to the same helper function `mail_new_test_user`. They follow the exact same pattern: removing verbose user creation dictionaries and replacing them with concise helper function calls using the same parameters (login, groups). This represents a uniform refactoring pattern applied to the same type of syntactic construct (user creation code) across different files, making them part of a single contiguous refactor operation."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform identical structural substitutions, replacing verbose user creation code with calls to the same helper function `mail_new_test_user`. They follow the exact same before\u2192after pattern: removing manual user creation with context and groups_id, and replacing with a single function call. Both target the same type of syntactic construct (user creation in test setup methods) and appear to be part of the same refactoring sweep to standardize test user creation across the codebase."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform identical structural substitutions, replacing verbose user creation code with calls to the same helper function `mail_new_test_user`. They follow the exact same before\u2192after pattern: removing manual user creation with context and groups_id, and replacing with a single function call. Both target the same type of syntactic construct (user creation in test setup methods) and appear to be part of the same refactoring sweep to standardize test user creation across the codebase."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 imports the function `mail_new_test_user` from `odoo.addons.test_mail.tests.common`, and Edit 1 uses this exact same function `mail_new_test_user` in the changed line. The import creates an immediate, mechanically obvious prompt to use the imported function, and using the function requires it to be imported first. Both edits reference the exact same symbol `mail_new_test_user`, creating a direct code dependency where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 imports the function `mail_new_test_user` from `odoo.addons.test_mail.tests.common`, and Edit 1 uses this exact same function `mail_new_test_user` in the changed line. The import creates an immediate, mechanically obvious prompt to use the imported function, and using the function requires it to be imported first. Both edits reference the exact same symbol `mail_new_test_user`, creating a direct code dependency where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds an import statement for 'mail_new_test_user' from 'odoo.addons.test_mail.tests.common', while Edit 1 uses this exact same function 'mail_new_test_user' in the changed lines to replace manual user creation code. The changed lines in Edit 1 directly call the function that is imported in Edit 0. This creates an immediate, mechanically obvious code dependency - after importing the function in Edit 0, Edit 1 becomes the natural next step to use that imported function. Both edits reference the exact same symbol 'mail_new_test_user' and would occur in a single uninterrupted micro-task of refactoring user creation code to use the helper function."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds an import statement for 'mail_new_test_user' from 'odoo.addons.test_mail.tests.common', while Edit 1 uses this exact same function 'mail_new_test_user' in the changed lines to replace manual user creation code. The changed lines in Edit 1 directly call the function that is imported in Edit 0. This creates an immediate, mechanically obvious code dependency - after importing the function in Edit 0, Edit 1 becomes the natural next step to use that imported function. Both edits reference the exact same symbol 'mail_new_test_user' and would occur in a single uninterrupted micro-task of refactoring user creation code to use the helper function."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 replaces manual user creation code with a call to `mail_new_test_user()` function, while Edit 1 adds an import for that exact same `mail_new_test_user` function. The changed lines reference the exact same symbol - `mail_new_test_user`. After making Edit 0, the code would have an undefined symbol error until Edit 1 provides the import. However, in Python, both edits can be written and parsed in either order since undefined names only cause runtime NameError, not parse-time syntax errors. Either edit naturally prompts the other as the immediate next step due to the direct code dependency on the same symbol."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 replaces manual user creation code with a call to `mail_new_test_user()` function, while Edit 1 adds an import for that exact same `mail_new_test_user` function. The changed lines reference the exact same symbol - `mail_new_test_user`. After making Edit 0, the code would have an undefined symbol error until Edit 1 provides the import. However, in Python, both edits can be written and parsed in either order since undefined names only cause runtime NameError, not parse-time syntax errors. Either edit naturally prompts the other as the immediate next step due to the direct code dependency on the same symbol."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits remove identical code blocks (the _quick_create_ctx and _quick_create_user_ctx definitions) from different test files. This represents a bulk cleanup operation where the same obsolete code pattern is being removed from multiple locations. The edits perform identical textual substitutions (removing the same lines) and target the same type of syntactic construct (context dictionary definitions in test setUp methods). This is a clear case of synchronized pattern removal across multiple files as part of a single refactoring task."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits remove identical code blocks (the _quick_create_ctx and _quick_create_user_ctx definitions) from different test files. This represents a bulk cleanup operation where the same obsolete code pattern is being removed from multiple locations. The edits perform identical textual substitutions (removing the same lines) and target the same type of syntactic construct (context dictionary definitions in test setUp methods). This is a clear case of synchronized pattern removal across multiple files as part of a single refactoring task."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds an import for 'mail_new_test_user' from 'odoo.addons.test_mail.tests.common', and Edit 1 uses this exact same function 'mail_new_test_user' to replace a manual user creation. The changed lines reference the exact same symbol - 'mail_new_test_user'. After importing the function in Edit 0, Edit 1 becomes the immediate next step to use that imported function. This is a classic import-usage pattern where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds an import for 'mail_new_test_user' from 'odoo.addons.test_mail.tests.common', and Edit 1 uses this exact same function 'mail_new_test_user' to replace a manual user creation. The changed lines reference the exact same symbol - 'mail_new_test_user'. After importing the function in Edit 0, Edit 1 becomes the immediate next step to use that imported function. This is a classic import-usage pattern where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 removes the definition of `self._quick_create_user_ctx` (line 16), while Edit 1 removes the usage of that same variable (line 19). The changed lines reference the exact same symbol `self._quick_create_user_ctx`. After making either edit, the other becomes the immediate next step - if you remove the definition first, you need to remove the usage to avoid a NameError; if you remove the usage first, you need to remove the now-unused definition. This is a classic definition-usage relationship for the same symbol within the same class context."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 removes the definition of `self._quick_create_user_ctx` (line 16), while Edit 1 removes the usage of that same variable (line 19). The changed lines reference the exact same symbol `self._quick_create_user_ctx`. After making either edit, the other becomes the immediate next step - if you remove the definition first, you need to remove the usage to avoid a NameError; if you remove the usage first, you need to remove the now-unused definition. This is a classic definition-usage relationship for the same symbol within the same class context."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 imports the function `mail_new_test_user` from `odoo.addons.test_mail.tests.common`, and Edit 1 uses this exact same function `mail_new_test_user` in the changed lines to create a user. The import in Edit 0 makes the function available for use, and Edit 1 directly calls this imported function. This creates an immediate, mechanically obvious code dependency where the import enables the usage. Both edits reference the exact same symbol `mail_new_test_user`, and making either edit creates a prompt for the other as the next contiguous action within the same development task."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 imports the function `mail_new_test_user` from `odoo.addons.test_mail.tests.common`, and Edit 1 uses this exact same function `mail_new_test_user` in the changed lines to create a user. The import in Edit 0 makes the function available for use, and Edit 1 directly calls this imported function. This creates an immediate, mechanically obvious code dependency where the import enables the usage. Both edits reference the exact same symbol `mail_new_test_user`, and making either edit creates a prompt for the other as the next contiguous action within the same development task."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 imports the function `mail_new_test_user` from `odoo.addons.test_mail.tests.common`, and Edit 1 uses this exact same function in the changed lines to replace the manual user creation code. The import in Edit 0 makes the function available for use in Edit 1. This creates an immediate, mechanically obvious code-driven prompt - after importing `mail_new_test_user`, it becomes available to replace the verbose user creation patterns. Both edits reference the exact same symbol (`mail_new_test_user`) and would naturally occur in one contiguous micro-task of refactoring user creation code to use the helper function."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 imports the function `mail_new_test_user` from `odoo.addons.test_mail.tests.common`, and Edit 1 uses this exact same function in the changed lines to replace the manual user creation code. The import in Edit 0 makes the function available for use in Edit 1. This creates an immediate, mechanically obvious code-driven prompt - after importing `mail_new_test_user`, it becomes available to replace the verbose user creation patterns. Both edits reference the exact same symbol (`mail_new_test_user`) and would naturally occur in one contiguous micro-task of refactoring user creation code to use the helper function."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 adds an import statement for 'mail_new_test_user' from 'odoo.addons.test_mail.tests.common', and Edit 1 uses this exact same imported function 'mail_new_test_user' in the changed line. The import creates an immediate, mechanically obvious prompt to use the imported function, and both edits reference the exact same symbol. This is a classic import-usage relationship within the same file where either edit can be staged first (the usage before import would only cause a runtime NameError in Python, not a parse error), making it bi-directional."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 adds an import statement for 'mail_new_test_user' from 'odoo.addons.test_mail.tests.common', and Edit 1 uses this exact same imported function 'mail_new_test_user' in the changed line. The import creates an immediate, mechanically obvious prompt to use the imported function, and both edits reference the exact same symbol. This is a classic import-usage relationship within the same file where either edit can be staged first (the usage before import would only cause a runtime NameError in Python, not a parse error), making it bi-directional."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform identical structural substitutions within the same method (setUp). They replace verbose Users.create() calls with concise mail_new_test_user() calls, following the exact same before\u2192after pattern. Both target the same type of syntactic construct (user creation statements) and are clearly part of a single, contiguous refactoring operation to modernize the test user creation approach. The changes are mechanically identical in structure and would naturally be performed together in one uninterrupted micro-task."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform identical structural substitutions within the same method (setUp). They replace verbose Users.create() calls with concise mail_new_test_user() calls, following the exact same before\u2192after pattern. Both target the same type of syntactic construct (user creation statements) and are clearly part of a single, contiguous refactoring operation to modernize the test user creation approach. The changes are mechanically identical in structure and would naturally be performed together in one uninterrupted micro-task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits reference the same variable 'Users' that was defined in edit 0 and used in edit 1. Edit 0 removes the definition of 'Users = self.env['res.users'].with_context(self._quick_create_user_ctx)', while edit 1 removes the usage of 'Users.create(...)'. Since edit 1's changed line explicitly references the 'Users' variable that is being removed in edit 0, these edits are part of the same refactoring task to replace manual user creation with the mail_new_test_user helper function. The relationship is bi-directional because both edits can be staged in either order - removing either the definition or usage first would not cause a parse error, only a potential runtime NameError."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits reference the same variable 'Users' that was defined in edit 0 and used in edit 1. Edit 0 removes the definition of 'Users = self.env['res.users'].with_context(self._quick_create_user_ctx)', while edit 1 removes the usage of 'Users.create(...)'. Since edit 1's changed line explicitly references the 'Users' variable that is being removed in edit 0, these edits are part of the same refactoring task to replace manual user creation with the mail_new_test_user helper function. The relationship is bi-directional because both edits can be staged in either order - removing either the definition or usage first would not cause a parse error, only a potential runtime NameError."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits are part of the same refactoring operation, replacing manual user creation with `Users.create()` calls to using the `mail_new_test_user()` helper function. Edit 0 removes the `Users` variable definition and replaces the first user creation, while Edit 1 continues this pattern by replacing the remaining `Users.create()` calls with `mail_new_test_user()` calls. However, the changed lines in each edit don't reference the exact same symbol - Edit 0 removes the `Users` variable definition and uses it once, while Edit 1 uses the `Users` variable multiple times but doesn't define it. After Edit 0 is applied, the `Users` variable no longer exists, so Edit 1's references to `Users` would cause a NameError. This creates a dependency where Edit 0 must come before Edit 1."
        }
    ],
    "allowed_init_edits": [
        3
    ]
}