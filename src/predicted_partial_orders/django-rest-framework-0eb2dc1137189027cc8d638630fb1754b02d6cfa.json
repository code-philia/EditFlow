{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 imports ProhibitNullCharactersValidator in rest_framework/fields.py, and Edit 1 uses that exact same symbol in a test condition (@pytest.mark.skipif(ProhibitNullCharactersValidator is None, ...)). The changed lines reference the exact same symbol - ProhibitNullCharactersValidator. After importing the validator in Edit 0, Edit 1 becomes the natural next step to test its functionality. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime), both edits can be staged in either order without causing parser errors. The test would simply fail at runtime if the import hasn't been added yet. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 imports ProhibitNullCharactersValidator in rest_framework/fields.py, and Edit 1 uses that exact same symbol in a test condition (@pytest.mark.skipif(ProhibitNullCharactersValidator is None, ...)). The changed lines reference the exact same symbol - ProhibitNullCharactersValidator. After importing the validator in Edit 0, Edit 1 becomes the natural next step to test its functionality. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime), both edits can be staged in either order without causing parser errors. The test would simply fail at runtime if the import hasn't been added yet. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 imports ProhibitNullCharactersValidator from django.core.validators, and Edit 1 uses that exact same imported symbol ProhibitNullCharactersValidator in the CharField class. The changed lines reference the exact same symbol - Edit 0 makes it available via import, and Edit 1 uses it. This creates an immediate code dependency where importing the symbol naturally prompts its usage as the next step in the same development session. Both edits can be staged in either order since Python allows referencing undefined symbols at parse time (would only fail at runtime/import time), making this bi-directional."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 imports ProhibitNullCharactersValidator from django.core.validators, and Edit 1 uses that exact same imported symbol ProhibitNullCharactersValidator in the CharField class. The changed lines reference the exact same symbol - Edit 0 makes it available via import, and Edit 1 uses it. This creates an immediate code dependency where importing the symbol naturally prompts its usage as the next step in the same development session. Both edits can be staged in either order since Python allows referencing undefined symbols at parse time (would only fail at runtime/import time), making this bi-directional."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 defines/imports ProhibitNullCharactersValidator in rest_framework/compat.py, while Edit 1 imports that exact same symbol from rest_framework.compat in tests/test_fields.py. The changed lines reference the exact same symbol - ProhibitNullCharactersValidator. After making Edit 0, the symbol becomes available for import, making Edit 1 a natural next step. After making Edit 1, if the symbol wasn't already defined in compat.py, it would create an import error, making Edit 0 necessary. Both edits can be staged in either order (Edit 1 would cause a runtime ImportError but not a parse error), so this is a bi-directional definition-usage relationship."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 defines/imports ProhibitNullCharactersValidator in rest_framework/compat.py, while Edit 1 imports that exact same symbol from rest_framework.compat in tests/test_fields.py. The changed lines reference the exact same symbol - ProhibitNullCharactersValidator. After making Edit 0, the symbol becomes available for import, making Edit 1 a natural next step. After making Edit 1, if the symbol wasn't already defined in compat.py, it would create an import error, making Edit 0 necessary. Both edits can be staged in either order (Edit 1 would cause a runtime ImportError but not a parse error), so this is a bi-directional definition-usage relationship."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 defines/imports ProhibitNullCharactersValidator in rest_framework/compat.py, while Edit 1 imports that exact same symbol in rest_framework/fields.py from the compat module. The changed lines reference the exact same symbol - ProhibitNullCharactersValidator. After making Edit 0 (defining the symbol), Edit 1 becomes the immediate next step to import and use that symbol. After making Edit 1 (importing the symbol), Edit 0 would be the required step to ensure the symbol exists. This is a classic definition-usage relationship where both edits can be staged in either order (the import in Edit 1 would cause a runtime ImportError if Edit 0 hasn't been made, but both edits can be parsed and staged independently)."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 defines/imports ProhibitNullCharactersValidator in rest_framework/compat.py, while Edit 1 imports that exact same symbol in rest_framework/fields.py from the compat module. The changed lines reference the exact same symbol - ProhibitNullCharactersValidator. After making Edit 0 (defining the symbol), Edit 1 becomes the immediate next step to import and use that symbol. After making Edit 1 (importing the symbol), Edit 0 would be the required step to ensure the symbol exists. This is a classic definition-usage relationship where both edits can be staged in either order (the import in Edit 1 would cause a runtime ImportError if Edit 0 hasn't been made, but both edits can be parsed and staged independently)."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 imports ProhibitNullCharactersValidator in rest_framework/compat.py, making it available for use. Edit 1 uses this exact same symbol in rest_framework/fields.py by checking if ProhibitNullCharactersValidator is not None and then instantiating it. This is a classic import-usage pattern where the changed lines reference the exact same symbol. The usage in edit 1 would cause a NameError at runtime if edit 0 hasn't been made, but since Python allows referencing undefined symbols at parse time (only failing at runtime), both edits can be staged in either order. This makes it bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 imports ProhibitNullCharactersValidator in rest_framework/compat.py, making it available for use. Edit 1 uses this exact same symbol in rest_framework/fields.py by checking if ProhibitNullCharactersValidator is not None and then instantiating it. This is a classic import-usage pattern where the changed lines reference the exact same symbol. The usage in edit 1 would cause a NameError at runtime if edit 0 hasn't been made, but since Python allows referencing undefined symbols at parse time (only failing at runtime), both edits can be staged in either order. This makes it bi-directional rather than ordered."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 imports ProhibitNullCharactersValidator from rest_framework.compat, and Edit 1 uses this exact same symbol in a pytest.mark.skipif decorator condition. The changed lines reference the same symbol - Edit 0 makes it available via import, and Edit 1 uses it in the test condition. This creates an immediate code dependency where importing the symbol naturally prompts its usage in the test, and using it in the test requires the import to be present. Both edits can be staged in either order since Python allows referencing undefined names at parse time (would only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 imports ProhibitNullCharactersValidator from rest_framework.compat, and Edit 1 uses this exact same symbol in a pytest.mark.skipif decorator condition. The changed lines reference the same symbol - Edit 0 makes it available via import, and Edit 1 uses it in the test condition. This creates an immediate code dependency where importing the symbol naturally prompts its usage in the test, and using it in the test requires the import to be present. Both edits can be staged in either order since Python allows referencing undefined names at parse time (would only fail at runtime), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'ProhibitNullCharactersValidator' in their changed lines. Edit 0 adds code that checks if ProhibitNullCharactersValidator is not None and appends it to validators in the CharField class. Edit 1 adds a test that uses pytest.mark.skipif with the same ProhibitNullCharactersValidator symbol to conditionally skip the test. The test is specifically testing the functionality that edit 0 implements - null character validation. Both edits are part of implementing the same feature where the production code adds the validator and the test code verifies its behavior. Either edit could be made first and would create an immediate prompt for the other as part of the same development task."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'ProhibitNullCharactersValidator' in their changed lines. Edit 0 adds code that checks if ProhibitNullCharactersValidator is not None and appends it to validators in the CharField class. Edit 1 adds a test that uses pytest.mark.skipif with the same ProhibitNullCharactersValidator symbol to conditionally skip the test. The test is specifically testing the functionality that edit 0 implements - null character validation. Both edits are part of implementing the same feature where the production code adds the validator and the test code verifies its behavior. Either edit could be made first and would create an immediate prompt for the other as part of the same development task."
        }
    ],
    "allowed_init_edits": [
        2
    ]
}