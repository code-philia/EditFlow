{
    "partial_orders": [
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 raises RemoteServerDeactivatedError() in the validate_api_key function, while Edit 1 defines the RemoteServerDeactivatedError class. The changed lines reference the exact same symbol - RemoteServerDeactivatedError. Edit 0 cannot be parsed/staged without Edit 1 since it references an undefined class, creating a NameError at import time when the decorator module is loaded. This is a definition-usage relationship where the usage edit cannot exist without the definition edit being present first."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'RemoteServerDeactivatedError'. Edit 0 imports this exception class, while Edit 1 raises an instance of this same exception class. After importing the exception in Edit 0, Edit 1 becomes the immediate next step to use that imported exception. Conversely, if Edit 1 were made first, it would create an undefined symbol error that would immediately prompt the import in Edit 0. This is a classic import-usage relationship for the same symbol within the same file."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'RemoteServerDeactivatedError'. Edit 0 imports this exception class, while Edit 1 raises an instance of this same exception class. After importing the exception in Edit 0, Edit 1 becomes the immediate next step to use that imported exception. Conversely, if Edit 1 were made first, it would create an undefined symbol error that would immediately prompt the import in Edit 0. This is a classic import-usage relationship for the same symbol within the same file."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 1 defines a new class 'RemoteServerDeactivatedError' and Edit 0 imports that exact same class. The changed lines reference the exact same symbol - 'RemoteServerDeactivatedError'. After defining the class in edit 1, importing it in edit 0 becomes the immediate next step to make it available for use. Conversely, after importing it in edit 0, the definition in edit 1 is needed for the import to resolve. Both edits can be staged in either order since Python allows importing undefined symbols (they fail at runtime, not parse time), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 1 defines a new class 'RemoteServerDeactivatedError' and Edit 0 imports that exact same class. The changed lines reference the exact same symbol - 'RemoteServerDeactivatedError'. After defining the class in edit 1, importing it in edit 0 becomes the immediate next step to make it available for use. Conversely, after importing it in edit 0, the definition in edit 1 is needed for the import to resolve. Both edits can be staged in either order since Python allows importing undefined symbols (they fail at runtime, not parse time), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'server' in the same method context. Edit 0 changes the assignment from 'server = RemoteZulipServer(...)' to 'self.server = RemoteZulipServer(...)', and Edit 1 changes the method call from 'server.save()' to 'self.server.save()'. This is a synchronized refactoring where a local variable is being converted to an instance attribute. Both changed lines reference the same symbol and the edits form part of a single, contiguous micro-task of converting from local variable to instance attribute usage. Either edit can be made first since both are syntactically valid - the relationship is bi-directional as making either edit creates an immediate prompt for the other to maintain consistency."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'server' in the same method context. Edit 0 changes the assignment from 'server = RemoteZulipServer(...)' to 'self.server = RemoteZulipServer(...)', and Edit 1 changes the method call from 'server.save()' to 'self.server.save()'. This is a synchronized refactoring where a local variable is being converted to an instance attribute. Both changed lines reference the same symbol and the edits form part of a single, contiguous micro-task of converting from local variable to instance attribute usage. Either edit can be made first since both are syntactically valid - the relationship is bi-directional as making either edit creates an immediate prompt for the other to maintain consistency."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Edit 0 changes 'server.save()' to 'self.server.save()' in the setUp method of BouncerTestCase, establishing 'self.server' as the correct reference. Edit 1 uses 'self.server' in a test method within PushBouncerNotificationTest (which inherits from BouncerTestCase). Both edits reference the exact same symbol 'self.server' - edit 0 establishes the proper reference pattern and edit 1 follows that pattern. However, edit 1 can be written and parsed independently of edit 0, as the 'self.server' reference would simply fail at runtime if the setUp wasn't corrected. Since both edits can be staged in either order without parser errors, this is bi-directional."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Edit 0 changes 'server.save()' to 'self.server.save()' in the setUp method of BouncerTestCase, establishing 'self.server' as the correct reference. Edit 1 uses 'self.server' in a test method within PushBouncerNotificationTest (which inherits from BouncerTestCase). Both edits reference the exact same symbol 'self.server' - edit 0 establishes the proper reference pattern and edit 1 follows that pattern. However, edit 1 can be written and parsed independently of edit 0, as the 'self.server' reference would simply fail at runtime if the setUp wasn't corrected. Since both edits can be staged in either order without parser errors, this is bi-directional."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 changes 'server.save()' to 'self.server.save()' in the setUp method of BouncerTestCase, establishing 'self.server' as the correct reference. Edit 1 uses 'self.server.deactivated = True' and 'self.server.save()' in a test method within PushBouncerNotificationTest, which inherits from BouncerTestCase. Both edits reference the exact same symbol 'self.server' that was established in edit 0. The changed lines in both edits explicitly reference the same server object, making this a direct code dependency where either edit could prompt the other as the next mechanical step in handling the server object correctly."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 changes 'server.save()' to 'self.server.save()' in the setUp method of BouncerTestCase, establishing 'self.server' as the correct reference. Edit 1 uses 'self.server.deactivated = True' and 'self.server.save()' in a test method within PushBouncerNotificationTest, which inherits from BouncerTestCase. Both edits reference the exact same symbol 'self.server' that was established in edit 0. The changed lines in both edits explicitly reference the same server object, making this a direct code dependency where either edit could prompt the other as the next mechanical step in handling the server object correctly."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 changes the assignment from a local variable 'server' to an instance attribute 'self.server' in the setUp method of BouncerTestCase. Edit 1 uses this same 'self.server' attribute in a test method of PushBouncerNotificationTest (which inherits from BouncerTestCase). The changed lines in both edits reference the exact same symbol 'self.server'. Edit 0 makes the server object available as an instance attribute, and Edit 1 uses that instance attribute. This creates a direct code dependency where Edit 1's usage of 'self.server' depends on Edit 0's creation of that attribute. However, since Edit 1 can be written and parsed without Edit 0 (it would just result in a runtime AttributeError), and both edits can be staged in either order, this is bi-directional rather than ordered."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 changes the assignment from a local variable 'server' to an instance attribute 'self.server' in the setUp method of BouncerTestCase. Edit 1 uses this same 'self.server' attribute in a test method of PushBouncerNotificationTest (which inherits from BouncerTestCase). The changed lines in both edits reference the exact same symbol 'self.server'. Edit 0 makes the server object available as an instance attribute, and Edit 1 uses that instance attribute. This creates a direct code dependency where Edit 1's usage of 'self.server' depends on Edit 0's creation of that attribute. However, since Edit 1 can be written and parsed without Edit 0 (it would just result in a runtime AttributeError), and both edits can be staged in either order, this is bi-directional rather than ordered."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Edit 0 assigns a RemoteZulipServer instance to self.server in the setUp method of BouncerTestCase. Edit 1 uses self.server in a test method within PushBouncerNotificationTest, which inherits from BouncerTestCase. Both edits reference the exact same symbol (self.server) - edit 0 defines it and edit 1 uses it. This creates a direct definition-usage relationship where the changed lines reference the same symbol. Since PushBouncerNotificationTest inherits from BouncerTestCase, the self.server defined in setUp is the same symbol being used in the test method. Either edit can be staged first without causing parse errors, making this bi-directional."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Edit 0 assigns a RemoteZulipServer instance to self.server in the setUp method of BouncerTestCase. Edit 1 uses self.server in a test method within PushBouncerNotificationTest, which inherits from BouncerTestCase. Both edits reference the exact same symbol (self.server) - edit 0 defines it and edit 1 uses it. This creates a direct definition-usage relationship where the changed lines reference the same symbol. Since PushBouncerNotificationTest inherits from BouncerTestCase, the self.server defined in setUp is the same symbol being used in the test method. Either edit can be staged first without causing parse errors, making this bi-directional."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits add nearly identical test code blocks that test deactivated remote servers. They follow the same pattern: set self.server.deactivated = True, save the server, make a uuid_post call, and assert the same error message. The only difference is the payload parameter ('unregister' vs 'register'). This represents a bulk-edit pattern where the same structural test logic is being added to multiple test methods within the same test class. Both edits involve identical code structure and serve the same testing purpose, making either edit naturally prompt the addition of the other as part of a single, contiguous refactoring task to add deactivated server testing across related endpoints."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits add nearly identical test code blocks that test deactivated remote servers. They follow the same pattern: set self.server.deactivated = True, save the server, make a uuid_post call, and assert the same error message. The only difference is the payload parameter ('unregister' vs 'register'). This represents a bulk-edit pattern where the same structural test logic is being added to multiple test methods within the same test class. Both edits involve identical code structure and serve the same testing purpose, making either edit naturally prompt the addition of the other as part of a single, contiguous refactoring task to add deactivated server testing across related endpoints."
        }
    ],
    "allowed_init_edits": [
        2
    ]
}