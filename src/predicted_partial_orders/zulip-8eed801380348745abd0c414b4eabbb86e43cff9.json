{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution, changing the hardcoded string '@role:members' to the constant 'UserGroup.MEMBERS_GROUP_NAME' in the same type of syntactic construct (UserGroup.objects.get() calls with the name parameter). This is a clear bulk refactoring operation where the same before\u2192after pattern is applied to the same construct type across multiple files. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution, changing the hardcoded string '@role:members' to the constant 'UserGroup.MEMBERS_GROUP_NAME' in the same type of syntactic construct (UserGroup.objects.get() calls with the name parameter). This is a clear bulk refactoring operation where the same before\u2192after pattern is applied to the same construct type across multiple files. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution, replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME in UserGroup.objects.get() calls. This is a uniform refactoring pattern where the same before\u2192after substitution is applied to the same type of syntactic construct (method calls with the same parameter structure). Both edits are part of a single refactoring effort to replace magic strings with named constants, and either edit could be made first as they are independent changes that follow the same substitution pattern."
        },
        {
            "src": 7,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution, replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME in UserGroup.objects.get() calls. This is a uniform refactoring pattern where the same before\u2192after substitution is applied to the same type of syntactic construct (method calls with the same parameter structure). Both edits are part of a single refactoring effort to replace magic strings with named constants, and either edit could be made first as they are independent changes that follow the same substitution pattern."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution, replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME in UserGroup.objects.get() calls. This is a uniform refactoring pattern applied to the same type of syntactic construct (method calls with the same parameter structure). Both edits reference the exact same constant symbol (UserGroup.MEMBERS_GROUP_NAME) and represent a single, contiguous refactor to eliminate magic strings. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the consistent refactoring pattern."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution, replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME in UserGroup.objects.get() calls. This is a uniform refactoring pattern applied to the same type of syntactic construct (method calls with the same parameter structure). Both edits reference the exact same constant symbol (UserGroup.MEMBERS_GROUP_NAME) and represent a single, contiguous refactor to eliminate magic strings. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the consistent refactoring pattern."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits are replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a bulk uniform substitution pattern where both edits perform the identical textual substitution (hardcoded string \u2192 constant) on the same type of syntactic construct (string literals referencing the same group name). Both edits reference the exact same symbol/concept (the members group name) and are clearly part of a single refactoring operation to replace magic strings with named constants. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits are replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a bulk uniform substitution pattern where both edits perform the identical textual substitution (hardcoded string \u2192 constant) on the same type of syntactic construct (string literals referencing the same group name). Both edits reference the exact same symbol/concept (the members group name) and are clearly part of a single refactoring operation to replace magic strings with named constants. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol: UserGroup.MEMBERS_GROUP_NAME. Edit 0 changes a hardcoded string '@role:members' to use the constant UserGroup.MEMBERS_GROUP_NAME, while Edit 1 changes another hardcoded string '@role:members' to use the same constant MEMBERS_GROUP_NAME (within the UserGroup class context). This is a clear case of bulk uniform substitution where both edits perform the identical textual substitution (replacing '@role:members' with the constant reference) and target the same type of syntactic construct (string literals being replaced with constant references). Both edits are part of a single refactoring operation to eliminate hardcoded strings in favor of a named constant."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol: UserGroup.MEMBERS_GROUP_NAME. Edit 0 changes a hardcoded string '@role:members' to use the constant UserGroup.MEMBERS_GROUP_NAME, while Edit 1 changes another hardcoded string '@role:members' to use the same constant MEMBERS_GROUP_NAME (within the UserGroup class context). This is a clear case of bulk uniform substitution where both edits perform the identical textual substitution (replacing '@role:members' with the constant reference) and target the same type of syntactic construct (string literals being replaced with constant references). Both edits are part of a single refactoring operation to eliminate hardcoded strings in favor of a named constant."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol: UserGroup.MEMBERS_GROUP_NAME. Edit 0 changes a hardcoded string '@role:members' to use the constant UserGroup.MEMBERS_GROUP_NAME, while edit 1 changes another hardcoded string '@role:members' to use the same constant MEMBERS_GROUP_NAME (within the UserGroup class context). This is a bulk uniform substitution pattern where both edits perform the identical textual substitution (hardcoded string \u2192 constant reference) on the same type of syntactic construct (string literals). Both edits can be staged in either order without causing parse errors, and either edit naturally prompts the other as part of the same refactoring sweep to replace hardcoded strings with the named constant."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol: UserGroup.MEMBERS_GROUP_NAME. Edit 0 changes a hardcoded string '@role:members' to use the constant UserGroup.MEMBERS_GROUP_NAME, while edit 1 changes another hardcoded string '@role:members' to use the same constant MEMBERS_GROUP_NAME (within the UserGroup class context). This is a bulk uniform substitution pattern where both edits perform the identical textual substitution (hardcoded string \u2192 constant reference) on the same type of syntactic construct (string literals). Both edits can be staged in either order without causing parse errors, and either edit naturally prompts the other as part of the same refactoring sweep to replace hardcoded strings with the named constant."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution, replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform refactoring pattern where the same before\u2192after substitution is applied to the same type of syntactic construct (string literals referencing the same system group name) across different files. Both edits reference the exact same conceptual symbol (the members group name) and represent a synchronized code cleanup to replace magic strings with named constants. Either edit could be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution, replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform refactoring pattern where the same before\u2192after substitution is applied to the same type of syntactic construct (string literals referencing the same system group name) across different files. Both edits reference the exact same conceptual symbol (the members group name) and represent a synchronized code cleanup to replace magic strings with named constants. Either edit could be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME in UserGroup.objects.get() calls. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (UserGroup.objects.get calls with name parameter). Both edits are part of a single refactoring sweep to replace magic strings with named constants, and either edit could be made first as they are independent changes that follow the same substitution pattern."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME in UserGroup.objects.get() calls. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (UserGroup.objects.get calls with name parameter). Both edits are part of a single refactoring sweep to replace magic strings with named constants, and either edit could be made first as they are independent changes that follow the same substitution pattern."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 1 defines a new class constant MEMBERS_GROUP_NAME with the value '@role:members', while Edit 0 changes a hardcoded string '@role:members' to use UserGroup.MEMBERS_GROUP_NAME. The changed line in Edit 0 explicitly references the exact same symbol (UserGroup.MEMBERS_GROUP_NAME) that is being defined in Edit 1. This creates a direct definition-usage relationship where both edits reference the same symbol. In Python, both edits can be staged in either order since the usage in Edit 0 would only cause a runtime AttributeError if staged before Edit 1, not a parse-time syntax error. After making either edit, the other becomes the immediate next step to complete the refactoring from hardcoded string to named constant."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 1 defines a new class constant MEMBERS_GROUP_NAME with the value '@role:members', while Edit 0 changes a hardcoded string '@role:members' to use UserGroup.MEMBERS_GROUP_NAME. The changed line in Edit 0 explicitly references the exact same symbol (UserGroup.MEMBERS_GROUP_NAME) that is being defined in Edit 1. This creates a direct definition-usage relationship where both edits reference the same symbol. In Python, both edits can be staged in either order since the usage in Edit 0 would only cause a runtime AttributeError if staged before Edit 1, not a parse-time syntax error. After making either edit, the other becomes the immediate next step to complete the refactoring from hardcoded string to named constant."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform refactoring pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (string literals) across different files. Both edits reference the exact same symbol (UserGroup.MEMBERS_GROUP_NAME) and represent a single, contiguous refactoring task to eliminate hardcoded strings in favor of named constants. Either edit could be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform refactoring pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (string literals) across different files. Both edits reference the exact same symbol (UserGroup.MEMBERS_GROUP_NAME) and represent a single, contiguous refactoring task to eliminate hardcoded strings in favor of named constants. Either edit could be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 1 defines a new class constant MEMBERS_GROUP_NAME in the UserGroup class, while Edit 0 uses that exact same constant (UserGroup.MEMBERS_GROUP_NAME) to replace a hardcoded string. The changed lines reference the exact same symbol - the MEMBERS_GROUP_NAME constant. After making either edit, the other becomes the immediate next step: if you define the constant first, you'd naturally want to use it to replace the hardcoded string; if you try to use the constant first, you'd need to define it. Both edits can be parsed and staged in either order (using an undefined constant in Python only causes a runtime AttributeError, not a parse error), making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 1 defines a new class constant MEMBERS_GROUP_NAME in the UserGroup class, while Edit 0 uses that exact same constant (UserGroup.MEMBERS_GROUP_NAME) to replace a hardcoded string. The changed lines reference the exact same symbol - the MEMBERS_GROUP_NAME constant. After making either edit, the other becomes the immediate next step: if you define the constant first, you'd naturally want to use it to replace the hardcoded string; if you try to use the constant first, you'd need to define it. Both edits can be parsed and staged in either order (using an undefined constant in Python only causes a runtime AttributeError, not a parse error), making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits are replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform textual substitution pattern where the same before\u2192after transformation (hardcoded string to named constant) is being applied to the same type of syntactic construct (string literals referencing the same group name). Both edits reference the exact same semantic symbol (the members group name) and are clearly part of a single refactoring operation to replace magic strings with named constants."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits are replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform textual substitution pattern where the same before\u2192after transformation (hardcoded string to named constant) is being applied to the same type of syntactic construct (string literals referencing the same group name). Both edits reference the exact same semantic symbol (the members group name) and are clearly part of a single refactoring operation to replace magic strings with named constants."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 defines a new class constant MEMBERS_GROUP_NAME with the value '@role:members', while Edit 1 replaces the hardcoded string '@role:members' with a reference to MEMBERS_GROUP_NAME. Both edits reference the exact same symbol (MEMBERS_GROUP_NAME) within the same class context. This is a classic definition-usage pattern where defining the constant creates an immediate prompt to replace the hardcoded string with the constant reference. Since Python allows referencing undefined variables at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 defines a new class constant MEMBERS_GROUP_NAME with the value '@role:members', while Edit 1 replaces the hardcoded string '@role:members' with a reference to MEMBERS_GROUP_NAME. Both edits reference the exact same symbol (MEMBERS_GROUP_NAME) within the same class context. This is a classic definition-usage pattern where defining the constant creates an immediate prompt to replace the hardcoded string with the constant reference. Since Python allows referencing undefined variables at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string \"@role:members\" with the constant UserGroup.MEMBERS_GROUP_NAME in UserGroup.objects.get() calls. This is a clear bulk refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (UserGroup.objects.get calls with name parameter). Both edits reference the exact same constant (UserGroup.MEMBERS_GROUP_NAME) and represent a synchronized refactoring to replace magic strings with named constants. Either edit could be made first as part of this uniform substitution pattern."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string \"@role:members\" with the constant UserGroup.MEMBERS_GROUP_NAME in UserGroup.objects.get() calls. This is a clear bulk refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (UserGroup.objects.get calls with name parameter). Both edits reference the exact same constant (UserGroup.MEMBERS_GROUP_NAME) and represent a synchronized refactoring to replace magic strings with named constants. Either edit could be made first as part of this uniform substitution pattern."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol MEMBERS_GROUP_NAME from the UserGroup class. Edit 0 changes from a string literal to UserGroup.MEMBERS_GROUP_NAME, while edit 1 changes from the same string literal to UserGroup.MEMBERS_GROUP_NAME. This is a synchronized substitution pattern where both edits perform the identical textual substitution (replacing '@role:members' with MEMBERS_GROUP_NAME) and both can be staged in either order without causing parse errors. The relationship is bi-directional because either edit can be made first, and after making either one, the other becomes the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol MEMBERS_GROUP_NAME from the UserGroup class. Edit 0 changes from a string literal to UserGroup.MEMBERS_GROUP_NAME, while edit 1 changes from the same string literal to UserGroup.MEMBERS_GROUP_NAME. This is a synchronized substitution pattern where both edits perform the identical textual substitution (replacing '@role:members' with MEMBERS_GROUP_NAME) and both can be staged in either order without causing parse errors. The relationship is bi-directional because either edit can be made first, and after making either one, the other becomes the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 defines a new constant MEMBERS_GROUP_NAME with the value '@role:members' in the UserGroup class. Edit 1 changes a hardcoded string '@role:members' to use the newly defined constant UserGroup.MEMBERS_GROUP_NAME. Both edits reference the exact same symbol (MEMBERS_GROUP_NAME) - edit 0 defines it and edit 1 uses it. This creates an immediate code-driven relationship where defining the constant naturally prompts replacing hardcoded strings with the constant reference. Both edits can be staged in either order since Python allows referencing undefined attributes at parse time (would only fail at runtime), making this bi-directional."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 defines a new constant MEMBERS_GROUP_NAME with the value '@role:members' in the UserGroup class. Edit 1 changes a hardcoded string '@role:members' to use the newly defined constant UserGroup.MEMBERS_GROUP_NAME. Both edits reference the exact same symbol (MEMBERS_GROUP_NAME) - edit 0 defines it and edit 1 uses it. This creates an immediate code-driven relationship where defining the constant naturally prompts replacing hardcoded strings with the constant reference. Both edits can be staged in either order since Python allows referencing undefined attributes at parse time (would only fail at runtime), making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 defines a new class constant MEMBERS_GROUP_NAME with the value '@role:members' in the UserGroup class. Edit 1 replaces the hardcoded string '@role:members' with a reference to UserGroup.MEMBERS_GROUP_NAME. The changed lines reference the exact same symbol - MEMBERS_GROUP_NAME is being defined in edit 0 and used in edit 1. This creates an immediate code-driven relationship where defining the constant naturally prompts updating the hardcoded usage, and vice versa. Both edits can be staged in either order without parser errors (the usage would just reference an undefined attribute until the definition is added, causing a runtime AttributeError but not a syntax error)."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 defines a new class constant MEMBERS_GROUP_NAME with the value '@role:members' in the UserGroup class. Edit 1 replaces the hardcoded string '@role:members' with a reference to UserGroup.MEMBERS_GROUP_NAME. The changed lines reference the exact same symbol - MEMBERS_GROUP_NAME is being defined in edit 0 and used in edit 1. This creates an immediate code-driven relationship where defining the constant naturally prompts updating the hardcoded usage, and vice versa. Both edits can be staged in either order without parser errors (the usage would just reference an undefined attribute until the definition is added, causing a runtime AttributeError but not a syntax error)."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Edit 0 defines a new class constant MEMBERS_GROUP_NAME with the value '@role:members', while Edit 1 changes a hardcoded string '@role:members' to use UserGroup.MEMBERS_GROUP_NAME. The changed lines reference the exact same symbol - UserGroup.MEMBERS_GROUP_NAME. After defining the constant in Edit 0, using it in Edit 1 becomes the immediate next step to replace the hardcoded string. This is a classic definition-usage pattern where both edits can be staged in either order (the usage would just reference an undefined attribute until the definition is added, causing a runtime AttributeError but no parse error)."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Edit 0 defines a new class constant MEMBERS_GROUP_NAME with the value '@role:members', while Edit 1 changes a hardcoded string '@role:members' to use UserGroup.MEMBERS_GROUP_NAME. The changed lines reference the exact same symbol - UserGroup.MEMBERS_GROUP_NAME. After defining the constant in Edit 0, using it in Edit 1 becomes the immediate next step to replace the hardcoded string. This is a classic definition-usage pattern where both edits can be staged in either order (the usage would just reference an undefined attribute until the definition is added, causing a runtime AttributeError but no parse error)."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbol: UserGroup.MEMBERS_GROUP_NAME. Edit 0 changes a hardcoded string '@role:members' to use the constant MEMBERS_GROUP_NAME, while edit 1 updates a test assertion to use UserGroup.MEMBERS_GROUP_NAME instead of the hardcoded string '@role:members'. These are part of the same refactoring operation - replacing hardcoded strings with a named constant. After making either edit, the other becomes the immediate next step to maintain consistency between the implementation and its test. Both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol: UserGroup.MEMBERS_GROUP_NAME. Edit 0 changes a hardcoded string '@role:members' to use the constant MEMBERS_GROUP_NAME, while edit 1 updates a test assertion to use UserGroup.MEMBERS_GROUP_NAME instead of the hardcoded string '@role:members'. These are part of the same refactoring operation - replacing hardcoded strings with a named constant. After making either edit, the other becomes the immediate next step to maintain consistency between the implementation and its test. Both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits replace the hardcoded string '@role:members' with the same constant MEMBERS_GROUP_NAME. Edit 0 changes the definition in the UserGroup model where MEMBERS_GROUP_NAME is assigned as the name value, while Edit 1 changes a test that queries for a UserGroup with that same name. Both changed lines reference the exact same symbol (MEMBERS_GROUP_NAME) and represent a synchronized substitution pattern - replacing the same hardcoded string with the same constant across different locations. This is a bulk refactoring operation where either edit can be made first, and after making either edit, the other becomes the natural next step to complete the consistent replacement pattern."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits replace the hardcoded string '@role:members' with the same constant MEMBERS_GROUP_NAME. Edit 0 changes the definition in the UserGroup model where MEMBERS_GROUP_NAME is assigned as the name value, while Edit 1 changes a test that queries for a UserGroup with that same name. Both changed lines reference the exact same symbol (MEMBERS_GROUP_NAME) and represent a synchronized substitution pattern - replacing the same hardcoded string with the same constant across different locations. This is a bulk refactoring operation where either edit can be made first, and after making either edit, the other becomes the natural next step to complete the consistent replacement pattern."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 defines a new class constant MEMBERS_GROUP_NAME with the value '@role:members' in the UserGroup class. Edit 1 updates test code to reference this newly defined constant UserGroup.MEMBERS_GROUP_NAME instead of the hardcoded string '@role:members'. The changed lines reference the exact same symbol - MEMBERS_GROUP_NAME - where edit 0 defines it and edit 1 uses it. This creates an immediate code-driven prompt: after defining the constant, the next natural step is to replace hardcoded usages with the constant reference. Both edits can be staged in either order since Python allows referencing undefined attributes (would only fail at runtime), making this bi-directional."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 defines a new class constant MEMBERS_GROUP_NAME with the value '@role:members' in the UserGroup class. Edit 1 updates test code to reference this newly defined constant UserGroup.MEMBERS_GROUP_NAME instead of the hardcoded string '@role:members'. The changed lines reference the exact same symbol - MEMBERS_GROUP_NAME - where edit 0 defines it and edit 1 uses it. This creates an immediate code-driven prompt: after defining the constant, the next natural step is to replace hardcoded usages with the constant reference. Both edits can be staged in either order since Python allows referencing undefined attributes (would only fail at runtime), making this bi-directional."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "Both edits replace the hardcoded string '@role:members' with the same constant MEMBERS_GROUP_NAME/UserGroup.MEMBERS_GROUP_NAME. Edit 0 changes the definition in the UserGroup model where MEMBERS_GROUP_NAME is assigned, while Edit 1 changes a test that queries for a group with that name. Both edits reference the exact same symbol (the members group name) and perform identical textual substitution (replacing '@role:members' with the constant). This is a synchronized refactoring where either edit can be made first, and after making either edit, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "Both edits replace the hardcoded string '@role:members' with the same constant MEMBERS_GROUP_NAME/UserGroup.MEMBERS_GROUP_NAME. Edit 0 changes the definition in the UserGroup model where MEMBERS_GROUP_NAME is assigned, while Edit 1 changes a test that queries for a group with that name. Both edits reference the exact same symbol (the members group name) and perform identical textual substitution (replacing '@role:members' with the constant). This is a synchronized refactoring where either edit can be made first, and after making either edit, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform refactoring operation targeting the same type of syntactic construct (string literals referencing the same system group) within the same test file. Both changed lines reference the exact same conceptual entity (the members system group) and represent a synchronized pattern substitution that would naturally occur as part of a single, contiguous refactoring task to replace hardcoded strings with named constants."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform refactoring operation targeting the same type of syntactic construct (string literals referencing the same system group) within the same test file. Both changed lines reference the exact same conceptual entity (the members system group) and represent a synchronized pattern substitution that would naturally occur as part of a single, contiguous refactoring task to replace hardcoded strings with named constants."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform the identical textual substitution of '@role:members' with 'UserGroup.MEMBERS_GROUP_NAME' in test assertion contexts. This is a uniform, synchronized substitution pattern targeting the same type of syntactic construct (string literals in test assertions) as part of what appears to be a single refactoring operation to replace hardcoded role strings with named constants. The changed lines in both edits reference the exact same symbol (UserGroup.MEMBERS_GROUP_NAME) and perform the same before\u2192after pattern substitution."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform the identical textual substitution of '@role:members' with 'UserGroup.MEMBERS_GROUP_NAME' in test assertion contexts. This is a uniform, synchronized substitution pattern targeting the same type of syntactic construct (string literals in test assertions) as part of what appears to be a single refactoring operation to replace hardcoded role strings with named constants. The changed lines in both edits reference the exact same symbol (UserGroup.MEMBERS_GROUP_NAME) and perform the same before\u2192after pattern substitution."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME in UserGroup.objects.get() calls. This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (method calls with name parameter) across multiple files. Both edits are part of a single, contiguous refactor to replace magic strings with named constants. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME in UserGroup.objects.get() calls. This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (method calls with name parameter) across multiple files. Both edits are part of a single, contiguous refactor to replace magic strings with named constants. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string literals referencing the same system group name). Both edits are part of a single refactoring sweep to replace hardcoded group names with named constants, and either edit could be made first as they are independent substitutions of the same pattern."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string literals referencing the same system group name). Both edits are part of a single refactoring sweep to replace hardcoded group names with named constants, and either edit could be made first as they are independent substitutions of the same pattern."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits are replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform textual substitution pattern where the same before\u2192after transformation (hardcoded string to constant) is being applied to the same type of syntactic construct (string literals referencing the same group name). Both edits reference the exact same logical entity (the members group) and are part of a single refactoring operation to replace magic strings with named constants. Either edit can be made first, and both are part of the same contiguous micro-task of eliminating hardcoded group names."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits are replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform textual substitution pattern where the same before\u2192after transformation (hardcoded string to constant) is being applied to the same type of syntactic construct (string literals referencing the same group name). Both edits reference the exact same logical entity (the members group) and are part of a single refactoring operation to replace magic strings with named constants. Either edit can be made first, and both are part of the same contiguous micro-task of eliminating hardcoded group names."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string literals in function calls) across different files. Both edits reference the exact same symbol (UserGroup.MEMBERS_GROUP_NAME) and represent a single, contiguous refactoring task to replace hardcoded strings with named constants. Either edit could be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string '@role:members' with the constant UserGroup.MEMBERS_GROUP_NAME. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (string literals in function calls) across different files. Both edits reference the exact same symbol (UserGroup.MEMBERS_GROUP_NAME) and represent a single, contiguous refactoring task to replace hardcoded strings with named constants. Either edit could be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        }
    ],
    "allowed_init_edits": [
        0,
        5,
        7,
        1,
        6,
        3,
        4,
        2
    ]
}