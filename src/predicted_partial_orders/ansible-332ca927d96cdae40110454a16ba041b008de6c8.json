{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern within the same function: changing 'not value' to 'value is None' in conditional expressions. This is a uniform refactoring operation where the same logical change is being applied to multiple similar code constructs within the same method. The edits target the same type of syntactic construct (conditional expressions) and apply the exact same before\u2192after pattern. This represents a single, contiguous micro-task of standardizing truthiness checks throughout the method."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern within the same function: changing 'not value' to 'value is None' in conditional expressions. This is a uniform refactoring operation where the same logical change is being applied to multiple similar code constructs within the same method. The edits target the same type of syntactic construct (conditional expressions) and apply the exact same before\u2192after pattern. This represents a single, contiguous micro-task of standardizing truthiness checks throughout the method."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern, changing 'not value' to 'value is None' in conditional expressions within methods named '_get_parent_attribute'. This represents a uniform refactoring operation targeting the same type of syntactic construct (conditional expressions) with the exact same before\u2192after pattern. The edits appear to be part of a single, contiguous refactor to improve null checking semantics across related classes in the same codebase."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern, changing 'not value' to 'value is None' in conditional expressions within methods named '_get_parent_attribute'. This represents a uniform refactoring operation targeting the same type of syntactic construct (conditional expressions) with the exact same before\u2192after pattern. The edits appear to be part of a single, contiguous refactor to improve null checking semantics across related classes in the same codebase."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution within the same function `_get_parent_attribute`. They both change the condition from `(not value or extend)` to `(value is None or extend)` in similar conditional statements. This is a uniform pattern-based refactor where the same logical change is being applied to multiple locations within the same method. The edits reference the same variables (`value` and `extend`) and apply the same transformation pattern, making them part of a single, contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution within the same function `_get_parent_attribute`. They both change the condition from `(not value or extend)` to `(value is None or extend)` in similar conditional statements. This is a uniform pattern-based refactor where the same logical change is being applied to multiple locations within the same method. The edits reference the same variables (`value` and `extend`) and apply the same transformation pattern, making them part of a single, contiguous refactoring task."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in the same type of syntactic construct (conditional expressions within _get_parent_attribute methods). This represents a uniform refactoring operation where the same logical fix is being applied to structurally identical code patterns across different classes. The edits target the same type of conditional logic bug fix and would naturally be part of a single, contiguous refactoring sweep to address the same issue in multiple locations."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in the same type of syntactic construct (conditional expressions within _get_parent_attribute methods). This represents a uniform refactoring operation where the same logical fix is being applied to structurally identical code patterns across different classes. The edits target the same type of conditional logic bug fix and would naturally be part of a single, contiguous refactoring sweep to address the same issue in multiple locations."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern within the same function: changing 'not value' to 'value is None' in conditional expressions. The edits target the same type of syntactic construct (conditional expressions) and are part of a single, contiguous refactor to improve the boolean evaluation logic. The changes are mechanically identical and would naturally be made together as part of the same micro-task to ensure consistent behavior throughout the function."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern within the same function: changing 'not value' to 'value is None' in conditional expressions. The edits target the same type of syntactic construct (conditional expressions) and are part of a single, contiguous refactor to improve the boolean evaluation logic. The changes are mechanically identical and would naturally be made together as part of the same micro-task to ensure consistent behavior throughout the function."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in conditional statements. They target the same type of syntactic construct (conditional expressions in if statements) within similar method contexts (_get_parent_attribute methods). This represents a uniform refactoring pattern applied consistently across related code structures, making either edit naturally prompt the other as part of the same contiguous substitution task."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in conditional statements. They target the same type of syntactic construct (conditional expressions in if statements) within similar method contexts (_get_parent_attribute methods). This represents a uniform refactoring pattern applied consistently across related code structures, making either edit naturally prompt the other as part of the same contiguous substitution task."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern within the same function: changing 'not value' to 'value is None' in conditional expressions. This is a uniform refactoring operation where the same logical change is being applied to structurally identical code constructs (both are conditional checks in the same method). The edits are part of a single, contiguous micro-task to improve the boolean evaluation logic consistently throughout the function. Either edit can be made first, and after making one, the other becomes the immediate next step to complete the uniform pattern application."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern within the same function: changing 'not value' to 'value is None' in conditional expressions. This is a uniform refactoring operation where the same logical change is being applied to structurally identical code constructs (both are conditional checks in the same method). The edits are part of a single, contiguous micro-task to improve the boolean evaluation logic consistently throughout the function. Either edit can be made first, and after making one, the other becomes the immediate next step to complete the uniform pattern application."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits are part of the same refactoring pattern within the same method `_get_parent_attribute`. They both change the truthiness check of the `value` variable from implicit boolean evaluation (`not value` and `value`) to explicit None comparison (`value is None` and `value is not None`). This is a uniform substitution pattern applied to the same variable within the same function scope, making it a synchronized refactoring where both changes would naturally be made together as part of a single micro-task to fix the same logical issue with falsy value handling."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits are part of the same refactoring pattern within the same method `_get_parent_attribute`. They both change the truthiness check of the `value` variable from implicit boolean evaluation (`not value` and `value`) to explicit None comparison (`value is None` and `value is not None`). This is a uniform substitution pattern applied to the same variable within the same function scope, making it a synchronized refactoring where both changes would naturally be made together as part of a single micro-task to fix the same logical issue with falsy value handling."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution within the same function (_get_parent_attribute). They both change the condition from 'not value or extend' to 'value is None or extend' on lines that have the same syntactic structure and purpose - checking if a parent attribute should be retrieved. This is a uniform pattern-based refactor where the same logical change is being applied to multiple similar conditional statements within the same method. The edits are part of a single micro-task to fix the boolean evaluation logic consistently throughout the function."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution within the same function (_get_parent_attribute). They both change the condition from 'not value or extend' to 'value is None or extend' on lines that have the same syntactic structure and purpose - checking if a parent attribute should be retrieved. This is a uniform pattern-based refactor where the same logical change is being applied to multiple similar conditional statements within the same method. The edits are part of a single micro-task to fix the boolean evaluation logic consistently throughout the function."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits are making identical structural substitutions within the same method (_get_parent_attribute). Edit 0 changes 'not value' to 'value is None' and edit 1 changes 'value and not extend' to 'value is not None and not extend'. These are part of the same refactoring pattern - replacing truthiness checks with explicit None checks for the same variable 'value' within the same function. This represents a uniform substitution pattern where both edits target the same type of syntactic construct (conditional expressions involving the 'value' variable) and apply the same before\u2192after transformation pattern. Either edit could be made first as both are syntactically valid independently, and making either one creates an immediate prompt to apply the same pattern to the other occurrence for consistency."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits are making identical structural substitutions within the same method (_get_parent_attribute). Edit 0 changes 'not value' to 'value is None' and edit 1 changes 'value and not extend' to 'value is not None and not extend'. These are part of the same refactoring pattern - replacing truthiness checks with explicit None checks for the same variable 'value' within the same function. This represents a uniform substitution pattern where both edits target the same type of syntactic construct (conditional expressions involving the 'value' variable) and apply the same before\u2192after transformation pattern. Either edit could be made first as both are syntactically valid independently, and making either one creates an immediate prompt to apply the same pattern to the other occurrence for consistency."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in the same type of syntactic construct (conditional expressions within if statements). Both are in _get_parent_attribute methods of related classes (Block and Task) that appear to inherit from similar base classes. This represents a uniform refactoring operation where the same logical fix is being applied to identical code patterns across related classes. The substitution pattern is identical and targets the same construct type, making this a bulk-edit synchronization that would naturally occur in a single contiguous refactoring session."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in the same type of syntactic construct (conditional expressions within if statements). Both are in _get_parent_attribute methods of related classes (Block and Task) that appear to inherit from similar base classes. This represents a uniform refactoring operation where the same logical fix is being applied to identical code patterns across related classes. The substitution pattern is identical and targets the same construct type, making this a bulk-edit synchronization that would naturally occur in a single contiguous refactoring session."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in conditional statements. They target the same type of syntactic construct (conditional expressions within if statements) and appear to be part of a single, contiguous refactor to improve boolean logic consistency across the codebase. The substitution pattern is mechanically identical and both edits would naturally occur together as part of the same search-and-replace or refactoring operation."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in conditional statements. They target the same type of syntactic construct (conditional expressions within if statements) and appear to be part of a single, contiguous refactor to improve boolean logic consistency across the codebase. The substitution pattern is mechanically identical and both edits would naturally occur together as part of the same search-and-replace or refactoring operation."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in conditional statements within similar methods (_get_parent_attribute) of related classes (Block and Task). This represents a uniform refactoring operation targeting the same type of syntactic construct (conditional expressions) with the exact same before\u2192after pattern. The edits are part of a single, contiguous refactor to improve null checking logic across the codebase."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in conditional statements within similar methods (_get_parent_attribute) of related classes (Block and Task). This represents a uniform refactoring operation targeting the same type of syntactic construct (conditional expressions) with the exact same before\u2192after pattern. The edits are part of a single, contiguous refactor to improve null checking logic across the codebase."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern within the same function: changing '(not value or extend)' to '(value is None or extend)'. This is a uniform refactoring operation where the same logical condition is being updated in two different locations within the same method. The edits target the same type of syntactic construct (conditional expressions) and apply the exact same before\u2192after transformation pattern. This represents a single, contiguous micro-task of updating all instances of this specific condition pattern within the function."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern within the same function: changing '(not value or extend)' to '(value is None or extend)'. This is a uniform refactoring operation where the same logical condition is being updated in two different locations within the same method. The edits target the same type of syntactic construct (conditional expressions) and apply the exact same before\u2192after transformation pattern. This represents a single, contiguous micro-task of updating all instances of this specific condition pattern within the function."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits are part of the same refactoring pattern within the same function `_get_parent_attribute`. Edit 0 changes `if value and not extend:` to `if value is not None and not extend:` and Edit 1 changes `if self._play and (not value or extend):` to `if self._play and (value is None or extend):`. These are complementary changes that replace truthiness checks with explicit None checks for the same variable `value`. The changes follow identical before\u2192after patterns (replacing `value`/`not value` with `value is not None`/`value is None`) and are clearly part of a single, contiguous refactoring task to handle None values more explicitly. Both edits reference the exact same symbol `value` and represent synchronized modifications within the same function scope."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits are part of the same refactoring pattern within the same function `_get_parent_attribute`. Edit 0 changes `if value and not extend:` to `if value is not None and not extend:` and Edit 1 changes `if self._play and (not value or extend):` to `if self._play and (value is None or extend):`. These are complementary changes that replace truthiness checks with explicit None checks for the same variable `value`. The changes follow identical before\u2192after patterns (replacing `value`/`not value` with `value is not None`/`value is None`) and are clearly part of a single, contiguous refactoring task to handle None values more explicitly. Both edits reference the exact same symbol `value` and represent synchronized modifications within the same function scope."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits are making identical structural substitutions within the same method (_get_parent_attribute). Edit 0 changes 'not value' to 'value is None' and edit 1 changes 'value and not extend' to 'value is not None and not extend'. These are part of the same refactoring pattern - replacing truthiness checks with explicit None checks for the same variable 'value' within the same function. This represents a uniform substitution pattern where both edits target the same type of syntactic construct (boolean expressions involving the 'value' variable) with the same before\u2192after transformation pattern. Both edits reference the exact same symbol 'value' and are clearly part of a single, contiguous refactoring task to improve None-handling semantics."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits are making identical structural substitutions within the same method (_get_parent_attribute). Edit 0 changes 'not value' to 'value is None' and edit 1 changes 'value and not extend' to 'value is not None and not extend'. These are part of the same refactoring pattern - replacing truthiness checks with explicit None checks for the same variable 'value' within the same function. This represents a uniform substitution pattern where both edits target the same type of syntactic construct (boolean expressions involving the 'value' variable) with the same before\u2192after transformation pattern. Both edits reference the exact same symbol 'value' and are clearly part of a single, contiguous refactoring task to improve None-handling semantics."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in conditional statements within similar methods (_get_parent_attribute) across related classes (Block and Task). This represents a uniform refactoring operation targeting the same type of syntactic construct (conditional expressions) with the exact same before\u2192after pattern. The edits are part of a single, contiguous refactor to improve the logic for checking None values versus falsy values. Either edit can be made first, and after making either one, the other becomes the natural next step to maintain consistency across the codebase."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in conditional statements within similar methods (_get_parent_attribute) across related classes (Block and Task). This represents a uniform refactoring operation targeting the same type of syntactic construct (conditional expressions) with the exact same before\u2192after pattern. The edits are part of a single, contiguous refactor to improve the logic for checking None values versus falsy values. Either edit can be made first, and after making either one, the other becomes the natural next step to maintain consistency across the codebase."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in conditional statements within '_get_parent_attribute' methods. This is a uniform refactoring operation targeting the same type of syntactic construct (conditional expressions) with the exact same before\u2192after pattern. The edits appear to be part of a single, contiguous refactor to improve null checking logic across similar methods in related classes. Either edit could be made first, and after making one, the other would be the natural next step to maintain consistency in the codebase."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing '(not value or extend)' to '(value is None or extend)' in conditional statements within '_get_parent_attribute' methods. This is a uniform refactoring operation targeting the same type of syntactic construct (conditional expressions) with the exact same before\u2192after pattern. The edits appear to be part of a single, contiguous refactor to improve null checking logic across similar methods in related classes. Either edit could be made first, and after making one, the other would be the natural next step to maintain consistency in the codebase."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution pattern: changing 'if value and not extend:' to 'if value is not None and not extend:' in edit 0, and changing 'if self._block and (not value or extend):' to 'if self._block and (value is None or extend):' in edit 1. Both are changing the truthiness check from 'value' to 'value is not None' within similar conditional logic in related classes (Block and Task) that both inherit from Base and have _get_parent_attribute methods. This represents a uniform refactoring pattern applied to the same type of syntactic construct (conditional expressions checking value truthiness) across related code structures. The edits are part of a single, contiguous refactor to fix the same logical issue in parallel implementations."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical structural substitution pattern: changing 'if value and not extend:' to 'if value is not None and not extend:' in edit 0, and changing 'if self._block and (not value or extend):' to 'if self._block and (value is None or extend):' in edit 1. Both are changing the truthiness check from 'value' to 'value is not None' within similar conditional logic in related classes (Block and Task) that both inherit from Base and have _get_parent_attribute methods. This represents a uniform refactoring pattern applied to the same type of syntactic construct (conditional expressions checking value truthiness) across related code structures. The edits are part of a single, contiguous refactor to fix the same logical issue in parallel implementations."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern within the same function: changing 'not value' to 'value is None' in conditional expressions. This is a uniform refactoring operation where the same logical change is being applied to structurally identical code constructs (both are conditional checks in if statements). The edits target the same type of syntactic construct and apply the exact same before\u2192after pattern, making this a clear case of bulk-edit synchronization within a single micro-task."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern within the same function: changing 'not value' to 'value is None' in conditional expressions. This is a uniform refactoring operation where the same logical change is being applied to structurally identical code constructs (both are conditional checks in if statements). The edits target the same type of syntactic construct and apply the exact same before\u2192after pattern, making this a clear case of bulk-edit synchronization within a single micro-task."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical structural substitution pattern, changing 'if value and not extend:' to 'if value is not None and not extend:' and 'if self._task_include and (not value or extend):' to 'if self._task_include and (value is None or extend):'. This is a uniform refactoring pattern applied to the same type of syntactic construct (conditional expressions involving 'value' and 'extend' parameters) across two different classes that both inherit from similar base classes and implement the same method '_get_parent_attribute'. The substitution pattern is mechanically identical - replacing truthiness checks with explicit None checks - and both target the same logical construct within similar inheritance hierarchies. This represents a bulk edit/pattern synchronization where both edits are part of a single, contiguous refactor to fix the same logical issue across related classes."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical structural substitution pattern, changing 'if value and not extend:' to 'if value is not None and not extend:' and 'if self._task_include and (not value or extend):' to 'if self._task_include and (value is None or extend):'. This is a uniform refactoring pattern applied to the same type of syntactic construct (conditional expressions involving 'value' and 'extend' parameters) across two different classes that both inherit from similar base classes and implement the same method '_get_parent_attribute'. The substitution pattern is mechanically identical - replacing truthiness checks with explicit None checks - and both target the same logical construct within similar inheritance hierarchies. This represents a bulk edit/pattern synchronization where both edits are part of a single, contiguous refactor to fix the same logical issue across related classes."
        }
    ],
    "allowed_init_edits": [
        1,
        2,
        0,
        6,
        4,
        5,
        3
    ]
}