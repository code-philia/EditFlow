{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "These edits involve renaming the same function from 'validate_choice_field' to 'validate_select_field'. Edit 0 changes the function definition, while Edit 1 updates an import statement that references the exact same function. The changed lines reference the exact same symbol - the function being renamed. After making either edit, the other becomes immediately necessary to maintain code consistency and avoid import errors. This is a classic definition-usage relationship where both edits reference the same symbol and either can prompt the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "These edits involve renaming the same function from 'validate_choice_field' to 'validate_select_field'. Edit 0 changes the function definition, while Edit 1 updates an import statement that references the exact same function. The changed lines reference the exact same symbol - the function being renamed. After making either edit, the other becomes immediately necessary to maintain code consistency and avoid import errors. This is a classic definition-usage relationship where both edits reference the same symbol and either can prompt the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution, changing 'validate_choice_field' to 'validate_select_field' in the same file. The changed lines in both edits reference the exact same symbol (validate_choice_field being replaced with validate_select_field). This is a clear case of bulk uniform substitution where both edits are part of a single, contiguous refactor operation. Either edit can be made first, and after making either one, the other becomes the immediate next step to complete the consistent renaming throughout the codebase."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution, changing 'validate_choice_field' to 'validate_select_field' in the same file. The changed lines in both edits reference the exact same symbol (validate_choice_field being replaced with validate_select_field). This is a clear case of bulk uniform substitution where both edits are part of a single, contiguous refactor operation. Either edit can be made first, and after making either one, the other becomes the immediate next step to complete the consistent renaming throughout the codebase."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol - they are renaming the function from 'validate_choice_field' to 'validate_select_field'. Edit 0 changes the function definition, and edit 1 updates the usage of that same function in a different file. After making either edit, the other becomes immediately necessary to maintain code consistency and avoid NameError at runtime. This is a classic definition-usage relationship for the same symbol across files."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol - they are renaming the function from 'validate_choice_field' to 'validate_select_field'. Edit 0 changes the function definition, and edit 1 updates the usage of that same function in a different file. After making either edit, the other becomes immediately necessary to maintain code consistency and avoid NameError at runtime. This is a classic definition-usage relationship for the same symbol across files."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 renames the function `validate_choice_field` to `validate_select_field` in its definition. Edit 1 updates the import statement to import the renamed function `validate_select_field` instead of `validate_choice_field`. Both edits reference the exact same symbol - the function being renamed. After making edit 0 (renaming the function), edit 1 becomes immediately necessary to fix the import, and vice versa. This is a classic definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 renames the function `validate_choice_field` to `validate_select_field` in its definition. Edit 1 updates the import statement to import the renamed function `validate_select_field` instead of `validate_choice_field`. Both edits reference the exact same symbol - the function being renamed. After making edit 0 (renaming the function), edit 1 becomes immediately necessary to fix the import, and vice versa. This is a classic definition-usage relationship where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 renames the function `validate_choice_field_data` to `validate_select_field_data` in its definition. Edit 1 updates a call site to use the new function name `validate_select_field_data`. Both edits reference the exact same symbol - the function being renamed. After making either edit, the other becomes the immediate next step to maintain code consistency, as having a function definition with one name and a call site with a different name would create a runtime NameError. However, both edits can be written and parsed in either order since Python allows referencing undefined symbols at parse time (the error only occurs at runtime/import time)."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 renames the function `validate_choice_field_data` to `validate_select_field_data` in its definition. Edit 1 updates a call site to use the new function name `validate_select_field_data`. Both edits reference the exact same symbol - the function being renamed. After making either edit, the other becomes the immediate next step to maintain code consistency, as having a function definition with one name and a call site with a different name would create a runtime NameError. However, both edits can be written and parsed in either order since Python allows referencing undefined symbols at parse time (the error only occurs at runtime/import time)."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform identical textual substitution (changing 'choice' to 'select' in function names) on the same type of syntactic construct (function definitions) within the same file. This represents a bulk refactoring operation where both function names are being renamed with the same pattern as part of a single, contiguous micro-task. The edits are mechanically linked by the identical substitution pattern and would naturally occur together in one uninterrupted renaming sweep."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform identical textual substitution (changing 'choice' to 'select' in function names) on the same type of syntactic construct (function definitions) within the same file. This represents a bulk refactoring operation where both function names are being renamed with the same pattern as part of a single, contiguous micro-task. The edits are mechanically linked by the identical substitution pattern and would naturally occur together in one uninterrupted renaming sweep."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 renames the function `validate_choice_field_data` to `validate_select_field_data` in its definition. Edit 1 updates the import statement to import the renamed function `validate_select_field_data` instead of `validate_choice_field_data`. Both edits reference the exact same symbol - the function being renamed. After renaming the function definition, the import must be updated to reference the new name, and vice versa. This creates an immediate, mechanically obvious code-driven prompt where either edit naturally leads to the other as the next contiguous action. Both edits can be staged in either order without causing parse errors (the import will just reference a non-existent function until the definition is updated, which is a runtime error, not a parse error)."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 renames the function `validate_choice_field_data` to `validate_select_field_data` in its definition. Edit 1 updates the import statement to import the renamed function `validate_select_field_data` instead of `validate_choice_field_data`. Both edits reference the exact same symbol - the function being renamed. After renaming the function definition, the import must be updated to reference the new name, and vice versa. This creates an immediate, mechanically obvious code-driven prompt where either edit naturally leads to the other as the next contiguous action. Both edits can be staged in either order without causing parse errors (the import will just reference a non-existent function until the definition is updated, which is a runtime error, not a parse error)."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform identical textual substitution of 'validate_choice_field' to 'validate_select_field'. This is a uniform rename/refactor operation where the same function name is being changed consistently across multiple files. The edits reference the exact same symbol (the validation function) and represent a synchronized bulk substitution pattern - both are part of the same contiguous refactoring task to rename this validation function throughout the codebase."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitution of 'validate_choice_field' to 'validate_select_field'. This is a uniform rename/refactor operation where the same function name is being changed consistently across multiple files. The edits reference the exact same symbol (the validation function) and represent a synchronized bulk substitution pattern - both are part of the same contiguous refactoring task to rename this validation function throughout the codebase."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution: changing 'validate_choice_field' to 'validate_select_field'. Edit 0 changes the import statement, while Edit 1 changes the function call. These are part of a single refactoring operation where a function is being renamed consistently across its import and usage. The changed lines reference the exact same symbol (the function being renamed), and this represents a uniform substitution pattern across the same type of syntactic construct (function references). Either edit could be made first, and after making either one, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution: changing 'validate_choice_field' to 'validate_select_field'. Edit 0 changes the import statement, while Edit 1 changes the function call. These are part of a single refactoring operation where a function is being renamed consistently across its import and usage. The changed lines reference the exact same symbol (the function being renamed), and this represents a uniform substitution pattern across the same type of syntactic construct (function references). Either edit could be made first, and after making either one, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitutions changing 'choice_field' to 'select_field' in function names. Edit 0 changes 'validate_choice_field' to 'validate_select_field' in a data structure definition, while Edit 1 changes 'validate_choice_field_data' to 'validate_select_field_data' in an import statement. These are part of the same bulk refactoring operation - renaming functions from 'choice_field' to 'select_field' pattern across the codebase. Both edits can be applied in either order as they involve different symbols (validate_choice_field vs validate_choice_field_data) and represent synchronized pattern substitution within the same refactoring sweep."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitutions changing 'choice_field' to 'select_field' in function names. Edit 0 changes 'validate_choice_field' to 'validate_select_field' in a data structure definition, while Edit 1 changes 'validate_choice_field_data' to 'validate_select_field_data' in an import statement. These are part of the same bulk refactoring operation - renaming functions from 'choice_field' to 'select_field' pattern across the codebase. Both edits can be applied in either order as they involve different symbols (validate_choice_field vs validate_choice_field_data) and represent synchronized pattern substitution within the same refactoring sweep."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution, changing 'validate_choice_field_data' to 'validate_select_field_data' in the same file. Edit 0 changes the import statement, while Edit 1 changes the function call. These are part of a single refactoring operation where a function is being renamed - both the import and usage must be updated together. The changed lines reference the exact same symbol (the function being renamed), and either edit can be made first since both are syntactically valid in either order (the old function name would just result in a runtime NameError if called before the import is updated, but both edits can be parsed and staged independently)."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution, changing 'validate_choice_field_data' to 'validate_select_field_data' in the same file. Edit 0 changes the import statement, while Edit 1 changes the function call. These are part of a single refactoring operation where a function is being renamed - both the import and usage must be updated together. The changed lines reference the exact same symbol (the function being renamed), and either edit can be made first since both are syntactically valid in either order (the old function name would just result in a runtime NameError if called before the import is updated, but both edits can be parsed and staged independently)."
        }
    ],
    "allowed_init_edits": [
        2,
        0
    ]
}