{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitution (commenting out assert statements by adding '# ' prefix) on the same type of syntactic construct (assert statements) within the same test file. This appears to be part of a single, contiguous refactor to disable certain test assertions. The edits follow the bulk-edit pattern where the same before\u2192after transformation is applied to similar constructs."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform identical textual substitution (commenting out assert statements by adding '# ' prefix) on the same type of syntactic construct (assert statements) within the same test file. This appears to be part of a single, contiguous refactor to disable certain test assertions. The edits follow the bulk-edit pattern where the same before\u2192after transformation is applied to similar constructs."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform identical structural substitutions - commenting out assertion statements by adding '# ' prefix to the lines. They target the same type of syntactic construct (assert statements) with the exact same before\u2192after pattern (uncommented assert \u2192 commented assert). This appears to be part of a single, contiguous refactoring operation to disable certain test assertions across related test methods in the same test class."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform identical structural substitutions - commenting out assertion statements by adding '# ' prefix to the lines. They target the same type of syntactic construct (assert statements) with the exact same before\u2192after pattern (uncommented assert \u2192 commented assert). This appears to be part of a single, contiguous refactoring operation to disable certain test assertions across related test methods in the same test class."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits are commenting out code within the same test method that references the exact same symbols (idx0, idx2). The changed lines in both edits reference these identical symbols that were defined in edit 0 and used in edit 1. After commenting out the variable definitions in edit 0, the assertions in edit 1 that reference those same variables would naturally be commented out as the next mechanical step, since they would otherwise reference undefined variables. This creates an immediate, code-driven prompt where either edit can be made first, and the other becomes the natural next step to maintain code consistency."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits are commenting out code within the same test method that references the exact same symbols (idx0, idx2). The changed lines in both edits reference these identical symbols that were defined in edit 0 and used in edit 1. After commenting out the variable definitions in edit 0, the assertions in edit 1 that reference those same variables would naturally be commented out as the next mechanical step, since they would otherwise reference undefined variables. This creates an immediate, code-driven prompt where either edit can be made first, and the other becomes the natural next step to maintain code consistency."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitutions (commenting out assert statements by adding '# ' prefix) within the same test file and same test class. They target the same type of syntactic construct (assert statements) with the exact same transformation pattern. This appears to be part of a single, contiguous refactoring operation to disable certain test assertions, making this a bulk-edit pattern synchronization where either edit could be made first and both are part of the same mechanical task."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform identical textual substitutions (commenting out assert statements by adding '# ' prefix) within the same test file and same test class. They target the same type of syntactic construct (assert statements) with the exact same transformation pattern. This appears to be part of a single, contiguous refactoring operation to disable certain test assertions, making this a bulk-edit pattern synchronization where either edit could be made first and both are part of the same mechanical task."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform identical structural substitutions - commenting out assertion statements and variable definitions in test methods. They follow the same pattern of adding '# ' prefix to convert active code into comments. Both edits target the same type of syntactic construct (test assertions and variable definitions) within the same test class, applying the same before\u2192after transformation pattern. This represents a bulk edit operation where the same commenting pattern is being applied uniformly across multiple test methods as part of a single refactoring task."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform identical structural substitutions - commenting out assertion statements and variable definitions in test methods. They follow the same pattern of adding '# ' prefix to convert active code into comments. Both edits target the same type of syntactic construct (test assertions and variable definitions) within the same test class, applying the same before\u2192after transformation pattern. This represents a bulk edit operation where the same commenting pattern is being applied uniformly across multiple test methods as part of a single refactoring task."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits add identical conditional checks `if self - b == 0:` to different methods (__floordiv__ and __mod__) of the same SumNode class. This represents a synchronized pattern addition where the same logical check is being applied to related mathematical operations. The edits involve identical structural substitution (adding the same conditional pattern) to the same type of syntactic construct (method definitions in the same class). This appears to be part of a single refactoring effort to add consistent zero-difference handling across mathematical operations."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits add identical conditional checks `if self - b == 0:` to different methods (__floordiv__ and __mod__) of the same SumNode class. This represents a synchronized pattern addition where the same logical check is being applied to related mathematical operations. The edits involve identical structural substitution (adding the same conditional pattern) to the same type of syntactic construct (method definitions in the same class). This appears to be part of a single refactoring effort to add consistent zero-difference handling across mathematical operations."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits involve commenting out code that references the exact same symbol 'lidx1'. Edit 0 comments out the variable definition 'lidx1 = Variable(\"lidx1\", 0, 7)', while Edit 1 comments out the assert statements that use this same lidx1 variable. After commenting out the definition in Edit 0, the usage in Edit 1 would cause a NameError at runtime, making it natural to comment out the usage as well. However, in Python, both edits can be written and parsed in either order since referencing undefined variables is allowed at parse time and only fails at runtime. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step to maintain code consistency."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits involve commenting out code that references the exact same symbol 'lidx1'. Edit 0 comments out the variable definition 'lidx1 = Variable(\"lidx1\", 0, 7)', while Edit 1 comments out the assert statements that use this same lidx1 variable. After commenting out the definition in Edit 0, the usage in Edit 1 would cause a NameError at runtime, making it natural to comment out the usage as well. However, in Python, both edits can be written and parsed in either order since referencing undefined variables is allowed at parse time and only fails at runtime. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step to maintain code consistency."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits remove identical code blocks from different methods (__floordiv__ and __mod__) within the same SumNode class. The removed code is exactly the same: checking if b is a SumNode, calculating nu_num and de_num from flat_components, and performing the same conditional logic with d=nu_num//de_num. This represents a bulk-edit pattern where identical code is being removed from multiple locations as part of a single refactoring operation. The edits perform the same structural substitution (removing the same code pattern) on the same type of syntactic construct (method implementations), making them part of a contiguous cleanup task."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits remove identical code blocks from different methods (__floordiv__ and __mod__) within the same SumNode class. The removed code is exactly the same: checking if b is a SumNode, calculating nu_num and de_num from flat_components, and performing the same conditional logic with d=nu_num//de_num. This represents a bulk-edit pattern where identical code is being removed from multiple locations as part of a single refactoring operation. The edits perform the same structural substitution (removing the same code pattern) on the same type of syntactic construct (method implementations), making them part of a contiguous cleanup task."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitution (commenting out assert statements by adding '# ' prefix) on the same type of syntactic construct (assert statements) within related test methods in the same test class. This appears to be part of a single, contiguous refactoring operation to disable certain test assertions. The edits follow the bulk-edit pattern where the same before\u2192after transformation is applied to similar constructs."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitution (commenting out assert statements by adding '# ' prefix) on the same type of syntactic construct (assert statements) within related test methods in the same test class. This appears to be part of a single, contiguous refactoring operation to disable certain test assertions. The edits follow the bulk-edit pattern where the same before\u2192after transformation is applied to similar constructs."
        }
    ],
    "allowed_init_edits": [
        5,
        3,
        6
    ]
}