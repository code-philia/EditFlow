{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 adds a default 'group_operator': 'sum' to the Float field class, while Edit 1 removes the fallback 'or sum' logic when accessing group_operator. These edits reference the exact same symbol (group_operator attribute) and form a coordinated change where the default value is moved from runtime fallback logic to field definition. Either edit can be staged first without causing parse errors, and after making either edit, the other becomes the immediate next step to complete the refactoring."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 adds a default 'group_operator': 'sum' to the Float field class, while Edit 1 removes the fallback 'or sum' logic when accessing group_operator. These edits reference the exact same symbol (group_operator attribute) and form a coordinated change where the default value is moved from runtime fallback logic to field definition. Either edit can be staged first without causing parse errors, and after making either edit, the other becomes the immediate next step to complete the refactoring."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical structural substitution pattern: they replace the dynamic assignment of 'group_operator' = 'sum' in the _setup_regular_base method with a static declaration 'group_operator': 'sum' in the _slots dictionary. This is a uniform refactoring pattern applied to the same type of syntactic construct (class attribute definitions) across related field classes (Integer and Float). The edits are part of a single, contiguous refactor to change how group_operator is initialized from dynamic method-based assignment to static slot-based declaration."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical structural substitution pattern: they replace the dynamic assignment of 'group_operator' = 'sum' in the _setup_regular_base method with a static declaration 'group_operator': 'sum' in the _slots dictionary. This is a uniform refactoring pattern applied to the same type of syntactic construct (class attribute definitions) across related field classes (Integer and Float). The edits are part of a single, contiguous refactor to change how group_operator is initialized from dynamic method-based assignment to static slot-based declaration."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits are adding the same 'group_operator': 'sum' entry to the _slots dictionary of different field classes (Integer and Monetary). This represents a bulk/pattern synchronization where identical structural changes are being applied to similar constructs. Both edits involve the same before\u2192after pattern (adding the group_operator entry) and target the same type of syntactic construct (_slots dictionaries in field classes). This appears to be part of a single refactoring operation to standardize how group_operator is defined across field types."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits are adding the same 'group_operator': 'sum' entry to the _slots dictionary of different field classes (Integer and Monetary). This represents a bulk/pattern synchronization where identical structural changes are being applied to similar constructs. Both edits involve the same before\u2192after pattern (adding the group_operator entry) and target the same type of syntactic construct (_slots dictionaries in field classes). This appears to be part of a single refactoring operation to standardize how group_operator is defined across field types."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits add the exact same line 'group_operator': 'sum' to different class definitions (Float and Monetary). This represents a bulk/pattern synchronization where identical structural changes are being applied to multiple similar constructs (both are Field subclasses with similar dictionary structures). The edits follow the same before\u2192after pattern (adding the same key-value pair) and target the same type of syntactic construct (class attribute dictionaries). This appears to be part of a single, contiguous refactor to add the same attribute to multiple related field classes."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits add the exact same line 'group_operator': 'sum' to different class definitions (Float and Monetary). This represents a bulk/pattern synchronization where identical structural changes are being applied to multiple similar constructs (both are Field subclasses with similar dictionary structures). The edits follow the same before\u2192after pattern (adding the same key-value pair) and target the same type of syntactic construct (class attribute dictionaries). This appears to be part of a single, contiguous refactor to add the same attribute to multiple related field classes."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 adds 'group_operator': 'sum' to the default attributes dictionary of the Float class, while Edit 1 removes the _setup_regular_base method that was previously setting self.group_operator = 'sum' conditionally. These edits reference the exact same attribute (group_operator) and represent a refactoring where the conditional runtime assignment is being replaced with a default value declaration. The removal of the method and addition of the default value are mechanically linked - after adding the default value in the class attributes, the conditional assignment method becomes redundant and is the immediate next step to remove. Both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 adds 'group_operator': 'sum' to the default attributes dictionary of the Float class, while Edit 1 removes the _setup_regular_base method that was previously setting self.group_operator = 'sum' conditionally. These edits reference the exact same attribute (group_operator) and represent a refactoring where the conditional runtime assignment is being replaced with a default value declaration. The removal of the method and addition of the default value are mechanically linked - after adding the default value in the class attributes, the conditional assignment method becomes redundant and is the immediate next step to remove. Both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits are performing the same structural refactoring pattern: removing the `_setup_regular_base` method that sets `group_operator = 'sum'` conditionally. Edit 0 shows this method being replaced with a `_slots` declaration that sets `group_operator: 'sum'` directly. Edit 1 only shows the removal of the same method pattern from the Float class. This appears to be part of a uniform refactoring across multiple field classes to replace dynamic setup methods with static slot declarations. Both edits target the same type of syntactic construct (the `_setup_regular_base` method) and follow the same before\u2192after pattern (removing conditional group_operator setup), making this a bulk-edit synchronization."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits are performing the same structural refactoring pattern: removing the `_setup_regular_base` method that sets `group_operator = 'sum'` conditionally. Edit 0 shows this method being replaced with a `_slots` declaration that sets `group_operator: 'sum'` directly. Edit 1 only shows the removal of the same method pattern from the Float class. This appears to be part of a uniform refactoring across multiple field classes to replace dynamic setup methods with static slot declarations. Both edits target the same type of syntactic construct (the `_setup_regular_base` method) and follow the same before\u2192after pattern (removing conditional group_operator setup), making this a bulk-edit synchronization."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "These edits reference different aspects of the same field attribute `group_operator`. Edit 0 removes code that sets a default value of 'sum' for `group_operator` when it's not already set, while Edit 1 removes the fallback logic (`or 'sum'`) that would use 'sum' as a default when `group_operator` is falsy. Both edits reference the exact same field attribute `group_operator` and appear to be part of removing the default 'sum' behavior - removing both the initialization of the default and the fallback usage. Either edit could be made first and would create an immediate prompt for the other to maintain consistency in how `group_operator` is handled."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "These edits reference different aspects of the same field attribute `group_operator`. Edit 0 removes code that sets a default value of 'sum' for `group_operator` when it's not already set, while Edit 1 removes the fallback logic (`or 'sum'`) that would use 'sum' as a default when `group_operator` is falsy. Both edits reference the exact same field attribute `group_operator` and appear to be part of removing the default 'sum' behavior - removing both the initialization of the default and the fallback usage. Either edit could be made first and would create an immediate prompt for the other to maintain consistency in how `group_operator` is handled."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds 'group_operator': 'sum' to the default values dictionary in the Monetary class, while Edit 1 removes the conditional logic that would set self.group_operator = 'sum' if it wasn't already set. These edits reference the exact same attribute (group_operator) and represent a refactoring where the default value assignment is moved from runtime initialization logic to the class defaults dictionary. Making either edit creates an immediate prompt for the other to maintain consistent behavior - if you add the default to the dictionary, you should remove the redundant runtime check, and vice versa. Both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds 'group_operator': 'sum' to the default values dictionary in the Monetary class, while Edit 1 removes the conditional logic that would set self.group_operator = 'sum' if it wasn't already set. These edits reference the exact same attribute (group_operator) and represent a refactoring where the default value assignment is moved from runtime initialization logic to the class defaults dictionary. Making either edit creates an immediate prompt for the other to maintain consistent behavior - if you add the default to the dictionary, you should remove the redundant runtime check, and vice versa. Both edits can be staged in either order without causing parse errors."
        }
    ],
    "allowed_init_edits": [
        4
    ]
}