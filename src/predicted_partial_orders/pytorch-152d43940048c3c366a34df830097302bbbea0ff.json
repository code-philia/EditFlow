{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds 'net_type' as a new field to the PredictorExportMeta namedtuple definition, while Edit 1 adds documentation explaining what the 'net_type' field represents. These edits reference the exact same symbol ('net_type') - one defines it in the namedtuple structure and the other documents it. Both edits are part of adding the same new field to the class, making them bi-directional neighbors where either edit naturally prompts the other as the next step in the same micro-task of adding and documenting the new field."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds 'net_type' as a new field to the PredictorExportMeta namedtuple definition, while Edit 1 adds documentation explaining what the 'net_type' field represents. These edits reference the exact same symbol ('net_type') - one defines it in the namedtuple structure and the other documents it. Both edits are part of adding the same new field to the class, making them bi-directional neighbors where either edit naturally prompts the other as the next step in the same micro-task of adding and documenting the new field."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits add the same parameter 'net_type' to the same class PredictorExportMeta. Edit 0 adds 'net_type' to the namedtuple field specification, while Edit 1 adds 'net_type=None' to the __new__ method signature. These edits reference the exact same symbol (the net_type parameter) and are part of a synchronized parameter addition pattern. After making either edit, the other becomes immediately necessary to maintain consistency between the namedtuple field definition and the constructor signature. This is a clear case of mirrored additions within the same class context where both changed lines explicitly reference the same parameter."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits add the same parameter 'net_type' to the same class PredictorExportMeta. Edit 0 adds 'net_type' to the namedtuple field specification, while Edit 1 adds 'net_type=None' to the __new__ method signature. These edits reference the exact same symbol (the net_type parameter) and are part of a synchronized parameter addition pattern. After making either edit, the other becomes immediately necessary to maintain consistency between the namedtuple field definition and the constructor signature. This is a clear case of mirrored additions within the same class context where both changed lines explicitly reference the same parameter."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds a new parameter 'net_type' to the PredictorExportMeta namedtuple definition, and Edit 1 adds the same 'net_type' parameter to a constructor call of that exact same namedtuple class. These edits reference the exact same symbol (PredictorExportMeta) and create a direct code dependency - after adding the parameter to the namedtuple definition, the constructor call must be updated to include the new parameter to avoid a TypeError. Either edit can be made first and parsed successfully, but making either edit creates an immediate, mechanically obvious prompt for the other as the next contiguous action within the same micro-task of adding the net_type parameter."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds a new parameter 'net_type' to the PredictorExportMeta namedtuple definition, and Edit 1 adds the same 'net_type' parameter to a constructor call of that exact same namedtuple class. These edits reference the exact same symbol (PredictorExportMeta) and create a direct code dependency - after adding the parameter to the namedtuple definition, the constructor call must be updated to include the new parameter to avoid a TypeError. Either edit can be made first and parsed successfully, but making either edit creates an immediate, mechanically obvious prompt for the other as the next contiguous action within the same micro-task of adding the net_type parameter."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Edit 0 adds a new field 'net_type' to the PredictorExportMeta namedtuple definition. Edit 1 uses this newly added field by accessing predictor_export_meta.net_type in a conditional check. The changed lines reference the exact same symbol - the net_type attribute of the PredictorExportMeta class. After adding the field in edit 0, edit 1 becomes the natural next step to utilize this new field. However, since Python allows accessing undefined attributes at parse time (only failing at runtime with AttributeError), both edits can be staged in either order without parser errors. This creates a bi-directional relationship where either edit prompts the other as the immediate next mechanical step."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Edit 0 adds a new field 'net_type' to the PredictorExportMeta namedtuple definition. Edit 1 uses this newly added field by accessing predictor_export_meta.net_type in a conditional check. The changed lines reference the exact same symbol - the net_type attribute of the PredictorExportMeta class. After adding the field in edit 0, edit 1 becomes the natural next step to utilize this new field. However, since Python allows accessing undefined attributes at parse time (only failing at runtime with AttributeError), both edits can be staged in either order without parser errors. This creates a bi-directional relationship where either edit prompts the other as the immediate next mechanical step."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits modify the exact same namedtuple class 'PredictorExportMeta' by adding the same new field 'net_type'. Edit 0 adds 'net_type' to the namedtuple field definition, while Edit 1 adds 'net_type' to the corresponding __new__ method call that constructs instances of this namedtuple. These edits reference the same symbol (the PredictorExportMeta namedtuple) and represent a synchronized structural change - adding a field requires updating both the field list and the constructor call. Either edit can be made first without causing parse errors, but making either edit creates an immediate mechanical prompt for the other to maintain structural consistency."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits modify the exact same namedtuple class 'PredictorExportMeta' by adding the same new field 'net_type'. Edit 0 adds 'net_type' to the namedtuple field definition, while Edit 1 adds 'net_type' to the corresponding __new__ method call that constructs instances of this namedtuple. These edits reference the same symbol (the PredictorExportMeta namedtuple) and represent a synchronized structural change - adding a field requires updating both the field list and the constructor call. Either edit can be made first without causing parse errors, but making either edit creates an immediate mechanical prompt for the other to maintain structural consistency."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits involve adding the exact same parameter 'net_type' to the same function '__new__' in the PredictorExportMeta class. Edit 0 adds 'net_type=None' to the function signature, and Edit 1 adds 'net_type' to the corresponding super().__new__() call that passes the parameters. These edits reference the exact same symbol (the net_type parameter) and form a direct code dependency - adding a parameter to a function signature naturally requires updating the corresponding call site that passes all parameters. Either edit can be made first without causing a parse error, making this a bi-directional relationship where making either edit creates an immediate, mechanically obvious prompt for the other as the next contiguous action."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits involve adding the exact same parameter 'net_type' to the same function '__new__' in the PredictorExportMeta class. Edit 0 adds 'net_type=None' to the function signature, and Edit 1 adds 'net_type' to the corresponding super().__new__() call that passes the parameters. These edits reference the exact same symbol (the net_type parameter) and form a direct code dependency - adding a parameter to a function signature naturally requires updating the corresponding call site that passes all parameters. Either edit can be made first without causing a parse error, making this a bi-directional relationship where making either edit creates an immediate, mechanically obvious prompt for the other as the next contiguous action."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 adds a new parameter 'net_type=None' to the PredictorExportMeta constructor signature. Edit 1 adds 'net_type='dag'' to a call to PredictorExportMeta constructor in the test file. Both edits reference the exact same symbol (the net_type parameter of PredictorExportMeta). This is a classic definition-usage pattern where adding a parameter to a function signature and then using that parameter in a call site creates an immediate code-driven linkage. After adding the parameter to the constructor, the test code can immediately use it, and vice versa - either edit can be made first since Python allows optional parameters to be added to function signatures and used in calls in either order without parse errors."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 adds a new parameter 'net_type=None' to the PredictorExportMeta constructor signature. Edit 1 adds 'net_type='dag'' to a call to PredictorExportMeta constructor in the test file. Both edits reference the exact same symbol (the net_type parameter of PredictorExportMeta). This is a classic definition-usage pattern where adding a parameter to a function signature and then using that parameter in a call site creates an immediate code-driven linkage. After adding the parameter to the constructor, the test code can immediately use it, and vice versa - either edit can be made first since Python allows optional parameters to be added to function signatures and used in calls in either order without parse errors."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds a 'net_type' parameter to the PredictorExportMeta constructor's __new__ method call, while Edit 1 adds the same 'net_type' parameter to a PredictorExportMeta constructor call in a test. Both edits reference the exact same symbol (the PredictorExportMeta constructor) and involve adding the same parameter. After making either edit, the other becomes the immediate next step to maintain consistency - if the constructor signature is changed to include net_type, the test call must be updated to provide it, and vice versa. This is a classic signature-caller relationship for the same function/constructor."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds a 'net_type' parameter to the PredictorExportMeta constructor's __new__ method call, while Edit 1 adds the same 'net_type' parameter to a PredictorExportMeta constructor call in a test. Both edits reference the exact same symbol (the PredictorExportMeta constructor) and involve adding the same parameter. After making either edit, the other becomes the immediate next step to maintain consistency - if the constructor signature is changed to include net_type, the test call must be updated to provide it, and vice versa. This is a classic signature-caller relationship for the same function/constructor."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 adds a new parameter 'net_type=None' to the PredictorExportMeta class constructor. Edit 1 uses this exact same parameter by accessing 'predictor_export_meta.net_type' in a conditional check. The changed lines reference the exact same symbol - the net_type attribute of the PredictorExportMeta object. After adding the net_type parameter in edit 0, edit 1 becomes the natural next step to actually use this new parameter. However, both edits can be staged in either order since Python allows accessing attributes that may be None without parse errors - the usage in edit 1 would simply access None if edit 0 hadn't been applied yet."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 adds a new parameter 'net_type=None' to the PredictorExportMeta class constructor. Edit 1 uses this exact same parameter by accessing 'predictor_export_meta.net_type' in a conditional check. The changed lines reference the exact same symbol - the net_type attribute of the PredictorExportMeta object. After adding the net_type parameter in edit 0, edit 1 becomes the natural next step to actually use this new parameter. However, both edits can be staged in either order since Python allows accessing attributes that may be None without parse errors - the usage in edit 1 would simply access None if edit 0 hadn't been applied yet."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 adds a 'net_type' parameter with value 'dag' to a PredictorExportMeta constructor call. Edit 1 adds an assertion that checks if predict_net.type equals 'dag'. These edits are part of the same test method and work together - the first edit sets up the configuration with net_type='dag', and the second edit verifies that this configuration was applied correctly by asserting the predict_net.type is 'dag'. This is a test-production synchronization pattern where one edit configures a parameter and another edit validates that the configuration took effect. Both edits reference the same concept ('dag' net type) and form a natural test setup-verification pair within the same test method."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 adds a 'net_type' parameter with value 'dag' to a PredictorExportMeta constructor call. Edit 1 adds an assertion that checks if predict_net.type equals 'dag'. These edits are part of the same test method and work together - the first edit sets up the configuration with net_type='dag', and the second edit verifies that this configuration was applied correctly by asserting the predict_net.type is 'dag'. This is a test-production synchronization pattern where one edit configures a parameter and another edit validates that the configuration took effect. Both edits reference the same concept ('dag' net type) and form a natural test setup-verification pair within the same test method."
        }
    ],
    "allowed_init_edits": [
        1,
        5
    ]
}