{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds 'record_name' to the @api.depends decorator for the _compute_subject method, while Edit 1 adds logic inside the _compute_subject method that uses composer.record_name. The changed lines reference the exact same symbol 'record_name' - Edit 0 declares it as a dependency for the computed field, and Edit 1 uses that same field in the computation logic. This creates a direct code dependency where adding the field to the dependency list and using it in the computation are mechanically linked parts of the same micro-task. Either edit could be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to complete the coherent change."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds 'record_name' to the @api.depends decorator for the _compute_subject method, while Edit 1 adds logic inside the _compute_subject method that uses composer.record_name. The changed lines reference the exact same symbol 'record_name' - Edit 0 declares it as a dependency for the computed field, and Edit 1 uses that same field in the computation logic. This creates a direct code dependency where adding the field to the dependency list and using it in the computation are mechanically linked parts of the same micro-task. Either edit could be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to complete the coherent change."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'ticket_record' in their changed lines. Edit 0 creates/assigns the ticket_record variable, and Edit 1 uses that same ticket_record variable in an assertion. The changed lines in both edits explicitly reference the same symbol, creating a direct code dependency where the variable must be defined before it can be used in the assertion."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'simple_record' in their changed lines. Edit 0 creates and assigns the simple_record variable, while Edit 1 uses that same simple_record variable as a parameter in the _get_web_context call. The changed lines in both edits explicitly reference the same symbol, creating a direct code dependency where the creation of simple_record in Edit 0 enables its usage in Edit 1. This represents a definition-usage relationship for the same symbol within the same function scope."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'simple_record' in their changed lines. Edit 0 creates and assigns the simple_record variable, while Edit 1 uses that same simple_record variable as a parameter in the _get_web_context call. The changed lines in both edits explicitly reference the same symbol, creating a direct code dependency where the creation of simple_record in Edit 0 enables its usage in Edit 1. This represents a definition-usage relationship for the same symbol within the same function scope."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform identical structural transformations within the same test method. They both: (1) extract the context creation into a variable named 'ctx', (2) change 'composition_mode' to 'default_composition_mode' in the _get_web_context call, and (3) use the extracted 'ctx' variable in the with_context call. This represents a uniform refactoring pattern applied to the same type of syntactic construct (context creation and usage) within the same function scope. The edits are part of a single, contiguous refactoring operation that could be performed in either order."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform identical structural transformations within the same test method. They both: (1) extract the context creation into a variable named 'ctx', (2) change 'composition_mode' to 'default_composition_mode' in the _get_web_context call, and (3) use the extracted 'ctx' variable in the with_context call. This represents a uniform refactoring pattern applied to the same type of syntactic construct (context creation and usage) within the same function scope. The edits are part of a single, contiguous refactoring operation that could be performed in either order."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbols: 'ticket_record' and 'nonthread_record'. Edit 0 creates these variables by assigning them to database records, and Edit 1 uses these exact same variables in method calls and assertions. After making Edit 0, the variables are defined and available for use in Edit 1. After making Edit 1, the variables are being used, which creates an immediate prompt to ensure they are properly defined in Edit 0. This is a classic definition-usage relationship where both edits reference the same symbols and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbols: 'ticket_record' and 'nonthread_record'. Edit 0 creates these variables by assigning them to database records, and Edit 1 uses these exact same variables in method calls and assertions. After making Edit 0, the variables are defined and available for use in Edit 1. After making Edit 1, the variables are being used, which creates an immediate prompt to ensure they are properly defined in Edit 0. This is a classic definition-usage relationship where both edits reference the same symbols and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform identical structural refactoring within the same test method. They extract the context creation into a variable 'ctx' and change 'composition_mode' to 'default_composition_mode' in the _get_web_context call. This is a uniform substitution pattern applied to the same type of syntactic construct (context creation and usage pattern) within the same function scope. The edits are part of a single, contiguous refactoring operation with identical before\u2192after transformation patterns."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform identical structural refactoring within the same test method. They extract the context creation into a variable 'ctx' and change 'composition_mode' to 'default_composition_mode' in the _get_web_context call. This is a uniform substitution pattern applied to the same type of syntactic construct (context creation and usage pattern) within the same function scope. The edits are part of a single, contiguous refactoring operation with identical before\u2192after transformation patterns."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbol 'ticket_record' in their changed lines. Edit 0 creates/defines the ticket_record variable, and Edit 1 uses that same ticket_record variable in a function call. This creates a direct definition-usage relationship where the changed lines reference the same symbol. In Python, both edits can be parsed and staged in either order (the usage before definition would only cause a runtime NameError, not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'ticket_record' in their changed lines. Edit 0 creates/defines the ticket_record variable, and Edit 1 uses that same ticket_record variable in a function call. This creates a direct definition-usage relationship where the changed lines reference the same symbol. In Python, both edits can be parsed and staged in either order (the usage before definition would only cause a runtime NameError, not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform identical structural refactoring within the same test method. They extract the context creation into a variable 'ctx' and change 'composition_mode' to 'default_composition_mode' in the _get_web_context call. This is a uniform substitution pattern applied to similar code constructs (context creation and usage) within the same function. The edits are part of the same refactoring micro-task and either could be applied first without breaking the code."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform identical structural refactoring within the same test method. They extract the context creation into a variable 'ctx' and change 'composition_mode' to 'default_composition_mode' in the _get_web_context call. This is a uniform substitution pattern applied to similar code constructs (context creation and usage) within the same function. The edits are part of the same refactoring micro-task and either could be applied first without breaking the code."
        }
    ],
    "allowed_init_edits": [
        7
    ]
}