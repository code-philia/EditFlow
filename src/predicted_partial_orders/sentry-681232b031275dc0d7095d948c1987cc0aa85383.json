{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical structural substitution pattern: removing 'BaseTestCase' from the inheritance list of test classes, changing from 'class X(TestCase, BaseTestCase):' to 'class X(TestCase):'. This is a uniform refactoring operation targeting the same type of syntactic construct (class inheritance declarations) with the exact same before\u2192after pattern. Both edits are part of what appears to be a single, contiguous refactor to remove BaseTestCase inheritance from test classes across the codebase."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical structural substitution pattern: removing 'BaseTestCase' from the inheritance list of test classes, changing from 'class X(TestCase, BaseTestCase):' to 'class X(TestCase):'. This is a uniform refactoring operation targeting the same type of syntactic construct (class inheritance declarations) with the exact same before\u2192after pattern. Both edits are part of what appears to be a single, contiguous refactor to remove BaseTestCase inheritance from test classes across the codebase."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform the identical textual substitution pattern of removing 'BaseTestCase' from import statements and class inheritance declarations. Edit 0 removes 'BaseTestCase' from an import line, while Edit 1 removes 'BaseTestCase' from a class inheritance declaration. This represents a uniform refactoring pattern where BaseTestCase is being systematically removed across the codebase. Both edits target the same syntactic construct type (references to the BaseTestCase symbol) and apply the same before\u2192after transformation (removing BaseTestCase references). This is a clear case of bulk-edit synchronization where both edits are part of the same contiguous refactoring sweep."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform the identical textual substitution pattern of removing 'BaseTestCase' from import statements and class inheritance declarations. Edit 0 removes 'BaseTestCase' from an import line, while Edit 1 removes 'BaseTestCase' from a class inheritance declaration. This represents a uniform refactoring pattern where BaseTestCase is being systematically removed across the codebase. Both edits target the same syntactic construct type (references to the BaseTestCase symbol) and apply the same before\u2192after transformation (removing BaseTestCase references). This is a clear case of bulk-edit synchronization where both edits are part of the same contiguous refactoring sweep."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits involve removing the exact same symbol 'BaseTestCase' from the same file. Edit 0 removes 'BaseTestCase' from the import statement, and Edit 1 removes 'BaseTestCase' from the class inheritance. After removing the import in Edit 0, the reference to 'BaseTestCase' in the class definition (Edit 1) would cause a NameError at runtime when the module is imported. However, in Python, both edits can be written and parsed in either order - the parser doesn't enforce that imported symbols must be defined before use in class inheritance. The relationship is bi-directional because both edits reference the exact same symbol 'BaseTestCase' and either edit naturally prompts the other as the next mechanical step in removing this dependency."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits involve removing the exact same symbol 'BaseTestCase' from the same file. Edit 0 removes 'BaseTestCase' from the import statement, and Edit 1 removes 'BaseTestCase' from the class inheritance. After removing the import in Edit 0, the reference to 'BaseTestCase' in the class definition (Edit 1) would cause a NameError at runtime when the module is imported. However, in Python, both edits can be written and parsed in either order - the parser doesn't enforce that imported symbols must be defined before use in class inheritance. The relationship is bi-directional because both edits reference the exact same symbol 'BaseTestCase' and either edit naturally prompts the other as the next mechanical step in removing this dependency."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitutions by removing 'BaseTestCase' from import statements. Edit 0 removes 'BaseTestCase, ' from the import line, while edit 1 removes the entire line 'from sentry.testutils.cases import BaseTestCase'. Both are part of the same cleanup operation removing unused BaseTestCase imports across multiple files. This represents a bulk-edit pattern with identical before\u2192after substitution (removing BaseTestCase imports) targeting the same type of syntactic construct (import statements)."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform identical textual substitutions by removing 'BaseTestCase' from import statements. Edit 0 removes 'BaseTestCase, ' from the import line, while edit 1 removes the entire line 'from sentry.testutils.cases import BaseTestCase'. Both are part of the same cleanup operation removing unused BaseTestCase imports across multiple files. This represents a bulk-edit pattern with identical before\u2192after substitution (removing BaseTestCase imports) targeting the same type of syntactic construct (import statements)."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 removes the import of BaseTestCase from line 15, and Edit 1 removes BaseTestCase from the class inheritance on line 56. These edits reference the exact same symbol (BaseTestCase) - one removes its import and the other removes its usage in class inheritance. After removing the import in Edit 0, the usage in Edit 1 becomes undefined, creating an immediate code-driven prompt to remove the usage. Similarly, after removing the usage in Edit 1, the import in Edit 0 becomes unused, prompting its removal. Both edits can be staged in either order without parser errors (Python allows undefined names in class inheritance at parse time), making this a bi-directional relationship."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 removes the import of BaseTestCase from line 15, and Edit 1 removes BaseTestCase from the class inheritance on line 56. These edits reference the exact same symbol (BaseTestCase) - one removes its import and the other removes its usage in class inheritance. After removing the import in Edit 0, the usage in Edit 1 becomes undefined, creating an immediate code-driven prompt to remove the usage. Similarly, after removing the usage in Edit 1, the import in Edit 0 becomes unused, prompting its removal. Both edits can be staged in either order without parser errors (Python allows undefined names in class inheritance at parse time), making this a bi-directional relationship."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform the identical textual substitution pattern of removing 'BaseTestCase' from class inheritance or import statements. Edit 0 removes 'BaseTestCase' from an import statement, while Edit 1 removes 'BaseTestCase' from a class inheritance declaration. This represents a bulk refactoring operation where the same pattern (removing BaseTestCase references) is being applied across multiple files to the same type of syntactic construct (removing BaseTestCase from different contexts). Both edits are part of the same refactoring sweep to eliminate BaseTestCase usage, making either edit a natural prompt for the other as part of the same contiguous micro-task."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform the identical textual substitution pattern of removing 'BaseTestCase' from class inheritance or import statements. Edit 0 removes 'BaseTestCase' from an import statement, while Edit 1 removes 'BaseTestCase' from a class inheritance declaration. This represents a bulk refactoring operation where the same pattern (removing BaseTestCase references) is being applied across multiple files to the same type of syntactic construct (removing BaseTestCase from different contexts). Both edits are part of the same refactoring sweep to eliminate BaseTestCase usage, making either edit a natural prompt for the other as part of the same contiguous micro-task."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 removes the import of BaseTestCase from line 15, and Edit 1 removes BaseTestCase from the class inheritance on line 34. Both edits reference the exact same symbol 'BaseTestCase' - one removes its import and the other removes its usage in class inheritance. After removing the import (Edit 0), the usage in the class definition (Edit 1) would cause a NameError at runtime when the class is defined. However, in Python, both edits can be written and parsed in either order since undefined names in class inheritance don't cause parse-time syntax errors. The relationship is bi-directional because either edit creates an immediate, mechanically obvious prompt for the other as the next step in removing BaseTestCase from the codebase."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 removes the import of BaseTestCase from line 15, and Edit 1 removes BaseTestCase from the class inheritance on line 34. Both edits reference the exact same symbol 'BaseTestCase' - one removes its import and the other removes its usage in class inheritance. After removing the import (Edit 0), the usage in the class definition (Edit 1) would cause a NameError at runtime when the class is defined. However, in Python, both edits can be written and parsed in either order since undefined names in class inheritance don't cause parse-time syntax errors. The relationship is bi-directional because either edit creates an immediate, mechanically obvious prompt for the other as the next step in removing BaseTestCase from the codebase."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: removing 'BaseTestCase' from the class inheritance list, changing '(TestCase, BaseTestCase)' to '(TestCase)'. This is a uniform refactoring operation targeting the same type of syntactic construct (class inheritance declarations) with the exact same before\u2192after pattern. Both edits are part of a single, contiguous refactor to remove BaseTestCase inheritance from test classes."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: removing 'BaseTestCase' from the class inheritance list, changing '(TestCase, BaseTestCase)' to '(TestCase)'. This is a uniform refactoring operation targeting the same type of syntactic construct (class inheritance declarations) with the exact same before\u2192after pattern. Both edits are part of a single, contiguous refactor to remove BaseTestCase inheritance from test classes."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'BaseTestCase' - edit 0 removes the import of BaseTestCase, and edit 1 removes BaseTestCase from the class inheritance. After removing the import in edit 0, the usage in edit 1 would cause a NameError at runtime when the class is defined. However, in Python, both edits can be written and parsed in either order since undefined names in class inheritance don't cause parse-time syntax errors. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step when removing this dependency."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'BaseTestCase' - edit 0 removes the import of BaseTestCase, and edit 1 removes BaseTestCase from the class inheritance. After removing the import in edit 0, the usage in edit 1 would cause a NameError at runtime when the class is defined. However, in Python, both edits can be written and parsed in either order since undefined names in class inheritance don't cause parse-time syntax errors. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step when removing this dependency."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution pattern: removing 'BaseTestCase' from the class inheritance list while keeping 'TestCase'. This is a uniform refactoring operation where the same before\u2192after pattern ('TestCase, BaseTestCase' \u2192 'TestCase') is applied to the same type of syntactic construct (class inheritance declarations) in the same file. Both edits are part of a single, contiguous refactor to clean up test class inheritance."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical structural substitution pattern: removing 'BaseTestCase' from the class inheritance list while keeping 'TestCase'. This is a uniform refactoring operation where the same before\u2192after pattern ('TestCase, BaseTestCase' \u2192 'TestCase') is applied to the same type of syntactic construct (class inheritance declarations) in the same file. Both edits are part of a single, contiguous refactor to clean up test class inheritance."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical structural substitution pattern: removing 'BaseTestCase' from the class inheritance list while keeping 'TestCase'. This is a uniform refactoring operation where the same before\u2192after pattern ('TestCase, BaseTestCase' \u2192 'TestCase') is applied to the same type of syntactic construct (class inheritance declarations) in the same file. Both edits are part of a single, contiguous refactor to clean up test class inheritance."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical structural substitution pattern: removing 'BaseTestCase' from the class inheritance list while keeping 'TestCase'. This is a uniform refactoring operation where the same before\u2192after pattern ('TestCase, BaseTestCase' \u2192 'TestCase') is applied to the same type of syntactic construct (class inheritance declarations) in the same file. Both edits are part of a single, contiguous refactor to clean up test class inheritance."
        }
    ],
    "allowed_init_edits": [
        1
    ]
}