{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds a 'max_prefetch' parameter to the ChunkManager.__init__ method signature. Edit 1 passes this same 'max_prefetch' parameter to the init_chunk_manager function call, which creates a ChunkManager instance. The changed lines reference the exact same symbol (max_prefetch parameter) - edit 0 defines it in the constructor signature and edit 1 uses it in the function call that creates the ChunkManager. This creates an immediate code dependency where adding the parameter to the constructor (edit 0) requires passing it in the call site (edit 1), and vice versa. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds a 'max_prefetch' parameter to the ChunkManager.__init__ method signature. Edit 1 passes this same 'max_prefetch' parameter to the init_chunk_manager function call, which creates a ChunkManager instance. The changed lines reference the exact same symbol (max_prefetch parameter) - edit 0 defines it in the constructor signature and edit 1 uses it in the function call that creates the ChunkManager. This creates an immediate code dependency where adding the parameter to the constructor (edit 0) requires passing it in the call site (edit 1), and vice versa. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 adds a new parameter `max_prefetch` to the ChunkManager constructor's implementation, using it to conditionally initialize `self._prefetch_stream`. Edit 1 updates a call to the ChunkManager constructor to pass the `max_prefetch` parameter. These edits reference the exact same symbol (the ChunkManager constructor) and create a direct code dependency - after adding the parameter usage in the constructor (edit 0), the caller must be updated to provide that parameter (edit 1), or vice versa. This is a classic signature-caller relationship where both edits can be staged in either order without parse errors, making either edit prompt the other as the immediate next step."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 adds a new parameter `max_prefetch` to the ChunkManager constructor's implementation, using it to conditionally initialize `self._prefetch_stream`. Edit 1 updates a call to the ChunkManager constructor to pass the `max_prefetch` parameter. These edits reference the exact same symbol (the ChunkManager constructor) and create a direct code dependency - after adding the parameter usage in the constructor (edit 0), the caller must be updated to provide that parameter (edit 1), or vice versa. This is a classic signature-caller relationship where both edits can be staged in either order without parse errors, making either edit prompt the other as the immediate next step."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 adds a 'max_prefetch' parameter to the ChunkManager.__init__ method signature. Edit 1 updates a call to ChunkManager() to include the new 'max_prefetch' parameter. These edits reference the exact same symbol (the max_prefetch parameter of ChunkManager.__init__) and create a direct code dependency - after adding the parameter to the constructor signature, the call site needs to be updated to pass this parameter. This is a classic definition-usage relationship where both edits can be staged in either order (the call site can include the parameter even before the constructor accepts it, as this would only cause a runtime TypeError, not a parse error)."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 adds a 'max_prefetch' parameter to the ChunkManager.__init__ method signature. Edit 1 updates a call to ChunkManager() to include the new 'max_prefetch' parameter. These edits reference the exact same symbol (the max_prefetch parameter of ChunkManager.__init__) and create a direct code dependency - after adding the parameter to the constructor signature, the call site needs to be updated to pass this parameter. This is a classic definition-usage relationship where both edits can be staged in either order (the call site can include the parameter even before the constructor accepts it, as this would only cause a runtime TypeError, not a parse error)."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 adds a new parameter `max_prefetch` to the ChunkManager constructor and uses it to initialize `self._prefetch_stream`. Edit 1 passes the `max_prefetch` parameter to the ChunkManager constructor call. These edits reference the exact same symbol (`max_prefetch` parameter) and create a direct definition-usage relationship. After adding the parameter to the constructor signature in edit 0, the caller in edit 1 needs to be updated to pass this parameter, making them mechanically linked. Either edit can be staged first since both are syntactically valid independently, but together they form a cohesive parameter addition pattern."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 adds a new parameter `max_prefetch` to the ChunkManager constructor and uses it to initialize `self._prefetch_stream`. Edit 1 passes the `max_prefetch` parameter to the ChunkManager constructor call. These edits reference the exact same symbol (`max_prefetch` parameter) and create a direct definition-usage relationship. After adding the parameter to the constructor signature in edit 0, the caller in edit 1 needs to be updated to pass this parameter, making them mechanically linked. Either edit can be staged first since both are syntactically valid independently, but together they form a cohesive parameter addition pattern."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds a 'max_prefetch' parameter to the ChunkManager.__init__ method signature. Edit 1 passes the 'max_prefetch' parameter to the ChunkManager constructor call. These edits reference the exact same symbol (the max_prefetch parameter) and create a direct code dependency - after adding the parameter to the constructor signature, the caller must be updated to provide that parameter to avoid a TypeError. Either edit can be made first since both are syntactically valid, but making either edit creates an immediate, mechanically obvious prompt for the other as the next contiguous action."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds a 'max_prefetch' parameter to the ChunkManager.__init__ method signature. Edit 1 passes the 'max_prefetch' parameter to the ChunkManager constructor call. These edits reference the exact same symbol (the max_prefetch parameter) and create a direct code dependency - after adding the parameter to the constructor signature, the caller must be updated to provide that parameter to avoid a TypeError. Either edit can be made first since both are syntactically valid, but making either edit creates an immediate, mechanically obvious prompt for the other as the next contiguous action."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits add the exact same parameter 'max_prefetch: int = 0' to function signatures. Edit 0 adds it to the ChunkManager.__init__ method, and Edit 1 adds it to the init_chunk_manager function. Looking at the structural context, init_chunk_manager appears to be a utility function that creates and returns a ChunkManager instance, so it would need to pass the max_prefetch parameter to the ChunkManager constructor. This creates a direct parameter threading relationship where both functions need the same parameter to maintain API consistency. The changed lines in both edits reference the exact same parameter name and type, and this appears to be part of a synchronized parameter addition across related functions in the same codebase. Either edit could be made first and would prompt the other as the next mechanical step to maintain consistency."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits add the exact same parameter 'max_prefetch: int = 0' to function signatures. Edit 0 adds it to the ChunkManager.__init__ method, and Edit 1 adds it to the init_chunk_manager function. Looking at the structural context, init_chunk_manager appears to be a utility function that creates and returns a ChunkManager instance, so it would need to pass the max_prefetch parameter to the ChunkManager constructor. This creates a direct parameter threading relationship where both functions need the same parameter to maintain API consistency. The changed lines in both edits reference the exact same parameter name and type, and this appears to be part of a synchronized parameter addition across related functions in the same codebase. Either edit could be made first and would prompt the other as the next mechanical step to maintain consistency."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'max_prefetch' within the same function (__init__). Edit 0 adds 'max_prefetch' as a parameter to the function signature, and Edit 1 uses that same parameter in the function body to conditionally create a prefetch stream. This creates a direct code dependency where the parameter definition in the signature enables its usage in the body. Either edit can be staged first since Python allows referencing parameters in function bodies even if the parameter isn't defined yet (would only cause a runtime NameError, not a parse error). After making either edit, the other becomes the immediate next step to complete the parameter threading pattern."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'max_prefetch' within the same function (__init__). Edit 0 adds 'max_prefetch' as a parameter to the function signature, and Edit 1 uses that same parameter in the function body to conditionally create a prefetch stream. This creates a direct code dependency where the parameter definition in the signature enables its usage in the body. Either edit can be staged first since Python allows referencing parameters in function bodies even if the parameter isn't defined yet (would only cause a runtime NameError, not a parse error). After making either edit, the other becomes the immediate next step to complete the parameter threading pattern."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 adds a line that uses the `max_prefetch` parameter in the ChunkManager constructor to initialize `self._prefetch_stream`. Edit 1 adds the `max_prefetch` parameter to a function call that creates a ChunkManager instance. The changed lines reference the exact same symbol `max_prefetch` - edit 1 passes it as a parameter and edit 0 uses it in the constructor body. This creates a direct code dependency where the parameter added in edit 1 is immediately used by the code added in edit 0. Both edits are part of the same micro-task of threading the `max_prefetch` parameter through the system."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 adds a line that uses the `max_prefetch` parameter in the ChunkManager constructor to initialize `self._prefetch_stream`. Edit 1 adds the `max_prefetch` parameter to a function call that creates a ChunkManager instance. The changed lines reference the exact same symbol `max_prefetch` - edit 1 passes it as a parameter and edit 0 uses it in the constructor body. This creates a direct code dependency where the parameter added in edit 1 is immediately used by the code added in edit 0. Both edits are part of the same micro-task of threading the `max_prefetch` parameter through the system."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'max_prefetch' within the same function. Edit 0 adds 'max_prefetch' as a parameter to the function signature, and Edit 1 uses that same parameter in the ChunkManager constructor call. This creates a direct code dependency where adding the parameter naturally prompts its usage in the function body, and vice versa. Both edits can be staged in either order without causing parse errors (the parameter can be added before its usage or the usage can be added before the parameter definition in Python), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'max_prefetch' within the same function. Edit 0 adds 'max_prefetch' as a parameter to the function signature, and Edit 1 uses that same parameter in the ChunkManager constructor call. This creates a direct code dependency where adding the parameter naturally prompts its usage in the function body, and vice versa. Both edits can be staged in either order without causing parse errors (the parameter can be added before its usage or the usage can be added before the parameter definition in Python), making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "Edit 0 adds a new attribute `_prefetch_stream` to the ChunkManager class in its __init__ method. Edit 1 uses this exact same attribute by accessing `self._gemini_manager.chunk_manager._prefetch_stream` in a stream context. The changed lines reference the exact same symbol - the `_prefetch_stream` attribute. After adding the attribute in edit 0, edit 1 becomes the natural next step to use this newly created stream. However, edit 1 could also be written first (it would just cause a runtime AttributeError when executed), so this is bi-directional rather than ordered since both edits can be parsed and staged in either order."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "Edit 0 adds a new attribute `_prefetch_stream` to the ChunkManager class in its __init__ method. Edit 1 uses this exact same attribute by accessing `self._gemini_manager.chunk_manager._prefetch_stream` in a stream context. The changed lines reference the exact same symbol - the `_prefetch_stream` attribute. After adding the attribute in edit 0, edit 1 becomes the natural next step to use this newly created stream. However, edit 1 could also be written first (it would just cause a runtime AttributeError when executed), so this is bi-directional rather than ordered since both edits can be parsed and staged in either order."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 adds a 'max_prefetch' parameter to the init_chunk_manager function signature. Edit 1 passes this same 'max_prefetch' parameter to a ChunkManager constructor call. The changed lines reference the exact same symbol 'max_prefetch' - edit 0 defines it as a parameter and edit 1 uses it in a function call. This creates a direct code dependency where adding the parameter in the function signature naturally prompts its usage in the call site, making them part of the same contiguous micro-task of threading the parameter through the code."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 adds a 'max_prefetch' parameter to the init_chunk_manager function signature. Edit 1 passes this same 'max_prefetch' parameter to a ChunkManager constructor call. The changed lines reference the exact same symbol 'max_prefetch' - edit 0 defines it as a parameter and edit 1 uses it in a function call. This creates a direct code dependency where adding the parameter in the function signature naturally prompts its usage in the call site, making them part of the same contiguous micro-task of threading the parameter through the code."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 adds a 'max_prefetch' parameter to the init_chunk_manager function signature, and Edit 1 passes that exact same parameter when calling init_chunk_manager. The changed lines reference the exact same symbol 'max_prefetch' - one defines it as a parameter and the other uses it as an argument. This creates an immediate code dependency where adding the parameter naturally prompts passing it at the call site, or vice versa. Both edits can be staged in either order without parser errors (the function call with an extra argument would just cause a runtime TypeError, not a syntax error), making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 adds a 'max_prefetch' parameter to the init_chunk_manager function signature, and Edit 1 passes that exact same parameter when calling init_chunk_manager. The changed lines reference the exact same symbol 'max_prefetch' - one defines it as a parameter and the other uses it as an argument. This creates an immediate code dependency where adding the parameter naturally prompts passing it at the call site, or vice versa. Both edits can be staged in either order without parser errors (the function call with an extra argument would just cause a runtime TypeError, not a syntax error), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform identical structural modifications to ChunkManager constructor calls by adding the max_prefetch parameter in the same position and format. The changed lines in both edits reference the exact same constructor (ChunkManager) and apply the same before\u2192after pattern: adding ', max_prefetch=max_prefetch' to the parameter list. This represents a uniform, synchronized substitution across multiple call sites of the same constructor, which constitutes a bulk-edit pattern where both edits are part of a single contiguous refactor to update all ChunkManager instantiations."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform identical structural modifications to ChunkManager constructor calls by adding the max_prefetch parameter in the same position and format. The changed lines in both edits reference the exact same constructor (ChunkManager) and apply the same before\u2192after pattern: adding ', max_prefetch=max_prefetch' to the parameter list. This represents a uniform, synchronized substitution across multiple call sites of the same constructor, which constitutes a bulk-edit pattern where both edits are part of a single contiguous refactor to update all ChunkManager instantiations."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits add the same parameter 'max_prefetch' to different function calls within the same constructor method. Edit 0 adds 'max_prefetch=max_prefetch' to the ChunkManager constructor call, and Edit 1 adds 'max_prefetch=max_prefetch' to the init_chunk_manager function call. Both changed lines reference the exact same symbol 'max_prefetch' (the parameter from the constructor signature), and this appears to be part of a single micro-task of threading the max_prefetch parameter through to the underlying chunk management components. This is a clear case of parameter threading where the same parameter symbol is being passed to multiple related function calls as part of one contiguous refactoring action."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits add the same parameter 'max_prefetch' to different function calls within the same constructor method. Edit 0 adds 'max_prefetch=max_prefetch' to the ChunkManager constructor call, and Edit 1 adds 'max_prefetch=max_prefetch' to the init_chunk_manager function call. Both changed lines reference the exact same symbol 'max_prefetch' (the parameter from the constructor signature), and this appears to be part of a single micro-task of threading the max_prefetch parameter through to the underlying chunk management components. This is a clear case of parameter threading where the same parameter symbol is being passed to multiple related function calls as part of one contiguous refactoring action."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 imports the symbol 'get_accelerator' from colossalai.accelerator, and Edit 1 uses that exact same symbol 'get_accelerator' in a function call within the same file. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. After making the import in Edit 0, using get_accelerator() in Edit 1 becomes mechanically possible. Conversely, after adding the usage in Edit 1, the import in Edit 0 becomes the immediate next required step to resolve the undefined symbol. Since this is Python, both edits can be written and parsed in either order (the usage would only fail at runtime/import-time without the import), making this a bi-directional relationship."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 imports the symbol 'get_accelerator' from colossalai.accelerator, and Edit 1 uses that exact same symbol 'get_accelerator' in a function call within the same file. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. After making the import in Edit 0, using get_accelerator() in Edit 1 becomes mechanically possible. Conversely, after adding the usage in Edit 1, the import in Edit 0 becomes the immediate next required step to resolve the undefined symbol. Since this is Python, both edits can be written and parsed in either order (the usage would only fail at runtime/import-time without the import), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'max_prefetch' and are part of a synchronized parameter threading operation. Edit 1 adds 'max_prefetch=max_prefetch' to the call site of init_chunk_manager(), while Edit 0 adds 'max_prefetch=max_prefetch' to the ChunkManager constructor call within that same init_chunk_manager() function. This creates a direct code dependency where the parameter is being threaded through the call chain - the caller passes max_prefetch to init_chunk_manager, which then passes it to ChunkManager. Both edits can be staged in either order since they don't create parse errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'max_prefetch' and are part of a synchronized parameter threading operation. Edit 1 adds 'max_prefetch=max_prefetch' to the call site of init_chunk_manager(), while Edit 0 adds 'max_prefetch=max_prefetch' to the ChunkManager constructor call within that same init_chunk_manager() function. This creates a direct code dependency where the parameter is being threaded through the call chain - the caller passes max_prefetch to init_chunk_manager, which then passes it to ChunkManager. Both edits can be staged in either order since they don't create parse errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        }
    ],
    "allowed_init_edits": [
        6
    ]
}