{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 defines a new variable 'runserver_args' with the value ['--noreload'], and Edit 1 uses this exact same variable 'runserver_args' in a list concatenation operation. The changed lines reference the exact same symbol - the variable 'runserver_args'. After making Edit 0, Edit 1 becomes the immediate next step to actually use the newly defined variable. This is a classic definition-usage pattern where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 defines a new variable 'runserver_args' with the value ['--noreload'], and Edit 1 uses this exact same variable 'runserver_args' in a list concatenation operation. The changed lines reference the exact same symbol - the variable 'runserver_args'. After making Edit 0, Edit 1 becomes the immediate next step to actually use the newly defined variable. This is a classic definition-usage pattern where both edits reference the same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'runserver_args' within the same file. Edit 0 initializes 'runserver_args = []' and edit 1 assigns 'runserver_args = ['--noreload']' in a conditional block. The changed lines in both edits directly reference the same variable symbol. After making either edit, the other becomes a natural next step in the same micro-task of setting up the runserver_args variable - first initializing it, then conditionally modifying it. This represents a clear definition-usage pattern for the same symbol within a single development flow."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'runserver_args' within the same file. Edit 0 initializes 'runserver_args = []' and edit 1 assigns 'runserver_args = ['--noreload']' in a conditional block. The changed lines in both edits directly reference the same variable symbol. After making either edit, the other becomes a natural next step in the same micro-task of setting up the runserver_args variable - first initializing it, then conditionally modifying it. This represents a clear definition-usage pattern for the same symbol within a single development flow."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 defines a new variable 'runserver_args = []' at line 98, and Edit 1 uses this exact same variable 'runserver_args' in line 159 by adding it to a list concatenation. The changed lines reference the exact same symbol 'runserver_args'. After defining the variable in Edit 0, using it in Edit 1 becomes the immediate next step to incorporate the new variable into the existing code structure. Both edits can be staged in either order since Python allows referencing undefined variables at parse time (would only cause a NameError at runtime), making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 defines a new variable 'runserver_args = []' at line 98, and Edit 1 uses this exact same variable 'runserver_args' in line 159 by adding it to a list concatenation. The changed lines reference the exact same symbol 'runserver_args'. After defining the variable in Edit 0, using it in Edit 1 becomes the immediate next step to incorporate the new variable into the existing code structure. Both edits can be staged in either order since Python allows referencing undefined variables at parse time (would only cause a NameError at runtime), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 1 defines the AUTORELOAD setting in settings.py, and Edit 0 uses that exact same symbol (settings.AUTORELOAD) in the tornado application configuration. The changed line in Edit 0 explicitly references the symbol defined in Edit 1's changed line. This creates a direct code dependency where defining AUTORELOAD enables its usage in the tornado configuration. Both edits can be staged in either order since Python allows referencing undefined attributes at parse time (would only fail at runtime/import time), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 1 defines the AUTORELOAD setting in settings.py, and Edit 0 uses that exact same symbol (settings.AUTORELOAD) in the tornado application configuration. The changed line in Edit 0 explicitly references the symbol defined in Edit 1's changed line. This creates a direct code dependency where defining AUTORELOAD enables its usage in the tornado configuration. Both edits can be staged in either order since Python allows referencing undefined attributes at parse time (would only fail at runtime/import time), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        }
    ],
    "allowed_init_edits": [
        5
    ]
}