{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds a new parameter 'id_field_name' to the GroupPermissionSetting class definition, and Edit 1 adds the same parameter with a specific value to a GroupPermissionSetting instantiation. The changed lines reference the exact same symbol (the id_field_name parameter), creating a direct definition-usage relationship. After adding the parameter to the class definition, the instantiation naturally needs to be updated to provide the new required parameter, making this a bi-directional relationship where either edit prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds a new parameter 'id_field_name' to the GroupPermissionSetting class definition, and Edit 1 adds the same parameter with a specific value to a GroupPermissionSetting instantiation. The changed lines reference the exact same symbol (the id_field_name parameter), creating a direct definition-usage relationship. After adding the parameter to the class definition, the instantiation naturally needs to be updated to provide the new required parameter, making this a bi-directional relationship where either edit prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds a new parameter 'id_field_name' to the GroupPermissionSetting class definition, while Edit 1 adds the same parameter with a specific value to a GroupPermissionSetting constructor call. These edits reference the exact same symbol (the id_field_name parameter) and have a direct code dependency - adding the parameter to the class definition creates an immediate prompt to provide it in the constructor call. Either edit can be staged first without causing parse errors, making this a bi-directional relationship where both edits are part of the same micro-task of adding this parameter to the GroupPermissionSetting interface."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds a new parameter 'id_field_name' to the GroupPermissionSetting class definition, while Edit 1 adds the same parameter with a specific value to a GroupPermissionSetting constructor call. These edits reference the exact same symbol (the id_field_name parameter) and have a direct code dependency - adding the parameter to the class definition creates an immediate prompt to provide it in the constructor call. Either edit can be staged first without causing parse errors, making this a bi-directional relationship where both edits are part of the same micro-task of adding this parameter to the GroupPermissionSetting interface."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 adds the 'id_field_name' attribute to a GroupPermissionSetting configuration, while Edit 1 changes code to use 'permission_config.id_field_name' instead of constructing the field name via string concatenation. The changed lines reference the exact same symbol - the 'id_field_name' attribute that is being added in Edit 0 and accessed in Edit 1. This creates a direct code dependency where Edit 1's changed line explicitly references the attribute being added in Edit 0. Either edit can be staged first without causing parse errors, but making either edit creates an immediate prompt for the other as the next mechanical step in implementing this refactoring."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 adds the 'id_field_name' attribute to a GroupPermissionSetting configuration, while Edit 1 changes code to use 'permission_config.id_field_name' instead of constructing the field name via string concatenation. The changed lines reference the exact same symbol - the 'id_field_name' attribute that is being added in Edit 0 and accessed in Edit 1. This creates a direct code dependency where Edit 1's changed line explicitly references the attribute being added in Edit 0. Either edit can be staged first without causing parse errors, but making either edit creates an immediate prompt for the other as the next mechanical step in implementing this refactoring."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 adds an 'id_field_name' attribute to the GroupPermissionSetting class, and Edit 1 uses this exact same attribute (permissions_configuration.id_field_name) to replace a hardcoded string concatenation. The changed line in Edit 1 directly references the attribute that was added in Edit 0. This creates an immediate code dependency where Edit 0 defines the attribute that Edit 1 uses. However, since this is Python, Edit 1 could be written and parsed before Edit 0 (it would only fail at runtime with an AttributeError), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 adds an 'id_field_name' attribute to the GroupPermissionSetting class, and Edit 1 uses this exact same attribute (permissions_configuration.id_field_name) to replace a hardcoded string concatenation. The changed line in Edit 1 directly references the attribute that was added in Edit 0. This creates an immediate code dependency where Edit 0 defines the attribute that Edit 1 uses. However, since this is Python, Edit 1 could be written and parsed before Edit 0 (it would only fail at runtime with an AttributeError), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds an 'id_field_name' attribute to the GroupPermissionSetting class, and Edit 1 uses that exact same attribute (permission_config.id_field_name) to replace a string concatenation operation. The changed line in Edit 1 directly references the attribute that was added in Edit 0. This creates a definition-usage relationship where both edits reference the exact same symbol (the id_field_name attribute). Either edit could be made first since Python allows referencing undefined attributes at parse time (would only fail at runtime), making this a bi-directional relationship where making either edit creates an immediate prompt for the other."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds an 'id_field_name' attribute to the GroupPermissionSetting class, and Edit 1 uses that exact same attribute (permission_config.id_field_name) to replace a string concatenation operation. The changed line in Edit 1 directly references the attribute that was added in Edit 0. This creates a definition-usage relationship where both edits reference the exact same symbol (the id_field_name attribute). Either edit could be made first since Python allows referencing undefined attributes at parse time (would only fail at runtime), making this a bi-directional relationship where making either edit creates an immediate prompt for the other."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds an 'id_field_name' attribute to the GroupPermissionSetting class, and Edit 1 uses that exact same attribute (permission_config.id_field_name) to replace a string concatenation operation. The changed line in Edit 1 directly references the attribute that was added in Edit 0. This creates a definition-usage relationship where both edits reference the exact same symbol. Either edit can be staged first (the usage would result in a runtime AttributeError if staged before the definition, but both are syntactically valid), making this a bi-directional relationship where making either edit creates an immediate prompt for the other."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds an 'id_field_name' attribute to the GroupPermissionSetting class, and Edit 1 uses that exact same attribute (permission_config.id_field_name) to replace a string concatenation operation. The changed line in Edit 1 directly references the attribute that was added in Edit 0. This creates a definition-usage relationship where both edits reference the exact same symbol. Either edit can be staged first (the usage would result in a runtime AttributeError if staged before the definition, but both are syntactically valid), making this a bi-directional relationship where making either edit creates an immediate prompt for the other."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'setting_name + \"_id\"' with a reference to an 'id_field_name' attribute from a configuration object. In edit 0, it's 'permissions_configuration.id_field_name' and in edit 1, it's 'permission_config.id_field_name'. This represents a uniform refactoring pattern where the same string concatenation logic is being replaced with a more structured approach using configuration objects. Both edits target the same type of syntactic construct (assignment statements) and apply the identical before\u2192after transformation pattern as part of what appears to be a single, contiguous refactoring sweep."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'setting_name + \"_id\"' with a reference to an 'id_field_name' attribute from a configuration object. In edit 0, it's 'permissions_configuration.id_field_name' and in edit 1, it's 'permission_config.id_field_name'. This represents a uniform refactoring pattern where the same string concatenation logic is being replaced with a more structured approach using configuration objects. Both edits target the same type of syntactic construct (assignment statements) and apply the identical before\u2192after transformation pattern as part of what appears to be a single, contiguous refactoring sweep."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'setting_name + \"_id\"' to 'permission_config.id_field_name' in the same type of syntactic construct (assignment statements within similar for loops). The edits are part of a uniform refactoring that replaces string concatenation with accessing a field from the permission_config object. Both changed lines reference the same variables (setting_name, permission_config) and perform the same structural transformation. This is a clear case of bulk-edit pattern synchronization where either edit could be made first as part of the same contiguous refactoring task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'setting_name + \"_id\"' to 'permission_config.id_field_name' in the same type of syntactic construct (assignment statements within similar for loops). The edits are part of a uniform refactoring that replaces string concatenation with accessing a field from the permission_config object. Both changed lines reference the same variables (setting_name, permission_config) and perform the same structural transformation. This is a clear case of bulk-edit pattern synchronization where either edit could be made first as part of the same contiguous refactoring task."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'setting_name + \"_id\"' with a reference to an 'id_field_name' attribute from a configuration object. In edit 0, it's 'permissions_configuration.id_field_name' and in edit 1, it's 'permission_config.id_field_name'. This represents the same structural change - accessing the id_field_name property instead of string concatenation - applied to the same type of syntactic construct (assignment statements) in similar contexts (both dealing with permission settings). This appears to be part of a single refactoring operation to standardize how ID field names are accessed across the codebase."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'setting_name + \"_id\"' with a reference to an 'id_field_name' attribute from a configuration object. In edit 0, it's 'permissions_configuration.id_field_name' and in edit 1, it's 'permission_config.id_field_name'. This represents the same structural change - accessing the id_field_name property instead of string concatenation - applied to the same type of syntactic construct (assignment statements) in similar contexts (both dealing with permission settings). This appears to be part of a single refactoring operation to standardize how ID field names are accessed across the codebase."
        }
    ],
    "allowed_init_edits": [
        2
    ]
}