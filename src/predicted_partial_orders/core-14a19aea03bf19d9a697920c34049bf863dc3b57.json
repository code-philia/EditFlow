{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits add the exact same import symbol 'ATTR_ENTITY_PICTURE' to their respective import statements from 'homeassistant.const'. Edit 0 adds it to the production code file, while Edit 1 adds it to the test file. This represents a synchronized import addition pattern where the same symbol is being imported in both production and test contexts, likely as part of implementing a feature that requires this constant in both places. The edits reference the exact same symbol and represent identical structural substitutions (adding the same import). Either edit can be made first without causing parse errors, making this bi-directional."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits add the exact same import symbol 'ATTR_ENTITY_PICTURE' to their respective import statements from 'homeassistant.const'. Edit 0 adds it to the production code file, while Edit 1 adds it to the test file. This represents a synchronized import addition pattern where the same symbol is being imported in both production and test contexts, likely as part of implementing a feature that requires this constant in both places. The edits reference the exact same symbol and represent identical structural substitutions (adding the same import). Either edit can be made first without causing parse errors, making this bi-directional."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 imports ATTR_ENTITY_PICTURE from homeassistant.const, and Edit 1 uses that exact same symbol ATTR_ENTITY_PICTURE in a test assertion. The changed lines reference the exact same symbol - ATTR_ENTITY_PICTURE. After importing the symbol in Edit 0, Edit 1 becomes the immediate next step to use it in the test. This is a classic import-usage pattern where both edits reference the same symbol and either can be staged first (the usage would cause a runtime NameError if staged before the import, but both can be parsed and staged in either order in Python)."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 imports ATTR_ENTITY_PICTURE from homeassistant.const, and Edit 1 uses that exact same symbol ATTR_ENTITY_PICTURE in a test assertion. The changed lines reference the exact same symbol - ATTR_ENTITY_PICTURE. After importing the symbol in Edit 0, Edit 1 becomes the immediate next step to use it in the test. This is a classic import-usage pattern where both edits reference the same symbol and either can be staged first (the usage would cause a runtime NameError if staged before the import, but both can be parsed and staged in either order in Python)."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 imports ATTR_ENTITY_PICTURE from homeassistant.const in the recorder.py file, while Edit 1 uses ATTR_ENTITY_PICTURE in a test assertion in test_recorder.py. Both edits reference the exact same symbol (ATTR_ENTITY_PICTURE), and the import in Edit 0 makes the symbol available for use in Edit 1's test. This creates a direct code dependency where the import enables the usage, making them bi-directional neighbors in mental flow - either edit could prompt the other as the next mechanical step in a development session."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 imports ATTR_ENTITY_PICTURE from homeassistant.const in the recorder.py file, while Edit 1 uses ATTR_ENTITY_PICTURE in a test assertion in test_recorder.py. Both edits reference the exact same symbol (ATTR_ENTITY_PICTURE), and the import in Edit 0 makes the symbol available for use in Edit 1's test. This creates a direct code dependency where the import enables the usage, making them bi-directional neighbors in mental flow - either edit could prompt the other as the next mechanical step in a development session."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 adds ATTR_ENTITY_PICTURE to a return set in the exclude_attributes function, while Edit 1 adds ATTR_ENTITY_PICTURE to an import statement in a test file. Both edits reference the exact same symbol (ATTR_ENTITY_PICTURE from homeassistant.const). After making either edit, the other becomes the immediate next step - if you add the symbol to the function without importing it in the test, the test will have a NameError when it tries to reference the symbol; if you import it without using it in the function, the import becomes unused. This creates a direct code dependency where both edits reference the same symbol and either naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 adds ATTR_ENTITY_PICTURE to a return set in the exclude_attributes function, while Edit 1 adds ATTR_ENTITY_PICTURE to an import statement in a test file. Both edits reference the exact same symbol (ATTR_ENTITY_PICTURE from homeassistant.const). After making either edit, the other becomes the immediate next step - if you add the symbol to the function without importing it in the test, the test will have a NameError when it tries to reference the symbol; if you import it without using it in the function, the import becomes unused. This creates a direct code dependency where both edits reference the same symbol and either naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 imports ATTR_ENTITY_PICTURE from homeassistant.const, and Edit 1 uses that exact same imported symbol ATTR_ENTITY_PICTURE in the return statement of the exclude_attributes function. This is a classic import-usage relationship where the changed lines reference the exact same symbol. After making the import in Edit 0, using the symbol in Edit 1 becomes the immediate next step, and vice versa - if Edit 1 were made first, the import in Edit 0 would be immediately needed. In Python, both edits can be staged in either order since referencing an undefined symbol only causes a runtime NameError, not a parse error."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 imports ATTR_ENTITY_PICTURE from homeassistant.const, and Edit 1 uses that exact same imported symbol ATTR_ENTITY_PICTURE in the return statement of the exclude_attributes function. This is a classic import-usage relationship where the changed lines reference the exact same symbol. After making the import in Edit 0, using the symbol in Edit 1 becomes the immediate next step, and vice versa - if Edit 1 were made first, the import in Edit 0 would be immediately needed. In Python, both edits can be staged in either order since referencing an undefined symbol only causes a runtime NameError, not a parse error."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 adds ATTR_ENTITY_PICTURE to the set of excluded attributes in the exclude_attributes function. Edit 1 adds a test assertion that checks for ATTR_ENTITY_PICTURE in the state attributes. These edits reference the exact same symbol (ATTR_ENTITY_PICTURE) and appear to be part of the same development session where the attribute is being added to the exclusion list and then tested. The test edit verifies the behavior change made in the production code edit. Either edit could be staged first without causing parse errors, making this a bi-directional relationship where making either edit creates an immediate prompt for the other as part of the same micro-task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 adds ATTR_ENTITY_PICTURE to the set of excluded attributes in the exclude_attributes function. Edit 1 adds a test assertion that checks for ATTR_ENTITY_PICTURE in the state attributes. These edits reference the exact same symbol (ATTR_ENTITY_PICTURE) and appear to be part of the same development session where the attribute is being added to the exclusion list and then tested. The test edit verifies the behavior change made in the production code edit. Either edit could be staged first without causing parse errors, making this a bi-directional relationship where making either edit creates an immediate prompt for the other as part of the same micro-task."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds ATTR_ENTITY_PICTURE to the import statement, and Edit 1 uses that exact same imported symbol ATTR_ENTITY_PICTURE in a test assertion. This creates an immediate code dependency where the import in Edit 0 makes the symbol available for use in Edit 1. Both edits reference the exact same symbol and are part of the same file, making this a classic import-usage relationship within the same development context."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds ATTR_ENTITY_PICTURE to the import statement, and Edit 1 uses that exact same imported symbol ATTR_ENTITY_PICTURE in a test assertion. This creates an immediate code dependency where the import in Edit 0 makes the symbol available for use in Edit 1. Both edits reference the exact same symbol and are part of the same file, making this a classic import-usage relationship within the same development context."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 imports ATTR_ENTITY_PICTURE from homeassistant.const, and Edit 1 uses that exact same imported symbol ATTR_ENTITY_PICTURE in an assertion. This is a classic import-usage relationship where the changed lines reference the exact same symbol. After importing ATTR_ENTITY_PICTURE in Edit 0, Edit 1 becomes the immediate next step to use that imported symbol. In Python, the usage can be written before the import (it would only fail at runtime), so this is bi-directional rather than ordered."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 imports ATTR_ENTITY_PICTURE from homeassistant.const, and Edit 1 uses that exact same imported symbol ATTR_ENTITY_PICTURE in an assertion. This is a classic import-usage relationship where the changed lines reference the exact same symbol. After importing ATTR_ENTITY_PICTURE in Edit 0, Edit 1 becomes the immediate next step to use that imported symbol. In Python, the usage can be written before the import (it would only fail at runtime), so this is bi-directional rather than ordered."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 adds ATTR_ENTITY_PICTURE to the set of excluded attributes in the exclude_attributes function. Edit 1 adds a test assertion to verify that ATTR_ENTITY_PICTURE is not present in state attributes, which directly tests the behavior modified in edit 0. Both edits reference the exact same symbol (ATTR_ENTITY_PICTURE) and are part of a synchronized test-production code change where the test validates the exact functionality being modified in the production code. This creates an immediate, mechanically obvious prompt where after adding the exclusion in production code, the corresponding test assertion becomes the natural next step to verify the change works correctly."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 adds ATTR_ENTITY_PICTURE to the set of excluded attributes in the exclude_attributes function. Edit 1 adds a test assertion to verify that ATTR_ENTITY_PICTURE is not present in state attributes, which directly tests the behavior modified in edit 0. Both edits reference the exact same symbol (ATTR_ENTITY_PICTURE) and are part of a synchronized test-production code change where the test validates the exact functionality being modified in the production code. This creates an immediate, mechanically obvious prompt where after adding the exclusion in production code, the corresponding test assertion becomes the natural next step to verify the change works correctly."
        }
    ],
    "allowed_init_edits": [
        1
    ]
}