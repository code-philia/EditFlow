{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits add the exact same parameter 'vmem_limit_bytes' with identical type annotation 'int | None = None' to function signatures. Edit 0 adds it to the mosaic.as_tpu_kernel() call by extracting it from mosaic_params, while Edit 1 adds it as a parameter to the _lowered_as_tpu_kernel function signature. This represents a definition-usage relationship where the parameter added in Edit 1 is being passed through and used in Edit 0. The changed lines reference the exact same symbol (vmem_limit_bytes parameter) and this appears to be part of a single micro-task of adding vmem_limit_bytes support throughout the call chain. Either edit could be made first and would create an immediate prompt for the other."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits add the exact same parameter 'vmem_limit_bytes' with identical type annotation 'int | None = None' to function signatures. Edit 0 adds it to the mosaic.as_tpu_kernel() call by extracting it from mosaic_params, while Edit 1 adds it as a parameter to the _lowered_as_tpu_kernel function signature. This represents a definition-usage relationship where the parameter added in Edit 1 is being passed through and used in Edit 0. The changed lines reference the exact same symbol (vmem_limit_bytes parameter) and this appears to be part of a single micro-task of adding vmem_limit_bytes support throughout the call chain. Either edit could be made first and would create an immediate prompt for the other."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits add the exact same parameter 'vmem_limit_bytes: int | None' to different parts of the same codebase. Edit 0 adds it to the CustomCallBackendConfig class definition, while Edit 1 adds it to the as_tpu_kernel function signature. These appear to be part of a synchronized parameter addition where the same configuration option is being added to both the backend configuration class and the function that uses it. This represents a mirrored structural addition with identical syntax and semantics, making either edit a natural prompt for the other as part of the same feature implementation."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits add the exact same parameter 'vmem_limit_bytes: int | None' to different parts of the same codebase. Edit 0 adds it to the CustomCallBackendConfig class definition, while Edit 1 adds it to the as_tpu_kernel function signature. These appear to be part of a synchronized parameter addition where the same configuration option is being added to both the backend configuration class and the function that uses it. This represents a mirrored structural addition with identical syntax and semantics, making either edit a natural prompt for the other as part of the same feature implementation."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits add the exact same parameter 'vmem_limit_bytes' with identical extraction pattern from mosaic_params in edit 0 and as a direct parameter in edit 1. Edit 0 calls mosaic.as_tpu_kernel() which is the function being modified in edit 1. The changed lines reference the exact same parameter being threaded through the call chain - edit 0 passes vmem_limit_bytes=mosaic_params.get('vmem_limit_bytes', None) to the function, and edit 1 adds vmem_limit_bytes as a parameter to that same function signature and passes it to the internal _lowered_as_tpu_kernel call. This creates a direct code dependency where both edits are part of the same parameter threading operation for the exact same symbol."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits add the exact same parameter 'vmem_limit_bytes' with identical extraction pattern from mosaic_params in edit 0 and as a direct parameter in edit 1. Edit 0 calls mosaic.as_tpu_kernel() which is the function being modified in edit 1. The changed lines reference the exact same parameter being threaded through the call chain - edit 0 passes vmem_limit_bytes=mosaic_params.get('vmem_limit_bytes', None) to the function, and edit 1 adds vmem_limit_bytes as a parameter to that same function signature and passes it to the internal _lowered_as_tpu_kernel call. This creates a direct code dependency where both edits are part of the same parameter threading operation for the exact same symbol."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 adds a new attribute 'vmem_limit_bytes' to the CustomCallBackendConfig class definition. Edit 1 uses this exact same attribute in the to_json method by referencing 'self.vmem_limit_bytes' multiple times in the changed lines. This creates a direct definition-usage relationship where the attribute defined in edit 0 is immediately referenced in edit 1. Both edits reference the exact same symbol (vmem_limit_bytes attribute of the CustomCallBackendConfig class). After adding the attribute definition, using it in the method becomes the natural next step. Since Python allows referencing undefined attributes at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 adds a new attribute 'vmem_limit_bytes' to the CustomCallBackendConfig class definition. Edit 1 uses this exact same attribute in the to_json method by referencing 'self.vmem_limit_bytes' multiple times in the changed lines. This creates a direct definition-usage relationship where the attribute defined in edit 0 is immediately referenced in edit 1. Both edits reference the exact same symbol (vmem_limit_bytes attribute of the CustomCallBackendConfig class). After adding the attribute definition, using it in the method becomes the natural next step. Since Python allows referencing undefined attributes at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 adds a 'vmem_limit_bytes' parameter to a call to mosaic.as_tpu_kernel(), while Edit 1 adds the same 'vmem_limit_bytes' parameter to the function signature of as_tpu_kernel(). These edits reference the exact same symbol - the vmem_limit_bytes parameter being passed from the caller to the callee. This creates an immediate, mechanically obvious code dependency: adding the parameter to the function call (Edit 0) requires the corresponding parameter to exist in the function signature (Edit 1), and vice versa. Both edits can be staged in either order since Python allows function calls with extra keyword arguments even if the parameter doesn't exist in the signature (this would only cause a runtime TypeError, not a parse error). Therefore, this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 adds a 'vmem_limit_bytes' parameter to a call to mosaic.as_tpu_kernel(), while Edit 1 adds the same 'vmem_limit_bytes' parameter to the function signature of as_tpu_kernel(). These edits reference the exact same symbol - the vmem_limit_bytes parameter being passed from the caller to the callee. This creates an immediate, mechanically obvious code dependency: adding the parameter to the function call (Edit 0) requires the corresponding parameter to exist in the function signature (Edit 1), and vice versa. Both edits can be staged in either order since Python allows function calls with extra keyword arguments even if the parameter doesn't exist in the signature (this would only cause a runtime TypeError, not a parse error). Therefore, this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "Edit 0 adds a new parameter 'vmem_limit_bytes: int | None' to the CustomCallBackendConfig class definition. Edit 1 adds 'vmem_limit_bytes' as an argument in the constructor call to CustomCallBackendConfig within the apply_kernel function. These edits reference the exact same symbol (the vmem_limit_bytes parameter of CustomCallBackendConfig) and form a definition-usage relationship. After adding the parameter to the class definition, the constructor call must be updated to include this parameter, making this a direct code dependency where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "Edit 0 adds a new parameter 'vmem_limit_bytes: int | None' to the CustomCallBackendConfig class definition. Edit 1 adds 'vmem_limit_bytes' as an argument in the constructor call to CustomCallBackendConfig within the apply_kernel function. These edits reference the exact same symbol (the vmem_limit_bytes parameter of CustomCallBackendConfig) and form a definition-usage relationship. After adding the parameter to the class definition, the constructor call must be updated to include this parameter, making this a direct code dependency where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits add the exact same parameter 'vmem_limit_bytes: int | None' to different parts of the same codebase. Edit 0 adds it to the CustomCallBackendConfig class definition, while Edit 1 adds it to the _lowered_as_tpu_kernel function signature. These appear to be part of a synchronized parameter addition where the same parameter is being threaded through related components of the TPU custom call system. The parameter has identical name, type annotation, and positioning relative to the 'flags' parameter in both locations. This represents a mirrored structural addition pattern where both edits perform the same syntactic operation (adding the same parameter) to related constructs in the same system."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits add the exact same parameter 'vmem_limit_bytes: int | None' to different parts of the same codebase. Edit 0 adds it to the CustomCallBackendConfig class definition, while Edit 1 adds it to the _lowered_as_tpu_kernel function signature. These appear to be part of a synchronized parameter addition where the same parameter is being threaded through related components of the TPU custom call system. The parameter has identical name, type annotation, and positioning relative to the 'flags' parameter in both locations. This represents a mirrored structural addition pattern where both edits perform the same syntactic operation (adding the same parameter) to related constructs in the same system."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'vmem_limit_bytes' within the same function. Edit 0 adds the parameter to the function signature, and Edit 1 adds validation logic that references this parameter. After adding the parameter in Edit 0, the next natural step would be to add validation for it (Edit 1). Conversely, if the validation code were written first, it would create an immediate need to add the parameter to the signature. Both edits can be parsed and staged in either order without syntax errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'vmem_limit_bytes' within the same function. Edit 0 adds the parameter to the function signature, and Edit 1 adds validation logic that references this parameter. After adding the parameter in Edit 0, the next natural step would be to add validation for it (Edit 1). Conversely, if the validation code were written first, it would create an immediate need to add the parameter to the signature. Both edits can be parsed and staged in either order without syntax errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Edit 0 adds code that references `self.vmem_limit_bytes` in the `to_json` method of `CustomCallBackendConfig` class. Edit 1 adds `vmem_limit_bytes` as a parameter to the `CustomCallBackendConfig` constructor call. These edits reference the exact same symbol (`vmem_limit_bytes`) - one edit uses it in the class method, and the other provides it as a constructor parameter. This creates a direct code dependency where the parameter must be passed to the constructor for the method to access it via `self.vmem_limit_bytes`. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to complete the functionality."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Edit 0 adds code that references `self.vmem_limit_bytes` in the `to_json` method of `CustomCallBackendConfig` class. Edit 1 adds `vmem_limit_bytes` as a parameter to the `CustomCallBackendConfig` constructor call. These edits reference the exact same symbol (`vmem_limit_bytes`) - one edit uses it in the class method, and the other provides it as a constructor parameter. This creates a direct code dependency where the parameter must be passed to the constructor for the method to access it via `self.vmem_limit_bytes`. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to complete the functionality."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'vmem_limit_bytes'. Edit 0 adds the parameter to the function signature, and Edit 1 passes that parameter to a function call within the same function body. This creates a direct code dependency where the parameter added in the signature is immediately used in the function implementation. Either edit can be made first since Python allows parameters to be defined before they are used, and both edits reference the same symbol in their changed lines."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'vmem_limit_bytes'. Edit 0 adds the parameter to the function signature, and Edit 1 passes that parameter to a function call within the same function body. This creates a direct code dependency where the parameter added in the signature is immediately used in the function implementation. Either edit can be made first since Python allows parameters to be defined before they are used, and both edits reference the same symbol in their changed lines."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits add the exact same parameter 'vmem_limit_bytes: int | None = None' to function signatures in the same file. This appears to be part of a synchronized parameter addition across related functions, where both functions likely need the same parameter for consistent API behavior. The edits perform identical structural modifications (adding the same parameter with the same type annotation and default value) to similar function signatures, making this a clear case of mirrored/synchronized additions within the same context."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits add the exact same parameter 'vmem_limit_bytes: int | None = None' to function signatures in the same file. This appears to be part of a synchronized parameter addition across related functions, where both functions likely need the same parameter for consistent API behavior. The edits perform identical structural modifications (adding the same parameter with the same type annotation and default value) to similar function signatures, making this a clear case of mirrored/synchronized additions within the same context."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 adds a parameter 'vmem_limit_bytes=vmem_limit_bytes' to a function call to '_lowered_as_tpu_kernel', while Edit 1 adds the corresponding parameter 'vmem_limit_bytes: int | None = None' to the function signature of '_lowered_as_tpu_kernel'. These edits reference the exact same symbol (vmem_limit_bytes parameter) and create a direct function signature-caller relationship. After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the parameter to the call site, you need to add it to the function signature, and vice versa. Both edits can be staged in either order without causing parse errors in Python."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 adds a parameter 'vmem_limit_bytes=vmem_limit_bytes' to a function call to '_lowered_as_tpu_kernel', while Edit 1 adds the corresponding parameter 'vmem_limit_bytes: int | None = None' to the function signature of '_lowered_as_tpu_kernel'. These edits reference the exact same symbol (vmem_limit_bytes parameter) and create a direct function signature-caller relationship. After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the parameter to the call site, you need to add it to the function signature, and vice versa. Both edits can be staged in either order without causing parse errors in Python."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits reference the exact same symbol 'vmem_limit_bytes'. Edit 0 adds this parameter to the function signature, and Edit 1 adds the same parameter to the CustomCallBackendConfig call within the function body. After adding the parameter to the signature, the next immediate mechanical step would be to pass it to the CustomCallBackendConfig call, or vice versa. Both edits can be staged in either order without causing parse errors - the function would simply have an unused parameter or be passing an undefined variable (both valid at parse time in Python, only causing runtime errors). This represents a clear definition-usage relationship for the same symbol within the same function."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbol 'vmem_limit_bytes'. Edit 0 adds this parameter to the function signature, and Edit 1 adds the same parameter to the CustomCallBackendConfig call within the function body. After adding the parameter to the signature, the next immediate mechanical step would be to pass it to the CustomCallBackendConfig call, or vice versa. Both edits can be staged in either order without causing parse errors - the function would simply have an unused parameter or be passing an undefined variable (both valid at parse time in Python, only causing runtime errors). This represents a clear definition-usage relationship for the same symbol within the same function."
        }
    ],
    "allowed_init_edits": [
        4
    ]
}