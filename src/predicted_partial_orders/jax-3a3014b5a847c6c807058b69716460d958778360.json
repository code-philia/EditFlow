{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits modify the same function signature and call site for the `roll` operation, changing the `shift` parameter from keyword-only to positional. Edit 0 changes the lowering rule function signature to accept `shift` as a positional parameter, while Edit 1 updates the corresponding call site to pass `shift` as a positional argument. The changed lines reference the exact same symbol (`shift` parameter in the roll operation) and create a direct code dependency - after making either edit, the other becomes the immediate next step to maintain consistency between the function signature and its usage."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits modify the same function signature and call site for the `roll` operation, changing the `shift` parameter from keyword-only to positional. Edit 0 changes the lowering rule function signature to accept `shift` as a positional parameter, while Edit 1 updates the corresponding call site to pass `shift` as a positional argument. The changed lines reference the exact same symbol (`shift` parameter in the roll operation) and create a direct code dependency - after making either edit, the other becomes the immediate next step to maintain consistency between the function signature and its usage."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'ctx' in their changed lines. Edit 0 modifies the function signature to change the parameter order of 'ctx', and Edit 1 adds a line that uses 'ctx.avals_out'. Since both edits reference the same 'ctx' parameter within the same function scope, and making either edit creates an immediate code-driven prompt for the other (the parameter reordering affects how ctx is accessed, and the new usage of ctx requires the parameter to be available), this represents a bi-directional relationship where either edit can be made first and naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'ctx' in their changed lines. Edit 0 modifies the function signature to change the parameter order of 'ctx', and Edit 1 adds a line that uses 'ctx.avals_out'. Since both edits reference the same 'ctx' parameter within the same function scope, and making either edit creates an immediate code-driven prompt for the other (the parameter reordering affects how ctx is accessed, and the new usage of ctx requires the parameter to be available), this represents a bi-directional relationship where either edit can be made first and naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 8,
            "reason": "Both edits are modifying the same function `_roll_lowering_rule` to handle a parameter signature change. Edit 0 moves the `shift` parameter from keyword-only to positional in the function definition, while Edit 1 updates the function call to pass `shift` as a positional argument. The changed lines reference the exact same function and parameter, creating a direct code dependency where after making either edit, the other becomes the immediate next step to maintain consistency between the function signature and its usage."
        },
        {
            "src": 8,
            "tgt": 0,
            "reason": "Both edits are modifying the same function `_roll_lowering_rule` to handle a parameter signature change. Edit 0 moves the `shift` parameter from keyword-only to positional in the function definition, while Edit 1 updates the function call to pass `shift` as a positional argument. The changed lines reference the exact same function and parameter, creating a direct code dependency where after making either edit, the other becomes the immediate next step to maintain consistency between the function signature and its usage."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits make identical structural changes to function signatures with the same name `_roll_lowering_rule`. They both move the `shift` parameter from after the `*` (keyword-only) to before it (positional), changing the parameter ordering in exactly the same way. This represents a bulk uniform substitution pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (function signatures) across multiple files. This would naturally occur as part of a single, contiguous refactoring operation to synchronize the parameter ordering of these related functions."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits make identical structural changes to function signatures with the same name `_roll_lowering_rule`. They both move the `shift` parameter from after the `*` (keyword-only) to before it (positional), changing the parameter ordering in exactly the same way. This represents a bulk uniform substitution pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (function signatures) across multiple files. This would naturally occur as part of a single, contiguous refactoring operation to synchronize the parameter ordering of these related functions."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits modify the same function signature pattern by changing how the 'shift' parameter is handled. Edit 0 removes the type annotation from the 'shift' parameter in the main roll function, while Edit 1 adds 'shift' as an explicit parameter to the abstract evaluation function and immediately deletes it. These edits reference the exact same parameter symbol 'shift' and appear to be part of a coordinated refactoring to change how the shift parameter is processed. The changes are mechanically linked - both involve modifying function signatures to handle the 'shift' parameter differently, and either edit could be made first as both are syntactically valid independently."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits modify the same function signature pattern by changing how the 'shift' parameter is handled. Edit 0 removes the type annotation from the 'shift' parameter in the main roll function, while Edit 1 adds 'shift' as an explicit parameter to the abstract evaluation function and immediately deletes it. These edits reference the exact same parameter symbol 'shift' and appear to be part of a coordinated refactoring to change how the shift parameter is processed. The changes are mechanically linked - both involve modifying function signatures to handle the 'shift' parameter differently, and either edit could be made first as both are syntactically valid independently."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits modify the exact same parameter 'shift' in the same function 'roll'. Edit 0 removes the type annotation ': int' from the parameter declaration, while Edit 1 changes the function call from using keyword argument 'shift=shift' to positional argument 'shift'. These changes are synchronized modifications to the same parameter symbol - one changes how it's declared and the other changes how it's passed. Both edits reference the exact same 'shift' parameter symbol and represent a coordinated refactoring that could be done in either order without causing parse errors."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits modify the exact same parameter 'shift' in the same function 'roll'. Edit 0 removes the type annotation ': int' from the parameter declaration, while Edit 1 changes the function call from using keyword argument 'shift=shift' to positional argument 'shift'. These changes are synchronized modifications to the same parameter symbol - one changes how it's declared and the other changes how it's passed. Both edits reference the exact same 'shift' parameter symbol and represent a coordinated refactoring that could be done in either order without causing parse errors."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits modify the parameter signature for the same 'shift' parameter in related functions. Edit 0 removes the type annotation ': int' from the 'shift' parameter in the roll function, while Edit 1 moves the 'shift' parameter from keyword-only (after *) to positional in the _roll_lowering_rule function. These are synchronized changes to the same parameter's signature across related functions in the same module, making them part of a coordinated refactoring of the shift parameter's interface. The changes reference the exact same parameter symbol and would naturally be done together as part of a single micro-task to maintain consistency."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits modify the parameter signature for the same 'shift' parameter in related functions. Edit 0 removes the type annotation ': int' from the 'shift' parameter in the roll function, while Edit 1 moves the 'shift' parameter from keyword-only (after *) to positional in the _roll_lowering_rule function. These are synchronized changes to the same parameter's signature across related functions in the same module, making them part of a coordinated refactoring of the shift parameter's interface. The changes reference the exact same parameter symbol and would naturally be done together as part of a single micro-task to maintain consistency."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'shift' parameter within the same function. Edit 0 removes the type annotation ': int' from the shift parameter, while Edit 1 adds a runtime type check 'isinstance(shift, int)' before using shift in a comparison. These edits are mechanically linked - removing the static type constraint in the parameter definition creates an immediate need to add runtime type checking where the parameter is used. The changed lines in both edits explicitly reference the same 'shift' symbol, and making either edit would naturally prompt the other as the next contiguous action in a single micro-task of changing how the shift parameter's type is handled."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'shift' parameter within the same function. Edit 0 removes the type annotation ': int' from the shift parameter, while Edit 1 adds a runtime type check 'isinstance(shift, int)' before using shift in a comparison. These edits are mechanically linked - removing the static type constraint in the parameter definition creates an immediate need to add runtime type checking where the parameter is used. The changed lines in both edits explicitly reference the same 'shift' symbol, and making either edit would naturally prompt the other as the next contiguous action in a single micro-task of changing how the shift parameter's type is handled."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Edit 0 removes the type annotation ': int' from the 'shift' parameter in the roll function signature, while Edit 1 adds 'shift' as a parameter to the inner _roll function definition. Both edits involve the exact same 'shift' parameter symbol within the same function context - Edit 0 modifies the outer function's shift parameter, and Edit 1 adds shift as a parameter to the inner helper function that needs access to it. This creates a direct code dependency where both edits reference the same shift parameter and would naturally occur together as part of threading the shift parameter through the function hierarchy."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Edit 0 removes the type annotation ': int' from the 'shift' parameter in the roll function signature, while Edit 1 adds 'shift' as a parameter to the inner _roll function definition. Both edits involve the exact same 'shift' parameter symbol within the same function context - Edit 0 modifies the outer function's shift parameter, and Edit 1 adds shift as a parameter to the inner helper function that needs access to it. This creates a direct code dependency where both edits reference the same shift parameter and would naturally occur together as part of threading the shift parameter through the function hierarchy."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits modify the same function signature and its corresponding abstract evaluation function to change how the 'shift' parameter is handled. Edit 0 changes the roll_p.bind call to pass 'shift' as a positional argument instead of a keyword argument. Edit 1 updates the _roll_abstract_eval function signature to accept 'shift' as a positional parameter and explicitly delete it. These changes are synchronized - when the bind call passes shift positionally, the abstract eval function must be updated to accept it positionally as well. Both edits reference the same 'shift' parameter and form a coordinated change to maintain consistency between the caller and the abstract evaluation function."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits modify the same function signature and its corresponding abstract evaluation function to change how the 'shift' parameter is handled. Edit 0 changes the roll_p.bind call to pass 'shift' as a positional argument instead of a keyword argument. Edit 1 updates the _roll_abstract_eval function signature to accept 'shift' as a positional parameter and explicitly delete it. These changes are synchronized - when the bind call passes shift positionally, the abstract eval function must be updated to accept it positionally as well. Both edits reference the same 'shift' parameter and form a coordinated change to maintain consistency between the caller and the abstract evaluation function."
        },
        {
            "src": 5,
            "tgt": 8,
            "reason": "Both edits modify the same function `_roll` and its usage pattern. Edit 0 adds a `shift` parameter to the abstract evaluation function signature, and Edit 1 updates the call to `_roll` to pass the `shift` parameter. The changed lines reference the exact same symbol (`shift` parameter) and function (`_roll`). After making either edit, the other becomes the immediate next step to maintain consistency between the function signature and its usage. This is a classic definition-usage relationship where both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 8,
            "tgt": 5,
            "reason": "Both edits modify the same function `_roll` and its usage pattern. Edit 0 adds a `shift` parameter to the abstract evaluation function signature, and Edit 1 updates the call to `_roll` to pass the `shift` parameter. The changed lines reference the exact same symbol (`shift` parameter) and function (`_roll`). After making either edit, the other becomes the immediate next step to maintain consistency between the function signature and its usage. This is a classic definition-usage relationship where both edits can be staged in either order without causing parse errors."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits modify function signatures in the same file to change how the 'shift' parameter is handled - edit 0 adds 'shift' as a positional parameter to _roll_abstract_eval, and edit 1 moves 'shift' from a keyword-only parameter to a positional parameter in _roll_lowering_rule. These appear to be part of a coordinated signature change to make the parameter handling consistent across related functions in the same primitive implementation. The changes reference the exact same parameter name 'shift' and appear to be synchronizing the API contract between these two functions that are part of the same roll primitive implementation."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits modify function signatures in the same file to change how the 'shift' parameter is handled - edit 0 adds 'shift' as a positional parameter to _roll_abstract_eval, and edit 1 moves 'shift' from a keyword-only parameter to a positional parameter in _roll_lowering_rule. These appear to be part of a coordinated signature change to make the parameter handling consistent across related functions in the same primitive implementation. The changes reference the exact same parameter name 'shift' and appear to be synchronizing the API contract between these two functions that are part of the same roll primitive implementation."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 changes the outer function signature to move 'shift' from a keyword-only parameter to a positional parameter. Edit 1 adds 'shift' as a parameter to the inner '_roll' function. These edits reference the exact same 'shift' parameter symbol and are part of a coordinated parameter threading operation - the outer function signature change enables 'shift' to be passed as a positional argument, which then needs to be threaded through to the inner function. Making either edit creates an immediate, mechanically obvious prompt for the other as the next step in the same micro-task."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 changes the outer function signature to move 'shift' from a keyword-only parameter to a positional parameter. Edit 1 adds 'shift' as a parameter to the inner '_roll' function. These edits reference the exact same 'shift' parameter symbol and are part of a coordinated parameter threading operation - the outer function signature change enables 'shift' to be passed as a positional argument, which then needs to be threaded through to the inner function. Making either edit creates an immediate, mechanically obvious prompt for the other as the next step in the same micro-task."
        },
        {
            "src": 6,
            "tgt": 8,
            "reason": "Both edits modify the same function `_roll_lowering_rule` and involve adding the `shift` parameter. Edit 0 changes the function signature to move `shift` from a keyword-only parameter to a positional parameter. Edit 1 updates the function call to pass `shift` as a positional argument, which is required after the signature change in Edit 0. The changed lines reference the exact same symbols (`ctx`, `x`, and `shift`) and there is a direct code dependency - the function call must match the signature. Either edit can be made first since both are syntactically valid, but making either edit creates an immediate prompt for the other to maintain consistency between the signature and its usage."
        },
        {
            "src": 8,
            "tgt": 6,
            "reason": "Both edits modify the same function `_roll_lowering_rule` and involve adding the `shift` parameter. Edit 0 changes the function signature to move `shift` from a keyword-only parameter to a positional parameter. Edit 1 updates the function call to pass `shift` as a positional argument, which is required after the signature change in Edit 0. The changed lines reference the exact same symbols (`ctx`, `x`, and `shift`) and there is a direct code dependency - the function call must match the signature. Either edit can be made first since both are syntactically valid, but making either edit creates an immediate prompt for the other to maintain consistency between the signature and its usage."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits modify the parameter signature for the same primitive operation 'roll' by moving the 'shift' parameter from keyword-only to positional. Edit 0 changes the call site in roll_p.bind() to pass 'shift' as a positional argument, while Edit 1 changes the lowering rule function signature to accept 'shift' as a positional parameter. These edits reference the exact same 'shift' parameter in the same roll operation and create a direct code dependency - the call site and function signature must match for the binding to work correctly. Either edit can be made first since both are syntactically valid independently, but making one creates an immediate mechanical prompt for the other to maintain consistency."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits modify the parameter signature for the same primitive operation 'roll' by moving the 'shift' parameter from keyword-only to positional. Edit 0 changes the call site in roll_p.bind() to pass 'shift' as a positional argument, while Edit 1 changes the lowering rule function signature to accept 'shift' as a positional parameter. These edits reference the exact same 'shift' parameter in the same roll operation and create a direct code dependency - the call site and function signature must match for the binding to work correctly. Either edit can be made first since both are syntactically valid independently, but making one creates an immediate mechanical prompt for the other to maintain consistency."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Edit 0 changes the function signature of `_roll` by adding a `shift` parameter, and Edit 1 updates the call site to pass the `shift` argument to the same `_roll` function. Both edits reference the exact same symbol (`_roll` function within the same file and scope). After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the parameter without updating the call site, you get a TypeError at runtime, and if you update the call site without adding the parameter, you get a TypeError. Both edits can be written and parsed in either order since Python allows mismatched function signatures at parse time (only failing at runtime), making this bi-directional rather than ordered."
        },
        {
            "src": 8,
            "tgt": 7,
            "reason": "Edit 0 changes the function signature of `_roll` by adding a `shift` parameter, and Edit 1 updates the call site to pass the `shift` argument to the same `_roll` function. Both edits reference the exact same symbol (`_roll` function within the same file and scope). After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the parameter without updating the call site, you get a TypeError at runtime, and if you update the call site without adding the parameter, you get a TypeError. Both edits can be written and parsed in either order since Python allows mismatched function signatures at parse time (only failing at runtime), making this bi-directional rather than ordered."
        }
    ],
    "allowed_init_edits": [
        1,
        3
    ]
}