{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'foo' to 'foo_b') in the same type of syntactic construct (function call arguments) within similar test methods. This represents a bulk-edit pattern where the same refactoring operation is being applied consistently across multiple test files. The edits are part of a single, contiguous refactor that involves the same before\u2192after pattern on the same construct type."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'foo' to 'foo_b') in the same type of syntactic construct (function call arguments) within similar test methods. This represents a bulk-edit pattern where the same refactoring operation is being applied consistently across multiple test files. The edits are part of a single, contiguous refactor that involves the same before\u2192after pattern on the same construct type."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits are changing the first parameter (chart name) in calls to the same method `self.insert_chart()` within the same test function. Edit 0 changes 'foo' to 'foo_a' and edit 1 changes 'foo' to 'foo_b'. This appears to be part of a coordinated refactoring to ensure unique chart names in the test, likely to avoid naming conflicts. Both edits are making identical types of changes (string parameter modifications) to the same method calls within the same test context, representing a synchronized pattern of substitution. Either edit can be made independently without causing parse errors, and both serve the same purpose of disambiguating chart names."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits are changing the first parameter (chart name) in calls to the same method `self.insert_chart()` within the same test function. Edit 0 changes 'foo' to 'foo_a' and edit 1 changes 'foo' to 'foo_b'. This appears to be part of a coordinated refactoring to ensure unique chart names in the test, likely to avoid naming conflicts. Both edits are making identical types of changes (string parameter modifications) to the same method calls within the same test context, representing a synchronized pattern of substitution. Either edit can be made independently without causing parse errors, and both serve the same purpose of disambiguating chart names."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits are part of the same test method and involve updating chart names from 'foo' to 'foo_b' and 'foo_a'. Edit 0 changes the chart creation call to use 'foo_b' as the chart name, while Edit 1 updates the expected test response to match this change by updating the slice_name from 'foo' to 'foo_b'. These edits reference the same test data and are part of a synchronized update to maintain test consistency - the chart creation and its corresponding assertion must match. This creates a direct code dependency where both edits reference the same logical chart entity being tested."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits are part of the same test method and involve updating chart names from 'foo' to 'foo_b' and 'foo_a'. Edit 0 changes the chart creation call to use 'foo_b' as the chart name, while Edit 1 updates the expected test response to match this change by updating the slice_name from 'foo' to 'foo_b'. These edits reference the same test data and are part of a synchronized update to maintain test consistency - the chart creation and its corresponding assertion must match. This creates a direct code dependency where both edits reference the same logical chart entity being tested."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits are part of the same test method and involve changing chart names from 'foo' to 'foo_a' and 'foo_b'. Edit 0 changes the chart creation call to use 'foo_a' as the name, while Edit 1 updates the expected response to match this change (and also adds 'foo_b'). The changed lines reference the exact same symbol/value being tested - the chart name 'foo' being renamed to 'foo_a'. This creates a direct code dependency where after making either edit, the other becomes immediately necessary to maintain test consistency. The test would fail if only one edit is applied since the expected response wouldn't match the actual chart name created."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits are part of the same test method and involve changing chart names from 'foo' to 'foo_a' and 'foo_b'. Edit 0 changes the chart creation call to use 'foo_a' as the name, while Edit 1 updates the expected response to match this change (and also adds 'foo_b'). The changed lines reference the exact same symbol/value being tested - the chart name 'foo' being renamed to 'foo_a'. This creates a direct code dependency where after making either edit, the other becomes immediately necessary to maintain test consistency. The test would fail if only one edit is applied since the expected response wouldn't match the actual chart name created."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Edit 0 changes the dashboard_title parameter from 'foo' to 'foo_b' when creating dashboard3. Edit 1 updates the expected test response to reflect this change, modifying the dashboard_title from 'foo' to 'foo_b' for the entry with slug 'slug1zy_'. The changed lines reference the exact same string value 'foo_b' - one edit creates it as a parameter, the other references it in the expected response. This creates an immediate code-driven dependency where after changing the dashboard creation, the test expectation must be updated to match, making them bi-directional neighbours in the same micro-task."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Edit 0 changes the dashboard_title parameter from 'foo' to 'foo_b' when creating dashboard3. Edit 1 updates the expected test response to reflect this change, modifying the dashboard_title from 'foo' to 'foo_b' for the entry with slug 'slug1zy_'. The changed lines reference the exact same string value 'foo_b' - one edit creates it as a parameter, the other references it in the expected response. This creates an immediate code-driven dependency where after changing the dashboard creation, the test expectation must be updated to match, making them bi-directional neighbours in the same micro-task."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Both edits are part of the same test method and involve changing the dashboard title from 'foo' to 'foo_a'. Edit 0 changes the dashboard creation call to use 'foo_a' as the title, and Edit 1 updates the expected response to match this change by updating the dashboard_title field from 'foo' to 'foo_a'. These edits reference the same logical entity (the dashboard with slug 'ZY_bar') and form a direct test setup-assertion pair where the expected response must match the actual dashboard creation. Either edit can be made first since both are syntactically valid, but making either edit creates an immediate prompt to update the other to maintain test consistency."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Both edits are part of the same test method and involve changing the dashboard title from 'foo' to 'foo_a'. Edit 0 changes the dashboard creation call to use 'foo_a' as the title, and Edit 1 updates the expected response to match this change by updating the dashboard_title field from 'foo' to 'foo_a'. These edits reference the same logical entity (the dashboard with slug 'ZY_bar') and form a direct test setup-assertion pair where the expected response must match the actual dashboard creation. Either edit can be made first since both are syntactically valid, but making either edit creates an immediate prompt to update the other to maintain test consistency."
        }
    ],
    "allowed_init_edits": [
        2,
        6
    ]
}