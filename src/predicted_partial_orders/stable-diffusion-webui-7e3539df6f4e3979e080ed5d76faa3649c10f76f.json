{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 removes the definition of the function `list_builtin_upscalers()` from the modelloader module, while Edit 1 removes the call to `modelloader.list_builtin_upscalers()` from webui.py. Both edits reference the exact same symbol - the `list_builtin_upscalers` function. After removing either the definition or the usage, the other edit becomes the immediate next step to maintain code consistency and avoid undefined symbol references. This is a classic definition-usage relationship where both edits can be staged in either order (the call can be removed before the definition, or vice versa) without causing parse errors."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 removes the definition of the function `list_builtin_upscalers()` from the modelloader module, while Edit 1 removes the call to `modelloader.list_builtin_upscalers()` from webui.py. Both edits reference the exact same symbol - the `list_builtin_upscalers` function. After removing either the definition or the usage, the other edit becomes the immediate next step to maintain code consistency and avoid undefined symbol references. This is a classic definition-usage relationship where both edits can be staged in either order (the call can be removed before the definition, or vice versa) without causing parse errors."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 removes the definition of the function `forbid_loaded_nonbuiltin_upscalers()` from the `modelloader` module, while Edit 1 removes a call to that exact same function (`modelloader.forbid_loaded_nonbuiltin_upscalers()`). Both edits reference the exact same symbol - the function `forbid_loaded_nonbuiltin_upscalers` in the `modelloader` module. Since Edit 0 removes the function definition and Edit 1 removes the call to that function, this appears to be a coordinated removal of both the definition and its usage. Either edit can be applied first without causing parse errors (the call will just reference a non-existent function at runtime), making this a bi-directional relationship where both edits are part of the same cleanup operation."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 removes the definition of the function `forbid_loaded_nonbuiltin_upscalers()` from the `modelloader` module, while Edit 1 removes a call to that exact same function (`modelloader.forbid_loaded_nonbuiltin_upscalers()`). Both edits reference the exact same symbol - the function `forbid_loaded_nonbuiltin_upscalers` in the `modelloader` module. Since Edit 0 removes the function definition and Edit 1 removes the call to that function, this appears to be a coordinated removal of both the definition and its usage. Either edit can be applied first without causing parse errors (the call will just reference a non-existent function at runtime), making this a bi-directional relationship where both edits are part of the same cleanup operation."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 removes the definition of `forbidden_upscaler_classes` (line 120) along with related functions, while Edit 1 removes code that references this same variable (line 149). The changed lines reference the exact same symbol `forbidden_upscaler_classes`. After Edit 0 removes the definition, Edit 1's reference would cause a NameError at runtime, but since Python allows referencing undefined variables at parse time, both edits can be staged in either order. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step to maintain code consistency."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 removes the definition of `forbidden_upscaler_classes` (line 120) along with related functions, while Edit 1 removes code that references this same variable (line 149). The changed lines reference the exact same symbol `forbidden_upscaler_classes`. After Edit 0 removes the definition, Edit 1's reference would cause a NameError at runtime, but since Python allows referencing undefined variables at parse time, both edits can be staged in either order. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step to maintain code consistency."
        }
    ],
    "allowed_init_edits": [
        2,
        4
    ]
}