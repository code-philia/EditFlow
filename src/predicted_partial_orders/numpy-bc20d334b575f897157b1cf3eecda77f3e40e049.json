{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution: changing '_dtypes' to '_dtype_categories'. This appears to be part of a single refactoring operation where a variable or dictionary name is being renamed consistently across the codebase. Both changed lines reference the exact same symbol (the renamed dictionary/variable) and perform the same before\u2192after pattern substitution. This is a classic bulk-edit pattern where either edit could be made first, and after making one, the other becomes an immediate next step to maintain consistency in the refactor."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution: changing '_dtypes' to '_dtype_categories'. This appears to be part of a single refactoring operation where a variable or dictionary name is being renamed consistently across the codebase. Both changed lines reference the exact same symbol (the renamed dictionary/variable) and perform the same before\u2192after pattern substitution. This is a classic bulk-edit pattern where either edit could be made first, and after making one, the other becomes an immediate next step to maintain consistency in the refactor."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits are part of the same refactoring operation that replaces the local `_dtypes` dictionary with an imported `_dtype_categories`. Edit 0 removes the local dictionary definition and imports `_dtype_categories`, while Edit 1 updates a usage of the old `_dtypes` variable to use the new `_dtype_categories`. Both changed lines reference the exact same symbol (`_dtype_categories`) and this represents a uniform substitution pattern where the local dictionary is being replaced with an imported one. Either edit could be made first since both are syntactically valid, but after making either edit, the other becomes the immediate next step to complete the refactoring."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits are part of the same refactoring operation that replaces the local `_dtypes` dictionary with an imported `_dtype_categories`. Edit 0 removes the local dictionary definition and imports `_dtype_categories`, while Edit 1 updates a usage of the old `_dtypes` variable to use the new `_dtype_categories`. Both changed lines reference the exact same symbol (`_dtype_categories`) and this represents a uniform substitution pattern where the local dictionary is being replaced with an imported one. Either edit could be made first since both are syntactically valid, but after making either edit, the other becomes the immediate next step to complete the refactoring."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution: changing '_dtypes[' to '_dtype_categories[' in the context of accessing dtype category mappings. Edit 0 changes the import and usage in the Array class method, while Edit 1 changes the usage in a test function. Both edits reference the exact same symbol '_dtype_categories' and perform the same before\u2192after pattern substitution on the same type of syntactic construct (dictionary access). This appears to be part of a single refactoring operation to rename the dtype categories dictionary across the codebase."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution: changing '_dtypes[' to '_dtype_categories[' in the context of accessing dtype category mappings. Edit 0 changes the import and usage in the Array class method, while Edit 1 changes the usage in a test function. Both edits reference the exact same symbol '_dtype_categories' and perform the same before\u2192after pattern substitution on the same type of syntactic construct (dictionary access). This appears to be part of a single refactoring operation to rename the dtype categories dictionary across the codebase."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 1 defines a new symbol `_dtype_categories` in the `_dtypes.py` file, and Edit 0 uses this exact same symbol by importing and referencing it in `_array_object.py`. The changed line in Edit 0 explicitly references `_dtype_categories[dtype_category]` which is the same symbol being defined in Edit 1. This creates a direct definition-usage relationship where both edits reference the exact same symbol. Since this appears to be Python code, the usage can be written before the definition (it would only fail at runtime/import time, not at parse time), making this a bi-directional relationship where either edit can be made first and naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 1 defines a new symbol `_dtype_categories` in the `_dtypes.py` file, and Edit 0 uses this exact same symbol by importing and referencing it in `_array_object.py`. The changed line in Edit 0 explicitly references `_dtype_categories[dtype_category]` which is the same symbol being defined in Edit 1. This creates a direct definition-usage relationship where both edits reference the exact same symbol. Since this appears to be Python code, the usage can be written before the definition (it would only fail at runtime/import time, not at parse time), making this a bi-directional relationship where either edit can be made first and naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits are part of the same refactoring operation that replaces individual dtype category imports with a single `_dtype_categories` dictionary import. Edit 0 changes the implementation to use `_dtype_categories[dtype_category]` instead of a local `_dtypes` dictionary, while Edit 1 updates the import statement to import `_dtype_categories` instead of `_all_dtypes` and `_numeric_dtypes`. Both edits reference the exact same symbol `_dtype_categories` and are part of a uniform substitution pattern - replacing multiple individual dtype category variables with a single dictionary lookup. This is a synchronized refactoring where both changes work together to implement the same structural improvement."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits are part of the same refactoring operation that replaces individual dtype category imports with a single `_dtype_categories` dictionary import. Edit 0 changes the implementation to use `_dtype_categories[dtype_category]` instead of a local `_dtypes` dictionary, while Edit 1 updates the import statement to import `_dtype_categories` instead of `_all_dtypes` and `_numeric_dtypes`. Both edits reference the exact same symbol `_dtype_categories` and are part of a uniform substitution pattern - replacing multiple individual dtype category variables with a single dictionary lookup. This is a synchronized refactoring where both changes work together to implement the same structural improvement."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 defines a new symbol `_dtype_categories` in the `_dtypes.py` module, while Edit 1 imports and uses that exact same symbol `_dtype_categories` in the test file. The changed lines reference the exact same symbol - Edit 0 creates the definition and Edit 1 imports it. This creates an immediate code dependency where after defining `_dtype_categories`, importing it becomes the next logical step. Since Python allows imports of undefined symbols at parse time (they only fail at runtime), either edit can be staged first, making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 defines a new symbol `_dtype_categories` in the `_dtypes.py` module, while Edit 1 imports and uses that exact same symbol `_dtype_categories` in the test file. The changed lines reference the exact same symbol - Edit 0 creates the definition and Edit 1 imports it. This creates an immediate code dependency where after defining `_dtype_categories`, importing it becomes the next logical step. Since Python allows imports of undefined symbols at parse time (they only fail at runtime), either edit can be staged first, making this a bi-directional relationship."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 1 defines a new symbol `_dtype_categories` in the `_dtypes.py` module, while Edit 0 imports and uses that exact same symbol in `_array_object.py`. The changed lines in Edit 0 explicitly reference `_dtype_categories` both in the import statement and in its usage, creating a direct definition-usage relationship. In Python, both edits can be written and parsed in either order (the usage before definition would only cause a runtime NameError, not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 1 defines a new symbol `_dtype_categories` in the `_dtypes.py` module, while Edit 0 imports and uses that exact same symbol in `_array_object.py`. The changed lines in Edit 0 explicitly reference `_dtype_categories` both in the import statement and in its usage, creating a direct definition-usage relationship. In Python, both edits can be written and parsed in either order (the usage before definition would only cause a runtime NameError, not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 removes the definition of the `_dtypes` dictionary variable, while Edit 1 changes a reference from `_dtypes[types]` to `_dtype_categories[types]`. These edits reference the exact same symbol `_dtypes` - Edit 0 removes its definition and Edit 1 changes its usage to a different variable. This creates a direct code dependency where removing the definition (Edit 0) makes the usage reference (Edit 1) necessary to avoid a NameError. However, since both edits can be parsed and staged in either order (the NameError only occurs at runtime), this is bi-directional rather than ordered."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 removes the definition of the `_dtypes` dictionary variable, while Edit 1 changes a reference from `_dtypes[types]` to `_dtype_categories[types]`. These edits reference the exact same symbol `_dtypes` - Edit 0 removes its definition and Edit 1 changes its usage to a different variable. This creates a direct code dependency where removing the definition (Edit 0) makes the usage reference (Edit 1) necessary to avoid a NameError. However, since both edits can be parsed and staged in either order (the NameError only occurs at runtime), this is bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits involve removing references to the exact same symbols from the _dtypes module. Edit 0 removes the imports of _all_dtypes, _integer_or_boolean_dtypes, and _numeric_dtypes from the import statement, while Edit 1 removes the usage of these same symbols in the _dtypes dictionary definition. The changed lines in both edits reference the exact same symbols (_all_dtypes, _numeric_dtypes, _integer_or_boolean_dtypes). This creates a direct code dependency where removing the imports makes the usage invalid, and removing the usage makes the imports unnecessary. Either edit can be made first since Python allows unused imports and undefined variable references at parse time (they only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next cleanup step."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits involve removing references to the exact same symbols from the _dtypes module. Edit 0 removes the imports of _all_dtypes, _integer_or_boolean_dtypes, and _numeric_dtypes from the import statement, while Edit 1 removes the usage of these same symbols in the _dtypes dictionary definition. The changed lines in both edits reference the exact same symbols (_all_dtypes, _numeric_dtypes, _integer_or_boolean_dtypes). This creates a direct code dependency where removing the imports makes the usage invalid, and removing the usage makes the imports unnecessary. Either edit can be made first since Python allows unused imports and undefined variable references at parse time (they only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next cleanup step."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 defines a new dictionary `_dtype_categories` in the `_dtypes.py` module, while Edit 1 changes a reference from `_dtypes[types]` to `_dtype_categories[types]` in a test file. The changed line in Edit 1 directly references the exact same symbol `_dtype_categories` that is being defined in Edit 0. This creates an immediate code dependency where defining the new dictionary enables its usage in the test. However, since this appears to be a refactoring where `_dtypes` is being replaced by `_dtype_categories`, and both edits can be parsed and staged independently (the test would just have a runtime NameError if staged before the definition), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 defines a new dictionary `_dtype_categories` in the `_dtypes.py` module, while Edit 1 changes a reference from `_dtypes[types]` to `_dtype_categories[types]` in a test file. The changed line in Edit 1 directly references the exact same symbol `_dtype_categories` that is being defined in Edit 0. This creates an immediate code dependency where defining the new dictionary enables its usage in the test. However, since this appears to be a refactoring where `_dtypes` is being replaced by `_dtype_categories`, and both edits can be parsed and staged independently (the test would just have a runtime NameError if staged before the definition), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol '_dtype_categories'. Edit 0 imports '_dtype_categories' from the _dtypes module, replacing the previous import of '_all_dtypes' and other dtype-related imports. Edit 1 uses '_dtype_categories' in place of '_dtypes' to access dtype categories. The import in edit 0 makes the symbol available for use in edit 1. However, in Python, both edits can be written and parsed in either order - using an undefined symbol only causes a runtime NameError, not a parse error. Therefore, either edit can be staged first, and after making either edit, the other becomes the immediate next step due to the direct code dependency on the same symbol."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol '_dtype_categories'. Edit 0 imports '_dtype_categories' from the _dtypes module, replacing the previous import of '_all_dtypes' and other dtype-related imports. Edit 1 uses '_dtype_categories' in place of '_dtypes' to access dtype categories. The import in edit 0 makes the symbol available for use in edit 1. However, in Python, both edits can be written and parsed in either order - using an undefined symbol only causes a runtime NameError, not a parse error. Therefore, either edit can be staged first, and after making either edit, the other becomes the immediate next step due to the direct code dependency on the same symbol."
        }
    ],
    "allowed_init_edits": [
        4
    ]
}