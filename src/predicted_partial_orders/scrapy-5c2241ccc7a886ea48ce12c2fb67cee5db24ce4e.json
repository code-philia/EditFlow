{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits are part of the same test refactoring to change string handling from str to bytes. Edit 0 converts test data to bytes using to_bytes(), while Edit 1 updates the corresponding test assertions to expect bytes instead of str. The changed lines in both edits work together to maintain test consistency - the test data conversion in Edit 0 directly supports the assertion changes in Edit 1. This represents a synchronized test update where both changes reference the same underlying data transformation pattern and are part of a single, contiguous refactoring task."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits are part of the same test refactoring to change string handling from str to bytes. Edit 0 converts test data to bytes using to_bytes(), while Edit 1 updates the corresponding test assertions to expect bytes instead of str. The changed lines in both edits work together to maintain test consistency - the test data conversion in Edit 0 directly supports the assertion changes in Edit 1. This represents a synchronized test update where both changes reference the same underlying data transformation pattern and are part of a single, contiguous refactoring task."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing string literals to byte literals by adding 'b' prefix to HTTP method names ('HEAD' \u2192 b'HEAD' and 'POST' \u2192 b'POST'). This is a uniform refactoring operation targeting the same type of syntactic construct (string literals for HTTP methods) with the exact same before\u2192after transformation pattern. Both edits are part of a single, contiguous refactor to convert HTTP method string comparisons to byte comparisons, likely for Python 3 compatibility. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: changing string literals to byte literals by adding 'b' prefix to HTTP method names ('HEAD' \u2192 b'HEAD' and 'POST' \u2192 b'POST'). This is a uniform refactoring operation targeting the same type of syntactic construct (string literals for HTTP methods) with the exact same before\u2192after transformation pattern. Both edits are part of a single, contiguous refactor to convert HTTP method string comparisons to byte comparisons, likely for Python 3 compatibility. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbols 'host' and 'port' within the same function testFactoryInfo. Edit 0 changes how these variables are assigned from the client._parse() call, and Edit 1 uses these same variables in the reactor.connectTCP() call. The variables 'host' and 'port' are the exact same symbols being referenced in both changed lines - they are assigned in edit 0 and used in edit 1. This creates a direct code dependency where both edits can be made in either order (the assignment and usage are both valid regardless of staging order), making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbols 'host' and 'port' within the same function testFactoryInfo. Edit 0 changes how these variables are assigned from the client._parse() call, and Edit 1 uses these same variables in the reactor.connectTCP() call. The variables 'host' and 'port' are the exact same symbols being referenced in both changed lines - they are assigned in edit 0 and used in edit 1. This creates a direct code dependency where both edits can be made in either order (the assignment and usage are both valid regardless of staging order), making this a bi-directional relationship."
        }
    ],
    "allowed_init_edits": [
        2,
        3,
        0,
        1,
        4,
        5
    ]
}