{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'if device.type == 'mps':' to 'if self.use_mps_noise or device.type == 'mps':' in the same type of syntactic construct (conditional statements within get_noise methods). This represents a bulk uniform substitution across related classes that inherit from the same Generator base class, applying the same logical change to the same conditional pattern. Both edits reference the same attribute 'self.use_mps_noise' and modify identical conditional logic, making this a synchronized refactor that would naturally occur as part of a single contiguous micro-task."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'if device.type == 'mps':' to 'if self.use_mps_noise or device.type == 'mps':' in the same type of syntactic construct (conditional statements within get_noise methods). This represents a bulk uniform substitution across related classes that inherit from the same Generator base class, applying the same logical change to the same conditional pattern. Both edits reference the same attribute 'self.use_mps_noise' and modify identical conditional logic, making this a synchronized refactor that would naturally occur as part of a single contiguous micro-task."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 adds the attribute 'use_mps_noise' to the Generator class constructor, initializing it to False. Edit 1 assigns a value to this same attribute on a generator instance. The changed lines reference the exact same symbol (use_mps_noise attribute), creating a direct code dependency where the attribute must be defined before it can be assigned. However, in Python, attribute assignment can occur even if the attribute wasn't explicitly initialized in __init__, so both edits can be staged in either order without causing parse errors. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step in implementing the use_mps_noise feature."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 adds the attribute 'use_mps_noise' to the Generator class constructor, initializing it to False. Edit 1 assigns a value to this same attribute on a generator instance. The changed lines reference the exact same symbol (use_mps_noise attribute), creating a direct code dependency where the attribute must be defined before it can be assigned. However, in Python, attribute assignment can occur even if the attribute wasn't explicitly initialized in __init__, so both edits can be staged in either order without causing parse errors. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step in implementing the use_mps_noise feature."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 adds a new attribute 'use_mps_noise' to the Generator base class constructor, while Edit 1 references this exact same attribute in a conditional statement within a subclass method. The changed lines reference the exact same symbol (self.use_mps_noise), creating a definition-usage relationship. After adding the attribute in the base class, using it in the subclass becomes the natural next step. Both edits can be staged in either order since Python allows referencing undefined attributes at parse time (would only cause AttributeError at runtime)."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 adds a new attribute 'use_mps_noise' to the Generator base class constructor, while Edit 1 references this exact same attribute in a conditional statement within a subclass method. The changed lines reference the exact same symbol (self.use_mps_noise), creating a definition-usage relationship. After adding the attribute in the base class, using it in the subclass becomes the natural next step. Both edits can be staged in either order since Python allows referencing undefined attributes at parse time (would only cause AttributeError at runtime)."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds a command-line argument '--use_mps_noise' with dest='use_mps_noise' to the argument parser. Edit 1 uses this exact same symbol 'use_mps_noise' in a conditional expression (self.use_mps_noise). The changed lines reference the exact same symbol - the argument parser destination becomes an attribute that is directly referenced in the conditional logic. This creates an immediate code dependency where adding the argument naturally prompts updating the logic to use it, making them part of a single micro-task of implementing the MPS noise feature."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds a command-line argument '--use_mps_noise' with dest='use_mps_noise' to the argument parser. Edit 1 uses this exact same symbol 'use_mps_noise' in a conditional expression (self.use_mps_noise). The changed lines reference the exact same symbol - the argument parser destination becomes an attribute that is directly referenced in the conditional logic. This creates an immediate code dependency where adding the argument naturally prompts updating the logic to use it, making them part of a single micro-task of implementing the MPS noise feature."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "These edits reference the exact same symbol 'use_mps_noise'. Edit 1 adds 'use_mps_noise' as a parameter to the prompt2image method, and Edit 0 uses 'self.use_mps_noise' in a conditional expression. The parameter added in Edit 1 would need to be passed through to make the reference in Edit 0 work properly. However, both edits can be staged independently - Edit 0 would result in an AttributeError at runtime if use_mps_noise isn't defined, but it's syntactically valid Python code. Edit 1 adds the parameter which would eventually be used by Edit 0. Either edit can be made first without causing parse errors, making this a bi-directional relationship where both edits reference the same symbol and either naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "These edits reference the exact same symbol 'use_mps_noise'. Edit 1 adds 'use_mps_noise' as a parameter to the prompt2image method, and Edit 0 uses 'self.use_mps_noise' in a conditional expression. The parameter added in Edit 1 would need to be passed through to make the reference in Edit 0 work properly. However, both edits can be staged independently - Edit 0 would result in an AttributeError at runtime if use_mps_noise isn't defined, but it's syntactically valid Python code. Edit 1 adds the parameter which would eventually be used by Edit 0. Either edit can be made first without causing parse errors, making this a bi-directional relationship where both edits reference the same symbol and either naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 adds a new attribute 'use_mps_noise' to the Generator class constructor, while Edit 1 references this exact same attribute in a conditional statement within a subclass method. The changed lines reference the exact same symbol (self.use_mps_noise), creating a definition-usage relationship. After adding the attribute in Edit 0, using it in Edit 1 becomes a natural next step. Since Python allows referencing undefined attributes at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 adds a new attribute 'use_mps_noise' to the Generator class constructor, while Edit 1 references this exact same attribute in a conditional statement within a subclass method. The changed lines reference the exact same symbol (self.use_mps_noise), creating a definition-usage relationship. After adding the attribute in Edit 0, using it in Edit 1 becomes a natural next step. Since Python allows referencing undefined attributes at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 adds the parameter 'use_mps_noise' to the function signature, and Edit 1 uses that exact same parameter by assigning it to 'generator.use_mps_noise'. This creates a direct definition-usage relationship where the parameter defined in the signature is immediately referenced in the function body. Both edits reference the exact same symbol 'use_mps_noise', and after adding the parameter to the signature, using it in the function body becomes the natural next step in the same micro-task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 adds the parameter 'use_mps_noise' to the function signature, and Edit 1 uses that exact same parameter by assigning it to 'generator.use_mps_noise'. This creates a direct definition-usage relationship where the parameter defined in the signature is immediately referenced in the function body. Both edits reference the exact same symbol 'use_mps_noise', and after adding the parameter to the signature, using it in the function body becomes the natural next step in the same micro-task."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 modifies the condition in get_noise() method to check for 'self.use_mps_noise' attribute, while Edit 1 sets the 'use_mps_noise' attribute on the generator object. The changed lines reference the exact same symbol 'use_mps_noise' - Edit 0 reads it as 'self.use_mps_noise' and Edit 1 assigns it as 'generator.use_mps_noise'. Edit 1 must come before Edit 0 because Edit 0 references an attribute that would be undefined until Edit 1 sets it. Without Edit 1, the attribute access in Edit 0 would cause an AttributeError at runtime."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 adds a check for `self.use_mps_noise` in the condition, while Edit 1 sets `generator.use_mps_noise = use_mps_noise`. These edits reference the exact same attribute `use_mps_noise` on the generator object. Edit 1 sets this attribute, and Edit 0 uses it in a conditional check. However, both edits can be staged in either order - Edit 0 would simply check an undefined attribute (which would be falsy in Python), and Edit 1 would set an attribute that may or may not be used yet. There's no parser-level dependency, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 adds a check for `self.use_mps_noise` in the condition, while Edit 1 sets `generator.use_mps_noise = use_mps_noise`. These edits reference the exact same attribute `use_mps_noise` on the generator object. Edit 1 sets this attribute, and Edit 0 uses it in a conditional check. However, both edits can be staged in either order - Edit 0 would simply check an undefined attribute (which would be falsy in Python), and Edit 1 would set an attribute that may or may not be used yet. There's no parser-level dependency, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}