{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'settings.ENABLE_FEEDBACK' in their changed lines. Edit 0 adds a check for 'settings.ENABLE_FEEDBACK' in the start() method's conditional, while Edit 1 adds an early return guard using the same symbol in the consume() method. These are part of a coordinated feature implementation where the same configuration flag is being consistently applied across related methods in the same class. Both edits can be made in either order without causing parse errors, and either edit naturally prompts consideration of the other as they both involve the same configuration symbol being used for similar gating logic."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'settings.ENABLE_FEEDBACK' in their changed lines. Edit 0 adds a check for 'settings.ENABLE_FEEDBACK' in the start() method's conditional, while Edit 1 adds an early return guard using the same symbol in the consume() method. These are part of a coordinated feature implementation where the same configuration flag is being consistently applied across related methods in the same class. Both edits can be made in either order without causing parse errors, and either edit naturally prompts consideration of the other as they both involve the same configuration symbol being used for similar gating logic."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "These two edits are modifying the same function (FeedbackBot.consume) and are restructuring the control flow logic together. Edit 0 adds an early return condition for when ENABLE_FEEDBACK is false, while Edit 1 converts the remaining logic from a sequential if-else structure to a proper if-else block. The changes are complementary and form a single logical refactoring of the same method's control flow - they reference the same function scope and work together to implement the same behavioral change. Either edit could be made first and would naturally prompt the other as the next step to complete the refactoring."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "These two edits are modifying the same function (FeedbackBot.consume) and are restructuring the control flow logic together. Edit 0 adds an early return condition for when ENABLE_FEEDBACK is false, while Edit 1 converts the remaining logic from a sequential if-else structure to a proper if-else block. The changes are complementary and form a single logical refactoring of the same method's control flow - they reference the same function scope and work together to implement the same behavioral change. Either edit could be made first and would naturally prompt the other as the next step to complete the refactoring."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits remove references to the same symbol 'DEPLOYMENT_ROLE_KEY' - edit 0 removes the variable definition and comment from local_settings_template.py, while edit 1 removes the tuple entry containing 'DEPLOYMENT_ROLE_KEY' from settings.py. These are part of a coordinated removal of the DEPLOYMENT_ROLE_KEY configuration across the codebase. Both edits reference the exact same symbol and appear to be part of a single refactoring task to eliminate this configuration option. Either edit could be performed first without causing parse errors, making this a bi-directional relationship where completing one edit naturally prompts the other as the next step in the same micro-task."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits remove references to the same symbol 'DEPLOYMENT_ROLE_KEY' - edit 0 removes the variable definition and comment from local_settings_template.py, while edit 1 removes the tuple entry containing 'DEPLOYMENT_ROLE_KEY' from settings.py. These are part of a coordinated removal of the DEPLOYMENT_ROLE_KEY configuration across the codebase. Both edits reference the exact same symbol and appear to be part of a single refactoring task to eliminate this configuration option. Either edit could be performed first without causing parse errors, making this a bi-directional relationship where completing one edit naturally prompts the other as the next step in the same micro-task."
        }
    ],
    "allowed_init_edits": [
        0,
        5
    ]
}