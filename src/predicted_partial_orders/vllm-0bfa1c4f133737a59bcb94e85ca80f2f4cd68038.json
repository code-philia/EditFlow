{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 adds a test function `test_parse_fine_tuned_lora_name_invalid()` that tests the `parse_fine_tuned_lora_name` function with invalid inputs, expecting it to raise ValueError with the message 'unsupported LoRA weight'. Edit 1 modifies the implementation of the `parse_fine_tuned_lora_name` function by adding new conditional logic. Both edits reference the exact same symbol `parse_fine_tuned_lora_name` - the test calls this function and the implementation modifies this function. This creates a direct test-production code synchronization where the test is designed to verify the behavior of the exact same function being modified. Either edit can be made first and would prompt the other as the next logical step in the development flow."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 adds a test function `test_parse_fine_tuned_lora_name_invalid()` that tests the `parse_fine_tuned_lora_name` function with invalid inputs, expecting it to raise ValueError with the message 'unsupported LoRA weight'. Edit 1 modifies the implementation of the `parse_fine_tuned_lora_name` function by adding new conditional logic. Both edits reference the exact same symbol `parse_fine_tuned_lora_name` - the test calls this function and the implementation modifies this function. This creates a direct test-production code synchronization where the test is designed to verify the behavior of the exact same function being modified. Either edit can be made first and would prompt the other as the next logical step in the development flow."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds an import statement for pytest, and Edit 1 adds a test function that uses pytest.raises() in its implementation. The changed lines show a direct import-usage relationship where the exact same symbol 'pytest' is imported in Edit 0 and used in Edit 1. This creates an immediate code-driven prompt - after importing pytest, using it in test functions becomes the natural next step. In Python, both edits can be staged in either order since the usage of pytest in a function body doesn't cause a parse error even if pytest isn't imported yet (it would only fail at runtime/import time)."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds an import statement for pytest, and Edit 1 adds a test function that uses pytest.raises() in its implementation. The changed lines show a direct import-usage relationship where the exact same symbol 'pytest' is imported in Edit 0 and used in Edit 1. This creates an immediate code-driven prompt - after importing pytest, using it in test functions becomes the natural next step. In Python, both edits can be staged in either order since the usage of pytest in a function body doesn't cause a parse error even if pytest isn't imported yet (it would only fail at runtime/import time)."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 adds a test function `test_parse_fine_tuned_lora_name_invalid()` that calls `parse_fine_tuned_lora_name(name)` with invalid inputs and expects it to raise ValueError. Edit 1 removes assertion statements from the `parse_fine_tuned_lora_name` function implementation. The test in edit 0 directly calls the exact same function that is being modified in edit 1. However, the test expects ValueError exceptions while edit 1 removes assertions that would cause AssertionError. This suggests the edits are part of changing the error handling behavior of the function - the implementation is being modified to raise ValueError instead of AssertionError, and the test is being added to verify this new behavior. Both edits reference the exact same symbol `parse_fine_tuned_lora_name` and appear to be part of a single development task to change error handling."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 adds a test function `test_parse_fine_tuned_lora_name_invalid()` that calls `parse_fine_tuned_lora_name(name)` with invalid inputs and expects it to raise ValueError. Edit 1 removes assertion statements from the `parse_fine_tuned_lora_name` function implementation. The test in edit 0 directly calls the exact same function that is being modified in edit 1. However, the test expects ValueError exceptions while edit 1 removes assertions that would cause AssertionError. This suggests the edits are part of changing the error handling behavior of the function - the implementation is being modified to raise ValueError instead of AssertionError, and the test is being added to verify this new behavior. Both edits reference the exact same symbol `parse_fine_tuned_lora_name` and appear to be part of a single development task to change error handling."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 1 changes the error message in the parse_fine_tuned_lora_name function from 'unsupported format' to 'unsupported LoRA weight'. Edit 0 adds a test that specifically checks for this exact error message using pytest.raises with match='unsupported LoRA weight'. The test directly depends on the exact error message text that was changed in edit 1. Both edits reference the same function (parse_fine_tuned_lora_name) and the same error message text, creating a direct code dependency where the test assertion must match the actual error message thrown by the implementation."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 1 changes the error message in the parse_fine_tuned_lora_name function from 'unsupported format' to 'unsupported LoRA weight'. Edit 0 adds a test that specifically checks for this exact error message using pytest.raises with match='unsupported LoRA weight'. The test directly depends on the exact error message text that was changed in edit 1. Both edits reference the same function (parse_fine_tuned_lora_name) and the same error message text, creating a direct code dependency where the test assertion must match the actual error message thrown by the implementation."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "These two edits are part of a single refactoring operation within the same function `parse_fine_tuned_lora_name`. Edit 0 removes the original assertion-based logic and conditional structure, while Edit 1 replaces it with a new conditional structure that incorporates the same logic but with proper guard conditions. The edits reference the same variables (`parts`) and implement the same logical flow but with improved structure. This is a contiguous refactoring where removing the old code (Edit 0) and adding the new code (Edit 1) are part of the same micro-task. Both edits can be staged in either order since they modify different line ranges within the same function, and the relationship is based on replacing one implementation with another rather than a strict dependency."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "These two edits are part of a single refactoring operation within the same function `parse_fine_tuned_lora_name`. Edit 0 removes the original assertion-based logic and conditional structure, while Edit 1 replaces it with a new conditional structure that incorporates the same logic but with proper guard conditions. The edits reference the same variables (`parts`) and implement the same logical flow but with improved structure. This is a contiguous refactoring where removing the old code (Edit 0) and adding the new code (Edit 1) are part of the same micro-task. Both edits can be staged in either order since they modify different line ranges within the same function, and the relationship is based on replacing one implementation with another rather than a strict dependency."
        }
    ],
    "allowed_init_edits": [
        1
    ]
}