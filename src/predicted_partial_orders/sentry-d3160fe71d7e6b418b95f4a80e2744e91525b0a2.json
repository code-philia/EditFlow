{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 imports the symbol 'to_timestamp' from sentry.utils.dates, and Edit 1 uses that exact same symbol 'to_timestamp' in line 70. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. After making the import in Edit 0, using 'to_timestamp' in Edit 1 becomes the immediate next step. Conversely, if Edit 1 is made first, the import in Edit 0 becomes necessary. In Python, using an undefined symbol is allowed at parse time and only fails at runtime, so both edits can be staged in either order without parser errors."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 imports the symbol 'to_timestamp' from sentry.utils.dates, and Edit 1 uses that exact same symbol 'to_timestamp' in line 70. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. After making the import in Edit 0, using 'to_timestamp' in Edit 1 becomes the immediate next step. Conversely, if Edit 1 is made first, the import in Edit 0 becomes necessary. In Python, using an undefined symbol is allowed at parse time and only fails at runtime, so both edits can be staged in either order without parser errors."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 imports both 'digests' and 'Record' symbols, while Edit 1 uses both of these exact same symbols in its changed lines. The import statements in Edit 0 make the symbols available for use, and Edit 1 references these exact same symbols ('digests.add()' and 'Record()'). This creates a direct definition-usage relationship where the imported symbols are immediately used. In Python, the usage can be written before the import (it would only fail at runtime), so either edit can be staged first, making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 imports both 'digests' and 'Record' symbols, while Edit 1 uses both of these exact same symbols in its changed lines. The import statements in Edit 0 make the symbols available for use, and Edit 1 references these exact same symbols ('digests.add()' and 'Record()'). This creates a direct definition-usage relationship where the imported symbols are immediately used. In Python, the usage can be written before the import (it would only fail at runtime), so either edit can be staged first, making this bi-directional."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 removes the import of 'pytz' module, while Edit 1 removes a function that uses 'pytz.utc' in its implementation. The changed lines reference the exact same symbol 'pytz' - Edit 0 removes the import statement and Edit 1 removes the usage of that imported module. After removing the import in Edit 0, the usage in Edit 1 becomes undefined, creating an immediate code-driven prompt to remove the function that depends on it. This is a classic import-usage relationship where both edits reference the same symbol."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 removes the import of 'pytz' module, while Edit 1 removes a function that uses 'pytz.utc' in its implementation. The changed lines reference the exact same symbol 'pytz' - Edit 0 removes the import statement and Edit 1 removes the usage of that imported module. After removing the import in Edit 0, the usage in Edit 1 becomes undefined, creating an immediate code-driven prompt to remove the function that depends on it. This is a classic import-usage relationship where both edits reference the same symbol."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 removes the import of 'datetime' from the datetime module, while Edit 1 removes a function that uses 'datetime(1970, 1, 1, tzinfo=pytz.utc)' in its implementation. Both edits reference the exact same symbol 'datetime' - Edit 0 removes its import and Edit 1 removes its usage. After removing the import in Edit 0, the usage in Edit 1 would cause a NameError at runtime, but both edits can still be parsed and staged in either order since Python allows referencing undefined names at parse time. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step in removing this unused datetime functionality."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 removes the import of 'datetime' from the datetime module, while Edit 1 removes a function that uses 'datetime(1970, 1, 1, tzinfo=pytz.utc)' in its implementation. Both edits reference the exact same symbol 'datetime' - Edit 0 removes its import and Edit 1 removes its usage. After removing the import in Edit 0, the usage in Edit 1 would cause a NameError at runtime, but both edits can still be parsed and staged in either order since Python allows referencing undefined names at parse time. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step in removing this unused datetime functionality."
        }
    ],
    "allowed_init_edits": [
        3
    ]
}