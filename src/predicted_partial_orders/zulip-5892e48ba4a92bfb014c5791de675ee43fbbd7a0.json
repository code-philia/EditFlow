{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds a new client 'ZulipFlutter' to the database, while Edit 1 adds handling for this same client name in the client_label_map function. Both edits reference the exact same symbol 'ZulipFlutter' - Edit 0 creates it as a database entry and Edit 1 references it in the conditional logic. After adding the ZulipFlutter client in Edit 0, the next logical step would be to ensure it has proper label mapping in Edit 1, or vice versa. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds a new client 'ZulipFlutter' to the database, while Edit 1 adds handling for this same client name in the client_label_map function. Both edits reference the exact same symbol 'ZulipFlutter' - Edit 0 creates it as a database entry and Edit 1 references it in the conditional logic. After adding the ZulipFlutter client in Edit 0, the next logical step would be to ensure it has proper label mapping in Edit 1, or vice versa. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'flutter'. Edit 0 creates/defines the flutter variable by calling Client.objects.get_or_create(name=\"ZulipFlutter\"), and edit 1 uses that same flutter variable by accessing flutter.id in a dictionary. After making edit 0, the flutter variable becomes available for use, making edit 1 the immediate next step to utilize this newly created client object. The changed lines in both edits explicitly reference the same symbol 'flutter', creating a direct definition-usage relationship within the same function scope."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'flutter'. Edit 0 creates/defines the flutter variable by calling Client.objects.get_or_create(name=\"ZulipFlutter\"), and edit 1 uses that same flutter variable by accessing flutter.id in a dictionary. After making edit 0, the flutter variable becomes available for use, making edit 1 the immediate next step to utilize this newly created client object. The changed lines in both edits explicitly reference the same symbol 'flutter', creating a direct definition-usage relationship within the same function scope."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits add identical lines referencing the same symbol 'flutter.id' with the exact same method call and parameters. This represents a bulk-edit pattern where the same structural addition is being made in multiple locations within the same method. The edits perform identical textual substitution (adding the same line) and target the same type of syntactic construct (dictionary entries with method calls). This appears to be part of a single, contiguous refactor to add flutter support to multiple data structures in the same function."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits add identical lines referencing the same symbol 'flutter.id' with the exact same method call and parameters. This represents a bulk-edit pattern where the same structural addition is being made in multiple locations within the same method. The edits perform identical textual substitution (adding the same line) and target the same type of syntactic construct (dictionary entries with method calls). This appears to be part of a single, contiguous refactor to add flutter support to multiple data structures in the same function."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'flutter' that is being introduced. Edit 0 creates/defines the flutter variable via Client.objects.get_or_create(), and Edit 1 immediately uses that same flutter variable by accessing its .id attribute. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. After making Edit 0, Edit 1 becomes the immediate next step to use the newly created flutter client object, and vice versa - both edits can be staged in either order since Python allows referencing undefined variables at parse time (would only fail at runtime)."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'flutter' that is being introduced. Edit 0 creates/defines the flutter variable via Client.objects.get_or_create(), and Edit 1 immediately uses that same flutter variable by accessing its .id attribute. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. After making Edit 0, Edit 1 becomes the immediate next step to use the newly created flutter client object, and vice versa - both edits can be staged in either order since Python allows referencing undefined variables at parse time (would only fail at runtime)."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits are modifying test data within the same test method `test_map_arrays`. Edit 0 modifies the input test data by changing ZulipMobile values and adding new entries for ZulipMobile/flutter and ZulipFlutter. Edit 1 modifies the expected output data by changing the Mobile app entry and adding a new Mobile app beta (Flutter) entry. These edits are part of the same test case modification where the input data changes necessitate corresponding changes to the expected output data to maintain test validity. The edits reference related but different data structures (input vs expected output) within the same test, making them part of a synchronized test update pattern."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits are modifying test data within the same test method `test_map_arrays`. Edit 0 modifies the input test data by changing ZulipMobile values and adding new entries for ZulipMobile/flutter and ZulipFlutter. Edit 1 modifies the expected output data by changing the Mobile app entry and adding a new Mobile app beta (Flutter) entry. These edits are part of the same test case modification where the input data changes necessitate corresponding changes to the expected output data to maintain test validity. The edits reference related but different data structures (input vs expected output) within the same test, making them part of a synchronized test update pattern."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "These edits are bi-directional neighbours because they both reference the exact same string literals that form a direct mapping relationship. Edit 1 changes the client_label_map function to return 'Mobile app (React Native)' and 'Mobile app beta (Flutter)' for specific client names, while Edit 0 updates the test expectations to use these exact same string literals as dictionary keys. The changed lines in both edits reference the identical string values, creating an immediate code-driven dependency where either edit naturally prompts the other as the next mechanical step to maintain consistency between the mapping function and its test assertions."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "These edits are bi-directional neighbours because they both reference the exact same string literals that form a direct mapping relationship. Edit 1 changes the client_label_map function to return 'Mobile app (React Native)' and 'Mobile app beta (Flutter)' for specific client names, while Edit 0 updates the test expectations to use these exact same string literals as dictionary keys. The changed lines in both edits reference the identical string values, creating an immediate code-driven dependency where either edit naturally prompts the other as the next mechanical step to maintain consistency between the mapping function and its test assertions."
        }
    ],
    "allowed_init_edits": [
        3
    ]
}