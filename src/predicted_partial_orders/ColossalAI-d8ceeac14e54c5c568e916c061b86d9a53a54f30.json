{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits fix the same typo by changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in an import statement, while Edit 1 fixes the typo in a method call that references the same class. The changed lines in both edits reference the exact same symbol (the class name HybridParallelCheckpointIO), making this a bi-directional relationship where either edit can be made first and both are part of the same typo correction task."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits fix the same typo by changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in an import statement, while Edit 1 fixes the typo in a method call that references the same class. The changed lines in both edits reference the exact same symbol (the class name HybridParallelCheckpointIO), making this a bi-directional relationship where either edit can be made first and both are part of the same typo correction task."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits are fixing the same typo - changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in the class instantiation, while Edit 1 fixes the typo in a static method call within the same class. Both changed lines reference the exact same symbol (the class name HybridParallelCheckpointIO) and represent identical textual substitutions (Hyprid\u2192Hybrid) on the same type of syntactic construct (class references). This is a clear case of bulk uniform substitution where both edits are part of the same contiguous typo-fixing task, and either edit could be made first as both are valid independently."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits are fixing the same typo - changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in the class instantiation, while Edit 1 fixes the typo in a static method call within the same class. Both changed lines reference the exact same symbol (the class name HybridParallelCheckpointIO) and represent identical textual substitutions (Hyprid\u2192Hybrid) on the same type of syntactic construct (class references). This is a clear case of bulk uniform substitution where both edits are part of the same contiguous typo-fixing task, and either edit could be made first as both are valid independently."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits fix the same typo by changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in an import statement, while Edit 1 fixes the typo in a method call within the class itself. Both changed lines reference the exact same symbol (the class name HybridParallelCheckpointIO), and this appears to be part of a single, contiguous typo-fixing operation. Either edit can be made first since both are valid Python syntax corrections, and after making either edit, the other becomes an obvious next step to complete the typo fix throughout the codebase."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits fix the same typo by changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in an import statement, while Edit 1 fixes the typo in a method call within the class itself. Both changed lines reference the exact same symbol (the class name HybridParallelCheckpointIO), and this appears to be part of a single, contiguous typo-fixing operation. Either edit can be made first since both are valid Python syntax corrections, and after making either edit, the other becomes an obvious next step to complete the typo fix throughout the codebase."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution, correcting the same typo from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in the class instantiation, while Edit 1 fixes the same typo in the import statement. Both edits reference the exact same symbol (the class name) and represent a uniform search-and-replace operation to fix a spelling error across multiple locations. This is a clear case of bulk-edit pattern synchronization where both edits can be applied in either order since they are correcting the same misspelling."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution, correcting the same typo from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in the class instantiation, while Edit 1 fixes the same typo in the import statement. Both edits reference the exact same symbol (the class name) and represent a uniform search-and-replace operation to fix a spelling error across multiple locations. This is a clear case of bulk-edit pattern synchronization where both edits can be applied in either order since they are correcting the same misspelling."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits are fixing the same typo - changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. This is a bulk uniform substitution where both edits perform the identical textual substitution (HypridParallelCheckpointIO \u2192 HybridParallelCheckpointIO) on the same type of syntactic construct (class name references). Both edits are clearly part of a single, contiguous refactor to fix the misspelled class name throughout the codebase. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform correction."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits are fixing the same typo - changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. This is a bulk uniform substitution where both edits perform the identical textual substitution (HypridParallelCheckpointIO \u2192 HybridParallelCheckpointIO) on the same type of syntactic construct (class name references). Both edits are clearly part of a single, contiguous refactor to fix the misspelled class name throughout the codebase. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform correction."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits change the exact same symbol from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' - this is a typo fix. Edit 0 changes the import statement that references this class, while Edit 1 changes the class definition itself. Both changed lines reference the exact same symbol and this represents a uniform textual substitution (HypridParallelCheckpointIO \u2192 HybridParallelCheckpointIO) across different syntactic constructs. Either edit can be made first and both are part of the same contiguous typo-fixing micro-task. This is a classic definition-usage relationship where both edits reference the same symbol."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits change the exact same symbol from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' - this is a typo fix. Edit 0 changes the import statement that references this class, while Edit 1 changes the class definition itself. Both changed lines reference the exact same symbol and this represents a uniform textual substitution (HypridParallelCheckpointIO \u2192 HybridParallelCheckpointIO) across different syntactic constructs. Either edit can be made first and both are part of the same contiguous typo-fixing micro-task. This is a classic definition-usage relationship where both edits reference the same symbol."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits correct the same typo by changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the import statement, while Edit 1 fixes the usage of the same class. The changed lines in both edits reference the exact same symbol - the class name 'HybridParallelCheckpointIO'. This is a bulk uniform substitution pattern where both edits perform identical textual substitution (HypridParallelCheckpointIO \u2192 HybridParallelCheckpointIO) on the same type of syntactic construct (class name references). Either edit can be made first, and after making either edit, the other becomes an immediate, mechanically obvious next step to maintain consistency. This represents a single uninterrupted micro-task of fixing a typo throughout the codebase."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits correct the same typo by changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the import statement, while Edit 1 fixes the usage of the same class. The changed lines in both edits reference the exact same symbol - the class name 'HybridParallelCheckpointIO'. This is a bulk uniform substitution pattern where both edits perform identical textual substitution (HypridParallelCheckpointIO \u2192 HybridParallelCheckpointIO) on the same type of syntactic construct (class name references). Either edit can be made first, and after making either edit, the other becomes an immediate, mechanically obvious next step to maintain consistency. This represents a single uninterrupted micro-task of fixing a typo throughout the codebase."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits are fixing the same typo - changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in the class instantiation, while Edit 1 fixes the typo in a static method call reference. Both changed lines reference the exact same symbol (the HybridParallelCheckpointIO class) and represent identical textual substitutions (Hyprid\u2192Hybrid) on the same type of syntactic construct (class name references). This is a uniform bulk substitution pattern where both edits are part of the same contiguous typo-fixing task and either can be applied first without creating parsing issues."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits are fixing the same typo - changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in the class instantiation, while Edit 1 fixes the typo in a static method call reference. Both changed lines reference the exact same symbol (the HybridParallelCheckpointIO class) and represent identical textual substitutions (Hyprid\u2192Hybrid) on the same type of syntactic construct (class name references). This is a uniform bulk substitution pattern where both edits are part of the same contiguous typo-fixing task and either can be applied first without creating parsing issues."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits are correcting the same typo - changing 'Hyprid' to 'Hybrid' in the class name 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in an import statement, while Edit 1 fixes the typo in a method call within the class itself. Both changed lines reference the exact same symbol (the HybridParallelCheckpointIO class), just in different contexts - one importing it and one calling a static method on it. This is a uniform textual substitution pattern correcting the same misspelling across different usages of the same symbol. Either edit can be made first without causing parse errors, and after making either edit, the other becomes an obvious next step to maintain consistency."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits are correcting the same typo - changing 'Hyprid' to 'Hybrid' in the class name 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in an import statement, while Edit 1 fixes the typo in a method call within the class itself. Both changed lines reference the exact same symbol (the HybridParallelCheckpointIO class), just in different contexts - one importing it and one calling a static method on it. This is a uniform textual substitution pattern correcting the same misspelling across different usages of the same symbol. Either edit can be made first without causing parse errors, and after making either edit, the other becomes an obvious next step to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits change the exact same symbol from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' - one edit changes the class definition and the other changes the usage/instantiation of that same class. This is a classic definition-usage relationship where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step to maintain consistency. Since this is Python, both edits can be parsed and staged in either order (the usage would just result in a runtime NameError if staged before the definition), making this bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits change the exact same symbol from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' - one edit changes the class definition and the other changes the usage/instantiation of that same class. This is a classic definition-usage relationship where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step to maintain consistency. Since this is Python, both edits can be parsed and staged in either order (the usage would just result in a runtime NameError if staged before the definition), making this bi-directional rather than ordered."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits are fixing the same typo by changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 changes the import statement that references this class, while Edit 1 changes the class definition itself. These edits reference the exact same symbol - the class name 'HypridParallelCheckpointIO' being corrected to 'HybridParallelCheckpointIO'. This is a uniform textual substitution across both the import and definition of the same symbol. Either edit can be made first and both would be part of the same contiguous typo-fixing micro-task, making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits are fixing the same typo by changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 changes the import statement that references this class, while Edit 1 changes the class definition itself. These edits reference the exact same symbol - the class name 'HypridParallelCheckpointIO' being corrected to 'HybridParallelCheckpointIO'. This is a uniform textual substitution across both the import and definition of the same symbol. Either edit can be made first and both would be part of the same contiguous typo-fixing micro-task, making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits fix the same typo by changing 'Hyprid' to 'Hybrid' in the class name 'HypridParallelCheckpointIO'. Edit 0 fixes the typo in the import statement, while Edit 1 fixes the typo in a method call that references the same class. The changed lines in both edits reference the exact same symbol (the class name), creating a direct code dependency where fixing the typo in one location naturally prompts fixing it in the other location as part of the same contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits fix the same typo by changing 'Hyprid' to 'Hybrid' in the class name 'HypridParallelCheckpointIO'. Edit 0 fixes the typo in the import statement, while Edit 1 fixes the typo in a method call that references the same class. The changed lines in both edits reference the exact same symbol (the class name), creating a direct code dependency where fixing the typo in one location naturally prompts fixing it in the other location as part of the same contiguous refactoring task."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits are fixing the same typo - changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in the import statement, while Edit 1 fixes the typo in the class method call. Both changed lines reference the exact same symbol (the class name HybridParallelCheckpointIO), and this is clearly part of a single, contiguous typo-fixing task. This is a bulk uniform substitution where both edits perform the identical textual substitution (HypridParallelCheckpointIO \u2192 HybridParallelCheckpointIO) on the same type of syntactic construct (class name references). Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the typo fix."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits are fixing the same typo - changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in the import statement, while Edit 1 fixes the typo in the class method call. Both changed lines reference the exact same symbol (the class name HybridParallelCheckpointIO), and this is clearly part of a single, contiguous typo-fixing task. This is a bulk uniform substitution where both edits perform the identical textual substitution (HypridParallelCheckpointIO \u2192 HybridParallelCheckpointIO) on the same type of syntactic construct (class name references). Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the typo fix."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform identical textual substitution of the same typo: changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. This is a uniform search-and-replace operation targeting the same type of syntactic construct (class name references) within the same class. Both changed lines reference the exact same symbol (the class name) and represent a single, contiguous refactoring task to fix the misspelled class name throughout the codebase."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitution of the same typo: changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. This is a uniform search-and-replace operation targeting the same type of syntactic construct (class name references) within the same class. Both changed lines reference the exact same symbol (the class name) and represent a single, contiguous refactoring task to fix the misspelled class name throughout the codebase."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits change the exact same class name from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' (fixing a typo). Edit 0 changes the class definition line, while Edit 1 changes a reference to that same class in a static method call. The changed lines in both edits reference the exact same symbol - the class name. After making either edit, the other becomes immediately necessary to maintain consistency and avoid NameError when the method is called. This is a clear definition-usage relationship for the same symbol."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits change the exact same class name from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' (fixing a typo). Edit 0 changes the class definition line, while Edit 1 changes a reference to that same class in a static method call. The changed lines in both edits reference the exact same symbol - the class name. After making either edit, the other becomes immediately necessary to maintain consistency and avoid NameError when the method is called. This is a clear definition-usage relationship for the same symbol."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits fix the same typo by changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in the import statement, while Edit 1 fixes the typo in a method call within the class itself. Both edits reference the exact same symbol (the class name HybridParallelCheckpointIO) and perform identical textual substitution (Hyprid\u2192Hybrid). This is a bulk uniform substitution pattern where both edits are part of the same contiguous typo-fixing task. Either edit can be made first, and after making either edit, the other becomes an immediate, mechanically obvious next step to complete the typo fix."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits fix the same typo by changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in the import statement, while Edit 1 fixes the typo in a method call within the class itself. Both edits reference the exact same symbol (the class name HybridParallelCheckpointIO) and perform identical textual substitution (Hyprid\u2192Hybrid). This is a bulk uniform substitution pattern where both edits are part of the same contiguous typo-fixing task. Either edit can be made first, and after making either edit, the other becomes an immediate, mechanically obvious next step to complete the typo fix."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits change the exact same symbol - the class name 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' (fixing a typo). Edit 0 changes the class definition line, while Edit 1 changes a reference to that same class in a method call. This is a classic definition-usage relationship where both edits reference the exact same symbol. After making either edit, the other becomes immediately necessary to maintain consistency - if you fix the class name in the definition, you must also fix all references to it, and vice versa. This creates a direct, mechanically obvious prompt for the companion edit."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits change the exact same symbol - the class name 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' (fixing a typo). Edit 0 changes the class definition line, while Edit 1 changes a reference to that same class in a method call. This is a classic definition-usage relationship where both edits reference the exact same symbol. After making either edit, the other becomes immediately necessary to maintain consistency - if you fix the class name in the definition, you must also fix all references to it, and vice versa. This creates a direct, mechanically obvious prompt for the companion edit."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits change the exact same symbol from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' - this is a typo fix. Edit 0 changes the class definition/name, while Edit 1 changes a reference to that same class in a method call. This creates an immediate code dependency: if only one edit is made, there will be a NameError at runtime since the class name and its reference won't match. Both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in fixing this typo throughout the codebase."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits change the exact same symbol from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' - this is a typo fix. Edit 0 changes the class definition/name, while Edit 1 changes a reference to that same class in a method call. This creates an immediate code dependency: if only one edit is made, there will be a NameError at runtime since the class name and its reference won't match. Both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in fixing this typo throughout the codebase."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform identical textual substitution of the same class name 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' (fixing a typo). The changed lines in both edits reference the exact same symbol - the class name being corrected. This is a uniform bulk substitution pattern where both edits are part of the same contiguous refactor to fix the misspelled class name throughout the codebase. Either edit can be made first, and after making either one, the other becomes an immediate next step to maintain consistency."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitution of the same class name 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' (fixing a typo). The changed lines in both edits reference the exact same symbol - the class name being corrected. This is a uniform bulk substitution pattern where both edits are part of the same contiguous refactor to fix the misspelled class name throughout the codebase. Either edit can be made first, and after making either one, the other becomes an immediate next step to maintain consistency."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform identical textual substitution of the same typo: changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' in method calls within the same class. This is a clear bulk-edit pattern where both changed lines reference the exact same class name and perform the same before\u2192after correction. Both edits are part of a single, contiguous typo-fixing micro-task and either can be made first, with the other being the natural next step in completing the uniform correction."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform identical textual substitution of the same typo: changing 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO' in method calls within the same class. This is a clear bulk-edit pattern where both changed lines reference the exact same class name and perform the same before\u2192after correction. Both edits are part of a single, contiguous typo-fixing micro-task and either can be made first, with the other being the natural next step in completing the uniform correction."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution, correcting the same typo from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in an import statement, while Edit 1 fixes the same typo in an __init__.py file's import/export statement. Both edits target the same type of syntactic construct (import statements) and apply the exact same before\u2192after pattern. This is a clear case of bulk-edit pattern synchronization where both edits are part of a single, contiguous refactor to fix the same typo across multiple locations. Either edit can be made first, and both reference the exact same symbol being corrected."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution, correcting the same typo from 'HypridParallelCheckpointIO' to 'HybridParallelCheckpointIO'. Edit 0 fixes the typo in an import statement, while Edit 1 fixes the same typo in an __init__.py file's import/export statement. Both edits target the same type of syntactic construct (import statements) and apply the exact same before\u2192after pattern. This is a clear case of bulk-edit pattern synchronization where both edits are part of a single, contiguous refactor to fix the same typo across multiple locations. Either edit can be made first, and both reference the exact same symbol being corrected."
        }
    ],
    "allowed_init_edits": [
        0,
        6,
        1,
        4,
        2,
        5,
        3
    ]
}