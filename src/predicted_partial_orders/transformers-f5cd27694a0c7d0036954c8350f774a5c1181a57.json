{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds a 'params' parameter to the function signature, and Edit 1 modifies the function body to use this new parameter with a fallback to self.params. The changed lines reference the exact same symbol 'params' - Edit 0 defines it as a parameter and Edit 1 uses it in the function body. This creates an immediate code dependency where adding the parameter naturally prompts updating its usage in the body, making them part of a single micro-task of adding parameter threading functionality."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds a 'params' parameter to the function signature, and Edit 1 modifies the function body to use this new parameter with a fallback to self.params. The changed lines reference the exact same symbol 'params' - Edit 0 defines it as a parameter and Edit 1 uses it in the function body. This creates an immediate code dependency where adding the parameter naturally prompts updating its usage in the body, making them part of a single micro-task of adding parameter threading functionality."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both change `{\"params\": self.params}` to `{\"params\": params or self.params}` in the same structural location within similar `get_text_features` methods that call `self.module.apply`. This represents a bulk-edit pattern where the same before\u2192after transformation is being applied to multiple instances of the same construct type across different files. The edits appear to be part of a single, contiguous refactor to add parameter flexibility to similar methods."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution on the same type of syntactic construct. They both change `{\"params\": self.params}` to `{\"params\": params or self.params}` in the same structural location within similar `get_text_features` methods that call `self.module.apply`. This represents a bulk-edit pattern where the same before\u2192after transformation is being applied to multiple instances of the same construct type across different files. The edits appear to be part of a single, contiguous refactor to add parameter flexibility to similar methods."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits add the exact same parameter 'params: dict = None' to two different method signatures within the same class (FlaxHybridCLIP). This represents a synchronized parameter addition pattern where the same parameter is being added to multiple related methods as part of a single refactoring task. The edits involve identical structural substitutions (adding the same parameter with the same type annotation and default value) to the same type of syntactic construct (method signatures). This creates a mirrored, structurally identical substitution that would naturally occur in one contiguous micro-task."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits add the exact same parameter 'params: dict = None' to two different method signatures within the same class (FlaxHybridCLIP). This represents a synchronized parameter addition pattern where the same parameter is being added to multiple related methods as part of a single refactoring task. The edits involve identical structural substitutions (adding the same parameter with the same type annotation and default value) to the same type of syntactic construct (method signatures). This creates a mirrored, structurally identical substitution that would naturally occur in one contiguous micro-task."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 adds a 'params' parameter to the get_image_features method signature, and Edit 1 modifies the method body to use this new parameter with a fallback to self.params. The changed lines reference the exact same symbol 'params' - Edit 0 defines it as a parameter, and Edit 1 uses it in the method implementation. This creates an immediate code-driven linkage where adding the parameter naturally prompts updating its usage in the method body as the next contiguous action within the same micro-task."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 adds a 'params' parameter to the get_image_features method signature, and Edit 1 modifies the method body to use this new parameter with a fallback to self.params. The changed lines reference the exact same symbol 'params' - Edit 0 defines it as a parameter, and Edit 1 uses it in the method implementation. This creates an immediate code-driven linkage where adding the parameter naturally prompts updating its usage in the method body as the next contiguous action within the same micro-task."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits perform identical structural modifications to the same method signature `get_image_features` by adding the same parameter `params: dict = None` in the same position. This represents a bulk-edit pattern where the same textual substitution (adding the params parameter) is applied to the same type of syntactic construct (method signatures) across different files. Both edits are part of a single, contiguous refactor to synchronize the API signature of the `get_image_features` method across different CLIP model implementations. Either edit can be made first, and after making either one, the other becomes the natural next step to maintain API consistency."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits perform identical structural modifications to the same method signature `get_image_features` by adding the same parameter `params: dict = None` in the same position. This represents a bulk-edit pattern where the same textual substitution (adding the params parameter) is applied to the same type of syntactic construct (method signatures) across different files. Both edits are part of a single, contiguous refactor to synchronize the API signature of the `get_image_features` method across different CLIP model implementations. Either edit can be made first, and after making either one, the other becomes the natural next step to maintain API consistency."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern, changing '{\"params\": self.params}' to '{\"params\": params or self.params}' in the same type of syntactic construct (dictionary literal passed to module.apply method). This represents a uniform refactoring pattern being applied across multiple similar code locations, making either edit naturally prompt the other as part of the same contiguous micro-task."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern, changing '{\"params\": self.params}' to '{\"params\": params or self.params}' in the same type of syntactic construct (dictionary literal passed to module.apply method). This represents a uniform refactoring pattern being applied across multiple similar code locations, making either edit naturally prompt the other as part of the same contiguous micro-task."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern, changing '{\"params\": self.params}' to '{\"params\": params or self.params}' in similar method contexts within different CLIP model classes. This represents a uniform refactoring pattern applied to the same type of syntactic construct (dictionary parameter passing in module.apply calls). The edits are part of a single refactoring operation to add parameter flexibility across related model classes, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern, changing '{\"params\": self.params}' to '{\"params\": params or self.params}' in similar method contexts within different CLIP model classes. This represents a uniform refactoring pattern applied to the same type of syntactic construct (dictionary parameter passing in module.apply calls). The edits are part of a single refactoring operation to add parameter flexibility across related model classes, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing '{\"params\": self.params}' to '{\"params\": params or self.params}' in the same type of syntactic construct (dictionary literals passed to self.module.apply()). This is a uniform refactoring pattern applied to two similar method implementations within the same class. The edits are clearly part of a single, contiguous refactor to add parameter flexibility to both methods. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: changing '{\"params\": self.params}' to '{\"params\": params or self.params}' in the same type of syntactic construct (dictionary literals passed to self.module.apply()). This is a uniform refactoring pattern applied to two similar method implementations within the same class. The edits are clearly part of a single, contiguous refactor to add parameter flexibility to both methods. Either edit can be made first, and after making either one, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 adds a 'params' parameter to the function signature, and Edit 1 updates the function body to use this new parameter with a fallback to self.params. The changed lines reference the exact same symbol 'params' - Edit 0 introduces it as a parameter and Edit 1 uses it in the method body. This creates an immediate code-driven linkage where adding the parameter naturally prompts updating its usage in the body as the next contiguous action within the same micro-task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 adds a 'params' parameter to the function signature, and Edit 1 updates the function body to use this new parameter with a fallback to self.params. The changed lines reference the exact same symbol 'params' - Edit 0 introduces it as a parameter and Edit 1 uses it in the method body. This creates an immediate code-driven linkage where adding the parameter naturally prompts updating its usage in the body as the next contiguous action within the same micro-task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits add the identical parameter `params: dict = None` to method signatures within the same class `FlaxCLIPPreTrainedModel`. This represents a synchronized parameter addition pattern - both methods are being updated with the same new parameter in the same structural context. The changes follow an identical before\u2192after pattern (adding `params: dict = None` parameter) on the same type of syntactic construct (method signatures in the same class). This is a clear case of bulk-edit/pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to related methods."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits add the identical parameter `params: dict = None` to method signatures within the same class `FlaxCLIPPreTrainedModel`. This represents a synchronized parameter addition pattern - both methods are being updated with the same new parameter in the same structural context. The changes follow an identical before\u2192after pattern (adding `params: dict = None` parameter) on the same type of syntactic construct (method signatures in the same class). This is a clear case of bulk-edit/pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to related methods."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern (changing '{\"params\": self.params}' to '{\"params\": params or self.params}') on the same type of syntactic construct (dictionary parameter in module.apply() calls). This represents a uniform refactoring pattern being applied across multiple files to the same structural element. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactoring sweep. Either edit could be made first, and after making one, the other would be the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern (changing '{\"params\": self.params}' to '{\"params\": params or self.params}') on the same type of syntactic construct (dictionary parameter in module.apply() calls). This represents a uniform refactoring pattern being applied across multiple files to the same structural element. The changes are mechanically identical and would naturally occur as part of a single, contiguous refactoring sweep. Either edit could be made first, and after making one, the other would be the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits are adding a 'params: dict = None' parameter to different methods within the same class (FlaxCLIPPreTrainedModel). Edit 0 modifies the get_text_features method to use 'params or self.params' in the module.apply call, while Edit 1 adds the same 'params: dict = None' parameter to the get_image_features method signature. This represents a synchronized parameter addition pattern where the same parameter is being added to multiple methods in the same class as part of a uniform API enhancement. The edits follow an identical structural pattern (adding the same parameter with the same type annotation and default value) and target the same type of syntactic construct (method signatures in the same class). This is a clear case of bulk-edit synchronization where both methods are being updated with the same parameter addition pattern."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits are adding a 'params: dict = None' parameter to different methods within the same class (FlaxCLIPPreTrainedModel). Edit 0 modifies the get_text_features method to use 'params or self.params' in the module.apply call, while Edit 1 adds the same 'params: dict = None' parameter to the get_image_features method signature. This represents a synchronized parameter addition pattern where the same parameter is being added to multiple methods in the same class as part of a uniform API enhancement. The edits follow an identical structural pattern (adding the same parameter with the same type annotation and default value) and target the same type of syntactic construct (method signatures in the same class). This is a clear case of bulk-edit synchronization where both methods are being updated with the same parameter addition pattern."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 adds a 'params' parameter to the get_image_features method signature, and Edit 1 modifies the method body to use this new 'params' parameter (with a fallback to self.params). The changed lines reference the exact same symbol - the 'params' parameter that was added in Edit 0 is directly used in Edit 1. This creates an immediate code dependency where adding the parameter naturally prompts updating the method body to use it, making them part of a single contiguous micro-task."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 adds a 'params' parameter to the get_image_features method signature, and Edit 1 modifies the method body to use this new 'params' parameter (with a fallback to self.params). The changed lines reference the exact same symbol - the 'params' parameter that was added in Edit 0 is directly used in Edit 1. This creates an immediate code dependency where adding the parameter naturally prompts updating the method body to use it, making them part of a single contiguous micro-task."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing `{\"params\": self.params}` to `{\"params\": params or self.params}` in different methods of the same class. This is a bulk-edit pattern where the same structural change is being applied to the same type of syntactic construct (module.apply parameter dictionaries) within the same class context. Both edits are part of what appears to be a single refactoring operation to add parameter override capability to multiple methods. Either edit can be made first, and after making one, the other becomes the natural next step to complete the uniform pattern application."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing `{\"params\": self.params}` to `{\"params\": params or self.params}` in different methods of the same class. This is a bulk-edit pattern where the same structural change is being applied to the same type of syntactic construct (module.apply parameter dictionaries) within the same class context. Both edits are part of what appears to be a single refactoring operation to add parameter override capability to multiple methods. Either edit can be made first, and after making one, the other becomes the natural next step to complete the uniform pattern application."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "These edits involve the exact same method signature and its corresponding usage within the same codebase. Edit 1 adds a 'params' parameter to the get_image_features method signature, and Edit 0 modifies the usage of that method to utilize the new 'params' parameter with '{'params': params or self.params}'. The changed lines reference the exact same symbol (the params parameter and its usage in the method call). This creates an immediate, mechanically obvious code-driven prompt - after adding the parameter to the signature, the implementation needs to be updated to use it, and vice versa. Both edits can be staged in either order without causing parser errors, making this a bi-directional relationship."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "These edits involve the exact same method signature and its corresponding usage within the same codebase. Edit 1 adds a 'params' parameter to the get_image_features method signature, and Edit 0 modifies the usage of that method to utilize the new 'params' parameter with '{'params': params or self.params}'. The changed lines reference the exact same symbol (the params parameter and its usage in the method call). This creates an immediate, mechanically obvious code-driven prompt - after adding the parameter to the signature, the implementation needs to be updated to use it, and vice versa. Both edits can be staged in either order without causing parser errors, making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits are adding a `params: dict = None` parameter to different methods (`get_text_features` and `get_image_features`) in the same class `FlaxHybridCLIP`. Edit 0 also shows the usage pattern where `params or self.params` is used. This appears to be a synchronized parameter addition across related methods in the same class, following the same pattern and structure. Both methods are feature extraction methods in the same model class, and the parameter addition follows an identical pattern (same parameter name, type annotation, and default value). This represents a bulk-edit pattern where the same structural change is being applied to multiple related methods."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits are adding a `params: dict = None` parameter to different methods (`get_text_features` and `get_image_features`) in the same class `FlaxHybridCLIP`. Edit 0 also shows the usage pattern where `params or self.params` is used. This appears to be a synchronized parameter addition across related methods in the same class, following the same pattern and structure. Both methods are feature extraction methods in the same model class, and the parameter addition follows an identical pattern (same parameter name, type annotation, and default value). This represents a bulk-edit pattern where the same structural change is being applied to multiple related methods."
        }
    ],
    "allowed_init_edits": [
        0,
        4
    ]
}