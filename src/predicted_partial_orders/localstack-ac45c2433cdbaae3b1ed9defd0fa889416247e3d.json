{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution, changing 'timestamp_millis()' to 'epoch_timestamp()' in the same type of syntactic construct (dictionary value assignment for 'approximateArrivalTimestamp' key). This is a uniform refactoring pattern within the same file and method, where both changes are part of a single, contiguous search-and-replace operation. The edits reference the same function call pattern and perform the exact same before\u2192after transformation."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution, changing 'timestamp_millis()' to 'epoch_timestamp()' in the same type of syntactic construct (dictionary value assignment for 'approximateArrivalTimestamp' key). This is a uniform refactoring pattern within the same file and method, where both changes are part of a single, contiguous search-and-replace operation. The edits reference the same function call pattern and perform the exact same before\u2192after transformation."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 1 defines a new function 'epoch_timestamp' and Edit 0 imports that exact same function. The changed lines reference the exact same symbol - the 'epoch_timestamp' function. After defining the function in Edit 1, importing it in Edit 0 becomes the immediate next step to use it. However, since this is Python, the import can be written and parsed even before the function is defined (it would only fail at runtime/import time with a NameError). Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 1 defines a new function 'epoch_timestamp' and Edit 0 imports that exact same function. The changed lines reference the exact same symbol - the 'epoch_timestamp' function. After defining the function in Edit 1, importing it in Edit 0 becomes the immediate next step to use it. However, since this is Python, the import can be written and parsed even before the function is defined (it would only fail at runtime/import time with a NameError). Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 1 defines a new function 'epoch_timestamp' and Edit 0 calls that exact same function. The changed line in Edit 0 references the symbol 'epoch_timestamp' that is being defined in Edit 1. This creates a direct code dependency where defining the function (Edit 1) and using it (Edit 0) are mechanically linked. However, since this is Python, the usage can be written and parsed before the definition exists (it would only fail at runtime with a NameError), so either edit can be staged first. This makes it bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 1 defines a new function 'epoch_timestamp' and Edit 0 calls that exact same function. The changed line in Edit 0 references the symbol 'epoch_timestamp' that is being defined in Edit 1. This creates a direct code dependency where defining the function (Edit 1) and using it (Edit 0) are mechanically linked. However, since this is Python, the usage can be written and parsed before the definition exists (it would only fail at runtime with a NameError), so either edit can be staged first. This makes it bi-directional rather than ordered."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 1 defines a new function 'epoch_timestamp' and Edit 0 calls that exact same function. The changed line in Edit 0 references the symbol 'epoch_timestamp' that is being defined in Edit 1. This creates a direct code dependency where defining the function (Edit 1) and using it (Edit 0) are mechanically linked. However, since this is Python, the usage can be written and parsed before the definition exists (it would only fail at runtime with a NameError), so either edit can be staged first. This makes it bi-directional rather than ordered."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 1 defines a new function 'epoch_timestamp' and Edit 0 calls that exact same function. The changed line in Edit 0 references the symbol 'epoch_timestamp' that is being defined in Edit 1. This creates a direct code dependency where defining the function (Edit 1) and using it (Edit 0) are mechanically linked. However, since this is Python, the usage can be written and parsed before the definition exists (it would only fail at runtime with a NameError), so either edit can be staged first. This makes it bi-directional rather than ordered."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol being renamed from 'timestamp_millis' to 'epoch_timestamp'. Edit 0 changes the import statement to import the new function name, while Edit 1 changes the usage of that function. After making either edit, the other becomes immediately necessary to maintain code consistency - if you change the import without changing the usage, you get a NameError at runtime; if you change the usage without changing the import, you also get a NameError. Since Python allows both edits to be parsed and staged in either order (the error only occurs at runtime), this is a bi-directional relationship where both edits reference the same symbol and either naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol being renamed from 'timestamp_millis' to 'epoch_timestamp'. Edit 0 changes the import statement to import the new function name, while Edit 1 changes the usage of that function. After making either edit, the other becomes immediately necessary to maintain code consistency - if you change the import without changing the usage, you get a NameError at runtime; if you change the usage without changing the import, you also get a NameError. Since Python allows both edits to be parsed and staged in either order (the error only occurs at runtime), this is a bi-directional relationship where both edits reference the same symbol and either naturally prompts the other as the next mechanical step."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol being renamed from 'timestamp_millis' to 'epoch_timestamp'. Edit 0 changes the import statement to import the new function name, while Edit 1 changes the usage of that function. After making either edit, the other becomes immediately necessary to maintain code consistency - if you change the import without changing the usage, you get a NameError at runtime; if you change the usage without changing the import, you also get a NameError. Since Python allows both edits to be parsed and staged in either order (the error only occurs at runtime), this is a bi-directional relationship where both edits reference the same symbol and either naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol being renamed from 'timestamp_millis' to 'epoch_timestamp'. Edit 0 changes the import statement to import the new function name, while Edit 1 changes the usage of that function. After making either edit, the other becomes immediately necessary to maintain code consistency - if you change the import without changing the usage, you get a NameError at runtime; if you change the usage without changing the import, you also get a NameError. Since Python allows both edits to be parsed and staged in either order (the error only occurs at runtime), this is a bi-directional relationship where both edits reference the same symbol and either naturally prompts the other as the next mechanical step."
        }
    ],
    "allowed_init_edits": [
        4,
        5
    ]
}