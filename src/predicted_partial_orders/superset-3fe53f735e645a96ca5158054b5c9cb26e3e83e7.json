{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. They both change the string literal 'dashboards/World_Banks_Data.yaml' to 'f\"dashboards/World_Banks_Data_{example_dashboard.id}.yaml\"' within test assertion contexts. This represents a uniform refactoring pattern applied to the same construct type (string literals in test assertions) as part of a single, contiguous refactor to make dashboard export filenames unique by including the dashboard ID. The edits are clearly part of the same bulk substitution operation."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. They both change the string literal 'dashboards/World_Banks_Data.yaml' to 'f\"dashboards/World_Banks_Data_{example_dashboard.id}.yaml\"' within test assertion contexts. This represents a uniform refactoring pattern applied to the same construct type (string literals in test assertions) as part of a single, contiguous refactor to make dashboard export filenames unique by including the dashboard ID. The edits are clearly part of the same bulk substitution operation."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits modify the exact same string pattern 'dashboards/World_Banks_Data.yaml' to 'dashboards/World_Banks_Data_{example_dashboard.id}.yaml' within the same test method. Edit 0 changes the expected filename in a list, and Edit 1 changes the key used to access the contents dictionary. This is a uniform textual substitution of the same string literal across two locations in the same function, making it a synchronized pattern change where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits modify the exact same string pattern 'dashboards/World_Banks_Data.yaml' to 'dashboards/World_Banks_Data_{example_dashboard.id}.yaml' within the same test method. Edit 0 changes the expected filename in a list, and Edit 1 changes the key used to access the contents dictionary. This is a uniform textual substitution of the same string literal across two locations in the same function, making it a synchronized pattern change where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. They both change the dictionary key access from a static string 'dashboards/World_Banks_Data.yaml' to a dynamic f-string 'dashboards/World_Banks_Data_{example_dashboard.id}.yaml'. This is a uniform, synchronized substitution across multiple test methods within the same test class, where both changed lines perform the exact same before\u2192after transformation on the same construct type (dictionary key access for YAML file paths). This represents a single, contiguous refactoring operation where either edit could be made first and would naturally prompt the other as part of the same bulk update pattern."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. They both change the dictionary key access from a static string 'dashboards/World_Banks_Data.yaml' to a dynamic f-string 'dashboards/World_Banks_Data_{example_dashboard.id}.yaml'. This is a uniform, synchronized substitution across multiple test methods within the same test class, where both changed lines perform the exact same before\u2192after transformation on the same construct type (dictionary key access for YAML file paths). This represents a single, contiguous refactoring operation where either edit could be made first and would naturally prompt the other as part of the same bulk update pattern."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits reference the exact same change pattern: modifying the dashboard file naming convention from `{dashboard_slug}.yaml` to `{dashboard_slug}_{model.id}.yaml`. Edit 0 changes the production code that generates the filename format, while Edit 1 updates the test code to expect the new filename format with the ID suffix. The test code directly references the exact same filename pattern being modified in the production code. This creates a bi-directional relationship where either edit can be made first, but after making one, the other becomes the immediate next step to maintain code consistency - if you change the filename format in production, you must update the test to match, and vice versa."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits reference the exact same change pattern: modifying the dashboard file naming convention from `{dashboard_slug}.yaml` to `{dashboard_slug}_{model.id}.yaml`. Edit 0 changes the production code that generates the filename format, while Edit 1 updates the test code to expect the new filename format with the ID suffix. The test code directly references the exact same filename pattern being modified in the production code. This creates a bi-directional relationship where either edit can be made first, but after making one, the other becomes the immediate next step to maintain code consistency - if you change the filename format in production, you must update the test to match, and vice versa."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits modify the same file naming pattern for dashboard exports. Edit 0 changes the production code to include the model ID in the filename format (from 'dashboards/{dashboard_slug}.yaml' to 'dashboards/{dashboard_slug}_{model.id}.yaml'), while Edit 1 updates the corresponding test assertion to expect the new filename format with the ID included. The test is directly asserting on the exact filename format that the production code generates, creating a direct code dependency where both edits reference the same filename generation pattern."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits modify the same file naming pattern for dashboard exports. Edit 0 changes the production code to include the model ID in the filename format (from 'dashboards/{dashboard_slug}.yaml' to 'dashboards/{dashboard_slug}_{model.id}.yaml'), while Edit 1 updates the corresponding test assertion to expect the new filename format with the ID included. The test is directly asserting on the exact filename format that the production code generates, creating a direct code dependency where both edits reference the same filename generation pattern."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits reference the exact same change to the dashboard export filename format. Edit 0 changes the production code to include the model ID in the filename pattern (from 'dashboards/{dashboard_slug}.yaml' to 'dashboards/{dashboard_slug}_{model.id}.yaml'), and Edit 1 updates the corresponding test code to expect this new filename format when loading the exported dashboard metadata. The test is directly asserting on the behavior modified in the production code - they reference the same filename generation logic and the test must be updated to match the production change. This is a classic test-production synchronization where both edits work together to maintain the same API contract."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits reference the exact same change to the dashboard export filename format. Edit 0 changes the production code to include the model ID in the filename pattern (from 'dashboards/{dashboard_slug}.yaml' to 'dashboards/{dashboard_slug}_{model.id}.yaml'), and Edit 1 updates the corresponding test code to expect this new filename format when loading the exported dashboard metadata. The test is directly asserting on the behavior modified in the production code - they reference the same filename generation logic and the test must be updated to match the production change. This is a classic test-production synchronization where both edits work together to maintain the same API contract."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits modify the exact same file naming pattern for dashboard exports. Edit 0 changes the production code to include the model ID in the filename format (from 'dashboards/{dashboard_slug}.yaml' to 'dashboards/{dashboard_slug}_{model.id}.yaml'), while Edit 1 updates the corresponding test assertion to expect the new filename format with the dashboard ID included. The test is directly asserting on the behavior being modified in the production code - they reference the same file naming logic and the test must be updated to match the production change. This is a classic test-production synchronization where changing the implementation requires updating the test expectation for the exact same functionality."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits modify the exact same file naming pattern for dashboard exports. Edit 0 changes the production code to include the model ID in the filename format (from 'dashboards/{dashboard_slug}.yaml' to 'dashboards/{dashboard_slug}_{model.id}.yaml'), while Edit 1 updates the corresponding test assertion to expect the new filename format with the dashboard ID included. The test is directly asserting on the behavior being modified in the production code - they reference the same file naming logic and the test must be updated to match the production change. This is a classic test-production synchronization where changing the implementation requires updating the test expectation for the exact same functionality."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits modify string literals that reference the same dashboard file path pattern, changing from a hardcoded 'World_Banks_Data.yaml' to a dynamic 'World_Banks_Data_{example_dashboard.id}.yaml' format. The first edit changes the expected filename in a test assertion, while the second edit changes the key used to access that same file from a contents dictionary. Both edits are part of the same refactoring to make the dashboard filename dynamic by including the dashboard ID. This represents a synchronized pattern substitution where both changed lines reference the exact same file path pattern and both need to be updated together for the test to work correctly. Either edit can be made first since both are valid Python syntax independently, but after making either edit, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits modify string literals that reference the same dashboard file path pattern, changing from a hardcoded 'World_Banks_Data.yaml' to a dynamic 'World_Banks_Data_{example_dashboard.id}.yaml' format. The first edit changes the expected filename in a test assertion, while the second edit changes the key used to access that same file from a contents dictionary. Both edits are part of the same refactoring to make the dashboard filename dynamic by including the dashboard ID. This represents a synchronized pattern substitution where both changed lines reference the exact same file path pattern and both need to be updated together for the test to work correctly. Either edit can be made first since both are valid Python syntax independently, but after making either edit, the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. They both change 'World_Banks_Data.yaml' to 'World_Banks_Data_{example_dashboard.id}.yaml' in string literals within the same test file. This represents a uniform refactoring operation where the same before\u2192after pattern is applied to the same construct type (string literals referencing dashboard file paths). Both edits are part of a single, contiguous refactor to update dashboard file naming conventions throughout the test file."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. They both change 'World_Banks_Data.yaml' to 'World_Banks_Data_{example_dashboard.id}.yaml' in string literals within the same test file. This represents a uniform refactoring operation where the same before\u2192after pattern is applied to the same construct type (string literals referencing dashboard file paths). Both edits are part of a single, contiguous refactor to update dashboard file naming conventions throughout the test file."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. They both change 'World_Banks_Data.yaml' to 'World_Banks_Data_{example_dashboard.id}.yaml' in string literals within the same test file. This represents a uniform refactoring operation where the same filename pattern is being updated consistently across multiple test methods. The edits are part of a single, contiguous refactor to include the dashboard ID in the filename pattern, making them synchronized pattern changes that would naturally occur together in one micro-task."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern on the same type of syntactic construct. They both change 'World_Banks_Data.yaml' to 'World_Banks_Data_{example_dashboard.id}.yaml' in string literals within the same test file. This represents a uniform refactoring operation where the same filename pattern is being updated consistently across multiple test methods. The edits are part of a single, contiguous refactor to include the dashboard ID in the filename pattern, making them synchronized pattern changes that would naturally occur together in one micro-task."
        }
    ],
    "allowed_init_edits": [
        4
    ]
}