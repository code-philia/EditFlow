{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 defines the variable 'has_ie_compat' by assigning it a boolean value based on checking meta tags. Edit 1 uses this exact same variable 'has_ie_compat' in a conditional statement. Both edits are within the same function '_generate_meta_html' and reference the exact same symbol. After making edit 0, edit 1 becomes the immediate next step to use the newly defined variable. This is a classic definition-usage pattern within the same function scope."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 defines the variable 'has_ie_compat' by assigning it a boolean value based on checking meta tags. Edit 1 uses this exact same variable 'has_ie_compat' in a conditional statement. Both edits are within the same function '_generate_meta_html' and reference the exact same symbol. After making edit 0, edit 1 becomes the immediate next step to use the newly defined variable. This is a classic definition-usage pattern within the same function scope."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: removing the forward slash from self-closing HTML meta tags. Edit 0 changes '<meta charset=\"UTF-8\"/>' to '<meta charset=\"UTF-8\">' and Edit 1 changes '<meta {} />' to '<meta {}>'. This is a uniform, synchronized substitution across the same type of syntactic construct (HTML meta tag generation) within the same method (_generate_meta_html). Both edits are part of a single refactoring task to standardize meta tag formatting by removing self-closing syntax. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the uniform pattern change."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: removing the forward slash from self-closing HTML meta tags. Edit 0 changes '<meta charset=\"UTF-8\"/>' to '<meta charset=\"UTF-8\">' and Edit 1 changes '<meta {} />' to '<meta {}>'. This is a uniform, synchronized substitution across the same type of syntactic construct (HTML meta tag generation) within the same method (_generate_meta_html). Both edits are part of a single refactoring task to standardize meta tag formatting by removing self-closing syntax. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the uniform pattern change."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Edit 0 adds a new meta tag with http-equiv=\"X-UA-Compatible\" to the _generate_meta_html method in the Dash class. Edit 1 updates a test assertion that counts meta tags, changing the expected count from 'len(meta) - 1' to 'len(meta) - 2' and updating the comment to reference both 'meta charset and http-equiv'. The test is directly validating the behavior of the code modified in edit 0 - specifically counting the meta tags generated by the _generate_meta_html method. The test assertion needs to be updated to account for the additional meta tag added in edit 0. Both edits reference the same functionality (meta tag generation and counting) and the test edit is a direct consequence of the implementation change."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Edit 0 adds a new meta tag with http-equiv=\"X-UA-Compatible\" to the _generate_meta_html method in the Dash class. Edit 1 updates a test assertion that counts meta tags, changing the expected count from 'len(meta) - 1' to 'len(meta) - 2' and updating the comment to reference both 'meta charset and http-equiv'. The test is directly validating the behavior of the code modified in edit 0 - specifically counting the meta tags generated by the _generate_meta_html method. The test assertion needs to be updated to account for the additional meta tag added in edit 0. Both edits reference the same functionality (meta tag generation and counting) and the test edit is a direct consequence of the implementation change."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "These two edits are part of a single, contiguous refactoring operation that changes a tuple to a list. Edit 0 changes the opening parenthesis '(' to opening bracket '[' on line 274, while Edit 1 changes the closing parenthesis ')' to closing bracket ']' on line 277. Both edits reference the exact same data structure (the 'metas' variable assignment) and perform identical structural substitution (tuple syntax \u2192 list syntax). This is a mechanically obvious, code-driven change where making either edit creates an immediate prompt for the other to complete the syntactic transformation. The edits cannot logically be separated as they form two parts of the same atomic operation."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "These two edits are part of a single, contiguous refactoring operation that changes a tuple to a list. Edit 0 changes the opening parenthesis '(' to opening bracket '[' on line 274, while Edit 1 changes the closing parenthesis ')' to closing bracket ']' on line 277. Both edits reference the exact same data structure (the 'metas' variable assignment) and perform identical structural substitution (tuple syntax \u2192 list syntax). This is a mechanically obvious, code-driven change where making either edit creates an immediate prompt for the other to complete the syntactic transformation. The edits cannot logically be separated as they form two parts of the same atomic operation."
        },
        {
            "src": 4,
            "tgt": 8,
            "reason": "Both edits reference the exact same symbol 'metas' within the same function test_meta_tags(). Edit 0 changes the initialization of the metas variable from a tuple to a list, and Edit 1 changes how metas is accessed by modifying the index from [i-1] to [i-2]. These edits are part of a single micro-task where changing the data structure (edit 0) creates an immediate need to adjust the indexing logic (edit 1) to maintain correct behavior. The changed lines in both edits explicitly reference the same metas symbol, creating a direct code dependency where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 8,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'metas' within the same function test_meta_tags(). Edit 0 changes the initialization of the metas variable from a tuple to a list, and Edit 1 changes how metas is accessed by modifying the index from [i-1] to [i-2]. These edits are part of a single micro-task where changing the data structure (edit 0) creates an immediate need to adjust the indexing logic (edit 1) to maintain correct behavior. The changed lines in both edits explicitly reference the same metas symbol, creating a direct code dependency where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbol 'metas' within the same test method. Edit 0 changes the data structure of 'metas' from a tuple (parentheses) to a list (square brackets), and Edit 1 updates the assertion logic that operates on this same 'metas' variable by changing the expected length calculation from 'len(meta) - 1' to 'len(meta) - 2'. The comment change in Edit 1 also reflects this structural change. Since both edits operate on the same symbol within the same function scope and either edit could be made first (both are syntactically valid regardless of order), this represents a bi-directional relationship where making either edit creates an immediate prompt for the other to maintain consistency."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'metas' within the same test method. Edit 0 changes the data structure of 'metas' from a tuple (parentheses) to a list (square brackets), and Edit 1 updates the assertion logic that operates on this same 'metas' variable by changing the expected length calculation from 'len(meta) - 1' to 'len(meta) - 2'. The comment change in Edit 1 also reflects this structural change. Since both edits operate on the same symbol within the same function scope and either edit could be made first (both are syntactically valid regardless of order), this represents a bi-directional relationship where making either edit creates an immediate prompt for the other to maintain consistency."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Both edits modify the same loop variable 'i' within the same function and are part of a coordinated change to shift the indexing pattern. Edit 0 changes the range start from 1 to 2, and Edit 1 adjusts the corresponding array access from 'i-1' to 'i-2' to maintain the same relative indexing relationship. The changed lines in both edits reference the exact same symbol 'i' and form a synchronized modification where changing one naturally prompts the need to change the other to maintain consistent indexing logic."
        },
        {
            "src": 8,
            "tgt": 7,
            "reason": "Both edits modify the same loop variable 'i' within the same function and are part of a coordinated change to shift the indexing pattern. Edit 0 changes the range start from 1 to 2, and Edit 1 adjusts the corresponding array access from 'i-1' to 'i-2' to maintain the same relative indexing relationship. The changed lines in both edits reference the exact same symbol 'i' and form a synchronized modification where changing one naturally prompts the need to change the other to maintain consistent indexing logic."
        },
        {
            "src": 6,
            "tgt": 8,
            "reason": "Both edits are making synchronized adjustments to the same test logic within the same test method. Edit 0 changes the offset from -1 to -2 in the assertion comparing lengths, while Edit 1 changes the corresponding array indexing from i-1 to i-2. These changes are part of the same logical adjustment to account for an additional meta tag being excluded from the comparison. The edits reference the same conceptual offset value and are mechanically linked as part of a single coherent change to the test's indexing logic."
        },
        {
            "src": 8,
            "tgt": 6,
            "reason": "Both edits are making synchronized adjustments to the same test logic within the same test method. Edit 0 changes the offset from -1 to -2 in the assertion comparing lengths, while Edit 1 changes the corresponding array indexing from i-1 to i-2. These changes are part of the same logical adjustment to account for an additional meta tag being excluded from the comparison. The edits reference the same conceptual offset value and are mechanically linked as part of a single coherent change to the test's indexing logic."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits are making synchronized changes to the same test method, adjusting the logic from excluding 1 meta tag to excluding 2 meta tags. Edit 0 changes the assertion to subtract 2 instead of 1, and Edit 1 changes the loop to start from index 2 instead of 1. These changes are part of the same logical modification - updating the test to account for an additional meta tag that should be excluded. The changes reference the same conceptual elements (the meta array and the exclusion count) and are mechanically linked as part of a single coherent test logic update. Either edit could be made first, and after making either one, the other becomes the immediate next step to maintain test consistency."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits are making synchronized changes to the same test method, adjusting the logic from excluding 1 meta tag to excluding 2 meta tags. Edit 0 changes the assertion to subtract 2 instead of 1, and Edit 1 changes the loop to start from index 2 instead of 1. These changes are part of the same logical modification - updating the test to account for an additional meta tag that should be excluded. The changes reference the same conceptual elements (the meta array and the exclusion count) and are mechanically linked as part of a single coherent test logic update. Either edit could be made first, and after making either one, the other becomes the immediate next step to maintain test consistency."
        }
    ],
    "allowed_init_edits": [
        0,
        2,
        3,
        5
    ]
}