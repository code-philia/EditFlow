{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to different polynomial test files. They perform the exact same textual substitution pattern - adding three assert_raises calls with identical parameter patterns - and target the same type of syntactic construct (test assertion lines). This represents a bulk uniform substitution across related test files that would naturally be done as part of a single, contiguous refactor to add consistent parameter validation tests across polynomial modules."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to different polynomial test files. They perform the exact same textual substitution pattern - adding three assert_raises calls with identical parameter patterns - and target the same type of syntactic construct (test assertion lines). This represents a bulk uniform substitution across related test files that would naturally be done as part of a single, contiguous refactor to add consistent parameter validation tests across polynomial modules."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to test similar polynomial integration functions (herm.hermint vs leg.legint). This represents a bulk-edit pattern where the same testing logic is being applied uniformly across different polynomial modules. The edits perform identical structural substitutions (adding the same three assert_raises lines) to the same type of syntactic construct (test methods for polynomial integration functions). This appears to be part of a single, contiguous refactor to add consistent parameter validation tests across polynomial modules."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to test similar polynomial integration functions (herm.hermint vs leg.legint). This represents a bulk-edit pattern where the same testing logic is being applied uniformly across different polynomial modules. The edits perform identical structural substitutions (adding the same three assert_raises lines) to the same type of syntactic construct (test methods for polynomial integration functions). This appears to be part of a single, contiguous refactor to add consistent parameter validation tests across polynomial modules."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to test ValueError conditions for integration functions. This represents a bulk-edit pattern where the same testing logic is being synchronized across different polynomial modules. The edits perform identical textual substitutions (adding the same three assert_raises lines) and target the same type of syntactic construct (test assertions within TestIntegral classes). This is clearly part of a single, contiguous refactor to add consistent error checking tests across polynomial modules."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to test ValueError conditions for integration functions. This represents a bulk-edit pattern where the same testing logic is being synchronized across different polynomial modules. The edits perform identical textual substitutions (adding the same three assert_raises lines) and target the same type of syntactic construct (test assertions within TestIntegral classes). This is clearly part of a single, contiguous refactor to add consistent error checking tests across polynomial modules."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to test similar integration functions (hermeint vs lagint) in different polynomial test files. This represents a bulk-edit pattern where the same testing logic is being synchronized across multiple polynomial modules. The edits perform identical textual substitutions (adding the same three assert_raises lines) and target the same type of syntactic construct (test assertions within integration test methods). This appears to be part of a single, contiguous refactor to add consistent parameter validation tests across polynomial modules."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to test similar integration functions (hermeint vs lagint) in different polynomial test files. This represents a bulk-edit pattern where the same testing logic is being synchronized across multiple polynomial modules. The edits perform identical textual substitutions (adding the same three assert_raises lines) and target the same type of syntactic construct (test assertions within integration test methods). This appears to be part of a single, contiguous refactor to add consistent parameter validation tests across polynomial modules."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to test ValueError conditions. They follow the exact same pattern of adding three assert_raises calls with identical parameter patterns, just targeting different polynomial integration functions (cheb.chebint vs herm.hermint). This represents a bulk-edit pattern where the same testing logic is being applied uniformly across different but related polynomial modules. The edits are structurally identical substitutions targeting the same type of syntactic construct (test assertions) and appear to be part of a single, contiguous refactoring effort to add consistent error handling tests across polynomial types."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to test ValueError conditions. They follow the exact same pattern of adding three assert_raises calls with identical parameter patterns, just targeting different polynomial integration functions (cheb.chebint vs herm.hermint). This represents a bulk-edit pattern where the same testing logic is being applied uniformly across different but related polynomial modules. The edits are structurally identical substitutions targeting the same type of syntactic construct (test assertions) and appear to be part of a single, contiguous refactoring effort to add consistent error handling tests across polynomial types."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to test similar polynomial integration functions (lag.lagint vs leg.legint). This represents a bulk-edit pattern where the same testing logic is being applied uniformly across different but related polynomial modules. The edits perform identical textual substitutions (adding the same three assert_raises lines) and target the same type of syntactic construct (test assertion calls within integration test methods). This appears to be part of a single, contiguous refactor to add consistent parameter validation tests across polynomial modules."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits add identical test assertions with the same structure and parameters (lbnd=[0], scl=[0], axis=.5) to test similar polynomial integration functions (lag.lagint vs leg.legint). This represents a bulk-edit pattern where the same testing logic is being applied uniformly across different but related polynomial modules. The edits perform identical textual substitutions (adding the same three assert_raises lines) and target the same type of syntactic construct (test assertion calls within integration test methods). This appears to be part of a single, contiguous refactor to add consistent parameter validation tests across polynomial modules."
        }
    ],
    "allowed_init_edits": [
        5
    ]
}