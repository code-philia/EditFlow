{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils, and Edit 1 uses that exact same imported symbol DOCKER_COMPOSE_COMMAND in the changed line. The import creates the symbol availability, and the usage references that exact same symbol. This creates an immediate code dependency where importing the symbol enables its usage in the function."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils, and Edit 1 uses that exact same imported symbol DOCKER_COMPOSE_COMMAND in the changed line. The import creates the symbol availability, and the usage references that exact same symbol. This creates an immediate code dependency where importing the symbol enables its usage in the function."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command list construction. This is a uniform bulk substitution targeting the same type of syntactic construct (command list initialization) across multiple locations in the same file. Both changed lines reference the exact same symbol (DOCKER_COMPOSE_COMMAND) and represent a single, contiguous refactoring operation to standardize docker-compose command usage."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command list construction. This is a uniform bulk substitution targeting the same type of syntactic construct (command list initialization) across multiple locations in the same file. Both changed lines reference the exact same symbol (DOCKER_COMPOSE_COMMAND) and represent a single, contiguous refactoring operation to standardize docker-compose command usage."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command list construction. This is a uniform bulk substitution targeting the same type of syntactic construct (command list initialization) across multiple locations in the same file. Both edits are part of a single refactoring operation to standardize how docker-compose commands are constructed, making them mechanically linked through the identical substitution pattern."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command list construction. This is a uniform bulk substitution targeting the same type of syntactic construct (command list initialization) across multiple locations in the same file. Both edits are part of a single refactoring operation to standardize how docker-compose commands are constructed, making them mechanically linked through the identical substitution pattern."
        },
        {
            "src": 0,
            "tgt": 7,
            "reason": "Edit 1 defines the symbol DOCKER_COMPOSE_COMMAND in docker_command_utils.py, while Edit 0 imports that exact same symbol from the same module. This creates a direct definition-usage relationship where both edits reference the exact same symbol. In Python, imports can be written before the symbol is defined (resulting in a runtime ImportError rather than a parse error), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the definition-import pair."
        },
        {
            "src": 7,
            "tgt": 0,
            "reason": "Edit 1 defines the symbol DOCKER_COMPOSE_COMMAND in docker_command_utils.py, while Edit 0 imports that exact same symbol from the same module. This creates a direct definition-usage relationship where both edits reference the exact same symbol. In Python, imports can be written before the symbol is defined (resulting in a runtime ImportError rather than a parse error), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the definition-import pair."
        },
        {
            "src": 0,
            "tgt": 8,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from docker_command_utils.py, and Edit 1 uses that exact same symbol (DOCKER_COMPOSE_COMMAND) in its changed lines by calling .clear() and .extend() methods on it. This creates a direct definition-usage relationship where the imported symbol in Edit 0 is the same symbol being modified in Edit 1. Both edits reference the exact same symbol, making this a bi-directional relationship since either edit can be staged first and the other would be the natural next step in the development flow."
        },
        {
            "src": 8,
            "tgt": 0,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from docker_command_utils.py, and Edit 1 uses that exact same symbol (DOCKER_COMPOSE_COMMAND) in its changed lines by calling .clear() and .extend() methods on it. This creates a direct definition-usage relationship where the imported symbol in Edit 0 is the same symbol being modified in Edit 1. Both edits reference the exact same symbol, making this a bi-directional relationship since either edit can be staged first and the other would be the natural next step in the development flow."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits add the exact same import 'DOCKER_COMPOSE_COMMAND' to existing import statements from the same module 'airflow_breeze.utils.docker_command_utils'. This represents a bulk-edit pattern where the same symbol is being imported in multiple files as part of a single refactoring operation. The edits perform identical textual substitution (adding the same import line) on the same type of syntactic construct (import statements from the same module). Either edit can be made first, and both are part of the same contiguous micro-task of adding this import across multiple files."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits add the exact same import 'DOCKER_COMPOSE_COMMAND' to existing import statements from the same module 'airflow_breeze.utils.docker_command_utils'. This represents a bulk-edit pattern where the same symbol is being imported in multiple files as part of a single refactoring operation. The edits perform identical textual substitution (adding the same import line) on the same type of syntactic construct (import statements from the same module). Either edit can be made first, and both are part of the same contiguous micro-task of adding this import across multiple files."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils, and Edit 1 uses that exact same imported symbol DOCKER_COMPOSE_COMMAND in a command construction. The changed line in Edit 1 directly references the symbol that was imported in Edit 0. This creates an immediate code dependency where importing the symbol naturally prompts its usage, and both edits reference the exact same symbol. Either edit can be staged first - the import can exist without usage, and the usage would create a NameError at runtime (not a parse error) if the import doesn't exist yet."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils, and Edit 1 uses that exact same imported symbol DOCKER_COMPOSE_COMMAND in a command construction. The changed line in Edit 1 directly references the symbol that was imported in Edit 0. This creates an immediate code dependency where importing the symbol naturally prompts its usage, and both edits reference the exact same symbol. Either edit can be staged first - the import can exist without usage, and the usage would create a NameError at runtime (not a parse error) if the import doesn't exist yet."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Edit 0 adds DOCKER_COMPOSE_COMMAND to the imports in developer_commands.py, while Edit 1 uses DOCKER_COMPOSE_COMMAND to replace a hardcoded 'docker-compose' command in testing_commands.py. These edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND) and represent a definition-usage relationship where the import makes the symbol available and the usage consumes it. This is a bi-directional relationship because either edit can be staged first - the import can exist without immediate usage, and the usage would only fail at runtime (ImportError) if the import doesn't exist, not at parse time."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Edit 0 adds DOCKER_COMPOSE_COMMAND to the imports in developer_commands.py, while Edit 1 uses DOCKER_COMPOSE_COMMAND to replace a hardcoded 'docker-compose' command in testing_commands.py. These edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND) and represent a definition-usage relationship where the import makes the symbol available and the usage consumes it. This is a bi-directional relationship because either edit can be staged first - the import can exist without immediate usage, and the usage would only fail at runtime (ImportError) if the import doesn't exist, not at parse time."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 changes a line to use DOCKER_COMPOSE_COMMAND (line 472), while Edit 1 adds an import for DOCKER_COMPOSE_COMMAND (line 52). These edits reference the exact same symbol - DOCKER_COMPOSE_COMMAND. Edit 1 imports the symbol that Edit 0 uses. In Python, imports can be added before or after usage since undefined name errors only occur at runtime, not parse time. Both edits can be staged in either order without causing parser errors. After making either edit, the other becomes the immediate next step to complete the symbol reference relationship."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 changes a line to use DOCKER_COMPOSE_COMMAND (line 472), while Edit 1 adds an import for DOCKER_COMPOSE_COMMAND (line 52). These edits reference the exact same symbol - DOCKER_COMPOSE_COMMAND. Edit 1 imports the symbol that Edit 0 uses. In Python, imports can be added before or after usage since undefined name errors only occur at runtime, not parse time. Both edits can be staged in either order without causing parser errors. After making either edit, the other becomes the immediate next step to complete the symbol reference relationship."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils, and Edit 1 uses that exact same symbol DOCKER_COMPOSE_COMMAND in the changed line to replace the hardcoded 'docker-compose' string. The import makes the symbol available, and the usage references the exact same imported symbol. This creates an immediate code dependency where importing the symbol naturally prompts its usage as the next step, and using the symbol requires it to be imported first. Both edits reference the exact same symbol and form a definition-usage relationship within the same file."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils, and Edit 1 uses that exact same symbol DOCKER_COMPOSE_COMMAND in the changed line to replace the hardcoded 'docker-compose' string. The import makes the symbol available, and the usage references the exact same imported symbol. This creates an immediate code dependency where importing the symbol naturally prompts its usage as the next step, and using the symbol requires it to be imported first. Both edits reference the exact same symbol and form a definition-usage relationship within the same file."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command construction. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (command list construction) across different files. Both edits are part of a single, contiguous refactor to standardize docker-compose command usage throughout the codebase. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command construction. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (command list construction) across different files. Both edits are part of a single, contiguous refactor to standardize docker-compose command usage throughout the codebase. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command construction lines. This is a uniform bulk substitution targeting the same type of syntactic construct (command list construction) across multiple files. Both edits are part of the same refactoring effort to standardize docker-compose command usage, and either edit can be made independently without creating a code dependency on the other. The changes are synchronized and mirrored, making this a bi-directional relationship."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command construction lines. This is a uniform bulk substitution targeting the same type of syntactic construct (command list construction) across multiple files. Both edits are part of the same refactoring effort to standardize docker-compose command usage, and either edit can be made independently without creating a code dependency on the other. The changes are synchronized and mirrored, making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 uses DOCKER_COMPOSE_COMMAND in a list unpacking operation ([*DOCKER_COMPOSE_COMMAND, ...]) while Edit 1 imports DOCKER_COMPOSE_COMMAND. These edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils). Edit 0 cannot function without the import in Edit 1, as using an undefined symbol would cause a NameError at runtime. However, in Python, both edits can be written and parsed in either order - the usage before import only fails at runtime/import time, not at parse time. This makes it a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 uses DOCKER_COMPOSE_COMMAND in a list unpacking operation ([*DOCKER_COMPOSE_COMMAND, ...]) while Edit 1 imports DOCKER_COMPOSE_COMMAND. These edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils). Edit 0 cannot function without the import in Edit 1, as using an undefined symbol would cause a NameError at runtime. However, in Python, both edits can be written and parsed in either order - the usage before import only fails at runtime/import time, not at parse time. This makes it a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "Edit 1 defines the DOCKER_COMPOSE_COMMAND variable, and Edit 0 uses that exact same variable in its changed line. This creates a direct definition-usage relationship where the symbol defined in Edit 1 is immediately referenced in Edit 0. However, since this is Python, the usage in Edit 0 can be written and parsed even before the definition exists (it would only fail at runtime with a NameError). Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "Edit 1 defines the DOCKER_COMPOSE_COMMAND variable, and Edit 0 uses that exact same variable in its changed line. This creates a direct definition-usage relationship where the symbol defined in Edit 1 is immediately referenced in Edit 0. However, since this is Python, the usage in Edit 0 can be written and parsed even before the definition exists (it would only fail at runtime with a NameError). Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded list ['docker-compose', ...] with [*DOCKER_COMPOSE_COMMAND, ...]. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (command list construction) in both locations. Both changed lines reference the exact same symbol DOCKER_COMPOSE_COMMAND and represent a synchronized bulk edit to standardize docker-compose command construction across the codebase."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded list ['docker-compose', ...] with [*DOCKER_COMPOSE_COMMAND, ...]. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (command list construction) in both locations. Both changed lines reference the exact same symbol DOCKER_COMPOSE_COMMAND and represent a synchronized bulk edit to standardize docker-compose command construction across the codebase."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded list ['docker-compose', ...] with [*DOCKER_COMPOSE_COMMAND, ...]. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (list construction for docker-compose commands) across different files. Both changed lines reference the same symbol DOCKER_COMPOSE_COMMAND and perform the identical structural transformation. This represents a bulk edit/pattern synchronization where either edit could be made first as part of the same contiguous refactoring task."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded list ['docker-compose', ...] with [*DOCKER_COMPOSE_COMMAND, ...]. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (list construction for docker-compose commands) across different files. Both changed lines reference the same symbol DOCKER_COMPOSE_COMMAND and perform the identical structural transformation. This represents a bulk edit/pattern synchronization where either edit could be made first as part of the same contiguous refactoring task."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded list ['docker-compose', ...] with [*DOCKER_COMPOSE_COMMAND, ...]. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (list construction with docker-compose commands) across different files. Both changed lines reference the same symbol DOCKER_COMPOSE_COMMAND and perform the identical structural transformation. This represents a bulk edit/pattern synchronization where either edit could be made first as part of the same contiguous refactoring task."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded list ['docker-compose', ...] with [*DOCKER_COMPOSE_COMMAND, ...]. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (list construction with docker-compose commands) across different files. Both changed lines reference the same symbol DOCKER_COMPOSE_COMMAND and perform the identical structural transformation. This represents a bulk edit/pattern synchronization where either edit could be made first as part of the same contiguous refactoring task."
        },
        {
            "src": 1,
            "tgt": 8,
            "reason": "Edit 0 changes from using hardcoded 'docker-compose' to using DOCKER_COMPOSE_COMMAND variable, while Edit 1 modifies the DOCKER_COMPOSE_COMMAND variable by clearing it and extending it with ['docker', 'compose']. Both edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND) - Edit 0 uses it in the command construction, and Edit 1 modifies its contents. This creates a direct code dependency where either edit can be made first, and after making either edit, the other becomes a natural next step in ensuring the DOCKER_COMPOSE_COMMAND variable is properly configured and used consistently."
        },
        {
            "src": 8,
            "tgt": 1,
            "reason": "Edit 0 changes from using hardcoded 'docker-compose' to using DOCKER_COMPOSE_COMMAND variable, while Edit 1 modifies the DOCKER_COMPOSE_COMMAND variable by clearing it and extending it with ['docker', 'compose']. Both edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND) - Edit 0 uses it in the command construction, and Edit 1 modifies its contents. This creates a direct code dependency where either edit can be made first, and after making either edit, the other becomes a natural next step in ensuring the DOCKER_COMPOSE_COMMAND variable is properly configured and used consistently."
        },
        {
            "src": 2,
            "tgt": 8,
            "reason": "Edit 0 uses DOCKER_COMPOSE_COMMAND in a list unpacking operation (*DOCKER_COMPOSE_COMMAND), while Edit 1 modifies DOCKER_COMPOSE_COMMAND by clearing and extending it. These edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND) and have a direct code dependency - Edit 0's usage of DOCKER_COMPOSE_COMMAND depends on it being properly initialized/modified by Edit 1. However, both edits can be written and parsed independently without syntax errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 8,
            "tgt": 2,
            "reason": "Edit 0 uses DOCKER_COMPOSE_COMMAND in a list unpacking operation (*DOCKER_COMPOSE_COMMAND), while Edit 1 modifies DOCKER_COMPOSE_COMMAND by clearing and extending it. These edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND) and have a direct code dependency - Edit 0's usage of DOCKER_COMPOSE_COMMAND depends on it being properly initialized/modified by Edit 1. However, both edits can be written and parsed independently without syntax errors, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Edit 1 defines the DOCKER_COMPOSE_COMMAND variable as a list containing 'docker-compose', while Edit 0 uses this exact same symbol by unpacking it with the spread operator (*DOCKER_COMPOSE_COMMAND) to replace the hardcoded 'docker-compose' string. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. After defining DOCKER_COMPOSE_COMMAND in Edit 1, Edit 0 becomes the immediate next step to use this newly defined constant. Since Python allows referencing undefined variables at parse time (only failing at runtime), either edit can be staged first, making this a bi-directional relationship."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Edit 1 defines the DOCKER_COMPOSE_COMMAND variable as a list containing 'docker-compose', while Edit 0 uses this exact same symbol by unpacking it with the spread operator (*DOCKER_COMPOSE_COMMAND) to replace the hardcoded 'docker-compose' string. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. After defining DOCKER_COMPOSE_COMMAND in Edit 1, Edit 0 becomes the immediate next step to use this newly defined constant. Since Python allows referencing undefined variables at parse time (only failing at runtime), either edit can be staged first, making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command list construction. This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (command list initialization) across different files. Both changed lines reference the same symbol DOCKER_COMPOSE_COMMAND and follow the identical substitution pattern, making this a synchronized multi-file refactor where either edit could be made first as part of the same contiguous task."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command list construction. This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (command list initialization) across different files. Both changed lines reference the same symbol DOCKER_COMPOSE_COMMAND and follow the identical substitution pattern, making this a synchronized multi-file refactor where either edit could be made first as part of the same contiguous task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils, and Edit 1 uses that exact same imported symbol DOCKER_COMPOSE_COMMAND in the changed line. This creates a direct definition-usage relationship where the import makes the symbol available for use in the same file. Both edits reference the exact same symbol, and after making either edit, the other becomes the immediate next step to complete the functionality."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils, and Edit 1 uses that exact same imported symbol DOCKER_COMPOSE_COMMAND in the changed line. This creates a direct definition-usage relationship where the import makes the symbol available for use in the same file. Both edits reference the exact same symbol, and after making either edit, the other becomes the immediate next step to complete the functionality."
        },
        {
            "src": 4,
            "tgt": 8,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from docker_command_utils.py, and Edit 1 modifies that exact same DOCKER_COMPOSE_COMMAND symbol by clearing it and extending it with new values. The changed lines reference the exact same symbol - DOCKER_COMPOSE_COMMAND. After importing it in Edit 0, the symbol becomes available for use, and Edit 1 modifies that imported symbol. This creates a direct code dependency where both edits reference the same symbol, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 8,
            "tgt": 4,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from docker_command_utils.py, and Edit 1 modifies that exact same DOCKER_COMPOSE_COMMAND symbol by clearing it and extending it with new values. The changed lines reference the exact same symbol - DOCKER_COMPOSE_COMMAND. After importing it in Edit 0, the symbol becomes available for use, and Edit 1 modifies that imported symbol. This creates a direct code dependency where both edits reference the same symbol, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "Edit 1 defines the DOCKER_COMPOSE_COMMAND constant as a list containing 'docker-compose', while Edit 0 uses this exact same symbol by unpacking it with the spread operator (*DOCKER_COMPOSE_COMMAND) to replace the hardcoded ['docker-compose'] list. The changed line in Edit 0 directly references the symbol being defined in Edit 1. This creates an immediate code dependency where defining the constant naturally prompts its usage, and using the constant requires its definition. Both edits can be staged in either order since Python allows referencing undefined names at parse time (only failing at runtime), making this a bi-directional relationship."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "Edit 1 defines the DOCKER_COMPOSE_COMMAND constant as a list containing 'docker-compose', while Edit 0 uses this exact same symbol by unpacking it with the spread operator (*DOCKER_COMPOSE_COMMAND) to replace the hardcoded ['docker-compose'] list. The changed line in Edit 0 directly references the symbol being defined in Edit 1. This creates an immediate code dependency where defining the constant naturally prompts its usage, and using the constant requires its definition. Both edits can be staged in either order since Python allows referencing undefined names at parse time (only failing at runtime), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command list construction. This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (command list initialization) across multiple files. Both edits reference the same symbol DOCKER_COMPOSE_COMMAND and represent part of a single, contiguous refactor to standardize docker-compose command usage. Either edit could be made first, and after making either, the other would be a natural continuation of the same refactoring pattern."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: replacing 'docker-compose' with '*DOCKER_COMPOSE_COMMAND' in command list construction. This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (command list initialization) across multiple files. Both edits reference the same symbol DOCKER_COMPOSE_COMMAND and represent part of a single, contiguous refactor to standardize docker-compose command usage. Either edit could be made first, and after making either, the other would be a natural continuation of the same refactoring pattern."
        },
        {
            "src": 3,
            "tgt": 8,
            "reason": "Edit 0 uses DOCKER_COMPOSE_COMMAND in a list unpacking operation ([*DOCKER_COMPOSE_COMMAND, ...]), while Edit 1 modifies DOCKER_COMPOSE_COMMAND by clearing it and extending it with new values. These edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND) and have a direct code dependency - Edit 0's usage of DOCKER_COMPOSE_COMMAND depends on the symbol being properly defined and populated, which Edit 1 ensures by setting its contents. However, both edits can be staged in either order without causing parse errors, as DOCKER_COMPOSE_COMMAND would be defined (though potentially empty or with different contents). The relationship is bi-directional because either edit creates an immediate prompt for the other as part of the same refactoring task."
        },
        {
            "src": 8,
            "tgt": 3,
            "reason": "Edit 0 uses DOCKER_COMPOSE_COMMAND in a list unpacking operation ([*DOCKER_COMPOSE_COMMAND, ...]), while Edit 1 modifies DOCKER_COMPOSE_COMMAND by clearing it and extending it with new values. These edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND) and have a direct code dependency - Edit 0's usage of DOCKER_COMPOSE_COMMAND depends on the symbol being properly defined and populated, which Edit 1 ensures by setting its contents. However, both edits can be staged in either order without causing parse errors, as DOCKER_COMPOSE_COMMAND would be defined (though potentially empty or with different contents). The relationship is bi-directional because either edit creates an immediate prompt for the other as part of the same refactoring task."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils, and Edit 1 uses that exact same imported symbol DOCKER_COMPOSE_COMMAND in a command construction. The changed lines reference the exact same symbol - Edit 0 adds it to the import statement, and Edit 1 uses it to replace a hardcoded 'docker-compose' string. This creates an immediate code dependency where importing the symbol naturally prompts its usage as the next step, and both edits can be staged in either order since Python allows referencing imported symbols regardless of order (would only cause a runtime NameError, not a parse error)."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 imports DOCKER_COMPOSE_COMMAND from airflow_breeze.utils.docker_command_utils, and Edit 1 uses that exact same imported symbol DOCKER_COMPOSE_COMMAND in a command construction. The changed lines reference the exact same symbol - Edit 0 adds it to the import statement, and Edit 1 uses it to replace a hardcoded 'docker-compose' string. This creates an immediate code dependency where importing the symbol naturally prompts its usage as the next step, and both edits can be staged in either order since Python allows referencing imported symbols regardless of order (would only cause a runtime NameError, not a parse error)."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Edit 1 defines the symbol DOCKER_COMPOSE_COMMAND in docker_command_utils.py, while Edit 0 imports that exact same symbol from the same module. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. In Python, imports can be written before their definitions are present (resulting in only a runtime ImportError, not a parse error), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the definition-import pair."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Edit 1 defines the symbol DOCKER_COMPOSE_COMMAND in docker_command_utils.py, while Edit 0 imports that exact same symbol from the same module. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. In Python, imports can be written before their definitions are present (resulting in only a runtime ImportError, not a parse error), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the definition-import pair."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Edit 1 defines the DOCKER_COMPOSE_COMMAND variable as a list containing 'docker-compose', and Edit 0 uses this exact same symbol by unpacking it with the spread operator (*DOCKER_COMPOSE_COMMAND) to replace the hardcoded 'docker-compose' string. The changed lines reference the exact same symbol - DOCKER_COMPOSE_COMMAND. After defining the variable in Edit 1, using it in Edit 0 becomes the immediate next step to replace the hardcoded value. Since Python allows referencing undefined variables at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Edit 1 defines the DOCKER_COMPOSE_COMMAND variable as a list containing 'docker-compose', and Edit 0 uses this exact same symbol by unpacking it with the spread operator (*DOCKER_COMPOSE_COMMAND) to replace the hardcoded 'docker-compose' string. The changed lines reference the exact same symbol - DOCKER_COMPOSE_COMMAND. After defining the variable in Edit 1, using it in Edit 0 becomes the immediate next step to replace the hardcoded value. Since Python allows referencing undefined variables at parse time (only failing at runtime), either edit can be staged first, making this bi-directional."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded list ['docker-compose', 'run', '--service-ports', '--rm', 'airflow'] with [*DOCKER_COMPOSE_COMMAND, 'run', '--service-ports', '--rm', 'airflow']. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (list construction) in both locations. The edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND) and represent a single, contiguous refactor to replace hardcoded docker-compose commands with a configurable constant. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded list ['docker-compose', 'run', '--service-ports', '--rm', 'airflow'] with [*DOCKER_COMPOSE_COMMAND, 'run', '--service-ports', '--rm', 'airflow']. This is a uniform refactoring operation where the same before\u2192after pattern is applied to the same type of syntactic construct (list construction) in both locations. The edits reference the exact same symbol (DOCKER_COMPOSE_COMMAND) and represent a single, contiguous refactor to replace hardcoded docker-compose commands with a configurable constant. Either edit can be made first, and after making either one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 5,
            "tgt": 8,
            "reason": "Edit 0 uses DOCKER_COMPOSE_COMMAND in a command construction, while Edit 1 modifies DOCKER_COMPOSE_COMMAND by clearing and extending it. However, these edits reference the same global variable DOCKER_COMPOSE_COMMAND but in different files and contexts. Edit 0 is consuming/using the variable, while Edit 1 is modifying its contents. The changed lines reference the exact same symbol (DOCKER_COMPOSE_COMMAND), and there's a direct code dependency where Edit 1's modification of the command list affects Edit 0's usage of that same list. This creates an immediate, mechanically obvious relationship where modifying the command structure (Edit 1) directly impacts how it's used in command construction (Edit 0)."
        },
        {
            "src": 8,
            "tgt": 5,
            "reason": "Edit 0 uses DOCKER_COMPOSE_COMMAND in a command construction, while Edit 1 modifies DOCKER_COMPOSE_COMMAND by clearing and extending it. However, these edits reference the same global variable DOCKER_COMPOSE_COMMAND but in different files and contexts. Edit 0 is consuming/using the variable, while Edit 1 is modifying its contents. The changed lines reference the exact same symbol (DOCKER_COMPOSE_COMMAND), and there's a direct code dependency where Edit 1's modification of the command list affects Edit 0's usage of that same list. This creates an immediate, mechanically obvious relationship where modifying the command structure (Edit 1) directly impacts how it's used in command construction (Edit 0)."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 1 defines the DOCKER_COMPOSE_COMMAND variable as a list containing 'docker-compose', and Edit 0 uses this exact same symbol by referencing it in the command construction. The changed line in Edit 0 explicitly references DOCKER_COMPOSE_COMMAND using the spread operator (*DOCKER_COMPOSE_COMMAND), creating a direct code dependency. After defining DOCKER_COMPOSE_COMMAND in Edit 1, using it in Edit 0 becomes the immediate next step. However, since this is Python and the usage in Edit 0 would only fail at runtime (NameError) if DOCKER_COMPOSE_COMMAND is not defined, both edits can be parsed and staged in either order. The relationship is bi-directional because both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 1 defines the DOCKER_COMPOSE_COMMAND variable as a list containing 'docker-compose', and Edit 0 uses this exact same symbol by referencing it in the command construction. The changed line in Edit 0 explicitly references DOCKER_COMPOSE_COMMAND using the spread operator (*DOCKER_COMPOSE_COMMAND), creating a direct code dependency. After defining DOCKER_COMPOSE_COMMAND in Edit 1, using it in Edit 0 becomes the immediate next step. However, since this is Python and the usage in Edit 0 would only fail at runtime (NameError) if DOCKER_COMPOSE_COMMAND is not defined, both edits can be parsed and staged in either order. The relationship is bi-directional because both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 8,
            "reason": "Edit 0 uses the DOCKER_COMPOSE_COMMAND variable by unpacking it in a command list (*DOCKER_COMPOSE_COMMAND), while Edit 1 modifies the contents of that same DOCKER_COMPOSE_COMMAND variable by clearing it and extending it with new values. The changed lines reference the exact same symbol (DOCKER_COMPOSE_COMMAND), creating a direct code dependency where Edit 1 sets up the command that Edit 0 uses. However, both edits can be staged in either order without causing parse errors - Edit 0 would simply use whatever current value DOCKER_COMPOSE_COMMAND has, and Edit 1 would modify it. This represents a bi-directional relationship where either edit naturally prompts consideration of the other as they both work with the same symbol."
        },
        {
            "src": 8,
            "tgt": 6,
            "reason": "Edit 0 uses the DOCKER_COMPOSE_COMMAND variable by unpacking it in a command list (*DOCKER_COMPOSE_COMMAND), while Edit 1 modifies the contents of that same DOCKER_COMPOSE_COMMAND variable by clearing it and extending it with new values. The changed lines reference the exact same symbol (DOCKER_COMPOSE_COMMAND), creating a direct code dependency where Edit 1 sets up the command that Edit 0 uses. However, both edits can be staged in either order without causing parse errors - Edit 0 would simply use whatever current value DOCKER_COMPOSE_COMMAND has, and Edit 1 would modify it. This represents a bi-directional relationship where either edit naturally prompts consideration of the other as they both work with the same symbol."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Edit 0 defines the DOCKER_COMPOSE_COMMAND variable as a list containing ['docker-compose'], while Edit 1 uses this exact same variable by calling .clear() and .extend() methods on it. The changed lines in both edits reference the exact same symbol DOCKER_COMPOSE_COMMAND. After defining the variable in Edit 0, Edit 1 becomes the immediate next step to modify its contents. This is a classic definition-usage pattern where both edits can be staged in either order (the variable can be defined and then modified, or the modification code can exist before the definition since Python allows referencing undefined variables at parse time)."
        },
        {
            "src": 8,
            "tgt": 7,
            "reason": "Edit 0 defines the DOCKER_COMPOSE_COMMAND variable as a list containing ['docker-compose'], while Edit 1 uses this exact same variable by calling .clear() and .extend() methods on it. The changed lines in both edits reference the exact same symbol DOCKER_COMPOSE_COMMAND. After defining the variable in Edit 0, Edit 1 becomes the immediate next step to modify its contents. This is a classic definition-usage pattern where both edits can be staged in either order (the variable can be defined and then modified, or the modification code can exist before the definition since Python allows referencing undefined variables at parse time)."
        }
    ],
    "allowed_init_edits": [
        0,
        3,
        4,
        5
    ]
}