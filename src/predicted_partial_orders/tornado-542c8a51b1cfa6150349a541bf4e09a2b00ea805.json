{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits change the exception type from AssertionError to ValueError for the same error condition. Edit 0 changes the production code that raises the exception, while Edit 1 updates the corresponding test that expects this exception. The test is specifically testing the behavior implemented in the production code - they reference the exact same error condition and exception type. This creates a direct code dependency where changing the exception type in production requires updating the test assertion to match."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits change the exception type from AssertionError to ValueError for the same error condition. Edit 0 changes the production code that raises the exception, while Edit 1 updates the corresponding test that expects this exception. The test is specifically testing the behavior implemented in the production code - they reference the exact same error condition and exception type. This creates a direct code dependency where changing the exception type in production requires updating the test assertion to match."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits change the exception type from AssertionError to ValueError for the same error condition. Edit 0 changes the exception being raised in the production code when a GET request has a body, and Edit 1 updates the corresponding test to expect the new ValueError exception type instead of AssertionError. The test is directly asserting on the exact same exception that the production code raises, creating a direct code dependency where both edits reference the same error condition and exception handling."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits change the exception type from AssertionError to ValueError for the same error condition. Edit 0 changes the exception being raised in the production code when a GET request has a body, and Edit 1 updates the corresponding test to expect the new ValueError exception type instead of AssertionError. The test is directly asserting on the exact same exception that the production code raises, creating a direct code dependency where both edits reference the same error condition and exception handling."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits change the same exception type from AssertionError to ValueError. Edit 0 changes the exception being raised in the production code, while Edit 1 updates the corresponding test to expect the new exception type. The test is specifically testing the behavior that raises this exception, creating a direct test-production synchronization where both edits reference the exact same error condition. After making either edit, the other becomes immediately necessary to maintain test-code consistency."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits change the same exception type from AssertionError to ValueError. Edit 0 changes the exception being raised in the production code, while Edit 1 updates the corresponding test to expect the new exception type. The test is specifically testing the behavior that raises this exception, creating a direct test-production synchronization where both edits reference the exact same error condition. After making either edit, the other becomes immediately necessary to maintain test-code consistency."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 changes an error message from 'Body must not be empty' to 'Body must not be None' in the production code. Edit 1 updates the corresponding test assertion to check for the new error message text 'must be None' instead of 'must be empty'. These edits reference the exact same error message content - the test is directly asserting on the specific error message text that was changed in the production code. This creates a direct, mechanical dependency where changing the error message in production immediately requires updating the test that validates that specific message."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 changes an error message from 'Body must not be empty' to 'Body must not be None' in the production code. Edit 1 updates the corresponding test assertion to check for the new error message text 'must be None' instead of 'must be empty'. These edits reference the exact same error message content - the test is directly asserting on the specific error message text that was changed in the production code. This creates a direct, mechanical dependency where changing the error message in production immediately requires updating the test that validates that specific message."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform identical structural substitutions within the same function: changing 'AssertionError' to 'ValueError' and updating the error message from 'empty' to 'None'. This represents a uniform refactoring pattern applied to the same type of syntactic construct (exception raising statements) within the same method. The edits are part of a single, contiguous micro-task to standardize exception types and improve error message consistency. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform identical structural substitutions within the same function: changing 'AssertionError' to 'ValueError' and updating the error message from 'empty' to 'None'. This represents a uniform refactoring pattern applied to the same type of syntactic construct (exception raising statements) within the same method. The edits are part of a single, contiguous micro-task to standardize exception types and improve error message consistency. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 7,
            "reason": "Edit 0 changes the error message from 'Body must be empty for GET request' to 'Body must be None for GET request'. Edit 1 updates a test assertion to check for 'must not be None' instead of 'must not be empty' in the exception message. These edits are directly linked because the test is verifying the exact error message that was changed in the production code. The test assertion must be updated to match the new error message text, making this a clear case of test-production code synchronization where both edits reference the same error condition and message."
        },
        {
            "src": 7,
            "tgt": 0,
            "reason": "Edit 0 changes the error message from 'Body must be empty for GET request' to 'Body must be None for GET request'. Edit 1 updates a test assertion to check for 'must not be None' instead of 'must not be empty' in the exception message. These edits are directly linked because the test is verifying the exact error message that was changed in the production code. The test assertion must be updated to match the new error message text, making this a clear case of test-production code synchronization where both edits reference the same error condition and message."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 changes the error message from 'Body must be empty for GET request' to 'Body must be None for GET request'. Edit 1 updates the corresponding test assertion from checking for 'must be empty' to 'must be None' in the exception message. These edits are directly linked because they both reference the exact same error message text - the test is specifically designed to validate the error message that was changed in the production code. After making edit 0, the test would fail because it's looking for the old message text, making edit 1 the immediate next step to fix the test. Either edit could be made first since both are syntactically valid, but they form a synchronized pair where one naturally prompts the other."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 changes the error message from 'Body must be empty for GET request' to 'Body must be None for GET request'. Edit 1 updates the corresponding test assertion from checking for 'must be empty' to 'must be None' in the exception message. These edits are directly linked because they both reference the exact same error message text - the test is specifically designed to validate the error message that was changed in the production code. After making edit 0, the test would fail because it's looking for the old message text, making edit 1 the immediate next step to fix the test. Either edit could be made first since both are syntactically valid, but they form a synchronized pair where one naturally prompts the other."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits change the same exception type from AssertionError to ValueError. Edit 0 changes the exception being raised in the production code, while Edit 1 updates the corresponding test to expect the new exception type. The test is specifically testing the behavior that raises this exception, so both edits reference the exact same error condition and exception type. This creates a direct code dependency where changing the exception type in production requires updating the test assertion to match, making them bi-directional neighbours in the same micro-task."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits change the same exception type from AssertionError to ValueError. Edit 0 changes the exception being raised in the production code, while Edit 1 updates the corresponding test to expect the new exception type. The test is specifically testing the behavior that raises this exception, so both edits reference the exact same error condition and exception type. This creates a direct code dependency where changing the exception type in production requires updating the test assertion to match, making them bi-directional neighbours in the same micro-task."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 changes the exception type from AssertionError to ValueError in the HTTP client implementation. Edit 1 updates the corresponding test to expect ValueError instead of AssertionError. Both edits reference the exact same exception handling behavior - the changed lines in edit 0 raise ValueError, and the changed lines in edit 1 expect ValueError. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step to maintain consistency between implementation and test."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 changes the exception type from AssertionError to ValueError in the HTTP client implementation. Edit 1 updates the corresponding test to expect ValueError instead of AssertionError. Both edits reference the exact same exception handling behavior - the changed lines in edit 0 raise ValueError, and the changed lines in edit 1 expect ValueError. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step to maintain consistency between implementation and test."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 changes the error message from 'Body must be empty' to 'Body must not be None' (or 'Body must be None') in the ValueError exception. Edit 1 updates the corresponding test assertion to check for 'must be None' instead of 'must be empty' in the exception message. These edits reference the exact same error message text that was changed, making them directly linked - the test assertion needs to be updated to match the new error message format from the implementation change."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 changes the error message from 'Body must be empty' to 'Body must not be None' (or 'Body must be None') in the ValueError exception. Edit 1 updates the corresponding test assertion to check for 'must be None' instead of 'must be empty' in the exception message. These edits reference the exact same error message text that was changed, making them directly linked - the test assertion needs to be updated to match the new error message format from the implementation change."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 changes the exception type from AssertionError to ValueError in the HTTP client implementation. Edit 1 updates the corresponding test to expect ValueError instead of AssertionError. Both edits reference the exact same exception handling behavior - the changed lines in edit 0 raise ValueError, and the changed lines in edit 1 expect ValueError. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain consistency between implementation and test. Both edits can be staged in either order without parser errors."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 changes the exception type from AssertionError to ValueError in the HTTP client implementation. Edit 1 updates the corresponding test to expect ValueError instead of AssertionError. Both edits reference the exact same exception handling behavior - the changed lines in edit 0 raise ValueError, and the changed lines in edit 1 expect ValueError. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain consistency between implementation and test. Both edits can be staged in either order without parser errors."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "Edit 0 changes an error message from 'Body must not be empty' to 'Body must not be None' in the production code. Edit 1 updates the corresponding test assertion to check for the new error message 'must not be None' instead of 'must not be empty'. These edits reference the exact same error message text and form a direct production-test synchronization where the test must be updated to match the changed error message in the production code. Either edit can be staged first without causing parse errors, but making either edit creates an immediate prompt for the other to maintain test-production consistency."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "Edit 0 changes an error message from 'Body must not be empty' to 'Body must not be None' in the production code. Edit 1 updates the corresponding test assertion to check for the new error message 'must not be None' instead of 'must not be empty'. These edits reference the exact same error message text and form a direct production-test synchronization where the test must be updated to match the changed error message in the production code. Either edit can be staged first without causing parse errors, but making either edit creates an immediate prompt for the other to maintain test-production consistency."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Edit 0 changes the error message from 'Body must not be empty for \"%s\" request' to 'Body must %sbe None for method %s'. Edit 1 updates a test assertion that checks for the old error message text 'must not be empty' to check for the new error message text 'must not be None'. Both edits reference the exact same error message content - edit 0 changes the message that gets raised, and edit 1 updates the test that validates that message. This creates a direct code dependency where the test assertion must be updated to match the new error message format, making them bi-directional neighbours in the same refactoring task."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Edit 0 changes the error message from 'Body must not be empty for \"%s\" request' to 'Body must %sbe None for method %s'. Edit 1 updates a test assertion that checks for the old error message text 'must not be empty' to check for the new error message text 'must not be None'. Both edits reference the exact same error message content - edit 0 changes the message that gets raised, and edit 1 updates the test that validates that message. This creates a direct code dependency where the test assertion must be updated to match the new error message format, making them bi-directional neighbours in the same refactoring task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution (AssertionError \u2192 ValueError) on the same type of syntactic construct (assertRaises context manager calls) within the same test method. This represents a bulk-edit pattern where the same before\u2192after substitution is being applied uniformly across multiple locations of the same construct type. Both changes are part of a single, contiguous refactor to update the expected exception type in test assertions."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution (AssertionError \u2192 ValueError) on the same type of syntactic construct (assertRaises context manager calls) within the same test method. This represents a bulk-edit pattern where the same before\u2192after substitution is being applied uniformly across multiple locations of the same construct type. Both changes are part of a single, contiguous refactor to update the expected exception type in test assertions."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern within the same test method: changing 'empty' to 'None' in assertion strings. They are part of the same syntactic construct type (assertTrue assertions with string containment checks) and appear to be part of a single, contiguous refactor to update error message expectations. The edits target the same type of code pattern within the same test function context, making this a bulk-edit synchronization where either edit naturally prompts the other as part of the same mechanical substitution task."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern within the same test method: changing 'empty' to 'None' in assertion strings. They are part of the same syntactic construct type (assertTrue assertions with string containment checks) and appear to be part of a single, contiguous refactor to update error message expectations. The edits target the same type of code pattern within the same test function context, making this a bulk-edit synchronization where either edit naturally prompts the other as part of the same mechanical substitution task."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits are modifying the same test method `test_body` and are directly related to the same test assertion flow. Edit 0 changes the expected exception type from AssertionError to ValueError, and Edit 1 changes the expected error message from 'must be empty' to 'must be None'. These changes are part of updating the same test case to match a change in the underlying implementation - when the exception type changes, the error message also needs to be updated to match the new exception. The `context.exception` object referenced in Edit 1 is the same exception object captured by the `with self.assertRaises(ValueError)` statement modified in Edit 0. Both edits reference the exact same test assertion context and are mechanically linked as part of updating a single test case."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits are modifying the same test method `test_body` and are directly related to the same test assertion flow. Edit 0 changes the expected exception type from AssertionError to ValueError, and Edit 1 changes the expected error message from 'must be empty' to 'must be None'. These changes are part of updating the same test case to match a change in the underlying implementation - when the exception type changes, the error message also needs to be updated to match the new exception. The `context.exception` object referenced in Edit 1 is the same exception object captured by the `with self.assertRaises(ValueError)` statement modified in Edit 0. Both edits reference the exact same test assertion context and are mechanically linked as part of updating a single test case."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Both edits are modifying the same test method `test_body` and are part of updating a test assertion. Edit 0 changes the expected exception type from AssertionError to ValueError, and Edit 1 changes the expected error message from 'must not be empty' to 'must not be None'. These changes are synchronized - they both reference the same `context.exception` object captured from the same `with` statement. The changes appear to be updating the test to match a change in the underlying implementation's error handling behavior. Both edits reference the exact same exception context and are part of the same test assertion update, making either edit naturally prompt the other as the next mechanical step in updating this test."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Both edits are modifying the same test method `test_body` and are part of updating a test assertion. Edit 0 changes the expected exception type from AssertionError to ValueError, and Edit 1 changes the expected error message from 'must not be empty' to 'must not be None'. These changes are synchronized - they both reference the same `context.exception` object captured from the same `with` statement. The changes appear to be updating the test to match a change in the underlying implementation's error handling behavior. Both edits reference the exact same exception context and are part of the same test assertion update, making either edit naturally prompt the other as the next mechanical step in updating this test."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits are modifying the same test method `test_body` and are directly related to testing the same exception scenario. Edit 0 changes the expected exception type from AssertionError to ValueError, and Edit 1 changes the expected error message from 'must not be empty' to 'must not be None'. These changes reference the exact same exception context object (`context.exception`) and are part of updating the same test assertion logic. The changes are synchronized - when the exception type changes, the corresponding error message assertion also needs to be updated to match the new exception's message. Both edits can be applied in either order as they modify different lines and both reference the same context object."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits are modifying the same test method `test_body` and are directly related to testing the same exception scenario. Edit 0 changes the expected exception type from AssertionError to ValueError, and Edit 1 changes the expected error message from 'must not be empty' to 'must not be None'. These changes reference the exact same exception context object (`context.exception`) and are part of updating the same test assertion logic. The changes are synchronized - when the exception type changes, the corresponding error message assertion also needs to be updated to match the new exception's message. Both edits can be applied in either order as they modify different lines and both reference the same context object."
        }
    ],
    "allowed_init_edits": [
        3
    ]
}