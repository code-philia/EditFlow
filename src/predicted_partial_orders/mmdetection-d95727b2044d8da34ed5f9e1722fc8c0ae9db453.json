{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds an 'evaluation' configuration dictionary to a config file, while Edit 1 retrieves that same 'evaluation' configuration using cfg.get('evaluation', {}). These edits reference the exact same configuration key 'evaluation' - one defines it in the config and the other accesses it in the training code. This creates a direct code dependency where the training code is designed to read the evaluation configuration that was added to the config file. Both edits are part of implementing an evaluation feature where the config defines the evaluation parameters and the training code consumes them."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds an 'evaluation' configuration dictionary to a config file, while Edit 1 retrieves that same 'evaluation' configuration using cfg.get('evaluation', {}). These edits reference the exact same configuration key 'evaluation' - one defines it in the config and the other accesses it in the training code. This creates a direct code dependency where the training code is designed to read the evaluation configuration that was added to the config file. Both edits are part of implementing an evaluation feature where the config defines the evaluation parameters and the training code consumes them."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 defines the variable 'eval_cfg' by extracting it from the configuration, and Edit 1 uses that exact same variable 'eval_cfg' in the function call to CocoDistEvalmAPHook. The changed lines reference the exact same symbol - 'eval_cfg'. After making Edit 0, the next immediate, mechanically obvious step would be to use the newly defined eval_cfg variable in the function call, which is exactly what Edit 1 does. This creates a direct definition-usage relationship where both edits reference the same symbol within the same function scope."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 defines the variable 'eval_cfg' by extracting it from the configuration, and Edit 1 uses that exact same variable 'eval_cfg' in the function call to CocoDistEvalmAPHook. The changed lines reference the exact same symbol - 'eval_cfg'. After making Edit 0, the next immediate, mechanically obvious step would be to use the newly defined eval_cfg variable in the function call, which is exactly what Edit 1 does. This creates a direct definition-usage relationship where both edits reference the same symbol within the same function scope."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 defines the variable 'eval_cfg' by extracting it from the configuration, and edit 1 uses that exact same variable 'eval_cfg' in the DistEvalmAPHook call. The changed lines reference the exact same symbol - 'eval_cfg'. After making edit 0, edit 1 becomes the immediate next step to use the newly defined variable. After making edit 1, edit 0 becomes necessary to define the variable being used. This is a classic definition-usage relationship within the same function scope."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 defines the variable 'eval_cfg' by extracting it from the configuration, and edit 1 uses that exact same variable 'eval_cfg' in the DistEvalmAPHook call. The changed lines reference the exact same symbol - 'eval_cfg'. After making edit 0, edit 1 becomes the immediate next step to use the newly defined variable. After making edit 1, edit 0 becomes necessary to define the variable being used. This is a classic definition-usage relationship within the same function scope."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 defines the variable 'eval_cfg' by extracting it from the config, and edit 1 immediately uses that exact same variable 'eval_cfg' in the function call to CocoDistEvalRecallHook. The changed lines reference the exact same symbol - 'eval_cfg' - where edit 0 creates the variable and edit 1 consumes it. This creates a direct code dependency where making edit 0 provides the variable that edit 1 needs to reference. Both edits can be staged in either order since Python allows referencing undefined variables at parse time (would only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 defines the variable 'eval_cfg' by extracting it from the config, and edit 1 immediately uses that exact same variable 'eval_cfg' in the function call to CocoDistEvalRecallHook. The changed lines reference the exact same symbol - 'eval_cfg' - where edit 0 creates the variable and edit 1 consumes it. This creates a direct code dependency where making edit 0 provides the variable that edit 1 needs to reference. Both edits can be staged in either order since Python allows referencing undefined variables at parse time (would only fail at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution pattern: they take existing hook registration calls and add the same `**eval_cfg` parameter to the constructor arguments. Edit 0 changes `CocoDistEvalRecallHook(val_dataset_cfg)` to `CocoDistEvalRecallHook(val_dataset_cfg, **eval_cfg)` and Edit 1 changes `DistEvalmAPHook(val_dataset_cfg)` to `DistEvalmAPHook(val_dataset_cfg, **eval_cfg)`. This is a bulk-edit pattern where the same before\u2192after transformation (adding `, **eval_cfg` parameter) is applied to the same type of syntactic construct (hook constructor calls) within the same function context. Both edits are part of a single, contiguous refactor to consistently pass evaluation configuration to hook constructors."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical structural substitution pattern: they take existing hook registration calls and add the same `**eval_cfg` parameter to the constructor arguments. Edit 0 changes `CocoDistEvalRecallHook(val_dataset_cfg)` to `CocoDistEvalRecallHook(val_dataset_cfg, **eval_cfg)` and Edit 1 changes `DistEvalmAPHook(val_dataset_cfg)` to `DistEvalmAPHook(val_dataset_cfg, **eval_cfg)`. This is a bulk-edit pattern where the same before\u2192after transformation (adding `, **eval_cfg` parameter) is applied to the same type of syntactic construct (hook constructor calls) within the same function context. Both edits are part of a single, contiguous refactor to consistently pass evaluation configuration to hook constructors."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical structural substitution pattern within the same function context. They both change hook registration calls from a single-line format to a multi-line format while adding the same '**eval_cfg' parameter. The changes target the same type of syntactic construct (hook registration calls) with the exact same before\u2192after pattern: adding '**eval_cfg' parameter and reformatting to multi-line. This represents a uniform refactoring operation where both edits are part of the same contiguous micro-task of updating hook registrations to accept eval_cfg parameters."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical structural substitution pattern within the same function context. They both change hook registration calls from a single-line format to a multi-line format while adding the same '**eval_cfg' parameter. The changes target the same type of syntactic construct (hook registration calls) with the exact same before\u2192after pattern: adding '**eval_cfg' parameter and reformatting to multi-line. This represents a uniform refactoring operation where both edits are part of the same contiguous micro-task of updating hook registrations to accept eval_cfg parameters."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits reference the exact same symbol 'interval' in the context of the same function's parameter handling. Edit 0 adds 'interval=1' as a parameter to the __init__ method signature, and Edit 1 passes that same 'interval' parameter to the parent class constructor call. This creates a direct code dependency where the parameter added in Edit 0 is immediately used in Edit 1. After making either edit, the other becomes the mechanically obvious next step to maintain code consistency - adding the parameter requires passing it to super(), and passing it to super() requires it to be defined as a parameter. This is a classic parameter threading pattern within the same function."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits reference the exact same symbol 'interval' in the context of the same function's parameter handling. Edit 0 adds 'interval=1' as a parameter to the __init__ method signature, and Edit 1 passes that same 'interval' parameter to the parent class constructor call. This creates a direct code dependency where the parameter added in Edit 0 is immediately used in Edit 1. After making either edit, the other becomes the mechanically obvious next step to maintain code consistency - adding the parameter requires passing it to super(), and passing it to super() requires it to be defined as a parameter. This is a classic parameter threading pattern within the same function."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution pattern within the same function context. Edit 0 changes the CocoDistEvalmAPHook call from taking only val_dataset_cfg to taking val_dataset_cfg, **eval_cfg. Edit 1 makes the exact same pattern change to DistEvalmAPHook call, changing from val_dataset_cfg to val_dataset_cfg, **eval_cfg. This is a bulk uniform substitution where both edits apply the same before\u2192after pattern (adding **eval_cfg parameter) to the same type of syntactic construct (hook registration calls) within the same conditional block. Either edit can be made first, and both are part of the same contiguous refactoring task to add eval_cfg parameter spreading to hook constructors."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical structural substitution pattern within the same function context. Edit 0 changes the CocoDistEvalmAPHook call from taking only val_dataset_cfg to taking val_dataset_cfg, **eval_cfg. Edit 1 makes the exact same pattern change to DistEvalmAPHook call, changing from val_dataset_cfg to val_dataset_cfg, **eval_cfg. This is a bulk uniform substitution where both edits apply the same before\u2192after pattern (adding **eval_cfg parameter) to the same type of syntactic construct (hook registration calls) within the same conditional block. Either edit can be made first, and both are part of the same contiguous refactoring task to add eval_cfg parameter spreading to hook constructors."
        }
    ],
    "allowed_init_edits": [
        1
    ]
}