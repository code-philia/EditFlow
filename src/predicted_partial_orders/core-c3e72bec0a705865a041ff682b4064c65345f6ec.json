{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits add identical assertion lines (`assert not browse.can_play`) to different test functions within the same test file. This represents a synchronized pattern addition where the same structural change is being applied to multiple test cases. The edits involve the same syntactic construct (assertion statements) with identical before\u2192after patterns (adding the same assertion). This appears to be part of a single, contiguous refactoring effort to add consistent test coverage for the `can_play` attribute across multiple test functions."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits add identical assertion lines (`assert not browse.can_play`) to different test functions within the same test file. This represents a synchronized pattern addition where the same structural change is being applied to multiple test cases. The edits involve the same syntactic construct (assertion statements) with identical before\u2192after patterns (adding the same assertion). This appears to be part of a single, contiguous refactoring effort to add consistent test coverage for the `can_play` attribute across multiple test functions."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 imports EventImageType from google_nest_sdm.event, and Edit 1 uses EventImageType in the expression (event.event_image_type == EventImageType.CLIP_PREVIEW). The changed lines reference the exact same symbol EventImageType - Edit 0 makes it available through import, and Edit 1 uses it. This creates an immediate code dependency where using EventImageType in Edit 1 requires the import from Edit 0. Both edits are part of the same micro-task of adding EventImageType functionality."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 imports EventImageType from google_nest_sdm.event, and Edit 1 uses EventImageType in the expression (event.event_image_type == EventImageType.CLIP_PREVIEW). The changed lines reference the exact same symbol EventImageType - Edit 0 makes it available through import, and Edit 1 uses it. This creates an immediate code dependency where using EventImageType in Edit 1 requires the import from Edit 0. Both edits are part of the same micro-task of adding EventImageType functionality."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 changes the logic for the `can_play` property in the `_browse_event` function from always being `True` to being conditional based on `event.event_image_type == EventImageType.CLIP_PREVIEW`. Edit 1 adds a test assertion `assert not browse.can_play` which directly tests the behavior of the `can_play` property that was modified in Edit 0. The test assertion is checking the exact same property that was changed in the production code, creating a direct test-production synchronization relationship where both edits reference the same `can_play` attribute behavior."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 changes the logic for the `can_play` property in the `_browse_event` function from always being `True` to being conditional based on `event.event_image_type == EventImageType.CLIP_PREVIEW`. Edit 1 adds a test assertion `assert not browse.can_play` which directly tests the behavior of the `can_play` property that was modified in Edit 0. The test assertion is checking the exact same property that was changed in the production code, creating a direct test-production synchronization relationship where both edits reference the same `can_play` attribute behavior."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 changes the `can_play` property logic in the `_browse_event` function from a hardcoded `True` to a conditional expression based on `event.event_image_type`. Edit 1 adds a test assertion `assert not browse.can_play` which directly tests the behavior of the `can_play` property that was modified in Edit 0. The test assertion is specifically checking the `can_play` attribute of the `BrowseMediaSource` object returned by the function modified in Edit 0. This creates a direct test-production code synchronization where the test is validating the exact behavior change implemented in the production code. Both edits reference the same `can_play` property - one modifies its implementation logic, the other tests its expected behavior."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 changes the `can_play` property logic in the `_browse_event` function from a hardcoded `True` to a conditional expression based on `event.event_image_type`. Edit 1 adds a test assertion `assert not browse.can_play` which directly tests the behavior of the `can_play` property that was modified in Edit 0. The test assertion is specifically checking the `can_play` attribute of the `BrowseMediaSource` object returned by the function modified in Edit 0. This creates a direct test-production code synchronization where the test is validating the exact behavior change implemented in the production code. Both edits reference the same `can_play` property - one modifies its implementation logic, the other tests its expected behavior."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits add identical assertion statements (`assert not browse.can_play`) to different test functions within the same test file. This represents a synchronized pattern addition where the same structural change is being applied to multiple test functions, likely as part of a single refactoring effort to add consistent test coverage for the `can_play` attribute. The edits involve identical textual substitution (adding the same assertion line) targeting the same type of syntactic construct (test assertions), making this a bulk-edit pattern synchronization that would naturally occur in one contiguous micro-task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits add identical assertion statements (`assert not browse.can_play`) to different test functions within the same test file. This represents a synchronized pattern addition where the same structural change is being applied to multiple test functions, likely as part of a single refactoring effort to add consistent test coverage for the `can_play` attribute. The edits involve identical textual substitution (adding the same assertion line) targeting the same type of syntactic construct (test assertions), making this a bulk-edit pattern synchronization that would naturally occur in one contiguous micro-task."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits add identical assertion lines (`assert not browse.can_play`) within the same test function `test_event_order`. This represents a bulk-edit pattern where the same structural change (adding the same assertion) is being applied to multiple locations within the same test context. The edits involve identical textual substitution (adding the same line) and target the same type of syntactic construct (assertion statements). Both edits reference the same `browse` object and test the same `can_play` attribute, making this a synchronized addition pattern within the same function scope. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the test assertions."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits add identical assertion lines (`assert not browse.can_play`) within the same test function `test_event_order`. This represents a bulk-edit pattern where the same structural change (adding the same assertion) is being applied to multiple locations within the same test context. The edits involve identical textual substitution (adding the same line) and target the same type of syntactic construct (assertion statements). Both edits reference the same `browse` object and test the same `can_play` attribute, making this a synchronized addition pattern within the same function scope. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the test assertions."
        }
    ],
    "allowed_init_edits": [
        5
    ]
}