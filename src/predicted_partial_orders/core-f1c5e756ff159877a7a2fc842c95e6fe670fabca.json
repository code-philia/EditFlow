{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds handling for EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED event types in the _exclude_events function. Edit 1 adds test events of these same types (EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED) to the test case that calls _exclude_events. The test edit is directly testing the new functionality added in the production code edit - both edits reference the exact same event type constants and the test is calling the exact same function that was modified. This creates a direct code dependency where the test is validating the behavior of the newly added code paths."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds handling for EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED event types in the _exclude_events function. Edit 1 adds test events of these same types (EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED) to the test case that calls _exclude_events. The test edit is directly testing the new functionality added in the production code edit - both edits reference the exact same event type constants and the test is calling the exact same function that was modified. This creates a direct code dependency where the test is validating the behavior of the newly added code paths."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Edit 0 adds handling for EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED event types in the _exclude_events function. Edit 1 adds event_alexa and event_homekit to the test data being passed to the same _exclude_events function. These edits reference the exact same function symbol (logbook._exclude_events) and appear to be part of the same development session where new event types are being added to the implementation and corresponding test events are being added to verify the new functionality. The test edit naturally follows from the implementation edit as it tests the newly added event handling logic."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Edit 0 adds handling for EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED event types in the _exclude_events function. Edit 1 adds event_alexa and event_homekit to the test data being passed to the same _exclude_events function. These edits reference the exact same function symbol (logbook._exclude_events) and appear to be part of the same development session where new event types are being added to the implementation and corresponding test events are being added to verify the new functionality. The test edit naturally follows from the implementation edit as it tests the newly added event handling logic."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform identical structural substitutions on the same type of syntactic construct (logbook.CONF_DOMAINS list values) within the same test file. Edit 0 changes the exclude domains list from ['switch', ] to ['switch', 'alexa', DOMAIN_HOMEKIT], while Edit 1 changes the include domains list from ['sensor', ] to ['sensor', 'alexa', DOMAIN_HOMEKIT]. Both edits add the exact same elements ('alexa', DOMAIN_HOMEKIT) to their respective domain lists, representing a uniform pattern of adding the same test domains across different test methods. This is a clear case of bulk-edit synchronization where both edits apply the same before\u2192after pattern (adding the same domain elements) to the same construct type (CONF_DOMAINS lists) as part of what appears to be a single refactoring operation to expand test coverage."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform identical structural substitutions on the same type of syntactic construct (logbook.CONF_DOMAINS list values) within the same test file. Edit 0 changes the exclude domains list from ['switch', ] to ['switch', 'alexa', DOMAIN_HOMEKIT], while Edit 1 changes the include domains list from ['sensor', ] to ['sensor', 'alexa', DOMAIN_HOMEKIT]. Both edits add the exact same elements ('alexa', DOMAIN_HOMEKIT) to their respective domain lists, representing a uniform pattern of adding the same test domains across different test methods. This is a clear case of bulk-edit synchronization where both edits apply the same before\u2192after pattern (adding the same domain elements) to the same construct type (CONF_DOMAINS lists) as part of what appears to be a single refactoring operation to expand test coverage."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds handling for EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED events by setting their domains to 'alexa' and DOMAIN_HOMEKIT respectively in the _exclude_events function. Edit 1 updates a test to include these same domains ('alexa' and DOMAIN_HOMEKIT) in the exclusion configuration. The test is specifically testing the domain exclusion functionality that was just modified in edit 0. Both edits reference the exact same domain values ('alexa' and DOMAIN_HOMEKIT) and the test directly validates the behavior implemented in the production code change. This creates a bi-directional relationship where either edit naturally prompts the other as the next step - implementing the feature prompts updating the test, or updating the test prompts implementing the feature."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds handling for EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED events by setting their domains to 'alexa' and DOMAIN_HOMEKIT respectively in the _exclude_events function. Edit 1 updates a test to include these same domains ('alexa' and DOMAIN_HOMEKIT) in the exclusion configuration. The test is specifically testing the domain exclusion functionality that was just modified in edit 0. Both edits reference the exact same domain values ('alexa' and DOMAIN_HOMEKIT) and the test directly validates the behavior implemented in the production code change. This creates a bi-directional relationship where either edit naturally prompts the other as the next step - implementing the feature prompts updating the test, or updating the test prompts implementing the feature."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 adds handling for EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED event types in the production code, while Edit 1 creates test events of these exact same event types (EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED) in the test code. Both edits reference the same event type constants, and the test edit appears to be creating test data to verify the behavior implemented in Edit 0. This represents a test-production code synchronization where the test is being updated to cover the new functionality added in production code."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 adds handling for EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED event types in the production code, while Edit 1 creates test events of these exact same event types (EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED) in the test code. Both edits reference the same event type constants, and the test edit appears to be creating test data to verify the behavior implemented in Edit 0. This represents a test-production code synchronization where the test is being updated to cover the new functionality added in production code."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits are part of the same test function and work together to test domain exclusion functionality. Edit 0 adds 'alexa' and DOMAIN_HOMEKIT to the exclusion configuration, while Edit 1 adds corresponding test events (EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED) to verify that these domains are properly excluded. The edits reference the same test scenario and are mechanically linked - adding domains to exclude in the config naturally prompts adding corresponding events to test that exclusion. Both edits can be applied in either order since they modify different parts of the same test setup."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits are part of the same test function and work together to test domain exclusion functionality. Edit 0 adds 'alexa' and DOMAIN_HOMEKIT to the exclusion configuration, while Edit 1 adds corresponding test events (EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED) to verify that these domains are properly excluded. The edits reference the same test scenario and are mechanically linked - adding domains to exclude in the config naturally prompts adding corresponding events to test that exclusion. Both edits can be applied in either order since they modify different parts of the same test setup."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "These edits are part of the same test modification where edit 0 adds two new events (EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED) to the test input, and edit 1 updates the assertion to expect 4 entries instead of 2 to account for these additional events. The edits reference the same test scenario and the assertion count directly corresponds to the number of events being tested, creating a direct dependency where adding events necessitates updating the expected count."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "These edits are part of the same test modification where edit 0 adds two new events (EVENT_ALEXA_SMART_HOME and EVENT_HOMEKIT_CHANGED) to the test input, and edit 1 updates the assertion to expect 4 entries instead of 2 to account for these additional events. The edits reference the same test scenario and the assertion count directly corresponds to the number of events being tested, creating a direct dependency where adding events necessitates updating the expected count."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "These edits are part of the same test modification where edit 0 adds two new event objects (event_alexa and event_homekit) to the test, and edit 1 updates the assertion to expect 4 entries instead of 2 to account for the newly added events. The changed lines reference the same test context and the assertion count directly corresponds to the number of events being tested. After adding the events in edit 0, the assertion in edit 1 becomes the immediate next step to make the test pass."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "These edits are part of the same test modification where edit 0 adds two new event objects (event_alexa and event_homekit) to the test, and edit 1 updates the assertion to expect 4 entries instead of 2 to account for the newly added events. The changed lines reference the same test context and the assertion count directly corresponds to the number of events being tested. After adding the events in edit 0, the assertion in edit 1 becomes the immediate next step to make the test pass."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 defines two variables `event_alexa` and `event_homekit` by creating ha.Event objects and assigning them to these variable names. Edit 1 then references these exact same variables by name in a function call, adding them to a tuple parameter. The changed lines in edit 1 explicitly reference the same symbols that were defined in edit 0's changed lines. This creates a direct definition-usage relationship where making edit 0 creates the variables that edit 1 immediately uses. Since Python allows referencing undefined variables at parse time (they only fail at runtime), either edit could be staged first, but after making either edit, the other becomes the mechanically obvious next step to complete the micro-task."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 defines two variables `event_alexa` and `event_homekit` by creating ha.Event objects and assigning them to these variable names. Edit 1 then references these exact same variables by name in a function call, adding them to a tuple parameter. The changed lines in edit 1 explicitly reference the same symbols that were defined in edit 0's changed lines. This creates a direct definition-usage relationship where making edit 0 creates the variables that edit 1 immediately uses. Since Python allows referencing undefined variables at parse time (they only fail at runtime), either edit could be staged first, but after making either edit, the other becomes the mechanically obvious next step to complete the micro-task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "These edits are part of the same test function and directly related. Edit 0 adds more domains ('alexa', DOMAIN_HOMEKIT) to the test configuration, which increases the number of expected entries. Edit 1 updates the assertion to expect 4 entries instead of 2, which directly corresponds to the additional domains added in edit 0. The test logic creates entries based on the configured domains, so adding domains mechanically requires updating the expected count. Both edits reference the same test scenario and the assertion count directly depends on the configuration change."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "These edits are part of the same test function and directly related. Edit 0 adds more domains ('alexa', DOMAIN_HOMEKIT) to the test configuration, which increases the number of expected entries. Edit 1 updates the assertion to expect 4 entries instead of 2, which directly corresponds to the additional domains added in edit 0. The test logic creates entries based on the configured domains, so adding domains mechanically requires updating the expected count. Both edits reference the same test scenario and the assertion count directly depends on the configuration change."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "These edits are part of the same test modification where edit 0 adds 'alexa' and DOMAIN_HOMEKIT to the configuration's included domains list, and edit 1 adds the corresponding test events (event_alexa, event_homekit) to verify that these domains are properly included. Both edits reference the same test scenario and are mechanically linked - after adding domains to the config, the natural next step is to add corresponding test events to verify the behavior. The edits can be applied in either order since both are syntactically valid independently, but they form a cohesive test update."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "These edits are part of the same test modification where edit 0 adds 'alexa' and DOMAIN_HOMEKIT to the configuration's included domains list, and edit 1 adds the corresponding test events (event_alexa, event_homekit) to verify that these domains are properly included. Both edits reference the same test scenario and are mechanically linked - after adding domains to the config, the natural next step is to add corresponding test events to verify the behavior. The edits can be applied in either order since both are syntactically valid independently, but they form a cohesive test update."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "These edits are part of the same test modification where edit 0 adds two new events (event_alexa, event_homekit) to the input tuple, and edit 1 adds corresponding assertions for those same events. The edits reference the same test data flow - the events added in edit 0 become entries that are asserted in edit 1. Both edits are modifying the same test method to handle the expanded event list, creating a direct structural dependency where the added events in the input must have corresponding assertions in the output verification."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "These edits are part of the same test modification where edit 0 adds two new events (event_alexa, event_homekit) to the input tuple, and edit 1 adds corresponding assertions for those same events. The edits reference the same test data flow - the events added in edit 0 become entries that are asserted in edit 1. Both edits are modifying the same test method to handle the expanded event list, creating a direct structural dependency where the added events in the input must have corresponding assertions in the output verification."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits are part of the same test function and are directly related to the same test assertion. Edit 0 adds two more events (event_alexa, event_homekit) to the tuple being passed to logbook._exclude_events(), changing the input from 3 events to 5 events. Edit 1 updates the assertion to expect 4 entries instead of 2, which directly corresponds to the change in the number of events being processed. The assertion in edit 1 is testing the length of the result from the function call modified in edit 0. These edits reference the same test logic and the assertion must be updated to match the new expected behavior from the modified function call."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits are part of the same test function and are directly related to the same test assertion. Edit 0 adds two more events (event_alexa, event_homekit) to the tuple being passed to logbook._exclude_events(), changing the input from 3 events to 5 events. Edit 1 updates the assertion to expect 4 entries instead of 2, which directly corresponds to the change in the number of events being processed. The assertion in edit 1 is testing the length of the result from the function call modified in edit 0. These edits reference the same test logic and the assertion must be updated to match the new expected behavior from the modified function call."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Both edits are part of the same test method `test_include_events_domain` and work together to modify the test configuration and corresponding assertions. Edit 0 adds 'alexa' and DOMAIN_HOMEKIT to the included domains list in the test configuration, while Edit 1 adds corresponding assertions for these new domains and adjusts the existing sensor assertion index. The edits reference the same test data structure - the configuration in Edit 0 determines what domains should be included, and the assertions in Edit 1 verify that entries for those exact same domains are present. This creates a direct code dependency where both edits must be synchronized to maintain test correctness - adding domains to the config without corresponding assertions would make the test incomplete, and adding assertions without including the domains in the config would cause test failures."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Both edits are part of the same test method `test_include_events_domain` and work together to modify the test configuration and corresponding assertions. Edit 0 adds 'alexa' and DOMAIN_HOMEKIT to the included domains list in the test configuration, while Edit 1 adds corresponding assertions for these new domains and adjusts the existing sensor assertion index. The edits reference the same test data structure - the configuration in Edit 0 determines what domains should be included, and the assertions in Edit 1 verify that entries for those exact same domains are present. This creates a direct code dependency where both edits must be synchronized to maintain test correctness - adding domains to the config without corresponding assertions would make the test incomplete, and adding assertions without including the domains in the config would cause test failures."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "These edits are part of the same test modification where the expected number of entries is being changed from 2 to 4, and correspondingly the assertion indices are being updated from entries[1] to entries[3] to accommodate the two new entries being inserted. The first edit changes the expected count, and the second edit adds the new entries and updates the existing assertion index. Both edits reference the same 'entries' array and are mechanically linked - changing the expected count necessitates updating the assertion indices to match the new structure."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "These edits are part of the same test modification where the expected number of entries is being changed from 2 to 4, and correspondingly the assertion indices are being updated from entries[1] to entries[3] to accommodate the two new entries being inserted. The first edit changes the expected count, and the second edit adds the new entries and updates the existing assertion index. Both edits reference the same 'entries' array and are mechanically linked - changing the expected count necessitates updating the assertion indices to match the new structure."
        }
    ],
    "allowed_init_edits": [
        2,
        1,
        3,
        7
    ]
}