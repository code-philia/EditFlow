{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 renames the class attribute from CLICKHOUSE_CHUNK_SIZE to CLICKHOUSE_MUTATION_CHUNK_SIZE. Edit 1 updates the usage of this same attribute in the run method from self.CLICKHOUSE_CHUNK_SIZE to self.CLICKHOUSE_MUTATION_CHUNK_SIZE. Both edits reference the exact same symbol - the class attribute that was renamed. After making either edit, the other becomes the immediate next step to maintain code consistency, as leaving one without the other would result in a NameError at runtime when the method tries to access the renamed attribute."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 renames the class attribute from CLICKHOUSE_CHUNK_SIZE to CLICKHOUSE_MUTATION_CHUNK_SIZE. Edit 1 updates the usage of this same attribute in the run method from self.CLICKHOUSE_CHUNK_SIZE to self.CLICKHOUSE_MUTATION_CHUNK_SIZE. Both edits reference the exact same symbol - the class attribute that was renamed. After making either edit, the other becomes the immediate next step to maintain code consistency, as leaving one without the other would result in a NameError at runtime when the method tries to access the renamed attribute."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 defines a new class attribute CLICKHOUSE_VERIFY_CHUNK_SIZE = 1_000, and edit 1 uses this exact same symbol in two places (lines 35 and 36) by referencing self.CLICKHOUSE_VERIFY_CHUNK_SIZE. The changed lines in edit 1 directly reference the symbol defined in edit 0. This creates an immediate code dependency where defining the attribute in edit 0 enables its usage in edit 1, and using it in edit 1 requires its definition in edit 0. Both edits reference the exact same symbol and either can prompt the other as the next mechanical step in a single micro-task."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 defines a new class attribute CLICKHOUSE_VERIFY_CHUNK_SIZE = 1_000, and edit 1 uses this exact same symbol in two places (lines 35 and 36) by referencing self.CLICKHOUSE_VERIFY_CHUNK_SIZE. The changed lines in edit 1 directly reference the symbol defined in edit 0. This creates an immediate code dependency where defining the attribute in edit 0 enables its usage in edit 1, and using it in edit 1 requires its definition in edit 0. Both edits reference the exact same symbol and either can prompt the other as the next mechanical step in a single micro-task."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 removes the declaration of the `to_verify` variable (line 31), while Edit 1 removes all subsequent references to this same variable throughout the function body (lines 37, 39, 40, 44, 45). The changed lines in both edits reference the exact same symbol `to_verify`. After removing the variable declaration in Edit 0, all the usage references in Edit 1 would cause NameError at runtime, making Edit 1 the immediate next step to complete the refactoring. However, since Python allows referencing undefined variables at parse time (they only fail at runtime), both edits can be staged in either order without causing parser errors. This is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step in removing the `to_verify` variable pattern."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 removes the declaration of the `to_verify` variable (line 31), while Edit 1 removes all subsequent references to this same variable throughout the function body (lines 37, 39, 40, 44, 45). The changed lines in both edits reference the exact same symbol `to_verify`. After removing the variable declaration in Edit 0, all the usage references in Edit 1 would cause NameError at runtime, making Edit 1 the immediate next step to complete the refactoring. However, since Python allows referencing undefined variables at parse time (they only fail at runtime), both edits can be staged in either order without causing parser errors. This is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step in removing the `to_verify` variable pattern."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits apply the exact same structural transformation pattern to similar code constructs within the same function. Edit 0 wraps `runner.mark_deletions_done()` and `runner.run()` in try-catch blocks, while Edit 1 applies the identical pattern to `cohort_runner.mark_deletions_done()` and `cohort_runner.run()`. This is a bulk-edit pattern where the same before\u2192after transformation (adding try-catch error handling) is applied to the same type of syntactic construct (method calls on runner objects). Both edits are part of a single, contiguous refactoring task to add error handling to similar operations in the same function. Either edit could be made first, and after making one, the other becomes the immediate next step to complete the uniform pattern application."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits apply the exact same structural transformation pattern to similar code constructs within the same function. Edit 0 wraps `runner.mark_deletions_done()` and `runner.run()` in try-catch blocks, while Edit 1 applies the identical pattern to `cohort_runner.mark_deletions_done()` and `cohort_runner.run()`. This is a bulk-edit pattern where the same before\u2192after transformation (adding try-catch error handling) is applied to the same type of syntactic construct (method calls on runner objects). Both edits are part of a single, contiguous refactoring task to add error handling to similar operations in the same function. Either edit could be made first, and after making one, the other becomes the immediate next step to complete the uniform pattern application."
        }
    ],
    "allowed_init_edits": [
        1,
        2,
        4,
        5
    ]
}