{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 adds handling for 'labels' in the websocket_update_entity function, converting the labels to a set. Edit 1 adds 'labels' to a test case that calls this websocket function. These edits reference the exact same 'labels' parameter - edit 0 implements the server-side handling of this parameter, while edit 1 adds it to the test data that exercises this functionality. This creates a direct code linkage where both edits work together to implement and test the same feature parameter. Either edit could be made first and would naturally prompt the other as the next step - implementing the feature prompts adding test coverage, or adding test coverage prompts implementing the feature handling."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 adds handling for 'labels' in the websocket_update_entity function, converting the labels to a set. Edit 1 adds 'labels' to a test case that calls this websocket function. These edits reference the exact same 'labels' parameter - edit 0 implements the server-side handling of this parameter, while edit 1 adds it to the test data that exercises this functionality. This creates a direct code linkage where both edits work together to implement and test the same feature parameter. Either edit could be made first and would naturally prompt the other as the next step - implementing the feature prompts adding test coverage, or adding test coverage prompts implementing the feature handling."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits add a 'labels' parameter to the same websocket API endpoint. Edit 0 adds the 'labels' parameter to the schema definition in the websocket command decorator, while Edit 1 adds the 'labels' parameter to a test that calls this same API endpoint. The changed lines reference the exact same API parameter ('labels') in the same websocket command ('config/entity_registry/update'). After adding the schema definition, the test naturally needs to be updated to include the new parameter, and vice versa - both edits reference the same symbol and either edit would prompt the other as the next mechanical step in implementing this API change."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits add a 'labels' parameter to the same websocket API endpoint. Edit 0 adds the 'labels' parameter to the schema definition in the websocket command decorator, while Edit 1 adds the 'labels' parameter to a test that calls this same API endpoint. The changed lines reference the exact same API parameter ('labels') in the same websocket command ('config/entity_registry/update'). After adding the schema definition, the test naturally needs to be updated to include the new parameter, and vice versa - both edits reference the same symbol and either edit would prompt the other as the next mechanical step in implementing this API change."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'labels' in the context of the websocket entity registry update functionality. Edit 0 adds 'labels' as an optional parameter to the websocket command schema, while Edit 1 adds the corresponding handling logic for that same 'labels' parameter in the websocket_update_entity function. The changed lines in both edits explicitly reference the same 'labels' key - one defining it as a valid input parameter and the other processing that parameter. This creates a direct code dependency where adding the schema parameter naturally prompts adding the corresponding processing logic as the next mechanical step, or vice versa. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol 'labels' in the context of the websocket entity registry update functionality. Edit 0 adds 'labels' as an optional parameter to the websocket command schema, while Edit 1 adds the corresponding handling logic for that same 'labels' parameter in the websocket_update_entity function. The changed lines in both edits explicitly reference the same 'labels' key - one defining it as a valid input parameter and the other processing that parameter. This creates a direct code dependency where adding the schema parameter naturally prompts adding the corresponding processing logic as the next mechanical step, or vice versa. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits are part of the same test function and involve the exact same 'labels' field. Edit 0 adds a 'labels' parameter to the WebSocket request payload, and Edit 1 updates the expected assertion to match the labels that were sent in the request. These edits reference the same symbol ('labels') and form a direct test setup-assertion pair where the request data in edit 0 directly corresponds to the expected response validation in edit 1. This is a clear case of test synchronization where both edits must be made together to maintain test correctness."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits are part of the same test function and involve the exact same 'labels' field. Edit 0 adds a 'labels' parameter to the WebSocket request payload, and Edit 1 updates the expected assertion to match the labels that were sent in the request. These edits reference the same symbol ('labels') and form a direct test setup-assertion pair where the request data in edit 0 directly corresponds to the expected response validation in edit 1. This is a clear case of test synchronization where both edits must be made together to maintain test correctness."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits are part of the same test function and involve the exact same 'labels' field. Edit 0 adds a 'labels' parameter to the WebSocket request payload, and Edit 1 updates the expected assertion to match the labels that were sent in the request. These edits reference the same symbol ('labels') and form a direct test setup-assertion pair where the request data in edit 0 directly corresponds to the expected response validation in edit 1. This is a classic test synchronization pattern where both edits can be made in either order since they're both part of setting up a complete test scenario."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits are part of the same test function and involve the exact same 'labels' field. Edit 0 adds a 'labels' parameter to the WebSocket request payload, and Edit 1 updates the expected assertion to match the labels that were sent in the request. These edits reference the same symbol ('labels') and form a direct test setup-assertion pair where the request data in edit 0 directly corresponds to the expected response validation in edit 1. This is a classic test synchronization pattern where both edits can be made in either order since they're both part of setting up a complete test scenario."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits are part of the same test function and work together to test the 'labels' functionality. Edit 0 adds 'labels': ['label1', 'label2'] to the input data being sent to the API, while Edit 1 updates the expected assertion to check for the same labels using unordered(['label1', 'label2']). These edits reference the exact same 'labels' field and form a coherent test pattern where the input data and expected output must be synchronized. Either edit could be made first since both are syntactically valid, but making either edit creates an immediate prompt for the other to maintain test consistency."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits are part of the same test function and work together to test the 'labels' functionality. Edit 0 adds 'labels': ['label1', 'label2'] to the input data being sent to the API, while Edit 1 updates the expected assertion to check for the same labels using unordered(['label1', 'label2']). These edits reference the exact same 'labels' field and form a coherent test pattern where the input data and expected output must be synchronized. Either edit could be made first since both are syntactically valid, but making either edit creates an immediate prompt for the other to maintain test consistency."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Both edits are part of the same test function and work together to test the 'labels' functionality. Edit 0 adds 'labels': ['label1', 'label2'] to the request payload being sent to the API, while Edit 1 updates the expected response assertion to verify that the same labels are returned. The changed lines reference the exact same 'labels' field in the context of testing the same API endpoint within the same test function. This creates a direct, mechanically obvious linkage where adding labels to the request naturally prompts updating the corresponding assertion to verify those labels are properly handled."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Both edits are part of the same test function and work together to test the 'labels' functionality. Edit 0 adds 'labels': ['label1', 'label2'] to the request payload being sent to the API, while Edit 1 updates the expected response assertion to verify that the same labels are returned. The changed lines reference the exact same 'labels' field in the context of testing the same API endpoint within the same test function. This creates a direct, mechanically obvious linkage where adding labels to the request naturally prompts updating the corresponding assertion to verify those labels are properly handled."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits are part of the same test function and work together to test the 'labels' functionality. Edit 0 adds 'labels': ['label1', 'label2'] to the request payload being sent to the API, while Edit 1 updates the expected response assertion to check for the same labels using unordered(['label1', 'label2']). These edits reference the exact same 'labels' field and form a cohesive test pattern where the input data (edit 0) must match the expected output assertion (edit 1). This is a classic test synchronization pattern where both edits can be made in either order since they're both part of setting up a complete test case."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits are part of the same test function and work together to test the 'labels' functionality. Edit 0 adds 'labels': ['label1', 'label2'] to the request payload being sent to the API, while Edit 1 updates the expected response assertion to check for the same labels using unordered(['label1', 'label2']). These edits reference the exact same 'labels' field and form a cohesive test pattern where the input data (edit 0) must match the expected output assertion (edit 1). This is a classic test synchronization pattern where both edits can be made in either order since they're both part of setting up a complete test case."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution within the same test function: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]). They target the same type of syntactic construct (dictionary value assignments for the 'labels' key) and appear to be part of a single, contiguous refactor to update test assertions. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after pattern to identical construct types within the same context."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution within the same test function: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]). They target the same type of syntactic construct (dictionary value assignments for the 'labels' key) and appear to be part of a single, contiguous refactor to update test assertions. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after pattern to identical construct types within the same context."
        },
        {
            "src": 2,
            "tgt": 8,
            "reason": "Both edits are part of the same test function and involve the exact same 'labels' field. Edit 0 adds a 'labels' parameter to the WebSocket API call with values ['label1', 'label2'], while Edit 1 updates the expected assertion to match those same label values using unordered(['label1', 'label2']). This is a classic test-production synchronization pattern where the test input and expected output must be kept in sync for the same field. The changed lines reference the exact same 'labels' field and values, making either edit prompt the other as the immediate next step to maintain test consistency."
        },
        {
            "src": 8,
            "tgt": 2,
            "reason": "Both edits are part of the same test function and involve the exact same 'labels' field. Edit 0 adds a 'labels' parameter to the WebSocket API call with values ['label1', 'label2'], while Edit 1 updates the expected assertion to match those same label values using unordered(['label1', 'label2']). This is a classic test-production synchronization pattern where the test input and expected output must be kept in sync for the same field. The changed lines reference the exact same 'labels' field and values, making either edit prompt the other as the immediate next step to maintain test consistency."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]) in the same type of syntactic construct (dictionary assertion structures within the same test function). This represents a bulk edit/pattern synchronization where the same before\u2192after pattern is applied to the same construct type as part of a single, contiguous refactor operation."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]) in the same type of syntactic construct (dictionary assertion structures within the same test function). This represents a bulk edit/pattern synchronization where the same before\u2192after pattern is applied to the same construct type as part of a single, contiguous refactor operation."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'labels': [] to 'labels': unordered(['label1', 'label2'])) on the same type of syntactic construct (dictionary entries in test assertions) within the same test function. This represents a bulk-edit pattern where the same structural change is being applied uniformly across multiple locations as part of a single, contiguous refactor operation."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'labels': [] to 'labels': unordered(['label1', 'label2'])) on the same type of syntactic construct (dictionary entries in test assertions) within the same test function. This represents a bulk-edit pattern where the same structural change is being applied uniformly across multiple locations as part of a single, contiguous refactor operation."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]) in the same test function. They target the same type of syntactic construct (dictionary value assignments for the 'labels' key) and appear to be part of a single, contiguous refactor to update test assertions. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after transformation to identical construct types within the same test context."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]) in the same test function. They target the same type of syntactic construct (dictionary value assignments for the 'labels' key) and appear to be part of a single, contiguous refactor to update test assertions. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after transformation to identical construct types within the same test context."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]) within the same test function test_update_entity. This is a bulk-edit pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (dictionary value assignments for 'labels' key) in multiple locations within the same context. Both changes are part of a single, contiguous refactor to update test assertions."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]) within the same test function test_update_entity. This is a bulk-edit pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (dictionary value assignments for 'labels' key) in multiple locations within the same context. Both changes are part of a single, contiguous refactor to update test assertions."
        },
        {
            "src": 4,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'labels': [] to 'labels': unordered(['label1', 'label2'])) on the same type of syntactic construct (dictionary entries in test assertions) within the same test function. This represents a bulk-edit pattern where the same structural change is being applied uniformly across multiple locations as part of a single, contiguous refactor operation."
        },
        {
            "src": 8,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'labels': [] to 'labels': unordered(['label1', 'label2'])) on the same type of syntactic construct (dictionary entries in test assertions) within the same test function. This represents a bulk-edit pattern where the same structural change is being applied uniformly across multiple locations as part of a single, contiguous refactor operation."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]) in the same test function. They target the same type of syntactic construct (dictionary value assignments for the 'labels' key) and appear to be part of a single, contiguous refactor to update test assertions. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after transformation to identical construct types within the same test context."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]) in the same test function. They target the same type of syntactic construct (dictionary value assignments for the 'labels' key) and appear to be part of a single, contiguous refactor to update test assertions. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after transformation to identical construct types within the same test context."
        },
        {
            "src": 3,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]) in the same test function. They target the same type of syntactic construct (dictionary value assignments for the 'labels' key) and appear to be part of a single, contiguous refactor to update test assertions. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after transformation to identical construct types within the same test context."
        },
        {
            "src": 8,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]) in the same test function. They target the same type of syntactic construct (dictionary value assignments for the 'labels' key) and appear to be part of a single, contiguous refactor to update test assertions. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after transformation to identical construct types within the same test context."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing '\"labels\": []' to '\"labels\": unordered([\"label1\", \"label2\"])' within the same test function. This is a bulk-edit pattern where both changes target the same type of syntactic construct (dictionary value assignments for the 'labels' key) with the exact same before\u2192after transformation. The edits appear to be part of a single, contiguous refactor to update test assertions consistently within the same test method."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing '\"labels\": []' to '\"labels\": unordered([\"label1\", \"label2\"])' within the same test function. This is a bulk-edit pattern where both changes target the same type of syntactic construct (dictionary value assignments for the 'labels' key) with the exact same before\u2192after transformation. The edits appear to be part of a single, contiguous refactor to update test assertions consistently within the same test method."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution within the same test function: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]). This is a bulk-edit pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (dictionary value assignments) in two different assertion dictionaries within the same test. Both changes are part of a single, contiguous refactor to update test expectations for labels, making either edit naturally prompt the other as the next mechanical step in completing the uniform substitution."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution within the same test function: changing 'labels': [] to 'labels': unordered([\"label1\", \"label2\"]). This is a bulk-edit pattern where the same before\u2192after transformation is applied to the same type of syntactic construct (dictionary value assignments) in two different assertion dictionaries within the same test. Both changes are part of a single, contiguous refactor to update test expectations for labels, making either edit naturally prompt the other as the next mechanical step in completing the uniform substitution."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern (changing '\"labels\": [],' to '\"labels\": unordered([\"label1\", \"label2\"]),' ) within the same test function and target the same type of syntactic construct (dictionary value assignments for the 'labels' key). This represents a bulk-edit pattern where the same change is being applied to multiple similar locations within the same context as part of a single refactoring operation. The edits are mechanically linked through their identical substitution pattern and would naturally occur as part of one contiguous micro-task."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern (changing '\"labels\": [],' to '\"labels\": unordered([\"label1\", \"label2\"]),' ) within the same test function and target the same type of syntactic construct (dictionary value assignments for the 'labels' key). This represents a bulk-edit pattern where the same change is being applied to multiple similar locations within the same context as part of a single refactoring operation. The edits are mechanically linked through their identical substitution pattern and would naturally occur as part of one contiguous micro-task."
        },
        {
            "src": 5,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing '\"labels\": []' to '\"labels\": unordered([\"label1\", \"label2\"])' within the same test function. They target the same type of syntactic construct (dictionary value assignments for the 'labels' key) and appear to be part of a single, contiguous refactor to update test assertions. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after pattern to identical construct types within the same context."
        },
        {
            "src": 8,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing '\"labels\": []' to '\"labels\": unordered([\"label1\", \"label2\"])' within the same test function. They target the same type of syntactic construct (dictionary value assignments for the 'labels' key) and appear to be part of a single, contiguous refactor to update test assertions. This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after pattern to identical construct types within the same context."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern: changing '\"labels\": [],' to '\"labels\": unordered([\"label1\", \"label2\"]),' within the same test function. This is a bulk-edit pattern where both changes apply the exact same before\u2192after transformation to the same type of syntactic construct (dictionary value assignments for the 'labels' key). Both edits are part of a single, contiguous refactor to update test assertions in the same test method, making either edit naturally prompt the other as part of the same mechanical substitution task."
        },
        {
            "src": 8,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: changing '\"labels\": [],' to '\"labels\": unordered([\"label1\", \"label2\"]),' within the same test function. This is a bulk-edit pattern where both changes apply the exact same before\u2192after transformation to the same type of syntactic construct (dictionary value assignments for the 'labels' key). Both edits are part of a single, contiguous refactor to update test assertions in the same test method, making either edit naturally prompt the other as part of the same mechanical substitution task."
        },
        {
            "src": 6,
            "tgt": 8,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'labels': [] to 'labels': unordered(['label1', 'label2'])) on the same type of syntactic construct (dictionary entries in test assertions) within the same test function. This represents a bulk edit/pattern synchronization where both changes are part of a single, contiguous refactor to update test expectations. The edits can be made in either order and both reference the same structural pattern."
        },
        {
            "src": 8,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'labels': [] to 'labels': unordered(['label1', 'label2'])) on the same type of syntactic construct (dictionary entries in test assertions) within the same test function. This represents a bulk edit/pattern synchronization where both changes are part of a single, contiguous refactor to update test expectations. The edits can be made in either order and both reference the same structural pattern."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern (changing '\"labels\": []' to '\"labels\": unordered([\"label1\", \"label2\"])') within the same test function and target the same type of syntactic construct (dictionary value assignments for the 'labels' key). This represents a bulk-edit pattern where the same structural change is being applied to multiple locations within the same context as part of a single, contiguous refactor operation."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern (changing '\"labels\": []' to '\"labels\": unordered([\"label1\", \"label2\"])') within the same test function and target the same type of syntactic construct (dictionary value assignments for the 'labels' key). This represents a bulk-edit pattern where the same structural change is being applied to multiple locations within the same context as part of a single, contiguous refactor operation."
        }
    ],
    "allowed_init_edits": [
        1,
        0
    ]
}