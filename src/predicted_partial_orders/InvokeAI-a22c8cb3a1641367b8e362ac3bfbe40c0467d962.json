{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 adds 'Union' to the import statement from typing, and Edit 1 uses 'Union' in a type annotation for the return type of the build_ip_adapter function. The changed line in Edit 0 imports the exact same symbol 'Union' that is referenced in the changed lines of Edit 1. This creates an immediate, mechanically obvious code dependency - after adding Union to the import, it becomes available for use in type annotations, and after using Union in a type annotation, the import becomes necessary. Both edits reference the exact same symbol and either can prompt the other as the next contiguous action within the same micro-task."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 adds 'Union' to the import statement from typing, and Edit 1 uses 'Union' in a type annotation for the return type of the build_ip_adapter function. The changed line in Edit 0 imports the exact same symbol 'Union' that is referenced in the changed lines of Edit 1. This creates an immediate, mechanically obvious code dependency - after adding Union to the import, it becomes available for use in type annotations, and after using Union in a type annotation, the import becomes necessary. Both edits reference the exact same symbol and either can prompt the other as the next contiguous action within the same micro-task."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 changes the parameter name from 'ip_adapter_ckpt_path' to 'state_dict' in the constructor signature. Edit 1 updates the constructor body to use the new parameter name 'state_dict' instead of loading from the old 'ip_adapter_ckpt_path'. Both edits reference the exact same symbol - the constructor parameter that was renamed. After making either edit, the other becomes the immediate next step to maintain code consistency, as the parameter name change in the signature requires updating its usage in the body, and vice versa."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 changes the parameter name from 'ip_adapter_ckpt_path' to 'state_dict' in the constructor signature. Edit 1 updates the constructor body to use the new parameter name 'state_dict' instead of loading from the old 'ip_adapter_ckpt_path'. Both edits reference the exact same symbol - the constructor parameter that was renamed. After making either edit, the other becomes the immediate next step to maintain code consistency, as the parameter name change in the signature requires updating its usage in the body, and vice versa."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 changes the parameter name from 'ip_adapter_ckpt_path' to 'state_dict' in the function signature. Edit 1 removes the line that assigns the old parameter 'ip_adapter_ckpt_path' to an instance variable. After making edit 0, the parameter 'ip_adapter_ckpt_path' no longer exists, so the assignment in edit 1 would cause a NameError at runtime. However, both edits can be written and parsed in either order - the assignment line in edit 1 would simply reference an undefined variable if edit 0 is applied first, which is allowed at parse time in Python. Since both edits reference the exact same symbol 'ip_adapter_ckpt_path' and either edit naturally prompts the other as the next mechanical step in refactoring the parameter, this is bi-directional."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 changes the parameter name from 'ip_adapter_ckpt_path' to 'state_dict' in the function signature. Edit 1 removes the line that assigns the old parameter 'ip_adapter_ckpt_path' to an instance variable. After making edit 0, the parameter 'ip_adapter_ckpt_path' no longer exists, so the assignment in edit 1 would cause a NameError at runtime. However, both edits can be written and parsed in either order - the assignment line in edit 1 would simply reference an undefined variable if edit 0 is applied first, which is allowed at parse time in Python. Since both edits reference the exact same symbol 'ip_adapter_ckpt_path' and either edit naturally prompts the other as the next mechanical step in refactoring the parameter, this is bi-directional."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 changes the IPAdapter constructor signature from accepting 'ip_adapter_ckpt_path: str' to 'state_dict: dict[torch.Tensor]'. Edit 1 adds a new factory method 'build_ip_adapter' that loads the checkpoint file and creates IPAdapter instances by calling the constructor with the loaded state_dict. The changed lines in edit 1 (lines 212 and 214) directly call the IPAdapter constructor with the new signature from edit 0, creating an immediate code dependency. After making edit 0, the factory method in edit 1 becomes the natural next step to provide the checkpoint loading functionality that was removed from the constructor. The exact same symbol (IPAdapter constructor) is referenced in both edits."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 changes the IPAdapter constructor signature from accepting 'ip_adapter_ckpt_path: str' to 'state_dict: dict[torch.Tensor]'. Edit 1 adds a new factory method 'build_ip_adapter' that loads the checkpoint file and creates IPAdapter instances by calling the constructor with the loaded state_dict. The changed lines in edit 1 (lines 212 and 214) directly call the IPAdapter constructor with the new signature from edit 0, creating an immediate code dependency. After making edit 0, the factory method in edit 1 becomes the natural next step to provide the checkpoint loading functionality that was removed from the constructor. The exact same symbol (IPAdapter constructor) is referenced in both edits."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 removes the assignment of `self._ip_adapter_ckpt_path = ip_adapter_ckpt_path` and Edit 1 removes the usage of `self._ip_adapter_ckpt_path` in the torch.load call. Both edits reference the exact same symbol `self._ip_adapter_ckpt_path`. After removing the assignment in Edit 0, the usage in Edit 1 would reference an undefined attribute, making Edit 1 the immediate next step to clean up the now-invalid reference. Either edit can be made first and naturally prompts the other as the next mechanical step in removing this attribute from the class."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 removes the assignment of `self._ip_adapter_ckpt_path = ip_adapter_ckpt_path` and Edit 1 removes the usage of `self._ip_adapter_ckpt_path` in the torch.load call. Both edits reference the exact same symbol `self._ip_adapter_ckpt_path`. After removing the assignment in Edit 0, the usage in Edit 1 would reference an undefined attribute, making Edit 1 the immediate next step to clean up the now-invalid reference. Either edit can be made first and naturally prompts the other as the next mechanical step in removing this attribute from the class."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 changes the IPAdapter constructor to accept a state_dict parameter instead of loading from ip_adapter_ckpt_path. Edit 1 adds a new build_ip_adapter function that loads the state_dict from ip_adapter_ckpt_path and then calls the IPAdapter constructor with that state_dict. The changed lines reference the exact same symbol (state_dict) - edit 0 changes the constructor to use state_dict as a parameter, and edit 1 creates and passes that same state_dict parameter to the constructor. This creates a direct code dependency where the new build_ip_adapter function depends on the modified constructor signature, making them part of the same refactoring micro-task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 changes the IPAdapter constructor to accept a state_dict parameter instead of loading from ip_adapter_ckpt_path. Edit 1 adds a new build_ip_adapter function that loads the state_dict from ip_adapter_ckpt_path and then calls the IPAdapter constructor with that state_dict. The changed lines reference the exact same symbol (state_dict) - edit 0 changes the constructor to use state_dict as a parameter, and edit 1 creates and passes that same state_dict parameter to the constructor. This creates a direct code dependency where the new build_ip_adapter function depends on the modified constructor signature, making them part of the same refactoring micro-task."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 defines a new function `build_ip_adapter` in the `invokeai.backend.ip_adapter.ip_adapter` module, while Edit 1 imports that exact same function `build_ip_adapter` from the same module. The changed lines reference the exact same symbol - the `build_ip_adapter` function. After defining the function in Edit 0, importing it in Edit 1 becomes the immediate next step to make it available in the importing module. This is a classic definition-usage pattern where both edits can be staged in either order (the import won't cause a parse error, only a runtime ImportError if the function doesn't exist), making it bi-directional."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 defines a new function `build_ip_adapter` in the `invokeai.backend.ip_adapter.ip_adapter` module, while Edit 1 imports that exact same function `build_ip_adapter` from the same module. The changed lines reference the exact same symbol - the `build_ip_adapter` function. After defining the function in Edit 0, importing it in Edit 1 becomes the immediate next step to make it available in the importing module. This is a classic definition-usage pattern where both edits can be staged in either order (the import won't cause a parse error, only a runtime ImportError if the function doesn't exist), making it bi-directional."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Edit 0 defines a new function `build_ip_adapter` with parameters `ip_adapter_ckpt_path`, `device`, and `dtype`. Edit 1 removes the old conditional logic and replaces it with a call to the exact same `build_ip_adapter` function, passing the same parameters (`ip_adapter_ckpt_path`, `device`, `dtype`). The changed lines in edit 1 directly reference the function and parameters defined in edit 0. This creates an immediate code dependency where after defining the function in edit 0, the natural next step is to use it in edit 1, or vice versa. Both edits can be staged in either order since the function call in edit 1 would only fail at runtime (ImportError) if the function doesn't exist, not at parse time."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Edit 0 defines a new function `build_ip_adapter` with parameters `ip_adapter_ckpt_path`, `device`, and `dtype`. Edit 1 removes the old conditional logic and replaces it with a call to the exact same `build_ip_adapter` function, passing the same parameters (`ip_adapter_ckpt_path`, `device`, `dtype`). The changed lines in edit 1 directly reference the function and parameters defined in edit 0. This creates an immediate code dependency where after defining the function in edit 0, the natural next step is to use it in edit 1, or vice versa. Both edits can be staged in either order since the function call in edit 1 would only fail at runtime (ImportError) if the function doesn't exist, not at parse time."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 adds 'build_ip_adapter' to the import statement, and Edit 1 replaces the conditional logic that creates IPAdapter/IPAdapterPlus instances with a call to 'build_ip_adapter'. The changed lines reference the exact same symbol 'build_ip_adapter' - Edit 0 imports it and Edit 1 uses it. This creates an immediate code dependency where importing the function enables its usage in the same file. Either edit can be staged first since Python allows referencing undefined symbols at parse time (runtime NameError only), making this a bi-directional relationship where each edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 adds 'build_ip_adapter' to the import statement, and Edit 1 replaces the conditional logic that creates IPAdapter/IPAdapterPlus instances with a call to 'build_ip_adapter'. The changed lines reference the exact same symbol 'build_ip_adapter' - Edit 0 imports it and Edit 1 uses it. This creates an immediate code dependency where importing the function enables its usage in the same file. Either edit can be staged first since Python allows referencing undefined symbols at parse time (runtime NameError only), making this a bi-directional relationship where each edit naturally prompts the other as the next mechanical step."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}