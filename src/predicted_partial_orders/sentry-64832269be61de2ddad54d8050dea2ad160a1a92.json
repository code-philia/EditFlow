{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol - the field name being changed from 'config' to 'monitor_config'. Edit 0 renames the field declaration, and Edit 1 updates the corresponding reference to that field in the validation method. This creates a direct code dependency where both changed lines reference the same field symbol, making either edit prompt the other as the immediate next mechanical step to maintain code consistency."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol - the field name being changed from 'config' to 'monitor_config'. Edit 0 renames the field declaration, and Edit 1 updates the corresponding reference to that field in the validation method. This creates a direct code dependency where both changed lines reference the same field symbol, making either edit prompt the other as the immediate next mechanical step to maintain code consistency."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol - the field name being changed from 'config' to 'monitor_config'. Edit 0 renames the field definition in the serializer class, and Edit 1 updates the corresponding usage of that field in the validate method via attrs.get(). The changed lines in both edits reference the same field symbol, creating a direct code dependency where renaming the field requires updating its usage. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbol - the field name being changed from 'config' to 'monitor_config'. Edit 0 renames the field definition in the serializer class, and Edit 1 updates the corresponding usage of that field in the validate method via attrs.get(). The changed lines in both edits reference the same field symbol, creating a direct code dependency where renaming the field requires updating its usage. This is a classic definition-usage relationship for the same symbol."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits change the field name from 'config' to 'monitor_config' - edit 0 changes the field definition in the MonitorCheckInValidator serializer class, and edit 1 updates a test that uses this field. The test data structure in edit 1 must match the field name expected by the validator in edit 0. Since both edits reference the exact same field/parameter name change and the test would fail if the field names don't match, making either edit creates an immediate prompt for the other to maintain consistency."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits change the field name from 'config' to 'monitor_config' - edit 0 changes the field definition in the MonitorCheckInValidator serializer class, and edit 1 updates a test that uses this field. The test data structure in edit 1 must match the field name expected by the validator in edit 0. Since both edits reference the exact same field/parameter name change and the test would fail if the field names don't match, making either edit creates an immediate prompt for the other to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'monitor_config' in the changed lines. Edit 0 changes attrs.get('config') to attrs.get('monitor_config'), and edit 1 changes del attrs['config'] to del attrs['monitor_config']. These are part of a synchronized rename operation where the same attribute key is being changed from 'config' to 'monitor_config' throughout the function. This creates a direct code dependency - both edits must reference the same dictionary key for the code to work correctly. Either edit can be made first and the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'monitor_config' in the changed lines. Edit 0 changes attrs.get('config') to attrs.get('monitor_config'), and edit 1 changes del attrs['config'] to del attrs['monitor_config']. These are part of a synchronized rename operation where the same attribute key is being changed from 'config' to 'monitor_config' throughout the function. This creates a direct code dependency - both edits must reference the same dictionary key for the code to work correctly. Either edit can be made first and the other becomes the immediate next step to maintain consistency."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'monitor_config' within the same method. Edit 0 changes the key used to retrieve monitor_config from attrs (from 'config' to 'monitor_config'), and Edit 1 adds a comment explaining that the monitor_config attribute will be dropped in favor of validated monitor data. The changed lines in both edits directly reference the same monitor_config concept, and making either edit creates an immediate prompt for the other as part of a single refactoring task to rename and document the monitor_config handling."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'monitor_config' within the same method. Edit 0 changes the key used to retrieve monitor_config from attrs (from 'config' to 'monitor_config'), and Edit 1 adds a comment explaining that the monitor_config attribute will be dropped in favor of validated monitor data. The changed lines in both edits directly reference the same monitor_config concept, and making either edit creates an immediate prompt for the other as part of a single refactoring task to rename and document the monitor_config handling."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Edit 0 renames the field 'config' to 'monitor_config' in the MonitorCheckInValidator class. Edit 1 updates a test that uses this validator to change the JSON payload from using 'config' to 'monitor_config'. Both edits reference the exact same field name change - the validator field that was renamed from 'config' to 'monitor_config'. After making either edit, the other becomes immediately necessary to maintain consistency between the validator definition and its usage in tests. This is a bi-directional definition-usage relationship where both edits reference the same symbol (the field name in the validator)."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Edit 0 renames the field 'config' to 'monitor_config' in the MonitorCheckInValidator class. Edit 1 updates a test that uses this validator to change the JSON payload from using 'config' to 'monitor_config'. Both edits reference the exact same field name change - the validator field that was renamed from 'config' to 'monitor_config'. After making either edit, the other becomes immediately necessary to maintain consistency between the validator definition and its usage in tests. This is a bi-directional definition-usage relationship where both edits reference the same symbol (the field name in the validator)."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits change the key name from 'config' to 'monitor_config' in the same codebase. Edit 0 changes the validator to look for 'monitor_config' instead of 'config' in attrs.get(), while Edit 1 changes a test to use 'monitor_config' as the key in the request payload. These edits reference the exact same symbol (the 'monitor_config' key) and form a definition-usage relationship where the validator expects 'monitor_config' and the test provides it. Either edit can be made first without causing parse errors, but after making either edit, the other becomes the immediate next step to maintain consistency between the validator and test."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits change the key name from 'config' to 'monitor_config' in the same codebase. Edit 0 changes the validator to look for 'monitor_config' instead of 'config' in attrs.get(), while Edit 1 changes a test to use 'monitor_config' as the key in the request payload. These edits reference the exact same symbol (the 'monitor_config' key) and form a definition-usage relationship where the validator expects 'monitor_config' and the test provides it. Either edit can be made first without causing parse errors, but after making either edit, the other becomes the immediate next step to maintain consistency between the validator and test."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits change the field name from 'config' to 'monitor_config'. Edit 0 changes the field definition in the MonitorCheckInValidator serializer class, while Edit 1 updates a test that uses this field in a POST request payload. The test is directly testing the validator's behavior, so when the field name changes in the validator (edit 0), the test data must be updated to match (edit 1). This creates a direct code dependency where both edits reference the exact same field name change, and either edit naturally prompts the other as the next mechanical step to maintain consistency between the validator and its test."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits change the field name from 'config' to 'monitor_config'. Edit 0 changes the field definition in the MonitorCheckInValidator serializer class, while Edit 1 updates a test that uses this field in a POST request payload. The test is directly testing the validator's behavior, so when the field name changes in the validator (edit 0), the test data must be updated to match (edit 1). This creates a direct code dependency where both edits reference the exact same field name change, and either edit naturally prompts the other as the next mechanical step to maintain consistency between the validator and its test."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits change the same attribute name from 'config' to 'monitor_config'. Edit 0 changes the code that retrieves this attribute using attrs.get('monitor_config'), while Edit 1 changes the test data that provides this attribute in the request payload. These edits reference the exact same symbol/attribute name and form a definition-usage relationship where the test provides the data that the validator code consumes. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain consistency between the test data and the code that processes it."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits change the same attribute name from 'config' to 'monitor_config'. Edit 0 changes the code that retrieves this attribute using attrs.get('monitor_config'), while Edit 1 changes the test data that provides this attribute in the request payload. These edits reference the exact same symbol/attribute name and form a definition-usage relationship where the test provides the data that the validator code consumes. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain consistency between the test data and the code that processes it."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 adds a comment explaining that the `monitor_config` attribute will be dropped in favor of validated monitor data. Edit 1 implements this by changing the deletion from `attrs[\"config\"]` to `attrs[\"monitor_config\"]`. The comment in edit 0 directly explains the action performed in edit 1, and both edits reference the same `monitor_config` attribute. The comment creates an immediate prompt for the corresponding code change, making them part of a single micro-task where the comment documents the exact change being made."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 adds a comment explaining that the `monitor_config` attribute will be dropped in favor of validated monitor data. Edit 1 implements this by changing the deletion from `attrs[\"config\"]` to `attrs[\"monitor_config\"]`. The comment in edit 0 directly explains the action performed in edit 1, and both edits reference the same `monitor_config` attribute. The comment creates an immediate prompt for the corresponding code change, making them part of a single micro-task where the comment documents the exact change being made."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'config' to 'monitor_config' in the same type of syntactic construct (dictionary keys within client.post() calls). This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same construct type across multiple test methods. Both edits are part of a single, contiguous refactor to rename the configuration parameter consistently across the test file."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'config' to 'monitor_config' in the same type of syntactic construct (dictionary keys within client.post() calls). This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same construct type across multiple test methods. Both edits are part of a single, contiguous refactor to rename the configuration parameter consistently across the test file."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution pattern: changing from a flat dictionary with 'config' key to a reformatted dictionary with 'monitor_config' key. The before\u2192after pattern is exactly the same (renaming 'config' to 'monitor_config' and reformatting the structure), and both target the same type of syntactic construct (dictionary literals in POST request parameters). This represents a bulk uniform substitution that would naturally occur as part of a single, contiguous refactor operation."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical structural substitution pattern: changing from a flat dictionary with 'config' key to a reformatted dictionary with 'monitor_config' key. The before\u2192after pattern is exactly the same (renaming 'config' to 'monitor_config' and reformatting the structure), and both target the same type of syntactic construct (dictionary literals in POST request parameters). This represents a bulk uniform substitution that would naturally occur as part of a single, contiguous refactor operation."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits involve changing the key name from 'config' to 'monitor_config'. Edit 0 changes the key being deleted in the validator from 'config' to 'monitor_config', while Edit 1 changes the key in the test data from 'config' to 'monitor_config'. These are part of a synchronized refactoring where the same field name is being changed consistently across the codebase. The validator expects to receive data with a 'monitor_config' key (which it then deletes after processing), and the test provides data with that same key. This represents a uniform substitution pattern where the same before\u2192after change ('config' \u2192 'monitor_config') is applied to the same type of construct (dictionary key references) in both locations."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits involve changing the key name from 'config' to 'monitor_config'. Edit 0 changes the key being deleted in the validator from 'config' to 'monitor_config', while Edit 1 changes the key in the test data from 'config' to 'monitor_config'. These are part of a synchronized refactoring where the same field name is being changed consistently across the codebase. The validator expects to receive data with a 'monitor_config' key (which it then deletes after processing), and the test provides data with that same key. This represents a uniform substitution pattern where the same before\u2192after change ('config' \u2192 'monitor_config') is applied to the same type of construct (dictionary key references) in both locations."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits involve changing the key name from 'config' to 'monitor_config' in the same codebase. Edit 0 changes the validator code to delete 'monitor_config' instead of 'config', while Edit 1 changes the test data to use 'monitor_config' as the key instead of 'config'. These are part of a uniform refactoring where the same field name is being changed consistently across the codebase. Both edits reference the same conceptual field (the monitor configuration data) and represent a synchronized API contract change between the validator and its test. This is a bi-directional relationship because either edit can be made first, and after making either edit, the other becomes the immediate next step to maintain consistency in the field naming convention."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits involve changing the key name from 'config' to 'monitor_config' in the same codebase. Edit 0 changes the validator code to delete 'monitor_config' instead of 'config', while Edit 1 changes the test data to use 'monitor_config' as the key instead of 'config'. These are part of a uniform refactoring where the same field name is being changed consistently across the codebase. Both edits reference the same conceptual field (the monitor configuration data) and represent a synchronized API contract change between the validator and its test. This is a bi-directional relationship because either edit can be made first, and after making either edit, the other becomes the immediate next step to maintain consistency in the field naming convention."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits involve changing the key name from 'config' to 'monitor_config'. Edit 0 changes the key being deleted in the validator from 'config' to 'monitor_config', while Edit 1 changes the key in the test data from 'config' to 'monitor_config'. These are part of a synchronized refactoring where the same key name is being changed consistently across the codebase. This represents a bulk uniform substitution pattern where both edits perform the identical textual substitution ('config' \u2192 'monitor_config') on the same type of syntactic construct (dictionary key references). Either edit can be made first, and after making either one, the other becomes the natural next step to maintain consistency in the refactoring."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits involve changing the key name from 'config' to 'monitor_config'. Edit 0 changes the key being deleted in the validator from 'config' to 'monitor_config', while Edit 1 changes the key in the test data from 'config' to 'monitor_config'. These are part of a synchronized refactoring where the same key name is being changed consistently across the codebase. This represents a bulk uniform substitution pattern where both edits perform the identical textual substitution ('config' \u2192 'monitor_config') on the same type of syntactic construct (dictionary key references). Either edit can be made first, and after making either one, the other becomes the natural next step to maintain consistency in the refactoring."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'config' to 'monitor_config' in the same type of syntactic construct (dictionary literals within client.post() calls). This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same construct type across multiple test methods. Both edits are part of a single, contiguous refactor to rename the configuration parameter consistently across the test file."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: changing 'config' to 'monitor_config' in the same type of syntactic construct (dictionary literals within client.post() calls). This is a bulk refactoring operation where the same before\u2192after pattern is applied to the same construct type across multiple test methods. Both edits are part of a single, contiguous refactor to rename the configuration parameter consistently across the test file."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits change the key name from 'config' to 'monitor_config' in the same codebase. Edit 0 changes the validator to look for 'monitor_config' instead of 'config' in attrs.get(), while Edit 1 updates a test to use 'monitor_config' as the key in the test data. These are part of a synchronized rename operation where the exact same symbol/key name is being changed consistently across production code and test code. The changed lines reference the same string literal 'monitor_config' and this appears to be a uniform substitution pattern."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits change the key name from 'config' to 'monitor_config' in the same codebase. Edit 0 changes the validator to look for 'monitor_config' instead of 'config' in attrs.get(), while Edit 1 updates a test to use 'monitor_config' as the key in the test data. These are part of a synchronized rename operation where the exact same symbol/key name is being changed consistently across production code and test code. The changed lines reference the same string literal 'monitor_config' and this appears to be a uniform substitution pattern."
        }
    ],
    "allowed_init_edits": [
        2
    ]
}