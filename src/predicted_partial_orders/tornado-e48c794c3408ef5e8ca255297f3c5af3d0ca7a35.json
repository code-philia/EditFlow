{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 adds an 'async_timeout' parameter to the HTTPRequest constructor, while Edit 1 uses 'request.async_timeout' in the SimpleAsyncHTTPClient implementation. The changed lines reference the exact same symbol - the async_timeout attribute of the request object. Edit 0 makes the parameter available on the request object, and Edit 1 uses that exact parameter. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in implementing async timeout functionality."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 adds an 'async_timeout' parameter to the HTTPRequest constructor, while Edit 1 uses 'request.async_timeout' in the SimpleAsyncHTTPClient implementation. The changed lines reference the exact same symbol - the async_timeout attribute of the request object. Edit 0 makes the parameter available on the request object, and Edit 1 uses that exact parameter. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in implementing async timeout functionality."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds an 'async_timeout' parameter to the HTTPRequest class defaults, while Edit 1 uses 'request.async_timeout' in the SimpleAsyncHTTPClient implementation. The changed lines reference the exact same symbol - the async_timeout attribute of the request object. Edit 0 defines the default value for this attribute, and Edit 1 uses this attribute in the timeout calculation. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in implementing async timeout functionality."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds an 'async_timeout' parameter to the HTTPRequest class defaults, while Edit 1 uses 'request.async_timeout' in the SimpleAsyncHTTPClient implementation. The changed lines reference the exact same symbol - the async_timeout attribute of the request object. Edit 0 defines the default value for this attribute, and Edit 1 uses this attribute in the timeout calculation. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in implementing async timeout functionality."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'async_timeout' within the same HTTPRequest class constructor. Edit 0 adds 'async_timeout' as a parameter to the __init__ method signature, and Edit 1 assigns that parameter to self.async_timeout in the constructor body. This creates a direct, explicit code dependency where the parameter added in Edit 0 is immediately referenced and used in Edit 1. This is a classic definition-usage pattern within the same function scope, making either edit naturally prompt the other as the next mechanical step in implementing the async_timeout feature."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'async_timeout' within the same HTTPRequest class constructor. Edit 0 adds 'async_timeout' as a parameter to the __init__ method signature, and Edit 1 assigns that parameter to self.async_timeout in the constructor body. This creates a direct, explicit code dependency where the parameter added in Edit 0 is immediately referenced and used in Edit 1. This is a classic definition-usage pattern within the same function scope, making either edit naturally prompt the other as the next mechanical step in implementing the async_timeout feature."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits add the same parameter 'async_timeout' to the HTTPRequest class - one to the default values dictionary and one to the __init__ method signature. These are part of the same parameter addition operation where adding a parameter to a class requires updating both the default values and the constructor signature. The changed lines reference the exact same symbol (async_timeout parameter) and this represents a synchronized addition within the same class context. Either edit can be made first and both are part of the same contiguous micro-task of adding a new parameter to the class."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits add the same parameter 'async_timeout' to the HTTPRequest class - one to the default values dictionary and one to the __init__ method signature. These are part of the same parameter addition operation where adding a parameter to a class requires updating both the default values and the constructor signature. The changed lines reference the exact same symbol (async_timeout parameter) and this represents a synchronized addition within the same class context. Either edit can be made first and both are part of the same contiguous micro-task of adding a new parameter to the class."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 adds an 'async_timeout' attribute to the HTTPRequest class constructor, while Edit 1 uses 'request.async_timeout' in the SimpleAsyncHTTPClient implementation. The changed lines reference the exact same symbol - the async_timeout attribute of the request object. Edit 0 defines/assigns the attribute, and Edit 1 accesses/uses that same attribute. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in implementing async timeout functionality."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 adds an 'async_timeout' attribute to the HTTPRequest class constructor, while Edit 1 uses 'request.async_timeout' in the SimpleAsyncHTTPClient implementation. The changed lines reference the exact same symbol - the async_timeout attribute of the request object. Edit 0 defines/assigns the attribute, and Edit 1 accesses/uses that same attribute. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in implementing async timeout functionality."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 calls the method `_remove_timeout(key)` on line 109, while Edit 1 defines this exact same method `_remove_timeout` starting at line 122. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. In Python, a method call can be written before the method definition without causing a parse error (it would only fail at runtime), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the code linkage."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 calls the method `_remove_timeout(key)` on line 109, while Edit 1 defines this exact same method `_remove_timeout` starting at line 122. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. In Python, a method call can be written before the method definition without causing a parse error (it would only fail at runtime), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the code linkage."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 calls `self._on_timeout` (line 97) which is defined in Edit 1 (line 128). The changed lines in Edit 0 explicitly reference the exact same symbol that is being defined in Edit 1. This creates an immediate, mechanically obvious code dependency where Edit 0 cannot function without the definition provided by Edit 1. However, since this is Python, both edits can be parsed and staged in either order - the call to `_on_timeout` would only fail at runtime if the method doesn't exist. Therefore, this is a bi-directional definition-usage relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 calls `self._on_timeout` (line 97) which is defined in Edit 1 (line 128). The changed lines in Edit 0 explicitly reference the exact same symbol that is being defined in Edit 1. This creates an immediate, mechanically obvious code dependency where Edit 0 cannot function without the definition provided by Edit 1. However, since this is Python, both edits can be parsed and staged in either order - the call to `_on_timeout` would only fail at runtime if the method doesn't exist. Therefore, this is a bi-directional definition-usage relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "These edits are bi-directional neighbours because they modify the same data structure (self.queue) in a synchronized way. Edit 0 changes how items are added to the queue by including a 'key' as the first element in the tuple, while Edit 1 changes how items are removed from the queue to expect this new tuple format with the key. The changed lines in both edits directly reference the same queue data structure and implement a coordinated change to its format - from (request, callback) tuples to (key, request, callback) tuples. After making either edit, the other becomes immediately necessary to maintain consistency in how the queue is accessed, making this a direct code dependency where both edits reference the exact same data structure with synchronized modifications."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "These edits are bi-directional neighbours because they modify the same data structure (self.queue) in a synchronized way. Edit 0 changes how items are added to the queue by including a 'key' as the first element in the tuple, while Edit 1 changes how items are removed from the queue to expect this new tuple format with the key. The changed lines in both edits directly reference the same queue data structure and implement a coordinated change to its format - from (request, callback) tuples to (key, request, callback) tuples. After making either edit, the other becomes immediately necessary to maintain consistency in how the queue is accessed, making this a direct code dependency where both edits reference the exact same data structure with synchronized modifications."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds a new instance attribute 'self.waiting = {}' in the initialize method, and Edit 1 uses this exact same attribute 'self.waiting' by assigning to it with 'self.waiting[key] = (request, callback, timeout_handle)'. The changed lines reference the exact same symbol - the 'waiting' attribute of the same class instance. After making Edit 0 (adding the attribute), Edit 1 becomes the natural next step to use that attribute. Conversely, Edit 1 cannot function properly without the 'waiting' attribute being initialized first, but since Python allows attribute assignment even if the attribute wasn't explicitly initialized (it would just create it), both edits can be staged in either order without parser errors. This creates a bi-directional relationship where either edit prompts the other as the immediate next mechanical step."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds a new instance attribute 'self.waiting = {}' in the initialize method, and Edit 1 uses this exact same attribute 'self.waiting' by assigning to it with 'self.waiting[key] = (request, callback, timeout_handle)'. The changed lines reference the exact same symbol - the 'waiting' attribute of the same class instance. After making Edit 0 (adding the attribute), Edit 1 becomes the natural next step to use that attribute. Conversely, Edit 1 cannot function properly without the 'waiting' attribute being initialized first, but since Python allows attribute assignment even if the attribute wasn't explicitly initialized (it would just create it), both edits can be staged in either order without parser errors. This creates a bi-directional relationship where either edit prompts the other as the immediate next mechanical step."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Edit 0 initializes the 'waiting' attribute as an empty dictionary in the class constructor. Edit 1 adds methods that directly reference and manipulate this exact same 'waiting' attribute through dictionary operations (checking membership, accessing values, deleting keys). The changed lines in edit 1 explicitly reference the same 'waiting' symbol that was defined in edit 0. After adding the 'waiting' attribute initialization, the natural next step would be to implement methods that use this attribute, making this a direct definition-usage relationship within the same class scope."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 0 initializes the 'waiting' attribute as an empty dictionary in the class constructor. Edit 1 adds methods that directly reference and manipulate this exact same 'waiting' attribute through dictionary operations (checking membership, accessing values, deleting keys). The changed lines in edit 1 explicitly reference the same 'waiting' symbol that was defined in edit 0. After adding the 'waiting' attribute initialization, the natural next step would be to implement methods that use this attribute, making this a direct definition-usage relationship within the same class scope."
        }
    ],
    "allowed_init_edits": [
        0,
        2,
        5,
        3
    ]
}