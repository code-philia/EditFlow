{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 defines a new configuration constant ANSIBLE_SSH_EXECUTABLE with the value 'ssh', and edit 1 immediately uses that exact same constant (C.ANSIBLE_SSH_EXECUTABLE) in a comparison. The changed lines reference the exact same symbol - ANSIBLE_SSH_EXECUTABLE. After defining the constant in edit 0, edit 1 becomes the immediate next step to use it, replacing the hardcoded 'ssh' string with the configurable constant. This creates a direct definition-usage relationship where both edits reference the same symbol."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 defines a new configuration constant ANSIBLE_SSH_EXECUTABLE with the value 'ssh', and edit 1 immediately uses that exact same constant (C.ANSIBLE_SSH_EXECUTABLE) in a comparison. The changed lines reference the exact same symbol - ANSIBLE_SSH_EXECUTABLE. After defining the constant in edit 0, edit 1 becomes the immediate next step to use it, replacing the hardcoded 'ssh' string with the configurable constant. This creates a direct definition-usage relationship where both edits reference the same symbol."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: replacing hardcoded 'ssh' with 'ssh_executable = C.ANSIBLE_SSH_EXECUTABLE' followed by using the variable. This is a uniform refactoring pattern applied to the same type of syntactic construct (subprocess command construction) across different files. The edits are part of a single, contiguous refactor to make SSH executable configurable throughout the codebase. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: replacing hardcoded 'ssh' with 'ssh_executable = C.ANSIBLE_SSH_EXECUTABLE' followed by using the variable. This is a uniform refactoring pattern applied to the same type of syntactic construct (subprocess command construction) across different files. The edits are part of a single, contiguous refactor to make SSH executable configurable throughout the codebase. Either edit can be made first, and both represent the same mechanical substitution pattern."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Edit 0 defines a new configuration constant ANSIBLE_SSH_EXECUTABLE in constants.py, and Edit 1 uses that exact same constant (C.ANSIBLE_SSH_EXECUTABLE) in the ssh connection plugin. The changed lines reference the exact same symbol - ANSIBLE_SSH_EXECUTABLE. After defining the constant in Edit 0, using it in Edit 1 becomes the natural next step to utilize the newly available configuration. Both edits can be staged in either order since the usage in Edit 1 is within a comment block and won't cause parse errors, making this a bi-directional relationship where either edit prompts the other as the immediate next mechanical step."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Edit 0 defines a new configuration constant ANSIBLE_SSH_EXECUTABLE in constants.py, and Edit 1 uses that exact same constant (C.ANSIBLE_SSH_EXECUTABLE) in the ssh connection plugin. The changed lines reference the exact same symbol - ANSIBLE_SSH_EXECUTABLE. After defining the constant in Edit 0, using it in Edit 1 becomes the natural next step to utilize the newly available configuration. Both edits can be staged in either order since the usage in Edit 1 is within a comment block and won't cause parse errors, making this a bi-directional relationship where either edit prompts the other as the immediate next mechanical step."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Edit 0 defines the constant ANSIBLE_SSH_EXECUTABLE in the constants module, and Edit 1 uses that exact same constant (C.ANSIBLE_SSH_EXECUTABLE) in the ssh connection plugin. This is a classic definition-usage relationship where the changed lines reference the exact same symbol. After defining the constant in Edit 0, Edit 1 becomes the immediate next step to use it. Since this is Python, both edits can be staged in either order (the usage would only fail at runtime/import time, not at parse time), making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Edit 0 defines the constant ANSIBLE_SSH_EXECUTABLE in the constants module, and Edit 1 uses that exact same constant (C.ANSIBLE_SSH_EXECUTABLE) in the ssh connection plugin. This is a classic definition-usage relationship where the changed lines reference the exact same symbol. After defining the constant in Edit 0, Edit 1 becomes the immediate next step to use it. Since this is Python, both edits can be staged in either order (the usage would only fail at runtime/import time, not at parse time), making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits involve replacing hardcoded 'ssh' strings with the same configuration constant C.ANSIBLE_SSH_EXECUTABLE. Edit 0 replaces 'ssh' in a subprocess.Popen call with ssh_executable = C.ANSIBLE_SSH_EXECUTABLE, while Edit 1 replaces 'ssh' in a string comparison with C.ANSIBLE_SSH_EXECUTABLE. This represents a uniform substitution pattern where the same hardcoded value is being replaced with the same configuration constant across different files. Both edits are part of the same refactoring effort to make the SSH executable configurable rather than hardcoded, and they follow identical before\u2192after patterns (hardcoded 'ssh' \u2192 C.ANSIBLE_SSH_EXECUTABLE) on the same type of syntactic construct (string literals). Either edit can be made independently without causing parse errors, and both are part of a single, contiguous refactoring task."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits involve replacing hardcoded 'ssh' strings with the same configuration constant C.ANSIBLE_SSH_EXECUTABLE. Edit 0 replaces 'ssh' in a subprocess.Popen call with ssh_executable = C.ANSIBLE_SSH_EXECUTABLE, while Edit 1 replaces 'ssh' in a string comparison with C.ANSIBLE_SSH_EXECUTABLE. This represents a uniform substitution pattern where the same hardcoded value is being replaced with the same configuration constant across different files. Both edits are part of the same refactoring effort to make the SSH executable configurable rather than hardcoded, and they follow identical before\u2192after patterns (hardcoded 'ssh' \u2192 C.ANSIBLE_SSH_EXECUTABLE) on the same type of syntactic construct (string literals). Either edit can be made independently without causing parse errors, and both are part of a single, contiguous refactoring task."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 defines a new configuration constant ANSIBLE_SSH_EXECUTABLE in the constants module, while Edit 1 uses that exact same constant (C.ANSIBLE_SSH_EXECUTABLE) to replace a hardcoded 'ssh' string in the task executor. The changed lines reference the exact same symbol - ANSIBLE_SSH_EXECUTABLE. After defining the constant in Edit 0, using it in Edit 1 becomes the immediate next step to replace the hardcoded value. This is a classic definition-usage pattern where both edits can be staged in either order (the usage would cause a runtime AttributeError if staged first, but would not cause a parse error), making it bi-directional."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 defines a new configuration constant ANSIBLE_SSH_EXECUTABLE in the constants module, while Edit 1 uses that exact same constant (C.ANSIBLE_SSH_EXECUTABLE) to replace a hardcoded 'ssh' string in the task executor. The changed lines reference the exact same symbol - ANSIBLE_SSH_EXECUTABLE. After defining the constant in Edit 0, using it in Edit 1 becomes the immediate next step to replace the hardcoded value. This is a classic definition-usage pattern where both edits can be staged in either order (the usage would cause a runtime AttributeError if staged first, but would not cause a parse error), making it bi-directional."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 defines/assigns the variable 'ssh_executable' with the value C.ANSIBLE_SSH_EXECUTABLE, and Edit 1 uses that exact same variable 'ssh_executable' in the args tuple construction. The changed lines reference the exact same symbol - the variable 'ssh_executable' defined in edit 0 and used in edit 1. After making edit 0, edit 1 becomes the immediate next step to actually use the newly defined variable. This is a classic definition-usage pattern within the same function scope where both edits reference the exact same symbol."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 defines/assigns the variable 'ssh_executable' with the value C.ANSIBLE_SSH_EXECUTABLE, and Edit 1 uses that exact same variable 'ssh_executable' in the args tuple construction. The changed lines reference the exact same symbol - the variable 'ssh_executable' defined in edit 0 and used in edit 1. After making edit 0, edit 1 becomes the immediate next step to actually use the newly defined variable. This is a classic definition-usage pattern within the same function scope where both edits reference the exact same symbol."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string 'ssh' with the variable 'ssh_executable' in tuple assignments to 'args'. Both changed lines are within the same function (_exec_command) and represent the same type of syntactic construct (tuple assignments). This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after pattern ('ssh' \u2192 ssh_executable) to identical construct types within the same context. Either edit could be made first, and after making one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: replacing the hardcoded string 'ssh' with the variable 'ssh_executable' in tuple assignments to 'args'. Both changed lines are within the same function (_exec_command) and represent the same type of syntactic construct (tuple assignments). This is a clear case of bulk-edit pattern synchronization where both edits apply the same before\u2192after pattern ('ssh' \u2192 ssh_executable) to identical construct types within the same context. Either edit could be made first, and after making one, the other becomes an obvious next step to complete the uniform substitution pattern."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits are part of the same refactoring pattern - replacing hardcoded 'ssh' string literals with the constant C.ANSIBLE_SSH_EXECUTABLE. Edit 0 changes a conditional check from 'ssh' to C.ANSIBLE_SSH_EXECUTABLE, while Edit 1 changes a commented-out code section to use a variable assigned to C.ANSIBLE_SSH_EXECUTABLE instead of the hardcoded 'ssh' string. This is a uniform textual substitution pattern where both edits are replacing the same hardcoded string with the same constant reference, targeting the same type of syntactic construct (string literals used to reference the ssh executable). Both edits can be applied in either order as they are independent changes that are part of the same bulk refactoring operation."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits are part of the same refactoring pattern - replacing hardcoded 'ssh' string literals with the constant C.ANSIBLE_SSH_EXECUTABLE. Edit 0 changes a conditional check from 'ssh' to C.ANSIBLE_SSH_EXECUTABLE, while Edit 1 changes a commented-out code section to use a variable assigned to C.ANSIBLE_SSH_EXECUTABLE instead of the hardcoded 'ssh' string. This is a uniform textual substitution pattern where both edits are replacing the same hardcoded string with the same constant reference, targeting the same type of syntactic construct (string literals used to reference the ssh executable). Both edits can be applied in either order as they are independent changes that are part of the same bulk refactoring operation."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 defines/assigns the variable 'ssh_executable' with the value C.ANSIBLE_SSH_EXECUTABLE, and Edit 1 uses that exact same variable 'ssh_executable' in place of the hardcoded 'ssh' string in the args tuple. The changed lines reference the exact same symbol - the variable 'ssh_executable'. After making either edit, the other becomes the immediate next step: if you define ssh_executable without using it, you'd naturally use it next; if you try to use ssh_executable without defining it, you'd get a NameError at runtime but both edits can be parsed and staged in either order in Python. This is a classic definition-usage relationship within the same function scope."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 defines/assigns the variable 'ssh_executable' with the value C.ANSIBLE_SSH_EXECUTABLE, and Edit 1 uses that exact same variable 'ssh_executable' in place of the hardcoded 'ssh' string in the args tuple. The changed lines reference the exact same symbol - the variable 'ssh_executable'. After making either edit, the other becomes the immediate next step: if you define ssh_executable without using it, you'd naturally use it next; if you try to use ssh_executable without defining it, you'd get a NameError at runtime but both edits can be parsed and staged in either order in Python. This is a classic definition-usage relationship within the same function scope."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform the same structural substitution pattern: replacing hardcoded 'ssh' string with 'ssh_executable' variable. Edit 0 changes 'ssh' to 'ssh_executable' in an active code line, while Edit 1 makes the identical substitution in a commented code block. Both edits target the same type of syntactic construct (string literals representing the ssh command) and apply the exact same before\u2192after pattern ('ssh' \u2192 'ssh_executable'). This represents a uniform, contiguous refactoring operation where both changes would naturally occur as part of the same search-and-replace sweep to eliminate hardcoded ssh references throughout the codebase."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform the same structural substitution pattern: replacing hardcoded 'ssh' string with 'ssh_executable' variable. Edit 0 changes 'ssh' to 'ssh_executable' in an active code line, while Edit 1 makes the identical substitution in a commented code block. Both edits target the same type of syntactic construct (string literals representing the ssh command) and apply the exact same before\u2192after pattern ('ssh' \u2192 'ssh_executable'). This represents a uniform, contiguous refactoring operation where both changes would naturally occur as part of the same search-and-replace sweep to eliminate hardcoded ssh references throughout the codebase."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform the same structural substitution pattern: replacing hardcoded 'ssh' string with ssh_executable variable. Edit 0 changes 'ssh' to ssh_executable in an active code line, while Edit 1 makes the identical substitution in a commented line. This represents a uniform refactoring pattern applied to the same type of syntactic construct (ssh command construction) within the same class. Both edits are part of the same refactoring effort to make SSH executable configurable throughout the codebase."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform the same structural substitution pattern: replacing hardcoded 'ssh' string with ssh_executable variable. Edit 0 changes 'ssh' to ssh_executable in an active code line, while Edit 1 makes the identical substitution in a commented line. This represents a uniform refactoring pattern applied to the same type of syntactic construct (ssh command construction) within the same class. Both edits are part of the same refactoring effort to make SSH executable configurable throughout the codebase."
        }
    ],
    "allowed_init_edits": [
        2,
        1,
        3,
        5,
        4
    ]
}