{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 renames the class from 'htmlHandler' to 'HTMLHandler', and Edit 1 updates the instantiation of that same class to use the new name 'HTMLHandler'. Both edits reference the exact same symbol (the htmlHandler/HTMLHandler class). After renaming the class definition, the instantiation must be updated to use the new name, making this a direct definition-usage relationship. In Python, either edit can be staged first since both are syntactically valid - the class definition change doesn't break parsing of the instantiation line, and vice versa. This is a bi-directional relationship where making either edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 renames the class from 'htmlHandler' to 'HTMLHandler', and Edit 1 updates the instantiation of that same class to use the new name 'HTMLHandler'. Both edits reference the exact same symbol (the htmlHandler/HTMLHandler class). After renaming the class definition, the instantiation must be updated to use the new name, making this a direct definition-usage relationship. In Python, either edit can be staged first since both are syntactically valid - the class definition change doesn't break parsing of the instantiation line, and vice versa. This is a bi-directional relationship where making either edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits change the exact same symbol 'xp_cmdshell' to 'Xp_cmdshell' - one in the import statement and one in the class inheritance. This is a uniform textual substitution of the same identifier across two different syntactic contexts (import and class definition). After making either edit, the other becomes immediately necessary to maintain consistency and avoid NameError when the class tries to inherit from the renamed symbol. Both edits reference the exact same symbol and form part of a single refactoring operation."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits change the exact same symbol 'xp_cmdshell' to 'Xp_cmdshell' - one in the import statement and one in the class inheritance. This is a uniform textual substitution of the same identifier across two different syntactic contexts (import and class definition). After making either edit, the other becomes immediately necessary to maintain consistency and avoid NameError when the class tries to inherit from the renamed symbol. Both edits reference the exact same symbol and form part of a single refactoring operation."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'xp_cmdshell' to 'Xp_cmdshell') within the same class context. Edit 0 changes the class inheritance declaration, while Edit 1 changes the corresponding docstring comment. These are part of a single, contiguous refactoring operation to standardize the capitalization of the class name throughout the same class definition. Both edits reference the same symbol (the class name) and represent a synchronized pattern substitution that would naturally occur together in one uninterrupted micro-task."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern (changing 'xp_cmdshell' to 'Xp_cmdshell') within the same class context. Edit 0 changes the class inheritance declaration, while Edit 1 changes the corresponding docstring comment. These are part of a single, contiguous refactoring operation to standardize the capitalization of the class name throughout the same class definition. Both edits reference the same symbol (the class name) and represent a synchronized pattern substitution that would naturally occur together in one uninterrupted micro-task."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits change the exact same symbol 'xp_cmdshell' to 'Xp_cmdshell' - one in the import statement and one in the constructor call. This is a uniform textual substitution of the same identifier across different syntactic contexts (import vs method call). After making either edit, the other becomes immediately necessary to maintain consistency and avoid NameError at runtime. The changed lines reference the exact same symbol being renamed."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits change the exact same symbol 'xp_cmdshell' to 'Xp_cmdshell' - one in the import statement and one in the constructor call. This is a uniform textual substitution of the same identifier across different syntactic contexts (import vs method call). After making either edit, the other becomes immediately necessary to maintain consistency and avoid NameError at runtime. The changed lines reference the exact same symbol being renamed."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 changes an import statement from 'xp_cmdshell' to 'Xp_cmdshell', while Edit 1 changes the class definition from 'class xp_cmdshell:' to 'class Xp_cmdshell:'. Both edits reference the exact same symbol - the class name being renamed from xp_cmdshell to Xp_cmdshell. This is a classic definition-usage relationship where the class definition change and the import change must be synchronized. Either edit can be made first since Python allows importing undefined names (they fail at runtime, not parse time), making this bi-directional. After making either edit, the other becomes the immediate next step to maintain code consistency."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 changes an import statement from 'xp_cmdshell' to 'Xp_cmdshell', while Edit 1 changes the class definition from 'class xp_cmdshell:' to 'class Xp_cmdshell:'. Both edits reference the exact same symbol - the class name being renamed from xp_cmdshell to Xp_cmdshell. This is a classic definition-usage relationship where the class definition change and the import change must be synchronized. Either edit can be made first since Python allows importing undefined names (they fail at runtime, not parse time), making this bi-directional. After making either edit, the other becomes the immediate next step to maintain code consistency."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits change the exact same symbol 'xp_cmdshell' to 'Xp_cmdshell'. Edit 1 changes the class definition, and Edit 0 changes the inheritance reference to that same class. This creates a direct code dependency where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a single refactoring task. The changed lines in both edits explicitly reference the same class symbol."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits change the exact same symbol 'xp_cmdshell' to 'Xp_cmdshell'. Edit 1 changes the class definition, and Edit 0 changes the inheritance reference to that same class. This creates a direct code dependency where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step in a single refactoring task. The changed lines in both edits explicitly reference the same class symbol."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 1 renames the class from 'xp_cmdshell' to 'Xp_cmdshell' in its definition, and Edit 0 updates the call to the constructor to use the new class name 'Xp_cmdshell'. Both edits reference the exact same symbol - the class name that is being renamed. After renaming the class definition, the constructor call must be updated to match the new name, or vice versa. This creates an immediate, mechanically obvious code-driven prompt where either edit naturally leads to the other as the next contiguous action. Both edits can be staged in either order without causing parse errors in Python."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 1 renames the class from 'xp_cmdshell' to 'Xp_cmdshell' in its definition, and Edit 0 updates the call to the constructor to use the new class name 'Xp_cmdshell'. Both edits reference the exact same symbol - the class name that is being renamed. After renaming the class definition, the constructor call must be updated to match the new name, or vice versa. This creates an immediate, mechanically obvious code-driven prompt where either edit naturally leads to the other as the next contiguous action. Both edits can be staged in either order without causing parse errors in Python."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits change references to the exact same symbol from 'xp_cmdshell' to 'Xp_cmdshell'. Edit 0 changes the class inheritance declaration, and Edit 1 changes the constructor call to the parent class. These are part of a uniform textual substitution pattern (xp_cmdshell \u2192 Xp_cmdshell) applied to the same type of syntactic construct (class references). Both edits reference the exact same symbol and represent a synchronized renaming operation that would naturally occur as part of a single, contiguous refactoring task. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to maintain consistency."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits change references to the exact same symbol from 'xp_cmdshell' to 'Xp_cmdshell'. Edit 0 changes the class inheritance declaration, and Edit 1 changes the constructor call to the parent class. These are part of a uniform textual substitution pattern (xp_cmdshell \u2192 Xp_cmdshell) applied to the same type of syntactic construct (class references). Both edits reference the exact same symbol and represent a synchronized renaming operation that would naturally occur as part of a single, contiguous refactoring task. Either edit can be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to maintain consistency."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform identical textual substitution changing 'xp_cmdshell' to 'Xp_cmdshell' - one in a docstring comment and one in a constructor call. This appears to be part of a single, contiguous refactoring operation to standardize the capitalization of the class name. Both edits involve the same before\u2192after pattern ('xp_cmdshell' \u2192 'Xp_cmdshell') and are clearly part of the same rename/capitalization fix. Either edit could be made first, and after making either one, the other would be the natural next step to complete the consistent renaming."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitution changing 'xp_cmdshell' to 'Xp_cmdshell' - one in a docstring comment and one in a constructor call. This appears to be part of a single, contiguous refactoring operation to standardize the capitalization of the class name. Both edits involve the same before\u2192after pattern ('xp_cmdshell' \u2192 'Xp_cmdshell') and are clearly part of the same rename/capitalization fix. Either edit could be made first, and after making either one, the other would be the natural next step to complete the consistent renaming."
        }
    ],
    "allowed_init_edits": [
        0,
        1
    ]
}