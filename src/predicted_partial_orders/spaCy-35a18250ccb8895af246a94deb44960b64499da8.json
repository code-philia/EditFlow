{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: adding the same parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) within the same test file context. This represents a bulk edit/pattern synchronization where both edits are part of a single, contiguous refactor applying the same before\u2192after pattern. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the codebase."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding the same parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) within the same test file context. This represents a bulk edit/pattern synchronization where both edits are part of a single, contiguous refactor applying the same before\u2192after pattern. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the codebase."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Both edits perform identical textual substitutions on the same type of syntactic construct. Each edit adds the exact same parameter 'parse=False' to function calls of the same function 'EN()'. This represents a uniform, synchronized pattern substitution where both edits are part of the same refactoring operation - adding the parse=False parameter to multiple EN() calls. The changes are structurally identical and would naturally occur as part of a single, contiguous micro-task of updating all EN() calls to include the parse parameter."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Both edits perform identical textual substitutions on the same type of syntactic construct. Each edit adds the exact same parameter 'parse=False' to function calls of the same function 'EN()'. This represents a uniform, synchronized pattern substitution where both edits are part of the same refactoring operation - adding the parse=False parameter to multiple EN() calls. The changes are structurally identical and would naturally occur as part of a single, contiguous micro-task of updating all EN() calls to include the parse parameter."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits follow the exact same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits follow the exact same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits apply the exact same before\u2192after transformation (EN(string) \u2192 EN(string, parse=False)) to the same type of syntactic construct (function calls to EN). This represents a bulk uniform substitution that would naturally occur as part of a single, contiguous refactor operation. Either edit could be made first, and after making one, the other would be the immediate next step in completing the uniform parameter addition across all EN() calls."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits apply the exact same before\u2192after transformation (EN(string) \u2192 EN(string, parse=False)) to the same type of syntactic construct (function calls to EN). This represents a bulk uniform substitution that would naturally occur as part of a single, contiguous refactor operation. Either edit could be made first, and after making one, the other would be the immediate next step in completing the uniform parameter addition across all EN() calls."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changes are structurally identical (same before\u2192after pattern) and target the same type of syntactic construct (function calls to EN). This appears to be part of a single, contiguous refactor to disable parsing across multiple test functions. Both edits reference the same function 'EN' and apply the same modification pattern, making this a bulk-edit synchronization where either edit could be made first and would naturally prompt the other as part of the same refactoring sweep."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changes are structurally identical (same before\u2192after pattern) and target the same type of syntactic construct (function calls to EN). This appears to be part of a single, contiguous refactor to disable parsing across multiple test functions. Both edits reference the same function 'EN' and apply the same modification pattern, making this a bulk-edit synchronization where either edit could be made first and would naturally prompt the other as part of the same refactoring sweep."
        },
        {
            "src": 0,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits follow the exact same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk uniform substitution that would naturally occur as part of a single, contiguous refactoring task. Either edit could be made first, and after making one, the other would be the next mechanical step in completing the uniform parameter addition across the test file."
        },
        {
            "src": 7,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits follow the exact same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk uniform substitution that would naturally occur as part of a single, contiguous refactoring task. Either edit could be made first, and after making one, the other would be the next mechanical step in completing the uniform parameter addition across the test file."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: adding the same parameter 'parse=False' to function calls with the same name 'EN'. This represents a bulk edit where the same before\u2192after pattern (adding 'parse=False' parameter) is applied to the same type of syntactic construct (function calls to EN). Both edits are part of a single, contiguous refactor to add the parse=False parameter to multiple EN function calls within the same test file. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding the same parameter 'parse=False' to function calls with the same name 'EN'. This represents a bulk edit where the same before\u2192after pattern (adding 'parse=False' parameter) is applied to the same type of syntactic construct (function calls to EN). Both edits are part of a single, contiguous refactor to add the parse=False parameter to multiple EN function calls within the same test file. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changes follow the same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to EN). This appears to be part of a single, contiguous refactor to disable parsing across multiple test cases. Both edits reference the same function symbol 'EN' and apply the same structural modification, making them part of a bulk-edit pattern synchronization."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changes follow the same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to EN). This appears to be part of a single, contiguous refactor to disable parsing across multiple test cases. Both edits reference the same function symbol 'EN' and apply the same structural modification, making them part of a bulk-edit pattern synchronization."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits follow the exact same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk uniform substitution where both edits are part of the same contiguous refactoring task to add the parse=False parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform parameter addition across the test file."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits follow the exact same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk uniform substitution where both edits are part of the same contiguous refactoring task to add the parse=False parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform parameter addition across the test file."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changes are structurally identical (same before\u2192after pattern) and target the same type of syntactic construct (function calls to EN). This appears to be part of a single, contiguous refactor to disable parsing across multiple test functions. Both edits reference the same function 'EN' and apply the same modification pattern, making this a bulk-edit synchronization where either edit could be made first and would naturally prompt the other as part of the same refactoring sweep."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changes are structurally identical (same before\u2192after pattern) and target the same type of syntactic construct (function calls to EN). This appears to be part of a single, contiguous refactor to disable parsing across multiple test functions. Both edits reference the same function 'EN' and apply the same modification pattern, making this a bulk-edit synchronization where either edit could be made first and would naturally prompt the other as part of the same refactoring sweep."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) and appear to be part of a single, contiguous refactor to disable parsing in test cases. The changes follow the bulk-edit pattern where the same before\u2192after transformation is applied to multiple instances of the same construct type."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) and appear to be part of a single, contiguous refactor to disable parsing in test cases. The changes follow the bulk-edit pattern where the same before\u2192after transformation is applied to multiple instances of the same construct type."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits involve the exact same type of syntactic construct (function calls to EN) and apply the same before\u2192after transformation pattern. This represents a bulk edit or pattern synchronization where both changes are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern across the test file."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits involve the exact same type of syntactic construct (function calls to EN) and apply the same before\u2192after transformation pattern. This represents a bulk edit or pattern synchronization where both changes are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern across the test file."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines follow the exact same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk uniform substitution where both edits are part of the same contiguous refactoring operation to add the parse=False parameter consistently across test functions. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the codebase."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines follow the exact same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk uniform substitution where both edits are part of the same contiguous refactoring operation to add the parse=False parameter consistently across test functions. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the codebase."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Both edits perform identical textual substitutions on the same type of syntactic construct. Each edit adds the exact same parameter 'parse=False' to EN() function calls within test functions. This represents a uniform, synchronized pattern change across multiple locations of the same construct type (function calls to EN). The edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Both edits perform identical textual substitutions on the same type of syntactic construct. Each edit adds the exact same parameter 'parse=False' to EN() function calls within test functions. This represents a uniform, synchronized pattern change across multiple locations of the same construct type (function calls to EN). The edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: adding the same parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) within the same test file context. This represents a bulk edit or pattern synchronization where the same modification is being applied uniformly across multiple similar locations. Either edit could be made first, and after making one, the other would be a natural continuation of the same refactoring pattern."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: adding the same parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) within the same test file context. This represents a bulk edit or pattern synchronization where the same modification is being applied uniformly across multiple similar locations. Either edit could be made first, and after making one, the other would be a natural continuation of the same refactoring pattern."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) and appear to be part of a single, contiguous refactor to add the same parameter across multiple test functions. The changed lines follow the exact same before\u2192after pattern (EN(string) \u2192 EN(string, parse=False)) and both reference calls to the same EN function symbol."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) and appear to be part of a single, contiguous refactor to add the same parameter across multiple test functions. The changed lines follow the exact same before\u2192after pattern (EN(string) \u2192 EN(string, parse=False)) and both reference calls to the same EN function symbol."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits follow the exact same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to the same EN function). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple calls of the same function. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the parameter usage pattern."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits follow the exact same before\u2192after pattern (EN(\"text\") \u2192 EN(\"text\", parse=False)) and target the same type of syntactic construct (function calls to the same EN function). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple calls of the same function. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the parameter usage pattern."
        },
        {
            "src": 8,
            "tgt": 1,
            "reason": "Edit 0 changes a call to EN() by adding a parse=False parameter, while Edit 1 changes the definition of EN() to return English().tokenizer instead of English(). These edits reference the exact same symbol (the EN function) - one modifies how it's called and the other modifies what it returns. However, the relationship is ordered because Edit 1 must come first. If Edit 0 is applied first (adding parse=False to the call), it would fail because the original EN() function returns an English() object which doesn't have a parse parameter. Only after Edit 1 changes EN() to return a tokenizer (which does have a parse parameter) can Edit 0 be successfully applied. This creates a parse-time/execution dependency where Edit 0 cannot work until Edit 1 is in place."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitutions within the same function, adding the same parameter 'parse=False' to EN() calls. This is a uniform pattern substitution targeting the same type of syntactic construct (function calls to EN) within the same test function. Both changes are part of a single, contiguous refactor to add the parse=False parameter to multiple EN() calls. Either edit can be made first, and both represent the same mechanical change pattern."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitutions within the same function, adding the same parameter 'parse=False' to EN() calls. This is a uniform pattern substitution targeting the same type of syntactic construct (function calls to EN) within the same test function. Both changes are part of a single, contiguous refactor to add the parse=False parameter to multiple EN() calls. Either edit can be made first, and both represent the same mechanical change pattern."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Both edits perform identical textual substitution within the same function, adding the same parameter 'parse=False' to EN() calls. This is a uniform pattern substitution targeting the same type of syntactic construct (function calls to EN) within the same test function. Both changes are part of a single, contiguous refactor to add the parse=False parameter to multiple EN() calls in the same test method."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Both edits perform identical textual substitution within the same function, adding the same parameter 'parse=False' to EN() calls. This is a uniform pattern substitution targeting the same type of syntactic construct (function calls to EN) within the same test function. Both changes are part of a single, contiguous refactor to add the parse=False parameter to multiple EN() calls in the same test method."
        },
        {
            "src": 2,
            "tgt": 8,
            "reason": "Edit 0 changes a call to EN() by adding a parse=False parameter, while Edit 1 changes the EN() fixture definition to return English().tokenizer instead of English(). These edits reference the same EN symbol - Edit 0 calls EN() and Edit 1 defines what EN() returns. However, the changed lines reference different aspects: Edit 0 is about how EN is called (adding a parameter), while Edit 1 is about what EN returns (changing the return value). The parameter addition in Edit 0 suggests EN should behave like a tokenizer (which typically has a parse parameter), and Edit 1 makes EN return a tokenizer object. This creates a direct code dependency where changing EN's return type (Edit 1) necessitates updating how it's called (Edit 0) to match the new interface. Both edits can be staged in either order without parse errors, making this bi-directional."
        },
        {
            "src": 8,
            "tgt": 2,
            "reason": "Edit 0 changes a call to EN() by adding a parse=False parameter, while Edit 1 changes the EN() fixture definition to return English().tokenizer instead of English(). These edits reference the same EN symbol - Edit 0 calls EN() and Edit 1 defines what EN() returns. However, the changed lines reference different aspects: Edit 0 is about how EN is called (adding a parameter), while Edit 1 is about what EN returns (changing the return value). The parameter addition in Edit 0 suggests EN should behave like a tokenizer (which typically has a parse parameter), and Edit 1 makes EN return a tokenizer object. This creates a direct code dependency where changing EN's return type (Edit 1) necessitates updating how it's called (Edit 0) to match the new interface. Both edits can be staged in either order without parse errors, making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits apply the exact same before\u2192after transformation (adding ', parse=False' parameter) to the same type of syntactic construct (function calls to EN). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform parameter addition across the test file."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits apply the exact same before\u2192after transformation (adding ', parse=False' parameter) to the same type of syntactic construct (function calls to EN). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform parameter addition across the test file."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: adding the same parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) within the same test file context. This represents a bulk edit/pattern synchronization where both edits are part of a single, contiguous refactor applying the same before\u2192after pattern. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the codebase."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: adding the same parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) within the same test file context. This represents a bulk edit/pattern synchronization where both edits are part of a single, contiguous refactor applying the same before\u2192after pattern. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the codebase."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits apply the exact same before\u2192after transformation (adding ', parse=False' parameter) to the same type of syntactic construct (function calls to EN). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform parameter addition across the codebase."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits apply the exact same before\u2192after transformation (adding ', parse=False' parameter) to the same type of syntactic construct (function calls to EN). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform parameter addition across the codebase."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits perform identical textual substitution within the same test function, adding the same parameter 'parse=False' to EN() calls. This is a bulk-edit pattern where both changes apply the same before\u2192after transformation (adding parse=False parameter) to the same type of syntactic construct (EN function calls). The edits are part of a single, contiguous refactor within the same function scope, making either edit naturally prompt the other as part of the same mechanical substitution task."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits perform identical textual substitution within the same test function, adding the same parameter 'parse=False' to EN() calls. This is a bulk-edit pattern where both changes apply the same before\u2192after transformation (adding parse=False parameter) to the same type of syntactic construct (EN function calls). The edits are part of a single, contiguous refactor within the same function scope, making either edit naturally prompt the other as part of the same mechanical substitution task."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines follow the exact same before\u2192after pattern (EN(\"string\") \u2192 EN(\"string\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines follow the exact same before\u2192after pattern (EN(\"string\") \u2192 EN(\"string\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits apply the exact same before\u2192after transformation (adding ', parse=False' parameter) to the same type of syntactic construct (function calls to EN). This represents a bulk-edit pattern where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform parameter addition across the test file."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits apply the exact same before\u2192after transformation (adding ', parse=False' parameter) to the same type of syntactic construct (function calls to EN). This represents a bulk-edit pattern where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform parameter addition across the test file."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits follow the exact same before\u2192after pattern (EN(\"string\") \u2192 EN(\"string\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. The changed lines in both edits follow the exact same before\u2192after pattern (EN(\"string\") \u2192 EN(\"string\", parse=False)) and target the same type of syntactic construct (function calls to EN). This represents a bulk edit or pattern synchronization where both edits are part of a single, contiguous refactor to add the same parameter to multiple EN() calls. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution pattern."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits perform identical textual substitution within the same function, adding the same parameter 'parse=False' to EN() calls. This is a uniform pattern substitution on the same type of syntactic construct (function calls) within the same test function. Both edits reference the same EN function and apply the identical before\u2192after pattern. Either edit can be made first, and after making either, the other becomes a natural next step to maintain consistency in the same micro-task of adding parse=False to all EN calls in this test."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits perform identical textual substitution within the same function, adding the same parameter 'parse=False' to EN() calls. This is a uniform pattern substitution on the same type of syntactic construct (function calls) within the same test function. Both edits reference the same EN function and apply the identical before\u2192after pattern. Either edit can be made first, and after making either, the other becomes a natural next step to maintain consistency in the same micro-task of adding parse=False to all EN calls in this test."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Edit 0 adds a `parse=False` parameter to a call to `EN()`, while Edit 1 changes the `EN()` fixture to return `English().tokenizer` instead of `English()`. These edits reference the same `EN` symbol - Edit 0 calls it and Edit 1 defines it. The change in Edit 1 affects what `EN()` returns (now a tokenizer object), and Edit 0 adapts the call to work with this new return type by adding `parse=False`. This creates a direct code dependency where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 8,
            "tgt": 7,
            "reason": "Edit 0 adds a `parse=False` parameter to a call to `EN()`, while Edit 1 changes the `EN()` fixture to return `English().tokenizer` instead of `English()`. These edits reference the same `EN` symbol - Edit 0 calls it and Edit 1 defines it. The change in Edit 1 affects what `EN()` returns (now a tokenizer object), and Edit 0 adapts the call to work with this new return type by adding `parse=False`. This creates a direct code dependency where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) within the same test file. This represents a bulk-edit pattern where the same modification is being applied uniformly across multiple locations as part of a single refactoring operation. The edits are mechanically identical and would naturally occur in one contiguous micro-task."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits perform an identical textual substitution pattern: adding the parameter 'parse=False' to EN() function calls. They target the same type of syntactic construct (function calls to EN) within the same test file. This represents a bulk-edit pattern where the same modification is being applied uniformly across multiple locations as part of a single refactoring operation. The edits are mechanically identical and would naturally occur in one contiguous micro-task."
        }
    ],
    "allowed_init_edits": [
        8
    ]
}