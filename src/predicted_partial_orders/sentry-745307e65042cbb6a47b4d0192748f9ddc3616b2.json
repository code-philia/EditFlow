{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 6,
            "reason": "Both edits reference the exact same task symbol 'sentry.tasks.check_update'. Edit 0 adds this task to the CELERYBEAT_SCHEDULE configuration, while Edit 1 modifies the task definition from a periodic_task to a regular task with the same name. These edits are part of a coordinated change to move task scheduling from decorator-based periodic tasks to centralized beat scheduling. The changed lines in both edits explicitly reference the same task symbol, creating a direct code dependency where either edit naturally prompts the other as the next mechanical step in this refactoring."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Both edits reference the exact same task symbol 'sentry.tasks.check_update'. Edit 0 adds this task to the CELERYBEAT_SCHEDULE configuration, while Edit 1 modifies the task definition from a periodic_task to a regular task with the same name. These edits are part of a coordinated change to move task scheduling from decorator-based periodic tasks to centralized beat scheduling. The changed lines in both edits explicitly reference the same task symbol, creating a direct code dependency where either edit naturally prompts the other as the next mechanical step in this refactoring."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 imports `timedelta` from datetime module, and Edit 1 uses `timedelta` in two places within the CELERYBEAT_SCHEDULE configuration. The changed lines in Edit 1 directly reference the exact same symbol (`timedelta`) that is imported in Edit 0. This creates an immediate code dependency - after importing `timedelta` in Edit 0, using it in Edit 1 becomes the natural next step. Both edits can be staged in either order since Python allows usage of undefined symbols at parse time (only failing at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical action."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 imports `timedelta` from datetime module, and Edit 1 uses `timedelta` in two places within the CELERYBEAT_SCHEDULE configuration. The changed lines in Edit 1 directly reference the exact same symbol (`timedelta`) that is imported in Edit 0. This creates an immediate code dependency - after importing `timedelta` in Edit 0, using it in Edit 1 becomes the natural next step. Both edits can be staged in either order since Python allows usage of undefined symbols at parse time (only failing at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical action."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits perform identical import modifications: removing 'periodic_task' and 'crontab' imports from 'celery.task' and 'celery.task.schedules' respectively, while keeping/adding the 'task' import. This represents a uniform bulk substitution pattern across multiple files, likely part of a single refactoring operation to clean up unused Celery imports. The edits target the same type of syntactic construct (import statements) with identical before\u2192after patterns, making them part of a synchronized multi-file change where either edit could be performed first as part of the same contiguous refactoring task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits perform identical import modifications: removing 'periodic_task' and 'crontab' imports from 'celery.task' and 'celery.task.schedules' respectively, while keeping/adding the 'task' import. This represents a uniform bulk substitution pattern across multiple files, likely part of a single refactoring operation to clean up unused Celery imports. The edits target the same type of syntactic construct (import statements) with identical before\u2192after patterns, making them part of a synchronized multi-file change where either edit could be performed first as part of the same contiguous refactoring task."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 removes the import of 'periodic_task' and 'crontab' from celery.task, while Edit 1 changes the decorator from '@periodic_task' to '@task' and removes the 'crontab' usage. The changed lines in both edits reference the exact same symbols: 'periodic_task' and 'crontab'. Edit 0 removes these symbols from the import statement, and Edit 1 removes their usage in the decorator. This creates a direct code dependency where removing the import makes the usage invalid, and changing the usage makes the import unnecessary. Both edits are part of the same refactoring task to replace periodic_task with regular task decorator."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 removes the import of 'periodic_task' and 'crontab' from celery.task, while Edit 1 changes the decorator from '@periodic_task' to '@task' and removes the 'crontab' usage. The changed lines in both edits reference the exact same symbols: 'periodic_task' and 'crontab'. Edit 0 removes these symbols from the import statement, and Edit 1 removes their usage in the decorator. This creates a direct code dependency where removing the import makes the usage invalid, and changing the usage makes the import unnecessary. Both edits are part of the same refactoring task to replace periodic_task with regular task decorator."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 changes the import from 'periodic_task' to 'task', and edit 1 changes the decorator usage from '@periodic_task' to '@task'. Both edits reference the exact same symbol - the 'periodic_task' function that is being replaced with 'task'. The changed lines in both edits directly reference this same symbol: edit 0 imports it, edit 1 uses it as a decorator. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in a single refactoring task. Both edits can be staged in either order without causing parse errors (the decorator will simply reference an undefined name until the import is updated, which is allowed in Python)."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 changes the import from 'periodic_task' to 'task', and edit 1 changes the decorator usage from '@periodic_task' to '@task'. Both edits reference the exact same symbol - the 'periodic_task' function that is being replaced with 'task'. The changed lines in both edits directly reference this same symbol: edit 0 imports it, edit 1 uses it as a decorator. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step in a single refactoring task. Both edits can be staged in either order without causing parse errors (the decorator will simply reference an undefined name until the import is updated, which is allowed in Python)."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 removes the definition of SENTRY_CHECKUPDATE_TIME variable, while Edit 1 removes the usage of that same variable in the crontab(**SENTRY_CHECKUPDATE_TIME) call. The changed lines reference the exact same symbol - SENTRY_CHECKUPDATE_TIME. After removing the definition in Edit 0, the usage in Edit 1 would cause a NameError at runtime, but since Python allows referencing undefined variables at parse time, both edits can be staged in either order. However, they are clearly part of the same refactoring task - converting from a periodic task with scheduled timing to a simple task, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 removes the definition of SENTRY_CHECKUPDATE_TIME variable, while Edit 1 removes the usage of that same variable in the crontab(**SENTRY_CHECKUPDATE_TIME) call. The changed lines reference the exact same symbol - SENTRY_CHECKUPDATE_TIME. After removing the definition in Edit 0, the usage in Edit 1 would cause a NameError at runtime, but since Python allows referencing undefined variables at parse time, both edits can be staged in either order. However, they are clearly part of the same refactoring task - converting from a periodic task with scheduled timing to a simple task, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same task name 'sentry.tasks.check_alerts'. Edit 0 adds this task to CELERYBEAT_SCHEDULE configuration, while Edit 1 changes the task definition from @periodic_task to @task with the same name. These edits are part of a coordinated refactoring where the scheduling is being moved from decorator-based periodic tasks to centralized CELERYBEAT_SCHEDULE configuration. The exact same symbol (task name string) is referenced in both changed lines, creating a direct code dependency where either edit naturally prompts the other as the next mechanical step in this refactoring."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same task name 'sentry.tasks.check_alerts'. Edit 0 adds this task to CELERYBEAT_SCHEDULE configuration, while Edit 1 changes the task definition from @periodic_task to @task with the same name. These edits are part of a coordinated refactoring where the scheduling is being moved from decorator-based periodic tasks to centralized CELERYBEAT_SCHEDULE configuration. The exact same symbol (task name string) is referenced in both changed lines, creating a direct code dependency where either edit naturally prompts the other as the next mechanical step in this refactoring."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Both edits perform an identical structural substitution pattern: replacing '@periodic_task' decorators with '@task' decorators while removing the 'run_every' parameter and preserving the 'name' and 'queue' parameters. This is a uniform refactoring operation targeting the same type of syntactic construct (function decorators) with the exact same before\u2192after transformation pattern. Both edits are clearly part of a single, contiguous refactor to convert periodic tasks to regular tasks. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution across the codebase."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Both edits perform an identical structural substitution pattern: replacing '@periodic_task' decorators with '@task' decorators while removing the 'run_every' parameter and preserving the 'name' and 'queue' parameters. This is a uniform refactoring operation targeting the same type of syntactic construct (function decorators) with the exact same before\u2192after transformation pattern. Both edits are clearly part of a single, contiguous refactor to convert periodic tasks to regular tasks. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform substitution across the codebase."
        }
    ],
    "allowed_init_edits": [
        0,
        5
    ]
}