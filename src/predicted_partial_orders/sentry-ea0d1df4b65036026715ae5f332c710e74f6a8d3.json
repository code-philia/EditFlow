{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate'. Edit 0 adds code that handles this option key in the PUT endpoint, while Edit 1 adds the same option key to the frozenset of serializable options. These edits are mechanically linked - adding the option handling in the endpoint creates an immediate need to include it in the serializer's option list, and vice versa. Either edit can be made first without causing parse errors, making this a bi-directional relationship where both edits reference the same string literal and form part of a single feature implementation."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate'. Edit 0 adds code that handles this option key in the PUT endpoint, while Edit 1 adds the same option key to the frozenset of serializable options. These edits are mechanically linked - adding the option handling in the endpoint creates an immediate need to include it in the serializer's option list, and vice versa. Either edit can be made first without causing parse errors, making this a bi-directional relationship where both edits reference the same string literal and form part of a single feature implementation."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate'. Edit 0 adds this option key to a frozenset of allowed options, while Edit 1 adds the corresponding serialization logic to access this option from attrs['options']. These edits are mechanically linked - adding an option to the allowed set and then accessing that option in the serialization logic are part of the same micro-task. Either edit can be staged first without causing parse errors, making this a bi-directional relationship where completing one edit naturally prompts the other as the next immediate step."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate'. Edit 0 adds this option key to a frozenset of allowed options, while Edit 1 adds the corresponding serialization logic to access this option from attrs['options']. These edits are mechanically linked - adding an option to the allowed set and then accessing that option in the serialization logic are part of the same micro-task. Either edit can be staged first without causing parse errors, making this a bi-directional relationship where completing one edit naturally prompts the other as the next immediate step."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate' - edit 0 adds code to handle updating this project option when it's provided in a request, while edit 1 adds code to serialize this same option in the project's API response. These edits are implementing complementary functionality for the same configuration option: one handles writing/updating the value, the other handles reading/serializing it. Either edit could be implemented first and would create an immediate prompt for the other to complete the full read/write functionality for this option."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate' - edit 0 adds code to handle updating this project option when it's provided in a request, while edit 1 adds code to serialize this same option in the project's API response. These edits are implementing complementary functionality for the same configuration option: one handles writing/updating the value, the other handles reading/serializing it. Either edit could be implemented first and would create an immediate prompt for the other to complete the full read/write functionality for this option."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 1 registers a new project option key 'sentry:performance_issue_creation_rate' with a default value, while Edit 0 uses that exact same option key to update project settings. The changed lines in both edits reference the identical string literal 'sentry:performance_issue_creation_rate'. Edit 0 calls project.update_option() with this key, which would fail at runtime if the key isn't registered in the defaults. However, since both edits can be written and parsed in either order (the runtime failure only occurs when the code is executed), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 1 registers a new project option key 'sentry:performance_issue_creation_rate' with a default value, while Edit 0 uses that exact same option key to update project settings. The changed lines in both edits reference the identical string literal 'sentry:performance_issue_creation_rate'. Edit 0 calls project.update_option() with this key, which would fail at runtime if the key isn't registered in the defaults. However, since both edits can be written and parsed in either order (the runtime failure only occurs when the code is executed), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate'. Edit 0 adds this option key to the frozenset of options that the serializer should fetch, while Edit 1 adds the corresponding serialization logic that uses this same option key. The changed lines in both edits explicitly reference the identical string literal 'sentry:performance_issue_creation_rate'. After making either edit, the other becomes the immediate next step to complete the feature - adding the option to the fetch list requires adding the serialization logic, and vice versa. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate'. Edit 0 adds this option key to the frozenset of options that the serializer should fetch, while Edit 1 adds the corresponding serialization logic that uses this same option key. The changed lines in both edits explicitly reference the identical string literal 'sentry:performance_issue_creation_rate'. After making either edit, the other becomes the immediate next step to complete the feature - adding the option to the fetch list requires adding the serialization logic, and vice versa. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate' - edit 0 adds code to handle updating this project option in the PUT endpoint, while edit 1 adds code to serialize this same option in the project serializer. These edits are part of implementing the same feature where the option needs to be both settable (via the endpoint) and retrievable (via the serializer). Either edit could be implemented first and would create an immediate prompt for the other - if you add the serialization first, you'd want to add the ability to set it, and vice versa. Both edits reference the same option key string and are mechanically linked through this shared symbol."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate' - edit 0 adds code to handle updating this project option in the PUT endpoint, while edit 1 adds code to serialize this same option in the project serializer. These edits are part of implementing the same feature where the option needs to be both settable (via the endpoint) and retrievable (via the serializer). Either edit could be implemented first and would create an immediate prompt for the other - if you add the serialization first, you'd want to add the ability to set it, and vice versa. Both edits reference the same option key string and are mechanically linked through this shared symbol."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds a 'performanceIssueCreationRate' field to the ProjectAdminSerializer class, while Edit 1 adds code that processes this exact same field name from the serialized result. The changed lines in both edits reference the same string literal 'performanceIssueCreationRate' - Edit 0 defines it as a serializer field, and Edit 1 uses it to check for and process that field in the request data. This creates a direct code dependency where the serializer field definition naturally prompts the need for corresponding processing logic, and vice versa. Both edits can be staged in either order since they don't create parse-time errors, making this a bi-directional relationship."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds a 'performanceIssueCreationRate' field to the ProjectAdminSerializer class, while Edit 1 adds code that processes this exact same field name from the serialized result. The changed lines in both edits reference the same string literal 'performanceIssueCreationRate' - Edit 0 defines it as a serializer field, and Edit 1 uses it to check for and process that field in the request data. This creates a direct code dependency where the serializer field definition naturally prompts the need for corresponding processing logic, and vice versa. Both edits can be staged in either order since they don't create parse-time errors, making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate' in their changed lines. Edit 0 adds this option key to the 'options' dictionary using attrs['options'].get(), while Edit 1 adds a 'performanceIssueCreationRate' field that references the same option key using get_value_with_default(). Both edits are adding different serialized representations of the same underlying configuration option within the same serialization method. This creates a direct code linkage where both edits reference the identical symbol, making them part of a synchronized addition pattern within the same data structure serialization context."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate' in their changed lines. Edit 0 adds this option key to the 'options' dictionary using attrs['options'].get(), while Edit 1 adds a 'performanceIssueCreationRate' field that references the same option key using get_value_with_default(). Both edits are adding different serialized representations of the same underlying configuration option within the same serialization method. This creates a direct code linkage where both edits reference the identical symbol, making them part of a synchronized addition pattern within the same data structure serialization context."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 adds a line that calls get_value_with_default('sentry:performance_issue_creation_rate') to retrieve a project option value. Edit 1 registers the exact same option key 'sentry:performance_issue_creation_rate' with a default value. The changed lines reference the exact same symbol (the option key string), and after making either edit, the other becomes the immediate next step - if you add the usage without the registration, the option won't have a default value; if you add the registration without the usage, the registered option won't be exposed. Both edits can be written and parsed in either order since they don't create syntax errors, making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 adds a line that calls get_value_with_default('sentry:performance_issue_creation_rate') to retrieve a project option value. Edit 1 registers the exact same option key 'sentry:performance_issue_creation_rate' with a default value. The changed lines reference the exact same symbol (the option key string), and after making either edit, the other becomes the immediate next step - if you add the usage without the registration, the option won't have a default value; if you add the registration without the usage, the registered option won't be exposed. Both edits can be written and parsed in either order since they don't create syntax errors, making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate'. Edit 0 adds this key to a frozenset of project options that need to be serialized, while Edit 1 registers this same key as a project option with a default value. These edits represent a definition-usage relationship where the option must be registered (Edit 1) before it can be meaningfully included in the serializer's option list (Edit 0). However, since this is Python and the frozenset containing the string literal can be parsed and staged regardless of whether the option is registered elsewhere, both edits can be written in either order without causing parse errors. The registration and inclusion in the serializer list are mechanically linked as part of adding a new project option, making either edit prompt the other as the next logical step."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'sentry:performance_issue_creation_rate'. Edit 0 adds this key to a frozenset of project options that need to be serialized, while Edit 1 registers this same key as a project option with a default value. These edits represent a definition-usage relationship where the option must be registered (Edit 1) before it can be meaningfully included in the serializer's option list (Edit 0). However, since this is Python and the frozenset containing the string literal can be parsed and staged regardless of whether the option is registered elsewhere, both edits can be written in either order without causing parse errors. The registration and inclusion in the serializer list are mechanically linked as part of adding a new project option, making either edit prompt the other as the next logical step."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 adds a reference to 'sentry:performance_issue_creation_rate' in the project serializer options, while Edit 1 registers the default value for this exact same option key. The changed lines reference the exact same symbol ('sentry:performance_issue_creation_rate'). After making either edit, the other becomes the immediate next step - if you add the serializer reference without the default registration, the option won't have a fallback value; if you register the default without exposing it in the serializer, it won't be accessible via the API. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 adds a reference to 'sentry:performance_issue_creation_rate' in the project serializer options, while Edit 1 registers the default value for this exact same option key. The changed lines reference the exact same symbol ('sentry:performance_issue_creation_rate'). After making either edit, the other becomes the immediate next step - if you add the serializer reference without the default registration, the option won't have a fallback value; if you register the default without exposing it in the serializer, it won't be accessible via the API. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}