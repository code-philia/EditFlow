{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 6,
            "reason": "Edit 0 adds a specific HTTPError with status code BAD_REQUEST and reason 'Update could not be processed' to the webhook handler. Edit 1 adds test assertions that verify the exact same status code (400, which is HTTPStatus.BAD_REQUEST) and the exact same error message 'Update could not be processed'. The test is directly asserting the behavior implemented in the production code - they reference the same error handling mechanism and message. This is a classic test-production synchronization where the test verifies the exact implementation added in the production code."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Edit 0 adds a specific HTTPError with status code BAD_REQUEST and reason 'Update could not be processed' to the webhook handler. Edit 1 adds test assertions that verify the exact same status code (400, which is HTTPStatus.BAD_REQUEST) and the exact same error message 'Update could not be processed'. The test is directly asserting the behavior implemented in the production code - they reference the same error handling mechanism and message. This is a classic test-production synchronization where the test verifies the exact implementation added in the production code."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Edit 0 defines a class attribute 'response_text' with a specific HTML template string. Edit 1 references this exact same attribute 'self.response_text' in an assertion, using it with the format method. The changed lines reference the exact same symbol - the response_text attribute defined in edit 0 is being used in edit 1. This creates an immediate code dependency where defining the attribute naturally prompts its usage in the test assertion, and both edits appear to be part of the same development session adding test functionality."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Edit 0 defines a class attribute 'response_text' with a specific HTML template string. Edit 1 references this exact same attribute 'self.response_text' in an assertion, using it with the format method. The changed lines reference the exact same symbol - the response_text attribute defined in edit 0 is being used in edit 1. This creates an immediate code dependency where defining the attribute naturally prompts its usage in the test assertion, and both edits appear to be part of the same development session adding test functionality."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 adds a new instance variable 'response_text' to the TestUpdater class, while Edit 1 modifies an existing assertion to use 'self.response_text' instead of a local 'response_text' variable. The changed lines reference the exact same symbol - the response_text attribute. Edit 0 defines the attribute and Edit 1 uses it. Since Python allows referencing undefined attributes at parse time (only failing at runtime), either edit can be staged first, making this bi-directional. After making either edit, the other becomes the immediate next step to complete the refactoring from local variable to instance attribute."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 adds a new instance variable 'response_text' to the TestUpdater class, while Edit 1 modifies an existing assertion to use 'self.response_text' instead of a local 'response_text' variable. The changed lines reference the exact same symbol - the response_text attribute. Edit 0 defines the attribute and Edit 1 uses it. Since Python allows referencing undefined attributes at parse time (only failing at runtime), either edit can be staged first, making this bi-directional. After making either edit, the other becomes the immediate next step to complete the refactoring from local variable to instance attribute."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 adds a class attribute 'response_text' to the TestUpdater class, while Edit 1 modifies code that references 'self.response_text' (the same symbol). The changed lines in both edits reference the exact same symbol - the response_text attribute of the TestUpdater class. Edit 0 defines the attribute and Edit 1 uses it. Since Python allows referencing undefined attributes at parse time (only failing at runtime), either edit can be staged first, making this bi-directional. After making either edit, the other becomes the immediate next step to complete the refactoring from a local variable to a class attribute."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 adds a class attribute 'response_text' to the TestUpdater class, while Edit 1 modifies code that references 'self.response_text' (the same symbol). The changed lines in both edits reference the exact same symbol - the response_text attribute of the TestUpdater class. Edit 0 defines the attribute and Edit 1 uses it. Since Python allows referencing undefined attributes at parse time (only failing at runtime), either edit can be staged first, making this bi-directional. After making either edit, the other becomes the immediate next step to complete the refactoring from a local variable to a class attribute."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 removes the definition of the variable 'response_text', while Edit 1 changes the usage of that same variable from 'response_text' to 'self.response_text'. These edits reference the exact same symbol 'response_text' in their changed lines. After removing the local variable definition in Edit 0, the usage in Edit 1 must be updated to reference a different source (self.response_text) to maintain functionality. This creates a direct, mechanical dependency where making either edit creates an immediate prompt for the other as the next contiguous action within the same micro-task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 removes the definition of the variable 'response_text', while Edit 1 changes the usage of that same variable from 'response_text' to 'self.response_text'. These edits reference the exact same symbol 'response_text' in their changed lines. After removing the local variable definition in Edit 0, the usage in Edit 1 must be updated to reference a different source (self.response_text) to maintain functionality. This creates a direct, mechanical dependency where making either edit creates an immediate prompt for the other as the next contiguous action within the same micro-task."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits perform identical structural transformations on the same type of syntactic construct within the same test method. They both change from using a local variable 'response_text' to using 'self.response_text' and add the same second parameter 'HTTPStatus.FORBIDDEN' to the format call. This represents a uniform substitution pattern - the same before\u2192after transformation applied to the same construct type (assertion statements with format calls). Both edits are part of a single refactoring operation to standardize the response text formatting pattern."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits perform identical structural transformations on the same type of syntactic construct within the same test method. They both change from using a local variable 'response_text' to using 'self.response_text' and add the same second parameter 'HTTPStatus.FORBIDDEN' to the format call. This represents a uniform substitution pattern - the same before\u2192after transformation applied to the same construct type (assertion statements with format calls). Both edits are part of a single refactoring operation to standardize the response text formatting pattern."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 removes the definition of the variable 'response_text', while Edit 1 changes the usage of that same variable from 'response_text' to 'self.response_text'. These edits reference the exact same symbol 'response_text' in their changed lines. After removing the local variable definition in Edit 0, the usage in Edit 1 must be updated to reference a different source (self.response_text) to maintain functionality. Either edit can be made first - if Edit 0 is made first, Edit 1 becomes necessary to fix the undefined reference; if Edit 1 is made first, Edit 0 becomes the natural cleanup step to remove the now-unused local variable. This represents a direct code dependency where both changed lines reference the same symbol."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 removes the definition of the variable 'response_text', while Edit 1 changes the usage of that same variable from 'response_text' to 'self.response_text'. These edits reference the exact same symbol 'response_text' in their changed lines. After removing the local variable definition in Edit 0, the usage in Edit 1 must be updated to reference a different source (self.response_text) to maintain functionality. Either edit can be made first - if Edit 0 is made first, Edit 1 becomes necessary to fix the undefined reference; if Edit 1 is made first, Edit 0 becomes the natural cleanup step to remove the now-unused local variable. This represents a direct code dependency where both changed lines reference the same symbol."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 assigns the return value of send_webhook_message() to a variable named 'response'. Edit 1 then uses this exact same 'response' variable in assertions to check its status_code and text attributes. The changed lines reference the exact same symbol - the 'response' variable. After making edit 0, edit 1 becomes the immediate next step to utilize the newly captured response value. This is a classic definition-usage pattern within the same function scope."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 assigns the return value of send_webhook_message() to a variable named 'response'. Edit 1 then uses this exact same 'response' variable in assertions to check its status_code and text attributes. The changed lines reference the exact same symbol - the 'response' variable. After making edit 0, edit 1 becomes the immediate next step to utilize the newly captured response value. This is a classic definition-usage pattern within the same function scope."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits modify test assertions to use `self.response_text.format()` with similar patterns - one changes an existing assertion from `response_text.format()` to `self.response_text.format()` with additional parameters, and the other adds new assertions using the same `self.response_text.format()` pattern. However, these are different test methods (`test_webhook_basic` vs `test_webhook_update_de_json_fails`) and the changed lines reference different local variables (`response` objects from different test contexts). While they follow the same refactoring pattern, they don't reference the exact same symbol - they're separate `response` objects in different test method scopes. This appears to be part of a bulk refactoring to standardize response text formatting across test methods, but lacks direct code linkage between the exact same symbols."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits modify test assertions to use `self.response_text.format()` with similar patterns - one changes an existing assertion from `response_text.format()` to `self.response_text.format()` with additional parameters, and the other adds new assertions using the same `self.response_text.format()` pattern. However, these are different test methods (`test_webhook_basic` vs `test_webhook_update_de_json_fails`) and the changed lines reference different local variables (`response` objects from different test contexts). While they follow the same refactoring pattern, they don't reference the exact same symbol - they're separate `response` objects in different test method scopes. This appears to be part of a bulk refactoring to standardize response text formatting across test methods, but lacks direct code linkage between the exact same symbols."
        }
    ],
    "allowed_init_edits": [
        0,
        5
    ]
}