{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'self.padded_cond_uncond'. Edit 0 initializes this attribute to False in the __init__ method, while Edit 1 sets it to True in the forward method. These edits are part of a single micro-task of adding a new instance attribute and using it. The changed lines in both edits explicitly reference the same symbol, creating a direct code dependency where the attribute must be initialized before it can be assigned."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'self.padded_cond_uncond'. Edit 0 initializes this attribute to False in the __init__ method, while Edit 1 sets it to True in the forward method. These edits are part of a single micro-task of adding a new instance attribute and using it. The changed lines in both edits explicitly reference the same symbol, creating a direct code dependency where the attribute must be initialized before it can be assigned."
        },
        {
            "src": 0,
            "tgt": 6,
            "reason": "Edit 0 adds a tuple ('Pad conds', 'pad_cond_uncond') to what appears to be a parameter mapping list. Edit 1 adds code that sets p.extra_generation_params[\"Pad conds\"] = True. Both edits reference the exact same string literal \"Pad conds\" - one defining it in a parameter mapping and the other using it as a key to set a parameter value. This creates a direct code linkage where both changed lines reference the same string symbol, making either edit prompt the other as the next mechanical step in implementing this parameter feature."
        },
        {
            "src": 6,
            "tgt": 0,
            "reason": "Edit 0 adds a tuple ('Pad conds', 'pad_cond_uncond') to what appears to be a parameter mapping list. Edit 1 adds code that sets p.extra_generation_params[\"Pad conds\"] = True. Both edits reference the exact same string literal \"Pad conds\" - one defining it in a parameter mapping and the other using it as a key to set a parameter value. This creates a direct code linkage where both changed lines reference the same string symbol, making either edit prompt the other as the next mechanical step in implementing this parameter feature."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'self.padded_cond_uncond' within the same class CFGDenoiser. Edit 0 initializes this attribute in the __init__ method, while Edit 1 assigns a value to this same attribute in the forward method. The changed lines in both edits explicitly reference the same symbol. After making either edit, the other becomes a natural next step - if you initialize the attribute, you'd want to use it somewhere (Edit 1), and if you're setting the attribute in forward(), you'd need it to be initialized first (Edit 0). This is a classic definition-usage relationship within the same class where both edits can be staged in either order without parser errors."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'self.padded_cond_uncond' within the same class CFGDenoiser. Edit 0 initializes this attribute in the __init__ method, while Edit 1 assigns a value to this same attribute in the forward method. The changed lines in both edits explicitly reference the same symbol. After making either edit, the other becomes a natural next step - if you initialize the attribute, you'd want to use it somewhere (Edit 1), and if you're setting the attribute in forward(), you'd need it to be initialized first (Edit 0). This is a classic definition-usage relationship within the same class where both edits can be staged in either order without parser errors."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 adds a new attribute 'padded_cond_uncond' to the CFGDenoiser class __init__ method, initializing it to False. Edit 1 accesses this exact same attribute via 'self.model_wrap_cfg.padded_cond_uncond' in a conditional check. The changed lines reference the exact same symbol - the 'padded_cond_uncond' attribute. After adding the attribute in edit 0, edit 1 becomes the natural next step to use that attribute. Conversely, edit 1 would cause an AttributeError if attempted before edit 0 since the attribute wouldn't exist. However, in Python, both edits can be written and parsed in either order - the error would only occur at runtime when the code path is executed. Since both edits can be staged in either order without parser errors, this is bi-directional."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 adds a new attribute 'padded_cond_uncond' to the CFGDenoiser class __init__ method, initializing it to False. Edit 1 accesses this exact same attribute via 'self.model_wrap_cfg.padded_cond_uncond' in a conditional check. The changed lines reference the exact same symbol - the 'padded_cond_uncond' attribute. After adding the attribute in edit 0, edit 1 becomes the natural next step to use that attribute. Conversely, edit 1 would cause an AttributeError if attempted before edit 0 since the attribute wouldn't exist. However, in Python, both edits can be written and parsed in either order - the error would only occur at runtime when the code path is executed. Since both edits can be staged in either order without parser errors, this is bi-directional."
        },
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits reference the exact same string literal 'Pad conds' - edit 0 adds it to a list of generation parameters, and edit 1 uses it as a key when setting extra_generation_params. This creates a direct code linkage where both changed lines reference the same symbol (the string 'Pad conds'). The edits appear to be part of implementing a feature where a parameter is both registered in the parameters list and conditionally set during sampling. Either edit could be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to complete the feature implementation."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits reference the exact same string literal 'Pad conds' - edit 0 adds it to a list of generation parameters, and edit 1 uses it as a key when setting extra_generation_params. This creates a direct code linkage where both changed lines reference the same symbol (the string 'Pad conds'). The edits appear to be part of implementing a feature where a parameter is both registered in the parameters list and conditionally set during sampling. Either edit could be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to complete the feature implementation."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'self.padded_cond_uncond'. Edit 0 initializes this attribute in the __init__ method, while Edit 1 assigns to it in the forward method. The changed lines in both edits explicitly reference the same instance attribute. After making either edit, the other becomes a natural next step - if you initialize the attribute, you'd want to use it somewhere, and if you're assigning to an attribute, it should be initialized. This creates a bi-directional relationship where either edit can be made first and both reference the exact same symbol."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'self.padded_cond_uncond'. Edit 0 initializes this attribute in the __init__ method, while Edit 1 assigns to it in the forward method. The changed lines in both edits explicitly reference the same instance attribute. After making either edit, the other becomes a natural next step - if you initialize the attribute, you'd want to use it somewhere, and if you're assigning to an attribute, it should be initialized. This creates a bi-directional relationship where either edit can be made first and both reference the exact same symbol."
        },
        {
            "src": 1,
            "tgt": 6,
            "reason": "Edit 0 adds a new attribute 'padded_cond_uncond' to the CFGDenoiser class constructor, initializing it to False. Edit 1 accesses this exact same attribute via 'self.model_wrap_cfg.padded_cond_uncond' in a conditional check. The changed lines reference the exact same symbol - the 'padded_cond_uncond' attribute. After adding the attribute in edit 0, edit 1 becomes the natural next step to use that attribute. Conversely, edit 1's usage of the attribute creates an immediate prompt to define it in edit 0. Both edits can be staged in either order without parser errors (accessing an undefined attribute in Python only causes runtime AttributeError, not parse-time errors), making this a bi-directional relationship."
        },
        {
            "src": 6,
            "tgt": 1,
            "reason": "Edit 0 adds a new attribute 'padded_cond_uncond' to the CFGDenoiser class constructor, initializing it to False. Edit 1 accesses this exact same attribute via 'self.model_wrap_cfg.padded_cond_uncond' in a conditional check. The changed lines reference the exact same symbol - the 'padded_cond_uncond' attribute. After adding the attribute in edit 0, edit 1 becomes the natural next step to use that attribute. Conversely, edit 1's usage of the attribute creates an immediate prompt to define it in edit 0. Both edits can be staged in either order without parser errors (accessing an undefined attribute in Python only causes runtime AttributeError, not parse-time errors), making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'self.padded_cond_uncond' within the same method. Edit 0 initializes this attribute to False, and edit 1 sets it to True under a specific condition. These are part of the same logical micro-task of implementing a flag to track whether conditional/unconditional padding occurred. The changed lines in both edits directly reference the same attribute symbol, creating an immediate code-driven relationship where both assignments are part of implementing the same feature mechanism."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'self.padded_cond_uncond' within the same method. Edit 0 initializes this attribute to False, and edit 1 sets it to True under a specific condition. These are part of the same logical micro-task of implementing a flag to track whether conditional/unconditional padding occurred. The changed lines in both edits directly reference the same attribute symbol, creating an immediate code-driven relationship where both assignments are part of implementing the same feature mechanism."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'self.padded_cond_uncond' within the same method. Edit 0 initializes this attribute to False, and edit 1 sets it to True when padding occurs. These are part of a single micro-task implementing a flag to track whether conditional/unconditional tensors were padded. The changed lines in both edits directly reference the same attribute symbol, creating an immediate code-driven relationship where both assignments work together to implement the padding tracking functionality."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbol 'self.padded_cond_uncond' within the same method. Edit 0 initializes this attribute to False, and edit 1 sets it to True when padding occurs. These are part of a single micro-task implementing a flag to track whether conditional/unconditional tensors were padded. The changed lines in both edits directly reference the same attribute symbol, creating an immediate code-driven relationship where both assignments work together to implement the padding tracking functionality."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 sets the attribute `self.padded_cond_uncond = False` in the CFGDenoiser class, while Edit 1 reads this same attribute via `self.model_wrap_cfg.padded_cond_uncond` in the KDiffusionSampler class. The changed lines reference the exact same symbol (the padded_cond_uncond attribute), creating a definition-usage relationship. Edit 1 cannot meaningfully execute without Edit 0 first setting the attribute, as it would result in an AttributeError at runtime. However, since Python allows both edits to be parsed and staged in either order (the error only occurs at runtime), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 sets the attribute `self.padded_cond_uncond = False` in the CFGDenoiser class, while Edit 1 reads this same attribute via `self.model_wrap_cfg.padded_cond_uncond` in the KDiffusionSampler class. The changed lines reference the exact same symbol (the padded_cond_uncond attribute), creating a definition-usage relationship. Edit 1 cannot meaningfully execute without Edit 0 first setting the attribute, as it would result in an AttributeError at runtime. However, since Python allows both edits to be parsed and staged in either order (the error only occurs at runtime), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 6,
            "reason": "Edit 0 sets the attribute `self.padded_cond_uncond = False` in the CFGDenoiser class, while Edit 1 reads this same attribute via `self.model_wrap_cfg.padded_cond_uncond` in the KDiffusionSampler class. The changed lines reference the exact same symbol (the padded_cond_uncond attribute), creating a definition-usage relationship. Edit 0 defines/sets the attribute, and Edit 1 uses/reads it. Both edits can be staged in either order without parser errors - the attribute access in Edit 1 would only fail at runtime if the attribute doesn't exist, not at parse time. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 2,
            "reason": "Edit 0 sets the attribute `self.padded_cond_uncond = False` in the CFGDenoiser class, while Edit 1 reads this same attribute via `self.model_wrap_cfg.padded_cond_uncond` in the KDiffusionSampler class. The changed lines reference the exact same symbol (the padded_cond_uncond attribute), creating a definition-usage relationship. Edit 0 defines/sets the attribute, and Edit 1 uses/reads it. Both edits can be staged in either order without parser errors - the attribute access in Edit 1 would only fail at runtime if the attribute doesn't exist, not at parse time. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits add identical code blocks that check `self.model_wrap_cfg.padded_cond_uncond` and set `p.extra_generation_params[\"Pad conds\"] = True`. This is a bulk-edit pattern where the exact same code structure is being added to two different methods (`sample_img2img` and `sample`) within the same class. The edits perform identical textual substitution (adding the same conditional block) and target the same type of syntactic construct (conditional statements within method bodies). This represents a single, contiguous refactor to add the same functionality to both sampling methods, making either edit naturally prompt for the other as part of the same synchronized change."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits add identical code blocks that check `self.model_wrap_cfg.padded_cond_uncond` and set `p.extra_generation_params[\"Pad conds\"] = True`. This is a bulk-edit pattern where the exact same code structure is being added to two different methods (`sample_img2img` and `sample`) within the same class. The edits perform identical textual substitution (adding the same conditional block) and target the same type of syntactic construct (conditional statements within method bodies). This represents a single, contiguous refactor to add the same functionality to both sampling methods, making either edit naturally prompt for the other as part of the same synchronized change."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 sets the attribute `self.padded_cond_uncond = True` on a CFGDenoiser instance, while Edit 1 reads this same attribute via `self.model_wrap_cfg.padded_cond_uncond` (where model_wrap_cfg is likely a CFGDenoiser instance). This creates a direct definition-usage relationship for the exact same attribute symbol. Edit 0 defines/sets the attribute, and Edit 1 uses/reads it. Both edits reference the same symbol `padded_cond_uncond` and there's a clear code dependency where the attribute must be set before it can be meaningfully read."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 sets the attribute `self.padded_cond_uncond = True` on a CFGDenoiser instance, while Edit 1 reads this same attribute via `self.model_wrap_cfg.padded_cond_uncond` (where model_wrap_cfg is likely a CFGDenoiser instance). This creates a direct definition-usage relationship for the exact same attribute symbol. Edit 0 defines/sets the attribute, and Edit 1 uses/reads it. Both edits reference the same symbol `padded_cond_uncond` and there's a clear code dependency where the attribute must be set before it can be meaningfully read."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Edit 0 sets the attribute `self.padded_cond_uncond = True` on a CFGDenoiser instance, while Edit 1 reads this same attribute via `self.model_wrap_cfg.padded_cond_uncond` (where model_wrap_cfg is a CFGDenoiser instance). This creates a direct definition-usage relationship for the exact same attribute symbol. Edit 0 defines/sets the attribute, and Edit 1 uses/reads it. Both edits reference the same symbol `padded_cond_uncond` on the same object type. This is a classic definition-usage pattern where either edit can be made first (the attribute access in Edit 1 would not cause a parse error, only a potential AttributeError at runtime), making it bi-directional."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 0 sets the attribute `self.padded_cond_uncond = True` on a CFGDenoiser instance, while Edit 1 reads this same attribute via `self.model_wrap_cfg.padded_cond_uncond` (where model_wrap_cfg is a CFGDenoiser instance). This creates a direct definition-usage relationship for the exact same attribute symbol. Edit 0 defines/sets the attribute, and Edit 1 uses/reads it. Both edits reference the same symbol `padded_cond_uncond` on the same object type. This is a classic definition-usage pattern where either edit can be made first (the attribute access in Edit 1 would not cause a parse error, only a potential AttributeError at runtime), making it bi-directional."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 sets the attribute `self.padded_cond_uncond = True` on a CFGDenoiser instance, while Edit 1 reads this same attribute via `self.model_wrap_cfg.padded_cond_uncond` (where model_wrap_cfg is a CFGDenoiser instance). This creates a direct definition-usage relationship for the exact same attribute symbol. Edit 0 defines the attribute and Edit 1 uses it to conditionally set generation parameters. The usage in Edit 1 would reference an undefined attribute if Edit 0 hasn't been applied first, but since Python allows attribute access that fails at runtime (not parse time), both edits can be staged in either order. After making either edit, the other becomes the immediate next step to complete the feature implementation."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 sets the attribute `self.padded_cond_uncond = True` on a CFGDenoiser instance, while Edit 1 reads this same attribute via `self.model_wrap_cfg.padded_cond_uncond` (where model_wrap_cfg is a CFGDenoiser instance). This creates a direct definition-usage relationship for the exact same attribute symbol. Edit 0 defines the attribute and Edit 1 uses it to conditionally set generation parameters. The usage in Edit 1 would reference an undefined attribute if Edit 0 hasn't been applied first, but since Python allows attribute access that fails at runtime (not parse time), both edits can be staged in either order. After making either edit, the other becomes the immediate next step to complete the feature implementation."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits add the exact same line 'self.padded_cond_uncond = True' in different branches of the same conditional logic within the same method. This is a mirrored/synchronized addition where both edits perform an identical textual substitution (adding the same assignment statement) in the same structural context (different branches of an if-elif statement handling padding logic). The edits are part of a single, contiguous refactor to ensure the same attribute is set in both code paths that handle padding operations."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits add the exact same line 'self.padded_cond_uncond = True' in different branches of the same conditional logic within the same method. This is a mirrored/synchronized addition where both edits perform an identical textual substitution (adding the same assignment statement) in the same structural context (different branches of an if-elif statement handling padding logic). The edits are part of a single, contiguous refactor to ensure the same attribute is set in both code paths that handle padding operations."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}