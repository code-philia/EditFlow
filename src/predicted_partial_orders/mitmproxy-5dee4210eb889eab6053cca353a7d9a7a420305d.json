{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 changes the function signature of make_app by adding a 'debug' parameter, and Edit 1 updates the call site to pass the new 'webdebug' argument to the same make_app function. The changed lines reference the exact same symbol (make_app function) - one edit modifies the function definition and the other modifies the call to that function. This creates an immediate code-driven dependency where after changing the signature, the call site must be updated to match, or vice versa. Both edits can be staged in either order without causing parse errors (Python allows mismatched function signatures at parse time, only failing at runtime), making this bi-directional."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 changes the function signature of make_app by adding a 'debug' parameter, and Edit 1 updates the call site to pass the new 'webdebug' argument to the same make_app function. The changed lines reference the exact same symbol (make_app function) - one edit modifies the function definition and the other modifies the call to that function. This creates an immediate code-driven dependency where after changing the signature, the call site must be updated to match, or vice versa. Both edits can be staged in either order without causing parse errors (Python allows mismatched function signatures at parse time, only failing at runtime), making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 adds a new command-line argument '--webdebug' to the argument parser, creating args.webdebug. Edit 1 uses this exact same symbol (args.webdebug) by passing it as a parameter to the Pathod constructor. This creates an immediate, mechanically obvious code dependency where defining the argument in the parser enables its usage in the main function. Both edits reference the exact same symbol (args.webdebug) and either edit naturally prompts the other as the next contiguous action within the same development task of adding webdebug functionality."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 adds a new command-line argument '--webdebug' to the argument parser, creating args.webdebug. Edit 1 uses this exact same symbol (args.webdebug) by passing it as a parameter to the Pathod constructor. This creates an immediate, mechanically obvious code dependency where defining the argument in the parser enables its usage in the main function. Both edits reference the exact same symbol (args.webdebug) and either edit naturally prompts the other as the next contiguous action within the same development task of adding webdebug functionality."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds a 'webdebug' parameter to the __init__ method signature, and Edit 1 uses that exact same 'webdebug' parameter in a function call within the same method body. This creates a direct code dependency where the parameter defined in the signature is immediately referenced in the method implementation. Both edits reference the exact same symbol 'webdebug' and represent a single micro-task of adding a parameter and threading it through to a function call. Either edit can be staged first without causing parse errors, making this bi-directional."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds a 'webdebug' parameter to the __init__ method signature, and Edit 1 uses that exact same 'webdebug' parameter in a function call within the same method body. This creates a direct code dependency where the parameter defined in the signature is immediately referenced in the method implementation. Both edits reference the exact same symbol 'webdebug' and represent a single micro-task of adding a parameter and threading it through to a function call. Either edit can be staged first without causing parse errors, making this bi-directional."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 adds a 'webdebug' parameter to the Pathod class constructor signature, and Edit 1 adds the corresponding 'webdebug' argument to the Pathod constructor call in the main function. Both edits reference the exact same symbol 'webdebug' - one defines it as a parameter and the other uses it as an argument. After adding the parameter to the constructor signature, the natural next step is to pass that parameter when calling the constructor. This creates an immediate, mechanically obvious code-driven prompt for the companion edit."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 adds a 'webdebug' parameter to the Pathod class constructor signature, and Edit 1 adds the corresponding 'webdebug' argument to the Pathod constructor call in the main function. Both edits reference the exact same symbol 'webdebug' - one defines it as a parameter and the other uses it as an argument. After adding the parameter to the constructor signature, the natural next step is to pass that parameter when calling the constructor. This creates an immediate, mechanically obvious code-driven prompt for the companion edit."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 adds a 'debug' parameter to the make_app function signature, and Edit 1 uses that exact same 'debug' parameter in the function body by assigning it to app.debug. The changed lines reference the exact same symbol - the 'debug' parameter. After adding the parameter in Edit 0, using it in the function body (Edit 1) becomes the immediate, mechanically obvious next step. Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action within the same micro-task."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 adds a 'debug' parameter to the make_app function signature, and Edit 1 uses that exact same 'debug' parameter in the function body by assigning it to app.debug. The changed lines reference the exact same symbol - the 'debug' parameter. After adding the parameter in Edit 0, using it in the function body (Edit 1) becomes the immediate, mechanically obvious next step. Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action within the same micro-task."
        }
    ],
    "allowed_init_edits": [
        6,
        7
    ]
}