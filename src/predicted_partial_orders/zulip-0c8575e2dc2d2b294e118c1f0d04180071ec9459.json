{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits reference the exact same variable symbol 'endpoints'/'post_endpoints' within the same function scope. Edit 0 renames the variable from 'endpoints' to 'post_endpoints' in its definition/assignment, and Edit 1 updates the usage of that same variable in the for loop to match the new name. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain consistency. The variable name must match between definition and usage for the code to work correctly."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits reference the exact same variable symbol 'endpoints'/'post_endpoints' within the same function scope. Edit 0 renames the variable from 'endpoints' to 'post_endpoints' in its definition/assignment, and Edit 1 updates the usage of that same variable in the for loop to match the new name. This creates a direct code dependency where after making either edit, the other becomes the immediate next step to maintain consistency. The variable name must match between definition and usage for the code to work correctly."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "These edits are part of the same test function and follow an identical structural pattern. Edit 0 changes the variable name from 'endpoints' to 'post_endpoints' to be more specific, while Edit 1 adds a new 'patch_endpoints' list with the same structure and testing pattern. Both edits reference the same variable name 'endpoint' in their for loops and follow the exact same testing pattern (list of endpoints \u2192 for loop \u2192 API call \u2192 assertion). This represents a synchronized pattern addition where the first edit disambiguates the existing endpoints list to make room for the new patch_endpoints list, creating a mirrored structure within the same test method."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "These edits are part of the same test function and follow an identical structural pattern. Edit 0 changes the variable name from 'endpoints' to 'post_endpoints' to be more specific, while Edit 1 adds a new 'patch_endpoints' list with the same structure and testing pattern. Both edits reference the same variable name 'endpoint' in their for loops and follow the exact same testing pattern (list of endpoints \u2192 for loop \u2192 API call \u2192 assertion). This represents a synchronized pattern addition where the first edit disambiguates the existing endpoints list to make room for the new patch_endpoints list, creating a mirrored structure within the same test method."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 imports the symbol 'human_users_only' from zerver.decorator, and Edit 1 uses that exact same symbol as a decorator. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. In Python, the usage can be written before the import (it would only fail at runtime), so either edit can be staged first, making this bi-directional."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 imports the symbol 'human_users_only' from zerver.decorator, and Edit 1 uses that exact same symbol as a decorator. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. In Python, the usage can be written before the import (it would only fail at runtime), so either edit can be staged first, making this bi-directional."
        },
        {
            "src": 3,
            "tgt": 5,
            "reason": "Edit 0 imports the symbol 'human_users_only' from zerver.decorator, and Edit 1 uses that exact same symbol as a decorator. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. In Python, the usage can be written before the import (it would only fail at runtime with a NameError), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the import-usage pair."
        },
        {
            "src": 5,
            "tgt": 3,
            "reason": "Edit 0 imports the symbol 'human_users_only' from zerver.decorator, and Edit 1 uses that exact same symbol as a decorator. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. In Python, the usage can be written before the import (it would only fail at runtime with a NameError), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the import-usage pair."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Edit 0 imports the symbol 'human_users_only' from zerver.decorator, and Edit 1 uses that exact same symbol as a decorator. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. In Python, the usage can be written before the import (it would only fail at runtime with a NameError), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the import-usage pair."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 0 imports the symbol 'human_users_only' from zerver.decorator, and Edit 1 uses that exact same symbol as a decorator. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. In Python, the usage can be written before the import (it would only fail at runtime with a NameError), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the import-usage pair."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Both edits add the exact same decorator '@human_users_only' to different functions in the same file. This represents a bulk/pattern synchronization where identical structural substitutions are being applied to the same type of syntactic construct (decorator additions). Both edits are part of what appears to be a single, contiguous refactor to add the same decorator to multiple functions. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform pattern application."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Both edits add the exact same decorator '@human_users_only' to different functions in the same file. This represents a bulk/pattern synchronization where identical structural substitutions are being applied to the same type of syntactic construct (decorator additions). Both edits are part of what appears to be a single, contiguous refactor to add the same decorator to multiple functions. Either edit can be made first, and after making either one, the other becomes a natural next step in completing the uniform pattern application."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Both edits perform an identical textual substitution - adding the '@human_users_only' decorator above '@has_request_variables' in the same file. This is a bulk-edit pattern where the same structural change (adding the same decorator in the same position relative to existing decorators) is being applied to multiple functions. Both edits target the same type of syntactic construct (decorator additions) with identical before\u2192after patterns, making this a synchronized refactoring operation that would naturally occur in a single contiguous micro-task."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Both edits perform an identical textual substitution - adding the '@human_users_only' decorator above '@has_request_variables' in the same file. This is a bulk-edit pattern where the same structural change (adding the same decorator in the same position relative to existing decorators) is being applied to multiple functions. Both edits target the same type of syntactic construct (decorator additions) with identical before\u2192after patterns, making this a synchronized refactoring operation that would naturally occur in a single contiguous micro-task."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Both edits perform an identical structural substitution - adding the same decorator '@human_users_only' in the same position (before '@has_request_variables') in what appears to be the same file. This represents a bulk-edit pattern where the same before\u2192after change is being applied to the same type of syntactic construct (decorator additions). Both edits are part of a single, contiguous refactor to add the same decorator to multiple functions. Either edit can be made first, and both represent the same mechanical action being applied uniformly."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Both edits perform an identical structural substitution - adding the same decorator '@human_users_only' in the same position (before '@has_request_variables') in what appears to be the same file. This represents a bulk-edit pattern where the same before\u2192after change is being applied to the same type of syntactic construct (decorator additions). Both edits are part of a single, contiguous refactor to add the same decorator to multiple functions. Either edit can be made first, and both represent the same mechanical action being applied uniformly."
        }
    ],
    "allowed_init_edits": [
        0,
        2
    ]
}