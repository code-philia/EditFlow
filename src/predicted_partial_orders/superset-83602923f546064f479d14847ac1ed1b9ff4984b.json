{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 adds 'Set' to the typing imports, and Edit 1 uses 'Set' in a type annotation (column_types: Set[GenericDataType] = set()). The changed lines reference the exact same symbol 'Set' - Edit 0 imports it and Edit 1 uses it. This creates an immediate code dependency where using Set in Edit 1 requires the import from Edit 0. However, in Python, the usage can be written before the import is added (it would only fail at runtime/import time, not at parse time), so either edit can be staged first."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 adds 'Set' to the typing imports, and Edit 1 uses 'Set' in a type annotation (column_types: Set[GenericDataType] = set()). The changed lines reference the exact same symbol 'Set' - Edit 0 imports it and Edit 1 uses it. This creates an immediate code dependency where using Set in Edit 1 requires the import from Edit 0. However, in Python, the usage can be written before the import is added (it would only fail at runtime/import time, not at parse time), so either edit can be staged first."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 imports GenericDataType from superset.utils.core, and Edit 1 uses GenericDataType in a type annotation (column_types: Set[GenericDataType]). The changed lines reference the exact same symbol - GenericDataType. Edit 0 makes the symbol available for use, and Edit 1 uses that symbol. In Python, the usage can be written before the import (it would only fail at runtime), so either edit can be staged first, making this bi-directional. After making either edit, the other becomes the immediate next step to complete the definition-usage relationship."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 imports GenericDataType from superset.utils.core, and Edit 1 uses GenericDataType in a type annotation (column_types: Set[GenericDataType]). The changed lines reference the exact same symbol - GenericDataType. Edit 0 makes the symbol available for use, and Edit 1 uses that symbol. In Python, the usage can be written before the import (it would only fail at runtime), so either edit can be staged first, making this bi-directional. After making either edit, the other becomes the immediate next step to complete the definition-usage relationship."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 introduces a new variable `column_types` (highlighted with <dep> tags) that is defined and populated within a loop. Edit 1 uses this exact same `column_types` variable to assign it to `data[\"column_types\"]`. The changed lines reference the exact same symbol - the `column_types` variable. After making edit 0, the natural next step would be to use the newly created `column_types` variable, which is exactly what edit 1 does. This creates an immediate, mechanically obvious code-driven prompt where either edit can be made first (both are syntactically valid independently), but making either one creates the natural prompt for the other as the next contiguous action within the same micro-task."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 introduces a new variable `column_types` (highlighted with <dep> tags) that is defined and populated within a loop. Edit 1 uses this exact same `column_types` variable to assign it to `data[\"column_types\"]`. The changed lines reference the exact same symbol - the `column_types` variable. After making edit 0, the natural next step would be to use the newly created `column_types` variable, which is exactly what edit 1 does. This creates an immediate, mechanically obvious code-driven prompt where either edit can be made first (both are syntactically valid independently), but making either one creates the natural prompt for the other as the next contiguous action within the same micro-task."
        },
        {
            "src": 3,
            "tgt": 6,
            "reason": "Edit 0 adds a 'column_types' field to the data dictionary in the BaseDatasource.data_for_slices method, while Edit 1 adds a test assertion that checks for this exact same 'column_types' field in the test result. The test is directly asserting on the behavior that was just implemented in the production code. Both edits reference the same symbol ('column_types') and represent a test-production code synchronization pattern where the implementation change and its corresponding test verification are mechanically linked."
        },
        {
            "src": 6,
            "tgt": 3,
            "reason": "Edit 0 adds a 'column_types' field to the data dictionary in the BaseDatasource.data_for_slices method, while Edit 1 adds a test assertion that checks for this exact same 'column_types' field in the test result. The test is directly asserting on the behavior that was just implemented in the production code. Both edits reference the same symbol ('column_types') and represent a test-production code synchronization pattern where the implementation change and its corresponding test verification are mechanically linked."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 introduces a new variable 'result' by extracting data['result'] into a local variable. Edit 1 then uses this exact same 'result' variable in a new assertion. The changed lines reference the exact same symbol 'result', where edit 0 defines it and edit 1 uses it. This creates an immediate code dependency where after making edit 0, using the newly introduced 'result' variable becomes a natural next step. Both edits are part of the same test method and represent a contiguous micro-task of refactoring to use the extracted variable."
        },
        {
            "src": 6,
            "tgt": 5,
            "reason": "Edit 0 introduces a new variable 'result' by extracting data['result'] into a local variable. Edit 1 then uses this exact same 'result' variable in a new assertion. The changed lines reference the exact same symbol 'result', where edit 0 defines it and edit 1 uses it. This creates an immediate code dependency where after making edit 0, using the newly introduced 'result' variable becomes a natural next step. Both edits are part of the same test method and represent a contiguous micro-task of refactoring to use the extracted variable."
        },
        {
            "src": 4,
            "tgt": 6,
            "reason": "Edit 0 adds a 'column_types' field to the DashboardDatasetSchema class, while Edit 1 adds a test assertion that checks for the presence and value of 'column_types' in the test result. These edits reference the exact same symbol ('column_types') - one defines it in the schema and the other tests its presence and expected value. This creates a bi-directional relationship where either edit could prompt the other: adding the schema field would naturally lead to testing it, or writing the test assertion would require the schema field to exist. Both are part of the same development micro-task of adding column_types support."
        },
        {
            "src": 6,
            "tgt": 4,
            "reason": "Edit 0 adds a 'column_types' field to the DashboardDatasetSchema class, while Edit 1 adds a test assertion that checks for the presence and value of 'column_types' in the test result. These edits reference the exact same symbol ('column_types') - one defines it in the schema and the other tests its presence and expected value. This creates a bi-directional relationship where either edit could prompt the other: adding the schema field would naturally lead to testing it, or writing the test assertion would require the schema field to exist. Both are part of the same development micro-task of adding column_types support."
        }
    ],
    "allowed_init_edits": [
        0,
        1,
        5,
        4
    ]
}