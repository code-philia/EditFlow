{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds imports for 'List' and 'Union' from the typing module. Edit 1 uses these exact same imported symbols ('List' and 'Union') in a type annotation for the baseviews variable. After making edit 0, the imported symbols become available for use, making edit 1 the immediate next step to utilize these newly imported types. The changed lines reference the exact same symbols (List and Union) - edit 0 imports them and edit 1 uses them. This creates a direct code dependency where the import enables the usage."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 imports BaseView from flask_appbuilder, and Edit 1 uses BaseView in a type annotation for the baseviews variable. The changed line in Edit 1 explicitly references the BaseView symbol that is imported in Edit 0. This creates a direct code dependency where the import in Edit 0 enables the type annotation usage in Edit 1. However, in Python, type annotations are processed at parse time but don't cause runtime errors if the symbol is undefined - they would only cause issues during type checking or if accessed via __annotations__. Since both edits can be written and parsed in either order (the type annotation won't cause a parser error even if BaseView is not imported), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 imports BaseView from flask_appbuilder, and Edit 1 uses BaseView in a type annotation for the baseviews variable. The changed line in Edit 1 explicitly references the BaseView symbol that is imported in Edit 0. This creates a direct code dependency where the import in Edit 0 enables the type annotation usage in Edit 1. However, in Python, type annotations are processed at parse time but don't cause runtime errors if the symbol is undefined - they would only cause issues during type checking or if accessed via __annotations__. Since both edits can be written and parsed in either order (the type annotation won't cause a parser error even if BaseView is not imported), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 imports 'Session' from sqlalchemy.orm, and Edit 1 uses 'Session' in a type annotation for the baseviews variable. The changed lines reference the exact same symbol - the Session class that is imported in Edit 0 and used in the type annotation in Edit 1. This creates a direct code dependency where the import must be available for the type annotation to be valid. However, in Python, type annotations are not evaluated at parse time but rather at runtime or when type checking tools process them, so both edits can be written and parsed in either order without causing a syntax error. The usage of Session in the type annotation would only cause a NameError at runtime/type-checking time if the import is missing, making this a bi-directional relationship."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 imports 'Session' from sqlalchemy.orm, and Edit 1 uses 'Session' in a type annotation for the baseviews variable. The changed lines reference the exact same symbol - the Session class that is imported in Edit 0 and used in the type annotation in Edit 1. This creates a direct code dependency where the import must be available for the type annotation to be valid. However, in Python, type annotations are not evaluated at parse time but rather at runtime or when type checking tools process them, so both edits can be written and parsed in either order without causing a syntax error. The usage of Session in the type annotation would only cause a NameError at runtime/type-checking time if the import is missing, making this a bi-directional relationship."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Edit 0 imports BaseSecurityManager from flask_appbuilder.security.manager, and Edit 1 uses BaseSecurityManager as a type annotation for the sm attribute. The changed lines reference the exact same symbol (BaseSecurityManager), creating a direct import-usage relationship within the same file. After importing BaseSecurityManager in Edit 0, it becomes available for use as a type annotation in Edit 1. Conversely, if Edit 1 were made first, the type annotation would reference an undefined symbol, but this would only cause a runtime NameError in Python, not a parse error, since Python allows forward references in type annotations. Both edits can be written and parsed in either order, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Edit 0 imports BaseSecurityManager from flask_appbuilder.security.manager, and Edit 1 uses BaseSecurityManager as a type annotation for the sm attribute. The changed lines reference the exact same symbol (BaseSecurityManager), creating a direct import-usage relationship within the same file. After importing BaseSecurityManager in Edit 0, it becomes available for use as a type annotation in Edit 1. Conversely, if Edit 1 were made first, the type annotation would reference an undefined symbol, but this would only cause a runtime NameError in Python, not a parse error, since Python allows forward references in type annotations. Both edits can be written and parsed in either order, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits are part of a single refactoring operation within the same function that eliminates the `dttm` variable and uses `as_iso` consistently throughout. Edit 0 removes the assignment `dttm = as_iso` and updates the conditional to use `as_iso` directly. Edit 1 updates the return statement to use `as_iso` instead of `dttm` for the display text. These edits reference the exact same variables (`dttm` and `as_iso`) and represent a coordinated variable substitution pattern within the same function scope. Either edit can be applied first without causing parse errors, and after making either edit, the other becomes the immediate next step to complete the consistent variable usage pattern."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits are part of a single refactoring operation within the same function that eliminates the `dttm` variable and uses `as_iso` consistently throughout. Edit 0 removes the assignment `dttm = as_iso` and updates the conditional to use `as_iso` directly. Edit 1 updates the return statement to use `as_iso` instead of `dttm` for the display text. These edits reference the exact same variables (`dttm` and `as_iso`) and represent a coordinated variable substitution pattern within the same function scope. Either edit can be applied first without causing parse errors, and after making either edit, the other becomes the immediate next step to complete the consistent variable usage pattern."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}