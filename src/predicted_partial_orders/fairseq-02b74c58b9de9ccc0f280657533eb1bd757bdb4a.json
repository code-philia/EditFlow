{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 changes the variable name from 'target_mask' to 'target_masks' and modifies its logic. Edit 1 then uses this renamed variable 'target_masks' in the masked_fill_ call and adds additional usage of the same variable. The changed lines in both edits reference the exact same symbol 'target_masks' - edit 0 defines/assigns it and edit 1 uses it. After making edit 0, edit 1 becomes the immediate next step to update the usage of the renamed variable. This is a clear definition-usage relationship for the same symbol within the same function scope."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 changes the variable name from 'target_mask' to 'target_masks' and modifies its logic. Edit 1 then uses this renamed variable 'target_masks' in the masked_fill_ call and adds additional usage of the same variable. The changed lines in both edits reference the exact same symbol 'target_masks' - edit 0 defines/assigns it and edit 1 uses it. After making edit 0, edit 1 becomes the immediate next step to update the usage of the renamed variable. This is a clear definition-usage relationship for the same symbol within the same function scope."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 imports the symbol 'new_arange' from fairseq.utils, and Edit 1 uses that exact same symbol 'new_arange' in a function call. This creates a direct import-usage relationship where both edits reference the exact same symbol. After making the import in Edit 0, using 'new_arange' in Edit 1 becomes the natural next step. Conversely, if Edit 1 were made first, it would create an immediate need for the import in Edit 0. Since Python allows referencing undefined symbols at parse time (only failing at runtime), both edits can be staged in either order, making this a bi-directional relationship."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 imports the symbol 'new_arange' from fairseq.utils, and Edit 1 uses that exact same symbol 'new_arange' in a function call. This creates a direct import-usage relationship where both edits reference the exact same symbol. After making the import in Edit 0, using 'new_arange' in Edit 1 becomes the natural next step. Conversely, if Edit 1 were made first, it would create an immediate need for the import in Edit 0. Since Python allows referencing undefined symbols at parse time (only failing at runtime), both edits can be staged in either order, making this a bi-directional relationship."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'target_score' in their changed lines. Edit 0 modifies target_score by calling masked_fill_ on it, and edit 1 immediately uses that same target_score variable by calling .sort(1) on it. The target_score variable created/modified in edit 0 is directly consumed by edit 1 in the very next lines of the same function. This creates an immediate, mechanically obvious code dependency where edit 1 depends on the target_score modifications made in edit 0. Since both edits can be parsed independently (no syntax errors), but edit 1 logically follows from edit 0's modifications to target_score, this is a bi-directional relationship where either could prompt the other as the next step in the same micro-task."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbol 'target_score' in their changed lines. Edit 0 modifies target_score by calling masked_fill_ on it, and edit 1 immediately uses that same target_score variable by calling .sort(1) on it. The target_score variable created/modified in edit 0 is directly consumed by edit 1 in the very next lines of the same function. This creates an immediate, mechanically obvious code dependency where edit 1 depends on the target_score modifications made in edit 0. Since both edits can be parsed independently (no syntax errors), but edit 1 logically follows from edit 0's modifications to target_score, this is a bi-directional relationship where either could prompt the other as the next step in the same micro-task."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 defines two variables `target_rank` and `target_cutoff` on lines 99-100. Edit 1 uses these exact same variables on line 102 in the `.scatter()` method call, replacing the previous masking logic. The changed lines in edit 1 directly reference the symbols defined in edit 0's changed lines. This creates an immediate code dependency where edit 0 must come before edit 1, as the variables used in edit 1 would be undefined without edit 0. This is a classic definition-before-usage pattern where the second edit cannot be parsed/executed without the first."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}