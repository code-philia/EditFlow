{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "These edits are bi-directional neighbours because they both modify the same method `_onchange_timezone` in a coordinated way. Edit 0 removes 'user_id' from the @api.onchange decorator, and Edit 1 removes the user_id logic from the method body. Both edits reference the exact same method and are part of a single refactoring task to remove user_id dependency from the timezone change handler. The changes are mechanically linked - removing user_id from the decorator makes the user_id logic in the method body unnecessary, and vice versa. Either edit can be made first without causing parse errors, making this bi-directional."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "These edits are bi-directional neighbours because they both modify the same method `_onchange_timezone` in a coordinated way. Edit 0 removes 'user_id' from the @api.onchange decorator, and Edit 1 removes the user_id logic from the method body. Both edits reference the exact same method and are part of a single refactoring task to remove user_id dependency from the timezone change handler. The changes are mechanically linked - removing user_id from the decorator makes the user_id logic in the method body unnecessary, and vice versa. Either edit can be made first without causing parse errors, making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 adds 'tz=user.tz' to the dictionary returned by the _sync_user method, while Edit 1 adds a call to self._sync_user() in the write method. These edits reference the exact same method symbol (_sync_user) and have a direct code dependency - Edit 1 calls the method that Edit 0 modifies. After making either edit, the other becomes a natural next step: if you modify what _sync_user returns (Edit 0), you might want to ensure it's being called appropriately (Edit 1), and vice versa. Both edits can be staged in either order without parser errors, making this bi-directional."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 adds 'tz=user.tz' to the dictionary returned by the _sync_user method, while Edit 1 adds a call to self._sync_user() in the write method. These edits reference the exact same method symbol (_sync_user) and have a direct code dependency - Edit 1 calls the method that Edit 0 modifies. After making either edit, the other becomes a natural next step: if you modify what _sync_user returns (Edit 0), you might want to ensure it's being called appropriately (Edit 1), and vice versa. Both edits can be staged in either order without parser errors, making this bi-directional."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Edit 0 adds 'tz=user.tz' to a dictionary in the _sync_user method of the Employee class, while Edit 1 modifies the write method of the User class to include 'tz' in the list of fields that get synchronized to employee records. Both edits reference the exact same field 'tz' and are part of implementing timezone synchronization between User and Employee models. Edit 1 creates the mechanism to sync the 'tz' field from user to employee, and Edit 0 ensures that when _sync_user is called, it includes the 'tz' field in the synchronization. These edits are mechanically linked as they both handle the same 'tz' field in the user-employee synchronization flow, making either edit prompt the other as the next logical step in implementing complete timezone synchronization."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Edit 0 adds 'tz=user.tz' to a dictionary in the _sync_user method of the Employee class, while Edit 1 modifies the write method of the User class to include 'tz' in the list of fields that get synchronized to employee records. Both edits reference the exact same field 'tz' and are part of implementing timezone synchronization between User and Employee models. Edit 1 creates the mechanism to sync the 'tz' field from user to employee, and Edit 0 ensures that when _sync_user is called, it includes the 'tz' field in the synchronization. These edits are mechanically linked as they both handle the same 'tz' field in the user-employee synchronization flow, making either edit prompt the other as the next logical step in implementing complete timezone synchronization."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Both edits modify the same method (write) in the same class (User) and are part of the same logical refactoring. Edit 0 updates the docstring to reflect the broader synchronization functionality, while Edit 1 replaces the implementation to synchronize multiple fields (name, email, image, tz) instead of just the name field for admin users. The docstring change in Edit 0 directly corresponds to the implementation change in Edit 1 - both reference the exact same method and the docstring accurately describes what the new implementation does. This is a synchronized documentation-code update where both edits reference the same symbol (the write method) and the docstring change directly corresponds to the code behavior change."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Both edits modify the same method (write) in the same class (User) and are part of the same logical refactoring. Edit 0 updates the docstring to reflect the broader synchronization functionality, while Edit 1 replaces the implementation to synchronize multiple fields (name, email, image, tz) instead of just the name field for admin users. The docstring change in Edit 0 directly corresponds to the implementation change in Edit 1 - both reference the exact same method and the docstring accurately describes what the new implementation does. This is a synchronized documentation-code update where both edits reference the same symbol (the write method) and the docstring change directly corresponds to the code behavior change."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Edit 0 removes the import of SUPERUSER_ID from the odoo module, while Edit 1 removes code that uses SUPERUSER_ID (specifically in line 25 where it checks 'user.id == SUPERUSER_ID'). Both edits reference the exact same symbol SUPERUSER_ID - one removes its import and the other removes its usage. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime), both edits can be staged in either order without causing parser errors. The removal of the import and the removal of its usage are mechanically linked as part of cleaning up unused code, making either edit prompt the other as the next logical step."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Edit 0 removes the import of SUPERUSER_ID from the odoo module, while Edit 1 removes code that uses SUPERUSER_ID (specifically in line 25 where it checks 'user.id == SUPERUSER_ID'). Both edits reference the exact same symbol SUPERUSER_ID - one removes its import and the other removes its usage. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime), both edits can be staged in either order without causing parser errors. The removal of the import and the removal of its usage are mechanically linked as part of cleaning up unused code, making either edit prompt the other as the next logical step."
        }
    ],
    "allowed_init_edits": [
        5
    ]
}