{
    "partial_orders": [
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbols 'check_interval' and 'max_attempts'. Edit 0 adds these parameters to the function signature, and Edit 1 assigns these parameters to instance variables using the exact same parameter names. This creates a direct code dependency where the parameters defined in the signature are immediately used in the constructor body. Both edits are part of the same micro-task of adding new parameters to the class constructor, and either edit can be staged first since both are syntactically valid independently."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbols 'check_interval' and 'max_attempts'. Edit 0 adds these parameters to the function signature, and Edit 1 assigns these parameters to instance variables using the exact same parameter names. This creates a direct code dependency where the parameters defined in the signature are immediately used in the constructor body. Both edits are part of the same micro-task of adding new parameters to the class constructor, and either edit can be staged first since both are syntactically valid independently."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 adds documentation for `check_interval` and `max_attempts` parameters, while Edit 1 uses these exact same parameters in the waiter.wait() call by referencing `self.check_interval` and `self.max_attempts`. The changed lines in Edit 1 directly reference the same symbols that are being documented in Edit 0. This creates a direct code linkage where both edits reference the exact same parameter symbols, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 adds documentation for `check_interval` and `max_attempts` parameters, while Edit 1 uses these exact same parameters in the waiter.wait() call by referencing `self.check_interval` and `self.max_attempts`. The changed lines in Edit 1 directly reference the same symbols that are being documented in Edit 0. This creates a direct code linkage where both edits reference the exact same parameter symbols, making them bi-directional neighbours in mental flow."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits reference the exact same symbols 'check_interval' and 'max_attempts'. Edit 0 adds documentation for these parameters in the docstring, while Edit 1 adds the actual parameter definitions to the __init__ method signature. These are the same symbols being documented and defined respectively, creating a direct code linkage where documenting parameters and defining them are part of the same contiguous micro-task of adding new parameters to a class constructor."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits reference the exact same symbols 'check_interval' and 'max_attempts'. Edit 0 adds documentation for these parameters in the docstring, while Edit 1 adds the actual parameter definitions to the __init__ method signature. These are the same symbols being documented and defined respectively, creating a direct code linkage where documenting parameters and defining them are part of the same contiguous micro-task of adding new parameters to a class constructor."
        },
        {
            "src": 0,
            "tgt": 3,
            "reason": "These edits are adding documentation for two new parameters (check_interval and max_attempts) in edit 0, and then adding the corresponding instance variable assignments for those same parameters in edit 1. The changed lines reference the exact same symbols - check_interval and max_attempts. This creates a direct code linkage where documenting parameters and then implementing their assignment in the constructor are part of the same contiguous micro-task. Either edit could be made first (documentation or implementation), and after making either, the other becomes the immediate next step to complete the parameter addition."
        },
        {
            "src": 3,
            "tgt": 0,
            "reason": "These edits are adding documentation for two new parameters (check_interval and max_attempts) in edit 0, and then adding the corresponding instance variable assignments for those same parameters in edit 1. The changed lines reference the exact same symbols - check_interval and max_attempts. This creates a direct code linkage where documenting parameters and then implementing their assignment in the constructor are part of the same contiguous micro-task. Either edit could be made first (documentation or implementation), and after making either, the other becomes the immediate next step to complete the parameter addition."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Both edits are adding the same two parameters ('check_interval' and 'max_attempts') to different parts of the same class - one to the docstring documentation and one to what appears to be a template_fields tuple. This represents a synchronized addition where both edits reference the exact same parameter names and are part of the same micro-task of adding these parameters to the class interface. The edits perform identical additions (same parameter names) to related syntactic constructs within the same class context, making either edit a natural prompt for the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Both edits are adding the same two parameters ('check_interval' and 'max_attempts') to different parts of the same class - one to the docstring documentation and one to what appears to be a template_fields tuple. This represents a synchronized addition where both edits reference the exact same parameter names and are part of the same micro-task of adding these parameters to the class interface. The edits perform identical additions (same parameter names) to related syntactic constructs within the same class context, making either edit a natural prompt for the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 adds two new parameters (check_interval and max_attempts) to the constructor of DynamoDBToS3Operator. Edit 1 uses these exact same parameters (self.check_interval and self.max_attempts) in the waiter.wait() call within the _export_table_to_point_in_time method. The changed lines in edit 1 directly reference the parameters added in edit 0, creating an immediate code dependency. After adding the parameters in the constructor, using them in the method becomes the natural next step. This is a classic definition-usage relationship where both edits reference the exact same symbols."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 adds two new parameters (check_interval and max_attempts) to the constructor of DynamoDBToS3Operator. Edit 1 uses these exact same parameters (self.check_interval and self.max_attempts) in the waiter.wait() call within the _export_table_to_point_in_time method. The changed lines in edit 1 directly reference the parameters added in edit 0, creating an immediate code dependency. After adding the parameters in the constructor, using them in the method becomes the natural next step. This is a classic definition-usage relationship where both edits reference the exact same symbols."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 adds 'check_interval' and 'max_attempts' to what appears to be a template_fields tuple or similar configuration list. Edit 1 uses these exact same attributes (self.check_interval and self.max_attempts) in a waiter.wait() call within the WaiterConfig parameter. The changed lines in edit 1 directly reference the same symbols that were added to the configuration in edit 0. This creates an immediate code dependency where adding the attributes to the template_fields makes them available for use in the waiter configuration, and using them in the waiter call requires them to be in the template_fields. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other as the next logical step."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 adds 'check_interval' and 'max_attempts' to what appears to be a template_fields tuple or similar configuration list. Edit 1 uses these exact same attributes (self.check_interval and self.max_attempts) in a waiter.wait() call within the WaiterConfig parameter. The changed lines in edit 1 directly reference the same symbols that were added to the configuration in edit 0. This creates an immediate code dependency where adding the attributes to the template_fields makes them available for use in the waiter configuration, and using them in the waiter call requires them to be in the template_fields. Either edit can be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other as the next logical step."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Both edits reference the exact same symbols 'check_interval' and 'max_attempts'. Edit 0 adds these parameters to the template_fields tuple, while Edit 1 assigns these parameters as instance attributes in the __init__ method. However, looking at the code structure, Edit 1's assignment references parameters that are not defined in the __init__ method signature shown. This suggests these parameters should be added to the method signature first, then assigned as instance attributes, and finally added to template_fields. The template_fields addition (Edit 0) would typically come after the parameters are properly defined and assigned. Since both edits reference the same symbols and are part of adding new parameters to the class, they are bi-directional - either could be implemented first as both are syntactically valid, though the assignment in Edit 1 references undefined parameters."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbols 'check_interval' and 'max_attempts'. Edit 0 adds these parameters to the template_fields tuple, while Edit 1 assigns these parameters as instance attributes in the __init__ method. However, looking at the code structure, Edit 1's assignment references parameters that are not defined in the __init__ method signature shown. This suggests these parameters should be added to the method signature first, then assigned as instance attributes, and finally added to template_fields. The template_fields addition (Edit 0) would typically come after the parameters are properly defined and assigned. Since both edits reference the same symbols and are part of adding new parameters to the class, they are bi-directional - either could be implemented first as both are syntactically valid, though the assignment in Edit 1 references undefined parameters."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 adds two new instance attributes 'check_interval' and 'max_attempts' to the constructor's initialization. Edit 1 uses these exact same attributes in a waiter configuration within the same class. The changed lines in edit 1 explicitly reference 'self.check_interval' and 'self.max_attempts' which are the same symbols being assigned in edit 0. This creates a direct definition-usage relationship where both edits reference the exact same symbols, making either edit prompt the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 adds two new instance attributes 'check_interval' and 'max_attempts' to the constructor's initialization. Edit 1 uses these exact same attributes in a waiter configuration within the same class. The changed lines in edit 1 explicitly reference 'self.check_interval' and 'self.max_attempts' which are the same symbols being assigned in edit 0. This creates a direct definition-usage relationship where both edits reference the exact same symbols, making either edit prompt the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Both edits involve adding the exact same two parameters ('check_interval' and 'max_attempts') to the same class (DynamoDBToS3Operator). Edit 0 adds these parameters to the template_fields tuple, while Edit 1 adds them as constructor parameters with default values. These edits reference the exact same symbols and represent a synchronized addition pattern - when adding new parameters to a class constructor, they typically need to be added to template_fields as well for proper templating support. Either edit could be made first, and after making either one, the other becomes the immediate next step to complete the parameter addition pattern."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Both edits involve adding the exact same two parameters ('check_interval' and 'max_attempts') to the same class (DynamoDBToS3Operator). Edit 0 adds these parameters to the template_fields tuple, while Edit 1 adds them as constructor parameters with default values. These edits reference the exact same symbols and represent a synchronized addition pattern - when adding new parameters to a class constructor, they typically need to be added to template_fields as well for proper templating support. Either edit could be made first, and after making either one, the other becomes the immediate next step to complete the parameter addition pattern."
        }
    ],
    "allowed_init_edits": [
        5
    ]
}