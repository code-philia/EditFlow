{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 4,
            "reason": "Edit 0 imports 'require_realm_admin' from zerver.lib.request, and Edit 1 uses that exact same imported symbol as a decorator on the deactivate_stream_backend function. After importing the symbol in Edit 0, using it as a decorator in Edit 1 becomes the immediate next step. Both edits reference the exact same symbol 'require_realm_admin' - one imports it, the other uses it. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical action."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Edit 0 imports 'require_realm_admin' from zerver.lib.request, and Edit 1 uses that exact same imported symbol as a decorator on the deactivate_stream_backend function. After importing the symbol in Edit 0, using it as a decorator in Edit 1 becomes the immediate next step. Both edits reference the exact same symbol 'require_realm_admin' - one imports it, the other uses it. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical action."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits add the exact same decorator '@require_realm_admin' to different function definitions in the same file. This represents a uniform, synchronized pattern substitution where the same structural change (adding the same decorator) is being applied to the same type of syntactic construct (function definitions). Both edits are part of what appears to be a single refactoring task to add admin permission requirements to multiple stream-related functions. Either edit could be made first, and after making one, the other would be a natural continuation of the same pattern-based refactoring task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits add the exact same decorator '@require_realm_admin' to different function definitions in the same file. This represents a uniform, synchronized pattern substitution where the same structural change (adding the same decorator) is being applied to the same type of syntactic construct (function definitions). Both edits are part of what appears to be a single refactoring task to add admin permission requirements to multiple stream-related functions. Either edit could be made first, and after making one, the other would be a natural continuation of the same pattern-based refactoring task."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 adds 'require_realm_admin' to the import statement, and Edit 1 uses that exact same imported symbol as a decorator. This creates a direct definition-usage relationship where the import makes the symbol available for use in the decorator. In Python, both edits can be staged in either order since the usage before import would only cause a runtime NameError, not a parse error. After making either edit, the other becomes the immediate next step to complete the functionality."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 adds 'require_realm_admin' to the import statement, and Edit 1 uses that exact same imported symbol as a decorator. This creates a direct definition-usage relationship where the import makes the symbol available for use in the decorator. In Python, both edits can be staged in either order since the usage before import would only cause a runtime NameError, not a parse error. After making either edit, the other becomes the immediate next step to complete the functionality."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 defines a new function `require_realm_admin` in the decorator.py file, while Edit 1 imports that exact same function in the views/__init__.py file. This is a classic definition-usage relationship where the changed lines reference the exact same symbol. After defining the function in Edit 0, importing it in Edit 1 becomes the immediate next step to make it available for use. In Python, both edits can be staged in either order since the import will only fail at runtime/import-time if the function doesn't exist, not at parse time. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 defines a new function `require_realm_admin` in the decorator.py file, while Edit 1 imports that exact same function in the views/__init__.py file. This is a classic definition-usage relationship where the changed lines reference the exact same symbol. After defining the function in Edit 0, importing it in Edit 1 becomes the immediate next step to make it available for use. In Python, both edits can be staged in either order since the import will only fail at runtime/import-time if the function doesn't exist, not at parse time. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Edit 0 adds the @require_realm_admin decorator to the json_rename_stream function, while Edit 1 removes the manual permission check code from within the same function. These edits are directly related because they both modify the same function's authorization mechanism - the decorator addition replaces the need for the manual permission check. The decorator @require_realm_admin provides the same functionality as the removed manual check 'if not user_profile.has_perm('administer', user_profile.realm)'. This is a refactoring where manual authorization logic is replaced with a decorator-based approach. Both edits reference the exact same function and work together to achieve the same authorization goal through different mechanisms."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Edit 0 adds the @require_realm_admin decorator to the json_rename_stream function, while Edit 1 removes the manual permission check code from within the same function. These edits are directly related because they both modify the same function's authorization mechanism - the decorator addition replaces the need for the manual permission check. The decorator @require_realm_admin provides the same functionality as the removed manual check 'if not user_profile.has_perm('administer', user_profile.realm)'. This is a refactoring where manual authorization logic is replaced with a decorator-based approach. Both edits reference the exact same function and work together to achieve the same authorization goal through different mechanisms."
        },
        {
            "src": 0,
            "tgt": 4,
            "reason": "Edit 0 defines a decorator function `require_realm_admin` in zerver/decorator.py, while Edit 1 uses that exact same decorator by applying it with `@require_realm_admin` to a function in zerver/views/__init__.py. This is a classic definition-usage relationship where the changed lines reference the exact same symbol. After defining the decorator in Edit 0, Edit 1 becomes the immediate next step to use it. Since this is Python, both edits can be parsed and staged in either order (the usage would only fail at import/runtime if the definition isn't present), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 4,
            "tgt": 0,
            "reason": "Edit 0 defines a decorator function `require_realm_admin` in zerver/decorator.py, while Edit 1 uses that exact same decorator by applying it with `@require_realm_admin` to a function in zerver/views/__init__.py. This is a classic definition-usage relationship where the changed lines reference the exact same symbol. After defining the decorator in Edit 0, Edit 1 becomes the immediate next step to use it. Since this is Python, both edits can be parsed and staged in either order (the usage would only fail at import/runtime if the definition isn't present), making this a bi-directional relationship rather than ordered."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Edit 0 defines a new decorator function `require_realm_admin` in zerver/decorator.py, while Edit 1 applies this exact same decorator to a function in zerver/views/__init__.py. The changed lines reference the exact same symbol - the `require_realm_admin` decorator. After defining the decorator in Edit 0, Edit 1 becomes the immediate next step to use it. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime/import), both edits can be staged in either order without causing parser errors. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Edit 0 defines a new decorator function `require_realm_admin` in zerver/decorator.py, while Edit 1 applies this exact same decorator to a function in zerver/views/__init__.py. The changed lines reference the exact same symbol - the `require_realm_admin` decorator. After defining the decorator in Edit 0, Edit 1 becomes the immediate next step to use it. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime/import), both edits can be staged in either order without causing parser errors. This creates a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 4,
            "tgt": 5,
            "reason": "Edit 0 adds the @require_realm_admin decorator to the deactivate_stream_backend function, while Edit 1 removes the manual admin permission check (if not user_profile.is_admin()) from within the same function. These edits are directly related because they both address the same permission checking mechanism for the exact same function. The decorator addition makes the manual permission check redundant, so removing the manual check is the immediate next step after adding the decorator. Both edits reference the same function and the same permission checking concern, making them part of a single refactoring task to replace manual permission checking with decorator-based checking."
        },
        {
            "src": 5,
            "tgt": 4,
            "reason": "Edit 0 adds the @require_realm_admin decorator to the deactivate_stream_backend function, while Edit 1 removes the manual admin permission check (if not user_profile.is_admin()) from within the same function. These edits are directly related because they both address the same permission checking mechanism for the exact same function. The decorator addition makes the manual permission check redundant, so removing the manual check is the immediate next step after adding the decorator. Both edits reference the same function and the same permission checking concern, making them part of a single refactoring task to replace manual permission checking with decorator-based checking."
        }
    ],
    "allowed_init_edits": [
        3,
        5
    ]
}