{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 adds SENSE_EXCEPTIONS to the imports at the top of the file, while Edit 1 uses SENSE_EXCEPTIONS in an exception handler. The changed lines reference the exact same symbol - SENSE_EXCEPTIONS. After making either edit, the other becomes the immediate next step: if you add the import first, you naturally use it in the exception handler; if you add the exception handler first, you need the import to resolve the undefined symbol. This is a classic import-usage relationship within the same file."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 adds SENSE_EXCEPTIONS to the imports at the top of the file, while Edit 1 uses SENSE_EXCEPTIONS in an exception handler. The changed lines reference the exact same symbol - SENSE_EXCEPTIONS. After making either edit, the other becomes the immediate next step: if you add the import first, you naturally use it in the exception handler; if you add the exception handler first, you need the import to resolve the undefined symbol. This is a classic import-usage relationship within the same file."
        },
        {
            "src": 1,
            "tgt": 3,
            "reason": "Edit 0 adds SENSE_EXCEPTIONS to the imports at the top of the file, while Edit 1 uses SENSE_EXCEPTIONS in an except clause within the async_setup_entry function. The changed lines reference the exact same symbol - SENSE_EXCEPTIONS. After making Edit 0 (adding the import), Edit 1 becomes the immediate next step to use that imported symbol. Conversely, if Edit 1 were made first, it would create an undefined symbol that would prompt adding the import in Edit 0. Both edits can be parsed and staged in either order in Python (usage before import only causes a runtime NameError, not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 3,
            "tgt": 1,
            "reason": "Edit 0 adds SENSE_EXCEPTIONS to the imports at the top of the file, while Edit 1 uses SENSE_EXCEPTIONS in an except clause within the async_setup_entry function. The changed lines reference the exact same symbol - SENSE_EXCEPTIONS. After making Edit 0 (adding the import), Edit 1 becomes the immediate next step to use that imported symbol. Conversely, if Edit 1 were made first, it would create an undefined symbol that would prompt adding the import in Edit 0. Both edits can be parsed and staged in either order in Python (usage before import only causes a runtime NameError, not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 1,
            "tgt": 4,
            "reason": "Both edits reference the exact same symbol 'SENSE_EXCEPTIONS'. Edit 0 adds SENSE_EXCEPTIONS to the import list, and Edit 1 uses SENSE_EXCEPTIONS in an except clause. This creates a direct definition-usage relationship where the import makes the symbol available for use in the exception handling code. In Python, using an undefined symbol in an except clause would cause a NameError at runtime when that code path is executed, but both edits can be parsed and staged in either order since the usage is within a function body that isn't executed at import time."
        },
        {
            "src": 4,
            "tgt": 1,
            "reason": "Both edits reference the exact same symbol 'SENSE_EXCEPTIONS'. Edit 0 adds SENSE_EXCEPTIONS to the import list, and Edit 1 uses SENSE_EXCEPTIONS in an except clause. This creates a direct definition-usage relationship where the import makes the symbol available for use in the exception handling code. In Python, using an undefined symbol in an except clause would cause a NameError at runtime when that code path is executed, but both edits can be parsed and staged in either order since the usage is within a function body that isn't executed at import time."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits perform identical structural transformations on the same type of syntactic construct within the same function. They both change bare 'raise ConfigEntryNotReady from err' statements to the same expanded pattern with error message handling and additional SENSE_EXCEPTIONS catch blocks. This represents a uniform refactoring pattern being applied consistently across multiple exception handling blocks in the same function context."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits perform identical structural transformations on the same type of syntactic construct within the same function. They both change bare 'raise ConfigEntryNotReady from err' statements to the same expanded pattern with error message handling and additional SENSE_EXCEPTIONS catch blocks. This represents a uniform refactoring pattern being applied consistently across multiple exception handling blocks in the same function context."
        },
        {
            "src": 1,
            "tgt": 7,
            "reason": "Edit 1 defines the constant SENSE_EXCEPTIONS in const.py, while Edit 0 imports SENSE_EXCEPTIONS in __init__.py. This is a classic definition-usage relationship where the same symbol is being defined in one edit and imported in another. In Python, imports can be written before the symbol is defined (resulting in a runtime ImportError rather than a parse error), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the definition-import pair."
        },
        {
            "src": 7,
            "tgt": 1,
            "reason": "Edit 1 defines the constant SENSE_EXCEPTIONS in const.py, while Edit 0 imports SENSE_EXCEPTIONS in __init__.py. This is a classic definition-usage relationship where the same symbol is being defined in one edit and imported in another. In Python, imports can be written before the symbol is defined (resulting in a runtime ImportError rather than a parse error), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the definition-import pair."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Edit 1 defines the symbol SENSE_EXCEPTIONS in const.py, and Edit 0 uses this exact same symbol in __init__.py with 'except SENSE_EXCEPTIONS as err:'. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. After defining SENSE_EXCEPTIONS in Edit 1, Edit 0 becomes the immediate next step to use it. Since this is Python and the usage can be written before the definition (it would only fail at import/runtime, not at parse time), the relationship is bi-directional."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Edit 1 defines the symbol SENSE_EXCEPTIONS in const.py, and Edit 0 uses this exact same symbol in __init__.py with 'except SENSE_EXCEPTIONS as err:'. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. After defining SENSE_EXCEPTIONS in Edit 1, Edit 0 becomes the immediate next step to use it. Since this is Python and the usage can be written before the definition (it would only fail at import/runtime, not at parse time), the relationship is bi-directional."
        },
        {
            "src": 3,
            "tgt": 7,
            "reason": "Edit 1 defines the symbol SENSE_EXCEPTIONS in const.py, and Edit 0 uses this exact same symbol in an except clause in __init__.py. The changed line in Edit 0 explicitly references SENSE_EXCEPTIONS which is defined in the changed line of Edit 1. This creates a direct definition-usage relationship where both edits reference the exact same symbol. In Python, using an undefined symbol in an except clause is allowed at parse time and only fails at runtime with a NameError, so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the exception handling pattern."
        },
        {
            "src": 7,
            "tgt": 3,
            "reason": "Edit 1 defines the symbol SENSE_EXCEPTIONS in const.py, and Edit 0 uses this exact same symbol in an except clause in __init__.py. The changed line in Edit 0 explicitly references SENSE_EXCEPTIONS which is defined in the changed line of Edit 1. This creates a direct definition-usage relationship where both edits reference the exact same symbol. In Python, using an undefined symbol in an except clause is allowed at parse time and only fails at runtime with a NameError, so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the exception handling pattern."
        },
        {
            "src": 4,
            "tgt": 7,
            "reason": "Edit 1 defines the constant SENSE_EXCEPTIONS in const.py, and Edit 0 uses this exact same symbol in an except clause. The changed line in Edit 0 explicitly references SENSE_EXCEPTIONS which is defined in Edit 1. This creates a direct code dependency where defining the constant enables its usage. Since Python allows referencing undefined names at parse time (they only fail at runtime/import time), either edit can be staged first, making this bi-directional rather than ordered."
        },
        {
            "src": 7,
            "tgt": 4,
            "reason": "Edit 1 defines the constant SENSE_EXCEPTIONS in const.py, and Edit 0 uses this exact same symbol in an except clause. The changed line in Edit 0 explicitly references SENSE_EXCEPTIONS which is defined in Edit 1. This creates a direct code dependency where defining the constant enables its usage. Since Python allows referencing undefined names at parse time (they only fail at runtime/import time), either edit can be staged first, making this bi-directional rather than ordered."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Edit 0 imports the socket module, and Edit 1 uses socket.gaierror in the changed line. This is a classic import-usage relationship where the exact same symbol (socket) is being imported in one edit and referenced in another edit within the same file. After adding the import, using socket.gaierror becomes the immediate next step, and conversely, if socket.gaierror is needed, importing socket becomes necessary. Both edits can be staged in either order since Python allows referencing undefined imports at parse time (only failing at runtime), making this bi-directional."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Edit 0 imports the socket module, and Edit 1 uses socket.gaierror in the changed line. This is a classic import-usage relationship where the exact same symbol (socket) is being imported in one edit and referenced in another edit within the same file. After adding the import, using socket.gaierror becomes the immediate next step, and conversely, if socket.gaierror is needed, importing socket becomes necessary. Both edits can be staged in either order since Python allows referencing undefined imports at parse time (only failing at runtime), making this bi-directional."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 imports SenseWebsocketException from sense_energy.sense_exceptions, and Edit 1 uses that exact same imported symbol SenseWebsocketException in a tuple assignment. This creates a direct definition-usage relationship where the import makes the symbol available for use in the tuple. In Python, both edits can be written and parsed in either order (the usage would only fail at runtime/import time if the import is missing), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 imports SenseWebsocketException from sense_energy.sense_exceptions, and Edit 1 uses that exact same imported symbol SenseWebsocketException in a tuple assignment. This creates a direct definition-usage relationship where the import makes the symbol available for use in the tuple. In Python, both edits can be written and parsed in either order (the usage would only fail at runtime/import time if the import is missing), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        }
    ],
    "allowed_init_edits": [
        0
    ]
}