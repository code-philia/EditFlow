{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 5,
            "reason": "Both edits perform an identical structural refactoring pattern: they remove a mixin class and consolidate its functionality into a main description class, while adding the same `@dataclass(kw_only=True)` decorator and `Generic[T]` inheritance. The edits apply the same before\u2192after transformation pattern to the same type of syntactic construct (dataclass definitions for entity descriptions), making this a bulk uniform substitution that would naturally occur as part of a single, contiguous refactoring sweep across the codebase."
        },
        {
            "src": 5,
            "tgt": 0,
            "reason": "Both edits perform an identical structural refactoring pattern: they remove a mixin class and consolidate its functionality into a main description class, while adding the same `@dataclass(kw_only=True)` decorator and `Generic[T]` inheritance. The edits apply the same before\u2192after transformation pattern to the same type of syntactic construct (dataclass definitions for entity descriptions), making this a bulk uniform substitution that would naturally occur as part of a single, contiguous refactoring sweep across the codebase."
        },
        {
            "src": 0,
            "tgt": 2,
            "reason": "Both edits perform identical structural transformations on dataclass definitions in the same codebase: they both add 'kw_only=True' to @dataclass decorators and consolidate class hierarchies by removing mixin classes. However, they operate on completely different symbols - DeconzBinarySensorDescription in binary_sensor.py and DeconzButtonDescription in button.py. While the pattern of change is identical (same before\u2192after transformation on the same type of syntactic construct), the changed lines reference different class symbols in different files. This appears to be part of a uniform refactoring sweep across the deconz component, but the symbols themselves are distinct."
        },
        {
            "src": 2,
            "tgt": 0,
            "reason": "Both edits perform identical structural transformations on dataclass definitions in the same codebase: they both add 'kw_only=True' to @dataclass decorators and consolidate class hierarchies by removing mixin classes. However, they operate on completely different symbols - DeconzBinarySensorDescription in binary_sensor.py and DeconzButtonDescription in button.py. While the pattern of change is identical (same before\u2192after transformation on the same type of syntactic construct), the changed lines reference different class symbols in different files. This appears to be part of a uniform refactoring sweep across the deconz component, but the symbols themselves are distinct."
        },
        {
            "src": 0,
            "tgt": 7,
            "reason": "Both edits perform an identical structural refactoring pattern: they remove a mixin class and consolidate its functionality into the main description class, while adding the same decorator parameter (kw_only=True) and reordering the inheritance to put Generic[T] first. This is a uniform, synchronized substitution across the same type of syntactic construct (dataclass definitions) in related files within the same component. The before\u2192after pattern is identical in both cases, and both target the same construct type (dataclass inheritance hierarchies). This represents a single, contiguous refactoring operation where either edit could be made first, and after making one, the other becomes the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 7,
            "tgt": 0,
            "reason": "Both edits perform an identical structural refactoring pattern: they remove a mixin class and consolidate its functionality into the main description class, while adding the same decorator parameter (kw_only=True) and reordering the inheritance to put Generic[T] first. This is a uniform, synchronized substitution across the same type of syntactic construct (dataclass definitions) in related files within the same component. The before\u2192after pattern is identical in both cases, and both target the same construct type (dataclass inheritance hierarchies). This represents a single, contiguous refactoring operation where either edit could be made first, and after making one, the other becomes the immediate next step to maintain consistency across the codebase."
        },
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 removes the DeconzBinarySensorDescriptionMixin class and consolidates its functionality into DeconzBinarySensorDescription. Edit 1 adds the update_key and value_fn fields directly to DeconzBinarySensorDescription. These edits are part of a single refactoring operation where the mixin pattern is being eliminated in favor of direct field definitions. The fields being added in edit 1 (update_key and value_fn) are the exact same fields that were defined in the mixin class being removed in edit 0. This creates a direct structural dependency - after removing the mixin inheritance, the fields must be added directly to maintain the same interface. Both edits reference the same symbols (update_key and value_fn) and are part of one contiguous refactoring micro-task."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 removes the DeconzBinarySensorDescriptionMixin class and consolidates its functionality into DeconzBinarySensorDescription. Edit 1 adds the update_key and value_fn fields directly to DeconzBinarySensorDescription. These edits are part of a single refactoring operation where the mixin pattern is being eliminated in favor of direct field definitions. The fields being added in edit 1 (update_key and value_fn) are the exact same fields that were defined in the mixin class being removed in edit 0. This creates a direct structural dependency - after removing the mixin inheritance, the fields must be added directly to maintain the same interface. Both edits reference the same symbols (update_key and value_fn) and are part of one contiguous refactoring micro-task."
        },
        {
            "src": 2,
            "tgt": 5,
            "reason": "Both edits perform an identical structural transformation: changing @dataclass to @dataclass(kw_only=True) and renaming classes from *DescriptionMixin to *Description while adding inheritance from their respective EntityDescription base classes. This is a uniform refactoring pattern applied to the same type of syntactic construct (dataclass decorators and class definitions) across different files in the same component. The edits represent a synchronized bulk substitution with identical before\u2192after patterns."
        },
        {
            "src": 5,
            "tgt": 2,
            "reason": "Both edits perform an identical structural transformation: changing @dataclass to @dataclass(kw_only=True) and renaming classes from *DescriptionMixin to *Description while adding inheritance from their respective EntityDescription base classes. This is a uniform refactoring pattern applied to the same type of syntactic construct (dataclass decorators and class definitions) across different files in the same component. The edits represent a synchronized bulk substitution with identical before\u2192after patterns."
        },
        {
            "src": 2,
            "tgt": 7,
            "reason": "Both edits perform an identical structural transformation on dataclass definitions in the same codebase: they both add 'kw_only=True' to the @dataclass decorator and modify the class inheritance structure. However, they operate on completely different classes in different files - DeconzButtonDescription in button.py and DeconzSensorDescription in sensor.py. While the pattern of change is identical (same before\u2192after transformation on the same type of syntactic construct), the changed lines reference different symbols/classes. This appears to be part of a bulk refactoring operation to standardize dataclass definitions across the deconz component, but since the exact same symbol is not referenced in both edits, they don't create immediate code-driven prompts for each other."
        },
        {
            "src": 7,
            "tgt": 2,
            "reason": "Both edits perform an identical structural transformation on dataclass definitions in the same codebase: they both add 'kw_only=True' to the @dataclass decorator and modify the class inheritance structure. However, they operate on completely different classes in different files - DeconzButtonDescription in button.py and DeconzSensorDescription in sensor.py. While the pattern of change is identical (same before\u2192after transformation on the same type of syntactic construct), the changed lines reference different symbols/classes. This appears to be part of a bulk refactoring operation to standardize dataclass definitions across the deconz component, but since the exact same symbol is not referenced in both edits, they don't create immediate code-driven prompts for each other."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Edit 0 changes the class definition from 'DeconzButtonDescriptionMixin' to 'DeconzButtonDescription(ButtonEntityDescription)' and adds kw_only=True to the dataclass decorator. Edit 1 removes the separate 'DeconzButtonDescription' class that inherited from both 'ButtonEntityDescription' and 'DeconzButtonDescriptionMixin', and adds a 'suffix: str' field. These edits are consolidating two classes into one - the mixin class is being transformed into the final class, eliminating the need for the separate inheriting class. The changed lines reference the exact same symbol 'DeconzButtonDescriptionMixin' in edit 0's removal and edit 1's removal from the inheritance list. This is a refactoring where both edits work together to merge class definitions, and either edit naturally prompts the other as the next mechanical step in the consolidation process."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Edit 0 changes the class definition from 'DeconzButtonDescriptionMixin' to 'DeconzButtonDescription(ButtonEntityDescription)' and adds kw_only=True to the dataclass decorator. Edit 1 removes the separate 'DeconzButtonDescription' class that inherited from both 'ButtonEntityDescription' and 'DeconzButtonDescriptionMixin', and adds a 'suffix: str' field. These edits are consolidating two classes into one - the mixin class is being transformed into the final class, eliminating the need for the separate inheriting class. The changed lines reference the exact same symbol 'DeconzButtonDescriptionMixin' in edit 0's removal and edit 1's removal from the inheritance list. This is a refactoring where both edits work together to merge class definitions, and either edit naturally prompts the other as the next mechanical step in the consolidation process."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Edit 0 removes the 'suffix: str' line from the DeconzButtonDescriptionMixin class, while Edit 1 removes the DeconzButtonDescription class definition and adds 'suffix: str' back to the mixin class. These edits reference the exact same symbol ('suffix: str') and appear to be part of a refactoring where the suffix attribute is being moved or reorganized within the class structure. The edits are mechanically linked because they both manipulate the same attribute definition, and either edit naturally prompts consideration of the other as part of the same structural change."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Edit 0 removes the 'suffix: str' line from the DeconzButtonDescriptionMixin class, while Edit 1 removes the DeconzButtonDescription class definition and adds 'suffix: str' back to the mixin class. These edits reference the exact same symbol ('suffix: str') and appear to be part of a refactoring where the suffix attribute is being moved or reorganized within the class structure. The edits are mechanically linked because they both manipulate the same attribute definition, and either edit naturally prompts consideration of the other as part of the same structural change."
        },
        {
            "src": 5,
            "tgt": 6,
            "reason": "Edit 0 changes the class definition from 'DeconzNumberDescriptionMixin' to 'DeconzNumberDescription', while Edit 1 removes the old 'DeconzNumberDescription' class that inherited from 'DeconzNumberDescriptionMixin'. The changed lines reference the exact same symbol 'DeconzNumberDescriptionMixin' - Edit 0 renames it and Edit 1 removes its usage. This is a refactoring where the mixin class is being consolidated into a single class. Edit 0 must happen before Edit 1 because Edit 1 removes the reference to 'DeconzNumberDescriptionMixin' which would create a NameError if Edit 0 hasn't already renamed that class. The dependency is explicit in the code - Edit 1's removed line directly references the symbol being renamed in Edit 0."
        },
        {
            "src": 5,
            "tgt": 7,
            "reason": "Both edits perform an identical structural transformation on dataclass definitions: they both change from a mixin pattern to a direct inheritance pattern, add the same `kw_only=True` parameter to the `@dataclass` decorator, and restructure the class hierarchy in the same way. The edits target the same type of syntactic construct (dataclass definitions) with identical before\u2192after patterns, making this a clear case of bulk-edit/pattern synchronization within a single refactoring operation."
        },
        {
            "src": 7,
            "tgt": 5,
            "reason": "Both edits perform an identical structural transformation on dataclass definitions: they both change from a mixin pattern to a direct inheritance pattern, add the same `kw_only=True` parameter to the `@dataclass` decorator, and restructure the class hierarchy in the same way. The edits target the same type of syntactic construct (dataclass definitions) with identical before\u2192after patterns, making this a clear case of bulk-edit/pattern synchronization within a single refactoring operation."
        },
        {
            "src": 7,
            "tgt": 8,
            "reason": "Edit 0 removes the DeconzSensorDescriptionMixin class and modifies the DeconzSensorDescription class definition, while Edit 1 adds the fields (supported_fn, update_key, value_fn) that were previously defined in the removed mixin directly to the DeconzSensorDescription class. This is a classic refactoring pattern where a mixin is being eliminated by moving its fields directly into the main class. Edit 0 must happen first because it removes the mixin inheritance from DeconzSensorDescription, and Edit 1 adds the fields that were previously inherited from that mixin. If Edit 1 were applied first, the fields would be duplicated (existing in both the mixin and the class), and if Edit 0 were applied after that, it would remove the mixin but the fields would remain in the class, which is the desired end state. However, the natural flow is to first restructure the class hierarchy (Edit 0) and then add the previously inherited fields directly (Edit 1)."
        }
    ],
    "allowed_init_edits": [
        1,
        3,
        6,
        8
    ]
}