{
    "partial_orders": [
        {
            "src": 1,
            "tgt": 5,
            "reason": "Both edits perform an identical textual and structural substitution: replacing 'masked_result._update_from(result)' with the same conditional logic that checks isinstance(a, MaskedArray) and isinstance(b, MaskedArray) to call _update_from with either a or b. The before\u2192after pattern is identical, and both target the same type of syntactic construct (method call statements within similar class methods). This represents a bulk uniform substitution pattern where the same refactoring logic is being applied consistently across related code locations."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Both edits perform an identical textual and structural substitution: replacing 'masked_result._update_from(result)' with the same conditional logic that checks isinstance(a, MaskedArray) and isinstance(b, MaskedArray) to call _update_from with either a or b. The before\u2192after pattern is identical, and both target the same type of syntactic construct (method call statements within similar class methods). This represents a bulk uniform substitution pattern where the same refactoring logic is being applied consistently across related code locations."
        },
        {
            "src": 6,
            "tgt": 7,
            "reason": "Edit 0 defines the SubMaskedArray class, while Edit 1 creates a test method that instantiates and uses that exact same SubMaskedArray class. The changed lines in Edit 1 explicitly reference the SubMaskedArray symbol that is defined in Edit 0's changed lines. This creates a direct definition-usage relationship where both edits reference the exact same symbol. After defining SubMaskedArray in Edit 0, the natural next step would be to test it (Edit 1), and conversely, the test in Edit 1 requires the class definition from Edit 0. Since this appears to be part of the same development session where a class is being introduced and immediately tested, and both edits can be parsed in either order (the test would only fail at runtime if the class isn't defined), this is a bi-directional relationship."
        },
        {
            "src": 7,
            "tgt": 6,
            "reason": "Edit 0 defines the SubMaskedArray class, while Edit 1 creates a test method that instantiates and uses that exact same SubMaskedArray class. The changed lines in Edit 1 explicitly reference the SubMaskedArray symbol that is defined in Edit 0's changed lines. This creates a direct definition-usage relationship where both edits reference the exact same symbol. After defining SubMaskedArray in Edit 0, the natural next step would be to test it (Edit 1), and conversely, the test in Edit 1 requires the class definition from Edit 0. Since this appears to be part of the same development session where a class is being introduced and immediately tested, and both edits can be parsed in either order (the test would only fail at runtime if the class isn't defined), this is a bi-directional relationship."
        }
    ],
    "allowed_init_edits": [
        0,
        2,
        3,
        4
    ]
}