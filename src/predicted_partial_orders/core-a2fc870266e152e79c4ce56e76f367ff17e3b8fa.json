{
    "partial_orders": [
        {
            "src": 0,
            "tgt": 1,
            "reason": "Edit 0 imports EventImageType from google_nest_sdm.event, and Edit 1 uses EventImageType in the expression (event.event_image_type == EventImageType.CLIP_PREVIEW). The changed lines reference the exact same symbol EventImageType - Edit 0 makes it available through import, and Edit 1 uses it. After making Edit 0, Edit 1 becomes the immediate next step to use the newly imported symbol. This is a classic import-usage pattern within the same file where both edits reference the exact same symbol."
        },
        {
            "src": 1,
            "tgt": 0,
            "reason": "Edit 0 imports EventImageType from google_nest_sdm.event, and Edit 1 uses EventImageType in the expression (event.event_image_type == EventImageType.CLIP_PREVIEW). The changed lines reference the exact same symbol EventImageType - Edit 0 makes it available through import, and Edit 1 uses it. After making Edit 0, Edit 1 becomes the immediate next step to use the newly imported symbol. This is a classic import-usage pattern within the same file where both edits reference the exact same symbol."
        },
        {
            "src": 2,
            "tgt": 3,
            "reason": "Both edits add identical assertion lines (`assert not browse.can_play`) to different test functions within the same test file. This represents a synchronized pattern addition where the same structural change is being applied to multiple test cases. The edits involve the same syntactic construct (assertion statements) with identical before\u2192after patterns (adding the same assertion). This appears to be part of a single, contiguous refactoring effort to add consistent test coverage for the `can_play` attribute across multiple test functions."
        },
        {
            "src": 3,
            "tgt": 2,
            "reason": "Both edits add identical assertion lines (`assert not browse.can_play`) to different test functions within the same test file. This represents a synchronized pattern addition where the same structural change is being applied to multiple test cases. The edits involve the same syntactic construct (assertion statements) with identical before\u2192after patterns (adding the same assertion). This appears to be part of a single, contiguous refactoring effort to add consistent test coverage for the `can_play` attribute across multiple test functions."
        },
        {
            "src": 2,
            "tgt": 4,
            "reason": "Both edits add identical assertion statements (`assert not browse.can_play`) to different test functions within the same test file. This represents a synchronized pattern addition where the same structural change is being applied to multiple test functions, likely as part of a single refactoring effort to add consistent test coverage for the `can_play` attribute. The edits involve identical textual substitution (adding the same assertion line) targeting the same type of syntactic construct (test assertions), making this a bulk-edit pattern synchronization that would naturally occur in one contiguous micro-task."
        },
        {
            "src": 4,
            "tgt": 2,
            "reason": "Both edits add identical assertion statements (`assert not browse.can_play`) to different test functions within the same test file. This represents a synchronized pattern addition where the same structural change is being applied to multiple test functions, likely as part of a single refactoring effort to add consistent test coverage for the `can_play` attribute. The edits involve identical textual substitution (adding the same assertion line) targeting the same type of syntactic construct (test assertions), making this a bulk-edit pattern synchronization that would naturally occur in one contiguous micro-task."
        },
        {
            "src": 1,
            "tgt": 5,
            "reason": "Edit 0 changes the logic for determining when a media item can be played by setting `can_play=(event.event_image_type == EventImageType.CLIP_PREVIEW)` instead of always `True`. Edit 1 adds a test assertion `assert browse.children[0].can_play` in a test function specifically named `test_camera_event_clip_preview`. The test is verifying the exact behavior that was modified in edit 0 - that clip preview events should be playable. The test assertion directly validates the `can_play` property that was changed in the production code, creating a direct test-production synchronization for the same functionality."
        },
        {
            "src": 5,
            "tgt": 1,
            "reason": "Edit 0 changes the logic for determining when a media item can be played by setting `can_play=(event.event_image_type == EventImageType.CLIP_PREVIEW)` instead of always `True`. Edit 1 adds a test assertion `assert browse.children[0].can_play` in a test function specifically named `test_camera_event_clip_preview`. The test is verifying the exact behavior that was modified in edit 0 - that clip preview events should be playable. The test assertion directly validates the `can_play` property that was changed in the production code, creating a direct test-production synchronization for the same functionality."
        },
        {
            "src": 1,
            "tgt": 2,
            "reason": "Edit 0 changes the `can_play` property logic in the `_browse_event` function from a hardcoded `True` to a conditional expression based on `event.event_image_type`. Edit 1 adds a test assertion `assert not browse.can_play` which directly tests the `can_play` property of the BrowseMediaSource object returned by the function modified in Edit 0. The test assertion is specifically validating the behavior change introduced in Edit 0 - both edits reference the exact same `can_play` attribute of the same BrowseMediaSource object. This creates a direct code dependency where the test assertion validates the implementation change, making them bi-directional neighbors in the same development session."
        },
        {
            "src": 2,
            "tgt": 1,
            "reason": "Edit 0 changes the `can_play` property logic in the `_browse_event` function from a hardcoded `True` to a conditional expression based on `event.event_image_type`. Edit 1 adds a test assertion `assert not browse.can_play` which directly tests the `can_play` property of the BrowseMediaSource object returned by the function modified in Edit 0. The test assertion is specifically validating the behavior change introduced in Edit 0 - both edits reference the exact same `can_play` attribute of the same BrowseMediaSource object. This creates a direct code dependency where the test assertion validates the implementation change, making them bi-directional neighbors in the same development session."
        },
        {
            "src": 3,
            "tgt": 4,
            "reason": "Both edits add identical assertion lines (`assert not browse.can_play`) within the same test function `test_event_order`. This represents a bulk-edit pattern where the same structural change (adding the same assertion) is being applied to multiple locations within the same test context. The edits involve identical textual substitution (adding the same line) and target the same type of syntactic construct (assertion statements). Both edits reference the same `browse` object and test the same `can_play` attribute, making this a synchronized addition pattern within the same function scope. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the test assertions."
        },
        {
            "src": 4,
            "tgt": 3,
            "reason": "Both edits add identical assertion lines (`assert not browse.can_play`) within the same test function `test_event_order`. This represents a bulk-edit pattern where the same structural change (adding the same assertion) is being applied to multiple locations within the same test context. The edits involve identical textual substitution (adding the same line) and target the same type of syntactic construct (assertion statements). Both edits reference the same `browse` object and test the same `can_play` attribute, making this a synchronized addition pattern within the same function scope. Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the test assertions."
        }
    ],
    "allowed_init_edits": [
        0,
        5
    ]
}