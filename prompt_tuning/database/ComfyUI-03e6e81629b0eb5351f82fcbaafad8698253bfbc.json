{
    "language": "python",
    "commit_url": "https://github.com/comfyanonymous/ComfyUI/commit/03e6e81629b0eb5351f82fcbaafad8698253bfbc",
    "commit_message": "Set upscale algorithm to bilinear for stable cascade controlnet.",
    "commit_snapshots": {
        "comfy/controlnet.py": [
            [
                "import torch\n",
                "import math\n",
                "import os\n",
                "import comfy.utils\n",
                "import comfy.model_management\n",
                "import comfy.model_detection\n",
                "import comfy.model_patcher\n",
                "import comfy.ops\n",
                "\n",
                "import comfy.cldm.cldm\n",
                "import comfy.t2i_adapter.adapter\n",
                "import comfy.ldm.cascade.controlnet\n",
                "\n",
                "\n",
                "def broadcast_image_to(tensor, target_batch_size, batched_number):\n",
                "    current_batch_size = tensor.shape[0]\n",
                "    #print(current_batch_size, target_batch_size)\n",
                "    if current_batch_size == 1:\n",
                "        return tensor\n",
                "\n",
                "    per_batch = target_batch_size // batched_number\n",
                "    tensor = tensor[:per_batch]\n",
                "\n",
                "    if per_batch > tensor.shape[0]:\n",
                "        tensor = torch.cat([tensor] * (per_batch // tensor.shape[0]) + [tensor[:(per_batch % tensor.shape[0])]], dim=0)\n",
                "\n",
                "    current_batch_size = tensor.shape[0]\n",
                "    if current_batch_size == target_batch_size:\n",
                "        return tensor\n",
                "    else:\n",
                "        return torch.cat([tensor] * batched_number, dim=0)\n",
                "\n",
                "class ControlBase:\n",
                "    def __init__(self, device=None):\n",
                "        self.cond_hint_original = None\n",
                "        self.cond_hint = None\n",
                "        self.strength = 1.0\n",
                "        self.timestep_percent_range = (0.0, 1.0)\n",
                "        self.global_average_pooling = False\n",
                "        self.timestep_range = None\n",
                "        self.compression_ratio = 8\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        self.upscale_algorithm = 'nearest-exact'\n"
                ],
                "parent_version_range": {
                    "start": 41,
                    "end": 41
                },
                "child_version_range": {
                    "start": 41,
                    "end": 42
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "ControlBase",
                        "signature": "class ControlBase:",
                        "at_line": 32
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(self, device=None):",
                        "at_line": 33
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: comfy/controlnet.py\nCode:\n         class ControlBase:\n             ...\n             def __init__(self, device=None):\n                 ...\n38 38            self.global_average_pooling = False\n39 39            self.timestep_range = None\n40 40            self.compression_ratio = 8\n   41  +         self.upscale_algorithm = 'nearest-exact'\n41 42    \n42 43            if device is None:\n43 44                device = comfy.model_management.get_torch_device()\n       ...\n",
                "file_path": "comfy/controlnet.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "self",
                    "upscale_algorithm"
                ],
                "prefix": [
                    "        self.global_average_pooling = False\n",
                    "        self.timestep_range = None\n",
                    "        self.compression_ratio = 8\n"
                ],
                "suffix": [
                    "\n",
                    "        if device is None:\n",
                    "            device = comfy.model_management.get_torch_device()\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "upscale_algorithm",
                            "position": {
                                "start": {
                                    "line": 41,
                                    "column": 13
                                },
                                "end": {
                                    "line": 41,
                                    "column": 30
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "upscale_algorithm",
                            "position": {
                                "start": {
                                    "line": 41,
                                    "column": 13
                                },
                                "end": {
                                    "line": 41,
                                    "column": 30
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    7
                ]
            },
            [
                "\n",
                "        if device is None:\n",
                "            device = comfy.model_management.get_torch_device()\n",
                "        self.device = device\n",
                "        self.previous_controlnet = None\n",
                "\n",
                "    def set_cond_hint(self, cond_hint, strength=1.0, timestep_percent_range=(0.0, 1.0)):\n",
                "        self.cond_hint_original = cond_hint\n",
                "        self.strength = strength\n",
                "        self.timestep_percent_range = timestep_percent_range\n",
                "        return self\n",
                "\n",
                "    def pre_run(self, model, percent_to_timestep_function):\n",
                "        self.timestep_range = (percent_to_timestep_function(self.timestep_percent_range[0]), percent_to_timestep_function(self.timestep_percent_range[1]))\n",
                "        if self.previous_controlnet is not None:\n",
                "            self.previous_controlnet.pre_run(model, percent_to_timestep_function)\n",
                "\n",
                "    def set_previous_controlnet(self, controlnet):\n",
                "        self.previous_controlnet = controlnet\n",
                "        return self\n",
                "\n",
                "    def cleanup(self):\n",
                "        if self.previous_controlnet is not None:\n",
                "            self.previous_controlnet.cleanup()\n",
                "        if self.cond_hint is not None:\n",
                "            del self.cond_hint\n",
                "            self.cond_hint = None\n",
                "        self.timestep_range = None\n",
                "\n",
                "    def get_models(self):\n",
                "        out = []\n",
                "        if self.previous_controlnet is not None:\n",
                "            out += self.previous_controlnet.get_models()\n",
                "        return out\n",
                "\n",
                "    def copy_to(self, c):\n",
                "        c.cond_hint_original = self.cond_hint_original\n",
                "        c.strength = self.strength\n",
                "        c.timestep_percent_range = self.timestep_percent_range\n",
                "        c.global_average_pooling = self.global_average_pooling\n",
                "        c.compression_ratio = self.compression_ratio\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        c.upscale_algorithm = self.upscale_algorithm\n"
                ],
                "parent_version_range": {
                    "start": 82,
                    "end": 82
                },
                "child_version_range": {
                    "start": 83,
                    "end": 84
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "ControlBase",
                        "signature": "class ControlBase:",
                        "at_line": 32
                    },
                    {
                        "type": "function",
                        "name": "copy_to",
                        "signature": "def copy_to(self, c):",
                        "at_line": 76
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: comfy/controlnet.py\nCode:\n         class ControlBase:\n             ...\n             def copy_to(self, c):\n                 ...\n79 80            c.timestep_percent_range = self.timestep_percent_range\n80 81            c.global_average_pooling = self.global_average_pooling\n81 82            c.compression_ratio = self.compression_ratio\n   83  +         c.upscale_algorithm = self.upscale_algorithm\n82 84    \n83 85        def inference_memory_requirements(self, dtype):\n84 86            if self.previous_controlnet is not None:\n       ...\n",
                "file_path": "comfy/controlnet.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "c",
                    "self",
                    "upscale_algorithm"
                ],
                "prefix": [
                    "        c.timestep_percent_range = self.timestep_percent_range\n",
                    "        c.global_average_pooling = self.global_average_pooling\n",
                    "        c.compression_ratio = self.compression_ratio\n"
                ],
                "suffix": [
                    "\n",
                    "    def inference_memory_requirements(self, dtype):\n",
                    "        if self.previous_controlnet is not None:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "upscale_algorithm",
                            "position": {
                                "start": {
                                    "line": 83,
                                    "column": 35
                                },
                                "end": {
                                    "line": 83,
                                    "column": 52
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    4
                ]
            },
            [
                "\n",
                "    def inference_memory_requirements(self, dtype):\n",
                "        if self.previous_controlnet is not None:\n",
                "            return self.previous_controlnet.inference_memory_requirements(dtype)\n",
                "        return 0\n",
                "\n",
                "    def control_merge(self, control_input, control_output, control_prev, output_dtype):\n",
                "        out = {'input':[], 'middle':[], 'output': []}\n",
                "\n",
                "        if control_input is not None:\n",
                "            for i in range(len(control_input)):\n",
                "                key = 'input'\n",
                "                x = control_input[i]\n",
                "                if x is not None:\n",
                "                    x *= self.strength\n",
                "                    if x.dtype != output_dtype:\n",
                "                        x = x.to(output_dtype)\n",
                "                out[key].insert(0, x)\n",
                "\n",
                "        if control_output is not None:\n",
                "            for i in range(len(control_output)):\n",
                "                if i == (len(control_output) - 1):\n",
                "                    key = 'middle'\n",
                "                    index = 0\n",
                "                else:\n",
                "                    key = 'output'\n",
                "                    index = i\n",
                "                x = control_output[i]\n",
                "                if x is not None:\n",
                "                    if self.global_average_pooling:\n",
                "                        x = torch.mean(x, dim=(2, 3), keepdim=True).repeat(1, 1, x.shape[2], x.shape[3])\n",
                "\n",
                "                    x *= self.strength\n",
                "                    if x.dtype != output_dtype:\n",
                "                        x = x.to(output_dtype)\n",
                "\n",
                "                out[key].append(x)\n",
                "        if control_prev is not None:\n",
                "            for x in ['input', 'middle', 'output']:\n",
                "                o = out[x]\n",
                "                for i in range(len(control_prev[x])):\n",
                "                    prev_val = control_prev[x][i]\n",
                "                    if i >= len(o):\n",
                "                        o.append(prev_val)\n",
                "                    elif prev_val is not None:\n",
                "                        if o[i] is None:\n",
                "                            o[i] = prev_val\n",
                "                        else:\n",
                "                            if o[i].shape[0] < prev_val.shape[0]:\n",
                "                                o[i] = prev_val + o[i]\n",
                "                            else:\n",
                "                                o[i] += prev_val\n",
                "        return out\n",
                "\n",
                "class ControlNet(ControlBase):\n",
                "    def __init__(self, control_model, global_average_pooling=False, device=None, load_device=None, manual_cast_dtype=None):\n",
                "        super().__init__(device)\n",
                "        self.control_model = control_model\n",
                "        self.load_device = load_device\n",
                "        self.control_model_wrapped = comfy.model_patcher.ModelPatcher(self.control_model, load_device=load_device, offload_device=comfy.model_management.unet_offload_device())\n",
                "        self.global_average_pooling = global_average_pooling\n",
                "        self.model_sampling_current = None\n",
                "        self.manual_cast_dtype = manual_cast_dtype\n",
                "\n",
                "    def get_control(self, x_noisy, t, cond, batched_number):\n",
                "        control_prev = None\n",
                "        if self.previous_controlnet is not None:\n",
                "            control_prev = self.previous_controlnet.get_control(x_noisy, t, cond, batched_number)\n",
                "\n",
                "        if self.timestep_range is not None:\n",
                "            if t[0] > self.timestep_range[0] or t[0] < self.timestep_range[1]:\n",
                "                if control_prev is not None:\n",
                "                    return control_prev\n",
                "                else:\n",
                "                    return None\n",
                "\n",
                "        dtype = self.control_model.dtype\n",
                "        if self.manual_cast_dtype is not None:\n",
                "            dtype = self.manual_cast_dtype\n",
                "\n",
                "        output_dtype = x_noisy.dtype\n",
                "        if self.cond_hint is None or x_noisy.shape[2] * self.compression_ratio != self.cond_hint.shape[2] or x_noisy.shape[3] * self.compression_ratio != self.cond_hint.shape[3]:\n",
                "            if self.cond_hint is not None:\n",
                "                del self.cond_hint\n",
                "            self.cond_hint = None\n"
            ],
            {
                "type": "replace",
                "before": [
                    "            self.cond_hint = comfy.utils.common_upscale(self.cond_hint_original, x_noisy.shape[3] * self.compression_ratio, x_noisy.shape[2] * self.compression_ratio, 'nearest-exact', \"center\").to(dtype).to(self.device)\n"
                ],
                "after": [
                    "            self.cond_hint = comfy.utils.common_upscale(self.cond_hint_original, x_noisy.shape[3] * self.compression_ratio, x_noisy.shape[2] * self.compression_ratio, self.upscale_algorithm, \"center\").to(dtype).to(self.device)\n"
                ],
                "parent_version_range": {
                    "start": 167,
                    "end": 168
                },
                "child_version_range": {
                    "start": 169,
                    "end": 170
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if self.cond_hint is None or x_noisy.shape[2] * self.compression_ratio != self.cond_hint.shape[2] or x_noisy.shape[3] * self.compression_ratio != self.cond_hint.shape[3]:",
                        "start_line": 163,
                        "end_line": 167
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "ControlNet",
                        "signature": "class ControlNet(ControlBase):",
                        "at_line": 136
                    },
                    {
                        "type": "function",
                        "name": "get_control",
                        "signature": "def get_control(self, x_noisy, t, cond, batched_number):",
                        "at_line": 146
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: comfy/controlnet.py\nCode:\n           class ControlNet(ControlBase):\n               ...\n               def get_control(self, x_noisy, t, cond, batched_number):\n                   ...\n164 166                if self.cond_hint is not None:\n165 167                    del self.cond_hint\n166 168                self.cond_hint = None\n167      -             self.cond_hint = comfy.utils.common_upscale(self.cond_hint_original, x_noisy.shape[3] * self.compression_ratio, x_noisy.shape[2] * self.compression_ratio, 'nearest-exact', \"center\").to(dtype).to(self.device)\n    169  +             self.cond_hint = comfy.utils.common_upscale(self.cond_hint_original, x_noisy.shape[3] * self.compression_ratio, x_noisy.shape[2] * self.compression_ratio, self.upscale_algorithm, \"center\").to(dtype).to(self.device)\n168 170            if x_noisy.shape[0] != self.cond_hint.shape[0]:\n169 171                self.cond_hint = broadcast_image_to(self.cond_hint, x_noisy.shape[0], batched_number)\n170 172    \n         ...\n",
                "file_path": "comfy/controlnet.py",
                "identifiers_before": [
                    "comfy",
                    "common_upscale",
                    "compression_ratio",
                    "cond_hint",
                    "cond_hint_original",
                    "device",
                    "dtype",
                    "self",
                    "shape",
                    "to",
                    "utils",
                    "x_noisy"
                ],
                "identifiers_after": [
                    "comfy",
                    "common_upscale",
                    "compression_ratio",
                    "cond_hint",
                    "cond_hint_original",
                    "device",
                    "dtype",
                    "self",
                    "shape",
                    "to",
                    "upscale_algorithm",
                    "utils",
                    "x_noisy"
                ],
                "prefix": [
                    "            if self.cond_hint is not None:\n",
                    "                del self.cond_hint\n",
                    "            self.cond_hint = None\n"
                ],
                "suffix": [
                    "        if x_noisy.shape[0] != self.cond_hint.shape[0]:\n",
                    "            self.cond_hint = broadcast_image_to(self.cond_hint, x_noisy.shape[0], batched_number)\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "upscale_algorithm",
                            "position": {
                                "start": {
                                    "line": 169,
                                    "column": 172
                                },
                                "end": {
                                    "line": 169,
                                    "column": 189
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    5
                ]
            },
            [
                "        if x_noisy.shape[0] != self.cond_hint.shape[0]:\n",
                "            self.cond_hint = broadcast_image_to(self.cond_hint, x_noisy.shape[0], batched_number)\n",
                "\n",
                "        context = cond.get('crossattn_controlnet', cond['c_crossattn'])\n",
                "        y = cond.get('y', None)\n",
                "        if y is not None:\n",
                "            y = y.to(dtype)\n",
                "        timestep = self.model_sampling_current.timestep(t)\n",
                "        x_noisy = self.model_sampling_current.calculate_input(t, x_noisy)\n",
                "\n",
                "        control = self.control_model(x=x_noisy.to(dtype), hint=self.cond_hint, timesteps=timestep.float(), context=context.to(dtype), y=y)\n",
                "        return self.control_merge(None, control, control_prev, output_dtype)\n",
                "\n",
                "    def copy(self):\n",
                "        c = ControlNet(self.control_model, global_average_pooling=self.global_average_pooling, load_device=self.load_device, manual_cast_dtype=self.manual_cast_dtype)\n",
                "        self.copy_to(c)\n",
                "        return c\n",
                "\n",
                "    def get_models(self):\n",
                "        out = super().get_models()\n",
                "        out.append(self.control_model_wrapped)\n",
                "        return out\n",
                "\n",
                "    def pre_run(self, model, percent_to_timestep_function):\n",
                "        super().pre_run(model, percent_to_timestep_function)\n",
                "        self.model_sampling_current = model.model_sampling\n",
                "\n",
                "    def cleanup(self):\n",
                "        self.model_sampling_current = None\n",
                "        super().cleanup()\n",
                "\n",
                "class ControlLoraOps:\n",
                "    class Linear(torch.nn.Module):\n",
                "        def __init__(self, in_features: int, out_features: int, bias: bool = True,\n",
                "                    device=None, dtype=None) -> None:\n",
                "            factory_kwargs = {'device': device, 'dtype': dtype}\n",
                "            super().__init__()\n",
                "            self.in_features = in_features\n",
                "            self.out_features = out_features\n",
                "            self.weight = None\n",
                "            self.up = None\n",
                "            self.down = None\n",
                "            self.bias = None\n",
                "\n",
                "        def forward(self, input):\n",
                "            weight, bias = comfy.ops.cast_bias_weight(self, input)\n",
                "            if self.up is not None:\n",
                "                return torch.nn.functional.linear(input, weight + (torch.mm(self.up.flatten(start_dim=1), self.down.flatten(start_dim=1))).reshape(self.weight.shape).type(input.dtype), bias)\n",
                "            else:\n",
                "                return torch.nn.functional.linear(input, weight, bias)\n",
                "\n",
                "    class Conv2d(torch.nn.Module):\n",
                "        def __init__(\n",
                "            self,\n",
                "            in_channels,\n",
                "            out_channels,\n",
                "            kernel_size,\n",
                "            stride=1,\n",
                "            padding=0,\n",
                "            dilation=1,\n",
                "            groups=1,\n",
                "            bias=True,\n",
                "            padding_mode='zeros',\n",
                "            device=None,\n",
                "            dtype=None\n",
                "        ):\n",
                "            super().__init__()\n",
                "            self.in_channels = in_channels\n",
                "            self.out_channels = out_channels\n",
                "            self.kernel_size = kernel_size\n",
                "            self.stride = stride\n",
                "            self.padding = padding\n",
                "            self.dilation = dilation\n",
                "            self.transposed = False\n",
                "            self.output_padding = 0\n",
                "            self.groups = groups\n",
                "            self.padding_mode = padding_mode\n",
                "\n",
                "            self.weight = None\n",
                "            self.bias = None\n",
                "            self.up = None\n",
                "            self.down = None\n",
                "\n",
                "\n",
                "        def forward(self, input):\n",
                "            weight, bias = comfy.ops.cast_bias_weight(self, input)\n",
                "            if self.up is not None:\n",
                "                return torch.nn.functional.conv2d(input, weight + (torch.mm(self.up.flatten(start_dim=1), self.down.flatten(start_dim=1))).reshape(self.weight.shape).type(input.dtype), bias, self.stride, self.padding, self.dilation, self.groups)\n",
                "            else:\n",
                "                return torch.nn.functional.conv2d(input, weight, bias, self.stride, self.padding, self.dilation, self.groups)\n",
                "\n",
                "\n",
                "class ControlLora(ControlNet):\n",
                "    def __init__(self, control_weights, global_average_pooling=False, device=None):\n",
                "        ControlBase.__init__(self, device)\n",
                "        self.control_weights = control_weights\n",
                "        self.global_average_pooling = global_average_pooling\n",
                "\n",
                "    def pre_run(self, model, percent_to_timestep_function):\n",
                "        super().pre_run(model, percent_to_timestep_function)\n",
                "        controlnet_config = model.model_config.unet_config.copy()\n",
                "        controlnet_config.pop(\"out_channels\")\n",
                "        controlnet_config[\"hint_channels\"] = self.control_weights[\"input_hint_block.0.weight\"].shape[1]\n",
                "        self.manual_cast_dtype = model.manual_cast_dtype\n",
                "        dtype = model.get_dtype()\n",
                "        if self.manual_cast_dtype is None:\n",
                "            class control_lora_ops(ControlLoraOps, comfy.ops.disable_weight_init):\n",
                "                pass\n",
                "        else:\n",
                "            class control_lora_ops(ControlLoraOps, comfy.ops.manual_cast):\n",
                "                pass\n",
                "            dtype = self.manual_cast_dtype\n",
                "\n",
                "        controlnet_config[\"operations\"] = control_lora_ops\n",
                "        controlnet_config[\"dtype\"] = dtype\n",
                "        self.control_model = comfy.cldm.cldm.ControlNet(**controlnet_config)\n",
                "        self.control_model.to(comfy.model_management.get_torch_device())\n",
                "        diffusion_model = model.diffusion_model\n",
                "        sd = diffusion_model.state_dict()\n",
                "        cm = self.control_model.state_dict()\n",
                "\n",
                "        for k in sd:\n",
                "            weight = sd[k]\n",
                "            try:\n",
                "                comfy.utils.set_attr_param(self.control_model, k, weight)\n",
                "            except:\n",
                "                pass\n",
                "\n",
                "        for k in self.control_weights:\n",
                "            if k not in {\"lora_controlnet\"}:\n",
                "                comfy.utils.set_attr_param(self.control_model, k, self.control_weights[k].to(dtype).to(comfy.model_management.get_torch_device()))\n",
                "\n",
                "    def copy(self):\n",
                "        c = ControlLora(self.control_weights, global_average_pooling=self.global_average_pooling)\n",
                "        self.copy_to(c)\n",
                "        return c\n",
                "\n",
                "    def cleanup(self):\n",
                "        del self.control_model\n",
                "        self.control_model = None\n",
                "        super().cleanup()\n",
                "\n",
                "    def get_models(self):\n",
                "        out = ControlBase.get_models(self)\n",
                "        return out\n",
                "\n",
                "    def inference_memory_requirements(self, dtype):\n",
                "        return comfy.utils.calculate_parameters(self.control_weights) * comfy.model_management.dtype_size(dtype) + ControlBase.inference_memory_requirements(self, dtype)\n",
                "\n",
                "def load_controlnet(ckpt_path, model=None):\n",
                "    controlnet_data = comfy.utils.load_torch_file(ckpt_path, safe_load=True)\n",
                "    if \"lora_controlnet\" in controlnet_data:\n",
                "        return ControlLora(controlnet_data)\n",
                "\n",
                "    controlnet_config = None\n",
                "    supported_inference_dtypes = None\n",
                "\n",
                "    if \"controlnet_cond_embedding.conv_in.weight\" in controlnet_data: #diffusers format\n",
                "        controlnet_config = comfy.model_detection.unet_config_from_diffusers_unet(controlnet_data)\n",
                "        diffusers_keys = comfy.utils.unet_to_diffusers(controlnet_config)\n",
                "        diffusers_keys[\"controlnet_mid_block.weight\"] = \"middle_block_out.0.weight\"\n",
                "        diffusers_keys[\"controlnet_mid_block.bias\"] = \"middle_block_out.0.bias\"\n",
                "\n",
                "        count = 0\n",
                "        loop = True\n",
                "        while loop:\n",
                "            suffix = [\".weight\", \".bias\"]\n",
                "            for s in suffix:\n",
                "                k_in = \"controlnet_down_blocks.{}{}\".format(count, s)\n",
                "                k_out = \"zero_convs.{}.0{}\".format(count, s)\n",
                "                if k_in not in controlnet_data:\n",
                "                    loop = False\n",
                "                    break\n",
                "                diffusers_keys[k_in] = k_out\n",
                "            count += 1\n",
                "\n",
                "        count = 0\n",
                "        loop = True\n",
                "        while loop:\n",
                "            suffix = [\".weight\", \".bias\"]\n",
                "            for s in suffix:\n",
                "                if count == 0:\n",
                "                    k_in = \"controlnet_cond_embedding.conv_in{}\".format(s)\n",
                "                else:\n",
                "                    k_in = \"controlnet_cond_embedding.blocks.{}{}\".format(count - 1, s)\n",
                "                k_out = \"input_hint_block.{}{}\".format(count * 2, s)\n",
                "                if k_in not in controlnet_data:\n",
                "                    k_in = \"controlnet_cond_embedding.conv_out{}\".format(s)\n",
                "                    loop = False\n",
                "                diffusers_keys[k_in] = k_out\n",
                "            count += 1\n",
                "\n",
                "        new_sd = {}\n",
                "        for k in diffusers_keys:\n",
                "            if k in controlnet_data:\n",
                "                new_sd[diffusers_keys[k]] = controlnet_data.pop(k)\n",
                "\n",
                "        leftover_keys = controlnet_data.keys()\n",
                "        if len(leftover_keys) > 0:\n",
                "            print(\"leftover keys:\", leftover_keys)\n",
                "        controlnet_data = new_sd\n",
                "\n",
                "    pth_key = 'control_model.zero_convs.0.0.weight'\n",
                "    pth = False\n",
                "    key = 'zero_convs.0.0.weight'\n",
                "    if pth_key in controlnet_data:\n",
                "        pth = True\n",
                "        key = pth_key\n",
                "        prefix = \"control_model.\"\n",
                "    elif key in controlnet_data:\n",
                "        prefix = \"\"\n",
                "    else:\n",
                "        net = load_t2i_adapter(controlnet_data)\n",
                "        if net is None:\n",
                "            print(\"error checkpoint does not contain controlnet or t2i adapter data\", ckpt_path)\n",
                "        return net\n",
                "\n",
                "    if controlnet_config is None:\n",
                "        model_config = comfy.model_detection.model_config_from_unet(controlnet_data, prefix, True)\n",
                "        supported_inference_dtypes = model_config.supported_inference_dtypes\n",
                "        controlnet_config = model_config.unet_config\n",
                "\n",
                "    load_device = comfy.model_management.get_torch_device()\n",
                "    if supported_inference_dtypes is None:\n",
                "        unet_dtype = comfy.model_management.unet_dtype()\n",
                "    else:\n",
                "        unet_dtype = comfy.model_management.unet_dtype(supported_dtypes=supported_inference_dtypes)\n",
                "\n",
                "    manual_cast_dtype = comfy.model_management.unet_manual_cast(unet_dtype, load_device)\n",
                "    if manual_cast_dtype is not None:\n",
                "        controlnet_config[\"operations\"] = comfy.ops.manual_cast\n",
                "    controlnet_config[\"dtype\"] = unet_dtype\n",
                "    controlnet_config.pop(\"out_channels\")\n",
                "    controlnet_config[\"hint_channels\"] = controlnet_data[\"{}input_hint_block.0.weight\".format(prefix)].shape[1]\n",
                "    control_model = comfy.cldm.cldm.ControlNet(**controlnet_config)\n",
                "\n",
                "    if pth:\n",
                "        if 'difference' in controlnet_data:\n",
                "            if model is not None:\n",
                "                comfy.model_management.load_models_gpu([model])\n",
                "                model_sd = model.model_state_dict()\n",
                "                for x in controlnet_data:\n",
                "                    c_m = \"control_model.\"\n",
                "                    if x.startswith(c_m):\n",
                "                        sd_key = \"diffusion_model.{}\".format(x[len(c_m):])\n",
                "                        if sd_key in model_sd:\n",
                "                            cd = controlnet_data[x]\n",
                "                            cd += model_sd[sd_key].type(cd.dtype).to(cd.device)\n",
                "            else:\n",
                "                print(\"WARNING: Loaded a diff controlnet without a model. It will very likely not work.\")\n",
                "\n",
                "        class WeightsLoader(torch.nn.Module):\n",
                "            pass\n",
                "        w = WeightsLoader()\n",
                "        w.control_model = control_model\n",
                "        missing, unexpected = w.load_state_dict(controlnet_data, strict=False)\n",
                "    else:\n",
                "        missing, unexpected = control_model.load_state_dict(controlnet_data, strict=False)\n",
                "    print(missing, unexpected)\n",
                "\n",
                "    global_average_pooling = False\n",
                "    filename = os.path.splitext(ckpt_path)[0]\n",
                "    if filename.endswith(\"_shuffle\") or filename.endswith(\"_shuffle_fp16\"): #TODO: smarter way of enabling global_average_pooling\n",
                "        global_average_pooling = True\n",
                "\n",
                "    control = ControlNet(control_model, global_average_pooling=global_average_pooling, load_device=load_device, manual_cast_dtype=manual_cast_dtype)\n",
                "    return control\n",
                "\n",
                "class T2IAdapter(ControlBase):\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    def __init__(self, t2i_model, channels_in, compression_ratio, device=None):\n"
                ],
                "after": [
                    "    def __init__(self, t2i_model, channels_in, compression_ratio, upscale_algorithm, device=None):\n"
                ],
                "parent_version_range": {
                    "start": 437,
                    "end": 438
                },
                "child_version_range": {
                    "start": 439,
                    "end": 440
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "T2IAdapter",
                        "signature": "class T2IAdapter(ControlBase):",
                        "at_line": 436
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(self, t2i_model, channels_in, compression_ratio, device=None):",
                        "at_line": 437
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: comfy/controlnet.py\nCode:\n434 436        return control\n435 437    \n436 438    class T2IAdapter(ControlBase):\n437      -     def __init__(self, t2i_model, channels_in, compression_ratio, device=None):\n    439  +     def __init__(self, t2i_model, channels_in, compression_ratio, upscale_algorithm, device=None):\n438 440            super().__init__(device)\n439 441            self.t2i_model = t2i_model\n440 442            self.channels_in = channels_in\n         ...\n",
                "file_path": "comfy/controlnet.py",
                "identifiers_before": [
                    "__init__",
                    "channels_in",
                    "compression_ratio",
                    "device",
                    "self",
                    "t2i_model"
                ],
                "identifiers_after": [
                    "__init__",
                    "channels_in",
                    "compression_ratio",
                    "device",
                    "self",
                    "t2i_model",
                    "upscale_algorithm"
                ],
                "prefix": [
                    "    return control\n",
                    "\n",
                    "class T2IAdapter(ControlBase):\n"
                ],
                "suffix": [
                    "        super().__init__(device)\n",
                    "        self.t2i_model = t2i_model\n",
                    "        self.channels_in = channels_in\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 439,
                                    "column": 17
                                },
                                "end": {
                                    "line": 439,
                                    "column": 21
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "upscale_algorithm",
                            "position": {
                                "start": {
                                    "line": 439,
                                    "column": 66
                                },
                                "end": {
                                    "line": 439,
                                    "column": 83
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "        super().__init__(device)\n",
                "        self.t2i_model = t2i_model\n",
                "        self.channels_in = channels_in\n",
                "        self.control_input = None\n",
                "        self.compression_ratio = compression_ratio\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        self.upscale_algorithm = upscale_algorithm\n"
                ],
                "parent_version_range": {
                    "start": 443,
                    "end": 443
                },
                "child_version_range": {
                    "start": 445,
                    "end": 446
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "T2IAdapter",
                        "signature": "class T2IAdapter(ControlBase):",
                        "at_line": 436
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(self, t2i_model, channels_in, compression_ratio, device=None):",
                        "at_line": 437
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: comfy/controlnet.py\nCode:\n           class T2IAdapter(ControlBase):\n               ...\n               def __init__(self, t2i_model, channels_in, compression_ratio, device=None):\n                   ...\n440 442            self.channels_in = channels_in\n441 443            self.control_input = None\n442 444            self.compression_ratio = compression_ratio\n    445  +         self.upscale_algorithm = upscale_algorithm\n443 446    \n444 447        def scale_image_to(self, width, height):\n445 448            unshuffle_amount = self.t2i_model.unshuffle_amount\n         ...\n",
                "file_path": "comfy/controlnet.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "self",
                    "upscale_algorithm"
                ],
                "prefix": [
                    "        self.channels_in = channels_in\n",
                    "        self.control_input = None\n",
                    "        self.compression_ratio = compression_ratio\n"
                ],
                "suffix": [
                    "\n",
                    "    def scale_image_to(self, width, height):\n",
                    "        unshuffle_amount = self.t2i_model.unshuffle_amount\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 445,
                                    "column": 8
                                },
                                "end": {
                                    "line": 445,
                                    "column": 12
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "upscale_algorithm",
                            "position": {
                                "start": {
                                    "line": 445,
                                    "column": 33
                                },
                                "end": {
                                    "line": 445,
                                    "column": 50
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "upscale_algorithm",
                            "position": {
                                "start": {
                                    "line": 445,
                                    "column": 13
                                },
                                "end": {
                                    "line": 445,
                                    "column": 30
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "upscale_algorithm",
                            "position": {
                                "start": {
                                    "line": 445,
                                    "column": 13
                                },
                                "end": {
                                    "line": 445,
                                    "column": 30
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    1
                ]
            },
            [
                "\n",
                "    def scale_image_to(self, width, height):\n",
                "        unshuffle_amount = self.t2i_model.unshuffle_amount\n",
                "        width = math.ceil(width / unshuffle_amount) * unshuffle_amount\n",
                "        height = math.ceil(height / unshuffle_amount) * unshuffle_amount\n",
                "        return width, height\n",
                "\n",
                "    def get_control(self, x_noisy, t, cond, batched_number):\n",
                "        control_prev = None\n",
                "        if self.previous_controlnet is not None:\n",
                "            control_prev = self.previous_controlnet.get_control(x_noisy, t, cond, batched_number)\n",
                "\n",
                "        if self.timestep_range is not None:\n",
                "            if t[0] > self.timestep_range[0] or t[0] < self.timestep_range[1]:\n",
                "                if control_prev is not None:\n",
                "                    return control_prev\n",
                "                else:\n",
                "                    return None\n",
                "\n",
                "        if self.cond_hint is None or x_noisy.shape[2] * self.compression_ratio != self.cond_hint.shape[2] or x_noisy.shape[3] * self.compression_ratio != self.cond_hint.shape[3]:\n",
                "            if self.cond_hint is not None:\n",
                "                del self.cond_hint\n",
                "            self.control_input = None\n",
                "            self.cond_hint = None\n",
                "            width, height = self.scale_image_to(x_noisy.shape[3] * self.compression_ratio, x_noisy.shape[2] * self.compression_ratio)\n"
            ],
            {
                "type": "replace",
                "before": [
                    "            self.cond_hint = comfy.utils.common_upscale(self.cond_hint_original, width, height, 'nearest-exact', \"center\").float().to(self.device)\n"
                ],
                "after": [
                    "            self.cond_hint = comfy.utils.common_upscale(self.cond_hint_original, width, height, self.upscale_algorithm, \"center\").float().to(self.device)\n"
                ],
                "parent_version_range": {
                    "start": 468,
                    "end": 469
                },
                "child_version_range": {
                    "start": 471,
                    "end": 472
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if self.cond_hint is None or x_noisy.shape[2] * self.compression_ratio != self.cond_hint.shape[2] or x_noisy.shape[3] * self.compression_ratio != self.cond_hint.shape[3]:",
                        "start_line": 462,
                        "end_line": 470
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "T2IAdapter",
                        "signature": "class T2IAdapter(ControlBase):",
                        "at_line": 436
                    },
                    {
                        "type": "function",
                        "name": "get_control",
                        "signature": "def get_control(self, x_noisy, t, cond, batched_number):",
                        "at_line": 450
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: comfy/controlnet.py\nCode:\n           class T2IAdapter(ControlBase):\n               ...\n               def get_control(self, x_noisy, t, cond, batched_number):\n                   ...\n465 468                self.control_input = None\n466 469                self.cond_hint = None\n467 470                width, height = self.scale_image_to(x_noisy.shape[3] * self.compression_ratio, x_noisy.shape[2] * self.compression_ratio)\n468      -             self.cond_hint = comfy.utils.common_upscale(self.cond_hint_original, width, height, 'nearest-exact', \"center\").float().to(self.device)\n    471  +             self.cond_hint = comfy.utils.common_upscale(self.cond_hint_original, width, height, self.upscale_algorithm, \"center\").float().to(self.device)\n469 472                if self.channels_in == 1 and self.cond_hint.shape[1] > 1:\n470 473                    self.cond_hint = torch.mean(self.cond_hint, 1, keepdim=True)\n471 474            if x_noisy.shape[0] != self.cond_hint.shape[0]:\n         ...\n",
                "file_path": "comfy/controlnet.py",
                "identifiers_before": [
                    "comfy",
                    "common_upscale",
                    "cond_hint",
                    "cond_hint_original",
                    "device",
                    "float",
                    "height",
                    "self",
                    "to",
                    "utils",
                    "width"
                ],
                "identifiers_after": [
                    "comfy",
                    "common_upscale",
                    "cond_hint",
                    "cond_hint_original",
                    "device",
                    "float",
                    "height",
                    "self",
                    "to",
                    "upscale_algorithm",
                    "utils",
                    "width"
                ],
                "prefix": [
                    "            self.control_input = None\n",
                    "            self.cond_hint = None\n",
                    "            width, height = self.scale_image_to(x_noisy.shape[3] * self.compression_ratio, x_noisy.shape[2] * self.compression_ratio)\n"
                ],
                "suffix": [
                    "            if self.channels_in == 1 and self.cond_hint.shape[1] > 1:\n",
                    "                self.cond_hint = torch.mean(self.cond_hint, 1, keepdim=True)\n",
                    "        if x_noisy.shape[0] != self.cond_hint.shape[0]:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "upscale_algorithm",
                            "position": {
                                "start": {
                                    "line": 471,
                                    "column": 101
                                },
                                "end": {
                                    "line": 471,
                                    "column": 118
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    2
                ]
            },
            [
                "            if self.channels_in == 1 and self.cond_hint.shape[1] > 1:\n",
                "                self.cond_hint = torch.mean(self.cond_hint, 1, keepdim=True)\n",
                "        if x_noisy.shape[0] != self.cond_hint.shape[0]:\n",
                "            self.cond_hint = broadcast_image_to(self.cond_hint, x_noisy.shape[0], batched_number)\n",
                "        if self.control_input is None:\n",
                "            self.t2i_model.to(x_noisy.dtype)\n",
                "            self.t2i_model.to(self.device)\n",
                "            self.control_input = self.t2i_model(self.cond_hint.to(x_noisy.dtype))\n",
                "            self.t2i_model.cpu()\n",
                "\n",
                "        control_input = list(map(lambda a: None if a is None else a.clone(), self.control_input))\n",
                "        mid = None\n",
                "        if self.t2i_model.xl == True:\n",
                "            mid = control_input[-1:]\n",
                "            control_input = control_input[:-1]\n",
                "        return self.control_merge(control_input, mid, control_prev, x_noisy.dtype)\n",
                "\n",
                "    def copy(self):\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        c = T2IAdapter(self.t2i_model, self.channels_in, self.compression_ratio)\n"
                ],
                "after": [
                    "        c = T2IAdapter(self.t2i_model, self.channels_in, self.compression_ratio, self.upscale_algorithm)\n"
                ],
                "parent_version_range": {
                    "start": 487,
                    "end": 488
                },
                "child_version_range": {
                    "start": 490,
                    "end": 491
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "T2IAdapter",
                        "signature": "class T2IAdapter(ControlBase):",
                        "at_line": 436
                    },
                    {
                        "type": "function",
                        "name": "copy",
                        "signature": "def copy(self):",
                        "at_line": 486
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: comfy/controlnet.py\nCode:\n           class T2IAdapter(ControlBase):\n               ...\n484 487            return self.control_merge(control_input, mid, control_prev, x_noisy.dtype)\n485 488    \n486 489        def copy(self):\n487      -         c = T2IAdapter(self.t2i_model, self.channels_in, self.compression_ratio)\n    490  +         c = T2IAdapter(self.t2i_model, self.channels_in, self.compression_ratio, self.upscale_algorithm)\n488 491            self.copy_to(c)\n489 492            return c\n490 493    \n         ...\n",
                "file_path": "comfy/controlnet.py",
                "identifiers_before": [
                    "T2IAdapter",
                    "c",
                    "channels_in",
                    "compression_ratio",
                    "self",
                    "t2i_model"
                ],
                "identifiers_after": [
                    "T2IAdapter",
                    "c",
                    "channels_in",
                    "compression_ratio",
                    "self",
                    "t2i_model",
                    "upscale_algorithm"
                ],
                "prefix": [
                    "        return self.control_merge(control_input, mid, control_prev, x_noisy.dtype)\n",
                    "\n",
                    "    def copy(self):\n"
                ],
                "suffix": [
                    "        self.copy_to(c)\n",
                    "        return c\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "upscale_algorithm",
                            "position": {
                                "start": {
                                    "line": 490,
                                    "column": 86
                                },
                                "end": {
                                    "line": 490,
                                    "column": 103
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/ComfyUI/comfy/controlnet.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        self.copy_to(c)\n",
                "        return c\n",
                "\n",
                "def load_t2i_adapter(t2i_data):\n",
                "    compression_ratio = 8\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    upscale_algorithm = 'nearest-exact'\n"
                ],
                "parent_version_range": {
                    "start": 493,
                    "end": 493
                },
                "child_version_range": {
                    "start": 496,
                    "end": 497
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "load_t2i_adapter",
                        "signature": "def load_t2i_adapter(t2i_data):",
                        "at_line": 491
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: comfy/controlnet.py\nCode:\n490 493    \n491 494    def load_t2i_adapter(t2i_data):\n492 495        compression_ratio = 8\n    496  +     upscale_algorithm = 'nearest-exact'\n493 497    \n494 498        if 'adapter' in t2i_data:\n495 499            t2i_data = t2i_data['adapter']\n         ...\n",
                "file_path": "comfy/controlnet.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "upscale_algorithm"
                ],
                "prefix": [
                    "\n",
                    "def load_t2i_adapter(t2i_data):\n",
                    "    compression_ratio = 8\n"
                ],
                "suffix": [
                    "\n",
                    "    if 'adapter' in t2i_data:\n",
                    "        t2i_data = t2i_data['adapter']\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    0
                ]
            },
            [
                "\n",
                "    if 'adapter' in t2i_data:\n",
                "        t2i_data = t2i_data['adapter']\n",
                "    if 'adapter.body.0.resnets.0.block1.weight' in t2i_data: #diffusers format\n",
                "        prefix_replace = {}\n",
                "        for i in range(4):\n",
                "            for j in range(2):\n",
                "                prefix_replace[\"adapter.body.{}.resnets.{}.\".format(i, j)] = \"body.{}.\".format(i * 2 + j)\n",
                "            prefix_replace[\"adapter.body.{}.\".format(i, j)] = \"body.{}.\".format(i * 2)\n",
                "        prefix_replace[\"adapter.\"] = \"\"\n",
                "        t2i_data = comfy.utils.state_dict_prefix_replace(t2i_data, prefix_replace)\n",
                "    keys = t2i_data.keys()\n",
                "\n",
                "    if \"body.0.in_conv.weight\" in keys:\n",
                "        cin = t2i_data['body.0.in_conv.weight'].shape[1]\n",
                "        model_ad = comfy.t2i_adapter.adapter.Adapter_light(cin=cin, channels=[320, 640, 1280, 1280], nums_rb=4)\n",
                "    elif 'conv_in.weight' in keys:\n",
                "        cin = t2i_data['conv_in.weight'].shape[1]\n",
                "        channel = t2i_data['conv_in.weight'].shape[0]\n",
                "        ksize = t2i_data['body.0.block2.weight'].shape[2]\n",
                "        use_conv = False\n",
                "        down_opts = list(filter(lambda a: a.endswith(\"down_opt.op.weight\"), keys))\n",
                "        if len(down_opts) > 0:\n",
                "            use_conv = True\n",
                "        xl = False\n",
                "        if cin == 256 or cin == 768:\n",
                "            xl = True\n",
                "        model_ad = comfy.t2i_adapter.adapter.Adapter(cin=cin, channels=[channel, channel*2, channel*4, channel*4][:4], nums_rb=2, ksize=ksize, sk=True, use_conv=use_conv, xl=xl)\n",
                "    elif \"backbone.0.0.weight\" in keys:\n",
                "        model_ad = comfy.ldm.cascade.controlnet.ControlNet(c_in=t2i_data['backbone.0.0.weight'].shape[1], proj_blocks=[0, 4, 8, 12, 51, 55, 59, 63])\n",
                "        compression_ratio = 32\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        upscale_algorithm = 'bilinear'\n"
                ],
                "parent_version_range": {
                    "start": 524,
                    "end": 524
                },
                "child_version_range": {
                    "start": 528,
                    "end": 529
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if \"body.0.in_conv.weight\" in keys:",
                        "start_line": 506,
                        "end_line": 525
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "load_t2i_adapter",
                        "signature": "def load_t2i_adapter(t2i_data):",
                        "at_line": 491
                    }
                ],
                "idx": 8,
                "hunk_diff": "File: comfy/controlnet.py\nCode:\n           def load_t2i_adapter(t2i_data):\n               ...\n521 525        elif \"backbone.0.0.weight\" in keys:\n522 526            model_ad = comfy.ldm.cascade.controlnet.ControlNet(c_in=t2i_data['backbone.0.0.weight'].shape[1], proj_blocks=[0, 4, 8, 12, 51, 55, 59, 63])\n523 527            compression_ratio = 32\n    528  +         upscale_algorithm = 'bilinear'\n524 529        else:\n525 530            return None\n526 531    \n         ...\n",
                "file_path": "comfy/controlnet.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "upscale_algorithm"
                ],
                "prefix": [
                    "    elif \"backbone.0.0.weight\" in keys:\n",
                    "        model_ad = comfy.ldm.cascade.controlnet.ControlNet(c_in=t2i_data['backbone.0.0.weight'].shape[1], proj_blocks=[0, 4, 8, 12, 51, 55, 59, 63])\n",
                    "        compression_ratio = 32\n"
                ],
                "suffix": [
                    "    else:\n",
                    "        return None\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    else:\n",
                "        return None\n",
                "\n",
                "    missing, unexpected = model_ad.load_state_dict(t2i_data)\n",
                "    if len(missing) > 0:\n",
                "        print(\"t2i missing\", missing)\n",
                "\n",
                "    if len(unexpected) > 0:\n",
                "        print(\"t2i unexpected\", unexpected)\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    return T2IAdapter(model_ad, model_ad.input_channels, compression_ratio)\n"
                ],
                "after": [
                    "    return T2IAdapter(model_ad, model_ad.input_channels, compression_ratio, upscale_algorithm)"
                ],
                "parent_version_range": {
                    "start": 534,
                    "end": 535
                },
                "child_version_range": {
                    "start": 539,
                    "end": 540
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "load_t2i_adapter",
                        "signature": "def load_t2i_adapter(t2i_data):",
                        "at_line": 491
                    }
                ],
                "idx": 9,
                "hunk_diff": "File: comfy/controlnet.py\nCode:\n           def load_t2i_adapter(t2i_data):\n               ...\n531 536        if len(unexpected) > 0:\n532 537            print(\"t2i unexpected\", unexpected)\n533 538    \n534      -     return T2IAdapter(model_ad, model_ad.input_channels, compression_ratio)\n    539  +     return T2IAdapter(model_ad, model_ad.input_channels, compression_ratio, upscale_algorithm)\n         ...\n",
                "file_path": "comfy/controlnet.py",
                "identifiers_before": [
                    "T2IAdapter",
                    "compression_ratio",
                    "input_channels",
                    "model_ad"
                ],
                "identifiers_after": [
                    "T2IAdapter",
                    "compression_ratio",
                    "input_channels",
                    "model_ad",
                    "upscale_algorithm"
                ],
                "prefix": [
                    "    if len(unexpected) > 0:\n",
                    "        print(\"t2i unexpected\", unexpected)\n",
                    "\n"
                ],
                "suffix": [],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            }
        ],
        "comfy/ldm/cascade/controlnet.py": [
            [
                "\"\"\"\n",
                "    This file is part of ComfyUI.\n",
                "    Copyright (C) 2024 Stability AI\n",
                "\n",
                "    This program is free software: you can redistribute it and/or modify\n",
                "    it under the terms of the GNU General Public License as published by\n",
                "    the Free Software Foundation, either version 3 of the License, or\n",
                "    (at your option) any later version.\n",
                "\n",
                "    This program is distributed in the hope that it will be useful,\n",
                "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n",
                "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n",
                "    GNU General Public License for more details.\n",
                "\n",
                "    You should have received a copy of the GNU General Public License\n",
                "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n",
                "\"\"\"\n",
                "\n",
                "import torch\n",
                "import torchvision\n",
                "from torch import nn\n",
                "from .common import LayerNorm2d_op\n",
                "\n",
                "\n",
                "class CNetResBlock(nn.Module):\n",
                "    def __init__(self, c, dtype=None, device=None, operations=None):\n",
                "        super().__init__()\n",
                "        self.blocks = nn.Sequential(\n",
                "            LayerNorm2d_op(operations)(c, dtype=dtype, device=device),\n",
                "            nn.GELU(),\n",
                "            operations.Conv2d(c, c, kernel_size=3, padding=1),\n",
                "            LayerNorm2d_op(operations)(c, dtype=dtype, device=device),\n",
                "            nn.GELU(),\n",
                "            operations.Conv2d(c, c, kernel_size=3, padding=1),\n",
                "        )\n",
                "\n",
                "    def forward(self, x):\n",
                "        return x + self.blocks(x)\n",
                "\n",
                "\n",
                "class ControlNet(nn.Module):\n",
                "    def __init__(self, c_in=3, c_proj=2048, proj_blocks=None, bottleneck_mode=None, dtype=None, device=None, operations=nn):\n",
                "        super().__init__()\n",
                "        if bottleneck_mode is None:\n",
                "            bottleneck_mode = 'effnet'\n",
                "        self.proj_blocks = proj_blocks\n",
                "        if bottleneck_mode == 'effnet':\n",
                "            embd_channels = 1280\n",
                "            self.backbone = torchvision.models.efficientnet_v2_s().features.eval()\n",
                "            if c_in != 3:\n",
                "                in_weights = self.backbone[0][0].weight.data\n",
                "                self.backbone[0][0] = operations.Conv2d(c_in, 24, kernel_size=3, stride=2, bias=False, dtype=dtype, device=device)\n",
                "                if c_in > 3:\n",
                "                    # nn.init.constant_(self.backbone[0][0].weight, 0)\n",
                "                    self.backbone[0][0].weight.data[:, :3] = in_weights[:, :3].clone()\n",
                "                else:\n",
                "                    self.backbone[0][0].weight.data = in_weights[:, :c_in].clone()\n",
                "        elif bottleneck_mode == 'simple':\n",
                "            embd_channels = c_in\n",
                "            self.backbone = nn.Sequential(\n",
                "                operations.Conv2d(embd_channels, embd_channels * 4, kernel_size=3, padding=1, dtype=dtype, device=device),\n",
                "                nn.LeakyReLU(0.2, inplace=True),\n",
                "                operations.Conv2d(embd_channels * 4, embd_channels, kernel_size=3, padding=1, dtype=dtype, device=device),\n",
                "            )\n",
                "        elif bottleneck_mode == 'large':\n",
                "            self.backbone = nn.Sequential(\n",
                "                operations.Conv2d(c_in, 4096 * 4, kernel_size=1, dtype=dtype, device=device),\n",
                "                nn.LeakyReLU(0.2, inplace=True),\n",
                "                operations.Conv2d(4096 * 4, 1024, kernel_size=1, dtype=dtype, device=device),\n",
                "                *[CNetResBlock(1024) for _ in range(8)],\n",
                "                operations.Conv2d(1024, 1280, kernel_size=1, dtype=dtype, device=device),\n",
                "            )\n",
                "            embd_channels = 1280\n",
                "        else:\n",
                "            raise ValueError(f'Unknown bottleneck mode: {bottleneck_mode}')\n",
                "        self.projections = nn.ModuleList()\n",
                "        for _ in range(len(proj_blocks)):\n",
                "            self.projections.append(nn.Sequential(\n",
                "                operations.Conv2d(embd_channels, embd_channels, kernel_size=1, bias=False, dtype=dtype, device=device),\n",
                "                nn.LeakyReLU(0.2, inplace=True),\n",
                "                operations.Conv2d(embd_channels, c_proj, kernel_size=1, bias=False, dtype=dtype, device=device),\n",
                "            ))\n",
                "            # nn.init.constant_(self.projections[-1][-1].weight, 0)  # zero output projection\n",
                "        self.xl = False\n",
                "        self.input_channels = c_in\n",
                "        self.unshuffle_amount = 8\n",
                "\n",
                "    def forward(self, x):\n"
            ],
            {
                "type": "delete",
                "before": [
                    "        print(x)\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 88,
                    "end": 89
                },
                "child_version_range": {
                    "start": 88,
                    "end": 88
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "ControlNet",
                        "signature": "class ControlNet(nn.Module):",
                        "at_line": 40
                    },
                    {
                        "type": "function",
                        "name": "forward",
                        "signature": "def forward(self, x):",
                        "at_line": 87
                    },
                    {
                        "type": "call",
                        "name": "print",
                        "signature": "print(x)",
                        "at_line": 88,
                        "argument": "x"
                    }
                ],
                "idx": 10,
                "hunk_diff": "File: comfy/ldm/cascade/controlnet.py\nCode:\n         class ControlNet(nn.Module):\n             ...\n85 85            self.unshuffle_amount = 8\n86 86    \n87 87        def forward(self, x):\n88     -         print(x)\n89 88            x = self.backbone(x)\n90 89            proj_outputs = [None for _ in range(max(self.proj_blocks) + 1)]\n91 90            for i, idx in enumerate(self.proj_blocks):\n       ...\n",
                "file_path": "comfy/ldm/cascade/controlnet.py",
                "identifiers_before": [
                    "print",
                    "x"
                ],
                "identifiers_after": [],
                "prefix": [
                    "        self.unshuffle_amount = 8\n",
                    "\n",
                    "    def forward(self, x):\n"
                ],
                "suffix": [
                    "        x = self.backbone(x)\n",
                    "        proj_outputs = [None for _ in range(max(self.proj_blocks) + 1)]\n",
                    "        for i, idx in enumerate(self.proj_blocks):\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        x = self.backbone(x)\n",
                "        proj_outputs = [None for _ in range(max(self.proj_blocks) + 1)]\n",
                "        for i, idx in enumerate(self.proj_blocks):\n",
                "            proj_outputs[idx] = self.projections[i](x)\n",
                "        return proj_outputs"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                0,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                0,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "clone"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                3,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                3,
                9
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                4,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                7,
                9
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                8,
                9
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        }
    ]
}