{
    "language": "python",
    "commit_url": "https://github.com/localstack/localstack/commit/d47f509bf2495f17f5716e1d7b8e3d80164adc81",
    "commit_message": "Allow privileged mode to be passed as additional flag (#7835)",
    "commit_snapshots": {
        "localstack/utils/container_utils/container_client.py": [
            [
                "import dataclasses\n",
                "import io\n",
                "import ipaddress\n",
                "import logging\n",
                "import os\n",
                "import re\n",
                "import shlex\n",
                "import sys\n",
                "import tarfile\n",
                "import tempfile\n",
                "from abc import ABCMeta, abstractmethod\n",
                "from enum import Enum, unique\n",
                "from pathlib import Path\n",
                "from typing import Dict, List, NamedTuple, Optional, Tuple, Union\n",
                "\n",
                "if sys.version_info >= (3, 8):\n",
                "    from typing import Literal, Protocol, get_args\n",
                "else:\n",
                "    from typing_extensions import Protocol, get_args, Literal\n",
                "\n",
                "from localstack import config\n",
                "from localstack.utils.collections import HashableList\n",
                "from localstack.utils.files import TMP_FILES, rm_rf, save_file\n",
                "from localstack.utils.strings import short_uid\n",
                "\n",
                "LOG = logging.getLogger(__name__)\n",
                "\n",
                "\n",
                "@unique\n",
                "class DockerContainerStatus(Enum):\n",
                "    DOWN = -1\n",
                "    NON_EXISTENT = 0\n",
                "    UP = 1\n",
                "    PAUSED = 2\n",
                "\n",
                "\n",
                "class ContainerException(Exception):\n",
                "    def __init__(self, message=None, stdout=None, stderr=None) -> None:\n",
                "        self.message = message or \"Error during the communication with the docker daemon\"\n",
                "        self.stdout = stdout\n",
                "        self.stderr = stderr\n",
                "\n",
                "\n",
                "class NoSuchObject(ContainerException):\n",
                "    def __init__(self, object_id: str, message=None, stdout=None, stderr=None) -> None:\n",
                "        message = message or f\"Docker object {object_id} not found\"\n",
                "        super().__init__(message, stdout, stderr)\n",
                "        self.object_id = object_id\n",
                "\n",
                "\n",
                "class NoSuchContainer(ContainerException):\n",
                "    def __init__(self, container_name_or_id: str, message=None, stdout=None, stderr=None) -> None:\n",
                "        message = message or f\"Docker container {container_name_or_id} not found\"\n",
                "        super().__init__(message, stdout, stderr)\n",
                "        self.container_name_or_id = container_name_or_id\n",
                "\n",
                "\n",
                "class NoSuchImage(ContainerException):\n",
                "    def __init__(self, image_name: str, message=None, stdout=None, stderr=None) -> None:\n",
                "        message = message or f\"Docker image {image_name} not found\"\n",
                "        super().__init__(message, stdout, stderr)\n",
                "        self.image_name = image_name\n",
                "\n",
                "\n",
                "class NoSuchNetwork(ContainerException):\n",
                "    def __init__(self, network_name: str, message=None, stdout=None, stderr=None) -> None:\n",
                "        message = message or f\"Docker network {network_name} not found\"\n",
                "        super().__init__(message, stdout, stderr)\n",
                "        self.network_name = network_name\n",
                "\n",
                "\n",
                "class RegistryConnectionError(ContainerException):\n",
                "    def __init__(self, details: str, message=None, stdout=None, stderr=None) -> None:\n",
                "        message = message or f\"Connection error: {details}\"\n",
                "        super().__init__(message, stdout, stderr)\n",
                "        self.details = details\n",
                "\n",
                "\n",
                "class AccessDenied(ContainerException):\n",
                "    def __init__(self, object_name: str, message=None, stdout=None, stderr=None) -> None:\n",
                "        message = message or f\"Access denied to {object_name}\"\n",
                "        super().__init__(message, stdout, stderr)\n",
                "        self.object_name = object_name\n",
                "\n",
                "\n",
                "class CancellableStream(Protocol):\n",
                "    \"\"\"Describes a generator that can be closed. Borrowed from ``docker.types.daemon``.\"\"\"\n",
                "\n",
                "    def __iter__(self):\n",
                "        raise NotImplementedError\n",
                "\n",
                "    def __next__(self):\n",
                "        raise NotImplementedError\n",
                "\n",
                "    def close(self):\n",
                "        raise NotImplementedError\n",
                "\n",
                "\n",
                "class DockerPlatform(str):\n",
                "    \"\"\"Platform in the format ``os[/arch[/variant]]``\"\"\"\n",
                "\n",
                "    linux_amd64 = \"linux/amd64\"\n",
                "    linux_arm64 = \"linux/arm64\"\n",
                "\n",
                "\n",
                "# defines the type for port mappings (source->target port range)\n",
                "PortRange = Union[List, HashableList]\n",
                "\n",
                "\n",
                "def isinstance_union(obj, class_or_tuple):\n",
                "    # that's some dirty hack\n",
                "    if sys.version_info < (3, 10):\n",
                "        return isinstance(obj, get_args(PortRange))\n",
                "    else:\n",
                "        return isinstance(obj, class_or_tuple)\n",
                "\n",
                "\n",
                "class PortMappings:\n",
                "    \"\"\"Maps source to target port ranges for Docker port mappings.\"\"\"\n",
                "\n",
                "    # bind host to be used for defining port mappings\n",
                "    bind_host: str\n",
                "    # maps `from` port range to `to` port range for port mappings\n",
                "    mappings: Dict[PortRange, List]\n",
                "\n",
                "    def __init__(self, bind_host: str = None):\n",
                "        self.bind_host = bind_host if bind_host else \"\"\n",
                "        self.mappings = {}\n",
                "\n",
                "    def add(\n",
                "        self,\n",
                "        port: Union[int, PortRange],\n",
                "        mapped: Union[int, PortRange] = None,\n",
                "        protocol: str = \"tcp\",\n",
                "    ):\n",
                "        mapped = mapped or port\n",
                "        if isinstance_union(port, PortRange):\n",
                "            for i in range(port[1] - port[0] + 1):\n",
                "                if isinstance_union(mapped, PortRange):\n",
                "                    self.add(port[0] + i, mapped[0] + i)\n",
                "                else:\n",
                "                    self.add(port[0] + i, mapped)\n",
                "            return\n",
                "        if port is None or int(port) <= 0:\n",
                "            raise Exception(f\"Unable to add mapping for invalid port: {port}\")\n",
                "        if self.contains(port):\n",
                "            return\n",
                "        bisected_host_port = None\n",
                "        for from_range, to_range in dict(self.mappings).items():\n",
                "            if not self.in_expanded_range(port, from_range):\n",
                "                continue\n",
                "            if not self.in_expanded_range(mapped, to_range):\n",
                "                continue\n",
                "            from_range_len = from_range[1] - from_range[0]\n",
                "            to_range_len = to_range[1] - to_range[0]\n",
                "            is_uniform = from_range_len == to_range_len\n",
                "            if is_uniform:\n",
                "                self.expand_range(port, from_range, remap=True)\n",
                "                self.expand_range(mapped, to_range)\n",
                "            else:\n",
                "                if not self.in_range(mapped, to_range):\n",
                "                    continue\n",
                "                # extending a 1 to 1 mapping to be many to 1\n",
                "                elif from_range_len == 1:\n",
                "                    self.expand_range(port, from_range, remap=True)\n",
                "                # splitting a uniform mapping\n",
                "                else:\n",
                "                    bisected_port_index = mapped - to_range[0]\n",
                "                    bisected_host_port = from_range[0] + bisected_port_index\n",
                "                    self.bisect_range(mapped, to_range)\n",
                "                    self.bisect_range(bisected_host_port, from_range, remap=True)\n",
                "                    break\n",
                "            return\n",
                "        protocol = str(protocol or \"tcp\").lower()\n",
                "        if bisected_host_port is None:\n",
                "            port_range = [port, port, protocol]\n",
                "        elif bisected_host_port < port:\n",
                "            port_range = [bisected_host_port, port, protocol]\n",
                "        else:\n",
                "            port_range = [port, bisected_host_port, protocol]\n",
                "        self.mappings[HashableList(port_range)] = [mapped, mapped]\n",
                "\n",
                "    def to_str(self) -> str:\n",
                "        bind_address = f\"{self.bind_host}:\" if self.bind_host else \"\"\n",
                "\n",
                "        def entry(k, v):\n",
                "            protocol = \"/%s\" % k[2] if k[2] != \"tcp\" else \"\"\n",
                "            if k[0] == k[1] and v[0] == v[1]:\n",
                "                return \"-p %s%s:%s%s\" % (bind_address, k[0], v[0], protocol)\n",
                "            if k[0] != k[1] and v[0] == v[1]:\n",
                "                return \"-p %s%s-%s:%s%s\" % (bind_address, k[0], k[1], v[0], protocol)\n",
                "            return \"-p %s%s-%s:%s-%s%s\" % (bind_address, k[0], k[1], v[0], v[1], protocol)\n",
                "\n",
                "        return \" \".join([entry(k, v) for k, v in self.mappings.items()])\n",
                "\n",
                "    def to_list(self) -> List[str]:  # TODO test\n",
                "        bind_address = f\"{self.bind_host}:\" if self.bind_host else \"\"\n",
                "\n",
                "        def entry(k, v):\n",
                "            protocol = \"/%s\" % k[2] if k[2] != \"tcp\" else \"\"\n",
                "            if k[0] == k[1] and v[0] == v[1]:\n",
                "                return [\"-p\", f\"{bind_address}{k[0]}:{v[0]}{protocol}\"]\n",
                "            return [\"-p\", f\"{bind_address}{k[0]}-{k[1]}:{v[0]}-{v[1]}{protocol}\"]\n",
                "\n",
                "        return [item for k, v in self.mappings.items() for item in entry(k, v)]\n",
                "\n",
                "    def to_dict(self) -> Dict[str, Union[Tuple[str, Union[int, List[int]]], int]]:\n",
                "        bind_address = self.bind_host or \"\"\n",
                "\n",
                "        def entry(k, v):\n",
                "            protocol = \"/%s\" % k[2]\n",
                "            if k[0] != k[1] and v[0] == v[1]:\n",
                "                container_port = v[0]\n",
                "                host_ports = list(range(k[0], k[1] + 1))\n",
                "                return [\n",
                "                    (\n",
                "                        f\"{container_port}{protocol}\",\n",
                "                        (bind_address, host_ports) if bind_address else host_ports,\n",
                "                    )\n",
                "                ]\n",
                "            return [\n",
                "                (\n",
                "                    f\"{container_port}{protocol}\",\n",
                "                    (bind_address, host_port) if bind_address else host_port,\n",
                "                )\n",
                "                for container_port, host_port in zip(range(v[0], v[1] + 1), range(k[0], k[1] + 1))\n",
                "            ]\n",
                "\n",
                "        items = [item for k, v in self.mappings.items() for item in entry(k, v)]\n",
                "        return dict(items)\n",
                "\n",
                "    def contains(self, port: int) -> bool:\n",
                "        for from_range, to_range in self.mappings.items():\n",
                "            if self.in_range(port, from_range):\n",
                "                return True\n",
                "\n",
                "    def in_range(self, port: int, range: PortRange) -> bool:\n",
                "        return port >= range[0] and port <= range[1]\n",
                "\n",
                "    def in_expanded_range(self, port: int, range: PortRange):\n",
                "        return port >= range[0] - 1 and port <= range[1] + 1\n",
                "\n",
                "    def expand_range(self, port: int, range: PortRange, remap: bool = False):\n",
                "        \"\"\"\n",
                "        Expand the given port range by the given port. If remap==True, put the updated range into self.mappings\n",
                "        \"\"\"\n",
                "        if self.in_range(port, range):\n",
                "            return\n",
                "        new_range = list(range) if remap else range\n",
                "        if port == range[0] - 1:\n",
                "            new_range[0] = port\n",
                "        elif port == range[1] + 1:\n",
                "            new_range[1] = port\n",
                "        else:\n",
                "            raise Exception(f\"Unable to add port {port} to existing range {range}\")\n",
                "        if remap:\n",
                "            self._remap_range(range, new_range)\n",
                "\n",
                "    def bisect_range(self, port: int, range: PortRange, remap: bool = False):\n",
                "        \"\"\"\n",
                "        Bisect a port range, at the provided port. This is needed in some cases when adding a\n",
                "        non-uniform host to port mapping adjacent to an existing port range.\n",
                "        If remap==True, put the updated range into self.mappings\n",
                "        \"\"\"\n",
                "        if not self.in_range(port, range):\n",
                "            return\n",
                "        new_range = list(range) if remap else range\n",
                "        if port == range[0]:\n",
                "            new_range[0] = port + 1\n",
                "        else:\n",
                "            new_range[1] = port - 1\n",
                "        if remap:\n",
                "            self._remap_range(range, new_range)\n",
                "\n",
                "    def _remap_range(self, old_key: PortRange, new_key: PortRange):\n",
                "        self.mappings[HashableList(new_key)] = self.mappings.pop(old_key)\n",
                "\n",
                "    def __repr__(self):\n",
                "        return f\"<PortMappings: {self.to_dict()}>\"\n",
                "\n",
                "\n",
                "SimpleVolumeBind = Tuple[str, str]\n",
                "\"\"\"Type alias for a simple version of VolumeBind\"\"\"\n",
                "\n",
                "\n",
                "@dataclasses.dataclass\n",
                "class VolumeBind:\n",
                "    \"\"\"Represents a --volume argument run/create command. When using VolumeBind to bind-mount a file or directory\n",
                "    that does not yet exist on the Docker host, -v creates the endpoint for you. It is always created as a directory.\n",
                "    \"\"\"\n",
                "\n",
                "    host_dir: str\n",
                "    container_dir: str\n",
                "    read_only: bool = False\n",
                "\n",
                "    def to_str(self) -> str:\n",
                "        args = []\n",
                "\n",
                "        if self.host_dir:\n",
                "            args.append(self.host_dir)\n",
                "\n",
                "        if not self.container_dir:\n",
                "            raise ValueError(\"no container dir specified\")\n",
                "\n",
                "        args.append(self.container_dir)\n",
                "\n",
                "        if self.read_only:\n",
                "            args.append(\"ro\")\n",
                "\n",
                "        return \":\".join(args)\n",
                "\n",
                "\n",
                "class VolumeMappings:\n",
                "    mappings: List[Union[SimpleVolumeBind, VolumeBind]]\n",
                "\n",
                "    def __init__(self, mappings: List[Union[SimpleVolumeBind, VolumeBind]] = None):\n",
                "        self.mappings = mappings if mappings is not None else []\n",
                "\n",
                "    def add(self, mapping: Union[SimpleVolumeBind, VolumeBind]):\n",
                "        self.append(mapping)\n",
                "\n",
                "    def append(\n",
                "        self,\n",
                "        mapping: Union[\n",
                "            SimpleVolumeBind,\n",
                "            VolumeBind,\n",
                "        ],\n",
                "    ):\n",
                "        self.mappings.append(mapping)\n",
                "\n",
                "    def __iter__(self):\n",
                "        return self.mappings.__iter__()\n",
                "\n",
                "\n",
                "VolumeType = Literal[\"bind\", \"volume\"]\n",
                "\n",
                "\n",
                "class VolumeInfo(NamedTuple):\n",
                "    \"\"\"Container volume information.\"\"\"\n",
                "\n",
                "    type: VolumeType\n",
                "    source: str\n",
                "    destination: str\n",
                "    mode: str\n",
                "    rw: bool\n",
                "    propagation: str\n",
                "    name: Optional[str] = None\n",
                "    driver: Optional[str] = None\n",
                "\n",
                "\n",
                "@dataclasses.dataclass\n",
                "class ContainerConfiguration:\n",
                "    image_name: str\n",
                "    name: Optional[str] = None\n",
                "    volumes: Optional[VolumeMappings] = None\n",
                "    ports: Optional[PortMappings] = None\n",
                "    entrypoint: Optional[str] = None\n",
                "    additional_flags: Optional[List[str]] = None\n",
                "    command: Optional[List[str]] = None\n",
                "    env_vars: Dict[str, str] = dataclasses.field(default_factory=dict)\n",
                "\n",
                "    privileged: Optional[bool] = None\n",
                "    remove: Optional[bool] = None\n",
                "    interactive: Optional[bool] = None\n",
                "    tty: Optional[bool] = None\n",
                "    detach: Optional[bool] = None\n",
                "\n",
                "    stdin: Optional[str] = None\n",
                "    user: Optional[str] = None\n",
                "    cap_add: Optional[List[str]] = None\n",
                "    cap_drop: Optional[List[str]] = None\n",
                "    security_opt: Optional[List[str]] = None\n",
                "    network: Optional[str] = None\n",
                "    dns: Optional[str] = None\n",
                "    workdir: Optional[str] = None\n",
                "    platform: Optional[str] = None\n",
                "\n",
                "\n",
                "@dataclasses.dataclass\n",
                "class DockerRunFlags:\n",
                "    \"\"\"Class to capture Docker run flags for a container\"\"\"\n",
                "\n",
                "    env_vars: Optional[Dict[str, str]]\n",
                "    ports: Optional[PortMappings]\n",
                "    mounts: Optional[List[SimpleVolumeBind]]\n",
                "    extra_hosts: Optional[Dict[str, str]]\n",
                "    network: Optional[str]\n",
                "    labels: Optional[Dict[str, str]]\n",
                "    user: Optional[str]\n",
                "    platform: Optional[DockerPlatform]\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    privileged: Optional[bool]\n"
                ],
                "parent_version_range": {
                    "start": 390,
                    "end": 390
                },
                "child_version_range": {
                    "start": 390,
                    "end": 391
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "DockerRunFlags",
                        "signature": "class DockerRunFlags:",
                        "at_line": 379
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: localstack/utils/container_utils/container_client.py\nCode:\n           class DockerRunFlags:\n               ...\n387 387        labels: Optional[Dict[str, str]]\n388 388        user: Optional[str]\n389 389        platform: Optional[DockerPlatform]\n    390  +     privileged: Optional[bool]\n390 391    \n391 392    \n392 393    class ContainerClient(metaclass=ABCMeta):\n         ...\n",
                "file_path": "localstack/utils/container_utils/container_client.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Optional",
                    "bool",
                    "privileged"
                ],
                "prefix": [
                    "    labels: Optional[Dict[str, str]]\n",
                    "    user: Optional[str]\n",
                    "    platform: Optional[DockerPlatform]\n"
                ],
                "suffix": [
                    "\n",
                    "\n",
                    "class ContainerClient(metaclass=ABCMeta):\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 390,
                                    "column": 4
                                },
                                "end": {
                                    "line": 390,
                                    "column": 14
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/container_utils/container_client.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 390,
                                    "column": 4
                                },
                                "end": {
                                    "line": 390,
                                    "column": 14
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/container_utils/container_client.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 12,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 390,
                                    "column": 4
                                },
                                "end": {
                                    "line": 390,
                                    "column": 14
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/container_utils/container_client.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 13,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 390,
                                    "column": 4
                                },
                                "end": {
                                    "line": 390,
                                    "column": 14
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/container_utils/container_client.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 13,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 390,
                                    "column": 4
                                },
                                "end": {
                                    "line": 390,
                                    "column": 14
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/container_utils/container_client.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    1
                ]
            },
            [
                "\n",
                "\n",
                "class ContainerClient(metaclass=ABCMeta):\n",
                "    STOP_TIMEOUT = 0\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_container_status(self, container_name: str) -> DockerContainerStatus:\n",
                "        \"\"\"Returns the status of the container with the given name\"\"\"\n",
                "        pass\n",
                "\n",
                "    def get_networks(self, container_name: str) -> List[str]:\n",
                "        LOG.debug(\"Getting networks for container: %s\", container_name)\n",
                "        container_attrs = self.inspect_container(container_name_or_id=container_name)\n",
                "        return list(container_attrs[\"NetworkSettings\"][\"Networks\"].keys())\n",
                "\n",
                "    def get_container_ipv4_for_network(\n",
                "        self, container_name_or_id: str, container_network: str\n",
                "    ) -> str:\n",
                "        \"\"\"\n",
                "        Returns the IPv4 address for the container on the interface connected to the given network\n",
                "        :param container_name_or_id: Container to inspect\n",
                "        :param container_network: Network the IP address will belong to\n",
                "        :return: IP address of the given container on the interface connected to the given network\n",
                "        \"\"\"\n",
                "        LOG.debug(\n",
                "            \"Getting ipv4 address for container %s in network %s.\",\n",
                "            container_name_or_id,\n",
                "            container_network,\n",
                "        )\n",
                "        # we always need the ID for this\n",
                "        container_id = self.get_container_id(container_name=container_name_or_id)\n",
                "        network_attrs = self.inspect_network(container_network)\n",
                "        containers = network_attrs[\"Containers\"]\n",
                "        if container_id not in containers:\n",
                "            raise ContainerException(\n",
                "                \"Container %s is not connected to target network %s\",\n",
                "                container_name_or_id,\n",
                "                container_network,\n",
                "            )\n",
                "        try:\n",
                "            ip = str(ipaddress.IPv4Interface(containers[container_id][\"IPv4Address\"]).ip)\n",
                "        except Exception as e:\n",
                "            raise ContainerException(\n",
                "                f\"Unable to detect IP address for container {container_name_or_id} in network {container_network}: {e}\"\n",
                "            )\n",
                "        return ip\n",
                "\n",
                "    @abstractmethod\n",
                "    def stop_container(self, container_name: str, timeout: int = None):\n",
                "        \"\"\"Stops container with given name\n",
                "        :param container_name: Container identifier (name or id) of the container to be stopped\n",
                "        :param timeout: Timeout after which SIGKILL is sent to the container.\n",
                "                        If not specified, defaults to `STOP_TIMEOUT`\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def restart_container(self, container_name: str, timeout: int = 10):\n",
                "        \"\"\"Restarts a container with the given name.\n",
                "        :param container_name: Container identifier\n",
                "        :param timeout: Seconds to wait for stop before killing the container\n",
                "        \"\"\"\n",
                "\n",
                "    @abstractmethod\n",
                "    def pause_container(self, container_name: str):\n",
                "        \"\"\"Pauses a container with the given name.\"\"\"\n",
                "\n",
                "    @abstractmethod\n",
                "    def unpause_container(self, container_name: str):\n",
                "        \"\"\"Unpauses a container with the given name.\"\"\"\n",
                "\n",
                "    @abstractmethod\n",
                "    def remove_container(self, container_name: str, force=True, check_existence=False) -> None:\n",
                "        \"\"\"Removes container with given name\"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def remove_image(self, image: str, force: bool = True) -> None:\n",
                "        \"\"\"Removes an image with given name\n",
                "\n",
                "        :param image: Image name and tag\n",
                "        :param force: Force removal\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def list_containers(self, filter: Union[List[str], str, None] = None, all=True) -> List[dict]:\n",
                "        \"\"\"List all containers matching the given filters\n",
                "\n",
                "        :return: A list of dicts with keys id, image, name, labels, status\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    def get_running_container_names(self) -> List[str]:\n",
                "        \"\"\"Returns a list of the names of all running containers\"\"\"\n",
                "        result = self.list_containers(all=False)\n",
                "        result = list(map(lambda container: container[\"name\"], result))\n",
                "        return result\n",
                "\n",
                "    def is_container_running(self, container_name: str) -> bool:\n",
                "        \"\"\"Checks whether a container with a given name is currently running\"\"\"\n",
                "        return container_name in self.get_running_container_names()\n",
                "\n",
                "    @abstractmethod\n",
                "    def copy_into_container(\n",
                "        self, container_name: str, local_path: str, container_path: str\n",
                "    ) -> None:\n",
                "        \"\"\"Copy contents of the given local path into the container\"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def copy_from_container(\n",
                "        self, container_name: str, local_path: str, container_path: str\n",
                "    ) -> None:\n",
                "        \"\"\"Copy contents of the given container to the host\"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def pull_image(self, docker_image: str, platform: Optional[DockerPlatform] = None) -> None:\n",
                "        \"\"\"Pulls an image with a given name from a Docker registry\"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def push_image(self, docker_image: str) -> None:\n",
                "        \"\"\"Pushes an image with a given name to a Docker registry\"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def build_image(\n",
                "        self,\n",
                "        dockerfile_path: str,\n",
                "        image_name: str,\n",
                "        context_path: str = None,\n",
                "        platform: Optional[DockerPlatform] = None,\n",
                "    ) -> None:\n",
                "        \"\"\"Builds an image from the given Dockerfile\n",
                "\n",
                "        :param dockerfile_path: Path to Dockerfile, or a directory that contains a Dockerfile\n",
                "        :param image_name: Name of the image to be built\n",
                "        :param context_path: Path for build context (defaults to dirname of Dockerfile)\n",
                "        :param platform: Target platform for build (defaults to platform of Docker host)\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def tag_image(self, source_ref: str, target_name: str) -> None:\n",
                "        \"\"\"Tags an image with a new name\n",
                "\n",
                "        :param source_ref: Name or ID of the image to be tagged\n",
                "        :param target_name: New name (tag) of the tagged image\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_docker_image_names(self, strip_latest=True, include_tags=True) -> List[str]:\n",
                "        \"\"\"\n",
                "        Get all names of docker images available to the container engine\n",
                "        :param strip_latest: return images both with and without :latest tag\n",
                "        :param include_tags: Include tags of the images in the names\n",
                "        :return: List of image names\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_container_logs(self, container_name_or_id: str, safe=False) -> str:\n",
                "        \"\"\"Get all logs of a given container\"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def stream_container_logs(self, container_name_or_id: str) -> CancellableStream:\n",
                "        \"\"\"Returns a blocking generator you can iterate over to retrieve log output as it happens.\"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def inspect_container(self, container_name_or_id: str) -> Dict[str, Union[Dict, str]]:\n",
                "        \"\"\"Get detailed attributes of a container.\n",
                "\n",
                "        :return: Dict containing docker attributes as returned by the daemon\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    def inspect_container_volumes(self, container_name_or_id) -> List[VolumeInfo]:\n",
                "        \"\"\"Return information about the volumes mounted into the given container.\n",
                "\n",
                "        :param container_name_or_id: the container name or id\n",
                "        :return: a list of volumes\n",
                "        \"\"\"\n",
                "        volumes = []\n",
                "        for doc in self.inspect_container(container_name_or_id)[\"Mounts\"]:\n",
                "            volumes.append(VolumeInfo(**{k.lower(): v for k, v in doc.items()}))\n",
                "\n",
                "        return volumes\n",
                "\n",
                "    @abstractmethod\n",
                "    def inspect_image(self, image_name: str, pull: bool = True) -> Dict[str, Union[Dict, str]]:\n",
                "        \"\"\"Get detailed attributes of an image.\n",
                "\n",
                "        :param image_name: Image name to inspect\n",
                "        :param pull: Whether to pull image if not existent\n",
                "        :return: Dict containing docker attributes as returned by the daemon\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def inspect_network(self, network_name: str) -> Dict[str, Union[Dict, str]]:\n",
                "        \"\"\"Get detailed attributes of an network.\n",
                "\n",
                "        :return: Dict containing docker attributes as returned by the daemon\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def connect_container_to_network(\n",
                "        self, network_name: str, container_name_or_id: str, aliases: Optional[List] = None\n",
                "    ) -> None:\n",
                "        \"\"\"\n",
                "        Connects a container to a given network\n",
                "        :param network_name: Network to connect the container to\n",
                "        :param container_name_or_id: Container to connect to the network\n",
                "        :param aliases: List of dns names the container should be available under in the network\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def disconnect_container_from_network(\n",
                "        self, network_name: str, container_name_or_id: str\n",
                "    ) -> None:\n",
                "        \"\"\"\n",
                "        Disconnects a container from a given network\n",
                "        :param network_name: Network to disconnect the container from\n",
                "        :param container_name_or_id: Container to disconnect from the network\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    def get_container_name(self, container_id: str) -> str:\n",
                "        \"\"\"Get the name of a container by a given identifier\"\"\"\n",
                "        return self.inspect_container(container_id)[\"Name\"].lstrip(\"/\")\n",
                "\n",
                "    def get_container_id(self, container_name: str) -> str:\n",
                "        \"\"\"Get the id of a container by a given name\"\"\"\n",
                "        return self.inspect_container(container_name)[\"Id\"]\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_container_ip(self, container_name_or_id: str) -> str:\n",
                "        \"\"\"Get the IP address of a given container\n",
                "\n",
                "        If container has multiple networks, it will return the IP of the first\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    def get_image_cmd(self, docker_image: str, pull: bool = True) -> List[str]:\n",
                "        \"\"\"Get the command for the given image\n",
                "        :param docker_image: Docker image to inspect\n",
                "        :param pull: Whether to pull if image is not present\n",
                "        :return: Image command in its array form\n",
                "        \"\"\"\n",
                "        cmd_list = self.inspect_image(docker_image, pull)[\"Config\"][\"Cmd\"] or []\n",
                "        return cmd_list\n",
                "\n",
                "    def get_image_entrypoint(self, docker_image: str, pull: bool = True) -> str:\n",
                "        \"\"\"Get the entry point for the given image\n",
                "        :param docker_image: Docker image to inspect\n",
                "        :param pull: Whether to pull if image is not present\n",
                "        :return: Image entrypoint\n",
                "        \"\"\"\n",
                "        LOG.debug(\"Getting the entrypoint for image: %s\", docker_image)\n",
                "        entrypoint_list = self.inspect_image(docker_image, pull)[\"Config\"][\"Entrypoint\"] or []\n",
                "        return shlex.join(entrypoint_list)\n",
                "\n",
                "    @abstractmethod\n",
                "    def has_docker(self) -> bool:\n",
                "        \"\"\"Check if system has docker available\"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def commit(\n",
                "        self,\n",
                "        container_name_or_id: str,\n",
                "        image_name: str,\n",
                "        image_tag: str,\n",
                "    ):\n",
                "        \"\"\"Create an image from a running container.\n",
                "\n",
                "        :param container_name_or_id: Source container\n",
                "        :param image_name: Destination image name\n",
                "        :param image_tag: Destination image tag\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    def create_container_from_config(self, container_config: ContainerConfiguration) -> str:\n",
                "        \"\"\"\n",
                "        Similar to create_container, but allows passing the whole ContainerConfiguration\n",
                "        :param container_config: ContainerConfiguration how to start the container\n",
                "        :return: Container ID\n",
                "        \"\"\"\n",
                "        return self.create_container(\n",
                "            image_name=container_config.image_name,\n",
                "            name=container_config.name,\n",
                "            entrypoint=container_config.entrypoint,\n",
                "            remove=container_config.remove,\n",
                "            interactive=container_config.interactive,\n",
                "            tty=container_config.tty,\n",
                "            detach=container_config.detach,\n",
                "            command=container_config.command,\n",
                "            mount_volumes=container_config.volumes,\n",
                "            ports=container_config.ports,\n",
                "            env_vars=container_config.env_vars,\n",
                "            user=container_config.user,\n",
                "            cap_add=container_config.cap_add,\n",
                "            cap_drop=container_config.cap_drop,\n",
                "            security_opt=container_config.security_opt,\n",
                "            network=container_config.network,\n",
                "            dns=container_config.dns,\n",
                "            additional_flags=container_config.additional_flags,\n",
                "            workdir=container_config.workdir,\n",
                "            privileged=container_config.privileged,\n",
                "            platform=container_config.platform,\n",
                "        )\n",
                "\n",
                "    @abstractmethod\n",
                "    def create_container(\n",
                "        self,\n",
                "        image_name: str,\n",
                "        *,\n",
                "        name: Optional[str] = None,\n",
                "        entrypoint: Optional[str] = None,\n",
                "        remove: bool = False,\n",
                "        interactive: bool = False,\n",
                "        tty: bool = False,\n",
                "        detach: bool = False,\n",
                "        command: Optional[Union[List[str], str]] = None,\n",
                "        mount_volumes: Optional[Union[VolumeMappings, List[SimpleVolumeBind]]] = None,\n",
                "        ports: Optional[PortMappings] = None,\n",
                "        env_vars: Optional[Dict[str, str]] = None,\n",
                "        user: Optional[str] = None,\n",
                "        cap_add: Optional[List[str]] = None,\n",
                "        cap_drop: Optional[List[str]] = None,\n",
                "        security_opt: Optional[List[str]] = None,\n",
                "        network: Optional[str] = None,\n",
                "        dns: Optional[str] = None,\n",
                "        additional_flags: Optional[str] = None,\n",
                "        workdir: Optional[str] = None,\n",
                "        privileged: Optional[bool] = None,\n",
                "        labels: Optional[Dict[str, str]] = None,\n",
                "        platform: Optional[DockerPlatform] = None,\n",
                "    ) -> str:\n",
                "        \"\"\"Creates a container with the given image\n",
                "\n",
                "        :return: Container ID\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def run_container(\n",
                "        self,\n",
                "        image_name: str,\n",
                "        stdin: bytes = None,\n",
                "        *,\n",
                "        name: Optional[str] = None,\n",
                "        entrypoint: Optional[str] = None,\n",
                "        remove: bool = False,\n",
                "        interactive: bool = False,\n",
                "        tty: bool = False,\n",
                "        detach: bool = False,\n",
                "        command: Optional[Union[List[str], str]] = None,\n",
                "        mount_volumes: Optional[List[SimpleVolumeBind]] = None,\n",
                "        ports: Optional[PortMappings] = None,\n",
                "        env_vars: Optional[Dict[str, str]] = None,\n",
                "        user: Optional[str] = None,\n",
                "        cap_add: Optional[List[str]] = None,\n",
                "        cap_drop: Optional[List[str]] = None,\n",
                "        security_opt: Optional[List[str]] = None,\n",
                "        network: Optional[str] = None,\n",
                "        dns: Optional[str] = None,\n",
                "        additional_flags: Optional[str] = None,\n",
                "        workdir: Optional[str] = None,\n",
                "        privileged: Optional[bool] = None,\n",
                "    ) -> Tuple[bytes, bytes]:\n",
                "        \"\"\"Creates and runs a given docker container\n",
                "\n",
                "        :return: A tuple (stdout, stderr)\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def exec_in_container(\n",
                "        self,\n",
                "        container_name_or_id: str,\n",
                "        command: Union[List[str], str],\n",
                "        interactive: bool = False,\n",
                "        detach: bool = False,\n",
                "        env_vars: Optional[Dict[str, Optional[str]]] = None,\n",
                "        stdin: Optional[bytes] = None,\n",
                "        user: Optional[str] = None,\n",
                "        workdir: Optional[str] = None,\n",
                "    ) -> Tuple[bytes, bytes]:\n",
                "        \"\"\"Execute a given command in a container\n",
                "\n",
                "        :return: A tuple (stdout, stderr)\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def start_container(\n",
                "        self,\n",
                "        container_name_or_id: str,\n",
                "        stdin: bytes = None,\n",
                "        interactive: bool = False,\n",
                "        attach: bool = False,\n",
                "        flags: Optional[str] = None,\n",
                "    ) -> Tuple[bytes, bytes]:\n",
                "        \"\"\"Start a given, already created container\n",
                "\n",
                "        :return: A tuple (stdout, stderr) if attach or interactive is set, otherwise a tuple (b\"container_name_or_id\", b\"\")\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def login(self, username: str, password: str, registry: Optional[str] = None) -> None:\n",
                "        \"\"\"\n",
                "        Login into an OCI registry\n",
                "\n",
                "        :param username: Username for the registry\n",
                "        :param password: Password / token for the registry\n",
                "        :param registry: Registry url\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "\n",
                "class Util:\n",
                "    MAX_ENV_ARGS_LENGTH = 20000\n",
                "\n",
                "    @staticmethod\n",
                "    def format_env_vars(key: str, value: Optional[str]):\n",
                "        if value is None:\n",
                "            return key\n",
                "        return f\"{key}={value}\"\n",
                "\n",
                "    @classmethod\n",
                "    def create_env_vars_file_flag(cls, env_vars: Dict) -> Tuple[List[str], Optional[str]]:\n",
                "        if not env_vars:\n",
                "            return [], None\n",
                "        result = []\n",
                "        env_vars = dict(env_vars)\n",
                "        env_file = None\n",
                "        if len(str(env_vars)) > cls.MAX_ENV_ARGS_LENGTH:\n",
                "            # default ARG_MAX=131072 in Docker - let's create an env var file if the string becomes too long...\n",
                "            env_file = cls.mountable_tmp_file()\n",
                "            env_content = \"\"\n",
                "            for name, value in dict(env_vars).items():\n",
                "                if len(value) > cls.MAX_ENV_ARGS_LENGTH:\n",
                "                    # each line in the env file has a max size as well (error \"bufio.Scanner: token too long\")\n",
                "                    continue\n",
                "                env_vars.pop(name)\n",
                "                value = value.replace(\"\\n\", \"\\\\\")\n",
                "                env_content += f\"{cls.format_env_vars(name, value)}\\n\"\n",
                "            save_file(env_file, env_content)\n",
                "            result += [\"--env-file\", env_file]\n",
                "\n",
                "        env_vars_res = [\n",
                "            item for k, v in env_vars.items() for item in [\"-e\", cls.format_env_vars(k, v)]\n",
                "        ]\n",
                "        result += env_vars_res\n",
                "        return result, env_file\n",
                "\n",
                "    @staticmethod\n",
                "    def rm_env_vars_file(env_vars_file) -> None:\n",
                "        if env_vars_file:\n",
                "            return rm_rf(env_vars_file)\n",
                "\n",
                "    @staticmethod\n",
                "    def mountable_tmp_file():\n",
                "        f = os.path.join(config.dirs.tmp, short_uid())\n",
                "        TMP_FILES.append(f)\n",
                "        return f\n",
                "\n",
                "    @staticmethod\n",
                "    def append_without_latest(image_names):\n",
                "        suffix = \":latest\"\n",
                "        for image in list(image_names):\n",
                "            if image.endswith(suffix):\n",
                "                image_names.append(image[: -len(suffix)])\n",
                "\n",
                "    @staticmethod\n",
                "    def tar_path(path, target_path, is_dir: bool):\n",
                "        f = tempfile.NamedTemporaryFile()\n",
                "        with tarfile.open(mode=\"w\", fileobj=f) as t:\n",
                "            abs_path = os.path.abspath(path)\n",
                "            arcname = (\n",
                "                os.path.basename(path)\n",
                "                if is_dir\n",
                "                else (os.path.basename(target_path) or os.path.basename(path))\n",
                "            )\n",
                "            t.add(abs_path, arcname=arcname)\n",
                "\n",
                "        f.seek(0)\n",
                "        return f\n",
                "\n",
                "    @staticmethod\n",
                "    def untar_to_path(tardata, target_path):\n",
                "        target_path = Path(target_path)\n",
                "        with tarfile.open(mode=\"r\", fileobj=io.BytesIO(b\"\".join(b for b in tardata))) as t:\n",
                "            if target_path.is_dir():\n",
                "                t.extractall(path=target_path)\n",
                "            else:\n",
                "                member = t.next()\n",
                "                if member:\n",
                "                    member.name = target_path.name\n",
                "                    t.extract(member, target_path.parent)\n",
                "                else:\n",
                "                    LOG.debug(\"File to copy empty, ignoring...\")\n",
                "\n",
                "    @staticmethod\n",
                "    def parse_additional_flags(\n",
                "        additional_flags: str,\n",
                "        env_vars: Dict[str, str] = None,\n",
                "        ports: PortMappings = None,\n",
                "        mounts: List[SimpleVolumeBind] = None,\n",
                "        network: Optional[str] = None,\n",
                "        user: Optional[str] = None,\n",
                "        platform: Optional[DockerPlatform] = None,\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        privileged: Optional[bool] = None,\n"
                ],
                "parent_version_range": {
                    "start": 911,
                    "end": 911
                },
                "child_version_range": {
                    "start": 912,
                    "end": 913
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Util",
                        "signature": "class Util:",
                        "at_line": 819
                    },
                    {
                        "type": "function",
                        "name": "parse_additional_flags",
                        "signature": "def parse_additional_flags(\n        additional_flags: str,\n        env_vars: Dict[str, str] = None,\n        ports: PortMappings = None,\n        mounts: List[SimpleVolumeBind] = None,\n        network: Optional[str] = None,\n        user: Optional[str] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->DockerRunFlags:",
                        "at_line": 903
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: localstack/utils/container_utils/container_client.py\nCode:\n           class Util:\n               ...\n               def parse_additional_flags(\n        additional_flags: str,\n        env_vars: Dict[str, str] = None,\n        ports: PortMappings = None,\n        mounts: List[SimpleVolumeBind] = None,\n        network: Optional[str] = None,\n        user: Optional[str] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->DockerRunFlags:\n                   ...\n908 909            network: Optional[str] = None,\n909 910            user: Optional[str] = None,\n910 911            platform: Optional[DockerPlatform] = None,\n    912  +         privileged: Optional[bool] = None,\n911 913        ) -> DockerRunFlags:\n912 914            \"\"\"Parses environment, volume and port flags passed as string\n913 915            :param additional_flags: String which contains the flag definitions\n         ...\n",
                "file_path": "localstack/utils/container_utils/container_client.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Optional",
                    "bool",
                    "privileged"
                ],
                "prefix": [
                    "        network: Optional[str] = None,\n",
                    "        user: Optional[str] = None,\n",
                    "        platform: Optional[DockerPlatform] = None,\n"
                ],
                "suffix": [
                    "    ) -> DockerRunFlags:\n",
                    "        \"\"\"Parses environment, volume and port flags passed as string\n",
                    "        :param additional_flags: String which contains the flag definitions\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    0
                ]
            },
            [
                "    ) -> DockerRunFlags:\n",
                "        \"\"\"Parses environment, volume and port flags passed as string\n",
                "        :param additional_flags: String which contains the flag definitions\n",
                "        :param env_vars: Dict with env vars. Will be modified in place.\n",
                "        :param ports: PortMapping object. Will be modified in place.\n",
                "        :param mounts: List of mount tuples (host_path, container_path). Will be modified in place.\n",
                "        :param network: Existing network name (optional). Warning will be printed if network is overwritten in flags.\n",
                "        :param user: User to run first process. Warning will be printed if user is overwritten in flags.\n",
                "        :param platform: Platform to execute container. Warning will be printed if platform is overwritten in flags.\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        :param privileged: Run the container in privileged mode. Warning will be printed if overwritten in flags.\n"
                ],
                "parent_version_range": {
                    "start": 920,
                    "end": 920
                },
                "child_version_range": {
                    "start": 922,
                    "end": 923
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Util",
                        "signature": "class Util:",
                        "at_line": 819
                    },
                    {
                        "type": "function",
                        "name": "parse_additional_flags",
                        "signature": "def parse_additional_flags(\n        additional_flags: str,\n        env_vars: Dict[str, str] = None,\n        ports: PortMappings = None,\n        mounts: List[SimpleVolumeBind] = None,\n        network: Optional[str] = None,\n        user: Optional[str] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->DockerRunFlags:",
                        "at_line": 903
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: localstack/utils/container_utils/container_client.py\nCode:\n           class Util:\n               ...\n               def parse_additional_flags(\n        additional_flags: str,\n        env_vars: Dict[str, str] = None,\n        ports: PortMappings = None,\n        mounts: List[SimpleVolumeBind] = None,\n        network: Optional[str] = None,\n        user: Optional[str] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->DockerRunFlags:\n                   ...\n917 919            :param network: Existing network name (optional). Warning will be printed if network is overwritten in flags.\n918 920            :param user: User to run first process. Warning will be printed if user is overwritten in flags.\n919 921            :param platform: Platform to execute container. Warning will be printed if platform is overwritten in flags.\n    922  +         :param privileged: Run the container in privileged mode. Warning will be printed if overwritten in flags.\n920 923            :return: A DockerRunFlags object containing the env_vars, ports, mount, extra_hosts, network, and labels.\n921 924                    The result will return new objects if respective parameters were None and additional flags contained\n922 925                    a flag for that object, the same which are passed otherwise.\n         ...\n",
                "file_path": "localstack/utils/container_utils/container_client.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Run",
                    "Warning",
                    "be",
                    "container",
                    "flags",
                    "mode",
                    "overwritten",
                    "param",
                    "printed",
                    "privileged",
                    "the",
                    "will"
                ],
                "prefix": [
                    "        :param network: Existing network name (optional). Warning will be printed if network is overwritten in flags.\n",
                    "        :param user: User to run first process. Warning will be printed if user is overwritten in flags.\n",
                    "        :param platform: Platform to execute container. Warning will be printed if platform is overwritten in flags.\n"
                ],
                "suffix": [
                    "        :return: A DockerRunFlags object containing the env_vars, ports, mount, extra_hosts, network, and labels.\n",
                    "                The result will return new objects if respective parameters were None and additional flags contained\n",
                    "                a flag for that object, the same which are passed otherwise.\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        :return: A DockerRunFlags object containing the env_vars, ports, mount, extra_hosts, network, and labels.\n",
                "                The result will return new objects if respective parameters were None and additional flags contained\n",
                "                a flag for that object, the same which are passed otherwise.\n",
                "        \"\"\"\n",
                "        cur_state = None\n",
                "        extra_hosts = None\n",
                "        labels = {}\n",
                "        # TODO Use argparse to simplify this logic\n",
                "        for flag in shlex.split(additional_flags):\n",
                "            if not cur_state:\n",
                "                if flag in [\"-v\", \"--volume\"]:\n",
                "                    cur_state = \"volume\"\n",
                "                elif flag in [\"-p\", \"--publish\"]:\n",
                "                    cur_state = \"port\"\n",
                "                elif flag in [\"-e\", \"--env\"]:\n",
                "                    cur_state = \"env\"\n",
                "                elif flag == \"--add-host\":\n",
                "                    cur_state = \"add-host\"\n",
                "                elif flag == \"--network\":\n",
                "                    cur_state = \"set-network\"\n",
                "                elif flag == \"--label\":\n",
                "                    cur_state = \"add-label\"\n",
                "                elif flag in [\"-u\", \"--user\"]:\n",
                "                    cur_state = \"user\"\n",
                "                elif flag == \"--platform\":\n",
                "                    cur_state = \"platform\"\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "                elif flag == \"--privileged\":\n",
                    "                    # Since this is a boolean flag with just one token, the\n",
                    "                    # override is done here rather than the else block\n",
                    "                    if privileged is not None:\n",
                    "                        LOG.warning(\n",
                    "                            f\"Overwriting Docker container privileged flag {privileged} with new value {flag}\"\n",
                    "                        )\n",
                    "                    privileged = True\n"
                ],
                "parent_version_range": {
                    "start": 946,
                    "end": 946
                },
                "child_version_range": {
                    "start": 949,
                    "end": 957
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for flag in shlex.split(additional_flags):",
                        "start_line": 928,
                        "end_line": 1024
                    },
                    {
                        "type": "if_statement",
                        "statement": "if not cur_state:",
                        "start_line": 929,
                        "end_line": 1024
                    },
                    {
                        "type": "if_statement",
                        "statement": "if flag in [\"-v\", \"--volume\"]:",
                        "start_line": 930,
                        "end_line": 949
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Util",
                        "signature": "class Util:",
                        "at_line": 819
                    },
                    {
                        "type": "function",
                        "name": "parse_additional_flags",
                        "signature": "def parse_additional_flags(\n        additional_flags: str,\n        env_vars: Dict[str, str] = None,\n        ports: PortMappings = None,\n        mounts: List[SimpleVolumeBind] = None,\n        network: Optional[str] = None,\n        user: Optional[str] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->DockerRunFlags:",
                        "at_line": 903
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: localstack/utils/container_utils/container_client.py\nCode:\n           class Util:\n               ...\n               def parse_additional_flags(\n        additional_flags: str,\n        env_vars: Dict[str, str] = None,\n        ports: PortMappings = None,\n        mounts: List[SimpleVolumeBind] = None,\n        network: Optional[str] = None,\n        user: Optional[str] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->DockerRunFlags:\n                   ...\n943 946                        cur_state = \"user\"\n944 947                    elif flag == \"--platform\":\n945 948                        cur_state = \"platform\"\n    949  +                 elif flag == \"--privileged\":\n    950  +                     # Since this is a boolean flag with just one token, the\n    951  +                     # override is done here rather than the else block\n    952  +                     if privileged is not None:\n    953  +                         LOG.warning(\n    954  +                             f\"Overwriting Docker container privileged flag {privileged} with new value {flag}\"\n    955  +                         )\n    956  +                     privileged = True\n946 957                    else:\n947 958                        raise NotImplementedError(\n948 959                            f\"Flag {flag} is currently not supported by this Docker client.\"\n         ...\n",
                "file_path": "localstack/utils/container_utils/container_client.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "LOG",
                    "elif",
                    "flag",
                    "privileged",
                    "warning"
                ],
                "prefix": [
                    "                    cur_state = \"user\"\n",
                    "                elif flag == \"--platform\":\n",
                    "                    cur_state = \"platform\"\n"
                ],
                "suffix": [
                    "                else:\n",
                    "                    raise NotImplementedError(\n",
                    "                        f\"Flag {flag} is currently not supported by this Docker client.\"\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                else:\n",
                "                    raise NotImplementedError(\n",
                "                        f\"Flag {flag} is currently not supported by this Docker client.\"\n",
                "                    )\n",
                "            else:\n",
                "                if cur_state == \"volume\":\n",
                "                    mounts = mounts if mounts is not None else []\n",
                "                    match = re.match(\n",
                "                        r\"(?P<host>[\\w\\s\\\\\\/:\\-.]+?):(?P<container>[\\w\\s\\/\\-.]+)(?::(?P<arg>ro|rw|z|Z))?\",\n",
                "                        flag,\n",
                "                    )\n",
                "                    if not match:\n",
                "                        LOG.warning(\"Unable to parse volume mount Docker flags: %s\", flag)\n",
                "                        continue\n",
                "                    host_path = match.group(\"host\")\n",
                "                    container_path = match.group(\"container\")\n",
                "                    rw_args = match.group(\"arg\")\n",
                "                    if rw_args:\n",
                "                        LOG.info(\"Volume options like :ro or :rw are currently ignored.\")\n",
                "                    mounts.append((host_path, container_path))\n",
                "                elif cur_state == \"port\":\n",
                "                    port_split = flag.split(\":\")\n",
                "                    protocol = \"tcp\"\n",
                "                    if len(port_split) == 2:\n",
                "                        host_port, container_port = port_split\n",
                "                    elif len(port_split) == 3:\n",
                "                        LOG.warning(\n",
                "                            \"Host part of port mappings are ignored currently in additional flags\"\n",
                "                        )\n",
                "                        _, host_port, container_port = port_split\n",
                "                    else:\n",
                "                        raise ValueError(\"Invalid port string provided: %s\", flag)\n",
                "                    host_port_split = host_port.split(\"-\")\n",
                "                    if len(host_port_split) == 2:\n",
                "                        host_port = [int(host_port_split[0]), int(host_port_split[1])]\n",
                "                    elif len(host_port_split) == 1:\n",
                "                        host_port = int(host_port)\n",
                "                    else:\n",
                "                        raise ValueError(\"Invalid port string provided: %s\", flag)\n",
                "                    if \"/\" in container_port:\n",
                "                        container_port, protocol = container_port.split(\"/\")\n",
                "                    ports = ports if ports is not None else PortMappings()\n",
                "                    ports.add(host_port, int(container_port), protocol)\n",
                "                elif cur_state == \"env\":\n",
                "                    lhs, _, rhs = flag.partition(\"=\")\n",
                "                    env_vars = env_vars if env_vars is not None else {}\n",
                "                    env_vars[lhs] = rhs\n",
                "                elif cur_state == \"add-host\":\n",
                "                    extra_hosts = extra_hosts if extra_hosts is not None else {}\n",
                "                    hosts_split = flag.split(\":\")\n",
                "                    extra_hosts[hosts_split[0]] = hosts_split[1]\n",
                "                elif cur_state == \"set-network\":\n",
                "                    if network:\n",
                "                        LOG.warning(\n",
                "                            \"Overwriting Docker container network '%s' with new value '%s'\",\n",
                "                            network,\n",
                "                            flag,\n",
                "                        )\n",
                "                    network = flag\n",
                "                elif cur_state == \"add-label\":\n",
                "                    key, _, value = flag.partition(\"=\")\n",
                "                    if key:\n",
                "                        labels[key] = value\n",
                "                    else:\n",
                "                        LOG.warning(\"Invalid --label specified, unable to parse: '%s'\", flag)\n",
                "                elif cur_state == \"user\":\n",
                "                    if user:\n",
                "                        LOG.warning(\n",
                "                            f\"Overwriting Docker container user {user} with new value {flag}\"\n",
                "                        )\n",
                "                    user = flag\n",
                "                elif cur_state == \"platform\":\n",
                "                    if platform:\n",
                "                        LOG.warning(\n",
                "                            f\"Overwriting Docker container platform {platform} with new value {flag}\"\n",
                "                        )\n",
                "                    platform = flag\n"
            ],
            {
                "type": "delete",
                "before": [
                    "\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 1023,
                    "end": 1024
                },
                "child_version_range": {
                    "start": 1034,
                    "end": 1034
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for flag in shlex.split(additional_flags):",
                        "start_line": 928,
                        "end_line": 1024
                    },
                    {
                        "type": "if_statement",
                        "statement": "if not cur_state:",
                        "start_line": 929,
                        "end_line": 1024
                    },
                    {
                        "type": "else_clause",
                        "statement": "else:",
                        "start_line": 950,
                        "end_line": 1024
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Util",
                        "signature": "class Util:",
                        "at_line": 819
                    },
                    {
                        "type": "function",
                        "name": "parse_additional_flags",
                        "signature": "def parse_additional_flags(\n        additional_flags: str,\n        env_vars: Dict[str, str] = None,\n        ports: PortMappings = None,\n        mounts: List[SimpleVolumeBind] = None,\n        network: Optional[str] = None,\n        user: Optional[str] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->DockerRunFlags:",
                        "at_line": 903
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: localstack/utils/container_utils/container_client.py\nCode:\n             class Util:\n                 ...\n                 def parse_additional_flags(\n        additional_flags: str,\n        env_vars: Dict[str, str] = None,\n        ports: PortMappings = None,\n        mounts: List[SimpleVolumeBind] = None,\n        network: Optional[str] = None,\n        user: Optional[str] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->DockerRunFlags:\n                     ...\n1020 1031                                f\"Overwriting Docker container platform {platform} with new value {flag}\"\n1021 1032                            )\n1022 1033                        platform = flag\n1023       - \n1024 1034                    cur_state = None\n1025 1035    \n1026 1036            return DockerRunFlags(\n           ...\n",
                "file_path": "localstack/utils/container_utils/container_client.py",
                "identifiers_before": [],
                "identifiers_after": [],
                "prefix": [
                    "                            f\"Overwriting Docker container platform {platform} with new value {flag}\"\n",
                    "                        )\n",
                    "                    platform = flag\n"
                ],
                "suffix": [
                    "                cur_state = None\n",
                    "\n",
                    "        return DockerRunFlags(\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                cur_state = None\n",
                "\n",
                "        return DockerRunFlags(\n",
                "            env_vars=env_vars,\n",
                "            ports=ports,\n",
                "            mounts=mounts,\n",
                "            extra_hosts=extra_hosts,\n",
                "            network=network,\n",
                "            labels=labels,\n",
                "            user=user,\n",
                "            platform=platform,\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "            privileged=privileged,\n"
                ],
                "parent_version_range": {
                    "start": 1035,
                    "end": 1035
                },
                "child_version_range": {
                    "start": 1045,
                    "end": 1046
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Util",
                        "signature": "class Util:",
                        "at_line": 819
                    },
                    {
                        "type": "function",
                        "name": "parse_additional_flags",
                        "signature": "def parse_additional_flags(\n        additional_flags: str,\n        env_vars: Dict[str, str] = None,\n        ports: PortMappings = None,\n        mounts: List[SimpleVolumeBind] = None,\n        network: Optional[str] = None,\n        user: Optional[str] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->DockerRunFlags:",
                        "at_line": 903
                    },
                    {
                        "type": "call",
                        "name": "DockerRunFlags",
                        "signature": "DockerRunFlags(\n            env_vars=env_vars,\n            ports=ports,\n            mounts=mounts,\n            extra_hosts=extra_hosts,\n            network=network,\n            labels=labels,\n            user=user,\n            platform=platform,\n        )",
                        "at_line": 1026,
                        "argument": "platform=..."
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: localstack/utils/container_utils/container_client.py\nCode:\n             class Util:\n                 ...\n                 def parse_additional_flags(\n        additional_flags: str,\n        env_vars: Dict[str, str] = None,\n        ports: PortMappings = None,\n        mounts: List[SimpleVolumeBind] = None,\n        network: Optional[str] = None,\n        user: Optional[str] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->DockerRunFlags:\n                     ...\n                     DockerRunFlags(\n            env_vars=env_vars,\n            ports=ports,\n            mounts=mounts,\n            extra_hosts=extra_hosts,\n            network=network,\n            labels=labels,\n            user=user,\n            platform=platform,\n        )\n                         ...\n1032 1042                labels=labels,\n1033 1043                user=user,\n1034 1044                platform=platform,\n     1045  +             privileged=privileged,\n1035 1046            )\n1036 1047    \n1037 1048        @staticmethod\n           ...\n",
                "file_path": "localstack/utils/container_utils/container_client.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "privileged"
                ],
                "prefix": [
                    "            labels=labels,\n",
                    "            user=user,\n",
                    "            platform=platform,\n"
                ],
                "suffix": [
                    "        )\n",
                    "\n",
                    "    @staticmethod\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 1045,
                                    "column": 12
                                },
                                "end": {
                                    "line": 1045,
                                    "column": 22
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/container_utils/container_client.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        )\n",
                "\n",
                "    @staticmethod\n",
                "    def convert_mount_list_to_dict(\n",
                "        mount_volumes: Union[List[SimpleVolumeBind], VolumeMappings],\n",
                "    ) -> Dict[str, Dict[str, str]]:\n",
                "        \"\"\"Converts a List of (host_path, container_path) tuples to a Dict suitable as volume argument for docker sdk\"\"\"\n",
                "\n",
                "        def _map_to_dict(paths: SimpleVolumeBind | VolumeBind):\n",
                "            if isinstance(paths, VolumeBind):\n",
                "                return str(paths.host_dir), {\n",
                "                    \"bind\": paths.container_dir,\n",
                "                    \"mode\": \"ro\" if paths.read_only else \"rw\",\n",
                "                }\n",
                "            else:\n",
                "                return str(paths[0]), {\"bind\": paths[1], \"mode\": \"rw\"}\n",
                "\n",
                "        return dict(\n",
                "            map(\n",
                "                _map_to_dict,\n",
                "                mount_volumes,\n",
                "            )\n",
                "        )\n",
                "\n",
                "    @staticmethod\n",
                "    def resolve_dockerfile_path(dockerfile_path: str) -> str:\n",
                "        \"\"\"If the given path is a directory that contains a Dockerfile, then return the file path to it.\"\"\"\n",
                "        rel_path = os.path.join(dockerfile_path, \"Dockerfile\")\n",
                "        if os.path.isdir(dockerfile_path) and os.path.exists(rel_path):\n",
                "            return rel_path\n",
                "        return dockerfile_path"
            ]
        ],
        "localstack/utils/container_utils/docker_sdk_client.py": [
            [
                "import logging\n",
                "import os\n",
                "import queue\n",
                "import socket\n",
                "import threading\n",
                "from typing import Dict, List, Optional, Tuple, Union\n",
                "\n",
                "import docker\n",
                "from docker import DockerClient\n",
                "from docker.errors import APIError, ContainerError, DockerException, ImageNotFound, NotFound\n",
                "from docker.models.containers import Container\n",
                "from docker.utils.socket import STDERR, STDOUT, frames_iter\n",
                "\n",
                "from localstack.utils.container_utils.container_client import (\n",
                "    AccessDenied,\n",
                "    CancellableStream,\n",
                "    ContainerClient,\n",
                "    ContainerException,\n",
                "    DockerContainerStatus,\n",
                "    DockerPlatform,\n",
                "    NoSuchContainer,\n",
                "    NoSuchImage,\n",
                "    NoSuchNetwork,\n",
                "    PortMappings,\n",
                "    RegistryConnectionError,\n",
                "    SimpleVolumeBind,\n",
                "    Util,\n",
                ")\n",
                "from localstack.utils.strings import to_bytes, to_str\n",
                "from localstack.utils.threads import start_worker_thread\n",
                "\n",
                "LOG = logging.getLogger(__name__)\n",
                "SDK_ISDIR = 1 << 31\n",
                "\n",
                "\n",
                "class SdkDockerClient(ContainerClient):\n",
                "    \"\"\"Class for managing docker using the python docker sdk\"\"\"\n",
                "\n",
                "    docker_client: Optional[DockerClient]\n",
                "\n",
                "    def __init__(self):\n",
                "        try:\n",
                "            self.docker_client = docker.from_env()\n",
                "            logging.getLogger(\"urllib3\").setLevel(logging.INFO)\n",
                "        except DockerException:\n",
                "            self.docker_client = None\n",
                "\n",
                "    def client(self):\n",
                "        if self.docker_client:\n",
                "            return self.docker_client\n",
                "        else:\n",
                "            raise ContainerException(\"Docker not available\")\n",
                "\n",
                "    def _read_from_sock(self, sock: socket, tty: bool):\n",
                "        \"\"\"Reads multiplexed messages from a socket returned by attach_socket.\n",
                "\n",
                "        Uses the protocol specified here: https://docs.docker.com/engine/api/v1.41/#operation/ContainerAttach\n",
                "        \"\"\"\n",
                "        stdout = b\"\"\n",
                "        stderr = b\"\"\n",
                "        for frame_type, frame_data in frames_iter(sock, tty):\n",
                "            if frame_type == STDOUT:\n",
                "                stdout += frame_data\n",
                "            elif frame_type == STDERR:\n",
                "                stderr += frame_data\n",
                "            else:\n",
                "                raise ContainerException(\"Invalid frame type when reading from socket\")\n",
                "        return stdout, stderr\n",
                "\n",
                "    def _container_path_info(self, container: Container, container_path: str):\n",
                "        \"\"\"\n",
                "        Get information about a path in the given container\n",
                "        :param container: Container to be inspected\n",
                "        :param container_path: Path in container\n",
                "        :return: Tuple (path_exists, path_is_directory)\n",
                "        \"\"\"\n",
                "        # Docker CLI copy uses go FileMode to determine if target is a dict or not\n",
                "        # https://github.com/docker/cli/blob/e3dfc2426e51776a3263cab67fbba753dd3adaa9/cli/command/container/cp.go#L260\n",
                "        # The isDir Bit is the most significant bit in the 32bit struct:\n",
                "        # https://golang.org/src/os/types.go?s=2650:2683\n",
                "        stats = {}\n",
                "        try:\n",
                "            _, stats = container.get_archive(container_path)\n",
                "            target_exists = True\n",
                "        except APIError:\n",
                "            target_exists = False\n",
                "        target_is_dir = target_exists and bool(stats[\"mode\"] & SDK_ISDIR)\n",
                "        return target_exists, target_is_dir\n",
                "\n",
                "    def get_container_status(self, container_name: str) -> DockerContainerStatus:\n",
                "        # LOG.debug(\"Getting container status for container: %s\", container_name) #  too verbose\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name)\n",
                "            if container.status == \"running\":\n",
                "                return DockerContainerStatus.UP\n",
                "            elif container.status == \"paused\":\n",
                "                return DockerContainerStatus.PAUSED\n",
                "            else:\n",
                "                return DockerContainerStatus.DOWN\n",
                "        except NotFound:\n",
                "            return DockerContainerStatus.NON_EXISTENT\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def stop_container(self, container_name: str, timeout: int = None) -> None:\n",
                "        if timeout is None:\n",
                "            timeout = self.STOP_TIMEOUT\n",
                "        LOG.debug(\"Stopping container: %s\", container_name)\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name)\n",
                "            container.stop(timeout=timeout)\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def restart_container(self, container_name: str, timeout: int = 10) -> None:\n",
                "        LOG.debug(\"Restarting container: %s\", container_name)\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name)\n",
                "            container.restart(timeout=timeout)\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def pause_container(self, container_name: str) -> None:\n",
                "        LOG.debug(\"Pausing container: %s\", container_name)\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name)\n",
                "            container.pause()\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def unpause_container(self, container_name: str) -> None:\n",
                "        LOG.debug(\"Unpausing container: %s\", container_name)\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name)\n",
                "            container.unpause()\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def remove_container(self, container_name: str, force=True, check_existence=False) -> None:\n",
                "        LOG.debug(\"Removing container: %s\", container_name)\n",
                "        if check_existence and container_name not in self.get_running_container_names():\n",
                "            LOG.debug(\"Aborting removing due to check_existence check\")\n",
                "            return\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name)\n",
                "            container.remove(force=force)\n",
                "        except NotFound:\n",
                "            if not force:\n",
                "                raise NoSuchContainer(container_name)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def list_containers(self, filter: Union[List[str], str, None] = None, all=True) -> List[dict]:\n",
                "        if filter:\n",
                "            filter = [filter] if isinstance(filter, str) else filter\n",
                "            filter = dict([f.split(\"=\", 1) for f in filter])\n",
                "        LOG.debug(\"Listing containers with filters: %s\", filter)\n",
                "        try:\n",
                "            container_list = self.client().containers.list(filters=filter, all=all)\n",
                "            result = []\n",
                "            for container in container_list:\n",
                "                try:\n",
                "                    result.append(\n",
                "                        {\n",
                "                            \"id\": container.id,\n",
                "                            \"image\": container.image,\n",
                "                            \"name\": container.name,\n",
                "                            \"status\": container.status,\n",
                "                            \"labels\": container.labels,\n",
                "                        }\n",
                "                    )\n",
                "                except Exception as e:\n",
                "                    LOG.error(f\"Error checking container {container}: {e}\")\n",
                "            return result\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def copy_into_container(\n",
                "        self, container_name: str, local_path: str, container_path: str\n",
                "    ) -> None:  # TODO behave like https://docs.docker.com/engine/reference/commandline/cp/\n",
                "        LOG.debug(\"Copying file %s into %s:%s\", local_path, container_name, container_path)\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name)\n",
                "            target_exists, target_isdir = self._container_path_info(container, container_path)\n",
                "            target_path = container_path if target_isdir else os.path.dirname(container_path)\n",
                "            with Util.tar_path(local_path, container_path, is_dir=target_isdir) as tar:\n",
                "                container.put_archive(target_path, tar)\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def copy_from_container(\n",
                "        self,\n",
                "        container_name: str,\n",
                "        local_path: str,\n",
                "        container_path: str,\n",
                "    ) -> None:\n",
                "        LOG.debug(\"Copying file from %s:%s to %s\", container_name, container_path, local_path)\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name)\n",
                "            bits, _ = container.get_archive(container_path)\n",
                "            Util.untar_to_path(bits, local_path)\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def pull_image(self, docker_image: str, platform: Optional[DockerPlatform] = None) -> None:\n",
                "        LOG.debug(\"Pulling Docker image: %s\", docker_image)\n",
                "        # some path in the docker image string indicates a custom repository\n",
                "        try:\n",
                "            self.client().images.pull(docker_image, platform=platform)\n",
                "        except ImageNotFound:\n",
                "            raise NoSuchImage(docker_image)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def push_image(self, docker_image: str) -> None:\n",
                "        LOG.debug(\"Pushing Docker image: %s\", docker_image)\n",
                "        try:\n",
                "            result = self.client().images.push(docker_image)\n",
                "            # some SDK clients (e.g., 5.0.0) seem to return an error string, instead of raising\n",
                "            if isinstance(result, (str, bytes)) and '\"errorDetail\"' in to_str(result):\n",
                "                if \"image does not exist locally\" in to_str(result):\n",
                "                    raise NoSuchImage(docker_image)\n",
                "                if \"is denied\" in to_str(result):\n",
                "                    raise AccessDenied(docker_image)\n",
                "                if \"connection refused\" in to_str(result):\n",
                "                    raise RegistryConnectionError(result)\n",
                "                raise ContainerException(result)\n",
                "        except ImageNotFound:\n",
                "            raise NoSuchImage(docker_image)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def build_image(\n",
                "        self,\n",
                "        dockerfile_path: str,\n",
                "        image_name: str,\n",
                "        context_path: str = None,\n",
                "        platform: Optional[DockerPlatform] = None,\n",
                "    ):\n",
                "        try:\n",
                "            dockerfile_path = Util.resolve_dockerfile_path(dockerfile_path)\n",
                "            context_path = context_path or os.path.dirname(dockerfile_path)\n",
                "            LOG.debug(\"Building Docker image %s from %s\", image_name, dockerfile_path)\n",
                "            self.client().images.build(\n",
                "                path=context_path,\n",
                "                dockerfile=dockerfile_path,\n",
                "                tag=image_name,\n",
                "                rm=True,\n",
                "                platform=platform,\n",
                "            )\n",
                "        except APIError as e:\n",
                "            raise ContainerException(\"Unable to build Docker image\") from e\n",
                "\n",
                "    def tag_image(self, source_ref: str, target_name: str) -> None:\n",
                "        try:\n",
                "            LOG.debug(\"Tagging Docker image '%s' as '%s'\", source_ref, target_name)\n",
                "            image = self.client().images.get(source_ref)\n",
                "            image.tag(target_name)\n",
                "        except APIError as e:\n",
                "            if e.status_code == 404:\n",
                "                raise NoSuchImage(source_ref)\n",
                "            raise ContainerException(\"Unable to tag Docker image\") from e\n",
                "\n",
                "    def get_docker_image_names(self, strip_latest=True, include_tags=True):\n",
                "        try:\n",
                "            images = self.client().images.list()\n",
                "            image_names = [tag for image in images for tag in image.tags if image.tags]\n",
                "            if not include_tags:\n",
                "                image_names = list(map(lambda image_name: image_name.split(\":\")[0], image_names))\n",
                "            if strip_latest:\n",
                "                Util.append_without_latest(image_names)\n",
                "            return image_names\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def get_container_logs(self, container_name_or_id: str, safe=False) -> str:\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name_or_id)\n",
                "            return to_str(container.logs())\n",
                "        except NotFound:\n",
                "            if safe:\n",
                "                return \"\"\n",
                "            raise NoSuchContainer(container_name_or_id)\n",
                "        except APIError as e:\n",
                "            if safe:\n",
                "                return \"\"\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def stream_container_logs(self, container_name_or_id: str) -> CancellableStream:\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name_or_id)\n",
                "            return container.logs(stream=True, follow=True)\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name_or_id)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def inspect_container(self, container_name_or_id: str) -> Dict[str, Union[Dict, str]]:\n",
                "        try:\n",
                "            return self.client().containers.get(container_name_or_id).attrs\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name_or_id)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def inspect_image(self, image_name: str, pull: bool = True) -> Dict[str, Union[Dict, str]]:\n",
                "        try:\n",
                "            return self.client().images.get(image_name).attrs\n",
                "        except NotFound:\n",
                "            if pull:\n",
                "                self.pull_image(image_name)\n",
                "                return self.inspect_image(image_name, pull=False)\n",
                "            raise NoSuchImage(image_name)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def inspect_network(self, network_name: str) -> Dict[str, Union[Dict, str]]:\n",
                "        try:\n",
                "            return self.client().networks.get(network_name).attrs\n",
                "        except NotFound:\n",
                "            raise NoSuchNetwork(network_name)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def connect_container_to_network(\n",
                "        self, network_name: str, container_name_or_id: str, aliases: Optional[List] = None\n",
                "    ) -> None:\n",
                "        LOG.debug(\n",
                "            \"Connecting container '%s' to network '%s' with aliases '%s'\",\n",
                "            container_name_or_id,\n",
                "            network_name,\n",
                "            aliases,\n",
                "        )\n",
                "        try:\n",
                "            network = self.client().networks.get(network_name)\n",
                "        except NotFound:\n",
                "            raise NoSuchNetwork(network_name)\n",
                "        try:\n",
                "            network.connect(container=container_name_or_id, aliases=aliases)\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name_or_id)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def disconnect_container_from_network(\n",
                "        self, network_name: str, container_name_or_id: str\n",
                "    ) -> None:\n",
                "        LOG.debug(\n",
                "            \"Disconnecting container '%s' from network '%s'\", container_name_or_id, network_name\n",
                "        )\n",
                "        try:\n",
                "            try:\n",
                "                network = self.client().networks.get(network_name)\n",
                "            except NotFound:\n",
                "                raise NoSuchNetwork(network_name)\n",
                "            try:\n",
                "                network.disconnect(container_name_or_id)\n",
                "            except NotFound:\n",
                "                raise NoSuchContainer(container_name_or_id)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def get_container_ip(self, container_name_or_id: str) -> str:\n",
                "        networks = self.inspect_container(container_name_or_id)[\"NetworkSettings\"][\"Networks\"]\n",
                "        network_names = list(networks)\n",
                "        if len(network_names) > 1:\n",
                "            LOG.info(\"Container has more than one assigned network. Picking the first one...\")\n",
                "        return networks[network_names[0]][\"IPAddress\"]\n",
                "\n",
                "    def has_docker(self) -> bool:\n",
                "        try:\n",
                "            if not self.docker_client:\n",
                "                return False\n",
                "            self.client().ping()\n",
                "            return True\n",
                "        except APIError:\n",
                "            return False\n",
                "\n",
                "    def remove_image(self, image: str, force: bool = True):\n",
                "        LOG.debug(\"Removing image %s %s\", image, \"(forced)\" if force else \"\")\n",
                "        try:\n",
                "            self.client().images.remove(image=image, force=force)\n",
                "        except ImageNotFound:\n",
                "            if not force:\n",
                "                raise NoSuchImage(image)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def commit(\n",
                "        self,\n",
                "        container_name_or_id: str,\n",
                "        image_name: str,\n",
                "        image_tag: str,\n",
                "    ):\n",
                "        LOG.debug(\n",
                "            \"Creating image from container %s as %s:%s\", container_name_or_id, image_name, image_tag\n",
                "        )\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name_or_id)\n",
                "            container.commit(repository=image_name, tag=image_tag)\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name_or_id)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def start_container(\n",
                "        self,\n",
                "        container_name_or_id: str,\n",
                "        stdin=None,\n",
                "        interactive: bool = False,\n",
                "        attach: bool = False,\n",
                "        flags: Optional[str] = None,\n",
                "    ) -> Tuple[bytes, bytes]:\n",
                "        LOG.debug(\"Starting container %s\", container_name_or_id)\n",
                "        try:\n",
                "            container = self.client().containers.get(container_name_or_id)\n",
                "            stdout = to_bytes(container_name_or_id)\n",
                "            stderr = b\"\"\n",
                "            if interactive or attach:\n",
                "                params = {\"stdout\": 1, \"stderr\": 1, \"stream\": 1}\n",
                "                if interactive:\n",
                "                    params[\"stdin\"] = 1\n",
                "                sock = container.attach_socket(params=params)\n",
                "                sock = sock._sock if hasattr(sock, \"_sock\") else sock\n",
                "                result_queue = queue.Queue()\n",
                "                thread_started = threading.Event()\n",
                "                start_waiting = threading.Event()\n",
                "\n",
                "                # Note: We need to be careful about potential race conditions here - .wait() should happen right\n",
                "                #   after .start(). Hence starting a thread and asynchronously waiting for the container exit code\n",
                "                def wait_for_result(*_):\n",
                "                    _exit_code = -1\n",
                "                    try:\n",
                "                        thread_started.set()\n",
                "                        start_waiting.wait()\n",
                "                        _exit_code = container.wait()[\"StatusCode\"]\n",
                "                    except APIError as e:\n",
                "                        _exit_code = 1\n",
                "                        raise ContainerException(str(e))\n",
                "                    finally:\n",
                "                        result_queue.put(_exit_code)\n",
                "\n",
                "                # start listener thread\n",
                "                start_worker_thread(wait_for_result)\n",
                "                thread_started.wait()\n",
                "                # start container\n",
                "                container.start()\n",
                "                # start awaiting container result\n",
                "                start_waiting.set()\n",
                "\n",
                "                # handle container input/output\n",
                "                # under windows, the socket has no __enter__ / cannot be used as context manager\n",
                "                # therefore try/finally instead of with here\n",
                "                try:\n",
                "                    if stdin:\n",
                "                        sock.sendall(to_bytes(stdin))\n",
                "                        sock.shutdown(socket.SHUT_WR)\n",
                "                    stdout, stderr = self._read_from_sock(sock, False)\n",
                "                except socket.timeout:\n",
                "                    LOG.debug(\n",
                "                        f\"Socket timeout when talking to the I/O streams of Docker container '{container_name_or_id}'\"\n",
                "                    )\n",
                "                finally:\n",
                "                    sock.close()\n",
                "\n",
                "                # get container exit code\n",
                "                exit_code = result_queue.get()\n",
                "                if exit_code:\n",
                "                    raise ContainerException(\n",
                "                        f\"Docker container returned with exit code {exit_code}\",\n",
                "                        stdout=stdout,\n",
                "                        stderr=stderr,\n",
                "                    )\n",
                "            else:\n",
                "                container.start()\n",
                "            return stdout, stderr\n",
                "        except NotFound:\n",
                "            raise NoSuchContainer(container_name_or_id)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def create_container(\n",
                "        self,\n",
                "        image_name: str,\n",
                "        *,\n",
                "        name: Optional[str] = None,\n",
                "        entrypoint: Optional[str] = None,\n",
                "        remove: bool = False,\n",
                "        interactive: bool = False,\n",
                "        tty: bool = False,\n",
                "        detach: bool = False,\n",
                "        command: Optional[Union[List[str], str]] = None,\n",
                "        mount_volumes: Optional[List[SimpleVolumeBind]] = None,\n",
                "        ports: Optional[PortMappings] = None,\n",
                "        env_vars: Optional[Dict[str, str]] = None,\n",
                "        user: Optional[str] = None,\n",
                "        cap_add: Optional[List[str]] = None,\n",
                "        cap_drop: Optional[List[str]] = None,\n",
                "        security_opt: Optional[List[str]] = None,\n",
                "        network: Optional[str] = None,\n",
                "        dns: Optional[str] = None,\n",
                "        additional_flags: Optional[str] = None,\n",
                "        workdir: Optional[str] = None,\n",
                "        privileged: Optional[bool] = None,\n",
                "        labels: Optional[Dict[str, str]] = None,\n",
                "        platform: Optional[DockerPlatform] = None,\n",
                "    ) -> str:\n",
                "        LOG.debug(\"Creating container with attributes: %s\", locals())\n",
                "        extra_hosts = None\n",
                "        if additional_flags:\n",
                "            parsed_flags = Util.parse_additional_flags(\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                additional_flags, env_vars, ports, mount_volumes, network, user, platform\n"
                ],
                "after": [
                    "                additional_flags,\n",
                    "                env_vars,\n",
                    "                ports,\n",
                    "                mount_volumes,\n",
                    "                network,\n",
                    "                user,\n",
                    "                platform,\n",
                    "                privileged,\n"
                ],
                "parent_version_range": {
                    "start": 523,
                    "end": 524
                },
                "child_version_range": {
                    "start": 523,
                    "end": 531
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if additional_flags:",
                        "start_line": 521,
                        "end_line": 532
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "SdkDockerClient",
                        "signature": "class SdkDockerClient(ContainerClient):",
                        "at_line": 35
                    },
                    {
                        "type": "function",
                        "name": "create_container",
                        "signature": "def create_container(\n        self,\n        image_name: str,\n        *,\n        name: Optional[str] = None,\n        entrypoint: Optional[str] = None,\n        remove: bool = False,\n        interactive: bool = False,\n        tty: bool = False,\n        detach: bool = False,\n        command: Optional[Union[List[str], str]] = None,\n        mount_volumes: Optional[List[SimpleVolumeBind]] = None,\n        ports: Optional[PortMappings] = None,\n        env_vars: Optional[Dict[str, str]] = None,\n        user: Optional[str] = None,\n        cap_add: Optional[List[str]] = None,\n        cap_drop: Optional[List[str]] = None,\n        security_opt: Optional[List[str]] = None,\n        network: Optional[str] = None,\n        dns: Optional[str] = None,\n        additional_flags: Optional[str] = None,\n        workdir: Optional[str] = None,\n        privileged: Optional[bool] = None,\n        labels: Optional[Dict[str, str]] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->str:",
                        "at_line": 493
                    },
                    {
                        "type": "call",
                        "name": "Util.parse_additional_flags",
                        "signature": "Util.parse_additional_flags(\n                additional_flags, env_vars, ports, mount_volumes, network, user, platform\n            )",
                        "at_line": 522,
                        "argument": "additional_flags"
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: localstack/utils/container_utils/docker_sdk_client.py\nCode:\n           class SdkDockerClient(ContainerClient):\n               ...\n               def create_container(\n        self,\n        image_name: str,\n        *,\n        name: Optional[str] = None,\n        entrypoint: Optional[str] = None,\n        remove: bool = False,\n        interactive: bool = False,\n        tty: bool = False,\n        detach: bool = False,\n        command: Optional[Union[List[str], str]] = None,\n        mount_volumes: Optional[List[SimpleVolumeBind]] = None,\n        ports: Optional[PortMappings] = None,\n        env_vars: Optional[Dict[str, str]] = None,\n        user: Optional[str] = None,\n        cap_add: Optional[List[str]] = None,\n        cap_drop: Optional[List[str]] = None,\n        security_opt: Optional[List[str]] = None,\n        network: Optional[str] = None,\n        dns: Optional[str] = None,\n        additional_flags: Optional[str] = None,\n        workdir: Optional[str] = None,\n        privileged: Optional[bool] = None,\n        labels: Optional[Dict[str, str]] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->str:\n                   ...\n520 520            extra_hosts = None\n521 521            if additional_flags:\n522 522                parsed_flags = Util.parse_additional_flags(\n523      -                 additional_flags, env_vars, ports, mount_volumes, network, user, platform\n    523  +                 additional_flags,\n    524  +                 env_vars,\n    525  +                 ports,\n    526  +                 mount_volumes,\n    527  +                 network,\n    528  +                 user,\n    529  +                 platform,\n    530  +                 privileged,\n524 531                )\n525 532                env_vars = parsed_flags.env_vars\n526 533                ports = parsed_flags.ports\n         ...\n",
                "file_path": "localstack/utils/container_utils/docker_sdk_client.py",
                "identifiers_before": [
                    "additional_flags",
                    "env_vars",
                    "mount_volumes",
                    "network",
                    "platform",
                    "ports",
                    "user"
                ],
                "identifiers_after": [
                    "additional_flags",
                    "env_vars",
                    "mount_volumes",
                    "network",
                    "platform",
                    "ports",
                    "privileged",
                    "user"
                ],
                "prefix": [
                    "        extra_hosts = None\n",
                    "        if additional_flags:\n",
                    "            parsed_flags = Util.parse_additional_flags(\n"
                ],
                "suffix": [
                    "            )\n",
                    "            env_vars = parsed_flags.env_vars\n",
                    "            ports = parsed_flags.ports\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "            )\n",
                "            env_vars = parsed_flags.env_vars\n",
                "            ports = parsed_flags.ports\n",
                "            mount_volumes = parsed_flags.mounts\n",
                "            extra_hosts = parsed_flags.extra_hosts\n",
                "            network = parsed_flags.network\n",
                "            labels = parsed_flags.labels\n",
                "            user = parsed_flags.user\n",
                "            platform = parsed_flags.platform\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "            privileged = parsed_flags.privileged\n"
                ],
                "parent_version_range": {
                    "start": 533,
                    "end": 533
                },
                "child_version_range": {
                    "start": 540,
                    "end": 541
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if additional_flags:",
                        "start_line": 521,
                        "end_line": 532
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "SdkDockerClient",
                        "signature": "class SdkDockerClient(ContainerClient):",
                        "at_line": 35
                    },
                    {
                        "type": "function",
                        "name": "create_container",
                        "signature": "def create_container(\n        self,\n        image_name: str,\n        *,\n        name: Optional[str] = None,\n        entrypoint: Optional[str] = None,\n        remove: bool = False,\n        interactive: bool = False,\n        tty: bool = False,\n        detach: bool = False,\n        command: Optional[Union[List[str], str]] = None,\n        mount_volumes: Optional[List[SimpleVolumeBind]] = None,\n        ports: Optional[PortMappings] = None,\n        env_vars: Optional[Dict[str, str]] = None,\n        user: Optional[str] = None,\n        cap_add: Optional[List[str]] = None,\n        cap_drop: Optional[List[str]] = None,\n        security_opt: Optional[List[str]] = None,\n        network: Optional[str] = None,\n        dns: Optional[str] = None,\n        additional_flags: Optional[str] = None,\n        workdir: Optional[str] = None,\n        privileged: Optional[bool] = None,\n        labels: Optional[Dict[str, str]] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->str:",
                        "at_line": 493
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: localstack/utils/container_utils/docker_sdk_client.py\nCode:\n           class SdkDockerClient(ContainerClient):\n               ...\n               def create_container(\n        self,\n        image_name: str,\n        *,\n        name: Optional[str] = None,\n        entrypoint: Optional[str] = None,\n        remove: bool = False,\n        interactive: bool = False,\n        tty: bool = False,\n        detach: bool = False,\n        command: Optional[Union[List[str], str]] = None,\n        mount_volumes: Optional[List[SimpleVolumeBind]] = None,\n        ports: Optional[PortMappings] = None,\n        env_vars: Optional[Dict[str, str]] = None,\n        user: Optional[str] = None,\n        cap_add: Optional[List[str]] = None,\n        cap_drop: Optional[List[str]] = None,\n        security_opt: Optional[List[str]] = None,\n        network: Optional[str] = None,\n        dns: Optional[str] = None,\n        additional_flags: Optional[str] = None,\n        workdir: Optional[str] = None,\n        privileged: Optional[bool] = None,\n        labels: Optional[Dict[str, str]] = None,\n        platform: Optional[DockerPlatform] = None,\n    )->str:\n                   ...\n530 537                labels = parsed_flags.labels\n531 538                user = parsed_flags.user\n532 539                platform = parsed_flags.platform\n    540  +             privileged = parsed_flags.privileged\n533 541    \n534 542            try:\n535 543                kwargs = {}\n         ...\n",
                "file_path": "localstack/utils/container_utils/docker_sdk_client.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "parsed_flags",
                    "privileged"
                ],
                "prefix": [
                    "            labels = parsed_flags.labels\n",
                    "            user = parsed_flags.user\n",
                    "            platform = parsed_flags.platform\n"
                ],
                "suffix": [
                    "\n",
                    "        try:\n",
                    "            kwargs = {}\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 540,
                                    "column": 38
                                },
                                "end": {
                                    "line": 540,
                                    "column": 48
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/container_utils/docker_sdk_client.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "        try:\n",
                "            kwargs = {}\n",
                "            if cap_add:\n",
                "                kwargs[\"cap_add\"] = cap_add\n",
                "            if cap_drop:\n",
                "                kwargs[\"cap_drop\"] = cap_drop\n",
                "            if security_opt:\n",
                "                kwargs[\"security_opt\"] = security_opt\n",
                "            if dns:\n",
                "                kwargs[\"dns\"] = [dns]\n",
                "            if ports:\n",
                "                kwargs[\"ports\"] = ports.to_dict()\n",
                "            if workdir:\n",
                "                kwargs[\"working_dir\"] = workdir\n",
                "            if privileged:\n",
                "                kwargs[\"privileged\"] = True\n",
                "            if labels:\n",
                "                kwargs[\"labels\"] = labels\n",
                "            mounts = None\n",
                "            if mount_volumes:\n",
                "                mounts = Util.convert_mount_list_to_dict(mount_volumes)\n",
                "\n",
                "            def create_container():\n",
                "                return self.client().containers.create(\n",
                "                    image=image_name,\n",
                "                    command=command,\n",
                "                    auto_remove=remove,\n",
                "                    name=name,\n",
                "                    stdin_open=interactive,\n",
                "                    tty=tty,\n",
                "                    entrypoint=entrypoint,\n",
                "                    environment=env_vars,\n",
                "                    detach=detach,\n",
                "                    user=user,\n",
                "                    network=network,\n",
                "                    volumes=mounts,\n",
                "                    extra_hosts=extra_hosts,\n",
                "                    platform=platform,\n",
                "                    **kwargs,\n",
                "                )\n",
                "\n",
                "            try:\n",
                "                container = create_container()\n",
                "            except ImageNotFound:\n",
                "                self.pull_image(image_name, platform)\n",
                "                container = create_container()\n",
                "            return container.id\n",
                "        except ImageNotFound:\n",
                "            raise NoSuchImage(image_name)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def run_container(\n",
                "        self,\n",
                "        image_name: str,\n",
                "        stdin=None,\n",
                "        *,\n",
                "        name: Optional[str] = None,\n",
                "        entrypoint: Optional[str] = None,\n",
                "        remove: bool = False,\n",
                "        interactive: bool = False,\n",
                "        tty: bool = False,\n",
                "        detach: bool = False,\n",
                "        command: Optional[Union[List[str], str]] = None,\n",
                "        mount_volumes: Optional[List[SimpleVolumeBind]] = None,\n",
                "        ports: Optional[PortMappings] = None,\n",
                "        env_vars: Optional[Dict[str, str]] = None,\n",
                "        user: Optional[str] = None,\n",
                "        cap_add: Optional[List[str]] = None,\n",
                "        cap_drop: Optional[List[str]] = None,\n",
                "        security_opt: Optional[List[str]] = None,\n",
                "        network: Optional[str] = None,\n",
                "        dns: Optional[str] = None,\n",
                "        additional_flags: Optional[str] = None,\n",
                "        workdir: Optional[str] = None,\n",
                "        privileged: Optional[bool] = None,\n",
                "    ) -> Tuple[bytes, bytes]:\n",
                "        LOG.debug(\"Running container with image: %s\", image_name)\n",
                "        container = None\n",
                "        try:\n",
                "            container = self.create_container(\n",
                "                image_name,\n",
                "                name=name,\n",
                "                entrypoint=entrypoint,\n",
                "                interactive=interactive,\n",
                "                tty=tty,\n",
                "                detach=detach,\n",
                "                remove=remove and detach,\n",
                "                command=command,\n",
                "                mount_volumes=mount_volumes,\n",
                "                ports=ports,\n",
                "                env_vars=env_vars,\n",
                "                user=user,\n",
                "                cap_add=cap_add,\n",
                "                cap_drop=cap_drop,\n",
                "                security_opt=security_opt,\n",
                "                network=network,\n",
                "                dns=dns,\n",
                "                additional_flags=additional_flags,\n",
                "                workdir=workdir,\n",
                "                privileged=privileged,\n",
                "            )\n",
                "            result = self.start_container(\n",
                "                container_name_or_id=container,\n",
                "                stdin=stdin,\n",
                "                interactive=interactive,\n",
                "                attach=not detach,\n",
                "            )\n",
                "        finally:\n",
                "            if remove and container and not detach:\n",
                "                self.remove_container(container)\n",
                "        return result\n",
                "\n",
                "    def exec_in_container(\n",
                "        self,\n",
                "        container_name_or_id: str,\n",
                "        command: Union[List[str], str],\n",
                "        interactive=False,\n",
                "        detach=False,\n",
                "        env_vars: Optional[Dict[str, Optional[str]]] = None,\n",
                "        stdin: Optional[bytes] = None,\n",
                "        user: Optional[str] = None,\n",
                "        workdir: Optional[str] = None,\n",
                "    ) -> Tuple[bytes, bytes]:\n",
                "        LOG.debug(\"Executing command in container %s: %s\", container_name_or_id, command)\n",
                "        try:\n",
                "            container: Container = self.client().containers.get(container_name_or_id)\n",
                "            result = container.exec_run(\n",
                "                cmd=command,\n",
                "                environment=env_vars,\n",
                "                user=user,\n",
                "                detach=detach,\n",
                "                stdin=interactive and bool(stdin),\n",
                "                socket=interactive and bool(stdin),\n",
                "                stdout=True,\n",
                "                stderr=True,\n",
                "                demux=True,\n",
                "                workdir=workdir,\n",
                "            )\n",
                "            tty = False\n",
                "            if interactive and stdin:  # result is a socket\n",
                "                sock = result[1]\n",
                "                sock = sock._sock if hasattr(sock, \"_sock\") else sock\n",
                "                with sock:\n",
                "                    try:\n",
                "                        sock.sendall(stdin)\n",
                "                        sock.shutdown(socket.SHUT_WR)\n",
                "                        stdout, stderr = self._read_from_sock(sock, tty)\n",
                "                        return stdout, stderr\n",
                "                    except socket.timeout:\n",
                "                        pass\n",
                "            else:\n",
                "                if detach:\n",
                "                    return b\"\", b\"\"\n",
                "                return_code = result[0]\n",
                "                if isinstance(result[1], bytes):\n",
                "                    stdout = result[1]\n",
                "                    stderr = b\"\"\n",
                "                else:\n",
                "                    stdout, stderr = result[1]\n",
                "                if return_code != 0:\n",
                "                    raise ContainerException(\n",
                "                        f\"Exec command returned with exit code {return_code}\", stdout, stderr\n",
                "                    )\n",
                "                return stdout, stderr\n",
                "        except ContainerError:\n",
                "            raise NoSuchContainer(container_name_or_id)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e\n",
                "\n",
                "    def login(self, username: str, password: str, registry: Optional[str] = None) -> None:\n",
                "        LOG.debug(\"Docker login for %s\", username)\n",
                "        try:\n",
                "            self.client().login(username, password=password, registry=registry, reauth=True)\n",
                "        except APIError as e:\n",
                "            raise ContainerException() from e"
            ]
        ],
        "tests/unit/test_dockerclient.py": [
            [
                "import json\n",
                "import logging\n",
                "from typing import List\n",
                "from unittest.mock import patch\n",
                "\n",
                "import pytest\n",
                "\n",
                "from localstack import config\n",
                "from localstack.utils.bootstrap import extract_port_flags\n",
                "from localstack.utils.container_utils.container_client import (\n",
                "    DockerContainerStatus,\n",
                "    PortMappings,\n",
                "    Util,\n",
                ")\n",
                "from localstack.utils.container_utils.docker_cmd_client import CmdDockerClient\n",
                "\n",
                "LOG = logging.getLogger(__name__)\n",
                "\n",
                "\n",
                "class TestDockerClient:\n",
                "    def _docker_cmd(self) -> List[str]:\n",
                "        \"\"\"Return the string to be used for running Docker commands.\"\"\"\n",
                "        return config.DOCKER_CMD.split()\n",
                "\n",
                "    @patch(\"localstack.utils.container_utils.docker_cmd_client.run\")\n",
                "    def test_list_containers(self, run_mock):\n",
                "        mock_container = {\n",
                "            \"ID\": \"00000000a1\",\n",
                "            \"Image\": \"localstack/localstack\",\n",
                "            \"Names\": \"localstack_main\",\n",
                "            \"Labels\": \"authors=LocalStack Contributors\",\n",
                "            \"State\": \"running\",\n",
                "        }\n",
                "        return_container = {\n",
                "            \"id\": mock_container[\"ID\"],\n",
                "            \"image\": mock_container[\"Image\"],\n",
                "            \"name\": mock_container[\"Names\"],\n",
                "            \"labels\": mock_container[\"Labels\"],\n",
                "            \"status\": mock_container[\"State\"],\n",
                "        }\n",
                "        run_mock.return_value = json.dumps(mock_container)\n",
                "        docker_client = CmdDockerClient()\n",
                "        container_list = docker_client.list_containers()\n",
                "        call_arguments = run_mock.call_args[0][0]\n",
                "        LOG.info(\"Intercepted call arguments: %s\", call_arguments)\n",
                "        assert container_list[0] == return_container\n",
                "        assert list_in(self._docker_cmd() + [\"ps\"], call_arguments)\n",
                "        assert \"-a\" in call_arguments\n",
                "        assert \"--format\" in call_arguments\n",
                "\n",
                "    @patch(\"localstack.utils.container_utils.docker_cmd_client.run\")\n",
                "    def test_container_status(self, run_mock):\n",
                "        test_output = \"Up 2 minutes - localstack_main\"\n",
                "        run_mock.return_value = test_output\n",
                "        docker_client = CmdDockerClient()\n",
                "        status = docker_client.get_container_status(\"localstack_main\")\n",
                "        assert status == DockerContainerStatus.UP\n",
                "        run_mock.return_value = \"Exited (0) 1 minute ago - localstack_main\"\n",
                "        status = docker_client.get_container_status(\"localstack_main\")\n",
                "        assert status == DockerContainerStatus.DOWN\n",
                "        run_mock.return_value = \"STATUS    NAME\"\n",
                "        status = docker_client.get_container_status(\"localstack_main\")\n",
                "        assert status == DockerContainerStatus.NON_EXISTENT\n",
                "\n",
                "\n",
                "def test_argument_parsing():\n",
                "    test_port_string = \"-p 80:8080/udp\"\n",
                "    test_port_string_with_host = \"-p 127.0.0.1:6000:7000/tcp\"\n",
                "    test_port_string_many_to_one = \"-p 9230-9231:9230\"\n",
                "    test_env_string = \"-e TEST_ENV_VAR=test_string=123\"\n",
                "    test_mount_string = \"-v /var/test:/opt/test\"\n",
                "    test_network_string = \"--network bridge\"\n",
                "    test_user_string = \"-u sbx_user1051\"\n",
                "    test_platform_string = \"--platform linux/arm64\"\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    test_privileged_string = \"--privileged\"\n"
                ],
                "parent_version_range": {
                    "start": 74,
                    "end": 74
                },
                "child_version_range": {
                    "start": 74,
                    "end": 75
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_argument_parsing",
                        "signature": "def test_argument_parsing():",
                        "at_line": 65
                    }
                ],
                "idx": 8,
                "hunk_diff": "File: tests/unit/test_dockerclient.py\nCode:\n         def test_argument_parsing():\n             ...\n71 71        test_network_string = \"--network bridge\"\n72 72        test_user_string = \"-u sbx_user1051\"\n73 73        test_platform_string = \"--platform linux/arm64\"\n   74  +     test_privileged_string = \"--privileged\"\n74 75        argument_string = \" \".join(\n75 76            [\n76 77                test_port_string,\n       ...\n",
                "file_path": "tests/unit/test_dockerclient.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "test_privileged_string"
                ],
                "prefix": [
                    "    test_network_string = \"--network bridge\"\n",
                    "    test_user_string = \"-u sbx_user1051\"\n",
                    "    test_platform_string = \"--platform linux/arm64\"\n"
                ],
                "suffix": [
                    "    argument_string = \" \".join(\n",
                    "        [\n",
                    "            test_port_string,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 9,
                        "detail": {
                            "identifier": "test_privileged_string",
                            "position": {
                                "start": {
                                    "line": 74,
                                    "column": 4
                                },
                                "end": {
                                    "line": 74,
                                    "column": 26
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/tests/unit/test_dockerclient.py",
                            "hunk_idx": 8,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "    argument_string = \" \".join(\n",
                "        [\n",
                "            test_port_string,\n",
                "            test_env_string,\n",
                "            test_mount_string,\n",
                "            test_port_string_with_host,\n",
                "            test_port_string_many_to_one,\n",
                "            test_network_string,\n",
                "            test_user_string,\n",
                "            test_platform_string,\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "            test_privileged_string,\n"
                ],
                "parent_version_range": {
                    "start": 84,
                    "end": 84
                },
                "child_version_range": {
                    "start": 85,
                    "end": 86
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_argument_parsing",
                        "signature": "def test_argument_parsing():",
                        "at_line": 65
                    },
                    {
                        "type": "call",
                        "name": "\" \".join",
                        "signature": "\" \".join(\n        [\n            test_port_string,\n            test_env_string,\n            test_mount_string,\n            test_port_string_with_host,\n            test_port_string_many_to_one,\n            test_network_string,\n            test_user_string,\n            test_platform_string,\n        ]\n    )",
                        "at_line": 74,
                        "argument": "[\n            test_port_string..."
                    }
                ],
                "idx": 9,
                "hunk_diff": "File: tests/unit/test_dockerclient.py\nCode:\n         def test_argument_parsing():\n             ...\n             \" \".join(\n        [\n            test_port_string,\n            test_env_string,\n            test_mount_string,\n            test_port_string_with_host,\n            test_port_string_many_to_one,\n            test_network_string,\n            test_user_string,\n            test_platform_string,\n        ]\n    )\n                 ...\n81 82                test_network_string,\n82 83                test_user_string,\n83 84                test_platform_string,\n   85  +             test_privileged_string,\n84 86            ]\n85 87        )\n86 88        env_vars = {}\n       ...\n",
                "file_path": "tests/unit/test_dockerclient.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "test_privileged_string"
                ],
                "prefix": [
                    "            test_network_string,\n",
                    "            test_user_string,\n",
                    "            test_platform_string,\n"
                ],
                "suffix": [
                    "        ]\n",
                    "    )\n",
                    "    env_vars = {}\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 8,
                        "detail": {
                            "identifier": "test_privileged_string",
                            "position": {
                                "start": {
                                    "line": 85,
                                    "column": 12
                                },
                                "end": {
                                    "line": 85,
                                    "column": 34
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/localstack/tests/unit/test_dockerclient.py",
                            "hunk_idx": 9,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        ]\n",
                "    )\n",
                "    env_vars = {}\n",
                "    ports = PortMappings()\n",
                "    mounts = []\n",
                "    network = \"host\"\n",
                "    user = \"root\"\n",
                "    platform = \"linux/amd64\"\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    privileged = False\n"
                ],
                "parent_version_range": {
                    "start": 92,
                    "end": 92
                },
                "child_version_range": {
                    "start": 94,
                    "end": 95
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_argument_parsing",
                        "signature": "def test_argument_parsing():",
                        "at_line": 65
                    }
                ],
                "idx": 10,
                "hunk_diff": "File: tests/unit/test_dockerclient.py\nCode:\n         def test_argument_parsing():\n             ...\n89 91        network = \"host\"\n90 92        user = \"root\"\n91 93        platform = \"linux/amd64\"\n   94  +     privileged = False\n92 95        flags = Util.parse_additional_flags(\n       ...\n",
                "file_path": "tests/unit/test_dockerclient.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "privileged"
                ],
                "prefix": [
                    "    network = \"host\"\n",
                    "    user = \"root\"\n",
                    "    platform = \"linux/amd64\"\n"
                ],
                "suffix": [
                    "    flags = Util.parse_additional_flags(\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 11,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 94,
                                    "column": 4
                                },
                                "end": {
                                    "line": 94,
                                    "column": 14
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/tests/unit/test_dockerclient.py",
                            "hunk_idx": 10,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "    flags = Util.parse_additional_flags(\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        argument_string, env_vars, ports, mounts, network, user, platform\n"
                ],
                "after": [
                    "        argument_string, env_vars, ports, mounts, network, user, platform, privileged\n"
                ],
                "parent_version_range": {
                    "start": 93,
                    "end": 94
                },
                "child_version_range": {
                    "start": 96,
                    "end": 97
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_argument_parsing",
                        "signature": "def test_argument_parsing():",
                        "at_line": 65
                    },
                    {
                        "type": "call",
                        "name": "Util.parse_additional_flags",
                        "signature": "Util.parse_additional_flags(\n        argument_string, env_vars, ports, mounts, network, user, platform\n    )",
                        "at_line": 92,
                        "argument": "argument_string"
                    }
                ],
                "idx": 11,
                "hunk_diff": "File: tests/unit/test_dockerclient.py\nCode:\n         def test_argument_parsing():\n             ...\n92 95        flags = Util.parse_additional_flags(\n93     -         argument_string, env_vars, ports, mounts, network, user, platform\n   96  +         argument_string, env_vars, ports, mounts, network, user, platform, privileged\n94 97        )\n95 98        assert env_vars == {\"TEST_ENV_VAR\": \"test_string=123\"}\n96 99        assert ports.to_str() == \"-p 80:8080/udp -p 6000:7000 -p 9230-9231:9230\"\n       ...\n",
                "file_path": "tests/unit/test_dockerclient.py",
                "identifiers_before": [
                    "argument_string",
                    "env_vars",
                    "mounts",
                    "network",
                    "platform",
                    "ports",
                    "user"
                ],
                "identifiers_after": [
                    "argument_string",
                    "env_vars",
                    "mounts",
                    "network",
                    "platform",
                    "ports",
                    "privileged",
                    "user"
                ],
                "prefix": [
                    "    flags = Util.parse_additional_flags(\n"
                ],
                "suffix": [
                    "    )\n",
                    "    assert env_vars == {\"TEST_ENV_VAR\": \"test_string=123\"}\n",
                    "    assert ports.to_str() == \"-p 80:8080/udp -p 6000:7000 -p 9230-9231:9230\"\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 10,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 96,
                                    "column": 75
                                },
                                "end": {
                                    "line": 96,
                                    "column": 85
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/localstack/tests/unit/test_dockerclient.py",
                            "hunk_idx": 11,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    )\n",
                "    assert env_vars == {\"TEST_ENV_VAR\": \"test_string=123\"}\n",
                "    assert ports.to_str() == \"-p 80:8080/udp -p 6000:7000 -p 9230-9231:9230\"\n",
                "    assert mounts == [(\"/var/test\", \"/opt/test\")]\n",
                "    assert flags.network == \"bridge\"\n",
                "    assert flags.user == \"sbx_user1051\"\n",
                "    assert flags.platform == \"linux/arm64\"\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    assert flags.privileged\n"
                ],
                "parent_version_range": {
                    "start": 101,
                    "end": 101
                },
                "child_version_range": {
                    "start": 104,
                    "end": 105
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_argument_parsing",
                        "signature": "def test_argument_parsing():",
                        "at_line": 65
                    }
                ],
                "idx": 12,
                "hunk_diff": "File: tests/unit/test_dockerclient.py\nCode:\n           def test_argument_parsing():\n               ...\n 98 101        assert flags.network == \"bridge\"\n 99 102        assert flags.user == \"sbx_user1051\"\n100 103        assert flags.platform == \"linux/arm64\"\n    104  +     assert flags.privileged\n101 105    \n102 106        argument_string = (\n103 107            \"--add-host host.docker.internal:host-gateway --add-host arbitrary.host:127.0.0.1\"\n         ...\n",
                "file_path": "tests/unit/test_dockerclient.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "flags",
                    "privileged"
                ],
                "prefix": [
                    "    assert flags.network == \"bridge\"\n",
                    "    assert flags.user == \"sbx_user1051\"\n",
                    "    assert flags.platform == \"linux/arm64\"\n"
                ],
                "suffix": [
                    "\n",
                    "    argument_string = (\n",
                    "        \"--add-host host.docker.internal:host-gateway --add-host arbitrary.host:127.0.0.1\"\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 104,
                                    "column": 17
                                },
                                "end": {
                                    "line": 104,
                                    "column": 27
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/localstack/tests/unit/test_dockerclient.py",
                            "hunk_idx": 12,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "    argument_string = (\n",
                "        \"--add-host host.docker.internal:host-gateway --add-host arbitrary.host:127.0.0.1\"\n",
                "    )\n",
                "    flags = Util.parse_additional_flags(argument_string, env_vars, ports, mounts)\n",
                "    assert {\n",
                "        \"host.docker.internal\": \"host-gateway\",\n",
                "        \"arbitrary.host\": \"127.0.0.1\",\n",
                "    } == flags.extra_hosts\n",
                "\n",
                "    with pytest.raises(NotImplementedError):\n",
                "        argument_string = \"--somerandomargument\"\n",
                "        Util.parse_additional_flags(argument_string, env_vars, ports, mounts)\n",
                "    with pytest.raises(ValueError):\n",
                "        argument_string = \"--publish 80:80:80:80\"\n",
                "        Util.parse_additional_flags(argument_string, env_vars, ports, mounts)\n",
                "\n",
                "    # Test windows paths\n",
                "    argument_string = r'-v \"C:\\Users\\SomeUser\\SomePath:/var/task\"'\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.mounts == [(r\"C:\\Users\\SomeUser\\SomePath\", \"/var/task\")]\n",
                "    argument_string = r'-v \"C:\\Users\\SomeUser\\SomePath:/var/task:ro\"'\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.mounts == [(r\"C:\\Users\\SomeUser\\SomePath\", \"/var/task\")]\n",
                "    argument_string = r'-v \"C:\\Users\\Some User\\Some Path:/var/task:ro\"'\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.mounts == [(r\"C:\\Users\\Some User\\Some Path\", \"/var/task\")]\n",
                "    argument_string = r'-v \"/var/test:/var/task:ro\"'\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.mounts == [(\"/var/test\", \"/var/task\")]\n",
                "\n",
                "    # Test file paths\n",
                "    argument_string = r'-v \"/tmp/test.jar:/tmp/foo bar/test.jar\"'\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.mounts == [(r\"/tmp/test.jar\", \"/tmp/foo bar/test.jar\")]\n",
                "    argument_string = r'-v \"/tmp/test-foo_bar.jar:/tmp/test-foo_bar2.jar\"'\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.mounts == [(r\"/tmp/test-foo_bar.jar\", \"/tmp/test-foo_bar2.jar\")]\n",
                "\n",
                "    # Test file paths\n",
                "    argument_string = r'-v \"/tmp/test.jar:/tmp/foo bar/test.jar\" --network mynet123'\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.network == \"mynet123\"\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    # Test privileged flag\n",
                    "    assert not flags.privileged\n",
                    "    argument_string = r\"--privileged\"\n",
                    "    flags = Util.parse_additional_flags(argument_string)\n",
                    "    assert flags.privileged\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 145,
                    "end": 145
                },
                "child_version_range": {
                    "start": 149,
                    "end": 155
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_argument_parsing",
                        "signature": "def test_argument_parsing():",
                        "at_line": 65
                    }
                ],
                "idx": 13,
                "hunk_diff": "File: tests/unit/test_dockerclient.py\nCode:\n           def test_argument_parsing():\n               ...\n142 146        flags = Util.parse_additional_flags(argument_string)\n143 147        assert flags.network == \"mynet123\"\n144 148    \n    149  +     # Test privileged flag\n    150  +     assert not flags.privileged\n    151  +     argument_string = r\"--privileged\"\n    152  +     flags = Util.parse_additional_flags(argument_string)\n    153  +     assert flags.privileged\n    154  + \n145 155        # Test labels\n146 156        argument_string = r\"--label foo=bar.123\"\n147 157        flags = Util.parse_additional_flags(argument_string)\n         ...\n",
                "file_path": "tests/unit/test_dockerclient.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Util",
                    "argument_string",
                    "flags",
                    "parse_additional_flags",
                    "privileged"
                ],
                "prefix": [
                    "    flags = Util.parse_additional_flags(argument_string)\n",
                    "    assert flags.network == \"mynet123\"\n",
                    "\n"
                ],
                "suffix": [
                    "    # Test labels\n",
                    "    argument_string = r\"--label foo=bar.123\"\n",
                    "    flags = Util.parse_additional_flags(argument_string)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 150,
                                    "column": 21
                                },
                                "end": {
                                    "line": 150,
                                    "column": 31
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/localstack/tests/unit/test_dockerclient.py",
                            "hunk_idx": 13,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "privileged",
                            "position": {
                                "start": {
                                    "line": 153,
                                    "column": 17
                                },
                                "end": {
                                    "line": 153,
                                    "column": 27
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/localstack/tests/unit/test_dockerclient.py",
                            "hunk_idx": 13,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    # Test labels\n",
                "    argument_string = r\"--label foo=bar.123\"\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.labels == {\"foo\": \"bar.123\"}\n",
                "    argument_string = r'--label foo=\"bar 123\"'  # test with whitespaces\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.labels == {\"foo\": \"bar 123\"}\n",
                "    argument_string = r'--label foo1=\"bar\" --label foo2=\"baz\"'  # test with multiple labels\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.labels == {\"foo1\": \"bar\", \"foo2\": \"baz\"}\n",
                "    argument_string = r\"--label foo=bar=baz\"  # assert label values that contain equal signs\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.labels == {\"foo\": \"bar=baz\"}\n",
                "    argument_string = r'--label \"\"'  # assert that we gracefully handle invalid labels\n",
                "    flags = Util.parse_additional_flags(argument_string)\n",
                "    assert flags.labels == {}\n",
                "\n",
                "\n",
                "def list_in(a, b):\n",
                "    return len(a) <= len(b) and any(\n",
                "        map(lambda x: b[x : x + len(a)] == a, range(len(b) - len(a) + 1))\n",
                "    )\n",
                "\n",
                "\n",
                "class TestPortMappings:\n",
                "    def test_extract_port_flags(self):\n",
                "        port_mappings = PortMappings()\n",
                "        flags = extract_port_flags(\"foo -p 1234:1234 bar\", port_mappings=port_mappings)\n",
                "        assert flags == \"foo  bar\"\n",
                "        mapping_str = port_mappings.to_str()\n",
                "        assert mapping_str == \"-p 1234:1234\"\n",
                "\n",
                "        port_mappings = PortMappings()\n",
                "        flags = extract_port_flags(\n",
                "            \"foo -p 1234:1234 bar -p 80-90:81-91 baz\", port_mappings=port_mappings\n",
                "        )\n",
                "        assert flags == \"foo  bar  baz\"\n",
                "        mapping_str = port_mappings.to_str()\n",
                "        assert \"-p 1234:1234\" in mapping_str\n",
                "        assert \"-p 80-90:81-91\" in mapping_str\n",
                "\n",
                "    def test_overlapping_port_ranges(self):\n",
                "        port_mappings = PortMappings()\n",
                "        port_mappings.add(4590)\n",
                "        port_mappings.add(4591)\n",
                "        port_mappings.add(4593)\n",
                "        port_mappings.add(4592)\n",
                "        port_mappings.add(4593)\n",
                "        result = port_mappings.to_str()\n",
                "        # assert that ranges are non-overlapping, i.e., no duplicate ports\n",
                "        assert \"-p 4593:4593\" in result\n",
                "        assert \"-p 4590-4592:4590-4592\" in result\n",
                "\n",
                "    def test_port_ranges_with_bind_host(self):\n",
                "        port_mappings = PortMappings(bind_host=\"0.0.0.0\")\n",
                "        port_mappings.add(5000)\n",
                "        port_mappings.add(5001)\n",
                "        port_mappings.add(5003)\n",
                "        port_mappings.add([5004, 5006], 9000)\n",
                "        result = port_mappings.to_str()\n",
                "        assert (\n",
                "            result\n",
                "            == \"-p 0.0.0.0:5000-5001:5000-5001 -p 0.0.0.0:5003:5003 -p 0.0.0.0:5004-5006:9000\"\n",
                "        )\n",
                "\n",
                "    def test_port_ranges_with_bind_host_to_dict(self):\n",
                "        port_mappings = PortMappings(bind_host=\"0.0.0.0\")\n",
                "        port_mappings.add(5000, 6000)\n",
                "        port_mappings.add(5001, 7000)\n",
                "        port_mappings.add(5003, 8000)\n",
                "        port_mappings.add([5004, 5006], 9000)\n",
                "        result = port_mappings.to_dict()\n",
                "        expected_result = {\n",
                "            \"6000/tcp\": (\"0.0.0.0\", 5000),\n",
                "            \"7000/tcp\": (\"0.0.0.0\", 5001),\n",
                "            \"8000/tcp\": (\"0.0.0.0\", 5003),\n",
                "            \"9000/tcp\": (\"0.0.0.0\", [5004, 5005, 5006]),\n",
                "        }\n",
                "        assert result == expected_result\n",
                "\n",
                "    def test_many_to_one_adjacent_to_uniform(self):\n",
                "        port_mappings = PortMappings()\n",
                "        port_mappings.add(5002)\n",
                "        port_mappings.add(5003)\n",
                "        port_mappings.add([5004, 5006], 5004)\n",
                "        expected_result = {\n",
                "            \"5002/tcp\": 5002,\n",
                "            \"5003/tcp\": 5003,\n",
                "            \"5004/tcp\": [5004, 5005, 5006],\n",
                "        }\n",
                "        result = port_mappings.to_dict()\n",
                "        assert result == expected_result\n",
                "\n",
                "    def test_adjacent_port_to_many_to_one(self):\n",
                "        port_mappings = PortMappings()\n",
                "        port_mappings.add([7000, 7002], 7000)\n",
                "        port_mappings.add(6999)\n",
                "        expected_result = {\n",
                "            \"6999/tcp\": 6999,\n",
                "            \"7000/tcp\": [7000, 7001, 7002],\n",
                "        }\n",
                "        result = port_mappings.to_dict()\n",
                "        assert result == expected_result"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "no relation",
            "reason": "Edit 0 adds param `privileged` to `DockerRunFlags`, while Edit 1 adds the same name param at `class Util: def parse_additional_flags(xx)`"
        },
        {
            "edit_hunk_pair": [
                0,
                2
            ],
            "edit_order": "no relation",
            "reason": "Edit 0 adds param `privileged` to `DockerRunFlags`, while Edit 1 adds the same name param comment at `class Util: def parse_additional_flags(xx)`"
        },
        {
            "edit_hunk_pair": [
                0,
                3
            ],
            "edit_order": "no relation",
            "reason": "Edit 0 at class `DockerRunFlags`, Edit 1 at class `Util: def parse_additional_flags(xx)`"
        },
        {
            "edit_hunk_pair": [
                0,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use (direct call)"
        },
        {
            "edit_hunk_pair": [
                0,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "def and use(dependency found by LSP)"
        },
        {
            "edit_hunk_pair": [
                0,
                11
            ],
            "edit_order": "no relation",
            "reason": "Edit 11 call `parse_additional_flags`, which further initialized an object from class `DockerRunFlags`, which is related to Edit 0. Multiple hop, hence no relation"
        },
        {
            "edit_hunk_pair": [
                0,
                12
            ],
            "edit_order": "bi-directional",
            "reason": "direct dependency by LSP"
        },
        {
            "edit_hunk_pair": [
                0,
                13
            ],
            "edit_order": "bi-directional",
            "reason": "direct dependency by LSP"
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "def and doc sync"
        },
        {
            "edit_hunk_pair": [
                1,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                1,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                1,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                1,
                11
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                1,
                13
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "implement and comment"
        },
        {
            "edit_hunk_pair": [
                2,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "implement and comment"
        },
        {
            "edit_hunk_pair": [
                3,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                3,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "implement and call"
        },
        {
            "edit_hunk_pair": [
                5,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "implement and call of privileged"
        },
        {
            "edit_hunk_pair": [
                5,
                11
            ],
            "edit_order": "bi-directional",
            "reason": "implement and call of privileged"
        },
        {
            "edit_hunk_pair": [
                6,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                8,
                9
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                9,
                11
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                10,
                11
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                11,
                12
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        }
    ]
}