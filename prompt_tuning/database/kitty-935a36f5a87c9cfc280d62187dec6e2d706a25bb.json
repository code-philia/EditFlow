{
    "language": "python",
    "commit_url": "https://github.com/kovidgoyal/kitty/commit/935a36f5a87c9cfc280d62187dec6e2d706a25bb",
    "commit_message": "Allow specifying VCS revision on the build command line",
    "commit_snapshots": {
        "glfw/glfw.py": [
            [
                "#!/usr/bin/env python3\n",
                "# vim:fileencoding=utf-8\n",
                "# License: GPL v3 Copyright: 2017, Kovid Goyal <kovid at kovidgoyal.net>\n",
                "\n",
                "import json\n",
                "import os\n",
                "import re\n",
                "import sys\n",
                "from typing import Callable, Dict, List, NamedTuple, Optional, Sequence, Tuple\n",
                "\n",
                "_plat = sys.platform.lower()\n",
                "is_linux = 'linux' in _plat\n",
                "is_openbsd = 'openbsd' in _plat\n",
                "base = os.path.dirname(os.path.abspath(__file__))\n",
                "\n",
                "\n",
                "def null_func() -> None:\n",
                "    return None\n",
                "\n",
                "\n",
                "class CompileKey(NamedTuple):\n",
                "    src: str\n",
                "    dest: str\n",
                "\n",
                "\n",
                "class Command(NamedTuple):\n",
                "    desc: str\n",
                "    cmd: Sequence[str]\n",
                "    is_newer_func: Callable[[], bool]\n",
                "    on_success: Callable[[], None] = null_func\n",
                "    key: Optional[CompileKey] = None\n",
                "    keyfile: Optional[str] = None\n",
                "\n",
                "\n",
                "class Env:\n",
                "\n",
                "    cc: List[str] = []\n",
                "    cppflags: List[str] = []\n",
                "    cflags: List[str] = []\n",
                "    ldflags: List[str] = []\n",
                "    library_paths: Dict[str, List[str]] = {}\n",
                "    ldpaths: List[str] = []\n",
                "    ccver: Tuple[int, int]\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    vcs_rev: str = ''\n"
                ],
                "parent_version_range": {
                    "start": 43,
                    "end": 43
                },
                "child_version_range": {
                    "start": 43,
                    "end": 44
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Env",
                        "signature": "class Env:",
                        "at_line": 34
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: glfw/glfw.py\nCode:\n         class Env:\n             ...\n40 40        library_paths: Dict[str, List[str]] = {}\n41 41        ldpaths: List[str] = []\n42 42        ccver: Tuple[int, int]\n   43  +     vcs_rev: str = ''\n43 44    \n44 45        # glfw stuff\n45 46        all_headers: List[str] = []\n       ...\n",
                "file_path": "glfw/glfw.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "str",
                    "vcs_rev"
                ],
                "prefix": [
                    "    library_paths: Dict[str, List[str]] = {}\n",
                    "    ldpaths: List[str] = []\n",
                    "    ccver: Tuple[int, int]\n"
                ],
                "suffix": [
                    "\n",
                    "    # glfw stuff\n",
                    "    all_headers: List[str] = []\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 43,
                                    "column": 4
                                },
                                "end": {
                                    "line": 43,
                                    "column": 11
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 43,
                                    "column": 4
                                },
                                "end": {
                                    "line": 43,
                                    "column": 11
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 43,
                                    "column": 4
                                },
                                "end": {
                                    "line": 43,
                                    "column": 11
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 43,
                                    "column": 4
                                },
                                "end": {
                                    "line": 43,
                                    "column": 11
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "\n",
                "    # glfw stuff\n",
                "    all_headers: List[str] = []\n",
                "    sources: List[str] = []\n",
                "    wayland_packagedir: str = ''\n",
                "    wayland_scanner: str = ''\n",
                "    wayland_scanner_code: str = ''\n",
                "    wayland_protocols: Tuple[str, ...] = ()\n",
                "\n",
                "    def __init__(\n",
                "        self, cc: List[str] = [], cppflags: List[str] = [], cflags: List[str] = [], ldflags: List[str] = [],\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        library_paths: Dict[str, List[str]] = {}, ldpaths: Optional[List[str]] = None, ccver: Tuple[int, int] = (0, 0)\n"
                ],
                "after": [
                    "        library_paths: Dict[str, List[str]] = {}, ldpaths: Optional[List[str]] = None, ccver: Tuple[int, int] = (0, 0),\n",
                    "        vcs_rev: str = ''\n"
                ],
                "parent_version_range": {
                    "start": 54,
                    "end": 55
                },
                "child_version_range": {
                    "start": 55,
                    "end": 57
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Env",
                        "signature": "class Env:",
                        "at_line": 34
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(\n        self, cc: List[str] = [], cppflags: List[str] = [], cflags: List[str] = [], ldflags: List[str] = [],\n        library_paths: Dict[str, List[str]] = {}, ldpaths: Optional[List[str]] = None, ccver: Tuple[int, int] = (0, 0)\n    ):",
                        "at_line": 52
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: glfw/glfw.py\nCode:\n         class Env:\n             ...\n51 52    \n52 53        def __init__(\n53 54            self, cc: List[str] = [], cppflags: List[str] = [], cflags: List[str] = [], ldflags: List[str] = [],\n54     -         library_paths: Dict[str, List[str]] = {}, ldpaths: Optional[List[str]] = None, ccver: Tuple[int, int] = (0, 0)\n   55  +         library_paths: Dict[str, List[str]] = {}, ldpaths: Optional[List[str]] = None, ccver: Tuple[int, int] = (0, 0),\n   56  +         vcs_rev: str = ''\n55 57        ):\n56 58            self.cc, self.cppflags, self.cflags, self.ldflags, self.library_paths = cc, cppflags, cflags, ldflags, library_paths\n57 59            self.ldpaths = ldpaths or []\n       ...\n",
                "file_path": "glfw/glfw.py",
                "identifiers_before": [
                    "Dict",
                    "List",
                    "Optional",
                    "Tuple",
                    "ccver",
                    "int",
                    "ldpaths",
                    "library_paths",
                    "str"
                ],
                "identifiers_after": [
                    "Dict",
                    "List",
                    "Optional",
                    "Tuple",
                    "ccver",
                    "int",
                    "ldpaths",
                    "library_paths",
                    "str",
                    "vcs_rev"
                ],
                "prefix": [
                    "\n",
                    "    def __init__(\n",
                    "        self, cc: List[str] = [], cppflags: List[str] = [], cflags: List[str] = [], ldflags: List[str] = [],\n"
                ],
                "suffix": [
                    "    ):\n",
                    "        self.cc, self.cppflags, self.cflags, self.ldflags, self.library_paths = cc, cppflags, cflags, ldflags, library_paths\n",
                    "        self.ldpaths = ldpaths or []\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "ldpaths",
                            "position": {
                                "start": {
                                    "line": 54,
                                    "column": 50
                                },
                                "end": {
                                    "line": 54,
                                    "column": 57
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "ccver",
                            "position": {
                                "start": {
                                    "line": 54,
                                    "column": 87
                                },
                                "end": {
                                    "line": 54,
                                    "column": 92
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "ldpaths",
                            "position": {
                                "start": {
                                    "line": 55,
                                    "column": 50
                                },
                                "end": {
                                    "line": 55,
                                    "column": 57
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "ccver",
                            "position": {
                                "start": {
                                    "line": 55,
                                    "column": 87
                                },
                                "end": {
                                    "line": 55,
                                    "column": 92
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 56,
                                    "column": 8
                                },
                                "end": {
                                    "line": 56,
                                    "column": 15
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 56,
                                    "column": 8
                                },
                                "end": {
                                    "line": 56,
                                    "column": 15
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "    ):\n",
                "        self.cc, self.cppflags, self.cflags, self.ldflags, self.library_paths = cc, cppflags, cflags, ldflags, library_paths\n",
                "        self.ldpaths = ldpaths or []\n",
                "        self.ccver = ccver\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        self.vcs_rev = vcs_rev\n"
                ],
                "parent_version_range": {
                    "start": 59,
                    "end": 59
                },
                "child_version_range": {
                    "start": 61,
                    "end": 62
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Env",
                        "signature": "class Env:",
                        "at_line": 34
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(\n        self, cc: List[str] = [], cppflags: List[str] = [], cflags: List[str] = [], ldflags: List[str] = [],\n        library_paths: Dict[str, List[str]] = {}, ldpaths: Optional[List[str]] = None, ccver: Tuple[int, int] = (0, 0)\n    ):",
                        "at_line": 52
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: glfw/glfw.py\nCode:\n         class Env:\n             ...\n             def __init__(\n        self, cc: List[str] = [], cppflags: List[str] = [], cflags: List[str] = [], ldflags: List[str] = [],\n        library_paths: Dict[str, List[str]] = {}, ldpaths: Optional[List[str]] = None, ccver: Tuple[int, int] = (0, 0)\n    ):\n                 ...\n56 58            self.cc, self.cppflags, self.cflags, self.ldflags, self.library_paths = cc, cppflags, cflags, ldflags, library_paths\n57 59            self.ldpaths = ldpaths or []\n58 60            self.ccver = ccver\n   61  +         self.vcs_rev = vcs_rev\n59 62    \n60 63        def copy(self) -> 'Env':\n61 64            ans = Env(self.cc, list(self.cppflags), list(self.cflags), list(self.ldflags), dict(self.library_paths), list(self.ldpaths), self.ccver)\n       ...\n",
                "file_path": "glfw/glfw.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "self",
                    "vcs_rev"
                ],
                "prefix": [
                    "        self.cc, self.cppflags, self.cflags, self.ldflags, self.library_paths = cc, cppflags, cflags, ldflags, library_paths\n",
                    "        self.ldpaths = ldpaths or []\n",
                    "        self.ccver = ccver\n"
                ],
                "suffix": [
                    "\n",
                    "    def copy(self) -> 'Env':\n",
                    "        ans = Env(self.cc, list(self.cppflags), list(self.cflags), list(self.ldflags), dict(self.library_paths), list(self.ldpaths), self.ccver)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 61,
                                    "column": 23
                                },
                                "end": {
                                    "line": 61,
                                    "column": 30
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 61,
                                    "column": 13
                                },
                                "end": {
                                    "line": 61,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/glfw/glfw.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "    def copy(self) -> 'Env':\n",
                "        ans = Env(self.cc, list(self.cppflags), list(self.cflags), list(self.ldflags), dict(self.library_paths), list(self.ldpaths), self.ccver)\n",
                "        ans.all_headers = list(self.all_headers)\n",
                "        ans.sources = list(self.sources)\n",
                "        ans.wayland_packagedir = self.wayland_packagedir\n",
                "        ans.wayland_scanner = self.wayland_scanner\n",
                "        ans.wayland_scanner_code = self.wayland_scanner_code\n",
                "        ans.wayland_protocols = self.wayland_protocols\n",
                "        return ans\n",
                "\n",
                "\n",
                "def wayland_protocol_file_name(base: str, ext: str = 'c') -> str:\n",
                "    base = os.path.basename(base).rpartition('.')[0]\n",
                "    return f'wayland-{base}-client-protocol.{ext}'\n",
                "\n",
                "\n",
                "def init_env(\n",
                "    env: Env,\n",
                "    pkg_config: Callable[..., List[str]],\n",
                "    pkg_version: Callable[[str], Tuple[int, int]],\n",
                "    at_least_version: Callable[..., None],\n",
                "    test_compile: Callable[..., bool],\n",
                "    module: str = 'x11'\n",
                ") -> Env:\n",
                "    ans = env.copy()\n",
                "    ans.cflags.append('-fPIC')\n",
                "    ans.cppflags.append(f'-D_GLFW_{module.upper()}')\n",
                "    ans.cppflags.append('-D_GLFW_BUILD_DLL')\n",
                "\n",
                "    with open(os.path.join(base, 'source-info.json')) as f:\n",
                "        sinfo = json.load(f)\n",
                "    module_sources = list(sinfo[module]['sources'])\n",
                "    if module in ('x11', 'wayland'):\n",
                "        remove = 'null_joystick.c' if is_linux else 'linux_joystick.c'\n",
                "        module_sources.remove(remove)\n",
                "\n",
                "    ans.sources = sinfo['common']['sources'] + module_sources\n",
                "    ans.all_headers = [x for x in os.listdir(base) if x.endswith('.h')]\n",
                "\n",
                "    if module in ('x11', 'wayland'):\n",
                "        ans.cflags.append('-pthread')\n",
                "        ans.ldpaths.extend('-pthread -lm'.split())\n",
                "        if not is_openbsd:\n",
                "            ans.ldpaths.extend('-lrt -ldl'.split())\n",
                "        major, minor = pkg_version('xkbcommon')\n",
                "        if (major, minor) < (0, 5):\n",
                "            raise SystemExit('libxkbcommon >= 0.5 required')\n",
                "        if major < 1:\n",
                "            ans.cflags.append('-DXKB_HAS_NO_UTF32')\n",
                "\n",
                "    if module == 'x11':\n",
                "        for dep in 'x11 xrandr xinerama xcursor xkbcommon xkbcommon-x11 x11-xcb dbus-1'.split():\n",
                "            ans.cflags.extend(pkg_config(dep, '--cflags-only-I'))\n",
                "            ans.ldpaths.extend(pkg_config(dep, '--libs'))\n",
                "\n",
                "    elif module == 'cocoa':\n",
                "        ans.cppflags.append('-DGL_SILENCE_DEPRECATION')\n",
                "        for f_ in 'Cocoa IOKit CoreFoundation CoreVideo UniformTypeIdentifiers'.split():\n",
                "            ans.ldpaths.extend(('-framework', f_))\n",
                "\n",
                "    elif module == 'wayland':\n",
                "        at_least_version('wayland-protocols', *sinfo['wayland_protocols'])\n",
                "        ans.wayland_packagedir = os.path.abspath(pkg_config('wayland-protocols', '--variable=pkgdatadir')[0])\n",
                "        ans.wayland_scanner = os.path.abspath(pkg_config('wayland-scanner', '--variable=wayland_scanner')[0])\n",
                "        scanner_version = tuple(map(int, pkg_config('wayland-scanner', '--modversion')[0].strip().split('.')))\n",
                "        ans.wayland_scanner_code = 'private-code' if scanner_version >= (1, 14, 91) else 'code'\n",
                "        ans.wayland_protocols = tuple(sinfo[module]['protocols'])\n",
                "        for p in ans.wayland_protocols:\n",
                "            ans.sources.append(wayland_protocol_file_name(p))\n",
                "            ans.all_headers.append(wayland_protocol_file_name(p, 'h'))\n",
                "        for dep in 'wayland-client wayland-cursor xkbcommon dbus-1'.split():\n",
                "            ans.cflags.extend(pkg_config(dep, '--cflags-only-I'))\n",
                "            ans.ldpaths.extend(pkg_config(dep, '--libs'))\n",
                "        has_memfd_create = test_compile(env.cc, '-Werror', src='''#define _GNU_SOURCE\n",
                "    #include <unistd.h>\n",
                "    #include <sys/syscall.h>\n",
                "    int main(void) {\n",
                "        return syscall(__NR_memfd_create, \"test\", 0);\n",
                "    }''')\n",
                "        if has_memfd_create:\n",
                "            ans.cppflags.append('-DHAS_MEMFD_CREATE')\n",
                "\n",
                "    return ans\n",
                "\n",
                "\n",
                "def build_wayland_protocols(\n",
                "    env: Env,\n",
                "    parallel_run: Callable[[List[Command]], None],\n",
                "    emphasis: Callable[[str], str],\n",
                "    newer: Callable[..., bool],\n",
                "    dest_dir: str\n",
                ") -> None:\n",
                "    items = []\n",
                "    for protocol in env.wayland_protocols:\n",
                "        src = os.path.join(env.wayland_packagedir, protocol)\n",
                "        if not os.path.exists(src):\n",
                "            raise SystemExit(f'The wayland-protocols package on your system is missing the {protocol} protocol definition file')\n",
                "        for ext in 'hc':\n",
                "            dest = wayland_protocol_file_name(src, ext)\n",
                "            dest = os.path.join(dest_dir, dest)\n",
                "            if newer(dest, src):\n",
                "                q = 'client-header' if ext == 'h' else env.wayland_scanner_code\n",
                "                items.append(Command(\n",
                "                    f'Generating {emphasis(os.path.basename(dest))} ...',\n",
                "                    [env.wayland_scanner, q, src, dest], lambda: True))\n",
                "    if items:\n",
                "        parallel_run(items)\n",
                "\n",
                "\n",
                "class Arg:\n",
                "\n",
                "    def __init__(self, decl: str):\n",
                "        self.type, self.name = decl.rsplit(' ', 1)\n",
                "        self.type = self.type.strip()\n",
                "        self.name = self.name.strip()\n",
                "        while self.name.startswith('*'):\n",
                "            self.name = self.name[1:]\n",
                "            self.type = self.type + '*'\n",
                "        if '[' in self.name:\n",
                "            self.type += '[' + self.name.partition('[')[-1]\n",
                "\n",
                "    def __repr__(self) -> str:\n",
                "        return f'Arg({self.type}, {self.name})'\n",
                "\n",
                "\n",
                "class Function:\n",
                "\n",
                "    def __init__(self, declaration: str, check_fail: bool = True):\n",
                "        self.check_fail = check_fail\n",
                "        m = re.match(\n",
                "            r'(.+?)\\s+(glfw[A-Z][a-zA-Z0-9]+)[(](.+)[)]$', declaration\n",
                "        )\n",
                "        if m is None:\n",
                "            raise SystemExit('Failed to parse ' + repr(declaration))\n",
                "        self.restype = m.group(1).strip()\n",
                "        self.name = m.group(2)\n",
                "        args = m.group(3).strip().split(',')\n",
                "        args = [x.strip() for x in args]\n",
                "        self.args = []\n",
                "        for a in args:\n",
                "            if a == 'void':\n",
                "                continue\n",
                "            self.args.append(Arg(a))\n",
                "        if not self.args:\n",
                "            self.args = [Arg('void v')]\n",
                "\n",
                "    def declaration(self) -> str:\n",
                "        return 'typedef {restype} (*{name}_func)({args});\\nGFW_EXTERN {name}_func {name}_impl;\\n#define {name} {name}_impl'.format(\n",
                "            restype=self.restype,\n",
                "            name=self.name,\n",
                "            args=', '.join(a.type for a in self.args)\n",
                "        )\n",
                "\n",
                "    def load(self) -> str:\n",
                "        ans = f'*(void **) (&{self.name}_impl) = dlsym(handle, \"{self.name}\");'\n",
                "        ans += f'\\n    if ({self.name}_impl == NULL) '\n",
                "        if self.check_fail:\n",
                "            ans += f'fail(\"Failed to load glfw function {self.name} with error: %s\", dlerror());'\n",
                "        else:\n",
                "            ans += 'dlerror(); // clear error indicator'\n",
                "        return ans\n",
                "\n",
                "\n",
                "def generate_wrappers(glfw_header: str) -> None:\n",
                "    with open(glfw_header) as f:\n",
                "        src = f.read()\n",
                "    functions = []\n",
                "    first = None\n",
                "    for m in re.finditer(r'^GLFWAPI\\s+(.+[)]);\\s*$', src, flags=re.MULTILINE):\n",
                "        if first is None:\n",
                "            first = m.start()\n",
                "        decl = m.group(1)\n",
                "        if 'VkInstance' in decl:\n",
                "            continue\n",
                "        functions.append(Function(decl))\n",
                "    for line in '''\\\n",
                "    void* glfwGetCocoaWindow(GLFWwindow* window)\n",
                "    void glfwHideCocoaTitlebar(GLFWwindow* window, bool yes)\n",
                "    void* glfwGetNSGLContext(GLFWwindow *window)\n",
                "    uint32_t glfwGetCocoaMonitor(GLFWmonitor* monitor)\n",
                "    GLFWcocoatextinputfilterfun glfwSetCocoaTextInputFilter(GLFWwindow* window, GLFWcocoatextinputfilterfun callback)\n",
                "    GLFWhandleurlopen glfwSetCocoaURLOpenCallback(GLFWhandleurlopen callback)\n",
                "    GLFWcocoatogglefullscreenfun glfwSetCocoaToggleFullscreenIntercept(GLFWwindow *window, GLFWcocoatogglefullscreenfun callback)\n",
                "    GLFWapplicationshouldhandlereopenfun glfwSetApplicationShouldHandleReopen(GLFWapplicationshouldhandlereopenfun callback)\n",
                "    GLFWapplicationwillfinishlaunchingfun glfwSetApplicationWillFinishLaunching(GLFWapplicationwillfinishlaunchingfun callback)\n",
                "    uint32_t glfwGetCocoaKeyEquivalent(uint32_t glfw_key, int glfw_mods, int* cocoa_mods)\n",
                "    void glfwCocoaRequestRenderFrame(GLFWwindow *w, GLFWcocoarenderframefun callback)\n",
                "    void* glfwGetX11Display(void)\n",
                "    int32_t glfwGetX11Window(GLFWwindow* window)\n",
                "    void glfwSetPrimarySelectionString(GLFWwindow* window, const char* string)\n",
                "    const char* glfwGetPrimarySelectionString(GLFWwindow* window, void)\n",
                "    int glfwGetNativeKeyForName(const char* key_name, int case_sensitive)\n",
                "    void glfwRequestWaylandFrameEvent(GLFWwindow *handle, unsigned long long id, GLFWwaylandframecallbackfunc callback)\n",
                "    void glfwWaylandActivateWindow(GLFWwindow *handle, const char *activation_token)\n",
                "    void glfwWaylandRunWithActivationToken(GLFWwindow *handle, GLFWactivationcallback cb, void *cb_data)\n",
                "    bool glfwWaylandSetTitlebarColor(GLFWwindow *handle, uint32_t color, bool use_system_color)\n",
                "    unsigned long long glfwDBusUserNotify(const char *app_name, const char* icon, const char *summary, const char *body, \\\n",
                "const char *action_text, int32_t timeout, GLFWDBusnotificationcreatedfun callback, void *data)\n",
                "    void glfwDBusSetUserNotificationHandler(GLFWDBusnotificationactivatedfun handler)\n",
                "    int glfwSetX11LaunchCommand(GLFWwindow *handle, char **argv, int argc)\n",
                "    void glfwSetX11WindowAsDock(int32_t x11_window_id)\n",
                "    void glfwSetX11WindowStrut(int32_t x11_window_id, uint32_t dimensions[12])\n",
                "'''.splitlines():\n",
                "        if line:\n",
                "            functions.append(Function(line.strip(), check_fail=False))\n",
                "\n",
                "    declarations = [f.declaration() for f in functions]\n",
                "    p = src.find(' * GLFW API tokens')\n",
                "    p = src.find('*/', p)\n",
                "    preamble = src[p + 2:first]\n",
                "    header = '''\\\n",
                "//\n",
                "// THIS FILE IS GENERATED BY glfw.py\n",
                "//\n",
                "// SAVE YOURSELF SOME TIME, DO NOT MANUALLY EDIT\n",
                "//\n",
                "\n",
                "#pragma once\n",
                "#include <stddef.h>\n",
                "#include <stdint.h>\n",
                "#include \"monotonic.h\"\n",
                "\n",
                "#ifndef GFW_EXTERN\n",
                "#define GFW_EXTERN extern\n",
                "#endif\n",
                "{}\n",
                "\n",
                "typedef int (* GLFWcocoatextinputfilterfun)(int,int,unsigned int,unsigned long);\n",
                "typedef bool (* GLFWapplicationshouldhandlereopenfun)(int);\n",
                "typedef bool (* GLFWhandleurlopen)(const char*);\n",
                "typedef void (* GLFWapplicationwillfinishlaunchingfun)(void);\n",
                "typedef bool (* GLFWcocoatogglefullscreenfun)(GLFWwindow*);\n",
                "typedef void (* GLFWcocoarenderframefun)(GLFWwindow*);\n",
                "typedef void (*GLFWwaylandframecallbackfunc)(unsigned long long id);\n",
                "typedef void (*GLFWDBusnotificationcreatedfun)(unsigned long long, uint32_t, void*);\n",
                "typedef void (*GLFWDBusnotificationactivatedfun)(uint32_t, const char*);\n",
                "{}\n",
                "\n",
                "const char* load_glfw(const char* path);\n",
                "'''.format(preamble, '\\n\\n'.join(declarations))\n",
                "    with open('../kitty/glfw-wrapper.h', 'w') as f:\n",
                "        f.write(header)\n",
                "\n",
                "    code = '''\n",
                "// generated by glfw.py DO NOT edit\n",
                "\n",
                "#define GFW_EXTERN\n",
                "#include \"data-types.h\"\n",
                "#include \"glfw-wrapper.h\"\n",
                "#include <dlfcn.h>\n",
                "\n",
                "static void* handle = NULL;\n",
                "\n",
                "#define fail(msg, ...) { snprintf(buf, sizeof(buf), msg, __VA_ARGS__); return buf; }\n",
                "\n",
                "const char*\n",
                "load_glfw(const char* path) {\n",
                "    static char buf[2048];\n",
                "    handle = dlopen(path, RTLD_LAZY);\n",
                "    if (handle == NULL) fail(\"Failed to dlopen %s with error: %s\", path, dlerror());\n",
                "    dlerror();\n",
                "\n",
                "    LOAD\n",
                "\n",
                "    return NULL;\n",
                "}\n",
                "\n",
                "void\n",
                "unload_glfw(void) {\n",
                "    if (handle) { dlclose(handle); handle = NULL; }\n",
                "}\n",
                "'''.replace('LOAD', '\\n\\n    '.join(f.load() for f in functions))\n",
                "    with open('../kitty/glfw-wrapper.c', 'w') as f:\n",
                "        f.write(code)\n",
                "\n",
                "\n",
                "def main() -> None:\n",
                "    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n",
                "    generate_wrappers('glfw3.h')\n",
                "\n",
                "\n",
                "if __name__ == '__main__':\n",
                "    main()"
            ]
        ],
        "setup.py": [
            [
                "#!/usr/bin/env python3\n",
                "# License: GPL v3 Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n",
                "\n",
                "import argparse\n",
                "import glob\n",
                "import json\n",
                "import os\n",
                "import platform\n",
                "import re\n",
                "import runpy\n",
                "import shlex\n",
                "import shutil\n",
                "import subprocess\n",
                "import sys\n",
                "import sysconfig\n",
                "import tempfile\n",
                "import textwrap\n",
                "import time\n",
                "from contextlib import suppress\n",
                "from functools import lru_cache, partial\n",
                "from pathlib import Path\n",
                "from typing import Callable, Dict, FrozenSet, Iterable, List, Optional, Sequence, Set, Tuple, Union, cast\n",
                "\n",
                "from glfw import glfw\n",
                "from glfw.glfw import Command, CompileKey\n",
                "\n",
                "if sys.version_info[:2] < (3, 8):\n",
                "    raise SystemExit('kitty requires python >= 3.8')\n",
                "src_base = os.path.dirname(os.path.abspath(__file__))\n",
                "\n",
                "verbose = False\n",
                "build_dir = 'build'\n",
                "constants = os.path.join('kitty', 'constants.py')\n",
                "with open(constants, 'rb') as f:\n",
                "    constants = f.read().decode('utf-8')\n",
                "appname = re.search(r\"^appname: str = '([^']+)'\", constants, re.MULTILINE).group(1)  # type: ignore\n",
                "version = tuple(\n",
                "    map(\n",
                "        int,\n",
                "        re.search(  # type: ignore\n",
                "            r\"^version: Version = Version\\((\\d+), (\\d+), (\\d+)\\)\", constants, re.MULTILINE\n",
                "        ).group(1, 2, 3)\n",
                "    )\n",
                ")\n",
                "_plat = sys.platform.lower()\n",
                "is_macos = 'darwin' in _plat\n",
                "is_openbsd = 'openbsd' in _plat\n",
                "is_freebsd = 'freebsd' in _plat\n",
                "is_netbsd = 'netbsd' in _plat\n",
                "is_dragonflybsd = 'dragonfly' in _plat\n",
                "is_bsd = is_freebsd or is_netbsd or is_dragonflybsd or is_openbsd\n",
                "is_arm = platform.processor() == 'arm' or platform.machine() == 'arm64'\n",
                "Env = glfw.Env\n",
                "env = Env()\n",
                "PKGCONFIG = os.environ.get('PKGCONFIG_EXE', 'pkg-config')\n",
                "\n",
                "\n",
                "class Options(argparse.Namespace):\n",
                "    action: str = 'build'\n",
                "    debug: bool = False\n",
                "    verbose: int = 0\n",
                "    sanitize: bool = False\n",
                "    prefix: str = './linux-package'\n",
                "    dir_for_static_binaries: str = 'build/static'\n",
                "    incremental: bool = True\n",
                "    profile: bool = False\n",
                "    libdir_name: str = 'lib'\n",
                "    extra_logging: List[str] = []\n",
                "    extra_include_dirs: List[str] = []\n",
                "    extra_library_dirs: List[str] = []\n",
                "    link_time_optimization: bool = 'KITTY_NO_LTO' not in os.environ\n",
                "    update_check_interval: float = 24.0\n",
                "    shell_integration: str = 'enabled'\n",
                "    egl_library: Optional[str] = os.getenv('KITTY_EGL_LIBRARY')\n",
                "    startup_notification_library: Optional[str] = os.getenv('KITTY_STARTUP_NOTIFICATION_LIBRARY')\n",
                "    canberra_library: Optional[str] = os.getenv('KITTY_CANBERRA_LIBRARY')\n",
                "    fontconfig_library: Optional[str] = os.getenv('KITTY_FONTCONFIG_LIBRARY')\n",
                "\n",
                "\n",
                "def emphasis(text: str) -> str:\n",
                "    if sys.stdout.isatty():\n",
                "        text = f'\\033[32m{text}\\033[39m'\n",
                "    return text\n",
                "\n",
                "\n",
                "def error(text: str) -> str:\n",
                "    if sys.stdout.isatty():\n",
                "        text = f'\\033[91m{text}\\033[39m'\n",
                "    return text\n",
                "\n",
                "\n",
                "def pkg_config(pkg: str, *args: str, extra_pc_dir: str = '', fatal: bool = True) -> List[str]:\n",
                "    env = os.environ.copy()\n",
                "    if extra_pc_dir:\n",
                "        pp = env.get('PKG_CONFIG_PATH', '')\n",
                "        if pp:\n",
                "            pp += os.pathsep\n",
                "        env['PKG_CONFIG_PATH'] = f'{pp}{extra_pc_dir}'\n",
                "    cmd = [PKGCONFIG, pkg] + list(args)\n",
                "    try:\n",
                "        return list(\n",
                "            filter(\n",
                "                None,\n",
                "                shlex.split(\n",
                "                    subprocess.check_output(cmd, env=env, stderr=None if fatal else subprocess.DEVNULL).decode('utf-8')\n",
                "                )\n",
                "            )\n",
                "        )\n",
                "    except subprocess.CalledProcessError:\n",
                "        if fatal:\n",
                "            raise SystemExit(f'The package {error(pkg)} was not found on your system')\n",
                "        raise\n",
                "\n",
                "\n",
                "def pkg_version(package: str) -> Tuple[int, int]:\n",
                "    ver = subprocess.check_output([\n",
                "        PKGCONFIG, package, '--modversion']).decode('utf-8').strip()\n",
                "    m = re.match(r'(\\d+).(\\d+)', ver)\n",
                "    if m is not None:\n",
                "        qmajor, qminor = map(int, m.groups())\n",
                "        return qmajor, qminor\n",
                "    return -1, -1\n",
                "\n",
                "\n",
                "def libcrypto_flags() -> Tuple[List[str], List[str]]:\n",
                "    # Apple use their special snowflake TLS libraries and additionally\n",
                "    # have an ancient broken system OpenSSL, so we need to check for one\n",
                "    # installed by all the various macOS package managers.\n",
                "    extra_pc_dir = ''\n",
                "\n",
                "    try:\n",
                "        cflags = pkg_config('libcrypto', '--cflags-only-I', fatal=False)\n",
                "    except subprocess.CalledProcessError:\n",
                "        if is_macos:\n",
                "            import ssl\n",
                "            v = ssl.OPENSSL_VERSION_INFO\n",
                "            pats = f'{v[0]}.{v[1]}', f'{v[0]}'\n",
                "            for pat in pats:\n",
                "                q = f'opt/openssl@{pat}/lib/pkgconfig'\n",
                "                openssl_dirs = glob.glob(f'/opt/homebrew/{q}') + glob.glob(f'/usr/local/{q}')\n",
                "                if openssl_dirs:\n",
                "                    break\n",
                "            if not openssl_dirs:\n",
                "                raise SystemExit(f'Failed to find OpenSSL version {v[0]}.{v[1]} on your system')\n",
                "            extra_pc_dir = os.pathsep.join(openssl_dirs)\n",
                "        cflags = pkg_config('libcrypto', '--cflags-only-I', extra_pc_dir=extra_pc_dir)\n",
                "    return cflags, pkg_config('libcrypto', '--libs', extra_pc_dir=extra_pc_dir)\n",
                "\n",
                "\n",
                "def at_least_version(package: str, major: int, minor: int = 0) -> None:\n",
                "    q = f'{major}.{minor}'\n",
                "    if subprocess.run([PKGCONFIG, package, f'--atleast-version={q}']\n",
                "                      ).returncode != 0:\n",
                "        qmajor = qminor = 0\n",
                "        try:\n",
                "            ver = subprocess.check_output([PKGCONFIG, package, '--modversion']\n",
                "                                          ).decode('utf-8').strip()\n",
                "            m = re.match(r'(\\d+).(\\d+)', ver)\n",
                "            if m is not None:\n",
                "                qmajor, qminor = map(int, m.groups())\n",
                "        except Exception:\n",
                "            ver = 'not found'\n",
                "        if qmajor < major or (qmajor == major and qminor < minor):\n",
                "            raise SystemExit(f'{error(package)} >= {major}.{minor} is required, found version: {ver}')\n",
                "\n",
                "\n",
                "def cc_version() -> Tuple[List[str], Tuple[int, int]]:\n",
                "    if 'CC' in os.environ:\n",
                "        q = os.environ['CC']\n",
                "    else:\n",
                "        if is_macos:\n",
                "            q = 'clang'\n",
                "        else:\n",
                "            if shutil.which('gcc'):\n",
                "                q = 'gcc'\n",
                "            elif shutil.which('clang'):\n",
                "                q = 'clang'\n",
                "            else:\n",
                "                q = 'cc'\n",
                "    cc = shlex.split(q)\n",
                "    raw = subprocess.check_output(cc + ['-dumpversion']).decode('utf-8')\n",
                "    ver_ = raw.strip().split('.')[:2]\n",
                "    try:\n",
                "        if len(ver_) == 1:\n",
                "            ver = int(ver_[0]), 0\n",
                "        else:\n",
                "            ver = int(ver_[0]), int(ver_[1])\n",
                "    except Exception:\n",
                "        ver = (0, 0)\n",
                "    return cc, ver\n",
                "\n",
                "\n",
                "def get_python_include_paths() -> List[str]:\n",
                "    ans = []\n",
                "    for name in sysconfig.get_path_names():\n",
                "        if 'include' in name:\n",
                "            ans.append(name)\n",
                "\n",
                "    def gp(x: str) -> Optional[str]:\n",
                "        return sysconfig.get_path(x)\n",
                "\n",
                "    return sorted(frozenset(filter(None, map(gp, sorted(ans)))))\n",
                "\n",
                "\n",
                "def get_python_flags(cflags: List[str], for_main_executable: bool = False) -> List[str]:\n",
                "    cflags.extend(f'-I{x}' for x in get_python_include_paths())\n",
                "    libs: List[str] = []\n",
                "    libs += (sysconfig.get_config_var('LIBS') or '').split()\n",
                "    libs += (sysconfig.get_config_var('SYSLIBS') or '').split()\n",
                "    fw = sysconfig.get_config_var('PYTHONFRAMEWORK')\n",
                "    if fw:\n",
                "        for var in 'data include stdlib'.split():\n",
                "            val = sysconfig.get_path(var)\n",
                "            if val and f'/{fw}.framework' in val:\n",
                "                fdir = val[:val.index(f'/{fw}.framework')]\n",
                "                if os.path.isdir(\n",
                "                    os.path.join(fdir, f'{fw}.framework')\n",
                "                ):\n",
                "                    framework_dir = fdir\n",
                "                    break\n",
                "        else:\n",
                "            raise SystemExit('Failed to find Python framework')\n",
                "        ldlib = sysconfig.get_config_var('LDLIBRARY')\n",
                "        if ldlib:\n",
                "            libs.append(os.path.join(framework_dir, ldlib))\n",
                "    else:\n",
                "        ldlib = sysconfig.get_config_var('LIBDIR')\n",
                "        if ldlib:\n",
                "            libs += [f'-L{ldlib}']\n",
                "        ldlib = sysconfig.get_config_var('VERSION')\n",
                "        if ldlib:\n",
                "            libs += [f'-lpython{ldlib}{sys.abiflags}']\n",
                "        lval = sysconfig.get_config_var('LINKFORSHARED') or ''\n",
                "        if not for_main_executable:\n",
                "            # Python sets the stack size on macOS which is not allowed unless\n",
                "            # compiling an executable https://github.com/kovidgoyal/kitty/issues/289\n",
                "            lval = re.sub(r'-Wl,-stack_size,\\d+', '', lval)\n",
                "        libs += list(filter(None, lval.split()))\n",
                "    return libs\n",
                "\n",
                "\n",
                "def get_sanitize_args(cc: List[str], ccver: Tuple[int, int]) -> List[str]:\n",
                "    sanitize_args = ['-fsanitize=address']\n",
                "    if ccver >= (5, 0):\n",
                "        sanitize_args.append('-fsanitize=undefined')\n",
                "        # if cc == 'gcc' or (cc == 'clang' and ccver >= (4, 2)):\n",
                "        #     sanitize_args.append('-fno-sanitize-recover=all')\n",
                "    sanitize_args.append('-fno-omit-frame-pointer')\n",
                "    return sanitize_args\n",
                "\n",
                "\n",
                "def test_compile(\n",
                "    cc: List[str], *cflags: str,\n",
                "    src: str = '',\n",
                "    source_ext: str = 'c',\n",
                "    link_also: bool = True,\n",
                "    show_stderr: bool = False,\n",
                "    libraries: Iterable[str] = (),\n",
                "    ldflags: Iterable[str] = (),\n",
                ") -> bool:\n",
                "    src = src or 'int main(void) { return 0; }'\n",
                "    with tempfile.TemporaryDirectory(prefix='kitty-test-compile-') as tdir:\n",
                "        with open(os.path.join(tdir, f'source.{source_ext}'), 'w', encoding='utf-8') as srcf:\n",
                "            print(src, file=srcf)\n",
                "        return subprocess.Popen(\n",
                "            cc + ['-Werror=implicit-function-declaration'] + list(cflags) + ([] if link_also else ['-c']) +\n",
                "            ['-o', os.path.join(tdir, 'source.output'), srcf.name] +\n",
                "            [f'-l{x}' for x in libraries] + list(ldflags),\n",
                "            stdout=subprocess.DEVNULL, stdin=subprocess.DEVNULL,\n",
                "            stderr=None if show_stderr else subprocess.DEVNULL\n",
                "        ).wait() == 0\n",
                "\n",
                "\n",
                "def first_successful_compile(cc: List[str], *cflags: str, src: str = '', source_ext: str = 'c') -> str:\n",
                "    for x in cflags:\n",
                "        if test_compile(cc, *shlex.split(x), src=src, source_ext=source_ext):\n",
                "            return x\n",
                "    return ''\n",
                "\n",
                "\n",
                "def set_arches(flags: List[str], arches: Iterable[str] = ('x86_64', 'arm64')) -> None:\n",
                "    while True:\n",
                "        try:\n",
                "            idx = flags.index('-arch')\n",
                "        except ValueError:\n",
                "            break\n",
                "        del flags[idx]\n",
                "        del flags[idx]\n",
                "    for arch in arches:\n",
                "        flags.extend(('-arch', arch))\n",
                "\n",
                "\n",
                "def detect_librsync(cc: List[str], cflags: List[str], ldflags: List[str]) -> str:\n",
                "    if not test_compile(\n",
                "            cc, *cflags, libraries=('rsync',), ldflags=ldflags, show_stderr=True,\n",
                "            src='#include <librsync.h>\\nint main(void) { rs_strerror(0); return 0; }'):\n",
                "        raise SystemExit('The librsync library is required')\n",
                "    # check for rs_sig_args() which was added to librsync in Apr 2020 version 2.3.0\n",
                "    if test_compile(cc, *cflags, libraries=('rsync',), ldflags=ldflags, src='''\n",
                "#include <librsync.h>\n",
                "int main(void) {\n",
                "    rs_magic_number magic_number = 0;\n",
                "    size_t block_len = 0, strong_len = 0;\n",
                "    rs_sig_args(1024, &magic_number, &block_len, &strong_len);\n",
                "    return 0;\n",
                "}'''):\n",
                "        return '-DKITTY_HAS_RS_SIG_ARGS'\n",
                "    return ''\n",
                "\n",
                "\n",
                "def is_gcc(cc: Iterable[str]) -> bool:\n",
                "\n",
                "    @lru_cache()\n",
                "    def f(cc: Tuple[str]) -> bool:\n",
                "        raw = subprocess.check_output(cc + ('--version',)).decode('utf-8').splitlines()[0]\n",
                "        return '(GCC)' in raw.split()\n",
                "\n",
                "    return f(tuple(cc))\n",
                "\n",
                "\n",
                "def init_env(\n",
                "    debug: bool = False,\n",
                "    sanitize: bool = False,\n",
                "    native_optimizations: bool = True,\n",
                "    link_time_optimization: bool = True,\n",
                "    profile: bool = False,\n",
                "    egl_library: Optional[str] = None,\n",
                "    startup_notification_library: Optional[str] = None,\n",
                "    canberra_library: Optional[str] = None,\n",
                "    fontconfig_library: Optional[str] = None,\n",
                "    extra_logging: Iterable[str] = (),\n",
                "    extra_include_dirs: Iterable[str] = (),\n",
                "    ignore_compiler_warnings: bool = False,\n",
                "    build_universal_binary: bool = False,\n",
                "    extra_library_dirs: Iterable[str] = (),\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    verbose: bool = True\n"
                ],
                "after": [
                    "    verbose: bool = True,\n",
                    "    vcs_rev: str = '',\n"
                ],
                "parent_version_range": {
                    "start": 335,
                    "end": 336
                },
                "child_version_range": {
                    "start": 335,
                    "end": 337
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "init_env",
                        "signature": "def init_env(\n    debug: bool = False,\n    sanitize: bool = False,\n    native_optimizations: bool = True,\n    link_time_optimization: bool = True,\n    profile: bool = False,\n    egl_library: Optional[str] = None,\n    startup_notification_library: Optional[str] = None,\n    canberra_library: Optional[str] = None,\n    fontconfig_library: Optional[str] = None,\n    extra_logging: Iterable[str] = (),\n    extra_include_dirs: Iterable[str] = (),\n    ignore_compiler_warnings: bool = False,\n    build_universal_binary: bool = False,\n    extra_library_dirs: Iterable[str] = (),\n    verbose: bool = True\n)->Env:",
                        "at_line": 320
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: setup.py\nCode:\n           def init_env(\n    debug: bool = False,\n    sanitize: bool = False,\n    native_optimizations: bool = True,\n    link_time_optimization: bool = True,\n    profile: bool = False,\n    egl_library: Optional[str] = None,\n    startup_notification_library: Optional[str] = None,\n    canberra_library: Optional[str] = None,\n    fontconfig_library: Optional[str] = None,\n    extra_logging: Iterable[str] = (),\n    extra_include_dirs: Iterable[str] = (),\n    ignore_compiler_warnings: bool = False,\n    build_universal_binary: bool = False,\n    extra_library_dirs: Iterable[str] = (),\n    verbose: bool = True\n)->Env:\n               ...\n332 332        ignore_compiler_warnings: bool = False,\n333 333        build_universal_binary: bool = False,\n334 334        extra_library_dirs: Iterable[str] = (),\n335      -     verbose: bool = True\n    335  +     verbose: bool = True,\n    336  +     vcs_rev: str = '',\n336 337    ) -> Env:\n337 338        native_optimizations = native_optimizations and not sanitize and not debug\n338 339        if native_optimizations and is_macos and is_arm:\n         ...\n",
                "file_path": "setup.py",
                "identifiers_before": [
                    "bool",
                    "verbose"
                ],
                "identifiers_after": [
                    "bool",
                    "str",
                    "vcs_rev",
                    "verbose"
                ],
                "prefix": [
                    "    ignore_compiler_warnings: bool = False,\n",
                    "    build_universal_binary: bool = False,\n",
                    "    extra_library_dirs: Iterable[str] = (),\n"
                ],
                "suffix": [
                    ") -> Env:\n",
                    "    native_optimizations = native_optimizations and not sanitize and not debug\n",
                    "    if native_optimizations and is_macos and is_arm:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 336,
                                    "column": 4
                                },
                                "end": {
                                    "line": 336,
                                    "column": 11
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                ") -> Env:\n",
                "    native_optimizations = native_optimizations and not sanitize and not debug\n",
                "    if native_optimizations and is_macos and is_arm:\n",
                "        # see https://github.com/kovidgoyal/kitty/issues/3126\n",
                "        # -march=native is not supported when targeting Apple Silicon\n",
                "        native_optimizations = False\n",
                "    cc, ccver = cc_version()\n",
                "    if verbose:\n",
                "        print('CC:', cc, ccver)\n",
                "    stack_protector = first_successful_compile(cc, '-fstack-protector-strong', '-fstack-protector')\n",
                "    missing_braces = ''\n",
                "    if ccver < (5, 2) and is_gcc(cc):\n",
                "        missing_braces = '-Wno-missing-braces'\n",
                "    df = '-g3'\n",
                "    float_conversion = ''\n",
                "    if ccver >= (5, 0):\n",
                "        df += ' -Og'\n",
                "        float_conversion = '-Wfloat-conversion'\n",
                "    fortify_source = '' if sanitize and is_macos else '-D_FORTIFY_SOURCE=2'\n",
                "    optimize = df if debug or sanitize else '-O3'\n",
                "    sanitize_args = get_sanitize_args(cc, ccver) if sanitize else set()\n",
                "    cppflags_ = os.environ.get(\n",
                "        'OVERRIDE_CPPFLAGS', '-D{}DEBUG'.format('' if debug else 'N'),\n",
                "    )\n",
                "    cppflags = shlex.split(cppflags_)\n",
                "    for el in extra_logging:\n",
                "        cppflags.append('-DDEBUG_{}'.format(el.upper().replace('-', '_')))\n",
                "    has_copy_file_range = test_compile(cc, src='#define _GNU_SOURCE 1\\n#include <unistd.h>\\nint main() { copy_file_range(1, NULL, 2, NULL, 0, 0); return 0; }')\n",
                "    if has_copy_file_range:\n",
                "        cppflags.append('-DHAS_COPY_FILE_RANGE')\n",
                "    werror = '' if ignore_compiler_warnings else '-pedantic-errors -Werror'\n",
                "    std = '' if is_openbsd else '-std=c11'\n",
                "    sanitize_flag = ' '.join(sanitize_args)\n",
                "    march = '-march=native' if native_optimizations else ''\n",
                "    cflags_ = os.environ.get(\n",
                "        'OVERRIDE_CFLAGS', (\n",
                "            f'-Wextra {float_conversion} -Wno-missing-field-initializers -Wall -Wstrict-prototypes {std}'\n",
                "            f' {werror} {optimize} {sanitize_flag} -fwrapv {stack_protector} {missing_braces}'\n",
                "            f' -pipe {march} -fvisibility=hidden {fortify_source}'\n",
                "        )\n",
                "    )\n",
                "    cflags = shlex.split(cflags_) + shlex.split(\n",
                "        sysconfig.get_config_var('CCSHARED') or ''\n",
                "    )\n",
                "    ldflags_ = os.environ.get(\n",
                "        'OVERRIDE_LDFLAGS',\n",
                "        '-Wall ' + ' '.join(sanitize_args) + ('' if debug else ' -O3')\n",
                "    )\n",
                "    ldflags = shlex.split(ldflags_)\n",
                "    ldflags.append('-shared')\n",
                "    cppflags += shlex.split(os.environ.get('CPPFLAGS', ''))\n",
                "    cflags += shlex.split(os.environ.get('CFLAGS', ''))\n",
                "    ldflags += shlex.split(os.environ.get('LDFLAGS', ''))\n",
                "    if not debug and not sanitize and not is_openbsd and link_time_optimization:\n",
                "        # See https://github.com/google/sanitizers/issues/647\n",
                "        cflags.append('-flto')\n",
                "        ldflags.append('-flto')\n",
                "\n",
                "    if debug:\n",
                "        cflags.append('-DKITTY_DEBUG_BUILD')\n",
                "\n",
                "    if profile:\n",
                "        cppflags.append('-DWITH_PROFILER')\n",
                "        cflags.append('-g3')\n",
                "        ldflags.append('-lprofiler')\n",
                "\n",
                "    library_paths: Dict[str, List[str]] = {}\n",
                "\n",
                "    def add_lpath(which: str, name: str, val: Optional[str]) -> None:\n",
                "        if val:\n",
                "            if '\"' in val:\n",
                "                raise SystemExit(f'Cannot have quotes in library paths: {val}')\n",
                "            library_paths.setdefault(which, []).append(f'{name}=\"{val}\"')\n",
                "\n",
                "    add_lpath('glfw/egl_context.c', '_GLFW_EGL_LIBRARY', egl_library)\n",
                "    add_lpath('kitty/desktop.c', '_KITTY_STARTUP_NOTIFICATION_LIBRARY', startup_notification_library)\n",
                "    add_lpath('kitty/desktop.c', '_KITTY_CANBERRA_LIBRARY', canberra_library)\n",
                "    add_lpath('kitty/fontconfig.c', '_KITTY_FONTCONFIG_LIBRARY', fontconfig_library)\n",
                "\n",
                "    for path in extra_include_dirs:\n",
                "        cflags.append(f'-I{path}')\n",
                "\n",
                "    ldpaths = []\n",
                "    for path in extra_library_dirs:\n",
                "        ldpaths.append(f'-L{path}')\n",
                "\n",
                "    rs_cflag = detect_librsync(cc, cflags, ldflags + ldpaths)\n",
                "    if rs_cflag:\n",
                "        cflags.append(rs_cflag)\n",
                "\n",
                "    if build_universal_binary:\n",
                "        set_arches(cflags)\n",
                "        set_arches(ldflags)\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    return Env(cc, cppflags, cflags, ldflags, library_paths, ccver=ccver, ldpaths=ldpaths)\n"
                ],
                "after": [
                    "    return Env(cc, cppflags, cflags, ldflags, library_paths, ccver=ccver, ldpaths=ldpaths, vcs_rev=vcs_rev)\n"
                ],
                "parent_version_range": {
                    "start": 430,
                    "end": 431
                },
                "child_version_range": {
                    "start": 431,
                    "end": 432
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "init_env",
                        "signature": "def init_env(\n    debug: bool = False,\n    sanitize: bool = False,\n    native_optimizations: bool = True,\n    link_time_optimization: bool = True,\n    profile: bool = False,\n    egl_library: Optional[str] = None,\n    startup_notification_library: Optional[str] = None,\n    canberra_library: Optional[str] = None,\n    fontconfig_library: Optional[str] = None,\n    extra_logging: Iterable[str] = (),\n    extra_include_dirs: Iterable[str] = (),\n    ignore_compiler_warnings: bool = False,\n    build_universal_binary: bool = False,\n    extra_library_dirs: Iterable[str] = (),\n    verbose: bool = True\n)->Env:",
                        "at_line": 320
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: setup.py\nCode:\n           def init_env(\n    debug: bool = False,\n    sanitize: bool = False,\n    native_optimizations: bool = True,\n    link_time_optimization: bool = True,\n    profile: bool = False,\n    egl_library: Optional[str] = None,\n    startup_notification_library: Optional[str] = None,\n    canberra_library: Optional[str] = None,\n    fontconfig_library: Optional[str] = None,\n    extra_logging: Iterable[str] = (),\n    extra_include_dirs: Iterable[str] = (),\n    ignore_compiler_warnings: bool = False,\n    build_universal_binary: bool = False,\n    extra_library_dirs: Iterable[str] = (),\n    verbose: bool = True\n)->Env:\n               ...\n427 428            set_arches(cflags)\n428 429            set_arches(ldflags)\n429 430    \n430      -     return Env(cc, cppflags, cflags, ldflags, library_paths, ccver=ccver, ldpaths=ldpaths)\n    431  +     return Env(cc, cppflags, cflags, ldflags, library_paths, ccver=ccver, ldpaths=ldpaths, vcs_rev=vcs_rev)\n431 432    \n432 433    \n433 434    def kitty_env() -> Env:\n         ...\n",
                "file_path": "setup.py",
                "identifiers_before": [
                    "Env",
                    "cc",
                    "ccver",
                    "cflags",
                    "cppflags",
                    "ldflags",
                    "ldpaths",
                    "library_paths"
                ],
                "identifiers_after": [
                    "Env",
                    "cc",
                    "ccver",
                    "cflags",
                    "cppflags",
                    "ldflags",
                    "ldpaths",
                    "library_paths",
                    "vcs_rev"
                ],
                "prefix": [
                    "        set_arches(cflags)\n",
                    "        set_arches(ldflags)\n",
                    "\n"
                ],
                "suffix": [
                    "\n",
                    "\n",
                    "def kitty_env() -> Env:\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "ldpaths",
                            "position": {
                                "start": {
                                    "line": 430,
                                    "column": 74
                                },
                                "end": {
                                    "line": 430,
                                    "column": 81
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "ccver",
                            "position": {
                                "start": {
                                    "line": 430,
                                    "column": 61
                                },
                                "end": {
                                    "line": 430,
                                    "column": 66
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "ldpaths",
                            "position": {
                                "start": {
                                    "line": 431,
                                    "column": 74
                                },
                                "end": {
                                    "line": 431,
                                    "column": 81
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "ccver",
                            "position": {
                                "start": {
                                    "line": 431,
                                    "column": 61
                                },
                                "end": {
                                    "line": 431,
                                    "column": 66
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 431,
                                    "column": 91
                                },
                                "end": {
                                    "line": 431,
                                    "column": 98
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 431,
                                    "column": 99
                                },
                                "end": {
                                    "line": 431,
                                    "column": 106
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "\n",
                "def kitty_env() -> Env:\n",
                "    ans = env.copy()\n",
                "    cflags = ans.cflags\n",
                "    cflags.append('-pthread')\n",
                "    # We add 4000 to the primary version because vim turns on SGR mouse mode\n",
                "    # automatically if this version is high enough\n",
                "    libcrypto_cflags, libcrypto_ldflags = libcrypto_flags()\n",
                "    cppflags = ans.cppflags\n",
                "    cppflags.append(f'-DPRIMARY_VERSION={version[0] + 4000}')\n",
                "    cppflags.append(f'-DSECONDARY_VERSION={version[1]}')\n",
                "    cppflags.append('-DXT_VERSION=\"{}\"'.format('.'.join(map(str, version))))\n",
                "    at_least_version('harfbuzz', 1, 5)\n",
                "    cflags.extend(pkg_config('libpng', '--cflags-only-I'))\n",
                "    cflags.extend(pkg_config('lcms2', '--cflags-only-I'))\n",
                "    cflags.extend(libcrypto_cflags)\n",
                "    if is_macos:\n",
                "        platform_libs = [\n",
                "            '-framework', 'Carbon', '-framework', 'CoreText', '-framework', 'CoreGraphics',\n",
                "        ]\n",
                "        test_program_src = '''#include <UserNotifications/UserNotifications.h>\n",
                "        int main(void) { return 0; }\\n'''\n",
                "        user_notifications_framework = first_successful_compile(\n",
                "            ans.cc, '-framework UserNotifications', src=test_program_src, source_ext='m')\n",
                "        if user_notifications_framework:\n",
                "            platform_libs.extend(shlex.split(user_notifications_framework))\n",
                "        else:\n",
                "            cppflags.append('-DKITTY_USE_DEPRECATED_MACOS_NOTIFICATION_API')\n",
                "        # Apple deprecated OpenGL in Mojave (10.14) silence the endless\n",
                "        # warnings about it\n",
                "        cppflags.append('-DGL_SILENCE_DEPRECATION')\n",
                "    else:\n",
                "        cflags.extend(pkg_config('fontconfig', '--cflags-only-I'))\n",
                "        platform_libs = []\n",
                "    cflags.extend(pkg_config('harfbuzz', '--cflags-only-I'))\n",
                "    platform_libs.extend(pkg_config('harfbuzz', '--libs'))\n",
                "    pylib = get_python_flags(cflags)\n",
                "    gl_libs = ['-framework', 'OpenGL'] if is_macos else pkg_config('gl', '--libs')\n",
                "    libpng = pkg_config('libpng', '--libs')\n",
                "    lcms2 = pkg_config('lcms2', '--libs')\n",
                "    ans.ldpaths += pylib + platform_libs + gl_libs + libpng + lcms2 + libcrypto_ldflags\n",
                "    if is_macos:\n",
                "        ans.ldpaths.extend('-framework Cocoa'.split())\n",
                "    elif not is_openbsd:\n",
                "        ans.ldpaths += ['-lrt']\n",
                "        if '-ldl' not in ans.ldpaths:\n",
                "            ans.ldpaths.append('-ldl')\n",
                "    if '-lz' not in ans.ldpaths:\n",
                "        ans.ldpaths.append('-lz')\n",
                "\n",
                "    os.makedirs(build_dir, exist_ok=True)\n",
                "    return ans\n",
                "\n",
                "\n",
                "def define(x: str) -> str:\n",
                "    return f'-D{x}'\n",
                "\n",
                "\n",
                "def run_tool(cmd: Union[str, List[str]], desc: Optional[str] = None) -> None:\n",
                "    if isinstance(cmd, str):\n",
                "        cmd = shlex.split(cmd[0])\n",
                "    if verbose:\n",
                "        desc = None\n",
                "    print(desc or ' '.join(cmd))\n",
                "    p = subprocess.Popen(cmd)\n",
                "    ret = p.wait()\n",
                "    if ret != 0:\n",
                "        if desc:\n",
                "            print(' '.join(cmd))\n",
                "        raise SystemExit(ret)\n",
                "\n",
                "\n",
                "@lru_cache\n"
            ],
            {
                "type": "replace",
                "before": [
                    "def get_vcs_rev_define() -> str:\n"
                ],
                "after": [
                    "def get_vcs_rev() -> str:\n"
                ],
                "parent_version_range": {
                    "start": 505,
                    "end": 506
                },
                "child_version_range": {
                    "start": 506,
                    "end": 507
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_vcs_rev_define",
                        "signature": "def get_vcs_rev_define()->str:",
                        "at_line": 505
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: setup.py\nCode:\n502 503    \n503 504    \n504 505    @lru_cache\n505      - def get_vcs_rev_define() -> str:\n    506  + def get_vcs_rev() -> str:\n506 507        ans = ''\n507 508        if os.path.exists('.git'):\n508 509            try:\n         ...\n",
                "file_path": "setup.py",
                "identifiers_before": [
                    "get_vcs_rev_define",
                    "str"
                ],
                "identifiers_after": [
                    "get_vcs_rev",
                    "str"
                ],
                "prefix": [
                    "\n",
                    "\n",
                    "@lru_cache\n"
                ],
                "suffix": [
                    "    ans = ''\n",
                    "    if os.path.exists('.git'):\n",
                    "        try:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "get_vcs_rev_define",
                            "position": {
                                "start": {
                                    "line": 505,
                                    "column": 4
                                },
                                "end": {
                                    "line": 505,
                                    "column": 22
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "get_vcs_rev_define",
                            "position": {
                                "start": {
                                    "line": 505,
                                    "column": 4
                                },
                                "end": {
                                    "line": 505,
                                    "column": 22
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "get_vcs_rev",
                            "position": {
                                "start": {
                                    "line": 506,
                                    "column": 4
                                },
                                "end": {
                                    "line": 506,
                                    "column": 15
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "get_vcs_rev",
                            "position": {
                                "start": {
                                    "line": 506,
                                    "column": 4
                                },
                                "end": {
                                    "line": 506,
                                    "column": 15
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "    ans = ''\n",
                "    if os.path.exists('.git'):\n",
                "        try:\n",
                "            rev = subprocess.check_output(['git', 'rev-parse', 'HEAD']).decode('utf-8')\n",
                "        except FileNotFoundError:\n",
                "            try:\n",
                "                with open('.git/refs/heads/master') as f:\n",
                "                    rev = f.read()\n",
                "            except NotADirectoryError:\n",
                "                with open('.git') as f:\n",
                "                    gitloc = f.read()\n",
                "                with open(os.path.join(gitloc, 'refs/heads/master')) as f:\n",
                "                    rev = f.read()\n",
                "\n",
                "        ans = rev.strip()\n",
                "    return ans\n",
                "\n",
                "\n",
                "def get_source_specific_defines(env: Env, src: str) -> Tuple[str, Optional[List[str]]]:\n",
                "    if src == 'kitty/parser_dump.c':\n",
                "        return 'kitty/parser.c', ['DUMP_COMMANDS']\n",
                "    if src == 'kitty/data-types.c':\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        return src, [f'KITTY_VCS_REV=\"{get_vcs_rev_define()}\"', f'WRAPPED_KITTENS=\"{wrapped_kittens()}\"']\n"
                ],
                "after": [
                    "        if not env.vcs_rev:\n",
                    "            env.vcs_rev = get_vcs_rev()\n",
                    "        return src, [f'KITTY_VCS_REV=\"{env.vcs_rev}\"', f'WRAPPED_KITTENS=\"{wrapped_kittens()}\"']\n"
                ],
                "parent_version_range": {
                    "start": 528,
                    "end": 529
                },
                "child_version_range": {
                    "start": 529,
                    "end": 532
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if src == 'kitty/data-types.c':",
                        "start_line": 527,
                        "end_line": 528
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_source_specific_defines",
                        "signature": "def get_source_specific_defines(env: Env, src: str)->Tuple[str, Optional[List[str]]]:",
                        "at_line": 524
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: setup.py\nCode:\n           def get_source_specific_defines(env: Env, src: str)->Tuple[str, Optional[List[str]]]:\n               ...\n525 526        if src == 'kitty/parser_dump.c':\n526 527            return 'kitty/parser.c', ['DUMP_COMMANDS']\n527 528        if src == 'kitty/data-types.c':\n528      -         return src, [f'KITTY_VCS_REV=\"{get_vcs_rev_define()}\"', f'WRAPPED_KITTENS=\"{wrapped_kittens()}\"']\n    529  +         if not env.vcs_rev:\n    530  +             env.vcs_rev = get_vcs_rev()\n    531  +         return src, [f'KITTY_VCS_REV=\"{env.vcs_rev}\"', f'WRAPPED_KITTENS=\"{wrapped_kittens()}\"']\n529 532        try:\n530 533            return src, env.library_paths[src]\n531 534        except KeyError:\n         ...\n",
                "file_path": "setup.py",
                "identifiers_before": [
                    "get_vcs_rev_define",
                    "src",
                    "wrapped_kittens"
                ],
                "identifiers_after": [
                    "env",
                    "get_vcs_rev",
                    "src",
                    "vcs_rev",
                    "wrapped_kittens"
                ],
                "prefix": [
                    "    if src == 'kitty/parser_dump.c':\n",
                    "        return 'kitty/parser.c', ['DUMP_COMMANDS']\n",
                    "    if src == 'kitty/data-types.c':\n"
                ],
                "suffix": [
                    "    try:\n",
                    "        return src, env.library_paths[src]\n",
                    "    except KeyError:\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "get_vcs_rev_define",
                            "position": {
                                "start": {
                                    "line": 528,
                                    "column": 39
                                },
                                "end": {
                                    "line": 528,
                                    "column": 57
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 529,
                                    "column": 19
                                },
                                "end": {
                                    "line": 529,
                                    "column": 26
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 530,
                                    "column": 16
                                },
                                "end": {
                                    "line": 530,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "vcs_rev",
                            "position": {
                                "start": {
                                    "line": 531,
                                    "column": 43
                                },
                                "end": {
                                    "line": 531,
                                    "column": 50
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "get_vcs_rev",
                            "position": {
                                "start": {
                                    "line": 530,
                                    "column": 26
                                },
                                "end": {
                                    "line": 530,
                                    "column": 37
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    try:\n",
                "        return src, env.library_paths[src]\n",
                "    except KeyError:\n",
                "        return src, None\n",
                "\n",
                "\n",
                "def newer(dest: str, *sources: str) -> bool:\n",
                "    try:\n",
                "        dtime = os.path.getmtime(dest)\n",
                "    except OSError:\n",
                "        return True\n",
                "    for s in sources:\n",
                "        with suppress(FileNotFoundError):\n",
                "            if os.path.getmtime(s) >= dtime:\n",
                "                return True\n",
                "    return False\n",
                "\n",
                "\n",
                "def dependecies_for(src: str, obj: str, all_headers: Iterable[str]) -> Iterable[str]:\n",
                "    dep_file = obj.rpartition('.')[0] + '.d'\n",
                "    try:\n",
                "        with open(dep_file) as f:\n",
                "            deps = f.read()\n",
                "    except FileNotFoundError:\n",
                "        yield src\n",
                "        yield from iter(all_headers)\n",
                "    else:\n",
                "        RE_INC = re.compile(\n",
                "            r'^(?P<target>.+?):\\s+(?P<deps>.+?)$', re.MULTILINE\n",
                "        )\n",
                "        SPACE_TOK = '\\x1B'\n",
                "\n",
                "        text = deps.replace('\\\\\\n', ' ').replace('\\\\ ', SPACE_TOK)\n",
                "        for match in RE_INC.finditer(text):\n",
                "            files = (\n",
                "                f.replace(SPACE_TOK, ' ') for f in match.group('deps').split()\n",
                "            )\n",
                "            for path in files:\n",
                "                path = os.path.abspath(path)\n",
                "                if path.startswith(src_base):\n",
                "                    yield path\n",
                "\n",
                "\n",
                "def parallel_run(items: List[Command]) -> None:\n",
                "    try:\n",
                "        num_workers = max(2, os.cpu_count() or 1)\n",
                "    except Exception:\n",
                "        num_workers = 2\n",
                "    items = list(reversed(items))\n",
                "    workers: Dict[int, Tuple[Optional[Command], Optional['subprocess.Popen[bytes]']]] = {}\n",
                "    failed = None\n",
                "    num, total = 0, len(items)\n",
                "\n",
                "    def wait() -> None:\n",
                "        nonlocal failed\n",
                "        if not workers:\n",
                "            return\n",
                "        pid, s = os.wait()\n",
                "        compile_cmd, w = workers.pop(pid, (None, None))\n",
                "        if compile_cmd is None:\n",
                "            return\n",
                "        if ((s & 0xff) != 0 or ((s >> 8) & 0xff) != 0):\n",
                "            if failed is None:\n",
                "                failed = compile_cmd\n",
                "        elif compile_cmd.on_success is not None:\n",
                "            compile_cmd.on_success()\n",
                "\n",
                "    printed = False\n",
                "    isatty = sys.stdout.isatty()\n",
                "    while items and failed is None:\n",
                "        while len(workers) < num_workers and items:\n",
                "            compile_cmd = items.pop()\n",
                "            num += 1\n",
                "            if verbose:\n",
                "                print(' '.join(compile_cmd.cmd))\n",
                "            elif isatty:\n",
                "                print(f'\\r\\x1b[K[{num}/{total}] {compile_cmd.desc}', end='')\n",
                "            else:\n",
                "                print(f'[{num}/{total}] {compile_cmd.desc}', flush=True)\n",
                "            printed = True\n",
                "            w = subprocess.Popen(compile_cmd.cmd, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n",
                "            workers[w.pid] = compile_cmd, w\n",
                "        wait()\n",
                "    while len(workers):\n",
                "        wait()\n",
                "    if not verbose and printed:\n",
                "        print(' done')\n",
                "    if failed:\n",
                "        print(failed.desc)\n",
                "        run_tool(list(failed.cmd))\n",
                "\n",
                "\n",
                "class CompilationDatabase:\n",
                "\n",
                "    def __init__(self, incremental: bool):\n",
                "        self.incremental = incremental\n",
                "        self.compile_commands: List[Command] = []\n",
                "        self.link_commands: List[Command] = []\n",
                "\n",
                "    def add_command(\n",
                "        self,\n",
                "        desc: str,\n",
                "        cmd: List[str],\n",
                "        is_newer_func: Callable[[], bool],\n",
                "        key: Optional[CompileKey] = None,\n",
                "        on_success: Optional[Callable[[], None]] = None,\n",
                "        keyfile: Optional[str] = None\n",
                "    ) -> None:\n",
                "        def no_op() -> None:\n",
                "            pass\n",
                "\n",
                "        queue = self.link_commands if keyfile is None else self.compile_commands\n",
                "        queue.append(Command(desc, cmd, is_newer_func, on_success or no_op, key, keyfile))\n",
                "\n",
                "    def build_all(self) -> None:\n",
                "\n",
                "        def sort_key(compile_cmd: Command) -> int:\n",
                "            if compile_cmd.keyfile:\n",
                "                return os.path.getsize(compile_cmd.keyfile)\n",
                "            return 0\n",
                "\n",
                "        items = []\n",
                "        for compile_cmd in self.compile_commands:\n",
                "            if not self.incremental or self.cmd_changed(compile_cmd) or compile_cmd.is_newer_func():\n",
                "                items.append(compile_cmd)\n",
                "        items.sort(key=sort_key, reverse=True)\n",
                "        parallel_run(items)\n",
                "\n",
                "        items = []\n",
                "        for compile_cmd in self.link_commands:\n",
                "            if not self.incremental or compile_cmd.is_newer_func():\n",
                "                items.append(compile_cmd)\n",
                "        parallel_run(items)\n",
                "\n",
                "    def cmd_changed(self, compile_cmd: Command) -> bool:\n",
                "        key, cmd = compile_cmd.key, compile_cmd.cmd\n",
                "        return bool(self.db.get(key) != cmd)\n",
                "\n",
                "    def __enter__(self) -> 'CompilationDatabase':\n",
                "        self.all_keys: Set[CompileKey] = set()\n",
                "        self.dbpath = os.path.abspath(os.path.join('build', 'compile_commands.json'))\n",
                "        self.linkdbpath = os.path.join(os.path.dirname(self.dbpath), 'link_commands.json')\n",
                "        try:\n",
                "            with open(self.dbpath) as f:\n",
                "                compilation_database = json.load(f)\n",
                "        except FileNotFoundError:\n",
                "            compilation_database = []\n",
                "        try:\n",
                "            with open(self.linkdbpath) as f:\n",
                "                link_database = json.load(f)\n",
                "        except FileNotFoundError:\n",
                "            link_database = []\n",
                "        compilation_database = {\n",
                "            CompileKey(k['file'], k['output']): k['arguments'] for k in compilation_database\n",
                "        }\n",
                "        self.db = compilation_database\n",
                "        self.linkdb = {tuple(k['output']): k['arguments'] for k in link_database}\n",
                "        return self\n",
                "\n",
                "    def __exit__(self, *a: object) -> None:\n",
                "        cdb = self.db\n",
                "        for key in set(cdb) - self.all_keys:\n",
                "            del cdb[key]\n",
                "        compilation_database = [\n",
                "            {'file': c.key.src, 'arguments': c.cmd, 'directory': src_base, 'output': c.key.dest} for c in self.compile_commands if c.key is not None\n",
                "        ]\n",
                "        with open(self.dbpath, 'w') as f:\n",
                "            json.dump(compilation_database, f, indent=2, sort_keys=True)\n",
                "        with open(self.linkdbpath, 'w') as f:\n",
                "            json.dump([{'output': c.key, 'arguments': c.cmd, 'directory': src_base} for c in self.link_commands], f, indent=2, sort_keys=True)\n",
                "\n",
                "\n",
                "def compile_c_extension(\n",
                "    kenv: Env,\n",
                "    module: str,\n",
                "    compilation_database: CompilationDatabase,\n",
                "    sources: List[str],\n",
                "    headers: List[str],\n",
                "    desc_prefix: str = ''\n",
                ") -> None:\n",
                "    prefix = os.path.basename(module)\n",
                "    objects = [\n",
                "        os.path.join(build_dir, f'{prefix}-{os.path.basename(src)}.o')\n",
                "        for src in sources\n",
                "    ]\n",
                "\n",
                "    for original_src, dest in zip(sources, objects):\n",
                "        src = original_src\n",
                "        cppflags = kenv.cppflags[:]\n",
                "        src, defines = get_source_specific_defines(kenv, src)\n",
                "        if defines is not None:\n",
                "            cppflags.extend(map(define, defines))\n",
                "        cmd = kenv.cc + ['-MMD'] + cppflags + kenv.cflags\n",
                "        cmd += ['-c', src] + ['-o', dest]\n",
                "        key = CompileKey(original_src, os.path.basename(dest))\n",
                "        desc = f'Compiling {emphasis(desc_prefix + src)} ...'\n",
                "        compilation_database.add_command(desc, cmd, partial(newer, dest, *dependecies_for(src, dest, headers)), key=key, keyfile=src)\n",
                "    dest = os.path.join(build_dir, f'{module}.so')\n",
                "    real_dest = f'{module}.so'\n",
                "    os.makedirs(os.path.dirname(dest), exist_ok=True)\n",
                "    desc = f'Linking {emphasis(desc_prefix + module)} ...'\n",
                "    # Old versions of clang don't like -pthread being passed to the linker\n",
                "    # Don't treat linker warnings as errors (linker generates spurious\n",
                "    # warnings on some old systems)\n",
                "    unsafe = {'-pthread', '-Werror', '-pedantic-errors'}\n",
                "    linker_cflags = list(filter(lambda x: x not in unsafe, kenv.cflags))\n",
                "    cmd = kenv.cc + linker_cflags + kenv.ldflags + objects + kenv.ldpaths + ['-o', dest]\n",
                "\n",
                "    def on_success() -> None:\n",
                "        os.rename(dest, real_dest)\n",
                "\n",
                "    compilation_database.add_command(desc, cmd, partial(newer, real_dest, *objects), on_success=on_success, key=CompileKey('', f'{module}.so'))\n",
                "\n",
                "\n",
                "def find_c_files() -> Tuple[List[str], List[str]]:\n",
                "    ans, headers = [], []\n",
                "    d = 'kitty'\n",
                "    exclude = {\n",
                "        'fontconfig.c', 'freetype.c', 'desktop.c', 'freetype_render_ui_text.c'\n",
                "    } if is_macos else {\n",
                "        'core_text.m', 'cocoa_window.m', 'macos_process_info.c'\n",
                "    }\n",
                "    for x in sorted(os.listdir(d)):\n",
                "        ext = os.path.splitext(x)[1]\n",
                "        if ext in ('.c', '.m') and os.path.basename(x) not in exclude:\n",
                "            ans.append(os.path.join('kitty', x))\n",
                "        elif ext == '.h':\n",
                "            headers.append(os.path.join('kitty', x))\n",
                "    ans.append('kitty/parser_dump.c')\n",
                "    return ans, headers\n",
                "\n",
                "\n",
                "def compile_glfw(compilation_database: CompilationDatabase) -> None:\n",
                "    modules = 'cocoa' if is_macos else 'x11 wayland'\n",
                "    for module in modules.split():\n",
                "        try:\n",
                "            genv = glfw.init_env(env, pkg_config, pkg_version, at_least_version, test_compile, module)\n",
                "        except SystemExit as err:\n",
                "            if module != 'wayland':\n",
                "                raise\n",
                "            print(err, file=sys.stderr)\n",
                "            print(error('Disabling building of wayland backend'), file=sys.stderr)\n",
                "            continue\n",
                "        sources = [os.path.join('glfw', x) for x in genv.sources]\n",
                "        all_headers = [os.path.join('glfw', x) for x in genv.all_headers]\n",
                "        if module == 'wayland':\n",
                "            try:\n",
                "                glfw.build_wayland_protocols(genv, parallel_run, emphasis, newer, 'glfw')\n",
                "            except SystemExit as err:\n",
                "                print(err, file=sys.stderr)\n",
                "                print(error('Disabling building of wayland backend'), file=sys.stderr)\n",
                "                continue\n",
                "        compile_c_extension(\n",
                "            genv, f'kitty/glfw-{module}', compilation_database,\n",
                "            sources, all_headers, desc_prefix=f'[{module}] ')\n",
                "\n",
                "\n",
                "def kittens_env() -> Env:\n",
                "    kenv = env.copy()\n",
                "    cflags = kenv.cflags\n",
                "    cflags.append('-pthread')\n",
                "    cflags.append('-Ikitty')\n",
                "    pylib = get_python_flags(cflags)\n",
                "    kenv.ldpaths += pylib\n",
                "    return kenv\n",
                "\n",
                "\n",
                "def compile_kittens(compilation_database: CompilationDatabase) -> None:\n",
                "    kenv = kittens_env()\n",
                "\n",
                "    def list_files(q: str) -> List[str]:\n",
                "        return sorted(glob.glob(q))\n",
                "\n",
                "    def files(\n",
                "            kitten: str,\n",
                "            output: str,\n",
                "            extra_headers: Sequence[str] = (),\n",
                "            extra_sources: Sequence[str] = (),\n",
                "            filter_sources: Optional[Callable[[str], bool]] = None,\n",
                "            includes: Sequence[str] = (), libraries: Sequence[str] = (),\n",
                "    ) -> Tuple[str, List[str], List[str], str, Sequence[str], Sequence[str]]:\n",
                "        sources = list(filter(filter_sources, list(extra_sources) + list_files(os.path.join('kittens', kitten, '*.c'))))\n",
                "        headers = list_files(os.path.join('kittens', kitten, '*.h')) + list(extra_headers)\n",
                "        return kitten, sources, headers, f'kittens/{kitten}/{output}', includes, libraries\n",
                "\n",
                "    for kitten, sources, all_headers, dest, includes, libraries in (\n",
                "        files('unicode_input', 'unicode_names'),\n",
                "        files('diff', 'diff_speedup'),\n",
                "        files('transfer', 'rsync', libraries=('rsync',)),\n",
                "        files(\n",
                "            'choose', 'subseq_matcher',\n",
                "            extra_headers=('kitty/charsets.h',),\n",
                "            extra_sources=('kitty/charsets.c',),\n",
                "            filter_sources=lambda x: 'windows_compat.c' not in x),\n",
                "    ):\n",
                "        final_env = kenv.copy()\n",
                "        final_env.cflags.extend(f'-I{x}' for x in includes)\n",
                "        final_env.ldpaths[:0] = list(f'-l{x}' for x in libraries)\n",
                "        compile_c_extension(\n",
                "            final_env, dest, compilation_database, sources, all_headers + ['kitty/data-types.h'])\n",
                "\n",
                "\n",
                "def init_env_from_args(args: Options, native_optimizations: bool = False) -> None:\n",
                "    global env\n",
                "    env = init_env(\n",
                "        args.debug, args.sanitize, native_optimizations, args.link_time_optimization, args.profile,\n",
                "        args.egl_library, args.startup_notification_library, args.canberra_library, args.fontconfig_library,\n",
                "        args.extra_logging, args.extra_include_dirs, args.ignore_compiler_warnings,\n",
                "        args.build_universal_binary, args.extra_library_dirs, verbose=args.verbose > 0\n",
                "    )\n",
                "\n",
                "\n",
                "@lru_cache\n",
                "def extract_rst_targets() -> Dict[str, Dict[str, str]]:\n",
                "    m = runpy.run_path('docs/extract-rst-targets.py')\n",
                "    return cast(Dict[str, Dict[str, str]], m['main']())\n",
                "\n",
                "\n",
                "def build_ref_map() -> str:\n",
                "    d = extract_rst_targets()\n",
                "    h = 'static const char docs_ref_map[] = {\\n' + textwrap.fill(', '.join(map(str, bytearray(json.dumps(d).encode('utf-8'))))) + '\\n};\\n'\n",
                "    dest = 'kitty/docs_ref_map_generated.h'\n",
                "    q = ''\n",
                "    with suppress(FileNotFoundError), open(dest) as f:\n",
                "        q = f.read()\n",
                "    if q != h:\n",
                "        with open(dest, 'w') as f:\n",
                "            f.write(h)\n",
                "    return dest\n",
                "\n",
                "\n",
                "@lru_cache\n",
                "def wrapped_kittens() -> str:\n",
                "    with open('shell-integration/ssh/kitty') as f:\n",
                "        for line in f:\n",
                "            if line.startswith('    wrapped_kittens=\"'):\n",
                "                val = line.strip().partition('\"')[2][:-1]\n",
                "                return ' '.join(sorted(filter(None, val.split())))\n",
                "    raise Exception('Failed to read wrapped kittens from kitty wrapper script')\n",
                "\n",
                "\n",
                "def build(args: Options, native_optimizations: bool = True, call_init: bool = True) -> None:\n",
                "    if call_init:\n",
                "        init_env_from_args(args, native_optimizations)\n",
                "    sources, headers = find_c_files()\n",
                "    headers.append(build_ref_map())\n",
                "    compile_c_extension(\n",
                "        kitty_env(), 'kitty/fast_data_types', args.compilation_database, sources, headers\n",
                "    )\n",
                "    compile_glfw(args.compilation_database)\n",
                "    compile_kittens(args.compilation_database)\n",
                "\n",
                "\n",
                "def safe_makedirs(path: str) -> None:\n",
                "    os.makedirs(path, exist_ok=True)\n",
                "\n",
                "\n",
                "def update_go_generated_files(args: Options, kitty_exe: str) -> None:\n",
                "    # update all the various auto-generated go files, if needed\n",
                "    if args.verbose:\n",
                "        print('Updating Go generated files...', flush=True)\n",
                "\n",
                "    env = os.environ.copy()\n",
                "    env['ASAN_OPTIONS'] = 'detect_leaks=0'\n",
                "    cp = subprocess.run([kitty_exe, '+launch', os.path.join(src_base, 'gen-go-code.py')], stdout=subprocess.PIPE, env=env)\n",
                "    if cp.returncode != 0:\n",
                "        raise SystemExit(cp.returncode)\n",
                "\n",
                "\n",
                "def build_static_kittens(\n",
                "    args: Options, launcher_dir: str, destination_dir: str = '', for_freeze: bool = False,\n",
                "    for_platform: Optional[Tuple[str, str]] = None\n",
                ") -> str:\n",
                "    sys.stdout.flush()\n",
                "    sys.stderr.flush()\n",
                "    go = shutil.which('go')\n",
                "    if not go:\n",
                "        raise SystemExit('The go tool was not found on this system. Install Go')\n",
                "    if not for_platform:\n",
                "        update_go_generated_files(args, os.path.join(launcher_dir, appname))\n",
                "    cmd = [go, 'build', '-v']\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    ld_flags = [f\"-X 'kitty.VCSRevision={get_vcs_rev_define()}'\"]\n"
                ],
                "after": [
                    "    vcs_rev = args.vcs_rev or get_vcs_rev()\n",
                    "    ld_flags = [f\"-X 'kitty.VCSRevision={vcs_rev}'\"]\n"
                ],
                "parent_version_range": {
                    "start": 910,
                    "end": 911
                },
                "child_version_range": {
                    "start": 913,
                    "end": 915
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "build_static_kittens",
                        "signature": "def build_static_kittens(\n    args: Options, launcher_dir: str, destination_dir: str = '', for_freeze: bool = False,\n    for_platform: Optional[Tuple[str, str]] = None\n)->str:",
                        "at_line": 898
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: setup.py\nCode:\n           def build_static_kittens(\n    args: Options, launcher_dir: str, destination_dir: str = '', for_freeze: bool = False,\n    for_platform: Optional[Tuple[str, str]] = None\n)->str:\n               ...\n907 910        if not for_platform:\n908 911            update_go_generated_files(args, os.path.join(launcher_dir, appname))\n909 912        cmd = [go, 'build', '-v']\n910      -     ld_flags = [f\"-X 'kitty.VCSRevision={get_vcs_rev_define()}'\"]\n    913  +     vcs_rev = args.vcs_rev or get_vcs_rev()\n    914  +     ld_flags = [f\"-X 'kitty.VCSRevision={vcs_rev}'\"]\n911 915        if for_freeze:\n912 916            ld_flags.append(\"-X 'kitty.IsFrozenBuild=true'\")\n913 917        if for_platform:\n         ...\n",
                "file_path": "setup.py",
                "identifiers_before": [
                    "get_vcs_rev_define",
                    "ld_flags"
                ],
                "identifiers_after": [
                    "args",
                    "get_vcs_rev",
                    "ld_flags",
                    "vcs_rev"
                ],
                "prefix": [
                    "    if not for_platform:\n",
                    "        update_go_generated_files(args, os.path.join(launcher_dir, appname))\n",
                    "    cmd = [go, 'build', '-v']\n"
                ],
                "suffix": [
                    "    if for_freeze:\n",
                    "        ld_flags.append(\"-X 'kitty.IsFrozenBuild=true'\")\n",
                    "    if for_platform:\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "get_vcs_rev_define",
                            "position": {
                                "start": {
                                    "line": 910,
                                    "column": 41
                                },
                                "end": {
                                    "line": 910,
                                    "column": 59
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "get_vcs_rev",
                            "position": {
                                "start": {
                                    "line": 913,
                                    "column": 30
                                },
                                "end": {
                                    "line": 913,
                                    "column": 41
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/setup.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    if for_freeze:\n",
                "        ld_flags.append(\"-X 'kitty.IsFrozenBuild=true'\")\n",
                "    if for_platform:\n",
                "        ld_flags.append(\"-X 'kitty.IsStandaloneBuild=true'\")\n",
                "    if not args.debug:\n",
                "        ld_flags.append('-s')\n",
                "        ld_flags.append('-w')\n",
                "    cmd += ['-ldflags', ' '.join(ld_flags)]\n",
                "    dest = os.path.join(destination_dir or launcher_dir, 'kitten')\n",
                "    if for_platform:\n",
                "        dest += f'-{for_platform[0]}-{for_platform[1]}'\n",
                "    src = os.path.abspath('tools/cmd')\n",
                "\n",
                "    def run_one(dest: str, **env: str) -> None:\n",
                "        c = cmd + ['-o', dest, src]\n",
                "        if args.verbose:\n",
                "            print(shlex.join(c))\n",
                "        e = os.environ.copy()\n",
                "        e.update(env)\n",
                "        # https://github.com/kovidgoyal/kitty/issues/6051#issuecomment-1441369828\n",
                "        e.pop('PWD', None)\n",
                "        if for_platform:\n",
                "            e['CGO_ENABLED'] = '0'\n",
                "            e['GOOS'] = for_platform[0]\n",
                "            e['GOARCH'] = for_platform[1]\n",
                "        cp = subprocess.run(c, env=e)\n",
                "        if cp.returncode != 0:\n",
                "            raise SystemExit(cp.returncode)\n",
                "\n",
                "    if args.build_universal_binary and not for_platform:\n",
                "        outs = []\n",
                "        for arch in ('amd64', 'arm64'):\n",
                "            d = dest + f'-{arch}'\n",
                "            run_one(d, GOOS='darwin', GOARCH=arch)\n",
                "            outs.append(d)\n",
                "        subprocess.check_call(['lipo', '-create', '-output', dest] + outs)\n",
                "        for x in outs:\n",
                "            os.remove(x)\n",
                "    else:\n",
                "        run_one(dest)\n",
                "    return dest\n",
                "\n",
                "\n",
                "def build_static_binaries(args: Options, launcher_dir: str) -> None:\n",
                "    arches = 'amd64', 'arm64'\n",
                "    for os_, arches_ in {\n",
                "        'darwin': arches, 'linux': arches + ('arm', '386'), 'freebsd': arches, 'netbsd': arches, 'openbsd': arches,\n",
                "        'dragonfly': ('amd64',),\n",
                "    }.items():\n",
                "        for arch in arches_:\n",
                "            print('Cross compiling static kitten for:', os_, arch)\n",
                "            build_static_kittens(args, launcher_dir, args.dir_for_static_binaries, for_platform=(os_, arch))\n",
                "\n",
                "\n",
                "def build_launcher(args: Options, launcher_dir: str = '.', bundle_type: str = 'source') -> None:\n",
                "    werror = '' if args.ignore_compiler_warnings else '-pedantic-errors -Werror'\n",
                "    cflags = f'-Wall {werror} -fpie'.split()\n",
                "    cppflags = [define(f'WRAPPED_KITTENS=\" {wrapped_kittens()} \"')]\n",
                "    libs: List[str] = []\n",
                "    ldflags = shlex.split(os.environ.get('LDFLAGS', ''))\n",
                "    if args.profile or args.sanitize:\n",
                "        if args.sanitize:\n",
                "            cflags.append('-g3')\n",
                "            sanitize_args = get_sanitize_args(env.cc, env.ccver)\n",
                "            cflags.extend(sanitize_args)\n",
                "            ldflags.extend(sanitize_args)\n",
                "            libs += ['-lasan'] if is_gcc(env.cc) and not is_macos else []\n",
                "        else:\n",
                "            cflags.append('-g')\n",
                "        if args.profile:\n",
                "            libs.append('-lprofiler')\n",
                "    else:\n",
                "        cflags.append('-g3' if args.debug else '-O3')\n",
                "    if bundle_type.endswith('-freeze'):\n",
                "        cppflags.append('-DFOR_BUNDLE')\n",
                "        cppflags.append(f'-DPYVER=\"{sysconfig.get_python_version()}\"')\n",
                "        cppflags.append(f'-DKITTY_LIB_DIR_NAME=\"{args.libdir_name}\"')\n",
                "    elif bundle_type == 'source':\n",
                "        cppflags.append('-DFROM_SOURCE')\n",
                "    if bundle_type.startswith('macos-'):\n",
                "        klp = '../Resources/kitty'\n",
                "    elif bundle_type.startswith('linux-'):\n",
                "        klp = '../{}/kitty'.format(args.libdir_name.strip('/'))\n",
                "    elif bundle_type == 'source':\n",
                "        klp = os.path.relpath('.', launcher_dir)\n",
                "    else:\n",
                "        raise SystemExit(f'Unknown bundle type: {bundle_type}')\n",
                "    cppflags.append(f'-DKITTY_LIB_PATH=\"{klp}\"')\n",
                "    pylib = get_python_flags(cflags, for_main_executable=True)\n",
                "    cppflags += shlex.split(os.environ.get('CPPFLAGS', ''))\n",
                "    cflags += shlex.split(os.environ.get('CFLAGS', ''))\n",
                "    for path in args.extra_include_dirs:\n",
                "        cflags.append(f'-I{path}')\n",
                "    if args.build_universal_binary:\n",
                "        set_arches(cflags)\n",
                "        set_arches(ldflags)\n",
                "    if bundle_type == 'linux-freeze':\n",
                "        # --disable-new-dtags prevents -rpath from generating RUNPATH instead of\n",
                "        # RPATH entries in the launcher. The ld dynamic linker does not search\n",
                "        # RUNPATH locations for transitive dependencies, unlike RPATH.\n",
                "        ldflags += ['-Wl,--disable-new-dtags', '-Wl,-rpath,$ORIGIN/../lib']\n",
                "    os.makedirs(launcher_dir, exist_ok=True)\n",
                "    os.makedirs(build_dir, exist_ok=True)\n",
                "    objects = []\n",
                "    for src in ('kitty/launcher/main.c',):\n",
                "        obj = os.path.join(build_dir, src.replace('/', '-').replace('.c', '.o'))\n",
                "        objects.append(obj)\n",
                "        cmd = env.cc + cppflags + cflags + ['-c', src, '-o', obj]\n",
                "        key = CompileKey(src, os.path.basename(obj))\n",
                "        args.compilation_database.add_command(f'Compiling {emphasis(src)} ...', cmd, partial(newer, obj, src), key=key, keyfile=src)\n",
                "    dest = os.path.join(launcher_dir, 'kitty')\n",
                "    desc = f'Linking {emphasis(\"launcher\")} ...'\n",
                "    cmd = env.cc + ldflags + objects + libs + pylib + ['-o', dest]\n",
                "    args.compilation_database.add_command(desc, cmd, partial(newer, dest, *objects), key=CompileKey('', 'kitty'))\n",
                "    args.compilation_database.build_all()\n",
                "\n",
                "\n",
                "# Packaging {{{\n",
                "def copy_man_pages(ddir: str) -> None:\n",
                "    mandir = os.path.join(ddir, 'share', 'man')\n",
                "    safe_makedirs(mandir)\n",
                "    man_levels = '15'\n",
                "    with suppress(FileNotFoundError):\n",
                "        for x in man_levels:\n",
                "            shutil.rmtree(os.path.join(mandir, f'man{x}'))\n",
                "    src = 'docs/_build/man'\n",
                "    if not os.path.exists(src):\n",
                "        raise SystemExit('''\\\n",
                "The kitty man pages are missing. If you are building from git then run:\n",
                "make && make docs\n",
                "(needs the sphinx documentation system to be installed)\n",
                "''')\n",
                "    for x in man_levels:\n",
                "        os.makedirs(os.path.join(mandir, f'man{x}'))\n",
                "        for y in glob.glob(os.path.join(src, f'*.{x}')):\n",
                "            shutil.copy2(y, os.path.join(mandir, f'man{x}'))\n",
                "\n",
                "\n",
                "def copy_html_docs(ddir: str) -> None:\n",
                "    htmldir = os.path.join(ddir, 'share', 'doc', appname, 'html')\n",
                "    safe_makedirs(os.path.dirname(htmldir))\n",
                "    with suppress(FileNotFoundError):\n",
                "        shutil.rmtree(htmldir)\n",
                "    src = 'docs/_build/html'\n",
                "    if not os.path.exists(src):\n",
                "        raise SystemExit('''\\\n",
                "The kitty html docs are missing. If you are building from git then run:\n",
                "make && make docs\n",
                "(needs the sphinx documentation system to be installed)\n",
                "''')\n",
                "    shutil.copytree(src, htmldir)\n",
                "\n",
                "\n",
                "def compile_python(base_path: str) -> None:\n",
                "    import compileall\n",
                "    import py_compile\n",
                "    try:\n",
                "        num_workers = max(1, os.cpu_count() or 1)\n",
                "    except Exception:\n",
                "        num_workers = 1\n",
                "    for root, dirs, files in os.walk(base_path):\n",
                "        for f in files:\n",
                "            if f.rpartition('.')[-1] in ('pyc', 'pyo'):\n",
                "                os.remove(os.path.join(root, f))\n",
                "\n",
                "    exclude = re.compile('.*/shell-integration/ssh/bootstrap.py')\n",
                "\n",
                "    def c(base_path: str, **kw: object) -> None:\n",
                "        try:\n",
                "            kw['invalidation_mode'] = py_compile.PycInvalidationMode.UNCHECKED_HASH\n",
                "        except AttributeError:\n",
                "            pass\n",
                "        compileall.compile_dir(base_path, **kw)  # type: ignore\n",
                "\n",
                "    for optimize in (0, 1, 2):\n",
                "        c(base_path, ddir='', rx=exclude, force=True, optimize=optimize, quiet=1, workers=num_workers)\n",
                "\n",
                "\n",
                "def create_linux_bundle_gunk(ddir: str, libdir_name: str) -> None:\n",
                "    if not os.path.exists('docs/_build/html'):\n",
                "        make = 'gmake' if is_freebsd else 'make'\n",
                "        run_tool([make, 'docs'])\n",
                "    copy_man_pages(ddir)\n",
                "    copy_html_docs(ddir)\n",
                "    for (icdir, ext) in {'256x256': 'png', 'scalable': 'svg'}.items():\n",
                "        icdir = os.path.join(ddir, 'share', 'icons', 'hicolor', icdir, 'apps')\n",
                "        safe_makedirs(icdir)\n",
                "        shutil.copy2(f'logo/kitty.{ext}', icdir)\n",
                "    deskdir = os.path.join(ddir, 'share', 'applications')\n",
                "    safe_makedirs(deskdir)\n",
                "    with open(os.path.join(deskdir, 'kitty.desktop'), 'w') as f:\n",
                "        f.write(\n",
                "            '''\\\n",
                "[Desktop Entry]\n",
                "Version=1.0\n",
                "Type=Application\n",
                "Name=kitty\n",
                "GenericName=Terminal emulator\n",
                "Comment=Fast, feature-rich, GPU based terminal\n",
                "TryExec=kitty\n",
                "Exec=kitty\n",
                "Icon=kitty\n",
                "Categories=System;TerminalEmulator;\n",
                "'''\n",
                "            )\n",
                "    with open(os.path.join(deskdir, 'kitty-open.desktop'), 'w') as f:\n",
                "        f.write(\n",
                "            '''\\\n",
                "[Desktop Entry]\n",
                "Version=1.0\n",
                "Type=Application\n",
                "Name=kitty URL Launcher\n",
                "GenericName=Terminal emulator\n",
                "Comment=Open URLs with kitty\n",
                "TryExec=kitty\n",
                "Exec=kitty +open %U\n",
                "Icon=kitty\n",
                "Categories=System;TerminalEmulator;\n",
                "NoDisplay=true\n",
                "MimeType=image/*;application/x-sh;application/x-shellscript;inode/directory;text/*;x-scheme-handler/kitty;x-scheme-handler/ssh;\n",
                "'''\n",
                "            )\n",
                "\n",
                "    base = Path(ddir)\n",
                "    in_src_launcher = base / (f'{libdir_name}/kitty/kitty/launcher/kitty')\n",
                "    launcher = base / 'bin/kitty'\n",
                "    if os.path.exists(in_src_launcher):\n",
                "        os.remove(in_src_launcher)\n",
                "    os.makedirs(os.path.dirname(in_src_launcher), exist_ok=True)\n",
                "    os.symlink(os.path.relpath(launcher, os.path.dirname(in_src_launcher)), in_src_launcher)\n",
                "\n",
                "\n",
                "def macos_info_plist() -> bytes:\n",
                "    import plistlib\n",
                "    VERSION = '.'.join(map(str, version))\n",
                "\n",
                "    def access(what: str, verb: str = 'would like to access') -> str:\n",
                "        return f'A program running inside kitty {verb} {what}'\n",
                "\n",
                "    docs = [\n",
                "        {\n",
                "            'CFBundleTypeName': 'Terminal scripts',\n",
                "            'CFBundleTypeExtensions': ['command', 'sh', 'zsh', 'bash', 'fish', 'tool'],\n",
                "            'CFBundleTypeIconFile': f'{appname}.icns',\n",
                "            'CFBundleTypeRole': 'Editor',\n",
                "        },\n",
                "        {\n",
                "            'CFBundleTypeName': 'Folders',\n",
                "            'LSItemContentTypes': ['public.directory'],\n",
                "            'CFBundleTypeRole': 'Editor',\n",
                "            'LSHandlerRank': 'Alternate',\n",
                "        },\n",
                "        {\n",
                "            'LSItemContentTypes': ['public.unix-executable'],\n",
                "            'CFBundleTypeRole': 'Shell',\n",
                "        },\n",
                "        {\n",
                "            'CFBundleTypeName': 'Text files',\n",
                "            'LSItemContentTypes': ['public.text'],\n",
                "            'CFBundleTypeRole': 'Editor',\n",
                "            'LSHandlerRank': 'Alternate',\n",
                "        },\n",
                "        {\n",
                "            'CFBundleTypeName': 'Image files',\n",
                "            'LSItemContentTypes': ['public.image'],\n",
                "            'CFBundleTypeRole': 'Viewer',\n",
                "            'LSHandlerRank': 'Alternate',\n",
                "        },\n",
                "        # Allows dragging arbitrary files to kitty Dock icon, and list kitty in the Open With context menu.\n",
                "        {\n",
                "            'CFBundleTypeName': 'All files',\n",
                "            'LSItemContentTypes': ['public.archive', 'public.content', 'public.data'],\n",
                "            'CFBundleTypeRole': 'Editor',\n",
                "            'LSHandlerRank': 'Alternate',\n",
                "        },\n",
                "    ]\n",
                "\n",
                "    url_schemes = [\n",
                "        {\n",
                "            'CFBundleURLName': 'File URL',\n",
                "            'CFBundleURLSchemes': ['file'],\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'FTP URL',\n",
                "            'CFBundleURLSchemes': ['ftp', 'ftps'],\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'Gemini URL',\n",
                "            'CFBundleURLSchemes': ['gemini'],\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'Git URL',\n",
                "            'CFBundleURLSchemes': ['git'],\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'Gopher URL',\n",
                "            'CFBundleURLSchemes': ['gopher'],\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'HTTP URL',\n",
                "            'CFBundleURLSchemes': ['http', 'https'],\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'IRC URL',\n",
                "            'CFBundleURLSchemes': ['irc', 'irc6', 'ircs'],\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'kitty URL',\n",
                "            'CFBundleURLSchemes': ['kitty'],\n",
                "            'LSHandlerRank': 'Owner',\n",
                "            'LSIsAppleDefaultForScheme': True,\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'Mail Address URL',\n",
                "            'CFBundleURLSchemes': ['mailto'],\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'News URL',\n",
                "            'CFBundleURLSchemes': ['news', 'nntp'],\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'SSH and SFTP URL',\n",
                "            'CFBundleURLSchemes': ['ssh', 'sftp'],\n",
                "        },\n",
                "        {\n",
                "            'CFBundleURLName': 'Telnet URL',\n",
                "            'CFBundleURLSchemes': ['telnet'],\n",
                "        },\n",
                "    ]\n",
                "\n",
                "    services = [\n",
                "        {\n",
                "            'NSMenuItem': {'default': f'New {appname} Tab Here'},\n",
                "            'NSMessage': 'openTab',\n",
                "            'NSRequiredContext': {'NSTextContent': 'FilePath'},\n",
                "            'NSSendTypes': ['NSFilenamesPboardType', 'public.plain-text'],\n",
                "        },\n",
                "        {\n",
                "            'NSMenuItem': {'default': f'New {appname} Window Here'},\n",
                "            'NSMessage': 'openOSWindow',\n",
                "            'NSRequiredContext': {'NSTextContent': 'FilePath'},\n",
                "            'NSSendTypes': ['NSFilenamesPboardType', 'public.plain-text'],\n",
                "        },\n",
                "        {\n",
                "            'NSMenuItem': {'default': f'Open with {appname}'},\n",
                "            'NSMessage': 'openFileURLs',\n",
                "            'NSRequiredContext': {'NSTextContent': 'FilePath'},\n",
                "            'NSSendTypes': ['NSFilenamesPboardType', 'public.plain-text'],\n",
                "        },\n",
                "    ]\n",
                "\n",
                "    pl = dict(\n",
                "        # Naming\n",
                "        CFBundleName=appname,\n",
                "        CFBundleDisplayName=appname,\n",
                "        # Identification\n",
                "        CFBundleIdentifier=f'net.kovidgoyal.{appname}',\n",
                "        # Bundle Version Info\n",
                "        CFBundleVersion=VERSION,\n",
                "        CFBundleShortVersionString=VERSION,\n",
                "        CFBundleInfoDictionaryVersion='6.0',\n",
                "        NSHumanReadableCopyright=time.strftime('Copyright %Y, Kovid Goyal'),\n",
                "        CFBundleGetInfoString='kitty - The fast, feature-rich, GPU based terminal emulator. https://sw.kovidgoyal.net/kitty/',\n",
                "        # Operating System Version\n",
                "        LSMinimumSystemVersion='10.12.0',\n",
                "        # Categorization\n",
                "        CFBundlePackageType='APPL',\n",
                "        CFBundleSignature='????',\n",
                "        LSApplicationCategoryType='public.app-category.utilities',\n",
                "        # App Execution\n",
                "        CFBundleExecutable=appname,\n",
                "        LSEnvironment={'KITTY_LAUNCHED_BY_LAUNCH_SERVICES': '1'},\n",
                "        LSRequiresNativeExecution=True,\n",
                "        NSSupportsSuddenTermination=False,\n",
                "        # Localization\n",
                "        # see https://github.com/kovidgoyal/kitty/issues/1233\n",
                "        CFBundleDevelopmentRegion='English',\n",
                "        CFBundleAllowMixedLocalizations=True,\n",
                "        TICapsLockLanguageSwitchCapable=True,\n",
                "        # User Interface and Graphics\n",
                "        CFBundleIconFile=f'{appname}.icns',\n",
                "        NSHighResolutionCapable=True,\n",
                "        NSSupportsAutomaticGraphicsSwitching=True,\n",
                "        # Needed for dark mode in Mojave when linking against older SDKs\n",
                "        NSRequiresAquaSystemAppearance='NO',\n",
                "        # Document and URL Types\n",
                "        CFBundleDocumentTypes=docs,\n",
                "        CFBundleURLTypes=url_schemes,\n",
                "        # Services\n",
                "        NSServices=services,\n",
                "        # Calendar and Reminders\n",
                "        NSCalendarsUsageDescription=access('your calendar data.'),\n",
                "        NSRemindersUsageDescription=access('your reminders.'),\n",
                "        # Camera and Microphone\n",
                "        NSCameraUsageDescription=access('the camera.'),\n",
                "        NSMicrophoneUsageDescription=access('the microphone.'),\n",
                "        # Contacts\n",
                "        NSContactsUsageDescription=access('your contacts.'),\n",
                "        # Location\n",
                "        NSLocationUsageDescription=access('your location information.'),\n",
                "        NSLocationTemporaryUsageDescriptionDictionary=access('your location temporarily.'),\n",
                "        # Motion\n",
                "        NSMotionUsageDescription=access('motion data.'),\n",
                "        # Networking\n",
                "        NSLocalNetworkUsageDescription=access('local network.'),\n",
                "        # Photos\n",
                "        NSPhotoLibraryUsageDescription=access('your photo library.'),\n",
                "        # Scripting\n",
                "        NSAppleScriptEnabled=False,\n",
                "        # Security\n",
                "        NSAppleEventsUsageDescription=access('AppleScript.'),\n",
                "        NSSystemAdministrationUsageDescription=access('elevated privileges.', 'requires'),\n",
                "        # Speech\n",
                "        NSSpeechRecognitionUsageDescription=access('speech recognition.'),\n",
                "    )\n",
                "    return plistlib.dumps(pl)\n",
                "\n",
                "\n",
                "def create_macos_app_icon(where: str = 'Resources') -> None:\n",
                "    iconset_dir = os.path.abspath(os.path.join('logo', f'{appname}.iconset'))\n",
                "    icns_dir = os.path.join(where, f'{appname}.icns')\n",
                "    try:\n",
                "        subprocess.check_call([\n",
                "            'iconutil', '-c', 'icns', iconset_dir, '-o', icns_dir\n",
                "        ])\n",
                "    except FileNotFoundError:\n",
                "        print(f'{error(\"iconutil not found\")}, using png2icns (without retina support) to convert the logo', file=sys.stderr)\n",
                "        subprocess.check_call([\n",
                "            'png2icns', icns_dir\n",
                "        ] + [os.path.join(iconset_dir, logo) for logo in [\n",
                "            # png2icns does not support retina icons, so only pass the non-retina icons\n",
                "            'icon_16x16.png',\n",
                "            'icon_32x32.png',\n",
                "            'icon_128x128.png',\n",
                "            'icon_256x256.png',\n",
                "            'icon_512x512.png',\n",
                "        ]])\n",
                "\n",
                "\n",
                "def create_minimal_macos_bundle(args: Options, launcher_dir: str) -> None:\n",
                "    kapp = os.path.join(launcher_dir, 'kitty.app')\n",
                "    if os.path.exists(kapp):\n",
                "        shutil.rmtree(kapp)\n",
                "    bin_dir = os.path.join(kapp, 'Contents/MacOS')\n",
                "    resources_dir = os.path.join(kapp, 'Contents/Resources')\n",
                "    os.makedirs(resources_dir)\n",
                "    os.makedirs(bin_dir)\n",
                "    with open(os.path.join(kapp, 'Contents/Info.plist'), 'wb') as f:\n",
                "        f.write(macos_info_plist())\n",
                "    build_launcher(args, bin_dir)\n",
                "    build_static_kittens(args, launcher_dir=bin_dir)\n",
                "    kitty_exe = os.path.join(launcher_dir, appname)\n",
                "    with suppress(FileNotFoundError):\n",
                "        os.remove(kitty_exe)\n",
                "    os.symlink(os.path.join(os.path.relpath(bin_dir, launcher_dir), appname), kitty_exe)\n",
                "    create_macos_app_icon(resources_dir)\n",
                "\n",
                "\n",
                "def create_macos_bundle_gunk(dest: str, for_freeze: bool, args: Options) -> str:\n",
                "    ddir = Path(dest)\n",
                "    os.mkdir(ddir / 'Contents')\n",
                "    with open(ddir / 'Contents/Info.plist', 'wb') as fp:\n",
                "        fp.write(macos_info_plist())\n",
                "    copy_man_pages(str(ddir))\n",
                "    copy_html_docs(str(ddir))\n",
                "    os.rename(ddir / 'share', ddir / 'Contents/Resources')\n",
                "    os.rename(ddir / 'bin', ddir / 'Contents/MacOS')\n",
                "    os.rename(ddir / 'lib', ddir / 'Contents/Frameworks')\n",
                "    os.rename(ddir / 'Contents/Frameworks/kitty', ddir / 'Contents/Resources/kitty')\n",
                "    kitty_exe = ddir / 'Contents/MacOS/kitty'\n",
                "    in_src_launcher = ddir / 'Contents/Resources/kitty/kitty/launcher/kitty'\n",
                "    if os.path.exists(in_src_launcher):\n",
                "        os.remove(in_src_launcher)\n",
                "    os.makedirs(os.path.dirname(in_src_launcher), exist_ok=True)\n",
                "    os.symlink(os.path.relpath(kitty_exe, os.path.dirname(in_src_launcher)), in_src_launcher)\n",
                "    create_macos_app_icon(os.path.join(ddir, 'Contents', 'Resources'))\n",
                "    if not for_freeze:\n",
                "        kitten_exe = build_static_kittens(args, launcher_dir=os.path.dirname(kitty_exe))\n",
                "        os.symlink(os.path.relpath(kitten_exe, os.path.dirname(in_src_launcher)),\n",
                "                   os.path.join(os.path.dirname(in_src_launcher), os.path.basename(kitten_exe)))\n",
                "    return str(kitty_exe)\n",
                "\n",
                "\n",
                "def package(args: Options, bundle_type: str) -> None:\n",
                "    ddir = args.prefix\n",
                "    for_freeze = bundle_type.endswith('-freeze')\n",
                "    if bundle_type == 'linux-freeze':\n",
                "        args.libdir_name = 'lib'\n",
                "    libdir = os.path.join(ddir, args.libdir_name.strip('/'), 'kitty')\n",
                "    if os.path.exists(libdir):\n",
                "        shutil.rmtree(libdir)\n",
                "    launcher_dir = os.path.join(ddir, 'bin')\n",
                "    safe_makedirs(launcher_dir)\n",
                "    if for_freeze:  # freeze launcher is built separately\n",
                "        args.compilation_database.build_all()\n",
                "    else:\n",
                "        build_launcher(args, launcher_dir, bundle_type)\n",
                "    os.makedirs(os.path.join(libdir, 'logo'))\n",
                "    build_terminfo = runpy.run_path('build-terminfo', run_name='import_build')\n",
                "    for x in (libdir, os.path.join(ddir, 'share')):\n",
                "        odir = os.path.join(x, 'terminfo')\n",
                "        safe_makedirs(odir)\n",
                "        build_terminfo['compile_terminfo'](odir)\n",
                "    shutil.copy2('terminfo/kitty.terminfo', os.path.join(libdir, 'terminfo'))\n",
                "    shutil.copy2('terminfo/kitty.termcap', os.path.join(libdir, 'terminfo'))\n",
                "    shutil.copy2('__main__.py', libdir)\n",
                "    shutil.copy2('logo/kitty-128.png', os.path.join(libdir, 'logo'))\n",
                "    shutil.copy2('logo/kitty.png', os.path.join(libdir, 'logo'))\n",
                "    shutil.copy2('logo/beam-cursor.png', os.path.join(libdir, 'logo'))\n",
                "    shutil.copy2('logo/beam-cursor@2x.png', os.path.join(libdir, 'logo'))\n",
                "    shutil.copytree('shell-integration', os.path.join(libdir, 'shell-integration'), dirs_exist_ok=True)\n",
                "    allowed_extensions = frozenset('py glsl so'.split())\n",
                "\n",
                "    def src_ignore(parent: str, entries: Iterable[str]) -> List[str]:\n",
                "        return [\n",
                "            x for x in entries\n",
                "            if '.' in x and x.rpartition('.')[2] not in\n",
                "            allowed_extensions\n",
                "        ]\n",
                "\n",
                "    shutil.copytree('kitty', os.path.join(libdir, 'kitty'), ignore=src_ignore)\n",
                "    shutil.copytree('kittens', os.path.join(libdir, 'kittens'), ignore=src_ignore)\n",
                "    if for_freeze:\n",
                "        shutil.copytree('kitty_tests', os.path.join(libdir, 'kitty_tests'))\n",
                "\n",
                "    def repl(name: str, raw: str, defval: Union[str, float, FrozenSet[str]], val: Union[str, float, FrozenSet[str]]) -> str:\n",
                "        if defval == val:\n",
                "            return raw\n",
                "        tname = type(defval).__name__\n",
                "        if tname == 'frozenset':\n",
                "            tname = 'typing.FrozenSet[str]'\n",
                "        prefix = f'{name}: {tname} ='\n",
                "        nraw = raw.replace(f'{prefix} {defval!r}', f'{prefix} {val!r}', 1)\n",
                "        if nraw == raw:\n",
                "            raise SystemExit(f'Failed to change the value of {name}')\n",
                "        return nraw\n",
                "\n",
                "    with open(os.path.join(libdir, 'kitty/options/types.py'), 'r+', encoding='utf-8') as f:\n",
                "        oraw = raw = f.read()\n",
                "        raw = repl('update_check_interval', raw, Options.update_check_interval, args.update_check_interval)\n",
                "        raw = repl('shell_integration', raw, frozenset(Options.shell_integration.split()), frozenset(args.shell_integration.split()))\n",
                "        if raw != oraw:\n",
                "            f.seek(0), f.truncate(), f.write(raw)\n",
                "\n",
                "    compile_python(libdir)\n",
                "\n",
                "    def should_be_executable(path: str) -> bool:\n",
                "        if path.endswith('.so'):\n",
                "            return True\n",
                "        q = path.split(os.sep)[-2:]\n",
                "        if len(q) == 2 and q[0] == 'ssh' and q[1] in ('kitty', 'kitten'):\n",
                "            return True\n",
                "        return False\n",
                "\n",
                "    for root, dirs, files in os.walk(libdir):\n",
                "        for f_ in files:\n",
                "            path = os.path.join(root, f_)\n",
                "            os.chmod(path, 0o755 if should_be_executable(path) else 0o644)\n",
                "    if not for_freeze and not bundle_type.startswith('macos-'):\n",
                "        build_static_kittens(args, launcher_dir=launcher_dir)\n",
                "    if not is_macos:\n",
                "        create_linux_bundle_gunk(ddir, args.libdir_name)\n",
                "\n",
                "    if bundle_type.startswith('macos-'):\n",
                "        create_macos_bundle_gunk(ddir, for_freeze, args)\n",
                "# }}}\n",
                "\n",
                "\n",
                "def clean_launcher_dir(launcher_dir: str) -> None:\n",
                "    for x in glob.glob(os.path.join(launcher_dir, 'kitt*')):\n",
                "        if os.path.isdir(x):\n",
                "            shutil.rmtree(x)\n",
                "        else:\n",
                "            os.remove(x)\n",
                "\n",
                "\n",
                "def clean() -> None:\n",
                "\n",
                "    def safe_remove(*entries: str) -> None:\n",
                "        for x in entries:\n",
                "            if os.path.exists(x):\n",
                "                if os.path.isdir(x):\n",
                "                    shutil.rmtree(x)\n",
                "                else:\n",
                "                    os.unlink(x)\n",
                "\n",
                "    safe_remove(\n",
                "        'build', 'compile_commands.json', 'link_commands.json',\n",
                "        'linux-package', 'kitty.app', 'asan-launcher',\n",
                "        'kitty-profile', 'docs/generated')\n",
                "    clean_launcher_dir('kitty/launcher')\n",
                "\n",
                "    def excluded(root: str, d: str) -> bool:\n",
                "        q = os.path.relpath(os.path.join(root, d), src_base).replace(os.sep, '/')\n",
                "        return q in ('.git', 'bypy/b')\n",
                "\n",
                "    for root, dirs, files in os.walk(src_base, topdown=True):\n",
                "        dirs[:] = [d for d in dirs if not excluded(root, d)]\n",
                "        remove_dirs = {d for d in dirs if d == '__pycache__' or d.endswith('.dSYM')}\n",
                "        for d in remove_dirs:\n",
                "            shutil.rmtree(os.path.join(root, d))\n",
                "            dirs.remove(d)\n",
                "        for f in files:\n",
                "            ext = f.rpartition('.')[-1]\n",
                "            if ext in ('so', 'dylib', 'pyc', 'pyo') or f.endswith('_generated.h') or f.endswith('_generated.go') or f.endswith('_generated.bin'):\n",
                "                os.unlink(os.path.join(root, f))\n",
                "    for x in glob.glob('glfw/wayland-*-protocol.[ch]'):\n",
                "        os.unlink(x)\n",
                "    subprocess.check_call(['go', 'clean', '-cache', '-testcache', '-modcache', '-fuzzcache'])\n",
                "\n",
                "\n",
                "def option_parser() -> argparse.ArgumentParser:  # {{{\n",
                "    p = argparse.ArgumentParser()\n",
                "    p.add_argument(\n",
                "        'action',\n",
                "        nargs='?',\n",
                "        default=Options.action,\n",
                "        choices=('build',\n",
                "                 'test',\n",
                "                 'linux-package',\n",
                "                 'kitty.app',\n",
                "                 'linux-freeze',\n",
                "                 'macos-freeze',\n",
                "                 'build-launcher',\n",
                "                 'build-frozen-launcher',\n",
                "                 'build-frozen-tools',\n",
                "                 'clean',\n",
                "                 'export-ci-bundles',\n",
                "                 'build-dep',\n",
                "                 'build-static-binaries',\n",
                "                 ),\n",
                "        help='Action to perform (default is build)'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--debug',\n",
                "        default=Options.debug,\n",
                "        action='store_true',\n",
                "        help='Build extension modules with debugging symbols'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '-v', '--verbose',\n",
                "        default=Options.verbose,\n",
                "        action='count',\n",
                "        help='Be verbose'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--sanitize',\n",
                "        default=Options.sanitize,\n",
                "        action='store_true',\n",
                "        help='Turn on sanitization to detect memory access errors and undefined behavior. This is a big performance hit.'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--prefix',\n",
                "        default=Options.prefix,\n",
                "        help='Where to create the linux package'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--dir-for-static-binaries',\n",
                "        default=Options.dir_for_static_binaries,\n",
                "        help='Where to create the static kitten binary'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--full',\n",
                "        dest='incremental',\n",
                "        default=Options.incremental,\n",
                "        action='store_false',\n",
                "        help='Do a full build, even for unchanged files'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--profile',\n",
                "        default=Options.profile,\n",
                "        action='store_true',\n",
                "        help='Use the -pg compile flag to add profiling information'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--libdir-name',\n",
                "        default=Options.libdir_name,\n",
                "        help='The name of the directory inside --prefix in which to store compiled files. Defaults to \"lib\"'\n",
                "    )\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    p.add_argument(\n",
                    "        '--vcs-rev', default='',\n",
                    "        help='The VCS revision to embed in the binary. The default is to read it from the .git directory when present.'\n",
                    "    )\n"
                ],
                "parent_version_range": {
                    "start": 1590,
                    "end": 1590
                },
                "child_version_range": {
                    "start": 1594,
                    "end": 1598
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "option_parser",
                        "signature": "def option_parser()->argparse.ArgumentParser:",
                        "at_line": 1522
                    },
                    {
                        "type": "call",
                        "name": "p.add_argument",
                        "signature": "p.add_argument(\n        '--libdir-name',\n        default=Options.libdir_name,\n        help='The name of the directory inside --prefix in which to store compiled files. Defaults to \"lib\"'\n    )",
                        "at_line": 1585
                    }
                ],
                "idx": 8,
                "hunk_diff": "File: setup.py\nCode:\n             def option_parser()->argparse.ArgumentParser:\n                 ...\n                 p.add_argument(\n        '--libdir-name',\n        default=Options.libdir_name,\n        help='The name of the directory inside --prefix in which to store compiled files. Defaults to \"lib\"'\n    )\n                     ...\n1587 1591            default=Options.libdir_name,\n1588 1592            help='The name of the directory inside --prefix in which to store compiled files. Defaults to \"lib\"'\n1589 1593        )\n     1594  +     p.add_argument(\n     1595  +         '--vcs-rev', default='',\n     1596  +         help='The VCS revision to embed in the binary. The default is to read it from the .git directory when present.'\n     1597  +     )\n1590 1598        p.add_argument(\n1591 1599            '--extra-logging',\n1592 1600            action='append',\n           ...\n",
                "file_path": "setup.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "add_argument",
                    "default",
                    "help",
                    "p"
                ],
                "prefix": [
                    "        default=Options.libdir_name,\n",
                    "        help='The name of the directory inside --prefix in which to store compiled files. Defaults to \"lib\"'\n",
                    "    )\n"
                ],
                "suffix": [
                    "    p.add_argument(\n",
                    "        '--extra-logging',\n",
                    "        action='append',\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    p.add_argument(\n",
                "        '--extra-logging',\n",
                "        action='append',\n",
                "        default=Options.extra_logging,\n",
                "        choices=('event-loop',),\n",
                "        help='Turn on extra logging for debugging in this build. Can be specified multiple times, to turn'\n",
                "        ' on different types of logging.'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--extra-include-dirs', '-I',\n",
                "        action='append',\n",
                "        default=Options.extra_include_dirs,\n",
                "        help='Extra include directories to use while compiling'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--extra-library-dirs', '-L',\n",
                "        action='append',\n",
                "        default=Options.extra_library_dirs,\n",
                "        help='Extra library directories to use while linking'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--update-check-interval',\n",
                "        type=float,\n",
                "        default=Options.update_check_interval,\n",
                "        help='When building a package, the default value for the update_check_interval setting will'\n",
                "        ' be set to this number. Use zero to disable update checking.'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--shell-integration',\n",
                "        type=str,\n",
                "        default=Options.shell_integration,\n",
                "        help='When building a package, the default value for the shell_integration setting will'\n",
                "        ' be set to this. Use \"enabled no-rc\" if you intend to install the shell integration scripts system wide.'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--egl-library',\n",
                "        type=str,\n",
                "        default=Options.egl_library,\n",
                "        help='The filename argument passed to dlopen for libEGL.'\n",
                "        ' This can be used to change the name of the loaded library or specify an absolute path.'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--startup-notification-library',\n",
                "        type=str,\n",
                "        default=Options.startup_notification_library,\n",
                "        help='The filename argument passed to dlopen for libstartup-notification-1.'\n",
                "        ' This can be used to change the name of the loaded library or specify an absolute path.'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--canberra-library',\n",
                "        type=str,\n",
                "        default=Options.canberra_library,\n",
                "        help='The filename argument passed to dlopen for libcanberra.'\n",
                "        ' This can be used to change the name of the loaded library or specify an absolute path.'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--fontconfig-library',\n",
                "        type=str,\n",
                "        default=Options.fontconfig_library,\n",
                "        help='The filename argument passed to dlopen for libfontconfig.'\n",
                "        ' This can be used to change the name of the loaded library or specify an absolute path.'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--disable-link-time-optimization',\n",
                "        dest='link_time_optimization',\n",
                "        default=Options.link_time_optimization,\n",
                "        action='store_false',\n",
                "        help='Turn off Link Time Optimization (LTO).'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--ignore-compiler-warnings',\n",
                "        default=False, action='store_true',\n",
                "        help='Ignore any warnings from the compiler while building'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        '--build-universal-binary',\n",
                "        default=False, action='store_true',\n",
                "        help='Build a universal binary (ARM + Intel on macOS, ignored on other platforms)'\n",
                "    )\n",
                "    return p\n",
                "# }}}\n",
                "\n",
                "\n",
                "def build_dep() -> None:\n",
                "    class Options(argparse.Namespace):\n",
                "        platform: str\n",
                "        deps: List[str]\n",
                "\n",
                "    p = argparse.ArgumentParser(prog=f'{sys.argv[0]} build-dep', description='Build dependencies for the kitty binary packages')\n",
                "    p.add_argument(\n",
                "        '--platform',\n",
                "        default='all',\n",
                "        choices='all macos linux linux-32 linux-arm64 linux-64'.split(),\n",
                "        help='Platforms to build the dep for'\n",
                "    )\n",
                "    p.add_argument(\n",
                "        'deps',\n",
                "        nargs='*',\n",
                "        default=[],\n",
                "        help='Names of the dependencies, if none provided, build all'\n",
                "    )\n",
                "    args = p.parse_args(sys.argv[2:], namespace=Options)\n",
                "    linux_platforms = [\n",
                "        ['linux', '--arch=64'],\n",
                "        ['linux', '--arch=32'],\n",
                "        ['linux', '--arch=arm64'],\n",
                "    ]\n",
                "    if args.platform == 'all':\n",
                "        platforms = linux_platforms + [['macos']]\n",
                "    elif args.platform == 'linux':\n",
                "        platforms = linux_platforms\n",
                "    elif args.platform == 'macos':\n",
                "        platforms = [['macos']]\n",
                "    elif '-' in args.platform:\n",
                "        parts = args.platform.split('-')\n",
                "        platforms = [[parts[0], f'--arch={parts[1]}']]\n",
                "    else:\n",
                "        raise SystemExit(f'Unknown platform: {args.platform}')\n",
                "    base = [sys.executable, '../bypy']\n",
                "    for pf in platforms:\n",
                "        cmd = base + pf + ['dependencies'] + args.deps\n",
                "        run_tool(cmd)\n",
                "\n",
                "\n",
                "def main() -> None:\n",
                "    global verbose\n",
                "    if len(sys.argv) > 1 and sys.argv[1] == 'build-dep':\n",
                "        return build_dep()\n",
                "    args = option_parser().parse_args(namespace=Options())\n",
                "    if not is_macos:\n",
                "        args.build_universal_binary = False\n",
                "    verbose = args.verbose > 0\n",
                "    args.prefix = os.path.abspath(args.prefix)\n",
                "    os.chdir(src_base)\n",
                "    launcher_dir = 'kitty/launcher'\n",
                "\n",
                "    if args.action == 'test':\n",
                "        texe = os.path.abspath(os.path.join(launcher_dir, 'kitty'))\n",
                "        os.execl(texe, texe, '+launch', 'test.py')\n",
                "    if args.action == 'clean':\n",
                "        clean()\n",
                "        return\n",
                "\n",
                "    with CompilationDatabase(args.incremental) as cdb:\n",
                "        args.compilation_database = cdb\n",
                "        if args.action == 'build':\n",
                "            build(args)\n",
                "            if is_macos:\n",
                "                create_minimal_macos_bundle(args, launcher_dir)\n",
                "            else:\n",
                "                build_launcher(args, launcher_dir=launcher_dir)\n",
                "                build_static_kittens(args, launcher_dir=launcher_dir)\n",
                "        elif args.action == 'build-launcher':\n",
                "            init_env_from_args(args, False)\n",
                "            build_launcher(args, launcher_dir=launcher_dir)\n",
                "            build_static_kittens(args, launcher_dir=launcher_dir)\n",
                "        elif args.action == 'build-frozen-launcher':\n",
                "            init_env_from_args(args, False)\n",
                "            bundle_type = ('macos' if is_macos else 'linux') + '-freeze'\n",
                "            build_launcher(args, launcher_dir=os.path.join(args.prefix, 'bin'), bundle_type=bundle_type)\n",
                "        elif args.action == 'build-frozen-tools':\n",
                "            build_static_kittens(args, launcher_dir=args.prefix, for_freeze=True)\n",
                "        elif args.action == 'linux-package':\n",
                "            build(args, native_optimizations=False)\n",
                "            package(args, bundle_type='linux-package')\n",
                "        elif args.action == 'linux-freeze':\n",
                "            build(args, native_optimizations=False)\n",
                "            package(args, bundle_type='linux-freeze')\n",
                "        elif args.action == 'macos-freeze':\n",
                "            init_env_from_args(args, native_optimizations=False)\n",
                "            build_launcher(args, launcher_dir=launcher_dir)\n",
                "            build(args, native_optimizations=False, call_init=False)\n",
                "            package(args, bundle_type='macos-freeze')\n",
                "        elif args.action == 'kitty.app':\n",
                "            args.prefix = 'kitty.app'\n",
                "            if os.path.exists(args.prefix):\n",
                "                shutil.rmtree(args.prefix)\n",
                "            build(args)\n",
                "            package(args, bundle_type='macos-package')\n",
                "            print('kitty.app successfully built!')\n",
                "        elif args.action == 'export-ci-bundles':\n",
                "            cmd = [sys.executable, '../bypy', 'export', 'download.calibre-ebook.com:/srv/download/ci/kitty']\n",
                "            subprocess.check_call(cmd + ['linux'])\n",
                "            subprocess.check_call(cmd + ['macos'])\n",
                "        elif args.action == 'build-static-binaries':\n",
                "            build_static_binaries(args, launcher_dir)\n",
                "\n",
                "\n",
                "if __name__ == '__main__':\n",
                "    main()"
            ]
        ]
    },
    "edit_order": [
        [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8
        ],
        [
            1,
            0,
            2,
            3,
            4,
            5,
            6,
            7,
            8
        ]
    ],
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "The new argument added is used in the function body.",
            "scenario of 0 -> 1": "declare fisrt, define latter",
            "scenario of 1 -> 0": "define first, declare latter"
        },
        {
            "edit_hunk_pair": [
                0,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "The new argument added is used in the function body.",
            "scenario of 0 -> 1": "declare fisrt, use latter",
            "scenario of 1 -> 0": "use first, declare latter"
        },
        {
            "edit_hunk_pair": [
                0,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "The new argument added is used in the function body.",
            "scenario of 0 -> 1": "declare fisrt, use latter",
            "scenario of 1 -> 0": "use first, declare latter"
        },
        {
            "edit_hunk_pair": [
                0,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "The new argument added is used in the function body.",
            "scenario of 0 -> 1": "declare fisrt, use latter",
            "scenario of 1 -> 0": "use first, declare latter"
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "The new argument added is used in the function body.",
            "scenario of 0 -> 1": "edit 0 introduces the new argument, then edit 1 uses it.",
            "scenario of 1 -> 0": "edit 1 uses the new argument first, then introduces the new argument in edit 0."
        },
        {
            "edit_hunk_pair": [
                1,
                3
            ],
            "edit_order": "no relation",
            "reason": "edit 3 at func init_env() add a new arg vcs_env, which should be passed to the calling of Env() at edit 4, then passed to edit 1 where Env __init__() use it at edit 1. we don't encourage logic jump"
        },
        {
            "edit_hunk_pair": [
                1,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "The function signature is updated before a new argument is added.",
            "scenario of 0 -> 1": "edit 0 introduces the new argument, then edit 1 adds the change required.",
            "scenario of 1 -> 0": "edit 1 uses the new argument first, then introduces the new argument in edit 0."
        },
        {
            "edit_hunk_pair": [
                1,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "The function signature is updated before a new argument is added.",
            "scenario of 0 -> 1": "edit 0 introduces the new argument, then edit 1 adds the change required.",
            "scenario of 1 -> 0": "edit 1 uses the new argument first, then introduces the new argument in edit 0."
        },
        {
            "edit_hunk_pair": [
                2,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "The function signature is updated before a new argument is added.",
            "scenario of 0 -> 1": "edit 0 introduces the new argument, then edit 1 adds the change required.",
            "scenario of 1 -> 0": "edit 1 uses the new argument first, then introduces the new argument in edit 0."
        },
        {
            "edit_hunk_pair": [
                2,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "use and define",
            "scenario of 0 -> 1": "define before use",
            "scenario of 1 -> 0": "use before define"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "Variable Dependency",
            "scenario of 0 -> 1": "edit 0 defines the variable first, then edit 1 uses it.",
            "scenario of 1 -> 0": "edit 1 uses the new variable first, then defines it in edit 0."
        },
        {
            "edit_hunk_pair": [
                5,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "The function was renamed and used in the function body.",
            "scenario of 0 -> 1": "edit 0 renames the function first, and then edit 1 uses it in the function body.",
            "scenario of 1 -> 0": "edit 1 uses the function `get_vcs_rev` first, and then edit 0 renames it."
        },
        {
            "edit_hunk_pair": [
                5,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "The function was renamed and used in the function body.",
            "scenario of 0 -> 1": "edit 0 renames the function first, and then edit 1 uses it in the function body.",
            "scenario of 1 -> 0": "edit 1 uses the function `get_vcs_rev` first, and then edit 0 renames it."
        },
        {
            "edit_hunk_pair": [
                7,
                8
            ],
            "edit_order": "bi-directional",
            "reason": "edit 0 use `arg.vcs_rev`, which is defined in edit 1",
            "scenario of 0 -> 1": "edit 0 use `arg.vcs_rev`, driven by error, define it in edit 1",
            "scenario of 1 -> 0": "edit 1 first define the new argument, then edit 0 use it"
        }
    ]
}