{
    "language": "python",
    "commit_url": "https://github.com/ytdl-org/youtube-dl/commit/690355551c084a942db9820b4c83b65f73fb2d4c",
    "commit_message": "[downoader/fragment,f4m,hls] Add internal support for custom HTTP headers",
    "commit_snapshots": {
        "youtube_dl/downloader/f4m.py": [
            [
                "from __future__ import division, unicode_literals\n",
                "\n",
                "import base64\n",
                "import io\n",
                "import itertools\n",
                "import os\n",
                "import time\n",
                "\n",
                "from .fragment import FragmentFD\n",
                "from ..compat import (\n",
                "    compat_etree_fromstring,\n",
                "    compat_urlparse,\n",
                "    compat_urllib_error,\n",
                "    compat_urllib_parse_urlparse,\n",
                "    compat_struct_pack,\n",
                "    compat_struct_unpack,\n",
                ")\n",
                "from ..utils import (\n",
                "    encodeFilename,\n",
                "    fix_xml_ampersands,\n",
                "    sanitize_open,\n",
                "    xpath_text,\n",
                ")\n",
                "\n",
                "\n",
                "class DataTruncatedError(Exception):\n",
                "    pass\n",
                "\n",
                "\n",
                "class FlvReader(io.BytesIO):\n",
                "    \"\"\"\n",
                "    Reader for Flv files\n",
                "    The file format is documented in https://www.adobe.com/devnet/f4v.html\n",
                "    \"\"\"\n",
                "\n",
                "    def read_bytes(self, n):\n",
                "        data = self.read(n)\n",
                "        if len(data) < n:\n",
                "            raise DataTruncatedError(\n",
                "                'FlvReader error: need %d bytes while only %d bytes got' % (\n",
                "                    n, len(data)))\n",
                "        return data\n",
                "\n",
                "    # Utility functions for reading numbers and strings\n",
                "    def read_unsigned_long_long(self):\n",
                "        return compat_struct_unpack('!Q', self.read_bytes(8))[0]\n",
                "\n",
                "    def read_unsigned_int(self):\n",
                "        return compat_struct_unpack('!I', self.read_bytes(4))[0]\n",
                "\n",
                "    def read_unsigned_char(self):\n",
                "        return compat_struct_unpack('!B', self.read_bytes(1))[0]\n",
                "\n",
                "    def read_string(self):\n",
                "        res = b''\n",
                "        while True:\n",
                "            char = self.read_bytes(1)\n",
                "            if char == b'\\x00':\n",
                "                break\n",
                "            res += char\n",
                "        return res\n",
                "\n",
                "    def read_box_info(self):\n",
                "        \"\"\"\n",
                "        Read a box and return the info as a tuple: (box_size, box_type, box_data)\n",
                "        \"\"\"\n",
                "        real_size = size = self.read_unsigned_int()\n",
                "        box_type = self.read_bytes(4)\n",
                "        header_end = 8\n",
                "        if size == 1:\n",
                "            real_size = self.read_unsigned_long_long()\n",
                "            header_end = 16\n",
                "        return real_size, box_type, self.read_bytes(real_size - header_end)\n",
                "\n",
                "    def read_asrt(self):\n",
                "        # version\n",
                "        self.read_unsigned_char()\n",
                "        # flags\n",
                "        self.read_bytes(3)\n",
                "        quality_entry_count = self.read_unsigned_char()\n",
                "        # QualityEntryCount\n",
                "        for i in range(quality_entry_count):\n",
                "            self.read_string()\n",
                "\n",
                "        segment_run_count = self.read_unsigned_int()\n",
                "        segments = []\n",
                "        for i in range(segment_run_count):\n",
                "            first_segment = self.read_unsigned_int()\n",
                "            fragments_per_segment = self.read_unsigned_int()\n",
                "            segments.append((first_segment, fragments_per_segment))\n",
                "\n",
                "        return {\n",
                "            'segment_run': segments,\n",
                "        }\n",
                "\n",
                "    def read_afrt(self):\n",
                "        # version\n",
                "        self.read_unsigned_char()\n",
                "        # flags\n",
                "        self.read_bytes(3)\n",
                "        # time scale\n",
                "        self.read_unsigned_int()\n",
                "\n",
                "        quality_entry_count = self.read_unsigned_char()\n",
                "        # QualitySegmentUrlModifiers\n",
                "        for i in range(quality_entry_count):\n",
                "            self.read_string()\n",
                "\n",
                "        fragments_count = self.read_unsigned_int()\n",
                "        fragments = []\n",
                "        for i in range(fragments_count):\n",
                "            first = self.read_unsigned_int()\n",
                "            first_ts = self.read_unsigned_long_long()\n",
                "            duration = self.read_unsigned_int()\n",
                "            if duration == 0:\n",
                "                discontinuity_indicator = self.read_unsigned_char()\n",
                "            else:\n",
                "                discontinuity_indicator = None\n",
                "            fragments.append({\n",
                "                'first': first,\n",
                "                'ts': first_ts,\n",
                "                'duration': duration,\n",
                "                'discontinuity_indicator': discontinuity_indicator,\n",
                "            })\n",
                "\n",
                "        return {\n",
                "            'fragments': fragments,\n",
                "        }\n",
                "\n",
                "    def read_abst(self):\n",
                "        # version\n",
                "        self.read_unsigned_char()\n",
                "        # flags\n",
                "        self.read_bytes(3)\n",
                "\n",
                "        self.read_unsigned_int()  # BootstrapinfoVersion\n",
                "        # Profile,Live,Update,Reserved\n",
                "        flags = self.read_unsigned_char()\n",
                "        live = flags & 0x20 != 0\n",
                "        # time scale\n",
                "        self.read_unsigned_int()\n",
                "        # CurrentMediaTime\n",
                "        self.read_unsigned_long_long()\n",
                "        # SmpteTimeCodeOffset\n",
                "        self.read_unsigned_long_long()\n",
                "\n",
                "        self.read_string()  # MovieIdentifier\n",
                "        server_count = self.read_unsigned_char()\n",
                "        # ServerEntryTable\n",
                "        for i in range(server_count):\n",
                "            self.read_string()\n",
                "        quality_count = self.read_unsigned_char()\n",
                "        # QualityEntryTable\n",
                "        for i in range(quality_count):\n",
                "            self.read_string()\n",
                "        # DrmData\n",
                "        self.read_string()\n",
                "        # MetaData\n",
                "        self.read_string()\n",
                "\n",
                "        segments_count = self.read_unsigned_char()\n",
                "        segments = []\n",
                "        for i in range(segments_count):\n",
                "            box_size, box_type, box_data = self.read_box_info()\n",
                "            assert box_type == b'asrt'\n",
                "            segment = FlvReader(box_data).read_asrt()\n",
                "            segments.append(segment)\n",
                "        fragments_run_count = self.read_unsigned_char()\n",
                "        fragments = []\n",
                "        for i in range(fragments_run_count):\n",
                "            box_size, box_type, box_data = self.read_box_info()\n",
                "            assert box_type == b'afrt'\n",
                "            fragments.append(FlvReader(box_data).read_afrt())\n",
                "\n",
                "        return {\n",
                "            'segments': segments,\n",
                "            'fragments': fragments,\n",
                "            'live': live,\n",
                "        }\n",
                "\n",
                "    def read_bootstrap_info(self):\n",
                "        total_size, box_type, box_data = self.read_box_info()\n",
                "        assert box_type == b'abst'\n",
                "        return FlvReader(box_data).read_abst()\n",
                "\n",
                "\n",
                "def read_bootstrap_info(bootstrap_bytes):\n",
                "    return FlvReader(bootstrap_bytes).read_bootstrap_info()\n",
                "\n",
                "\n",
                "def build_fragments_list(boot_info):\n",
                "    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n",
                "    res = []\n",
                "    segment_run_table = boot_info['segments'][0]\n",
                "    fragment_run_entry_table = boot_info['fragments'][0]['fragments']\n",
                "    first_frag_number = fragment_run_entry_table[0]['first']\n",
                "    fragments_counter = itertools.count(first_frag_number)\n",
                "    for segment, fragments_count in segment_run_table['segment_run']:\n",
                "        # In some live HDS streams (for example Rai), `fragments_count` is\n",
                "        # abnormal and causing out-of-memory errors. It's OK to change the\n",
                "        # number of fragments for live streams as they are updated periodically\n",
                "        if fragments_count == 4294967295 and boot_info['live']:\n",
                "            fragments_count = 2\n",
                "        for _ in range(fragments_count):\n",
                "            res.append((segment, next(fragments_counter)))\n",
                "\n",
                "    if boot_info['live']:\n",
                "        res = res[-2:]\n",
                "\n",
                "    return res\n",
                "\n",
                "\n",
                "def write_unsigned_int(stream, val):\n",
                "    stream.write(compat_struct_pack('!I', val))\n",
                "\n",
                "\n",
                "def write_unsigned_int_24(stream, val):\n",
                "    stream.write(compat_struct_pack('!I', val)[1:])\n",
                "\n",
                "\n",
                "def write_flv_header(stream):\n",
                "    \"\"\"Writes the FLV header to stream\"\"\"\n",
                "    # FLV header\n",
                "    stream.write(b'FLV\\x01')\n",
                "    stream.write(b'\\x05')\n",
                "    stream.write(b'\\x00\\x00\\x00\\x09')\n",
                "    stream.write(b'\\x00\\x00\\x00\\x00')\n",
                "\n",
                "\n",
                "def write_metadata_tag(stream, metadata):\n",
                "    \"\"\"Writes optional metadata tag to stream\"\"\"\n",
                "    SCRIPT_TAG = b'\\x12'\n",
                "    FLV_TAG_HEADER_LEN = 11\n",
                "\n",
                "    if metadata:\n",
                "        stream.write(SCRIPT_TAG)\n",
                "        write_unsigned_int_24(stream, len(metadata))\n",
                "        stream.write(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n",
                "        stream.write(metadata)\n",
                "        write_unsigned_int(stream, FLV_TAG_HEADER_LEN + len(metadata))\n",
                "\n",
                "\n",
                "def remove_encrypted_media(media):\n",
                "    return list(filter(lambda e: 'drmAdditionalHeaderId' not in e.attrib and\n",
                "                                 'drmAdditionalHeaderSetId' not in e.attrib,\n",
                "                       media))\n",
                "\n",
                "\n",
                "def _add_ns(prop):\n",
                "    return '{http://ns.adobe.com/f4m/1.0}%s' % prop\n",
                "\n",
                "\n",
                "class F4mFD(FragmentFD):\n",
                "    \"\"\"\n",
                "    A downloader for f4m manifests or AdobeHDS.\n",
                "    \"\"\"\n",
                "\n",
                "    FD_NAME = 'f4m'\n",
                "\n",
                "    def _get_unencrypted_media(self, doc):\n",
                "        media = doc.findall(_add_ns('media'))\n",
                "        if not media:\n",
                "            self.report_error('No media found')\n",
                "        for e in (doc.findall(_add_ns('drmAdditionalHeader')) +\n",
                "                  doc.findall(_add_ns('drmAdditionalHeaderSet'))):\n",
                "            # If id attribute is missing it's valid for all media nodes\n",
                "            # without drmAdditionalHeaderId or drmAdditionalHeaderSetId attribute\n",
                "            if 'id' not in e.attrib:\n",
                "                self.report_error('Missing ID in f4m DRM')\n",
                "        media = remove_encrypted_media(media)\n",
                "        if not media:\n",
                "            self.report_error('Unsupported DRM')\n",
                "        return media\n",
                "\n",
                "    def _get_bootstrap_from_url(self, bootstrap_url):\n",
                "        bootstrap = self.ydl.urlopen(bootstrap_url).read()\n",
                "        return read_bootstrap_info(bootstrap)\n",
                "\n",
                "    def _update_live_fragments(self, bootstrap_url, latest_fragment):\n",
                "        fragments_list = []\n",
                "        retries = 30\n",
                "        while (not fragments_list) and (retries > 0):\n",
                "            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n",
                "            fragments_list = build_fragments_list(boot_info)\n",
                "            fragments_list = [f for f in fragments_list if f[1] > latest_fragment]\n",
                "            if not fragments_list:\n",
                "                # Retry after a while\n",
                "                time.sleep(5.0)\n",
                "                retries -= 1\n",
                "\n",
                "        if not fragments_list:\n",
                "            self.report_error('Failed to update fragments')\n",
                "\n",
                "        return fragments_list\n",
                "\n",
                "    def _parse_bootstrap_node(self, node, base_url):\n",
                "        # Sometimes non empty inline bootstrap info can be specified along\n",
                "        # with bootstrap url attribute (e.g. dummy inline bootstrap info\n",
                "        # contains whitespace characters in [1]). We will prefer bootstrap\n",
                "        # url over inline bootstrap info when present.\n",
                "        # 1. http://live-1-1.rutube.ru/stream/1024/HDS/SD/C2NKsS85HQNckgn5HdEmOQ/1454167650/S-s604419906/move/four/dirs/upper/1024-576p.f4m\n",
                "        bootstrap_url = node.get('url')\n",
                "        if bootstrap_url:\n",
                "            bootstrap_url = compat_urlparse.urljoin(\n",
                "                base_url, bootstrap_url)\n",
                "            boot_info = self._get_bootstrap_from_url(bootstrap_url)\n",
                "        else:\n",
                "            bootstrap_url = None\n",
                "            bootstrap = base64.b64decode(node.text.encode('ascii'))\n",
                "            boot_info = read_bootstrap_info(bootstrap)\n",
                "        return boot_info, bootstrap_url\n",
                "\n",
                "    def real_download(self, filename, info_dict):\n",
                "        man_url = info_dict['url']\n",
                "        requested_bitrate = info_dict.get('tbr')\n",
                "        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        urlh = self.ydl.urlopen(man_url)\n"
                ],
                "after": [
                    "\n",
                    "        urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n"
                ],
                "parent_version_range": {
                    "start": 316,
                    "end": 317
                },
                "child_version_range": {
                    "start": 316,
                    "end": 318
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "F4mFD",
                        "signature": "class F4mFD(FragmentFD):",
                        "at_line": 252
                    },
                    {
                        "type": "function",
                        "name": "real_download",
                        "signature": "def real_download(self, filename, info_dict):",
                        "at_line": 312
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: youtube_dl/downloader/f4m.py\nCode:\n           class F4mFD(FragmentFD):\n               ...\n               def real_download(self, filename, info_dict):\n                   ...\n313 313            man_url = info_dict['url']\n314 314            requested_bitrate = info_dict.get('tbr')\n315 315            self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n316      -         urlh = self.ydl.urlopen(man_url)\n    316  + \n    317  +         urlh = self.ydl.urlopen(self._prepare_url(info_dict, man_url))\n317 318            man_url = urlh.geturl()\n318 319            # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n319 320            # (see https://github.com/rg3/youtube-dl/issues/6215#issuecomment-121704244\n         ...\n",
                "file_path": "youtube_dl/downloader/f4m.py",
                "identifiers_before": [
                    "man_url",
                    "self",
                    "urlh",
                    "urlopen",
                    "ydl"
                ],
                "identifiers_after": [
                    "_prepare_url",
                    "info_dict",
                    "man_url",
                    "self",
                    "urlh",
                    "urlopen",
                    "ydl"
                ],
                "prefix": [
                    "        man_url = info_dict['url']\n",
                    "        requested_bitrate = info_dict.get('tbr')\n",
                    "        self.to_screen('[%s] Downloading f4m manifest' % self.FD_NAME)\n"
                ],
                "suffix": [
                    "        man_url = urlh.geturl()\n",
                    "        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n",
                    "        # (see https://github.com/rg3/youtube-dl/issues/6215#issuecomment-121704244\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "_prepare_url",
                            "position": {
                                "start": {
                                    "line": 317,
                                    "column": 37
                                },
                                "end": {
                                    "line": 317,
                                    "column": 49
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/youtube-dl/youtube_dl/downloader/f4m.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    4
                ]
            },
            [
                "        man_url = urlh.geturl()\n",
                "        # Some manifests may be malformed, e.g. prosiebensat1 generated manifests\n",
                "        # (see https://github.com/rg3/youtube-dl/issues/6215#issuecomment-121704244\n",
                "        # and https://github.com/rg3/youtube-dl/issues/7823)\n",
                "        manifest = fix_xml_ampersands(urlh.read().decode('utf-8', 'ignore')).strip()\n",
                "\n",
                "        doc = compat_etree_fromstring(manifest)\n",
                "        formats = [(int(f.attrib.get('bitrate', -1)), f)\n",
                "                   for f in self._get_unencrypted_media(doc)]\n",
                "        if requested_bitrate is None or len(formats) == 1:\n",
                "            # get the best format\n",
                "            formats = sorted(formats, key=lambda f: f[0])\n",
                "            rate, media = formats[-1]\n",
                "        else:\n",
                "            rate, media = list(filter(\n",
                "                lambda f: int(f[0]) == requested_bitrate, formats))[0]\n",
                "\n",
                "        base_url = compat_urlparse.urljoin(man_url, media.attrib['url'])\n",
                "        bootstrap_node = doc.find(_add_ns('bootstrapInfo'))\n",
                "        # From Adobe F4M 3.0 spec:\n",
                "        # The <baseURL> element SHALL be the base URL for all relative\n",
                "        # (HTTP-based) URLs in the manifest. If <baseURL> is not present, said\n",
                "        # URLs should be relative to the location of the containing document.\n",
                "        boot_info, bootstrap_url = self._parse_bootstrap_node(bootstrap_node, man_url)\n",
                "        live = boot_info['live']\n",
                "        metadata_node = media.find(_add_ns('metadata'))\n",
                "        if metadata_node is not None:\n",
                "            metadata = base64.b64decode(metadata_node.text.encode('ascii'))\n",
                "        else:\n",
                "            metadata = None\n",
                "\n",
                "        fragments_list = build_fragments_list(boot_info)\n",
                "        test = self.params.get('test', False)\n",
                "        if test:\n",
                "            # We only download the first fragment\n",
                "            fragments_list = fragments_list[:1]\n",
                "        total_frags = len(fragments_list)\n",
                "        # For some akamai manifests we'll need to add a query to the fragment url\n",
                "        akamai_pv = xpath_text(doc, _add_ns('pv-2.0'))\n",
                "\n",
                "        ctx = {\n",
                "            'filename': filename,\n",
                "            'total_frags': total_frags,\n",
                "            'live': live,\n",
                "        }\n",
                "\n",
                "        self._prepare_frag_download(ctx)\n",
                "\n",
                "        dest_stream = ctx['dest_stream']\n",
                "\n",
                "        write_flv_header(dest_stream)\n",
                "        if not live:\n",
                "            write_metadata_tag(dest_stream, metadata)\n",
                "\n",
                "        base_url_parsed = compat_urllib_parse_urlparse(base_url)\n",
                "\n",
                "        self._start_frag_download(ctx)\n",
                "\n",
                "        frags_filenames = []\n",
                "        while fragments_list:\n",
                "            seg_i, frag_i = fragments_list.pop(0)\n",
                "            name = 'Seg%d-Frag%d' % (seg_i, frag_i)\n",
                "            query = []\n",
                "            if base_url_parsed.query:\n",
                "                query.append(base_url_parsed.query)\n",
                "            if akamai_pv:\n",
                "                query.append(akamai_pv.strip(';'))\n",
                "            if info_dict.get('extra_param_to_segment_url'):\n",
                "                query.append(info_dict['extra_param_to_segment_url'])\n",
                "            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n",
                "            frag_filename = '%s-%s' % (ctx['tmpfilename'], name)\n",
                "            try:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                success = ctx['dl'].download(frag_filename, {'url': url_parsed.geturl()})\n"
                ],
                "after": [
                    "                success = ctx['dl'].download(frag_filename, {\n",
                    "                    'url': url_parsed.geturl(),\n",
                    "                    'http_headers': info_dict.get('http_headers'),\n",
                    "                })\n"
                ],
                "parent_version_range": {
                    "start": 389,
                    "end": 390
                },
                "child_version_range": {
                    "start": 390,
                    "end": 394
                },
                "control_flow": [
                    {
                        "type": "while_statement",
                        "statement": "while fragments_list:",
                        "start_line": 376,
                        "end_line": 430
                    },
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 388,
                        "end_line": 423
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "F4mFD",
                        "signature": "class F4mFD(FragmentFD):",
                        "at_line": 252
                    },
                    {
                        "type": "function",
                        "name": "real_download",
                        "signature": "def real_download(self, filename, info_dict):",
                        "at_line": 312
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: youtube_dl/downloader/f4m.py\nCode:\n           class F4mFD(FragmentFD):\n               ...\n               def real_download(self, filename, info_dict):\n                   ...\n386 387                url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n387 388                frag_filename = '%s-%s' % (ctx['tmpfilename'], name)\n388 389                try:\n389      -                 success = ctx['dl'].download(frag_filename, {'url': url_parsed.geturl()})\n    390  +                 success = ctx['dl'].download(frag_filename, {\n    391  +                     'url': url_parsed.geturl(),\n    392  +                     'http_headers': info_dict.get('http_headers'),\n    393  +                 })\n390 394                    if not success:\n391 395                        return False\n392 396                    (down, frag_sanitized) = sanitize_open(frag_filename, 'rb')\n         ...\n",
                "file_path": "youtube_dl/downloader/f4m.py",
                "identifiers_before": [
                    "ctx",
                    "download",
                    "frag_filename",
                    "geturl",
                    "success",
                    "url_parsed"
                ],
                "identifiers_after": [
                    "ctx",
                    "download",
                    "frag_filename",
                    "get",
                    "geturl",
                    "info_dict",
                    "success",
                    "url_parsed"
                ],
                "prefix": [
                    "            url_parsed = base_url_parsed._replace(path=base_url_parsed.path + name, query='&'.join(query))\n",
                    "            frag_filename = '%s-%s' % (ctx['tmpfilename'], name)\n",
                    "            try:\n"
                ],
                "suffix": [
                    "                if not success:\n",
                    "                    return False\n",
                    "                (down, frag_sanitized) = sanitize_open(frag_filename, 'rb')\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    5
                ]
            },
            [
                "                if not success:\n",
                "                    return False\n",
                "                (down, frag_sanitized) = sanitize_open(frag_filename, 'rb')\n",
                "                down_data = down.read()\n",
                "                down.close()\n",
                "                reader = FlvReader(down_data)\n",
                "                while True:\n",
                "                    try:\n",
                "                        _, box_type, box_data = reader.read_box_info()\n",
                "                    except DataTruncatedError:\n",
                "                        if test:\n",
                "                            # In tests, segments may be truncated, and thus\n",
                "                            # FlvReader may not be able to parse the whole\n",
                "                            # chunk. If so, write the segment as is\n",
                "                            # See https://github.com/rg3/youtube-dl/issues/9214\n",
                "                            dest_stream.write(down_data)\n",
                "                            break\n",
                "                        raise\n",
                "                    if box_type == b'mdat':\n",
                "                        dest_stream.write(box_data)\n",
                "                        break\n",
                "                if live:\n",
                "                    os.remove(encodeFilename(frag_sanitized))\n",
                "                else:\n",
                "                    frags_filenames.append(frag_sanitized)\n",
                "            except (compat_urllib_error.HTTPError, ) as err:\n",
                "                if live and (err.code == 404 or err.code == 410):\n",
                "                    # We didn't keep up with the live window. Continue\n",
                "                    # with the next available fragment.\n",
                "                    msg = 'Fragment %d unavailable' % frag_i\n",
                "                    self.report_warning(msg)\n",
                "                    fragments_list = []\n",
                "                else:\n",
                "                    raise\n",
                "\n",
                "            if not fragments_list and not test and live and bootstrap_url:\n",
                "                fragments_list = self._update_live_fragments(bootstrap_url, frag_i)\n",
                "                total_frags += len(fragments_list)\n",
                "                if fragments_list and (fragments_list[0][1] > frag_i + 1):\n",
                "                    msg = 'Missed %d fragments' % (fragments_list[0][1] - (frag_i + 1))\n",
                "                    self.report_warning(msg)\n",
                "\n",
                "        self._finish_frag_download(ctx)\n",
                "\n",
                "        for frag_file in frags_filenames:\n",
                "            os.remove(encodeFilename(frag_file))\n",
                "\n",
                "        return True"
            ]
        ],
        "youtube_dl/downloader/fragment.py": [
            [
                "from __future__ import division, unicode_literals\n",
                "\n",
                "import os\n",
                "import time\n",
                "\n",
                "from .common import FileDownloader\n",
                "from .http import HttpFD\n",
                "from ..utils import (\n",
                "    error_to_compat_str,\n",
                "    encodeFilename,\n",
                "    sanitize_open,\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    sanitized_Request,\n"
                ],
                "parent_version_range": {
                    "start": 11,
                    "end": 11
                },
                "child_version_range": {
                    "start": 11,
                    "end": 12
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 2,
                "hunk_diff": "File: youtube_dl/downloader/fragment.py\nCode:\n  ...\n 8  8        error_to_compat_str,\n 9  9        encodeFilename,\n10 10        sanitize_open,\n   11  +     sanitized_Request,\n11 12    )\n12 13    \n13 14    \n       ...\n",
                "file_path": "youtube_dl/downloader/fragment.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "sanitized_Request"
                ],
                "prefix": [
                    "    error_to_compat_str,\n",
                    "    encodeFilename,\n",
                    "    sanitize_open,\n"
                ],
                "suffix": [
                    ")\n",
                    "\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "sanitized_Request",
                            "position": {
                                "start": {
                                    "line": 11,
                                    "column": 4
                                },
                                "end": {
                                    "line": 11,
                                    "column": 21
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/youtube-dl/youtube_dl/downloader/fragment.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                ")\n",
                "\n",
                "\n",
                "class HttpQuietDownloader(HttpFD):\n",
                "    def to_screen(self, *args, **kargs):\n",
                "        pass\n",
                "\n",
                "\n",
                "class FragmentFD(FileDownloader):\n",
                "    \"\"\"\n",
                "    A base file downloader class for fragmented media (e.g. f4m/m3u8 manifests).\n",
                "\n",
                "    Available options:\n",
                "\n",
                "    fragment_retries:   Number of times to retry a fragment for HTTP error (DASH\n",
                "                        and hlsnative only)\n",
                "    skip_unavailable_fragments:\n",
                "                        Skip unavailable fragments (DASH and hlsnative only)\n",
                "    \"\"\"\n",
                "\n",
                "    def report_retry_fragment(self, err, fragment_name, count, retries):\n",
                "        self.to_screen(\n",
                "            '[download] Got server HTTP error: %s. Retrying fragment %s (attempt %d of %s)...'\n",
                "            % (error_to_compat_str(err), fragment_name, count, self.format_retries(retries)))\n",
                "\n",
                "    def report_skip_fragment(self, fragment_name):\n",
                "        self.to_screen('[download] Skipping fragment %s...' % fragment_name)\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    def _prepare_url(self, info_dict, url):\n",
                    "        headers = info_dict.get('http_headers')\n",
                    "        return sanitized_Request(url, None, headers) if headers else url\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 39,
                    "end": 39
                },
                "child_version_range": {
                    "start": 40,
                    "end": 44
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "FragmentFD",
                        "signature": "class FragmentFD(FileDownloader):",
                        "at_line": 19
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: youtube_dl/downloader/fragment.py\nCode:\n         class FragmentFD(FileDownloader):\n             ...\n36 37        def report_skip_fragment(self, fragment_name):\n37 38            self.to_screen('[download] Skipping fragment %s...' % fragment_name)\n38 39    \n   40  +     def _prepare_url(self, info_dict, url):\n   41  +         headers = info_dict.get('http_headers')\n   42  +         return sanitized_Request(url, None, headers) if headers else url\n   43  + \n39 44        def _prepare_and_start_frag_download(self, ctx):\n40 45            self._prepare_frag_download(ctx)\n41 46            self._start_frag_download(ctx)\n       ...\n",
                "file_path": "youtube_dl/downloader/fragment.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "_prepare_url",
                    "get",
                    "headers",
                    "info_dict",
                    "sanitized_Request",
                    "self",
                    "url"
                ],
                "prefix": [
                    "    def report_skip_fragment(self, fragment_name):\n",
                    "        self.to_screen('[download] Skipping fragment %s...' % fragment_name)\n",
                    "\n"
                ],
                "suffix": [
                    "    def _prepare_and_start_frag_download(self, ctx):\n",
                    "        self._prepare_frag_download(ctx)\n",
                    "        self._start_frag_download(ctx)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "sanitized_Request",
                            "position": {
                                "start": {
                                    "line": 42,
                                    "column": 15
                                },
                                "end": {
                                    "line": 42,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/youtube-dl/youtube_dl/downloader/fragment.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "_prepare_url",
                            "position": {
                                "start": {
                                    "line": 40,
                                    "column": 8
                                },
                                "end": {
                                    "line": 40,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/youtube-dl/youtube_dl/downloader/fragment.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "_prepare_url",
                            "position": {
                                "start": {
                                    "line": 40,
                                    "column": 8
                                },
                                "end": {
                                    "line": 40,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/youtube-dl/youtube_dl/downloader/fragment.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "    def _prepare_and_start_frag_download(self, ctx):\n",
                "        self._prepare_frag_download(ctx)\n",
                "        self._start_frag_download(ctx)\n",
                "\n",
                "    def _prepare_frag_download(self, ctx):\n",
                "        if 'live' not in ctx:\n",
                "            ctx['live'] = False\n",
                "        self.to_screen(\n",
                "            '[%s] Total fragments: %s'\n",
                "            % (self.FD_NAME, ctx['total_frags'] if not ctx['live'] else 'unknown (live)'))\n",
                "        self.report_destination(ctx['filename'])\n",
                "        dl = HttpQuietDownloader(\n",
                "            self.ydl,\n",
                "            {\n",
                "                'continuedl': True,\n",
                "                'quiet': True,\n",
                "                'noprogress': True,\n",
                "                'ratelimit': self.params.get('ratelimit'),\n",
                "                'retries': self.params.get('retries', 0),\n",
                "                'test': self.params.get('test', False),\n",
                "            }\n",
                "        )\n",
                "        tmpfilename = self.temp_name(ctx['filename'])\n",
                "        dest_stream, tmpfilename = sanitize_open(tmpfilename, 'wb')\n",
                "        ctx.update({\n",
                "            'dl': dl,\n",
                "            'dest_stream': dest_stream,\n",
                "            'tmpfilename': tmpfilename,\n",
                "        })\n",
                "\n",
                "    def _start_frag_download(self, ctx):\n",
                "        total_frags = ctx['total_frags']\n",
                "        # This dict stores the download progress, it's updated by the progress\n",
                "        # hook\n",
                "        state = {\n",
                "            'status': 'downloading',\n",
                "            'downloaded_bytes': 0,\n",
                "            'frag_index': 0,\n",
                "            'frag_count': total_frags,\n",
                "            'filename': ctx['filename'],\n",
                "            'tmpfilename': ctx['tmpfilename'],\n",
                "        }\n",
                "\n",
                "        start = time.time()\n",
                "        ctx.update({\n",
                "            'started': start,\n",
                "            # Total complete fragments downloaded so far in bytes\n",
                "            'complete_frags_downloaded_bytes': 0,\n",
                "            # Amount of fragment's bytes downloaded by the time of the previous\n",
                "            # frag progress hook invocation\n",
                "            'prev_frag_downloaded_bytes': 0,\n",
                "        })\n",
                "\n",
                "        def frag_progress_hook(s):\n",
                "            if s['status'] not in ('downloading', 'finished'):\n",
                "                return\n",
                "\n",
                "            time_now = time.time()\n",
                "            state['elapsed'] = time_now - start\n",
                "            frag_total_bytes = s.get('total_bytes') or 0\n",
                "            if not ctx['live']:\n",
                "                estimated_size = (\n",
                "                    (ctx['complete_frags_downloaded_bytes'] + frag_total_bytes) /\n",
                "                    (state['frag_index'] + 1) * total_frags)\n",
                "                state['total_bytes_estimate'] = estimated_size\n",
                "\n",
                "            if s['status'] == 'finished':\n",
                "                state['frag_index'] += 1\n",
                "                state['downloaded_bytes'] += frag_total_bytes - ctx['prev_frag_downloaded_bytes']\n",
                "                ctx['complete_frags_downloaded_bytes'] = state['downloaded_bytes']\n",
                "                ctx['prev_frag_downloaded_bytes'] = 0\n",
                "            else:\n",
                "                frag_downloaded_bytes = s['downloaded_bytes']\n",
                "                state['downloaded_bytes'] += frag_downloaded_bytes - ctx['prev_frag_downloaded_bytes']\n",
                "                if not ctx['live']:\n",
                "                    state['eta'] = self.calc_eta(\n",
                "                        start, time_now, estimated_size,\n",
                "                        state['downloaded_bytes'])\n",
                "                state['speed'] = s.get('speed') or ctx.get('speed')\n",
                "                ctx['speed'] = state['speed']\n",
                "                ctx['prev_frag_downloaded_bytes'] = frag_downloaded_bytes\n",
                "            self._hook_progress(state)\n",
                "\n",
                "        ctx['dl'].add_progress_hook(frag_progress_hook)\n",
                "\n",
                "        return start\n",
                "\n",
                "    def _finish_frag_download(self, ctx):\n",
                "        ctx['dest_stream'].close()\n",
                "        elapsed = time.time() - ctx['started']\n",
                "        self.try_rename(ctx['tmpfilename'], ctx['filename'])\n",
                "        fsize = os.path.getsize(encodeFilename(ctx['filename']))\n",
                "\n",
                "        self._hook_progress({\n",
                "            'downloaded_bytes': fsize,\n",
                "            'total_bytes': fsize,\n",
                "            'filename': ctx['filename'],\n",
                "            'status': 'finished',\n",
                "            'elapsed': elapsed,\n",
                "        })"
            ]
        ],
        "youtube_dl/downloader/hls.py": [
            [
                "from __future__ import unicode_literals\n",
                "\n",
                "import os.path\n",
                "import re\n",
                "import binascii\n",
                "try:\n",
                "    from Crypto.Cipher import AES\n",
                "    can_decrypt_frag = True\n",
                "except ImportError:\n",
                "    can_decrypt_frag = False\n",
                "\n",
                "from .fragment import FragmentFD\n",
                "from .external import FFmpegFD\n",
                "\n",
                "from ..compat import (\n",
                "    compat_urllib_error,\n",
                "    compat_urlparse,\n",
                "    compat_struct_pack,\n",
                ")\n",
                "from ..utils import (\n",
                "    encodeFilename,\n",
                "    sanitize_open,\n",
                "    parse_m3u8_attributes,\n",
                "    update_url_query,\n",
                ")\n",
                "\n",
                "\n",
                "class HlsFD(FragmentFD):\n",
                "    \"\"\" A limited implementation that does not require ffmpeg \"\"\"\n",
                "\n",
                "    FD_NAME = 'hlsnative'\n",
                "\n",
                "    @staticmethod\n",
                "    def can_download(manifest, info_dict):\n",
                "        UNSUPPORTED_FEATURES = (\n",
                "            r'#EXT-X-KEY:METHOD=(?!NONE|AES-128)',  # encrypted streams [1]\n",
                "            r'#EXT-X-BYTERANGE',  # playlists composed of byte ranges of media files [2]\n",
                "\n",
                "            # Live streams heuristic does not always work (e.g. geo restricted to Germany\n",
                "            # http://hls-geo.daserste.de/i/videoportal/Film/c_620000/622873/format,716451,716457,716450,716458,716459,.mp4.csmil/index_4_av.m3u8?null=0)\n",
                "            # r'#EXT-X-MEDIA-SEQUENCE:(?!0$)',  # live streams [3]\n",
                "\n",
                "            # This heuristic also is not correct since segments may not be appended as well.\n",
                "            # Twitch vods of finished streams have EXT-X-PLAYLIST-TYPE:EVENT despite\n",
                "            # no segments will definitely be appended to the end of the playlist.\n",
                "            # r'#EXT-X-PLAYLIST-TYPE:EVENT',  # media segments may be appended to the end of\n",
                "            #                                 # event media playlists [4]\n",
                "\n",
                "            # 1. https://tools.ietf.org/html/draft-pantos-http-live-streaming-17#section-4.3.2.4\n",
                "            # 2. https://tools.ietf.org/html/draft-pantos-http-live-streaming-17#section-4.3.2.2\n",
                "            # 3. https://tools.ietf.org/html/draft-pantos-http-live-streaming-17#section-4.3.3.2\n",
                "            # 4. https://tools.ietf.org/html/draft-pantos-http-live-streaming-17#section-4.3.3.5\n",
                "        )\n",
                "        check_results = [not re.search(feature, manifest) for feature in UNSUPPORTED_FEATURES]\n",
                "        check_results.append(can_decrypt_frag or '#EXT-X-KEY:METHOD=AES-128' not in manifest)\n",
                "        check_results.append(not info_dict.get('is_live'))\n",
                "        return all(check_results)\n",
                "\n",
                "    def real_download(self, filename, info_dict):\n",
                "        man_url = info_dict['url']\n",
                "        self.to_screen('[%s] Downloading m3u8 manifest' % self.FD_NAME)\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        manifest = self.ydl.urlopen(man_url).read()\n"
                ],
                "after": [
                    "\n",
                    "        manifest = self.ydl.urlopen(self._prepare_url(info_dict, man_url)).read()\n"
                ],
                "parent_version_range": {
                    "start": 61,
                    "end": 62
                },
                "child_version_range": {
                    "start": 61,
                    "end": 63
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "HlsFD",
                        "signature": "class HlsFD(FragmentFD):",
                        "at_line": 27
                    },
                    {
                        "type": "function",
                        "name": "real_download",
                        "signature": "def real_download(self, filename, info_dict):",
                        "at_line": 58
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: youtube_dl/downloader/hls.py\nCode:\n         class HlsFD(FragmentFD):\n             ...\n58 58        def real_download(self, filename, info_dict):\n59 59            man_url = info_dict['url']\n60 60            self.to_screen('[%s] Downloading m3u8 manifest' % self.FD_NAME)\n61     -         manifest = self.ydl.urlopen(man_url).read()\n   61  + \n   62  +         manifest = self.ydl.urlopen(self._prepare_url(info_dict, man_url)).read()\n62 63    \n63 64            s = manifest.decode('utf-8', 'ignore')\n64 65    \n       ...\n",
                "file_path": "youtube_dl/downloader/hls.py",
                "identifiers_before": [
                    "man_url",
                    "manifest",
                    "read",
                    "self",
                    "urlopen",
                    "ydl"
                ],
                "identifiers_after": [
                    "_prepare_url",
                    "info_dict",
                    "man_url",
                    "manifest",
                    "read",
                    "self",
                    "urlopen",
                    "ydl"
                ],
                "prefix": [
                    "    def real_download(self, filename, info_dict):\n",
                    "        man_url = info_dict['url']\n",
                    "        self.to_screen('[%s] Downloading m3u8 manifest' % self.FD_NAME)\n"
                ],
                "suffix": [
                    "\n",
                    "        s = manifest.decode('utf-8', 'ignore')\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "_prepare_url",
                            "position": {
                                "start": {
                                    "line": 62,
                                    "column": 41
                                },
                                "end": {
                                    "line": 62,
                                    "column": 53
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/youtube-dl/youtube_dl/downloader/hls.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    0
                ]
            },
            [
                "\n",
                "        s = manifest.decode('utf-8', 'ignore')\n",
                "\n",
                "        if not self.can_download(s, info_dict):\n",
                "            self.report_warning(\n",
                "                'hlsnative has detected features it does not support, '\n",
                "                'extraction will be delegated to ffmpeg')\n",
                "            fd = FFmpegFD(self.ydl, self.params)\n",
                "            for ph in self._progress_hooks:\n",
                "                fd.add_progress_hook(ph)\n",
                "            return fd.real_download(filename, info_dict)\n",
                "\n",
                "        total_frags = 0\n",
                "        for line in s.splitlines():\n",
                "            line = line.strip()\n",
                "            if line and not line.startswith('#'):\n",
                "                total_frags += 1\n",
                "\n",
                "        ctx = {\n",
                "            'filename': filename,\n",
                "            'total_frags': total_frags,\n",
                "        }\n",
                "\n",
                "        self._prepare_and_start_frag_download(ctx)\n",
                "\n",
                "        fragment_retries = self.params.get('fragment_retries', 0)\n",
                "        skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)\n",
                "        test = self.params.get('test', False)\n",
                "\n",
                "        extra_query = None\n",
                "        extra_param_to_segment_url = info_dict.get('extra_param_to_segment_url')\n",
                "        if extra_param_to_segment_url:\n",
                "            extra_query = compat_urlparse.parse_qs(extra_param_to_segment_url)\n",
                "        i = 0\n",
                "        media_sequence = 0\n",
                "        decrypt_info = {'METHOD': 'NONE'}\n",
                "        frags_filenames = []\n",
                "        for line in s.splitlines():\n",
                "            line = line.strip()\n",
                "            if line:\n",
                "                if not line.startswith('#'):\n",
                "                    frag_url = (\n",
                "                        line\n",
                "                        if re.match(r'^https?://', line)\n",
                "                        else compat_urlparse.urljoin(man_url, line))\n",
                "                    frag_name = 'Frag%d' % i\n",
                "                    frag_filename = '%s-%s' % (ctx['tmpfilename'], frag_name)\n",
                "                    if extra_query:\n",
                "                        frag_url = update_url_query(frag_url, extra_query)\n",
                "                    count = 0\n",
                "                    while count <= fragment_retries:\n",
                "                        try:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                            success = ctx['dl'].download(frag_filename, {'url': frag_url})\n"
                ],
                "after": [
                    "                            success = ctx['dl'].download(frag_filename, {\n",
                    "                                'url': frag_url,\n",
                    "                                'http_headers': info_dict.get('http_headers'),\n",
                    "                            })\n"
                ],
                "parent_version_range": {
                    "start": 114,
                    "end": 115
                },
                "child_version_range": {
                    "start": 115,
                    "end": 119
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for line in s.splitlines():",
                        "start_line": 99,
                        "end_line": 161
                    },
                    {
                        "type": "if_statement",
                        "statement": "if line:",
                        "start_line": 101,
                        "end_line": 161
                    },
                    {
                        "type": "if_statement",
                        "statement": "if not line.startswith('#'):",
                        "start_line": 102,
                        "end_line": 161
                    },
                    {
                        "type": "while_statement",
                        "statement": "while count <= fragment_retries:",
                        "start_line": 112,
                        "end_line": 128
                    },
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 113,
                        "end_line": 128
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "HlsFD",
                        "signature": "class HlsFD(FragmentFD):",
                        "at_line": 27
                    },
                    {
                        "type": "function",
                        "name": "real_download",
                        "signature": "def real_download(self, filename, info_dict):",
                        "at_line": 58
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: youtube_dl/downloader/hls.py\nCode:\n           class HlsFD(FragmentFD):\n               ...\n               def real_download(self, filename, info_dict):\n                   ...\n111 112                        count = 0\n112 113                        while count <= fragment_retries:\n113 114                            try:\n114      -                             success = ctx['dl'].download(frag_filename, {'url': frag_url})\n    115  +                             success = ctx['dl'].download(frag_filename, {\n    116  +                                 'url': frag_url,\n    117  +                                 'http_headers': info_dict.get('http_headers'),\n    118  +                             })\n115 119                                if not success:\n116 120                                    return False\n117 121                                down, frag_sanitized = sanitize_open(frag_filename, 'rb')\n         ...\n",
                "file_path": "youtube_dl/downloader/hls.py",
                "identifiers_before": [
                    "ctx",
                    "download",
                    "frag_filename",
                    "frag_url",
                    "success"
                ],
                "identifiers_after": [
                    "ctx",
                    "download",
                    "frag_filename",
                    "frag_url",
                    "get",
                    "info_dict",
                    "success"
                ],
                "prefix": [
                    "                    count = 0\n",
                    "                    while count <= fragment_retries:\n",
                    "                        try:\n"
                ],
                "suffix": [
                    "                            if not success:\n",
                    "                                return False\n",
                    "                            down, frag_sanitized = sanitize_open(frag_filename, 'rb')\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    1
                ]
            },
            [
                "                            if not success:\n",
                "                                return False\n",
                "                            down, frag_sanitized = sanitize_open(frag_filename, 'rb')\n",
                "                            frag_content = down.read()\n",
                "                            down.close()\n",
                "                            break\n",
                "                        except compat_urllib_error.HTTPError as err:\n",
                "                            # Unavailable (possibly temporary) fragments may be served.\n",
                "                            # First we try to retry then either skip or abort.\n",
                "                            # See https://github.com/rg3/youtube-dl/issues/10165,\n",
                "                            # https://github.com/rg3/youtube-dl/issues/10448).\n",
                "                            count += 1\n",
                "                            if count <= fragment_retries:\n",
                "                                self.report_retry_fragment(err, frag_name, count, fragment_retries)\n",
                "                    if count > fragment_retries:\n",
                "                        if skip_unavailable_fragments:\n",
                "                            i += 1\n",
                "                            media_sequence += 1\n",
                "                            self.report_skip_fragment(frag_name)\n",
                "                            continue\n",
                "                        self.report_error(\n",
                "                            'giving up after %s fragment retries' % fragment_retries)\n",
                "                        return False\n",
                "                    if decrypt_info['METHOD'] == 'AES-128':\n",
                "                        iv = decrypt_info.get('IV') or compat_struct_pack('>8xq', media_sequence)\n",
                "                        frag_content = AES.new(\n",
                "                            decrypt_info['KEY'], AES.MODE_CBC, iv).decrypt(frag_content)\n",
                "                    ctx['dest_stream'].write(frag_content)\n",
                "                    frags_filenames.append(frag_sanitized)\n",
                "                    # We only download the first fragment during the test\n",
                "                    if test:\n",
                "                        break\n",
                "                    i += 1\n",
                "                    media_sequence += 1\n",
                "                elif line.startswith('#EXT-X-KEY'):\n",
                "                    decrypt_info = parse_m3u8_attributes(line[11:])\n",
                "                    if decrypt_info['METHOD'] == 'AES-128':\n",
                "                        if 'IV' in decrypt_info:\n",
                "                            decrypt_info['IV'] = binascii.unhexlify(decrypt_info['IV'][2:].zfill(32))\n",
                "                        if not re.match(r'^https?://', decrypt_info['URI']):\n",
                "                            decrypt_info['URI'] = compat_urlparse.urljoin(\n",
                "                                man_url, decrypt_info['URI'])\n",
                "                        if extra_query:\n",
                "                            decrypt_info['URI'] = update_url_query(decrypt_info['URI'], extra_query)\n",
                "                        decrypt_info['KEY'] = self.ydl.urlopen(decrypt_info['URI']).read()\n",
                "                elif line.startswith('#EXT-X-MEDIA-SEQUENCE'):\n",
                "                    media_sequence = int(line[22:])\n",
                "\n",
                "        self._finish_frag_download(ctx)\n",
                "\n",
                "        for frag_file in frags_filenames:\n",
                "            os.remove(encodeFilename(frag_file))\n",
                "\n",
                "        return True"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                0,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "clone"
        },
        {
            "edit_hunk_pair": [
                1,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "clone"
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        }
    ]
}