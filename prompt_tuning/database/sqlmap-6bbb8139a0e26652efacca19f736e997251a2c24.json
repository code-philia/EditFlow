{
    "language": "python",
    "commit_url": "https://github.com/sqlmapproject/sqlmap/commit/6bbb8139a0e26652efacca19f736e997251a2c24",
    "commit_message": "update (smaller memory footprint in postprocessing phase because of safecharencode part)",
    "commit_snapshots": {
        "lib/core/option.py": [
            [
                "#!/usr/bin/env python\n",
                "\n",
                "\"\"\"\n",
                "$Id$\n",
                "\n",
                "Copyright (c) 2006-2011 sqlmap developers (http://www.sqlmap.org/)\n",
                "See the file 'doc/COPYING' for copying permission\n",
                "\"\"\"\n",
                "\n",
                "import codecs\n",
                "import cookielib\n",
                "import difflib\n",
                "import inspect\n",
                "import logging\n",
                "import os\n",
                "import re\n",
                "import socket\n",
                "import sys\n",
                "import threading\n",
                "import urllib2\n",
                "import urlparse\n",
                "\n",
                "import lib.core.common\n",
                "import lib.core.threads\n",
                "\n",
                "from extra.clientform.clientform import ParseResponse\n",
                "from extra.clientform.clientform import ParseError\n",
                "from extra.keepalive import keepalive\n",
                "from extra.oset.pyoset import oset\n",
                "from lib.controller.checks import checkConnection\n",
                "from lib.core.common import Backend\n",
                "from lib.core.common import dataToStdout\n",
                "from lib.core.common import getPublicTypeMembers\n",
                "from lib.core.common import extractRegexResult\n",
                "from lib.core.common import filterStringValue\n",
                "from lib.core.common import getConsoleWidth\n",
                "from lib.core.common import getFileItems\n",
                "from lib.core.common import getFileType\n",
                "from lib.core.common import normalizePath\n",
                "from lib.core.common import ntToPosixSlashes\n",
                "from lib.core.common import openFile\n",
                "from lib.core.common import parseTargetDirect\n",
                "from lib.core.common import parseTargetUrl\n",
                "from lib.core.common import paths\n",
                "from lib.core.common import randomRange\n",
                "from lib.core.common import randomStr\n",
                "from lib.core.common import readCachedFileContent\n",
                "from lib.core.common import readInput\n",
                "from lib.core.common import runningAsAdmin\n",
                "from lib.core.common import sanitizeStr\n",
                "from lib.core.common import setOptimize\n",
                "from lib.core.common import UnicodeRawConfigParser\n",
                "from lib.core.convert import urldecode\n",
                "from lib.core.data import conf\n",
                "from lib.core.data import kb\n",
                "from lib.core.data import logger\n",
                "from lib.core.data import paths\n",
                "from lib.core.data import queries\n",
                "from lib.core.datatype import AttribDict\n",
                "from lib.core.datatype import InjectionDict\n",
                "from lib.core.defaults import defaults\n",
                "from lib.core.enums import DBMS\n",
                "from lib.core.enums import HTTPHEADER\n",
                "from lib.core.enums import HTTPMETHOD\n",
                "from lib.core.enums import MOBILES\n",
                "from lib.core.enums import PAYLOAD\n",
                "from lib.core.enums import PRIORITY\n",
                "from lib.core.enums import REFLECTIVE_COUNTER\n",
                "from lib.core.exception import sqlmapConnectionException\n",
                "from lib.core.exception import sqlmapFilePathException\n",
                "from lib.core.exception import sqlmapGenericException\n",
                "from lib.core.exception import sqlmapMissingDependence\n",
                "from lib.core.exception import sqlmapMissingMandatoryOptionException\n",
                "from lib.core.exception import sqlmapMissingPrivileges\n",
                "from lib.core.exception import sqlmapSilentQuitException\n",
                "from lib.core.exception import sqlmapSyntaxException\n",
                "from lib.core.exception import sqlmapUnsupportedDBMSException\n",
                "from lib.core.exception import sqlmapUserQuitException\n",
                "from lib.core.optiondict import optDict\n",
                "from lib.core.settings import CODECS_LIST_PAGE\n",
                "from lib.core.settings import DEFAULT_PAGE_ENCODING\n",
                "from lib.core.settings import DEFAULT_TOR_PORTS\n",
                "from lib.core.settings import GENERAL_IP_ADDRESS_REGEX\n",
                "from lib.core.settings import IS_WIN\n",
                "from lib.core.settings import PLATFORM\n",
                "from lib.core.settings import PYVERSION\n",
                "from lib.core.settings import SITE\n",
                "from lib.core.settings import DBMS_DICT\n",
                "from lib.core.settings import SUPPORTED_DBMS\n",
                "from lib.core.settings import SUPPORTED_OS\n",
                "from lib.core.settings import VERSION_STRING\n",
                "from lib.core.settings import MSSQL_ALIASES\n",
                "from lib.core.settings import MYSQL_ALIASES\n",
                "from lib.core.settings import PGSQL_ALIASES\n",
                "from lib.core.settings import ORACLE_ALIASES\n",
                "from lib.core.settings import SQLITE_ALIASES\n",
                "from lib.core.settings import ACCESS_ALIASES\n",
                "from lib.core.settings import FIREBIRD_ALIASES\n",
                "from lib.core.settings import MAXDB_ALIASES\n",
                "from lib.core.settings import SYBASE_ALIASES\n",
                "from lib.core.settings import DB2_ALIASES\n",
                "from lib.core.settings import BURP_SPLITTER\n",
                "from lib.core.settings import LOCALHOST\n",
                "from lib.core.settings import MAX_NUMBER_OF_THREADS\n",
                "from lib.core.settings import TIME_DELAY_CANDIDATES\n",
                "from lib.core.settings import UNKNOWN_DBMS_VERSION\n",
                "from lib.core.settings import WEBSCARAB_SPLITTER\n",
                "from lib.core.update import update\n",
                "from lib.parse.configfile import configFileParser\n",
                "from lib.parse.payloads import loadPayloads\n",
                "from lib.request.connect import Connect as Request\n",
                "from lib.request.proxy import ProxyHTTPSHandler\n",
                "from lib.request.basicauthhandler import SmartHTTPBasicAuthHandler\n",
                "from lib.request.certhandler import HTTPSCertAuthHandler\n",
                "from lib.request.rangehandler import HTTPRangeHandler\n",
                "from lib.request.redirecthandler import SmartRedirectHandler\n",
                "from lib.request.templates import getPageTemplate\n",
                "from lib.utils.crawler import Crawler\n",
                "from lib.utils.deps import checkDependencies\n",
                "from lib.utils.google import Google\n",
                "from xml.etree.ElementTree import ElementTree\n",
                "\n",
                "authHandler = urllib2.BaseHandler()\n",
                "keepAliveHandler = keepalive.HTTPHandler()\n",
                "proxyHandler = urllib2.BaseHandler()\n",
                "redirectHandler = SmartRedirectHandler()\n",
                "rangeHandler = HTTPRangeHandler()\n",
                "\n",
                "def __urllib2Opener():\n",
                "    \"\"\"\n",
                "    This function creates the urllib2 OpenerDirector.\n",
                "    \"\"\"\n",
                "\n",
                "    global authHandler\n",
                "    global keepAliveHandler\n",
                "    global proxyHandler\n",
                "    global rangeHandler\n",
                "    global redirectHandler\n",
                "\n",
                "    debugMsg = \"creating HTTP requests opener object\"\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    handlers = [proxyHandler, authHandler, redirectHandler, rangeHandler]\n",
                "\n",
                "    if not conf.dropSetCookie:\n",
                "        conf.cj = cookielib.LWPCookieJar()\n",
                "        handlers.append(urllib2.HTTPCookieProcessor(conf.cj))\n",
                "\n",
                "    # Reference: http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html\n",
                "    if conf.keepAlive:\n",
                "        warnMsg = \"persistent HTTP(s) connections, Keep-Alive, has \"\n",
                "        warnMsg += \"been disabled because of it's incompatibility \"\n",
                "\n",
                "        if conf.proxy:\n",
                "            warnMsg += \"with HTTP(s) proxy\"\n",
                "            logger.warn(warnMsg)\n",
                "        elif conf.aType:\n",
                "            warnMsg += \"with authentication methods\"\n",
                "            logger.warn(warnMsg)\n",
                "        else:\n",
                "            handlers.append(keepAliveHandler)\n",
                "\n",
                "    opener = urllib2.build_opener(*handlers)\n",
                "    urllib2.install_opener(opener)\n",
                "\n",
                "def __feedTargetsDict(reqFile, addedTargetUrls):\n",
                "    \"\"\"\n",
                "    Parses web scarab and burp logs and adds results to the target url list\n",
                "    \"\"\"\n",
                "\n",
                "    def __parseWebScarabLog(content):\n",
                "        \"\"\"\n",
                "        Parses web scarab logs (POST method not supported)\n",
                "        \"\"\"\n",
                "\n",
                "        reqResList = content.split(WEBSCARAB_SPLITTER)\n",
                "        getPostReq = False\n",
                "\n",
                "        for request in reqResList:\n",
                "            url = extractRegexResult(r\"URL: (?P<result>.+?)\\n\", request, re.I)\n",
                "            method = extractRegexResult(r\"METHOD: (?P<result>.+?)\\n\", request, re.I)\n",
                "            cookie = extractRegexResult(r\"COOKIE: (?P<result>.+?)\\n\", request, re.I)\n",
                "            getPostReq = True\n",
                "\n",
                "            if not method or not url:\n",
                "                logger.debug(\"not a valid WebScarab log data\")\n",
                "                continue\n",
                "\n",
                "            if method.upper() == \"POST\":\n",
                "                warnMsg = \"POST requests from WebScarab logs aren't supported \"\n",
                "                warnMsg += \"as their body content is stored in separate files. \"\n",
                "                warnMsg += \"Nevertheless you can use -r to load them individually.\"\n",
                "                logger.warning(warnMsg)\n",
                "                continue\n",
                "\n",
                "            if conf.scope:\n",
                "                getPostReq &= re.search(conf.scope, url, re.I) is not None\n",
                "\n",
                "            if getPostReq:\n",
                "                if not kb.targetUrls or url not in addedTargetUrls:\n",
                "                    kb.targetUrls.add((url, method, None, cookie))\n",
                "                    addedTargetUrls.add(url)\n",
                "\n",
                "    def __parseBurpLog(content):\n",
                "        \"\"\"\n",
                "        Parses burp logs\n",
                "        \"\"\"\n",
                "        port = None\n",
                "        scheme = None\n",
                "\n",
                "        reqResList = content.split(BURP_SPLITTER)\n",
                "\n",
                "        for request in reqResList:\n",
                "            if scheme is None:\n",
                "                schemePort = re.search(\"\\d\\d[\\:|\\.]\\d\\d[\\:|\\.]\\d\\d\\s+(http[\\w]*)\\:\\/\\/.*?\\:([\\d]+)\", request, re.I)\n",
                "\n",
                "                if schemePort:\n",
                "                    scheme = schemePort.group(1)\n",
                "                    port = schemePort.group(2)\n",
                "\n",
                "            if not re.search (\"^[\\n]*(GET|POST).*?\\sHTTP\\/\", request, re.I):\n",
                "                continue\n",
                "\n",
                "            if re.search(\"^[\\n]*(GET|POST).*?\\.(gif|jpg|png)\\sHTTP\\/\", request, re.I):\n",
                "                continue\n",
                "\n",
                "            getPostReq = False\n",
                "            url = None\n",
                "            host = None\n",
                "            method = None\n",
                "            data = None\n",
                "            cookie = None\n",
                "            params = False\n",
                "            lines = request.split(\"\\n\")\n",
                "\n",
                "            for line in lines:\n",
                "                if len(line) == 0 or line == \"\\n\":\n",
                "                    if method == HTTPMETHOD.POST and data is None:\n",
                "                        data = \"\"\n",
                "                        params = True\n",
                "\n",
                "                elif (line.startswith(\"GET \") or line.startswith(\"POST \")) and \" HTTP/\" in line:\n",
                "                    if line.startswith(\"GET \"):\n",
                "                        index = 4\n",
                "                    else:\n",
                "                        index = 5\n",
                "\n",
                "                    url = line[index:line.index(\" HTTP/\")]\n",
                "                    method = line[:index-1]\n",
                "\n",
                "                    if \"?\" in line and \"=\" in line:\n",
                "                        params = True\n",
                "\n",
                "                    getPostReq = True\n",
                "\n",
                "                # POST parameters\n",
                "                elif data is not None and params:\n",
                "                    data += line\n",
                "\n",
                "                # GET parameters\n",
                "                elif \"?\" in line and \"=\" in line and \": \" not in line:\n",
                "                    params = True\n",
                "\n",
                "                # Headers\n",
                "                elif \": \" in line:\n",
                "                    key, value = line.split(\": \", 1)\n",
                "\n",
                "                    # Cookie and Host headers\n",
                "                    if key.lower() == \"cookie\":\n",
                "                        cookie = value\n",
                "                    elif key.lower() == \"host\":\n",
                "                        if '://' in value:\n",
                "                            scheme, value = value.split('://')[:2]\n",
                "                        splitValue = value.split(\":\")\n",
                "                        host = splitValue[0]\n",
                "\n",
                "                        if len(splitValue) > 1:\n",
                "                            port = filterStringValue(splitValue[1], '[0-9]')\n",
                "\n",
                "                    # Avoid to add a static content length header to\n",
                "                    # conf.httpHeaders and consider the following lines as\n",
                "                    # POSTed data\n",
                "                    if key == \"Content-Length\":\n",
                "                        params = True\n",
                "\n",
                "                    # Avoid proxy and connection type related headers\n",
                "                    elif key not in ( \"Proxy-Connection\", \"Connection\" ):\n",
                "                        conf.httpHeaders.append((str(key), str(value)))\n",
                "\n",
                "            if conf.scope:\n",
                "                getPostReq &= re.search(conf.scope, host) is not None\n",
                "\n",
                "            if getPostReq and (params or cookie):\n",
                "                if not port and isinstance(scheme, basestring) and scheme.lower() == \"https\":\n",
                "                    port = \"443\"\n",
                "                elif not scheme and port == \"443\":\n",
                "                    scheme = \"https\"\n",
                "\n",
                "                if not url.startswith(\"http\"):\n",
                "                    url = \"%s://%s:%s%s\" % (scheme or \"http\", host, port or \"80\", url)\n",
                "                    scheme = None\n",
                "                    port = None\n",
                "\n",
                "                if not kb.targetUrls or url not in addedTargetUrls:\n",
                "                    kb.targetUrls.add((url, method, urldecode(data), cookie))\n",
                "                    addedTargetUrls.add(url)\n",
                "\n",
                "    fp = openFile(reqFile, \"rb\")\n",
                "\n",
                "    content = fp.read()\n",
                "    content = content.replace(\"\\r\", \"\")\n",
                "\n",
                "    if conf.scope:\n",
                "        logger.info(\"using regular expression '%s' for filtering targets\" % conf.scope)\n",
                "\n",
                "    __parseBurpLog(content)\n",
                "    __parseWebScarabLog(content)\n",
                "\n",
                "def __loadQueries():\n",
                "    \"\"\"\n",
                "    Loads queries from 'xml/queries.xml' file.\n",
                "    \"\"\"\n",
                "\n",
                "    def iterate(node, retVal=None):\n",
                "        class DictObject(object):\n",
                "            def __init__(self):\n",
                "                self.__dict__ = {}\n",
                "            def __contains__(self, name):\n",
                "                return name in self.__dict__\n",
                "\n",
                "        if retVal is None:\n",
                "            retVal = DictObject()\n",
                "\n",
                "        for child in node.findall(\"*\"):\n",
                "            instance = DictObject()\n",
                "            retVal.__dict__[child.tag] = instance\n",
                "            if child.attrib:\n",
                "                instance.__dict__.update(child.attrib)\n",
                "            else:\n",
                "                iterate(child, instance)\n",
                "\n",
                "        return retVal\n",
                "\n",
                "    tree = ElementTree()\n",
                "    tree.parse(paths.QUERIES_XML)\n",
                "\n",
                "    for node in tree.findall(\"*\"):\n",
                "        queries[node.attrib['value']] = iterate(node)\n",
                "\n",
                "def __setMultipleTargets():\n",
                "    \"\"\"\n",
                "    Define a configuration parameter if we are running in multiple target\n",
                "    mode.\n",
                "    \"\"\"\n",
                "\n",
                "    initialTargetsCount = len(kb.targetUrls)\n",
                "    addedTargetUrls = set()\n",
                "\n",
                "    if not conf.logFile:\n",
                "        return\n",
                "\n",
                "    debugMsg = \"parsing targets list from '%s'\" % conf.logFile\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    if not os.path.exists(conf.logFile):\n",
                "        errMsg = \"the specified list of targets does not exist\"\n",
                "        raise sqlmapFilePathException, errMsg\n",
                "\n",
                "    if os.path.isfile(conf.logFile):\n",
                "        __feedTargetsDict(conf.logFile, addedTargetUrls)\n",
                "\n",
                "    elif os.path.isdir(conf.logFile):\n",
                "        files = os.listdir(conf.logFile)\n",
                "        files.sort()\n",
                "\n",
                "        for reqFile in files:\n",
                "            if not re.search(\"([\\d]+)\\-request\", reqFile):\n",
                "                continue\n",
                "\n",
                "            __feedTargetsDict(os.path.join(conf.logFile, reqFile), addedTargetUrls)\n",
                "\n",
                "    else:\n",
                "        errMsg = \"the specified list of targets is not a file \"\n",
                "        errMsg += \"nor a directory\"\n",
                "        raise sqlmapFilePathException, errMsg\n",
                "\n",
                "    updatedTargetsCount = len(kb.targetUrls)\n",
                "\n",
                "    if updatedTargetsCount > initialTargetsCount:\n",
                "        infoMsg = \"sqlmap parsed %d \" % (updatedTargetsCount - initialTargetsCount)\n",
                "        infoMsg += \"testable requests from the targets list\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "def __setRequestFromFile():\n",
                "    \"\"\"\n",
                "    This function checks if the way to make a HTTP request is through supplied\n",
                "    textual file, parses it and saves the information into the knowledge base.\n",
                "    \"\"\"\n",
                "\n",
                "    if not conf.requestFile:\n",
                "        return\n",
                "\n",
                "    addedTargetUrls = set()\n",
                "\n",
                "    conf.requestFile = os.path.expanduser(conf.requestFile)\n",
                "\n",
                "    infoMsg = \"parsing HTTP request from '%s'\" % conf.requestFile\n",
                "    logger.info(infoMsg)\n",
                "\n",
                "    if not os.path.isfile(conf.requestFile):\n",
                "        errMsg = \"the specified HTTP request file \"\n",
                "        errMsg += \"does not exist\"\n",
                "        raise sqlmapFilePathException, errMsg\n",
                "\n",
                "    __feedTargetsDict(conf.requestFile, addedTargetUrls)\n",
                "\n",
                "def __setCrawler():\n",
                "    if not conf.crawlDepth:\n",
                "        return\n",
                "\n",
                "    crawler = Crawler()\n",
                "    crawler.getTargetUrls()\n",
                "\n",
                "def __setGoogleDorking():\n",
                "    \"\"\"\n",
                "    This function checks if the way to request testable hosts is through\n",
                "    Google dorking then requests to Google the search parameter, parses\n",
                "    the results and save the testable hosts into the knowledge base.\n",
                "    \"\"\"\n",
                "\n",
                "    if not conf.googleDork:\n",
                "        return\n",
                "\n",
                "    global keepAliveHandler\n",
                "    global proxyHandler\n",
                "\n",
                "    debugMsg = \"initializing Google dorking requests\"\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    infoMsg = \"first request to Google to get the session cookie\"\n",
                "    logger.info(infoMsg)\n",
                "\n",
                "    handlers = [ proxyHandler ]\n",
                "\n",
                "    # Reference: http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html\n",
                "    if conf.keepAlive:\n",
                "        if conf.proxy:\n",
                "            warnMsg = \"persistent HTTP(s) connections, Keep-Alive, has \"\n",
                "            warnMsg += \"been disabled because of it's incompatibility \"\n",
                "            warnMsg += \"with HTTP(s) proxy\"\n",
                "            logger.warn(warnMsg)\n",
                "        else:\n",
                "            handlers.append(keepAliveHandler)\n",
                "\n",
                "    googleObj = Google(handlers)\n",
                "    googleObj.getCookie()\n",
                "\n",
                "    def search():\n",
                "        matches = googleObj.search(conf.googleDork)\n",
                "\n",
                "        if not matches:\n",
                "            errMsg = \"unable to find results for your \"\n",
                "            errMsg += \"Google dork expression\"\n",
                "            raise sqlmapGenericException, errMsg\n",
                "\n",
                "        googleObj.getTargetUrls()\n",
                "        return matches\n",
                "\n",
                "    while True:\n",
                "        matches = search()\n",
                "\n",
                "        if kb.targetUrls:\n",
                "            infoMsg = \"sqlmap got %d results for your \" % len(matches)\n",
                "            infoMsg += \"Google dork expression, \"\n",
                "\n",
                "            if len(matches) == len(kb.targetUrls):\n",
                "                infoMsg += \"all \"\n",
                "            else:\n",
                "                infoMsg += \"%d \" % len(kb.targetUrls)\n",
                "\n",
                "            infoMsg += \"of them are testable targets\"\n",
                "            logger.info(infoMsg)\n",
                "            break\n",
                "\n",
                "        else:\n",
                "            message = \"sqlmap got %d results \" % len(matches)\n",
                "            message += \"for your Google dork expression, but none of them \"\n",
                "            message += \"have GET parameters to test for SQL injection. \"\n",
                "            message += \"Do you want to skip to the next result page? [Y/n]\"\n",
                "            test = readInput(message, default=\"Y\")\n",
                "\n",
                "            if test[0] in (\"n\", \"N\"):\n",
                "                raise sqlmapSilentQuitException\n",
                "            else:\n",
                "                conf.googlePage += 1\n",
                "\n",
                "def __setBulkMultipleTargets():\n",
                "    if not conf.bulkFile:\n",
                "        return\n",
                "\n",
                "    conf.bulkFile = os.path.expanduser(conf.bulkFile)\n",
                "\n",
                "    infoMsg = \"parsing multiple targets list from '%s'\" % conf.bulkFile\n",
                "    logger.info(infoMsg)\n",
                "\n",
                "    if not os.path.isfile(conf.bulkFile):\n",
                "        errMsg = \"the specified bulk file \"\n",
                "        errMsg += \"does not exist\"\n",
                "        raise sqlmapFilePathException, errMsg\n",
                "\n",
                "    f = open(conf.bulkFile, 'r')\n",
                "\n",
                "    for line in f.xreadlines():\n",
                "        if re.search(r\"[^ ]+\\?(.+)\", line, re.I):\n",
                "            kb.targetUrls.add((line.strip(), None, None, None))\n",
                "\n",
                "    f.close()\n",
                "\n",
                "def __findPageForms():\n",
                "    if not conf.forms:\n",
                "        return\n",
                "\n",
                "    if not checkConnection():\n",
                "        return\n",
                "\n",
                "    infoMsg = \"searching for forms\"\n",
                "    logger.info(infoMsg)\n",
                "\n",
                "    response, _ = Request.queryPage(response=True)\n",
                "\n",
                "    if response is None or isinstance(response, basestring):\n",
                "        errMsg = \"can't do form parsing as no valid response \"\n",
                "        errMsg += \"object found. please check previous log messages \"\n",
                "        errMsg += \"for connection issues\"\n",
                "        raise sqlmapGenericException, errMsg\n",
                "\n",
                "    try:\n",
                "        forms = ParseResponse(response, backwards_compat=False)\n",
                "    except ParseError:\n",
                "        errMsg = \"badly formed HTML at the target url. can't parse forms\"\n",
                "        raise sqlmapGenericException, errMsg\n",
                "\n",
                "    if forms:\n",
                "        for form in forms:\n",
                "            for control in form.controls:\n",
                "                if hasattr(control, 'items'):\n",
                "                    # if control has selectable items select first non-disabled\n",
                "                    for item in control.items:\n",
                "                        if not item.disabled:\n",
                "                            item.selected = True\n",
                "                            break\n",
                "            request = form.click()\n",
                "            url = urldecode(request.get_full_url(), kb.pageEncoding)\n",
                "            method = request.get_method()\n",
                "            data = urldecode(request.get_data(), kb.pageEncoding) if request.has_data() else None\n",
                "            if not data and method and method.upper() == HTTPMETHOD.POST:\n",
                "                debugMsg = \"invalid POST form with blank data detected\"\n",
                "                logger.debug(debugMsg)\n",
                "                continue\n",
                "            target = (url, method, data, conf.cookie)\n",
                "            kb.targetUrls.add(target)\n",
                "            kb.formNames.append(target)\n",
                "    else:\n",
                "        errMsg = \"there were no forms found at the given target url\"\n",
                "        raise sqlmapGenericException, errMsg\n",
                "\n",
                "def __setMetasploit():\n",
                "    if not conf.osPwn and not conf.osSmb and not conf.osBof:\n",
                "        return\n",
                "\n",
                "    debugMsg = \"setting the takeover out-of-band functionality\"\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    msfEnvPathExists = False\n",
                "\n",
                "    if IS_WIN:\n",
                "        warnMsg = \"some sqlmap takeover functionalities are not yet \"\n",
                "        warnMsg += \"supported on Windows. Please use Linux in a virtual \"\n",
                "        warnMsg += \"machine for out-of-band features.\"\n",
                "\n",
                "        logger.critical(warnMsg)\n",
                "\n",
                "        raise sqlmapSilentQuitException\n",
                "\n",
                "    if conf.osSmb:\n",
                "        isAdmin = runningAsAdmin()\n",
                "\n",
                "        if isAdmin is not True:\n",
                "            errMsg = \"you need to run sqlmap as an administrator \"\n",
                "            errMsg += \"if you want to perform a SMB relay attack because \"\n",
                "            errMsg += \"it will need to listen on a user-specified SMB \"\n",
                "            errMsg += \"TCP port for incoming connection attempts\"\n",
                "            raise sqlmapMissingPrivileges, errMsg\n",
                "\n",
                "    if conf.msfPath:\n",
                "        condition = False\n",
                "\n",
                "        for path in [conf.msfPath, os.path.join(conf.msfPath, 'bin')]:\n",
                "            condition = os.path.exists(normalizePath(path))\n",
                "            condition &= os.path.exists(normalizePath(os.path.join(path, \"msfcli\")))\n",
                "            condition &= os.path.exists(normalizePath(os.path.join(path, \"msfconsole\")))\n",
                "            condition &= os.path.exists(normalizePath(os.path.join(path, \"msfencode\")))\n",
                "            condition &= os.path.exists(normalizePath(os.path.join(path, \"msfpayload\")))\n",
                "\n",
                "            if condition:\n",
                "                conf.msfPath = path\n",
                "                break\n",
                "\n",
                "        if condition:\n",
                "            debugMsg = \"provided Metasploit Framework 3 path \"\n",
                "            debugMsg += \"'%s' is valid\" % conf.msfPath\n",
                "            logger.debug(debugMsg)\n",
                "\n",
                "            msfEnvPathExists = True\n",
                "        else:\n",
                "            warnMsg = \"the provided Metasploit Framework 3 path \"\n",
                "            warnMsg += \"'%s' is not valid. The cause could \" % conf.msfPath\n",
                "            warnMsg += \"be that the path does not exists or that one \"\n",
                "            warnMsg += \"or more of the needed Metasploit executables \"\n",
                "            warnMsg += \"within msfcli, msfconsole, msfencode and \"\n",
                "            warnMsg += \"msfpayload do not exist\"\n",
                "            logger.warn(warnMsg)\n",
                "    else:\n",
                "        warnMsg = \"you did not provide the local path where Metasploit \"\n",
                "        warnMsg += \"Framework 3 is installed\"\n",
                "        logger.warn(warnMsg)\n",
                "\n",
                "    if not msfEnvPathExists:\n",
                "        warnMsg = \"sqlmap is going to look for Metasploit Framework 3 \"\n",
                "        warnMsg += \"installation into the environment paths\"\n",
                "        logger.warn(warnMsg)\n",
                "\n",
                "        envPaths = os.environ[\"PATH\"]\n",
                "\n",
                "        if IS_WIN:\n",
                "            envPaths = envPaths.split(\";\")\n",
                "        else:\n",
                "            envPaths = envPaths.split(\":\")\n",
                "\n",
                "        for envPath in envPaths:\n",
                "            envPath = envPath.replace(\";\", \"\")\n",
                "            condition = os.path.exists(normalizePath(envPath))\n",
                "            condition &= os.path.exists(normalizePath(os.path.join(envPath, \"msfcli\")))\n",
                "            condition &= os.path.exists(normalizePath(os.path.join(envPath, \"msfconsole\")))\n",
                "            condition &= os.path.exists(normalizePath(os.path.join(envPath, \"msfencode\")))\n",
                "            condition &= os.path.exists(normalizePath(os.path.join(envPath, \"msfpayload\")))\n",
                "\n",
                "            if condition:\n",
                "                infoMsg = \"Metasploit Framework 3 has been found \"\n",
                "                infoMsg += \"installed in the '%s' path\" % envPath\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                msfEnvPathExists = True\n",
                "                conf.msfPath = envPath\n",
                "\n",
                "                break\n",
                "\n",
                "    if not msfEnvPathExists:\n",
                "        errMsg = \"unable to locate Metasploit Framework 3 installation. \"\n",
                "        errMsg += \"Get it from http://metasploit.com/framework/download/\"\n",
                "        raise sqlmapFilePathException, errMsg\n",
                "\n",
                "def __setWriteFile():\n",
                "    if not conf.wFile:\n",
                "        return\n",
                "\n",
                "    debugMsg = \"setting the write file functionality\"\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    if not os.path.exists(conf.wFile):\n",
                "        errMsg = \"the provided local file '%s' does not exist\" % conf.wFile\n",
                "        raise sqlmapFilePathException, errMsg\n",
                "\n",
                "    if not conf.dFile:\n",
                "        errMsg = \"you did not provide the back-end DBMS absolute path \"\n",
                "        errMsg += \"where you want to write the local file '%s'\" % conf.wFile\n",
                "        raise sqlmapMissingMandatoryOptionException, errMsg\n",
                "\n",
                "    conf.wFileType = getFileType(conf.wFile)\n",
                "\n",
                "def __setOS():\n",
                "    \"\"\"\n",
                "    Force the back-end DBMS operating system option.\n",
                "    \"\"\"\n",
                "\n",
                "    if not conf.os:\n",
                "        return\n",
                "\n",
                "    if conf.os.lower() not in SUPPORTED_OS:\n",
                "        errMsg = \"you provided an unsupported back-end DBMS operating \"\n",
                "        errMsg += \"system. The supported DBMS operating systems for OS \"\n",
                "        errMsg += \"and file system access are %s. \" % ', '.join([o.capitalize() for o in SUPPORTED_OS])\n",
                "        errMsg += \"If you do not know the back-end DBMS underlying OS, \"\n",
                "        errMsg += \"do not provide it and sqlmap will fingerprint it for \"\n",
                "        errMsg += \"you.\"\n",
                "        raise sqlmapUnsupportedDBMSException, errMsg\n",
                "\n",
                "    debugMsg = \"forcing back-end DBMS operating system to user defined \"\n",
                "    debugMsg += \"value '%s'\" % conf.os\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    Backend.setOs(conf.os)\n",
                "\n",
                "def __setTechnique():\n",
                "    validTechniques = sorted(getPublicTypeMembers(PAYLOAD.TECHNIQUE), key=lambda x: x[1])\n",
                "    validLetters = map(lambda x: x[0][0].upper(), validTechniques)\n",
                "\n",
                "    if conf.tech and isinstance(conf.tech, basestring):\n",
                "        selTechniques = []\n",
                "\n",
                "        for letter in conf.tech.upper():\n",
                "            if letter not in validLetters:\n",
                "                errMsg = \"value for --technique must be a string composed \"\n",
                "                errMsg += \"by the letters %s. Refer to the \" % \", \".join(validLetters)\n",
                "                errMsg += \"user's manual for details\"\n",
                "                raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "            for validTech, validInt in validTechniques:\n",
                "                if letter == validTech[0]:\n",
                "                    selTechniques.append(validInt)\n",
                "                    break\n",
                "\n",
                "        conf.tech = selTechniques\n",
                "\n",
                "    if len(conf.tech) > 0:\n",
                "        # TODO: consider MySQL/PHP/ASP/web backdoor case where stacked\n",
                "        # queries is technically not necessary\n",
                "        if any(map(lambda x: conf.__getitem__(x), ['rFile', 'wFile', \\\n",
                "           'osCmd', 'osShell', 'osPwn', 'osSmb', 'osBof', 'regRead', \\\n",
                "           'regAdd', 'regDel'])) and PAYLOAD.TECHNIQUE.STACKED not in conf.tech:\n",
                "            errMsg = \"value for --technique must include stacked queries \"\n",
                "            errMsg += \"technique (S) when you want to access the file \"\n",
                "            errMsg += \"system, takeover the operating system or access \"\n",
                "            errMsg += \"Windows registry hives\"\n",
                "            raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "def __setDBMS():\n",
                "    \"\"\"\n",
                "    Force the back-end DBMS option.\n",
                "    \"\"\"\n",
                "\n",
                "    if not conf.dbms:\n",
                "        return\n",
                "\n",
                "    debugMsg = \"forcing back-end DBMS to user defined value\"\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    conf.dbms = conf.dbms.lower()\n",
                "    regex = re.search(\"%s ([\\d\\.]+)\" % (\"(%s)\" % \"|\".join([alias for alias in SUPPORTED_DBMS])), conf.dbms, re.I)\n",
                "\n",
                "    if regex:\n",
                "        conf.dbms = regex.group(1)\n",
                "        Backend.setVersion(regex.group(2))\n",
                "\n",
                "    if conf.dbms not in SUPPORTED_DBMS:\n",
                "        errMsg = \"you provided an unsupported back-end database management \"\n",
                "        errMsg += \"system. The supported DBMS are %s. \" % ', '.join([d for d in DBMS_DICT])\n",
                "        errMsg += \"If you do not know the back-end DBMS, do not provide \"\n",
                "        errMsg += \"it and sqlmap will fingerprint it for you.\"\n",
                "        raise sqlmapUnsupportedDBMSException, errMsg\n",
                "\n",
                "    for aliases in (MSSQL_ALIASES, MYSQL_ALIASES, PGSQL_ALIASES, ORACLE_ALIASES, \\\n",
                "                    SQLITE_ALIASES, ACCESS_ALIASES, FIREBIRD_ALIASES, \\\n",
                "                    MAXDB_ALIASES, SYBASE_ALIASES, DB2_ALIASES):\n",
                "        if conf.dbms in aliases:\n",
                "            conf.dbms = aliases[0]\n",
                "\n",
                "            break\n",
                "\n",
                "def __setTamperingFunctions():\n",
                "    \"\"\"\n",
                "    Loads tampering functions from given script(s)\n",
                "    \"\"\"\n",
                "\n",
                "    if conf.tamper:\n",
                "        last_priority = PRIORITY.HIGHEST\n",
                "        check_priority = True\n",
                "        resolve_priorities = False\n",
                "        priorities = []\n",
                "\n",
                "        for tfile in re.split(r'[,|;]', conf.tamper):\n",
                "            found = False\n",
                "\n",
                "            tfile = tfile.strip()\n",
                "\n",
                "            if not tfile:\n",
                "                continue\n",
                "\n",
                "            elif os.path.exists(os.path.join(paths.SQLMAP_TAMPER_PATH, tfile if tfile.endswith('.py') else \"%s.py\" % tfile)):\n",
                "                tfile = os.path.join(paths.SQLMAP_TAMPER_PATH, tfile if tfile.endswith('.py') else \"%s.py\" % tfile)\n",
                "\n",
                "            elif not os.path.exists(tfile):\n",
                "                errMsg = \"tamper script '%s' does not exist\" % tfile\n",
                "                raise sqlmapFilePathException, errMsg\n",
                "\n",
                "            elif not tfile.endswith('.py'):\n",
                "                errMsg = \"tamper script '%s' should have an extension '.py'\" % tfile\n",
                "                raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "            dirname, filename = os.path.split(tfile)\n",
                "            dirname = os.path.abspath(dirname)\n",
                "\n",
                "            infoMsg = \"loading tamper script '%s'\" % filename[:-3]\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            if not os.path.exists(os.path.join(dirname, '__init__.py')):\n",
                "                errMsg = \"make sure that there is an empty file '__init__.py' \"\n",
                "                errMsg += \"inside of tamper scripts directory '%s'\" % dirname\n",
                "                raise sqlmapGenericException, errMsg\n",
                "\n",
                "            if dirname not in sys.path:\n",
                "                sys.path.insert(0, dirname)\n",
                "\n",
                "            try:\n",
                "                module = __import__(filename[:-3])\n",
                "            except ImportError, msg:\n",
                "                raise sqlmapSyntaxException, \"can not import tamper script '%s' (%s)\" % (filename[:-3], msg)\n",
                "\n",
                "            priority = PRIORITY.NORMAL if not hasattr(module, '__priority__') else module.__priority__\n",
                "\n",
                "            for name, function in inspect.getmembers(module, inspect.isfunction):\n",
                "                if name == \"tamper\" and function.func_code.co_argcount == 1:\n",
                "                    found = True\n",
                "                    kb.tamperFunctions.append(function)\n",
                "\n",
                "                    if check_priority and priority > last_priority:\n",
                "                        message = \"it seems that you might have mixed \"\n",
                "                        message += \"the order of tamper scripts.\\n\"\n",
                "                        message += \"Do you want to auto resolve this? [Y/n/q] \"\n",
                "                        test = readInput(message, default=\"Y\")\n",
                "\n",
                "                        if not test or test[0] in (\"y\", \"Y\"):\n",
                "                            resolve_priorities = True\n",
                "                        elif test[0] in (\"n\", \"N\"):\n",
                "                            resolve_priorities = False\n",
                "                        elif test[0] in (\"q\", \"Q\"):\n",
                "                            raise sqlmapUserQuitException\n",
                "\n",
                "                        check_priority = False\n",
                "\n",
                "                    priorities.append((priority, function))\n",
                "                    last_priority = priority\n",
                "\n",
                "                    break\n",
                "                elif name == \"dependencies\":\n",
                "                    function()\n",
                "\n",
                "            if not found:\n",
                "                raise sqlmapGenericException, \"missing function 'tamper(value)' in tamper script '%s'\" % tfile\n",
                "\n",
                "        if resolve_priorities and priorities:\n",
                "            priorities.sort(reverse=True)\n",
                "            kb.tamperFunctions = []\n",
                "\n",
                "            for _, function in priorities:\n",
                "                kb.tamperFunctions.append(function)\n",
                "\n",
                "def __setThreads():\n",
                "    if not isinstance(conf.threads, int) or conf.threads <= 0:\n",
                "        conf.threads = 1\n",
                "\n",
                "def __setDNSCache():\n",
                "    \"\"\"\n",
                "    Makes a cached version of socket._getaddrinfo to avoid subsequent DNS requests.\n",
                "    \"\"\"\n",
                "\n",
                "    def _getaddrinfo(*args, **kwargs):\n",
                "        if args in kb.cache:\n",
                "            return kb.cache[args]\n",
                "\n",
                "        else:\n",
                "            kb.cache[args] = socket._getaddrinfo(*args, **kwargs)\n",
                "            return kb.cache[args]\n",
                "\n",
                "    if not hasattr(socket, '_getaddrinfo'):\n",
                "        socket._getaddrinfo = socket.getaddrinfo\n",
                "        socket.getaddrinfo = _getaddrinfo\n",
                "\n",
                "def __setHTTPProxy():\n",
                "    \"\"\"\n",
                "    Check and set the HTTP proxy to pass by all HTTP requests.\n",
                "    \"\"\"\n",
                "\n",
                "    global proxyHandler\n",
                "\n",
                "    if not conf.proxy:\n",
                "        if conf.hostname in ('localhost', '127.0.0.1') or conf.ignoreProxy:\n",
                "            proxyHandler = urllib2.ProxyHandler({})\n",
                "\n",
                "        return\n",
                "\n",
                "    debugMsg = \"setting the HTTP proxy to pass by all HTTP requests\"\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    __proxySplit = urlparse.urlsplit(conf.proxy)\n",
                "    __hostnamePort = __proxySplit[1].split(\":\")\n",
                "\n",
                "    __scheme = __proxySplit[0]\n",
                "    __hostname = __hostnamePort[0]\n",
                "    __port = None\n",
                "    __proxyString = \"\"\n",
                "\n",
                "    if len(__hostnamePort) == 2:\n",
                "        try:\n",
                "            __port = int(__hostnamePort[1])\n",
                "        except:\n",
                "            pass #drops into the next check block\n",
                "\n",
                "    if not __scheme or not __hostname or not __port:\n",
                "        errMsg = \"proxy value must be in format 'http://url:port'\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.pCred:\n",
                "        pCredRegExp = re.search(\"^(.*?):(.*?)$\", conf.pCred)\n",
                "\n",
                "        if not pCredRegExp:\n",
                "            errMsg = \"Proxy authentication credentials \"\n",
                "            errMsg += \"value must be in format username:password\"\n",
                "            raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "        # Reference: http://stackoverflow.com/questions/34079/how-to-specify-an-authenticated-proxy-for-a-python-http-connection\n",
                "        __proxyString = \"%s@\" % conf.pCred\n",
                "\n",
                "    __proxyString += \"%s:%d\" % (__hostname, __port)\n",
                "\n",
                "    # Workaround for http://bugs.python.org/issue1424152 (urllib/urllib2:\n",
                "    # HTTPS over (Squid) Proxy fails) as long as HTTP over SSL requests\n",
                "    # can't be tunneled over an HTTP proxy natively by Python (<= 2.5)\n",
                "    # urllib2 standard library\n",
                "    if PYVERSION >= \"2.6\":\n",
                "        proxyHandler = urllib2.ProxyHandler({\"http\": __proxyString, \"https\": __proxyString})\n",
                "    elif conf.scheme == \"https\":\n",
                "        proxyHandler = ProxyHTTPSHandler(__proxyString)\n",
                "    else:\n",
                "        proxyHandler = urllib2.ProxyHandler({\"http\": __proxyString})\n",
                "\n",
                "def __setSafeUrl():\n",
                "    \"\"\"\n",
                "    Check and set the safe URL options.\n",
                "    \"\"\"\n",
                "    if not conf.safUrl:\n",
                "        return\n",
                "\n",
                "    if not re.search(\"^http[s]*://\", conf.safUrl):\n",
                "        if \":443/\" in conf.safUrl:\n",
                "            conf.safUrl = \"https://\" + conf.safUrl\n",
                "        else:\n",
                "            conf.safUrl = \"http://\" + conf.safUrl\n",
                "\n",
                "    if conf.saFreq <= 0:\n",
                "        errMsg = \"please provide a valid value (>0) for safe frequency (--safe-freq) while using safe url feature\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "def __setPrefixSuffix():\n",
                "    if conf.prefix is not None and conf.suffix is None:\n",
                "        errMsg = \"you specified the payload prefix, but did not provide \"\n",
                "        errMsg += \"the payload suffix\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "    elif conf.prefix is None and conf.suffix is not None:\n",
                "        errMsg = \"you specified the payload suffix, but did not provide \"\n",
                "        errMsg += \"the payload prefix\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.prefix is not None and conf.suffix is not None:\n",
                "        # Create a custom boundary object for user's supplied prefix\n",
                "        # and suffix\n",
                "        boundary = AttribDict()\n",
                "\n",
                "        boundary.level = 1\n",
                "        boundary.clause = [ 0 ]\n",
                "        boundary.where = [ 1, 2, 3 ]\n",
                "        boundary.prefix = conf.prefix\n",
                "        boundary.suffix = conf.suffix\n",
                "\n",
                "        if \" like\" in boundary.suffix.lower():\n",
                "            if \"'\" in boundary.suffix.lower():\n",
                "                boundary.ptype = 3\n",
                "            elif '\"' in boundary.suffix.lower():\n",
                "                boundary.ptype = 5\n",
                "        elif \"'\" in boundary.suffix:\n",
                "            boundary.ptype = 2\n",
                "        elif '\"' in boundary.suffix:\n",
                "            boundary.ptype = 4\n",
                "        else:\n",
                "            boundary.ptype = 1\n",
                "\n",
                "        # user who provides --prefix/--suffix does not want other boundaries\n",
                "        # to be tested for\n",
                "        conf.boundaries = [ boundary ]\n",
                "\n",
                "def __setHTTPAuthentication():\n",
                "    \"\"\"\n",
                "    Check and set the HTTP(s) authentication method (Basic, Digest, NTLM or Certificate),\n",
                "    username and password for first three methods, or key file and certification file for\n",
                "    certificate authentication\n",
                "    \"\"\"\n",
                "\n",
                "    global authHandler\n",
                "\n",
                "    if not conf.aType and not conf.aCred and not conf.aCert:\n",
                "        return\n",
                "\n",
                "    elif conf.aType and not conf.aCred:\n",
                "        errMsg = \"you specified the HTTP authentication type, but \"\n",
                "        errMsg += \"did not provide the credentials\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    elif not conf.aType and conf.aCred:\n",
                "        errMsg = \"you specified the HTTP authentication credentials, \"\n",
                "        errMsg += \"but did not provide the type\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if not conf.aCert:\n",
                "        debugMsg = \"setting the HTTP authentication type and credentials\"\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "        aTypeLower = conf.aType.lower()\n",
                "\n",
                "        if aTypeLower not in ( \"basic\", \"digest\", \"ntlm\" ):\n",
                "            errMsg = \"HTTP authentication type value must be \"\n",
                "            errMsg += \"Basic, Digest or NTLM\"\n",
                "            raise sqlmapSyntaxException, errMsg\n",
                "        elif aTypeLower in ( \"basic\", \"digest\" ):\n",
                "            regExp = \"^(.*?):(.*?)$\"\n",
                "            errMsg = \"HTTP %s authentication credentials \" % aTypeLower\n",
                "            errMsg += \"value must be in format username:password\"\n",
                "        elif aTypeLower == \"ntlm\":\n",
                "            regExp = \"^(.*\\\\\\\\.*):(.*?)$\"\n",
                "            errMsg = \"HTTP NTLM authentication credentials value must \"\n",
                "            errMsg += \"be in format DOMAIN\\username:password\"\n",
                "\n",
                "        aCredRegExp = re.search(regExp, conf.aCred)\n",
                "\n",
                "        if not aCredRegExp:\n",
                "            raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "        authUsername = aCredRegExp.group(1)\n",
                "        authPassword = aCredRegExp.group(2)\n",
                "\n",
                "        passwordMgr = urllib2.HTTPPasswordMgrWithDefaultRealm()\n",
                "        passwordMgr.add_password(None, \"%s://%s\" % (conf.scheme, conf.hostname), authUsername, authPassword)\n",
                "\n",
                "        if aTypeLower == \"basic\":\n",
                "            authHandler = SmartHTTPBasicAuthHandler(passwordMgr)\n",
                "\n",
                "        elif aTypeLower == \"digest\":\n",
                "            authHandler = urllib2.HTTPDigestAuthHandler(passwordMgr)\n",
                "\n",
                "        elif aTypeLower == \"ntlm\":\n",
                "            try:\n",
                "                from ntlm import HTTPNtlmAuthHandler\n",
                "            except ImportError, _:\n",
                "                errMsg = \"sqlmap requires Python NTLM third-party library \"\n",
                "                errMsg += \"in order to authenticate via NTLM, \"\n",
                "                errMsg += \"http://code.google.com/p/python-ntlm/\"\n",
                "                raise sqlmapMissingDependence, errMsg\n",
                "\n",
                "            authHandler = HTTPNtlmAuthHandler.HTTPNtlmAuthHandler(passwordMgr)\n",
                "    else:\n",
                "        debugMsg = \"setting the HTTP(s) authentication certificate\"\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "        aCertRegExp = re.search(\"^(.+?),\\s*(.+?)$\", conf.aCert)\n",
                "\n",
                "        if not aCertRegExp:\n",
                "            errMsg = \"HTTP authentication certificate option \"\n",
                "            errMsg += \"must be in format key_file,cert_file\"\n",
                "            raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "        # os.path.expanduser for support of paths with ~\n",
                "        key_file = os.path.expanduser(aCertRegExp.group(1))\n",
                "        cert_file = os.path.expanduser(aCertRegExp.group(2))\n",
                "\n",
                "        for ifile in (key_file, cert_file):\n",
                "            if not os.path.exists(ifile):\n",
                "                errMsg = \"File '%s' does not exist\" % ifile\n",
                "                raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "        authHandler = HTTPSCertAuthHandler(key_file, cert_file)\n",
                "\n",
                "def __setHTTPMethod():\n",
                "    \"\"\"\n",
                "    Check and set the HTTP method to perform HTTP requests through.\n",
                "    \"\"\"\n",
                "\n",
                "    if conf.data:\n",
                "        conf.method = HTTPMETHOD.POST\n",
                "    else:\n",
                "        conf.method = HTTPMETHOD.GET\n",
                "\n",
                "    debugMsg = \"setting the HTTP method to %s\" % conf.method\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "def __setHTTPExtraHeaders():\n",
                "    if conf.headers:\n",
                "        debugMsg = \"setting extra HTTP headers\"\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "        conf.headers = conf.headers.split(\"\\n\")\n",
                "\n",
                "        for headerValue in conf.headers:\n",
                "            header, value = headerValue.split(\": \")\n",
                "\n",
                "            if header and value:\n",
                "                conf.httpHeaders.append((header, value))\n",
                "\n",
                "    elif not conf.httpHeaders or len(conf.httpHeaders) == 1:\n",
                "        conf.httpHeaders.append((\"Accept-Language\", \"en-us,en;q=0.5\"))\n",
                "        conf.httpHeaders.append((\"Accept-Charset\", \"ISO-8859-15,utf-8;q=0.7,*;q=0.7\"))\n",
                "\n",
                "        # Invalidating any caching mechanism in between\n",
                "        # Reference: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\n",
                "        conf.httpHeaders.append((\"Cache-Control\", \"no-cache,no-store\"))\n",
                "        conf.httpHeaders.append((\"Pragma\", \"no-cache\"))\n",
                "\n",
                "def __defaultHTTPUserAgent():\n",
                "    \"\"\"\n",
                "    @return: default sqlmap HTTP User-Agent header\n",
                "    @rtype: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    return \"%s (%s)\" % (VERSION_STRING, SITE)\n",
                "\n",
                "    # Firefox 3 running on Ubuntu 9.04 updated at April 2009\n",
                "    #return \"Mozilla/5.0 (X11; U; Linux i686; en-GB; rv:1.9.0.9) Gecko/2009042113 Ubuntu/9.04 (jaunty) Firefox/3.0.9\"\n",
                "\n",
                "    # Internet Explorer 7.0 running on Windows 2003 Service Pack 2 english\n",
                "    # updated at March 2009\n",
                "    #return \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.04506.648; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\"\n",
                "\n",
                "def __setHTTPUserAgent():\n",
                "    \"\"\"\n",
                "    Set the HTTP User-Agent header.\n",
                "    Depending on the user options it can be:\n",
                "\n",
                "        * The default sqlmap string\n",
                "        * A default value read as user option\n",
                "        * A random value read from a list of User-Agent headers from a\n",
                "          file choosed as user option\n",
                "    \"\"\"\n",
                "\n",
                "    if conf.mobile:\n",
                "        message = \"which smartphone do you want sqlmap to imitate \"\n",
                "        message += \"through HTTP User-Agent header?\\n\"\n",
                "        items = sorted(getPublicTypeMembers(MOBILES, True))\n",
                "\n",
                "        for count in xrange(len(items)):\n",
                "            item = items[count]\n",
                "            message += \"[%d] %s%s\\n\" % (count + 1, item[:item.find(';')], \" (default)\" if item == MOBILES.IPHONE else \"\")\n",
                "\n",
                "        test = readInput(message.rstrip('\\n'), default=items.index(MOBILES.IPHONE) + 1)\n",
                "\n",
                "        try:\n",
                "            item = items[int(test) - 1]\n",
                "        except:\n",
                "            item = MOBILES.IPHONE\n",
                "\n",
                "        item = item[item.find(';') + 1:]\n",
                "\n",
                "        conf.httpHeaders.append((\"User-Agent\", item))\n",
                "\n",
                "    elif conf.agent:\n",
                "        debugMsg = \"setting the HTTP User-Agent header\"\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "        conf.httpHeaders.append((\"User-Agent\", conf.agent))\n",
                "\n",
                "    elif not conf.randomAgent:\n",
                "        addDefaultUserAgent = True\n",
                "\n",
                "        for header, _ in conf.httpHeaders:\n",
                "            if header == \"User-Agent\":\n",
                "                addDefaultUserAgent = False\n",
                "                break\n",
                "\n",
                "        if addDefaultUserAgent:\n",
                "            conf.httpHeaders.append((\"User-Agent\", __defaultHTTPUserAgent()))\n",
                "\n",
                "    else:\n",
                "        if not kb.userAgents:\n",
                "            debugMsg = \"loading random HTTP User-Agent header(s) from \"\n",
                "            debugMsg += \"file '%s'\" % paths.USER_AGENTS\n",
                "            logger.debug(debugMsg)\n",
                "\n",
                "            try:\n",
                "                kb.userAgents = getFileItems(paths.USER_AGENTS)\n",
                "            except IOError:\n",
                "                warnMsg = \"unable to read HTTP User-Agent header \"\n",
                "                warnMsg += \"file '%s'\" % paths.USER_AGENTS\n",
                "                logger.warn(warnMsg)\n",
                "\n",
                "                conf.httpHeaders.append((HTTPHEADER.USER_AGENT, __defaultHTTPUserAgent()))\n",
                "                return\n",
                "\n",
                "        count = len(kb.userAgents)\n",
                "\n",
                "        if count == 1:\n",
                "            userAgent = kb.userAgents[0]\n",
                "        else:\n",
                "            userAgent = kb.userAgents[randomRange(stop=count-1)]\n",
                "\n",
                "        userAgent = sanitizeStr(userAgent)\n",
                "        conf.httpHeaders.append((HTTPHEADER.USER_AGENT, userAgent))\n",
                "\n",
                "        infoMsg = \"fetched random HTTP User-Agent header from \"\n",
                "        infoMsg += \"file '%s': %s\" % (paths.USER_AGENTS, userAgent)\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "def __setHTTPReferer():\n",
                "    \"\"\"\n",
                "    Set the HTTP Referer\n",
                "    \"\"\"\n",
                "\n",
                "    if conf.referer:\n",
                "        debugMsg = \"setting the HTTP Referer header\"\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "        conf.httpHeaders.append((HTTPHEADER.REFERER, conf.referer))\n",
                "\n",
                "def __setHTTPCookies():\n",
                "    \"\"\"\n",
                "    Set the HTTP Cookie header\n",
                "    \"\"\"\n",
                "\n",
                "    if conf.cookie:\n",
                "        debugMsg = \"setting the HTTP Cookie header\"\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "        conf.httpHeaders.append((HTTPHEADER.COOKIE, conf.cookie))\n",
                "\n",
                "def __setHTTPTimeout():\n",
                "    \"\"\"\n",
                "    Set the HTTP timeout\n",
                "    \"\"\"\n",
                "\n",
                "    if conf.timeout:\n",
                "        debugMsg = \"setting the HTTP timeout\"\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "        conf.timeout = float(conf.timeout)\n",
                "\n",
                "        if conf.timeout < 3.0:\n",
                "            warnMsg = \"the minimum HTTP timeout is 3 seconds, sqlmap \"\n",
                "            warnMsg += \"will going to reset it\"\n",
                "            logger.warn(warnMsg)\n",
                "\n",
                "            conf.timeout = 3.0\n",
                "    else:\n",
                "        conf.timeout = 30.0\n",
                "\n",
                "    socket.setdefaulttimeout(conf.timeout)\n",
                "\n",
                "def __checkDependencies():\n",
                "    \"\"\"\n",
                "    Checks for missing dependencies.\n",
                "    \"\"\"\n",
                "\n",
                "    if conf.dependencies:\n",
                "        checkDependencies()\n",
                "\n",
                "def __cleanupOptions():\n",
                "    \"\"\"\n",
                "    Cleanup configuration attributes.\n",
                "    \"\"\"\n",
                "\n",
                "    debugMsg = \"cleaning up configuration parameters\"\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    width = getConsoleWidth()\n",
                "\n",
                "    if conf.eta:\n",
                "        conf.progressWidth = width-26\n",
                "    else:\n",
                "        conf.progressWidth = width-46\n",
                "\n",
                "    if conf.testParameter:\n",
                "        conf.testParameter = urldecode(conf.testParameter)\n",
                "        conf.testParameter = conf.testParameter.replace(\" \", \"\")\n",
                "        conf.testParameter = conf.testParameter.split(\",\")\n",
                "    else:\n",
                "        conf.testParameter = []\n",
                "\n",
                "    if conf.user:\n",
                "        conf.user = conf.user.replace(\" \", \"\")\n",
                "\n",
                "    if conf.delay:\n",
                "        conf.delay = float(conf.delay)\n",
                "\n",
                "    if conf.rFile:\n",
                "        conf.rFile = ntToPosixSlashes(normalizePath(conf.rFile))\n",
                "\n",
                "    if conf.wFile:\n",
                "        conf.wFile = ntToPosixSlashes(normalizePath(conf.wFile))\n",
                "\n",
                "    if conf.dFile:\n",
                "        conf.dFile = ntToPosixSlashes(normalizePath(conf.dFile))\n",
                "\n",
                "    if conf.msfPath:\n",
                "        conf.msfPath = ntToPosixSlashes(normalizePath(conf.msfPath))\n",
                "\n",
                "    if conf.tmpPath:\n",
                "        conf.tmpPath = ntToPosixSlashes(normalizePath(conf.tmpPath))\n",
                "\n",
                "    if conf.googleDork or conf.logFile or conf.bulkFile or conf.forms or conf.crawlDepth:\n",
                "        conf.multipleTargets = True\n",
                "\n",
                "    if conf.optimize:\n",
                "        setOptimize()\n",
                "\n",
                "    if conf.data:\n",
                "        conf.data = urldecode(conf.data)\n",
                "\n",
                "    if conf.os:\n",
                "        conf.os = conf.os.capitalize()\n",
                "\n",
                "    if conf.dbms:\n",
                "        conf.dbms = conf.dbms.capitalize()\n",
                "\n",
                "    if conf.timeSec not in kb.explicitSettings:\n",
                "        if conf.tor:\n",
                "            conf.timeSec = 2 * conf.timeSec\n",
                "            kb.adjustTimeDelay = False\n",
                "\n",
                "            warnMsg = \"increasing default value for \"\n",
                "            warnMsg += \"--time-sec to %d because \" % conf.timeSec\n",
                "            warnMsg += \"--tor switch was provided\"\n",
                "            logger.warn(warnMsg)\n",
                "        else:\n",
                "            kb.adjustTimeDelay = True\n",
                "    else:\n",
                "        kb.adjustTimeDelay = False\n",
                "\n",
                "def __setConfAttributes():\n",
                "    \"\"\"\n",
                "    This function set some needed attributes into the configuration\n",
                "    singleton.\n",
                "    \"\"\"\n",
                "\n",
                "    debugMsg = \"initializing the configuration\"\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    conf.boundaries = []\n",
                "    conf.cj = None\n",
                "    conf.dbmsConnector = None\n",
                "    conf.dbmsHandler = None\n",
                "    conf.dumpPath = None\n",
                "    conf.httpHeaders = []\n",
                "    conf.hostname = None\n",
                "    conf.multipleTargets = False\n",
                "    conf.outputPath = None\n",
                "    conf.paramDict = {}\n",
                "    conf.parameters = {}\n",
                "    conf.path = None\n",
                "    conf.port = None\n",
                "    conf.resultsFilename = None\n",
                "    conf.resultsFP = None\n",
                "    conf.scheme = None\n",
                "    conf.sessionFP = None\n",
                "    conf.start = True\n",
                "    conf.tests = []\n",
                "    conf.trafficFP = None\n",
                "    conf.wFileType = None\n",
                "\n",
                "def __setKnowledgeBaseAttributes(flushAll=True):\n",
                "    \"\"\"\n",
                "    This function set some needed attributes into the knowledge base\n",
                "    singleton.\n",
                "    \"\"\"\n",
                "\n",
                "    debugMsg = \"initializing the knowledge base\"\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    kb.absFilePaths = set()\n",
                "    kb.adjustTimeDelay = False\n",
                "    kb.alwaysRedirect = None\n",
                "    kb.alwaysRefresh = None\n",
                "    kb.arch = None\n",
                "    kb.authHeader = None\n",
                "    kb.bannerFp = AttribDict()\n",
                "\n",
                "    kb.brute = AttribDict({'tables':[], 'columns':[]})\n",
                "    kb.bruteMode = False\n",
                "\n",
                "    kb.cache = AttribDict()\n",
                "    kb.cache.content = {}\n",
                "    kb.cache.regex = {}\n",
                "    kb.cache.stdev = {}\n",
                "\n",
                "    kb.commonOutputs = None\n",
                "    kb.data = AttribDict()\n",
                "    kb.dataOutputFlag = False\n",
                "\n",
                "    # Active back-end DBMS fingerprint\n",
                "    kb.dbms = None\n",
                "    kb.dbmsVersion = [ UNKNOWN_DBMS_VERSION ]\n",
                "\n",
                "    kb.delayCandidates = TIME_DELAY_CANDIDATES * [0]\n",
                "    kb.dep = None\n",
                "    kb.docRoot = None\n",
                "    kb.dynamicMarkings = []\n",
                "    kb.dynamicParameters = False\n",
                "    kb.endDetection = False\n",
                "    kb.httpErrorCodes = {}\n",
                "    kb.explicitSettings = set()\n",
                "    kb.errorIsNone = True\n",
                "    kb.formNames = []\n",
                "    kb.headersCount = 0\n",
                "    kb.headersFp = {}\n",
                "    kb.heuristicTest = None\n",
                "    kb.hintValue = None\n",
                "    kb.htmlFp = []\n",
                "    kb.ignoreTimeout = False\n",
                "    kb.injection = InjectionDict()\n",
                "    kb.injections = []\n",
                "\n",
                "    kb.locks = AttribDict()\n",
                "    kb.locks.cacheLock = threading.Lock()\n",
                "    kb.locks.logLock = threading.Lock()\n",
                "    kb.locks.ioLock = threading.Lock()\n",
                "    kb.locks.countLock = threading.Lock()\n",
                "\n",
                "    kb.matchRatio = None\n",
                "    kb.multiThreadMode = False\n",
                "    kb.nullConnection = None\n",
                "    kb.pageTemplate = None\n",
                "    kb.pageTemplates = dict()\n",
                "    kb.originalPage = None\n",
                "\n",
                "    # Back-end DBMS underlying operating system fingerprint via banner (-b)\n",
                "    # parsing\n",
                "    kb.os = None\n",
                "    kb.osVersion = None\n",
                "    kb.osSP = None\n",
                "\n",
                "    kb.pageEncoding = DEFAULT_PAGE_ENCODING\n",
                "    kb.pageStable = None\n",
                "    kb.partRun = None\n",
                "    kb.proxyAuthHeader = None\n",
                "    kb.queryCounter = 0\n",
                "    kb.redirectSetCookie = None\n",
                "    kb.reflectiveMechanism = True\n",
                "    kb.reflectiveCounters = {REFLECTIVE_COUNTER.MISS:0, REFLECTIVE_COUNTER.HIT:0}\n",
                "    kb.responseTimes = []\n",
                "    kb.resumedQueries = {}\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    kb.safeCharEncode = False\n"
                ],
                "parent_version_range": {
                    "start": 1444,
                    "end": 1444
                },
                "child_version_range": {
                    "start": 1444,
                    "end": 1445
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "__setKnowledgeBaseAttributes",
                        "signature": "def __setKnowledgeBaseAttributes(flushAll=True):",
                        "at_line": 1363
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: lib/core/option.py\nCode:\n             def __setKnowledgeBaseAttributes(flushAll=True):\n                 ...\n1441 1441        kb.reflectiveCounters = {REFLECTIVE_COUNTER.MISS:0, REFLECTIVE_COUNTER.HIT:0}\n1442 1442        kb.responseTimes = []\n1443 1443        kb.resumedQueries = {}\n     1444  +     kb.safeCharEncode = False\n1444 1445        kb.singleLogFlags = set()\n1445 1446        kb.skipOthersDbms = None\n1446 1447        kb.suppressSession = False\n           ...\n",
                "file_path": "lib/core/option.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "kb",
                    "safeCharEncode"
                ],
                "prefix": [
                    "    kb.reflectiveCounters = {REFLECTIVE_COUNTER.MISS:0, REFLECTIVE_COUNTER.HIT:0}\n",
                    "    kb.responseTimes = []\n",
                    "    kb.resumedQueries = {}\n"
                ],
                "suffix": [
                    "    kb.singleLogFlags = set()\n",
                    "    kb.skipOthersDbms = None\n",
                    "    kb.suppressSession = False\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    kb.singleLogFlags = set()\n",
                "    kb.skipOthersDbms = None\n",
                "    kb.suppressSession = False\n",
                "    kb.suppressResumeInfo = False\n",
                "    kb.technique = None\n",
                "    kb.testMode = False\n",
                "    kb.testQueryCount = 0\n",
                "    kb.threadContinue = True\n",
                "    kb.threadException = False\n",
                "    kb.uChar = \"NULL\"\n",
                "    kb.xpCmdshellAvailable = False\n",
                "\n",
                "    kb.misc = AttribDict()\n",
                "    kb.misc.delimiter = randomStr(length=6, lowercase=True)\n",
                "    kb.misc.start = \":%s:\" % randomStr(length=3, lowercase=True)\n",
                "    kb.misc.stop = \":%s:\" % randomStr(length=3, lowercase=True)\n",
                "    kb.misc.at = \":%s:\" % randomStr(length=1, lowercase=True)\n",
                "    kb.misc.space = \":%s:\" % randomStr(length=1, lowercase=True)\n",
                "    kb.misc.dollar = \":%s:\" % randomStr(length=1, lowercase=True)\n",
                "    kb.misc.forcedDbms = None\n",
                "    kb.misc.stickyFlag = False\n",
                "\n",
                "    if flushAll:\n",
                "        kb.keywords = set(getFileItems(paths.SQL_KEYWORDS))\n",
                "        kb.tamperFunctions = []\n",
                "        kb.targetUrls = oset()\n",
                "        kb.testedParams = set()\n",
                "        kb.userAgents = None\n",
                "        kb.vainRun = True\n",
                "        kb.wordlist = None\n",
                "\n",
                "def __useWizardInterface():\n",
                "    \"\"\"\n",
                "    Presents simple wizard interface for beginner users\n",
                "    \"\"\"\n",
                "\n",
                "    if not conf.wizard:\n",
                "        return\n",
                "\n",
                "    logger.info(\"starting wizard interface\")\n",
                "\n",
                "    while True:\n",
                "        while not conf.url:\n",
                "            message = \"Please enter full target URL (-u): \"\n",
                "            conf.url = readInput(message, default=None)\n",
                "\n",
                "        message = \"POST data (--data) [Enter for None]: \"\n",
                "        conf.data = readInput(message, default=None)\n",
                "\n",
                "        if filter(lambda x: '=' in str(x), [conf.url, conf.data]) or '*' in conf.url:\n",
                "            break\n",
                "        else:\n",
                "            conf.url = conf.data = None\n",
                "            warnMsg = \"no testable GET and/or POST parameter(s) found \"\n",
                "            warnMsg += \"(e.g. GET parameter 'id' in 'www.site.com/index.php?id=1')\"\n",
                "            logger.critical(warnMsg)\n",
                "    choice = None\n",
                "\n",
                "    while choice is None or choice not in (\"\", \"1\", \"2\", \"3\"):\n",
                "        message = \"Injection difficulty (--level/--risk). Please choose:\\n\"\n",
                "        message += \"[1] Normal (default)\\n[2] Medium\\n[3] Hard\"\n",
                "        choice = readInput(message, default='1')\n",
                "\n",
                "        if choice == '2':\n",
                "            conf.risk = 2\n",
                "            conf.level = 3\n",
                "        elif choice == '3':\n",
                "            conf.risk = 3\n",
                "            conf.level = 5\n",
                "        else:\n",
                "            conf.risk = 1\n",
                "            conf.level = 1\n",
                "\n",
                "    choice = None\n",
                "\n",
                "    while choice is None or choice not in (\"\", \"1\", \"2\", \"3\"):\n",
                "        message = \"Enumeration (--banner/--current-user/etc). Please choose:\\n\"\n",
                "        message += \"[1] Basic (default)\\n[2] Smart\\n[3] All\"\n",
                "        choice = readInput(message, default='1')\n",
                "\n",
                "        if choice == '2':\n",
                "            map(lambda x: conf.__setitem__(x, True), ['getBanner', 'getCurrentUser', 'getCurrentDb', 'isDba', 'getUsers', 'getDbs', 'getTables', 'getSchema', 'excludeSysDbs'])\n",
                "        elif choice == '3':\n",
                "            map(lambda x: conf.__setitem__(x, True), ['getBanner', 'getCurrentUser', 'getCurrentDb', 'isDba', 'getUsers', 'getPasswordHashes', 'getPrivileges', 'getRoles', 'dumpAll'])\n",
                "        else:\n",
                "            map(lambda x: conf.__setitem__(x, True), ['getBanner', 'getCurrentUser', 'getCurrentDb', 'isDba'])\n",
                "\n",
                "    conf.batch = True\n",
                "    conf.threads = 4\n",
                "\n",
                "    logger.debug(\"muting sqlmap.. it will do the magic for you\")\n",
                "    conf.verbose = 0\n",
                "\n",
                "    dataToStdout(\"\\nsqlmap is running, please wait..\\n\\n\")\n",
                "\n",
                "def __saveCmdline():\n",
                "    \"\"\"\n",
                "    Saves the command line options on a sqlmap configuration INI file\n",
                "    Format.\n",
                "    \"\"\"\n",
                "\n",
                "    if not conf.saveCmdline:\n",
                "        return\n",
                "\n",
                "    debugMsg = \"saving command line options on a sqlmap configuration INI file\"\n",
                "    logger.debug(debugMsg)\n",
                "\n",
                "    config = UnicodeRawConfigParser()\n",
                "    userOpts = {}\n",
                "\n",
                "    for family in optDict.keys():\n",
                "        userOpts[family] = []\n",
                "\n",
                "    for option, value in conf.items():\n",
                "        for family, optionData in optDict.items():\n",
                "            if option in optionData:\n",
                "                userOpts[family].append((option, value, optionData[option]))\n",
                "\n",
                "    for family, optionData in userOpts.items():\n",
                "        config.add_section(family)\n",
                "\n",
                "        optionData.sort()\n",
                "\n",
                "        for option, value, datatype in optionData:\n",
                "            if isinstance(datatype, (list, tuple, set)):\n",
                "                datatype = datatype[0]\n",
                "\n",
                "            if value is None:\n",
                "                if datatype == \"boolean\":\n",
                "                    value = \"False\"\n",
                "                elif datatype in ( \"integer\", \"float\" ):\n",
                "                    if option in ( \"threads\", \"verbose\" ):\n",
                "                        value = \"1\"\n",
                "                    elif option == \"timeout\":\n",
                "                        value = \"10\"\n",
                "                    else:\n",
                "                        value = \"0\"\n",
                "                elif datatype == \"string\":\n",
                "                    value = \"\"\n",
                "\n",
                "            if isinstance(value, basestring):\n",
                "                value = value.replace(\"\\n\", \"\\n \")\n",
                "\n",
                "            config.set(family, option, value)\n",
                "\n",
                "    confFP = openFile(paths.SQLMAP_CONFIG, \"wb\")\n",
                "    config.write(confFP)\n",
                "\n",
                "    infoMsg = \"saved command line options on '%s' configuration file\" % paths.SQLMAP_CONFIG\n",
                "    logger.info(infoMsg)\n",
                "\n",
                "def __setVerbosity():\n",
                "    \"\"\"\n",
                "    This function set the verbosity of sqlmap output messages.\n",
                "    \"\"\"\n",
                "\n",
                "    if conf.verbose is None:\n",
                "        conf.verbose = 1\n",
                "\n",
                "    conf.verbose = int(conf.verbose)\n",
                "\n",
                "    if conf.verbose == 0:\n",
                "        logger.setLevel(logging.ERROR)\n",
                "    elif conf.verbose == 1:\n",
                "        logger.setLevel(logging.INFO)\n",
                "    elif conf.verbose > 2 and conf.eta:\n",
                "        conf.verbose = 2\n",
                "        logger.setLevel(logging.DEBUG)\n",
                "    elif conf.verbose == 2:\n",
                "        logger.setLevel(logging.DEBUG)\n",
                "    elif conf.verbose == 3:\n",
                "        logger.setLevel(9)\n",
                "    elif conf.verbose == 4:\n",
                "        logger.setLevel(8)\n",
                "    elif conf.verbose >= 5:\n",
                "        logger.setLevel(7)\n",
                "\n",
                "def __mergeOptions(inputOptions, overrideOptions):\n",
                "    \"\"\"\n",
                "    Merge command line options with configuration file and default options.\n",
                "\n",
                "    @param inputOptions: optparse object with command line options.\n",
                "    @type inputOptions: C{instance}\n",
                "    \"\"\"\n",
                "\n",
                "    if inputOptions.configFile:\n",
                "        configFileParser(inputOptions.configFile)\n",
                "\n",
                "    if hasattr(inputOptions, \"items\"):\n",
                "        inputOptionsItems = inputOptions.items()\n",
                "    else:\n",
                "        inputOptionsItems = inputOptions.__dict__.items()\n",
                "\n",
                "    for key, value in inputOptionsItems:\n",
                "        if key not in conf or value not in (None, False) or overrideOptions:\n",
                "            conf[key] = value\n",
                "\n",
                "    for key, value in conf.items():\n",
                "        if value:\n",
                "            kb.explicitSettings.add(key)\n",
                "\n",
                "    for key, value in defaults.items():\n",
                "        if not conf[key]:\n",
                "            conf[key] = value\n",
                "\n",
                "def __setTrafficOutputFP():\n",
                "    if conf.trafficFile:\n",
                "        infoMsg = \"setting file for logging HTTP traffic\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        conf.trafficFP = openFile(conf.trafficFile, \"w+\")\n",
                "\n",
                "def __setTorProxySettings():\n",
                "    if not conf.tor:\n",
                "        return\n",
                "\n",
                "    infoMsg = \"setting Tor proxy settings\"\n",
                "    logger.info(infoMsg)\n",
                "\n",
                "    found = None\n",
                "    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n",
                "\n",
                "    for port in DEFAULT_TOR_PORTS:\n",
                "        try:\n",
                "            s.connect((LOCALHOST, port))\n",
                "            found = port\n",
                "            break\n",
                "        except socket.error:\n",
                "            pass\n",
                "\n",
                "    s.close()\n",
                "\n",
                "    if found:\n",
                "        conf.proxy = \"http://%s:%d\" % (LOCALHOST, found)\n",
                "    else:\n",
                "        errMsg = \"can't establish connection with the Tor proxy. \"\n",
                "        errMsg += \"Please make sure that you have Vidalia, Privoxy or \"\n",
                "        errMsg += \"Polipo bundle installed for you to be able to \"\n",
                "        errMsg += \"successfully use --tor switch \"\n",
                "\n",
                "        if IS_WIN:\n",
                "            errMsg += \"(e.g. https://www.torproject.org/projects/vidalia.html.en)\"\n",
                "        else:\n",
                "            errMsg += \"(e.g. http://www.coresec.org/2011/04/24/sqlmap-with-tor/)\"\n",
                "\n",
                "        raise sqlmapConnectionException, errMsg\n",
                "\n",
                "def __basicOptionValidation():\n",
                "    if conf.limitStart is not None and not (isinstance(conf.limitStart, int) and conf.limitStart > 0):\n",
                "        errMsg = \"value for --start (limitStart) option must be an integer value greater than zero (>0)\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.limitStop is not None and not (isinstance(conf.limitStop, int) and conf.limitStop > 0):\n",
                "        errMsg = \"value for --stop (limitStop) option must be an integer value greater than zero (>0)\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.limitStart is not None and isinstance(conf.limitStart, int) and conf.limitStart > 0 and \\\n",
                "       conf.limitStop is not None and isinstance(conf.limitStop, int) and conf.limitStop <= conf.limitStart:\n",
                "        errMsg = \"value for --start (limitStart) option must be smaller than value for --stop (limitStop) option\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.firstChar is not None and isinstance(conf.firstChar, int) and conf.firstChar > 0 and \\\n",
                "       conf.lastChar is not None and isinstance(conf.lastChar, int) and conf.lastChar < conf.firstChar:\n",
                "        errMsg = \"value for --first (firstChar) option must be smaller than or equal to value for --last (lastChar) option\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.cpuThrottle is not None and isinstance(conf.cpuThrottle, int) and (conf.cpuThrottle > 100 or conf.cpuThrottle < 0):\n",
                "        errMsg = \"value for --cpu-throttle (cpuThrottle) option must be in range [0,100]\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.textOnly and conf.nullConnection:\n",
                "        errMsg = \"switch --text-only is incompatible with switch --null-connection\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.titles and conf.nullConnection:\n",
                "        errMsg = \"switch --titles is incompatible with switch --null-connection\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.data and conf.nullConnection:\n",
                "        errMsg = \"switch --data is incompatible with switch --null-connection\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.string and conf.nullConnection:\n",
                "        errMsg = \"switch --string is incompatible with switch --null-connection\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.regexp and conf.nullConnection:\n",
                "        errMsg = \"switch --regexp is incompatible with switch --null-connection\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.predictOutput and (conf.threads > 1 or conf.optimize):\n",
                "        errMsg = \"switch --predict-output is incompatible with switch --threads and -o\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.threads > MAX_NUMBER_OF_THREADS:\n",
                "        errMsg = \"maximum number of used threads is %d avoiding possible connection issues\" % MAX_NUMBER_OF_THREADS\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.forms and not conf.url:\n",
                "        errMsg = \"switch --forms requires usage of -u (--url) switch\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.tor and conf.ignoreProxy:\n",
                "        errMsg = \"switch --tor is incompatible with switch --ignore-proxy\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.tor and conf.proxy:\n",
                "        errMsg = \"switch --tor is incompatible with switch --proxy\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.mobile and conf.agent:\n",
                "        errMsg = \"switch --mobile is incompatible with switch --user-agent\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.proxy and conf.ignoreProxy:\n",
                "        errMsg = \"switch --proxy is incompatible with switch --ignore-proxy\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.forms and any([conf.logFile, conf.bulkFile, conf.direct, conf.requestFile, conf.googleDork]):\n",
                "        errMsg = \"switch --forms is compatible only with -u (--url) target switch\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.forms and conf.crawlDepth:\n",
                "        errMsg = \"switch --forms is currently not compatible with --crawl switch\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.timeSec < 1:\n",
                "        errMsg = \"value for --time-sec option must be an integer greater than 0\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if isinstance(conf.uCols, basestring):\n",
                "        if not conf.uCols.isdigit() and (\"-\" not in conf.uCols or len(conf.uCols.split(\"-\")) != 2):\n",
                "            errMsg = \"value for --union-cols must be a range with hyphon \"\n",
                "            errMsg += \"(e.g. 1-10) or integer value (e.g. 5)\"\n",
                "            raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    if conf.charset:\n",
                "        try:\n",
                "            codecs.lookup(conf.charset)\n",
                "        except LookupError:\n",
                "            errMsg = \"unknown charset '%s'. Please visit \" % conf.charset\n",
                "            errMsg += \"'%s' to get the full list of \" % CODECS_LIST_PAGE\n",
                "            errMsg += \"supported charsets\"\n",
                "            raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "def __resolveCrossReferences():\n",
                "    lib.core.threads.readInput = readInput\n",
                "    lib.core.common.getPageTemplate = getPageTemplate\n",
                "\n",
                "def init(inputOptions=AttribDict(), overrideOptions=False):\n",
                "    \"\"\"\n",
                "    Set attributes into both configuration and knowledge base singletons\n",
                "    based upon command line and configuration file options.\n",
                "    \"\"\"\n",
                "\n",
                "    __setConfAttributes()\n",
                "    __setKnowledgeBaseAttributes()\n",
                "    __mergeOptions(inputOptions, overrideOptions)\n",
                "    __useWizardInterface()\n",
                "    __setVerbosity()\n",
                "    __saveCmdline()\n",
                "    __setRequestFromFile()\n",
                "    __cleanupOptions()\n",
                "    __checkDependencies()\n",
                "    __basicOptionValidation()\n",
                "    __setTorProxySettings()\n",
                "    __setMultipleTargets()\n",
                "    __setTamperingFunctions()\n",
                "    __setTrafficOutputFP()\n",
                "    __resolveCrossReferences()\n",
                "\n",
                "    parseTargetUrl()\n",
                "    parseTargetDirect()\n",
                "\n",
                "    if any([conf.url, conf.logFile, conf.bulkFile, conf.requestFile, conf.googleDork, conf.liveTest]):\n",
                "        __setHTTPTimeout()\n",
                "        __setHTTPExtraHeaders()\n",
                "        __setHTTPCookies()\n",
                "        __setHTTPReferer()\n",
                "        __setHTTPUserAgent()\n",
                "        __setHTTPMethod()\n",
                "        __setHTTPAuthentication()\n",
                "        __setHTTPProxy()\n",
                "        __setDNSCache()\n",
                "        __setSafeUrl()\n",
                "        __setGoogleDorking()\n",
                "        __setBulkMultipleTargets()\n",
                "        __urllib2Opener()\n",
                "        __setCrawler()\n",
                "        __findPageForms()\n",
                "        __setDBMS()\n",
                "        __setTechnique()\n",
                "\n",
                "    __setThreads()\n",
                "    __setOS()\n",
                "    __setWriteFile()\n",
                "    __setMetasploit()\n",
                "\n",
                "    loadPayloads()\n",
                "    __setPrefixSuffix()\n",
                "    update()\n",
                "    __loadQueries()"
            ]
        ],
        "lib/request/inject.py": [
            [
                "#!/usr/bin/env python\n",
                "\n",
                "\"\"\"\n",
                "$Id$\n",
                "\n",
                "Copyright (c) 2006-2011 sqlmap developers (http://www.sqlmap.org/)\n",
                "See the file 'doc/COPYING' for copying permission\n",
                "\"\"\"\n",
                "\n",
                "import re\n",
                "import time\n",
                "\n",
                "from lib.core.agent import agent\n",
                "from lib.core.common import Backend\n",
                "from lib.core.common import BigArray\n",
                "from lib.core.common import calculateDeltaSeconds\n",
                "from lib.core.common import cleanQuery\n",
                "from lib.core.common import dataToSessionFile\n",
                "from lib.core.common import expandAsteriskForColumns\n",
                "from lib.core.common import getPublicTypeMembers\n",
                "from lib.core.common import initTechnique\n",
                "from lib.core.common import isNumPosStrValue\n",
                "from lib.core.common import isTechniqueAvailable\n",
                "from lib.core.common import parseUnionPage\n",
                "from lib.core.common import popValue\n",
                "from lib.core.common import pushValue\n",
                "from lib.core.common import randomInt\n",
                "from lib.core.common import readInput\n",
                "from lib.core.common import replaceNewlineTabs\n",
                "from lib.core.common import safeStringFormat\n"
            ],
            {
                "type": "delete",
                "before": [
                    "from lib.core.convert import safecharencode\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 30,
                    "end": 31
                },
                "child_version_range": {
                    "start": 30,
                    "end": 30
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 1,
                "hunk_diff": "File: lib/request/inject.py\nCode:\n  ...\n27 27    from lib.core.common import readInput\n28 28    from lib.core.common import replaceNewlineTabs\n29 29    from lib.core.common import safeStringFormat\n30     - from lib.core.convert import safecharencode\n31 30    from lib.core.data import conf\n32 31    from lib.core.data import kb\n33 32    from lib.core.data import logger\n       ...\n",
                "file_path": "lib/request/inject.py",
                "identifiers_before": [
                    "convert",
                    "core",
                    "lib",
                    "safecharencode"
                ],
                "identifiers_after": [],
                "prefix": [
                    "from lib.core.common import readInput\n",
                    "from lib.core.common import replaceNewlineTabs\n",
                    "from lib.core.common import safeStringFormat\n"
                ],
                "suffix": [
                    "from lib.core.data import conf\n",
                    "from lib.core.data import kb\n",
                    "from lib.core.data import logger\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "safecharencode",
                            "position": {
                                "start": {
                                    "line": 30,
                                    "column": 29
                                },
                                "end": {
                                    "line": 30,
                                    "column": 43
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/lib/request/inject.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "from lib.core.data import conf\n",
                "from lib.core.data import kb\n",
                "from lib.core.data import logger\n",
                "from lib.core.data import queries\n",
                "from lib.core.enums import DBMS\n",
                "from lib.core.enums import EXPECTED\n",
                "from lib.core.enums import PAYLOAD\n",
                "from lib.core.exception import sqlmapNotVulnerableException\n",
                "from lib.core.exception import sqlmapUserQuitException\n",
                "from lib.core.settings import FROM_TABLE\n",
                "from lib.core.settings import MIN_TIME_RESPONSES\n",
                "from lib.core.settings import MAX_TECHNIQUES_PER_VALUE\n",
                "from lib.core.settings import SQL_SCALAR_REGEX\n",
                "from lib.core.threads import getCurrentThreadData\n",
                "from lib.core.unescaper import unescaper\n",
                "from lib.request.connect import Connect as Request\n",
                "from lib.request.direct import direct\n",
                "from lib.techniques.union.use import unionUse\n",
                "from lib.techniques.blind.inference import bisection\n",
                "from lib.techniques.error.use import errorUse\n",
                "from lib.utils.resume import queryOutputLength\n",
                "from lib.utils.resume import resume\n",
                "\n",
                "def __goInference(payload, expression, charsetType=None, firstChar=None, lastChar=None, dump=False):\n",
                "    start = time.time()\n",
                "\n",
                "    timeBasedCompare = (kb.technique in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED))\n",
                "\n",
                "    if (conf.eta or conf.threads > 1) and Backend.getIdentifiedDbms() and not timeBasedCompare:\n",
                "        _, length, _ = queryOutputLength(expression, payload)\n",
                "    else:\n",
                "        length = None\n",
                "\n",
                "    dataToSessionFile(\"[%s][%s][%s][%s][\" % (conf.url, kb.injection.place, conf.parameters[kb.injection.place], expression))\n",
                "\n",
                "    count, value = bisection(payload, expression, length, charsetType, firstChar, lastChar, dump)\n",
                "\n",
                "    if not kb.bruteMode:\n",
                "        debugMsg = \"performed %d queries in %d seconds\" % (count, calculateDeltaSeconds(start))\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "    return value\n",
                "\n",
                "def __goInferenceFields(expression, expressionFields, expressionFieldsList, payload, expected=None, num=None, resumeValue=True, charsetType=None, firstChar=None, lastChar=None, dump=False):\n",
                "    outputs = []\n",
                "    origExpr = None\n",
                "\n",
                "    for field in expressionFieldsList:\n",
                "        output = None\n",
                "\n",
                "        if field.startswith(\"ROWNUM \"):\n",
                "            continue\n",
                "\n",
                "        if isinstance(num, int):\n",
                "            origExpr = expression\n",
                "            expression = agent.limitQuery(num, expression, field)\n",
                "\n",
                "        if \"ROWNUM\" in expressionFieldsList:\n",
                "            expressionReplaced = expression\n",
                "        else:\n",
                "            expressionReplaced = expression.replace(expressionFields, field, 1)\n",
                "\n",
                "        if resumeValue:\n",
                "            output = resume(expressionReplaced, payload)\n",
                "\n",
                "        if not output or (expected == EXPECTED.INT and not output.isdigit()):\n",
                "            if output:\n",
                "                warnMsg = \"expected value type %s, resumed '%s', \" % (expected, output)\n",
                "                warnMsg += \"sqlmap is going to retrieve the value again\"\n",
                "                logger.warn(warnMsg)\n",
                "\n",
                "            output = __goInference(payload, expressionReplaced, charsetType, firstChar, lastChar, dump)\n",
                "\n",
                "        if isinstance(num, int):\n",
                "            expression = origExpr\n",
                "\n",
                "        outputs.append(output)\n",
                "\n",
                "    return outputs\n",
                "\n",
                "def __goInferenceProxy(expression, fromUser=False, expected=None, batch=False, resumeValue=True, unpack=True, charsetType=None, firstChar=None, lastChar=None, dump=False):\n",
                "    \"\"\"\n",
                "    Retrieve the output of a SQL query characted by character taking\n",
                "    advantage of an blind SQL injection vulnerability on the affected\n",
                "    parameter through a bisection algorithm.\n",
                "    \"\"\"\n",
                "\n",
                "    initTechnique(kb.technique)\n",
                "\n",
                "    query = agent.prefixQuery(kb.injection.data[kb.technique].vector)\n",
                "    query = agent.suffixQuery(query)\n",
                "    payload = agent.payload(newValue=query)\n",
                "    count = None\n",
                "    startLimit = 0\n",
                "    stopLimit = None\n",
                "    outputs = BigArray()\n",
                "    test = None\n",
                "    untilLimitChar = None\n",
                "    untilOrderChar = None\n",
                "\n",
                "    if resumeValue:\n",
                "        output = resume(expression, payload)\n",
                "    else:\n",
                "        output = None\n",
                "\n",
                "    if output and (expected is None or (expected == EXPECTED.INT and output.isdigit())):\n",
                "        return output\n",
                "\n",
                "    if not unpack:\n",
                "        return __goInference(payload, expression, charsetType, firstChar, lastChar, dump)\n",
                "\n",
                "    _, _, _, _, _, expressionFieldsList, expressionFields, _ = agent.getFields(expression)\n",
                "\n",
                "    rdbRegExp = re.search(\"RDB\\$GET_CONTEXT\\([^)]+\\)\", expression, re.I)\n",
                "    if rdbRegExp and Backend.isDbms(DBMS.FIREBIRD):\n",
                "        expressionFieldsList = [expressionFields]\n",
                "\n",
                "    if len(expressionFieldsList) > 1:\n",
                "        infoMsg = \"the SQL query provided has more than a field. \"\n",
                "        infoMsg += \"sqlmap will now unpack it into distinct queries \"\n",
                "        infoMsg += \"to be able to retrieve the output even if we \"\n",
                "        infoMsg += \"are going blind\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "    # If we have been here from SQL query/shell we have to check if\n",
                "    # the SQL query might return multiple entries and in such case\n",
                "    # forge the SQL limiting the query output one entry per time\n",
                "    # NOTE: I assume that only queries that get data from a table\n",
                "    # can return multiple entries\n",
                "    if fromUser and \" FROM \" in expression.upper() and ((Backend.getIdentifiedDbms() \\\n",
                "      not in FROM_TABLE) or (Backend.getIdentifiedDbms() in FROM_TABLE and not \\\n",
                "      expression.upper().endswith(FROM_TABLE[Backend.getIdentifiedDbms()]))) \\\n",
                "      and not re.search(SQL_SCALAR_REGEX, expression, re.I):\n",
                "\n",
                "        limitRegExp = re.search(queries[Backend.getIdentifiedDbms()].limitregexp.query, expression, re.I)\n",
                "        topLimit = re.search(\"TOP\\s+([\\d]+)\\s+\", expression, re.I)\n",
                "\n",
                "        if limitRegExp or (Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE) and topLimit):\n",
                "            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n",
                "                limitGroupStart = queries[Backend.getIdentifiedDbms()].limitgroupstart.query\n",
                "                limitGroupStop = queries[Backend.getIdentifiedDbms()].limitgroupstop.query\n",
                "\n",
                "                if limitGroupStart.isdigit():\n",
                "                    startLimit = int(limitRegExp.group(int(limitGroupStart)))\n",
                "\n",
                "                stopLimit = limitRegExp.group(int(limitGroupStop))\n",
                "                limitCond = int(stopLimit) > 1\n",
                "\n",
                "            elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n",
                "                if limitRegExp:\n",
                "                    limitGroupStart = queries[Backend.getIdentifiedDbms()].limitgroupstart.query\n",
                "                    limitGroupStop = queries[Backend.getIdentifiedDbms()].limitgroupstop.query\n",
                "\n",
                "                    if limitGroupStart.isdigit():\n",
                "                        startLimit = int(limitRegExp.group(int(limitGroupStart)))\n",
                "\n",
                "                    stopLimit = limitRegExp.group(int(limitGroupStop))\n",
                "                    limitCond = int(stopLimit) > 1\n",
                "                elif topLimit:\n",
                "                    startLimit = 0\n",
                "                    stopLimit = int(topLimit.group(1))\n",
                "                    limitCond = int(stopLimit) > 1\n",
                "\n",
                "            elif Backend.isDbms(DBMS.ORACLE):\n",
                "                limitCond = False\n",
                "        else:\n",
                "            limitCond = True\n",
                "\n",
                "        # I assume that only queries NOT containing a \"LIMIT #, 1\"\n",
                "        # (or similar depending on the back-end DBMS) can return\n",
                "        # multiple entries\n",
                "        if limitCond:\n",
                "            if limitRegExp:\n",
                "                stopLimit = int(stopLimit)\n",
                "\n",
                "                # From now on we need only the expression until the \" LIMIT \"\n",
                "                # (or similar, depending on the back-end DBMS) word\n",
                "                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n",
                "                    stopLimit += startLimit\n",
                "                    untilLimitChar = expression.index(queries[Backend.getIdentifiedDbms()].limitstring.query)\n",
                "                    expression = expression[:untilLimitChar]\n",
                "\n",
                "                elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n",
                "                    stopLimit += startLimit\n",
                "\n",
                "            if not stopLimit or stopLimit <= 1:\n",
                "                if Backend.getIdentifiedDbms() in FROM_TABLE and expression.upper().endswith(FROM_TABLE[Backend.getIdentifiedDbms()]):\n",
                "                    test = False\n",
                "                else:\n",
                "                    test = True\n",
                "\n",
                "            if test:\n",
                "                # Count the number of SQL query entries output\n",
                "                countFirstField = queries[Backend.getIdentifiedDbms()].count.query % expressionFieldsList[0]\n",
                "                countedExpression = expression.replace(expressionFields, countFirstField, 1)\n",
                "\n",
                "                if re.search(\" ORDER BY \", expression, re.I):\n",
                "                    untilOrderChar = countedExpression.index(\" ORDER BY \")\n",
                "                    countedExpression = countedExpression[:untilOrderChar]\n",
                "\n",
                "                if resumeValue:\n",
                "                    count = resume(countedExpression, payload)\n",
                "\n",
                "                if not stopLimit:\n",
                "                    if not count or not count.isdigit():\n",
                "                        count = __goInference(payload, countedExpression, 2, firstChar, lastChar)\n",
                "\n",
                "                    if isNumPosStrValue(count):\n",
                "                        count = int(count)\n",
                "\n",
                "                        if batch:\n",
                "                            stopLimit = count\n",
                "                        else:\n",
                "                            message = \"the SQL query provided can return \"\n",
                "                            message += \"%d entries. How many \" % count\n",
                "                            message += \"entries do you want to retrieve?\\n\"\n",
                "                            message += \"[a] All (default)\\n[#] Specific number\\n\"\n",
                "                            message += \"[q] Quit\"\n",
                "                            test = readInput(message, default=\"a\")\n",
                "\n",
                "                            if not test or test[0] in (\"a\", \"A\"):\n",
                "                                stopLimit = count\n",
                "\n",
                "                            elif test[0] in (\"q\", \"Q\"):\n",
                "                                raise sqlmapUserQuitException\n",
                "\n",
                "                            elif test.isdigit() and int(test) > 0 and int(test) <= count:\n",
                "                                stopLimit = int(test)\n",
                "\n",
                "                                infoMsg = \"sqlmap is now going to retrieve the \"\n",
                "                                infoMsg += \"first %d query output entries\" % stopLimit\n",
                "                                logger.info(infoMsg)\n",
                "\n",
                "                            elif test[0] in (\"#\", \"s\", \"S\"):\n",
                "                                message = \"how many? \"\n",
                "                                stopLimit = readInput(message, default=\"10\")\n",
                "\n",
                "                                if not stopLimit.isdigit():\n",
                "                                    errMsg = \"invalid choice\"\n",
                "                                    logger.error(errMsg)\n",
                "\n",
                "                                    return None\n",
                "\n",
                "                                else:\n",
                "                                    stopLimit = int(stopLimit)\n",
                "\n",
                "                            else:\n",
                "                                errMsg = \"invalid choice\"\n",
                "                                logger.error(errMsg)\n",
                "\n",
                "                                return None\n",
                "\n",
                "                    elif count and not count.isdigit():\n",
                "                        warnMsg = \"it was not possible to count the number \"\n",
                "                        warnMsg += \"of entries for the SQL query provided. \"\n",
                "                        warnMsg += \"sqlmap will assume that it returns only \"\n",
                "                        warnMsg += \"one entry\"\n",
                "                        logger.warn(warnMsg)\n",
                "\n",
                "                        stopLimit = 1\n",
                "\n",
                "                    elif (not count or int(count) == 0):\n",
                "                        warnMsg = \"the SQL query provided does not \"\n",
                "                        warnMsg += \"return any output\"\n",
                "                        logger.warn(warnMsg)\n",
                "\n",
                "                        return None\n",
                "\n",
                "                elif (not count or int(count) == 0) and (not stopLimit or stopLimit == 0):\n",
                "                    warnMsg = \"the SQL query provided does not \"\n",
                "                    warnMsg += \"return any output\"\n",
                "                    logger.warn(warnMsg)\n",
                "\n",
                "                    return None\n",
                "\n",
                "                try:\n",
                "                    for num in xrange(startLimit, stopLimit):\n",
                "                        output = __goInferenceFields(expression, expressionFields, expressionFieldsList, payload, expected, num, resumeValue=resumeValue, charsetType=charsetType, firstChar=firstChar, lastChar=lastChar, dump=dump)\n",
                "                        outputs.append(output)\n",
                "\n",
                "                except KeyboardInterrupt:\n",
                "                    print\n",
                "                    warnMsg = \"user aborted during dumping phase\"\n",
                "                    logger.warn(warnMsg)\n",
                "\n",
                "                return outputs\n",
                "\n",
                "    elif Backend.getIdentifiedDbms() in FROM_TABLE and expression.upper().startswith(\"SELECT \") and \" FROM \" not in expression.upper():\n",
                "        expression += FROM_TABLE[Backend.getIdentifiedDbms()]\n",
                "\n",
                "    outputs = __goInferenceFields(expression, expressionFields, expressionFieldsList, payload, expected, resumeValue=resumeValue, charsetType=charsetType, firstChar=firstChar, lastChar=lastChar, dump=dump)\n",
                "    returnValue = \", \".join([output for output in outputs])\n",
                "\n",
                "    return returnValue\n",
                "\n",
                "def __goBooleanProxy(expression, resumeValue=True):\n",
                "    \"\"\"\n",
                "    Retrieve the output of a boolean based SQL query\n",
                "    \"\"\"\n",
                "\n",
                "    initTechnique(kb.technique)\n",
                "\n",
                "    vector = kb.injection.data[kb.technique].vector\n",
                "    vector = vector.replace(\"[INFERENCE]\", expression)\n",
                "    query = agent.prefixQuery(vector)\n",
                "    query = agent.suffixQuery(query)\n",
                "    payload = agent.payload(newValue=query)\n",
                "    timeBasedCompare = kb.technique in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED)\n",
                "\n",
                "    if resumeValue:\n",
                "        output = resume(expression, payload)\n",
                "    else:\n",
                "        output = None\n",
                "\n",
                "    if not output:\n",
                "        output = Request.queryPage(payload, timeBasedCompare=timeBasedCompare, raise404=False)\n",
                "\n",
                "    return output\n",
                "\n",
                "def __goError(expression, expected=None, resumeValue=True, dump=False):\n",
                "    \"\"\"\n",
                "    Retrieve the output of a SQL query taking advantage of an error-based\n",
                "    SQL injection vulnerability on the affected parameter.\n",
                "    \"\"\"\n",
                "\n",
                "    output = None\n",
                "\n",
                "    if resumeValue:\n",
                "        output = resume(expression, None)\n",
                "\n",
                "        if output and expected == EXPECTED.INT and not output.isdigit():\n",
                "            output = None\n",
                "\n",
                "    if output is None:\n",
                "        output = errorUse(expression, expected, resumeValue, dump)\n",
                "\n",
                "    return output\n",
                "\n",
                "def __goInband(expression, expected=None, sort=True, resumeValue=True, unpack=True, dump=False):\n",
                "    \"\"\"\n",
                "    Retrieve the output of a SQL query taking advantage of an inband SQL\n",
                "    injection vulnerability on the affected parameter.\n",
                "    \"\"\"\n",
                "\n",
                "    output = None\n",
                "    partial = False\n",
                "    data = None\n",
                "\n",
                "    if resumeValue:\n",
                "        output = resume(expression, None)\n",
                "\n",
                "        if not output or (output and (expected == EXPECTED.INT and not output.isdigit())):\n",
                "            partial = True\n",
                "\n",
                "    if output is None:\n",
                "        output = unionUse(expression, unpack=unpack, dump=dump)\n",
                "\n",
                "    if isinstance(output, list):\n",
                "        data = output\n",
                "    else:\n",
                "        data = parseUnionPage(output, expression, partial, None, sort)\n",
                "\n",
                "    return data\n",
                "\n",
                "def getValue(expression, blind=True, inband=True, error=True, time=True, fromUser=False, expected=None, batch=False, unpack=True, sort=True, resumeValue=True, charsetType=None, firstChar=None, lastChar=None, dump=False, suppressOutput=None, expectingNone=False, safeCharEncode=True):\n",
                "    \"\"\"\n",
                "    Called each time sqlmap inject a SQL query on the SQL injection\n",
                "    affected parameter. It can call a function to retrieve the output\n",
                "    through inband SQL injection (if selected) and/or blind SQL injection\n",
                "    (if selected).\n",
                "    \"\"\"\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    kb.safeCharEncode = safeCharEncode\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 403,
                    "end": 403
                },
                "child_version_range": {
                    "start": 402,
                    "end": 404
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "getValue",
                        "signature": "def getValue(expression, blind=True, inband=True, error=True, time=True, fromUser=False, expected=None, batch=False, unpack=True, sort=True, resumeValue=True, charsetType=None, firstChar=None, lastChar=None, dump=False, suppressOutput=None, expectingNone=False, safeCharEncode=True):",
                        "at_line": 395
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: lib/request/inject.py\nCode:\n           def getValue(expression, blind=True, inband=True, error=True, time=True, fromUser=False, expected=None, batch=False, unpack=True, sort=True, resumeValue=True, charsetType=None, firstChar=None, lastChar=None, dump=False, suppressOutput=None, expectingNone=False, safeCharEncode=True):\n               ...\n400 399        (if selected).\n401 400        \"\"\"\n402 401    \n    402  +     kb.safeCharEncode = safeCharEncode\n    403  + \n403 404        if suppressOutput is not None:\n404 405            pushValue(getCurrentThreadData().disableStdOut)\n405 406            getCurrentThreadData().disableStdOut = suppressOutput\n         ...\n",
                "file_path": "lib/request/inject.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "kb",
                    "safeCharEncode"
                ],
                "prefix": [
                    "    (if selected).\n",
                    "    \"\"\"\n",
                    "\n"
                ],
                "suffix": [
                    "    if suppressOutput is not None:\n",
                    "        pushValue(getCurrentThreadData().disableStdOut)\n",
                    "        getCurrentThreadData().disableStdOut = suppressOutput\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    if suppressOutput is not None:\n",
                "        pushValue(getCurrentThreadData().disableStdOut)\n",
                "        getCurrentThreadData().disableStdOut = suppressOutput\n",
                "\n",
                "    try:\n",
                "        if conf.direct:\n",
                "            value = direct(expression)\n",
                "\n",
                "        elif any(map(isTechniqueAvailable, getPublicTypeMembers(PAYLOAD.TECHNIQUE, onlyValues=True))):\n",
                "            query = cleanQuery(expression)\n",
                "            query = expandAsteriskForColumns(query)\n",
                "            value = None\n",
                "            found = False\n",
                "\n",
                "            if query and not 'COUNT(*)' in query:\n",
                "                query = query.replace(\"DISTINCT \", \"\")\n",
                "\n",
                "            count = 0\n",
                "\n",
                "            if expected == EXPECTED.BOOL:\n",
                "                forgeCaseExpression = booleanExpression = expression\n",
                "\n",
                "                if expression.upper().startswith(\"SELECT \"):\n",
                "                    booleanExpression = expression[len(\"SELECT \"):]\n",
                "                else:\n",
                "                    forgeCaseExpression = agent.forgeCaseStatement(expression)\n",
                "\n",
                "            if inband and isTechniqueAvailable(PAYLOAD.TECHNIQUE.UNION):\n",
                "                kb.technique = PAYLOAD.TECHNIQUE.UNION\n",
                "\n",
                "                if expected == EXPECTED.BOOL:\n",
                "                    value = __goInband(forgeCaseExpression, expected, sort, resumeValue, unpack, dump)\n",
                "                else:\n",
                "                    value = __goInband(query, expected, sort, resumeValue, unpack, dump)\n",
                "\n",
                "                count += 1\n",
                "                found = (value is not None) or (value is None and expectingNone) or count >= MAX_TECHNIQUES_PER_VALUE\n",
                "\n",
                "            if error and isTechniqueAvailable(PAYLOAD.TECHNIQUE.ERROR) and not found:\n",
                "                kb.technique = PAYLOAD.TECHNIQUE.ERROR\n",
                "\n",
                "                if expected == EXPECTED.BOOL:\n",
                "                    value = __goError(forgeCaseExpression, expected, resumeValue, dump)\n",
                "                else:\n",
                "                    value = __goError(query, expected, resumeValue, dump)\n",
                "\n",
                "                count += 1\n",
                "                found = (value is not None) or (value is None and expectingNone) or count >= MAX_TECHNIQUES_PER_VALUE\n",
                "\n",
                "            if blind and isTechniqueAvailable(PAYLOAD.TECHNIQUE.BOOLEAN) and not found:\n",
                "                kb.technique = PAYLOAD.TECHNIQUE.BOOLEAN\n",
                "\n",
                "                if expected == EXPECTED.BOOL:\n",
                "                    value = __goBooleanProxy(booleanExpression, resumeValue)\n",
                "                else:\n",
                "                    value = __goInferenceProxy(query, fromUser, expected, batch, resumeValue, unpack, charsetType, firstChar, lastChar, dump)\n",
                "\n",
                "                count += 1\n",
                "                found = (value is not None) or (value is None and expectingNone) or count >= MAX_TECHNIQUES_PER_VALUE\n",
                "\n",
                "            if time and (isTechniqueAvailable(PAYLOAD.TECHNIQUE.TIME) or isTechniqueAvailable(PAYLOAD.TECHNIQUE.STACKED)) and not found:\n",
                "                if isTechniqueAvailable(PAYLOAD.TECHNIQUE.TIME):\n",
                "                    kb.technique = PAYLOAD.TECHNIQUE.TIME\n",
                "                else:\n",
                "                    kb.technique = PAYLOAD.TECHNIQUE.STACKED\n",
                "\n",
                "                if expected == EXPECTED.BOOL:\n",
                "                    value = __goBooleanProxy(booleanExpression, resumeValue)\n",
                "                else:\n",
                "                    value = __goInferenceProxy(query, fromUser, expected, batch, resumeValue, unpack, charsetType, firstChar, lastChar, dump)\n",
                "\n",
                "            if value and isinstance(value, basestring):\n",
                "                value = value.strip()\n",
                "        else:\n",
                "            errMsg = \"none of the injection types identified can be \"\n",
                "            errMsg += \"leveraged to retrieve queries output\"\n",
                "            raise sqlmapNotVulnerableException, errMsg\n",
                "\n",
                "    finally:\n",
                "        if suppressOutput is not None:\n",
                "            getCurrentThreadData().disableStdOut = popValue()\n",
                "\n",
                "    if value and expected == EXPECTED.BOOL:\n",
                "        if isinstance(value, basestring):\n",
                "            value = value.strip().lower()\n",
                "            if value in (\"true\", \"false\"):\n",
                "                value = value == \"true\"\n",
                "            elif value in (\"1\", \"-1\"):\n",
                "                value = True\n",
                "            elif value == \"0\":\n",
                "                value = False\n",
                "            else:\n",
                "                value = None\n",
                "        elif isinstance(value, int):\n",
                "            value = bool(value)\n",
                "        elif value == [None]:\n",
                "            value = None\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    if safeCharEncode:\n",
                    "        value = safecharencode(value)\n"
                ],
                "after": [
                    "    kb.safeCharEncode = False\n"
                ],
                "parent_version_range": {
                    "start": 501,
                    "end": 503
                },
                "child_version_range": {
                    "start": 502,
                    "end": 503
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if safeCharEncode:",
                        "start_line": 501,
                        "end_line": 502
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "getValue",
                        "signature": "def getValue(expression, blind=True, inband=True, error=True, time=True, fromUser=False, expected=None, batch=False, unpack=True, sort=True, resumeValue=True, charsetType=None, firstChar=None, lastChar=None, dump=False, suppressOutput=None, expectingNone=False, safeCharEncode=True):",
                        "at_line": 395
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: lib/request/inject.py\nCode:\n           def getValue(expression, blind=True, inband=True, error=True, time=True, fromUser=False, expected=None, batch=False, unpack=True, sort=True, resumeValue=True, charsetType=None, firstChar=None, lastChar=None, dump=False, suppressOutput=None, expectingNone=False, safeCharEncode=True):\n               ...\n498 499            elif value == [None]:\n499 500                value = None\n500 501    \n501      -     if safeCharEncode:\n502      -         value = safecharencode(value)\n    502  +     kb.safeCharEncode = False\n503 503    \n504 504        return value\n505 505    \n         ...\n",
                "file_path": "lib/request/inject.py",
                "identifiers_before": [
                    "safeCharEncode",
                    "safecharencode",
                    "value"
                ],
                "identifiers_after": [
                    "kb",
                    "safeCharEncode"
                ],
                "prefix": [
                    "        elif value == [None]:\n",
                    "            value = None\n",
                    "\n"
                ],
                "suffix": [
                    "\n",
                    "    return value\n",
                    "\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "safecharencode",
                            "position": {
                                "start": {
                                    "line": 502,
                                    "column": 16
                                },
                                "end": {
                                    "line": 502,
                                    "column": 30
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/lib/request/inject.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "    return value\n",
                "\n",
                "def goStacked(expression, silent=False):\n",
                "    kb.technique = PAYLOAD.TECHNIQUE.STACKED\n",
                "    expression = cleanQuery(expression)\n",
                "\n",
                "    if conf.direct:\n",
                "        return direct(expression)\n",
                "\n",
                "    comment = queries[Backend.getIdentifiedDbms()].comment.query\n",
                "    query = agent.prefixQuery(\"; %s\" % expression)\n",
                "    query = agent.suffixQuery(\"%s;%s\" % (query, comment))\n",
                "    payload = agent.payload(newValue=query)\n",
                "    Request.queryPage(payload, content=False, silent=silent, noteResponseTime=False, timeBasedCompare=True)\n",
                "\n",
                "def checkBooleanExpression(expression, expectingNone=True):\n",
                "    kb.suppressSession = True\n",
                "    value = getValue(unescaper.unescape(expression), expected=EXPECTED.BOOL, suppressOutput=True, expectingNone=expectingNone)\n",
                "    kb.suppressSession = False\n",
                "\n",
                "    return value"
            ]
        ],
        "lib/techniques/blind/inference.py": [
            [
                "#!/usr/bin/env python\n",
                "\n",
                "\"\"\"\n",
                "$Id$\n",
                "\n",
                "Copyright (c) 2006-2011 sqlmap developers (http://www.sqlmap.org/)\n",
                "See the file 'doc/COPYING' for copying permission\n",
                "\"\"\"\n",
                "\n",
                "import threading\n",
                "import time\n",
                "import traceback\n",
                "\n",
                "from lib.core.agent import agent\n",
                "from lib.core.common import Backend\n",
                "from lib.core.common import dataToSessionFile\n",
                "from lib.core.common import dataToStdout\n",
                "from lib.core.common import decodeIntToUnicode\n",
                "from lib.core.common import filterControlChars\n",
                "from lib.core.common import getCharset\n",
                "from lib.core.common import goGoodSamaritan\n",
                "from lib.core.common import getPartRun\n",
                "from lib.core.common import popValue\n",
                "from lib.core.common import pushValue\n",
                "from lib.core.common import readInput\n",
                "from lib.core.common import replaceNewlineTabs\n",
                "from lib.core.common import safeStringFormat\n",
                "from lib.core.common import singleTimeWarnMessage\n",
                "from lib.core.common import unhandledExceptionMessage\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "from lib.core.convert import safecharencode\n"
                ],
                "parent_version_range": {
                    "start": 29,
                    "end": 29
                },
                "child_version_range": {
                    "start": 29,
                    "end": 30
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 4,
                "hunk_diff": "File: lib/techniques/blind/inference.py\nCode:\n  ...\n26 26    from lib.core.common import safeStringFormat\n27 27    from lib.core.common import singleTimeWarnMessage\n28 28    from lib.core.common import unhandledExceptionMessage\n   29  + from lib.core.convert import safecharencode\n29 30    from lib.core.data import conf\n30 31    from lib.core.data import kb\n31 32    from lib.core.data import logger\n       ...\n",
                "file_path": "lib/techniques/blind/inference.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "convert",
                    "core",
                    "lib",
                    "safecharencode"
                ],
                "prefix": [
                    "from lib.core.common import safeStringFormat\n",
                    "from lib.core.common import singleTimeWarnMessage\n",
                    "from lib.core.common import unhandledExceptionMessage\n"
                ],
                "suffix": [
                    "from lib.core.data import conf\n",
                    "from lib.core.data import kb\n",
                    "from lib.core.data import logger\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "safecharencode",
                            "position": {
                                "start": {
                                    "line": 29,
                                    "column": 29
                                },
                                "end": {
                                    "line": 29,
                                    "column": 43
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/lib/techniques/blind/inference.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "from lib.core.data import conf\n",
                "from lib.core.data import kb\n",
                "from lib.core.data import logger\n",
                "from lib.core.data import queries\n",
                "from lib.core.enums import DBMS\n",
                "from lib.core.enums import PAYLOAD\n",
                "from lib.core.exception import sqlmapConnectionException\n",
                "from lib.core.exception import sqlmapValueException\n",
                "from lib.core.exception import sqlmapThreadException\n",
                "from lib.core.progress import ProgressBar\n",
                "from lib.core.settings import CHAR_INFERENCE_MARK\n",
                "from lib.core.settings import INFERENCE_BLANK_BREAK\n",
                "from lib.core.settings import INFERENCE_UNKNOWN_CHAR\n",
                "from lib.core.settings import INFERENCE_GREATER_CHAR\n",
                "from lib.core.settings import INFERENCE_EQUALS_CHAR\n",
                "from lib.core.settings import INFERENCE_NOT_EQUALS_CHAR\n",
                "from lib.core.settings import PYVERSION\n",
                "from lib.core.threads import getCurrentThreadData\n",
                "from lib.core.threads import runThreads\n",
                "from lib.core.unescaper import unescaper\n",
                "from lib.request.connect import Connect as Request\n",
                "\n",
                "def bisection(payload, expression, length=None, charsetType=None, firstChar=None, lastChar=None, dump=False):\n",
                "    \"\"\"\n",
                "    Bisection algorithm that can be used to perform blind SQL injection\n",
                "    on an affected host\n",
                "    \"\"\"\n",
                "\n",
                "    partialValue = \"\"\n",
                "    finalValue = \"\"\n",
                "    asciiTbl = getCharset(charsetType)\n",
                "    timeBasedCompare = (kb.technique in (PAYLOAD.TECHNIQUE.TIME, PAYLOAD.TECHNIQUE.STACKED))\n",
                "\n",
                "    # Set kb.partRun in case \"common prediction\" feature (a.k.a. \"good\n",
                "    # samaritan\") is used\n",
                "    kb.partRun = getPartRun() if conf.predictOutput else None\n",
                "\n",
                "    if \"LENGTH(\" in expression or \"LEN(\" in expression:\n",
                "        firstChar = 0\n",
                "    elif dump and conf.firstChar is not None and ( isinstance(conf.firstChar, int) or ( isinstance(conf.firstChar, basestring) and conf.firstChar.isdigit() ) ):\n",
                "        firstChar = int(conf.firstChar) - 1\n",
                "    elif firstChar is None:\n",
                "        firstChar = 0\n",
                "    elif ( isinstance(firstChar, basestring) and firstChar.isdigit() ) or isinstance(firstChar, int):\n",
                "        firstChar = int(firstChar) - 1\n",
                "\n",
                "    if \"LENGTH(\" in expression or \"LEN(\" in expression:\n",
                "        lastChar = 0\n",
                "    elif dump and conf.lastChar is not None and ( isinstance(conf.lastChar, int) or ( isinstance(conf.lastChar, basestring) and conf.lastChar.isdigit() ) ):\n",
                "        lastChar = int(conf.lastChar)\n",
                "    elif lastChar in ( None, \"0\" ):\n",
                "        lastChar = 0\n",
                "    elif ( isinstance(lastChar, basestring) and lastChar.isdigit() ) or isinstance(lastChar, int):\n",
                "        lastChar = int(lastChar)\n",
                "\n",
                "    if Backend.getDbms():\n",
                "        _, _, _, _, _, _, fieldToCastStr, _ = agent.getFields(expression)\n",
                "        nulledCastedField = agent.nullAndCastField(fieldToCastStr)\n",
                "        expressionReplaced = expression.replace(fieldToCastStr, nulledCastedField, 1)\n",
                "        expressionUnescaped = unescaper.unescape(expressionReplaced)\n",
                "    else:\n",
                "        expressionUnescaped = unescaper.unescape(expression)\n",
                "\n",
                "    if length and not isinstance(length, int) and length.isdigit():\n",
                "        length = int(length)\n",
                "\n",
                "    if length == 0:\n",
                "        return 0, \"\"\n",
                "\n",
                "    if lastChar > 0 and length > ( lastChar - firstChar ):\n",
                "        length = ( lastChar - firstChar )\n",
                "\n",
                "    showEta = conf.eta and isinstance(length, int)\n",
                "    numThreads = min(conf.threads, length)\n",
                "    threads = []\n",
                "\n",
                "    if showEta:\n",
                "        progress = ProgressBar(maxValue=length)\n",
                "        progressTime = []\n",
                "\n",
                "    if numThreads > 1:\n",
                "        if not timeBasedCompare:\n",
                "            debugMsg = \"starting %d thread%s\" % (numThreads, (\"s\" if numThreads > 1 else \"\"))\n",
                "            logger.debug(debugMsg)\n",
                "        else:\n",
                "            debugMsg = \"multi-threading is not considered safe in time-based data retrieval\"\n",
                "            logger.debug(debugMsg)\n",
                "            numThreads = 1\n",
                "\n",
                "    if conf.threads == 1 and not timeBasedCompare:\n",
                "        warnMsg = \"running in a single-thread mode. Please consider \"\n",
                "        warnMsg += \"usage of --threads switch for faster data retrieval\"\n",
                "        singleTimeWarnMessage(warnMsg)\n",
                "\n",
                "    if conf.verbose in (1, 2) and not showEta:\n",
                "        if isinstance(length, int) and conf.threads > 1:\n",
                "            dataToStdout(\"[%s] [INFO] retrieved: %s\" % (time.strftime(\"%X\"), \"_\" * min(length, conf.progressWidth)))\n",
                "            dataToStdout(\"\\r[%s] [INFO] retrieved: \" % time.strftime(\"%X\"))\n",
                "        else:\n",
                "            dataToStdout(\"[%s] [INFO] retrieved: \" % time.strftime(\"%X\"))\n",
                "\n",
                "    queriesCount = [0] # As list to deal with nested scoping rules\n",
                "    hintlock = threading.Lock()\n",
                "\n",
                "    def tryHint(idx):\n",
                "        hintlock.acquire()\n",
                "        hintValue = kb.hintValue\n",
                "        hintlock.release()\n",
                "\n",
                "        if hintValue is not None and len(hintValue) >= idx:\n",
                "            if Backend.getIdentifiedDbms() in (DBMS.SQLITE, DBMS.ACCESS, DBMS.MAXDB, DBMS.DB2):\n",
                "                posValue = hintValue[idx-1]\n",
                "            else:\n",
                "                posValue = ord(hintValue[idx-1])\n",
                "\n",
                "            forgedPayload = safeStringFormat(payload.replace(INFERENCE_GREATER_CHAR, INFERENCE_EQUALS_CHAR), (expressionUnescaped, idx, posValue))\n",
                "            queriesCount[0] += 1\n",
                "            result = Request.queryPage(forgedPayload, timeBasedCompare=timeBasedCompare, raise404=False)\n",
                "\n",
                "            if result:\n",
                "                return hintValue[idx-1]\n",
                "\n",
                "        hintlock.acquire()\n",
                "        kb.hintValue = None\n",
                "        hintlock.release()\n",
                "\n",
                "        return None\n",
                "\n",
                "    def validateChar(idx, value):\n",
                "        \"\"\"\n",
                "        Used in time-based inference (in case that original and retrieved\n",
                "        value are not equal there will be a deliberate delay).\n",
                "        \"\"\"\n",
                "\n",
                "        forgedPayload = safeStringFormat(payload.replace(INFERENCE_GREATER_CHAR, INFERENCE_NOT_EQUALS_CHAR), (expressionUnescaped, idx, value))\n",
                "        queriesCount[0] += 1\n",
                "        result = Request.queryPage(forgedPayload, timeBasedCompare=timeBasedCompare, raise404=False)\n",
                "\n",
                "        return not result\n",
                "\n",
                "    def getChar(idx, charTbl=asciiTbl, continuousOrder=True, expand=charsetType is None):\n",
                "        \"\"\"\n",
                "        continuousOrder means that distance between each two neighbour's\n",
                "        numerical values is exactly 1\n",
                "        \"\"\"\n",
                "\n",
                "        result = tryHint(idx)\n",
                "\n",
                "        if result:\n",
                "            return result\n",
                "\n",
                "        originalTbl = list(charTbl)\n",
                "\n",
                "        if continuousOrder:\n",
                "            # Used for gradual expanding into unicode charspace\n",
                "            shiftTable = [5, 4]\n",
                "\n",
                "        if CHAR_INFERENCE_MARK in payload and ord('\\n') in charTbl:\n",
                "            charTbl.remove(ord('\\n'))\n",
                "\n",
                "        if len(charTbl) == 1:\n",
                "            forgedPayload = safeStringFormat(payload.replace(INFERENCE_GREATER_CHAR, INFERENCE_EQUALS_CHAR), (expressionUnescaped, idx, charTbl[0]))\n",
                "            queriesCount[0] += 1\n",
                "            result = Request.queryPage(forgedPayload, timeBasedCompare=timeBasedCompare, raise404=False)\n",
                "\n",
                "            if result:\n",
                "                return decodeIntToUnicode(charTbl[0])\n",
                "            else:\n",
                "                return None\n",
                "\n",
                "        maxChar = maxValue = charTbl[-1]\n",
                "        minChar = minValue = charTbl[0]\n",
                "\n",
                "        while len(charTbl) != 1:\n",
                "            position = (len(charTbl) >> 1)\n",
                "            posValue = charTbl[position]\n",
                "\n",
                "            if CHAR_INFERENCE_MARK not in payload:\n",
                "                forgedPayload = safeStringFormat(payload, (expressionUnescaped, idx, posValue))\n",
                "            else:\n",
                "                # e.g.: ... > '%c' -> ... > ORD(..)\n",
                "                markingValue = \"'%s'\" % CHAR_INFERENCE_MARK\n",
                "                unescapedCharValue = unescaper.unescape(markingValue % decodeIntToUnicode(posValue))\n",
                "                forgedPayload = safeStringFormat(payload, (expressionUnescaped, idx)).replace(markingValue, unescapedCharValue)\n",
                "\n",
                "            queriesCount[0] += 1\n",
                "            result = Request.queryPage(forgedPayload, timeBasedCompare=timeBasedCompare, raise404=False)\n",
                "\n",
                "            if result:\n",
                "                minValue = posValue\n",
                "\n",
                "                if type(charTbl) != xrange:\n",
                "                    charTbl = charTbl[position:]\n",
                "                else:\n",
                "                    # xrange() - extended virtual charset used for memory/space optimization\n",
                "                    charTbl = xrange(charTbl[position], charTbl[-1] + 1)\n",
                "            else:\n",
                "                maxValue = posValue\n",
                "\n",
                "                if type(charTbl) != xrange:\n",
                "                    charTbl = charTbl[:position]\n",
                "                else:\n",
                "                    charTbl = xrange(charTbl[0], charTbl[position])\n",
                "\n",
                "            if len(charTbl) == 1:\n",
                "                if continuousOrder:\n",
                "                    if maxValue == 1:\n",
                "                        return None\n",
                "\n",
                "                    # Going beyond the original charset\n",
                "                    elif minValue == maxChar:\n",
                "                        # If the original charTbl was [0,..,127] new one\n",
                "                        # will be [128,..,128*16-1] or from 128 to 2047\n",
                "                        # and instead of making a HUGE list with all the\n",
                "                        # elements we use a xrange, which is a virtual\n",
                "                        # list\n",
                "                        if expand and shiftTable:\n",
                "                            charTbl = xrange(maxChar + 1, (maxChar + 1) << shiftTable.pop())\n",
                "                            originalTbl = list(charTbl)\n",
                "                            maxChar = maxValue = charTbl[-1]\n",
                "                            minChar = minValue = charTbl[0]\n",
                "                        else:\n",
                "                            return None\n",
                "                    else:\n",
                "                        retVal = minValue + 1\n",
                "\n",
                "                        if retVal in originalTbl or (retVal == ord('\\n') and CHAR_INFERENCE_MARK in payload):\n",
                "                            if timeBasedCompare and not validateChar(idx, retVal):\n",
                "                                errMsg = \"invalid character detected. retrying..\"\n",
                "                                logger.error(errMsg)\n",
                "\n",
                "                                conf.timeSec += 1\n",
                "                                warnMsg = \"increasing time delay to %d second%s \" % (conf.timeSec, 's' if conf.timeSec > 1 else '')\n",
                "                                warnMsg += \"(due to invalid char)\"\n",
                "                                logger.warn(warnMsg)\n",
                "\n",
                "                                if kb.adjustTimeDelay:\n",
                "                                    dbgMsg = \"turning off auto-adjustment mechanism\"\n",
                "                                    logger.debug(dbgMsg)\n",
                "                                    kb.adjustTimeDelay = False\n",
                "                                return getChar(idx, originalTbl, continuousOrder, expand)\n",
                "                            else:\n",
                "                                return decodeIntToUnicode(retVal)\n",
                "                        else:\n",
                "                            return None\n",
                "                else:\n",
                "                    if minValue == maxChar or maxValue == minChar:\n",
                "                        return None\n",
                "\n",
                "                    # If we are working with non-continuous elements, set\n",
                "                    # both minValue and character afterwards are possible\n",
                "                    # candidates\n",
                "                    for retVal in (originalTbl[originalTbl.index(minValue)], originalTbl[originalTbl.index(minValue) + 1]):\n",
                "                        forgedPayload = safeStringFormat(payload.replace(INFERENCE_GREATER_CHAR, INFERENCE_EQUALS_CHAR), (expressionUnescaped, idx, retVal))\n",
                "                        queriesCount[0] += 1\n",
                "                        result = Request.queryPage(forgedPayload, timeBasedCompare=timeBasedCompare, raise404=False)\n",
                "\n",
                "                        if result:\n",
                "                            return decodeIntToUnicode(retVal)\n",
                "\n",
                "                    return None\n",
                "\n",
                "    def etaProgressUpdate(charTime, index):\n",
                "        if len(progressTime) <= ( (length * 3) / 100 ):\n",
                "            eta = 0\n",
                "        else:\n",
                "            midTime = sum(progressTime) / len(progressTime)\n",
                "            midTimeWithLatest = (midTime + charTime) / 2\n",
                "            eta = midTimeWithLatest * (length - index) / conf.threads\n",
                "\n",
                "        progressTime.append(charTime)\n",
                "        progress.update(index)\n",
                "        progress.draw(eta)\n",
                "\n",
                "    # Go multi-threading (--threads > 1)\n",
                "    if conf.threads > 1 and isinstance(length, int) and length > 1:\n",
                "        value = []\n",
                "        threadData = getCurrentThreadData()\n",
                "\n",
                "        threadData.shared.value = [ None ] * length\n",
                "        threadData.shared.index = [ firstChar ]    # As list for python nested function scoping\n",
                "\n",
                "        lockNames = ('iolock', 'idxlock', 'valuelock')\n",
                "        for lock in lockNames:\n",
                "            kb.locks[lock] = threading.Lock()\n",
                "\n",
                "        try:\n",
                "            def blindThread():\n",
                "                threadData = getCurrentThreadData()\n",
                "\n",
                "                while kb.threadContinue:\n",
                "                    kb.locks.idxlock.acquire()\n",
                "\n",
                "                    if threadData.shared.index[0] >= length:\n",
                "                        kb.locks.idxlock.release()\n",
                "\n",
                "                        return\n",
                "\n",
                "                    threadData.shared.index[0] += 1\n",
                "                    curidx = threadData.shared.index[0]\n",
                "                    kb.locks.idxlock.release()\n",
                "\n",
                "                    if kb.threadContinue:\n",
                "                        charStart = time.time()\n",
                "                        val = getChar(curidx)\n",
                "                        if val is None:\n",
                "                            val = INFERENCE_UNKNOWN_CHAR\n",
                "                    else:\n",
                "                        break\n",
                "\n",
                "                    kb.locks.valuelock.acquire()\n",
                "                    threadData.shared.value[curidx-1] = val\n",
                "                    currentValue = list(threadData.shared.value)\n",
                "                    kb.locks.valuelock.release()\n",
                "\n",
                "                    if kb.threadContinue:\n",
                "                        if showEta:\n",
                "                            etaProgressUpdate(time.time() - charStart, threadData.shared.index[0])\n",
                "                        elif conf.verbose >= 1:\n",
                "                            startCharIndex = 0\n",
                "                            endCharIndex = 0\n",
                "\n",
                "                            for i in xrange(length):\n",
                "                                if currentValue[i] is not None:\n",
                "                                    endCharIndex = max(endCharIndex, i)\n",
                "\n",
                "                            output = ''\n",
                "\n",
                "                            if endCharIndex > conf.progressWidth:\n",
                "                                startCharIndex = endCharIndex - conf.progressWidth\n",
                "\n",
                "                            count = 0\n",
                "\n",
                "                            for i in xrange(startCharIndex, endCharIndex + 1):\n",
                "                                output += '_' if currentValue[i] is None else currentValue[i]\n",
                "\n",
                "                            for i in xrange(length):\n",
                "                                count += 1 if currentValue[i] is not None else 0\n",
                "\n",
                "                            if startCharIndex > 0:\n",
                "                                output = '..' + output[2:]\n",
                "\n",
                "                            if (endCharIndex - startCharIndex == conf.progressWidth) and (endCharIndex < length-1):\n",
                "                                output = output[:-2] + '..'\n",
                "\n",
                "                            if conf.verbose in (1, 2) and not showEta:\n",
                "                                output += '_' * (min(length, conf.progressWidth) - len(output))\n",
                "                                status = ' %d/%d (%d%s)' % (count, length, round(100.0*count/length), '%')\n",
                "                                output += status if count != length else \" \"*len(status)\n",
                "\n",
                "                                kb.locks.iolock.acquire()\n",
                "                                dataToStdout(\"\\r[%s] [INFO] retrieved: %s\" % (time.strftime(\"%X\"), filterControlChars(output)))\n",
                "                                kb.locks.iolock.release()\n",
                "\n",
                "                if not kb.threadContinue:\n",
                "                    if int(threading.currentThread().getName()) == numThreads - 1:\n",
                "                        partialValue = unicode()\n",
                "                        for v in threadData.shared.value:\n",
                "                            if v is None:\n",
                "                                break\n",
                "                            elif isinstance(v, basestring):\n",
                "                                partialValue += v\n",
                "\n",
                "                        if len(partialValue) > 0:\n",
                "                            dataToSessionFile(replaceNewlineTabs(partialValue))\n",
                "\n",
                "            runThreads(numThreads, blindThread, startThreadMsg=False)\n",
                "\n",
                "        except KeyboardInterrupt:\n",
                "            raise\n",
                "\n",
                "        finally:\n",
                "            value = threadData.shared.value\n",
                "            \n",
                "        infoMsg = None\n",
                "\n",
                "        # If we have got one single character not correctly fetched it\n",
                "        # can mean that the connection to the target url was lost\n",
                "        if None in value:\n",
                "            for v in value:\n",
                "                if isinstance(v, basestring) and v is not None:\n",
                "                    partialValue += v\n",
                "\n",
                "            if partialValue:\n",
                "                finalValue = partialValue\n",
                "                infoMsg = \"\\r[%s] [INFO] partially retrieved: %s\" % (time.strftime(\"%X\"), filterControlChars(finalValue))\n",
                "        else:\n",
                "            finalValue = \"\".join(value)\n",
                "            infoMsg = \"\\r[%s] [INFO] retrieved: %s\" % (time.strftime(\"%X\"), filterControlChars(finalValue))\n",
                "\n",
                "        if isinstance(finalValue, basestring) and len(finalValue) > 0:\n",
                "            dataToSessionFile(replaceNewlineTabs(finalValue))\n",
                "\n",
                "        if conf.verbose in (1, 2) and not showEta and infoMsg:\n",
                "            dataToStdout(infoMsg)\n",
                "\n",
                "    # No multi-threading (--threads = 1)\n",
                "    else:\n",
                "        index = firstChar\n",
                "\n",
                "        while True:\n",
                "            index += 1\n",
                "            charStart = time.time()\n",
                "\n",
                "            # Common prediction feature (a.k.a. \"good samaritan\")\n",
                "            # NOTE: to be used only when multi-threading is not set for\n",
                "            # the moment\n",
                "            if conf.predictOutput and len(finalValue) > 0 and kb.partRun is not None:\n",
                "                val = None\n",
                "                commonValue, commonPattern, commonCharset, otherCharset = goGoodSamaritan(finalValue, asciiTbl)\n",
                "\n",
                "                # If there is one single output in common-outputs, check\n",
                "                # it via equal against the query output\n",
                "                if commonValue is not None:\n",
                "                    # One-shot query containing equals commonValue\n",
                "                    testValue = unescaper.unescape(\"'%s'\" % commonValue) if \"'\" not in commonValue else unescaper.unescape(\"%s\" % commonValue, quote=False)\n",
                "                    query = agent.prefixQuery(safeStringFormat(\"AND (%s) = %s\", (expressionUnescaped, testValue)))\n",
                "                    query = agent.suffixQuery(query)\n",
                "                    queriesCount[0] += 1\n",
                "                    result = Request.queryPage(agent.payload(newValue=query), timeBasedCompare=timeBasedCompare, raise404=False)\n",
                "\n",
                "                    # Did we have luck?\n",
                "                    if result:\n",
                "                        dataToSessionFile(replaceNewlineTabs(commonValue[index-1:]))\n",
                "\n",
                "                        if showEta:\n",
                "                            etaProgressUpdate(time.time() - charStart, len(commonValue))\n",
                "                        elif conf.verbose in (1, 2):\n",
                "                            dataToStdout(commonValue[index-1:])\n",
                "\n",
                "                        finalValue = commonValue\n",
                "\n",
                "                        break\n",
                "\n",
                "                # If there is a common pattern starting with finalValue,\n",
                "                # check it via equal against the substring-query output\n",
                "                if commonPattern is not None:\n",
                "                    # Substring-query containing equals commonPattern\n",
                "                    subquery = queries[Backend.getIdentifiedDbms()].substring.query % (expressionUnescaped, 1, len(commonPattern))\n",
                "                    testValue = unescaper.unescape(\"'%s'\" % commonPattern) if \"'\" not in commonPattern else unescaper.unescape(\"%s\" % commonPattern, quote=False)\n",
                "                    query = agent.prefixQuery(safeStringFormat(\"AND (%s) = %s\", (subquery, testValue)))\n",
                "                    query = agent.suffixQuery(query)\n",
                "                    queriesCount[0] += 1\n",
                "                    result = Request.queryPage(agent.payload(newValue=query), timeBasedCompare=timeBasedCompare, raise404=False)\n",
                "\n",
                "                    # Did we have luck?\n",
                "                    if result:\n",
                "                        val = commonPattern[index-1:]\n",
                "                        index += len(val)-1\n",
                "\n",
                "                # Otherwise if there is no commonValue (single match from\n",
                "                # txt/common-outputs.txt) and no commonPattern\n",
                "                # (common pattern) use the returned common charset only\n",
                "                # to retrieve the query output\n",
                "                if not val and commonCharset:\n",
                "                    val = getChar(index, commonCharset, False)\n",
                "\n",
                "                # If we had no luck with commonValue and common charset,\n",
                "                # use the returned other charset\n",
                "                if not val:\n",
                "                    val = getChar(index, otherCharset, otherCharset == asciiTbl)\n",
                "            else:\n",
                "                val = getChar(index, asciiTbl)\n",
                "\n",
                "            if val is None or ( lastChar > 0 and index > lastChar ):\n",
                "                break\n",
                "\n",
                "            if kb.data.processChar:\n",
                "                val = kb.data.processChar(val)\n",
                "\n",
                "            finalValue += val\n",
                "            dataToSessionFile(replaceNewlineTabs(val))\n",
                "\n",
                "            if showEta:\n",
                "                etaProgressUpdate(time.time() - charStart, index)\n",
                "            elif conf.verbose in (1, 2):\n",
                "                dataToStdout(val)\n",
                "\n",
                "            if len(finalValue) > INFERENCE_BLANK_BREAK and finalValue[-INFERENCE_BLANK_BREAK:].isspace():\n",
                "                break\n",
                "\n",
                "    if conf.verbose in (1, 2) or showEta:\n",
                "        dataToStdout(\"\\n\")\n",
                "\n",
                "    if ( conf.verbose in ( 1, 2 ) and showEta ) or conf.verbose >= 3:\n",
                "        infoMsg = \"retrieved: %s\" % filterControlChars(finalValue)\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "    if not partialValue:\n",
                "        dataToSessionFile(\"]\\n\")\n",
                "\n",
                "    if kb.threadException:\n",
                "        raise sqlmapThreadException, \"something unexpected happened inside the threads\"\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    return queriesCount[0], finalValue\n"
                ],
                "after": [
                    "    return queriesCount[0], safecharencode(finalValue) if kb.safeCharEncode else finalValue"
                ],
                "parent_version_range": {
                    "start": 523,
                    "end": 524
                },
                "child_version_range": {
                    "start": 524,
                    "end": 525
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "bisection",
                        "signature": "def bisection(payload, expression, length=None, charsetType=None, firstChar=None, lastChar=None, dump=False):",
                        "at_line": 51
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: lib/techniques/blind/inference.py\nCode:\n           def bisection(payload, expression, length=None, charsetType=None, firstChar=None, lastChar=None, dump=False):\n               ...\n520 521        if kb.threadException:\n521 522            raise sqlmapThreadException, \"something unexpected happened inside the threads\"\n522 523    \n523      -     return queriesCount[0], finalValue\n    524  +     return queriesCount[0], safecharencode(finalValue) if kb.safeCharEncode else finalValue\n         ...\n",
                "file_path": "lib/techniques/blind/inference.py",
                "identifiers_before": [
                    "finalValue",
                    "queriesCount"
                ],
                "identifiers_after": [
                    "finalValue",
                    "kb",
                    "queriesCount",
                    "safeCharEncode",
                    "safecharencode"
                ],
                "prefix": [
                    "    if kb.threadException:\n",
                    "        raise sqlmapThreadException, \"something unexpected happened inside the threads\"\n",
                    "\n"
                ],
                "suffix": [],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "safecharencode",
                            "position": {
                                "start": {
                                    "line": 524,
                                    "column": 28
                                },
                                "end": {
                                    "line": 524,
                                    "column": 42
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/lib/techniques/blind/inference.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            }
        ],
        "lib/techniques/error/use.py": [
            [
                "#!/usr/bin/env python\n",
                "\n",
                "\"\"\"\n",
                "$Id$\n",
                "\n",
                "Copyright (c) 2006-2011 sqlmap developers (http://www.sqlmap.org/)\n",
                "See the file 'doc/COPYING' for copying permission\n",
                "\"\"\"\n",
                "\n",
                "import re\n",
                "import threading\n",
                "import time\n",
                "\n",
                "from lib.core.agent import agent\n",
                "from lib.core.common import Backend\n",
                "from lib.core.common import BigArray\n",
                "from lib.core.common import calculateDeltaSeconds\n",
                "from lib.core.common import dataToSessionFile\n",
                "from lib.core.common import dataToStdout\n",
                "from lib.core.common import extractRegexResult\n",
                "from lib.core.common import getUnicode\n",
                "from lib.core.common import initTechnique\n",
                "from lib.core.common import isNumPosStrValue\n",
                "from lib.core.common import listToStrValue\n",
                "from lib.core.common import randomInt\n",
                "from lib.core.common import replaceNewlineTabs\n",
                "from lib.core.common import safeStringFormat\n",
                "from lib.core.convert import htmlunescape\n",
                "from lib.core.convert import safecharencode\n",
                "from lib.core.data import conf\n",
                "from lib.core.data import kb\n",
                "from lib.core.data import logger\n",
                "from lib.core.data import queries\n",
                "from lib.core.enums import DBMS\n",
                "from lib.core.enums import EXPECTED\n",
                "from lib.core.enums import PAYLOAD\n",
                "from lib.core.exception import sqlmapConnectionException\n",
                "from lib.core.settings import FROM_TABLE\n",
                "from lib.core.settings import MYSQL_ERROR_CHUNK_LENGTH\n",
                "from lib.core.settings import MSSQL_ERROR_CHUNK_LENGTH\n",
                "from lib.core.settings import SQL_SCALAR_REGEX\n",
                "from lib.core.settings import TURN_OFF_RESUME_INFO_LIMIT\n",
                "from lib.core.threads import getCurrentThreadData\n",
                "from lib.core.threads import runThreads\n",
                "from lib.core.unescaper import unescaper\n",
                "from lib.request.connect import Connect as Request\n",
                "from lib.utils.resume import resume\n",
                "\n",
                "reqCount = 0\n",
                "\n",
                "def __oneShotErrorUse(expression, field):\n",
                "    global reqCount\n",
                "\n",
                "    threadData = getCurrentThreadData()\n",
                "\n",
                "    retVal = None\n",
                "    offset = 1\n",
                "    chunk_length = None\n",
                "\n",
                "    while True:\n",
                "        check = \"%s(?P<result>.*?)%s\" % (kb.misc.start, kb.misc.stop)\n",
                "        trimcheck = \"%s(?P<result>.*?)</\" % (kb.misc.start)\n",
                "\n",
                "        nulledCastedField = agent.nullAndCastField(field)\n",
                "\n",
                "        if Backend.isDbms(DBMS.MYSQL):\n",
                "            chunk_length = MYSQL_ERROR_CHUNK_LENGTH\n",
                "            nulledCastedField = queries[DBMS.MYSQL].substring.query % (nulledCastedField, offset, chunk_length)\n",
                "        elif Backend.isDbms(DBMS.MSSQL):\n",
                "            chunk_length = MSSQL_ERROR_CHUNK_LENGTH\n",
                "            nulledCastedField = queries[DBMS.MSSQL].substring.query % (nulledCastedField, offset, chunk_length)\n",
                "\n",
                "        # Forge the error-based SQL injection request\n",
                "        vector = kb.injection.data[PAYLOAD.TECHNIQUE.ERROR].vector\n",
                "        query = agent.prefixQuery(vector)\n",
                "        query = agent.suffixQuery(query)\n",
                "        injExpression = expression.replace(field, nulledCastedField, 1)\n",
                "        injExpression = unescaper.unescape(injExpression)\n",
                "        injExpression = query.replace(\"[QUERY]\", injExpression)\n",
                "        payload = agent.payload(newValue=injExpression)\n",
                "\n",
                "        # Perform the request\n",
                "        page, headers = Request.queryPage(payload, content=True)\n",
                "\n",
                "        reqCount += 1\n",
                "\n",
                "        # Parse the returned page to get the exact error-based\n",
                "        # sql injection output\n",
                "        output = reduce(lambda x, y: x if x is not None else y, [ \\\n",
                "                extractRegexResult(check, page, re.DOTALL | re.IGNORECASE), \\\n",
                "                extractRegexResult(check, listToStrValue(headers.headers \\\n",
                "                if headers else None), re.DOTALL | re.IGNORECASE), \\\n",
                "                extractRegexResult(check, threadData.lastRedirectMsg[1] \\\n",
                "                if threadData.lastRedirectMsg and threadData.lastRedirectMsg[0] == \\\n",
                "                threadData.lastRequestUID else None, re.DOTALL | re.IGNORECASE)], \\\n",
                "                None)\n",
                "\n",
                "        if output is not None:\n",
                "            output = getUnicode(output, kb.pageEncoding)\n",
                "        else:\n",
                "            trimmed = extractRegexResult(trimcheck, page, re.DOTALL | re.IGNORECASE) \\\n",
                "                or extractRegexResult(trimcheck, listToStrValue(headers.headers \\\n",
                "                if headers else None), re.DOTALL | re.IGNORECASE) \\\n",
                "                or extractRegexResult(trimcheck, threadData.lastRedirectMsg[1] \\\n",
                "                if threadData.lastRedirectMsg and threadData.lastRedirectMsg[0] == \\\n",
                "                threadData.lastRequestUID else None, re.DOTALL | re.IGNORECASE)\n",
                "\n",
                "            if trimmed:\n",
                "                warnMsg = \"possible server trimmed output detected (due to its length): \"\n",
                "                warnMsg += trimmed\n",
                "                logger.warn(warnMsg)\n",
                "\n",
                "        if any(map(lambda dbms: Backend.isDbms(dbms), [DBMS.MYSQL, DBMS.MSSQL])):\n",
                "            if offset == 1:\n",
                "                retVal = output\n",
                "            else:\n",
                "                retVal += output if output else ''\n",
                "\n",
                "            if output and len(output) >= chunk_length:\n",
                "                offset += chunk_length\n",
                "            else:\n",
                "                break\n",
                "        else:\n",
                "            retVal = output\n",
                "            break\n",
                "\n",
                "    if isinstance(retVal, basestring):\n",
                "        retVal = htmlunescape(retVal).replace(\"<br>\", \"\\n\")\n",
                "\n",
                "    retVal = __errorReplaceChars(retVal)\n",
                "\n",
                "    dataToSessionFile(\"[%s][%s][%s][%s][%s]\\n\" % (conf.url, kb.injection.place, conf.parameters[kb.injection.place], expression, replaceNewlineTabs(retVal)))\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    return retVal\n"
                ],
                "after": [
                    "    return safecharencode(retVal) if kb.safeCharEncode else retVal\n"
                ],
                "parent_version_range": {
                    "start": 133,
                    "end": 134
                },
                "child_version_range": {
                    "start": 133,
                    "end": 134
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "__oneShotErrorUse",
                        "signature": "def __oneShotErrorUse(expression, field):",
                        "at_line": 50
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: lib/techniques/error/use.py\nCode:\n           def __oneShotErrorUse(expression, field):\n               ...\n130 130    \n131 131        dataToSessionFile(\"[%s][%s][%s][%s][%s]\\n\" % (conf.url, kb.injection.place, conf.parameters[kb.injection.place], expression, replaceNewlineTabs(retVal)))\n132 132    \n133      -     return retVal\n    133  +     return safecharencode(retVal) if kb.safeCharEncode else retVal\n134 134    \n135 135    def __errorFields(expression, expressionFields, expressionFieldsList, expected=None, num=None, resumeValue=True):\n136 136        outputs = []\n         ...\n",
                "file_path": "lib/techniques/error/use.py",
                "identifiers_before": [
                    "retVal"
                ],
                "identifiers_after": [
                    "kb",
                    "retVal",
                    "safeCharEncode",
                    "safecharencode"
                ],
                "prefix": [
                    "\n",
                    "    dataToSessionFile(\"[%s][%s][%s][%s][%s]\\n\" % (conf.url, kb.injection.place, conf.parameters[kb.injection.place], expression, replaceNewlineTabs(retVal)))\n",
                    "\n"
                ],
                "suffix": [
                    "\n",
                    "def __errorFields(expression, expressionFields, expressionFieldsList, expected=None, num=None, resumeValue=True):\n",
                    "    outputs = []\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "def __errorFields(expression, expressionFields, expressionFieldsList, expected=None, num=None, resumeValue=True):\n",
                "    outputs = []\n",
                "    origExpr = None\n",
                "\n",
                "    for field in expressionFieldsList:\n",
                "        output = None\n",
                "\n",
                "        if field.startswith(\"ROWNUM \"):\n",
                "            continue\n",
                "\n",
                "        if isinstance(num, int):\n",
                "            origExpr = expression\n",
                "            expression = agent.limitQuery(num, expression, field, expressionFieldsList[0])\n",
                "\n",
                "        if \"ROWNUM\" in expressionFieldsList:\n",
                "            expressionReplaced = expression\n",
                "        else:\n",
                "            expressionReplaced = expression.replace(expressionFields, field, 1)\n",
                "\n",
                "        if resumeValue:\n",
                "            output = resume(expressionReplaced, None)\n",
                "\n",
                "        if not output or (expected == EXPECTED.INT and not output.isdigit()):\n",
                "            if output:\n",
                "                warnMsg = \"expected value type %s, resumed '%s', \" % (expected, output)\n",
                "                warnMsg += \"sqlmap is going to retrieve the value again\"\n",
                "                logger.warn(warnMsg)\n",
                "\n",
                "            output = __oneShotErrorUse(expressionReplaced, field)\n",
                "\n",
                "            if not kb.threadContinue:\n",
                "                return None\n",
                "\n",
                "            if output is not None:\n",
                "                kb.locks.ioLock.acquire()\n",
                "                dataToStdout(\"[%s] [INFO] retrieved: %s\\r\\n\" % (time.strftime(\"%X\"), safecharencode(output)))\n",
                "                kb.locks.ioLock.release()\n",
                "\n",
                "        if isinstance(num, int):\n",
                "            expression = origExpr\n",
                "\n",
                "        outputs.append(output)\n",
                "\n",
                "    return outputs\n",
                "\n",
                "def __errorReplaceChars(value):\n",
                "    \"\"\"\n",
                "    Restores safely replaced characters\n",
                "    \"\"\"\n",
                "\n",
                "    retVal = value\n",
                "\n",
                "    if value:\n",
                "        retVal = retVal.replace(kb.misc.space, \" \").replace(kb.misc.dollar, \"$\").replace(kb.misc.at, \"@\")\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def errorUse(expression, expected=None, resumeValue=True, dump=False):\n",
                "    \"\"\"\n",
                "    Retrieve the output of a SQL query taking advantage of the error-based\n",
                "    SQL injection vulnerability on the affected parameter.\n",
                "    \"\"\"\n",
                "\n",
                "    initTechnique(PAYLOAD.TECHNIQUE.ERROR)\n",
                "\n",
                "    global reqCount\n",
                "\n",
                "    count = None\n",
                "    start = time.time()\n",
                "    startLimit = 0\n",
                "    stopLimit = None\n",
                "    outputs = []\n",
                "    untilLimitChar = None\n",
                "    untilOrderChar = None\n",
                "    reqCount = 0\n",
                "\n",
                "    if resumeValue:\n",
                "        output = resume(expression, None)\n",
                "    else:\n",
                "        output = None\n",
                "\n",
                "    if output and (expected is None or (expected == EXPECTED.INT and output.isdigit())):\n",
                "        return output\n",
                "\n",
                "    _, _, _, _, _, expressionFieldsList, expressionFields, _ = agent.getFields(expression)\n",
                "\n",
                "    # We have to check if the SQL query might return multiple entries\n",
                "    # and in such case forge the SQL limiting the query output one\n",
                "    # entry per time\n",
                "    # NOTE: I assume that only queries that get data from a table can\n",
                "    # return multiple entries\n",
                "    if (dump and (conf.limitStart or conf.limitStop)) or (\" FROM \" in \\\n",
                "       expression.upper() and ((Backend.getIdentifiedDbms() not in FROM_TABLE) \\\n",
                "       or (Backend.getIdentifiedDbms() in FROM_TABLE and not \\\n",
                "       expression.upper().endswith(FROM_TABLE[Backend.getIdentifiedDbms()]))) \\\n",
                "       and (\"(CASE\" not in expression.upper() or (\"(CASE\" in expression.upper() and \"WHEN use\" in expression))) \\\n",
                "       and not re.search(SQL_SCALAR_REGEX, expression, re.I):\n",
                "\n",
                "        limitRegExp = re.search(queries[Backend.getIdentifiedDbms()].limitregexp.query, expression, re.I)\n",
                "        topLimit = re.search(\"TOP\\s+([\\d]+)\\s+\", expression, re.I)\n",
                "\n",
                "        if limitRegExp or (Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE) and topLimit):\n",
                "            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n",
                "                limitGroupStart = queries[Backend.getIdentifiedDbms()].limitgroupstart.query\n",
                "                limitGroupStop = queries[Backend.getIdentifiedDbms()].limitgroupstop.query\n",
                "\n",
                "                if limitGroupStart.isdigit():\n",
                "                    startLimit = int(limitRegExp.group(int(limitGroupStart)))\n",
                "\n",
                "                stopLimit = limitRegExp.group(int(limitGroupStop))\n",
                "                limitCond = int(stopLimit) > 1\n",
                "\n",
                "            elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n",
                "                if limitRegExp:\n",
                "                    limitGroupStart = queries[Backend.getIdentifiedDbms()].limitgroupstart.query\n",
                "                    limitGroupStop = queries[Backend.getIdentifiedDbms()].limitgroupstop.query\n",
                "\n",
                "                    if limitGroupStart.isdigit():\n",
                "                        startLimit = int(limitRegExp.group(int(limitGroupStart)))\n",
                "\n",
                "                    stopLimit = limitRegExp.group(int(limitGroupStop))\n",
                "                    limitCond = int(stopLimit) > 1\n",
                "                elif topLimit:\n",
                "                    startLimit = 0\n",
                "                    stopLimit = int(topLimit.group(1))\n",
                "                    limitCond = int(stopLimit) > 1\n",
                "\n",
                "            elif Backend.isDbms(DBMS.ORACLE):\n",
                "                limitCond = False\n",
                "        else:\n",
                "            limitCond = True\n",
                "\n",
                "        # I assume that only queries NOT containing a \"LIMIT #, 1\"\n",
                "        # (or similar depending on the back-end DBMS) can return\n",
                "        # multiple entries\n",
                "        if limitCond:\n",
                "            if limitRegExp:\n",
                "                stopLimit = int(stopLimit)\n",
                "\n",
                "                # From now on we need only the expression until the \" LIMIT \"\n",
                "                # (or similar, depending on the back-end DBMS) word\n",
                "                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n",
                "                    stopLimit += startLimit\n",
                "                    untilLimitChar = expression.index(queries[Backend.getIdentifiedDbms()].limitstring.query)\n",
                "                    expression = expression[:untilLimitChar]\n",
                "\n",
                "                elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n",
                "                    stopLimit += startLimit\n",
                "            elif dump:\n",
                "                if conf.limitStart:\n",
                "                    startLimit = conf.limitStart\n",
                "                if conf.limitStop:\n",
                "                    stopLimit = conf.limitStop\n",
                "\n",
                "            # Count the number of SQL query entries output\n",
                "            countedExpression = expression.replace(expressionFields, \"COUNT(*)\", 1)\n",
                "\n",
                "            if re.search(\" ORDER BY \", expression, re.I):\n",
                "                untilOrderChar = countedExpression.index(\" ORDER BY \")\n",
                "                countedExpression = countedExpression[:untilOrderChar]\n",
                "\n",
                "            count = resume(countedExpression, None)\n",
                "\n",
                "            if not count or not count.isdigit():\n",
                "                _, _, _, _, _, _, countedExpressionFields, _ = agent.getFields(countedExpression)\n",
                "                count = __oneShotErrorUse(countedExpression, countedExpressionFields)\n",
                "\n",
                "            if isNumPosStrValue(count):\n",
                "                if isinstance(stopLimit, int) and stopLimit > 0:\n",
                "                    stopLimit = min(int(count), int(stopLimit))\n",
                "                else:\n",
                "                    stopLimit = int(count)\n",
                "\n",
                "                    infoMsg = \"the SQL query used returns \"\n",
                "                    infoMsg += \"%d entries\" % stopLimit\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "            else:\n",
                "                warnMsg = \"it was not possible to count the number \"\n",
                "                warnMsg += \"of entries for the used SQL query. \"\n",
                "                warnMsg += \"sqlmap will assume that it returns only \"\n",
                "                warnMsg += \"one entry\"\n",
                "                logger.warn(warnMsg)\n",
                "\n",
                "                stopLimit = 1\n",
                "\n",
                "            threadData = getCurrentThreadData()\n",
                "            threadData.shared.limits = iter(xrange(startLimit, stopLimit))\n",
                "            numThreads = min(conf.threads, (stopLimit - startLimit))\n",
                "            threadData.shared.outputs = BigArray()\n",
                "\n",
                "            if stopLimit > TURN_OFF_RESUME_INFO_LIMIT:\n",
                "                kb.suppressResumeInfo = True\n",
                "                debugMsg = \"suppressing possible resume console info because of \"\n",
                "                debugMsg += \"large number of rows. It might take too long\"\n",
                "                logger.debug(debugMsg)\n",
                "\n",
                "            lockNames = ('limits', 'outputs')\n",
                "            for lock in lockNames:\n",
                "                kb.locks[lock] = threading.Lock()\n",
                "\n",
                "            try:\n",
                "                def errorThread():\n",
                "                    threadData = getCurrentThreadData()\n",
                "\n",
                "                    while kb.threadContinue:\n",
                "                        kb.locks.limits.acquire()\n",
                "                        try:\n",
                "                            num = threadData.shared.limits.next()\n",
                "                        except StopIteration:\n",
                "                            break\n",
                "                        finally:\n",
                "                            kb.locks.limits.release()\n",
                "\n",
                "                        output = __errorFields(expression, expressionFields, expressionFieldsList, expected, num, resumeValue)\n",
                "\n",
                "                        if not kb.threadContinue:\n",
                "                            break\n",
                "\n",
                "                        if output and isinstance(output, list) and len(output) == 1:\n",
                "                            output = output[0]\n",
                "\n",
                "                        kb.locks.outputs.acquire()\n",
                "                        threadData.shared.outputs.append(output)\n",
                "                        kb.locks.outputs.release()\n",
                "\n",
                "                runThreads(numThreads, errorThread)\n",
                "\n",
                "            except KeyboardInterrupt:\n",
                "                warnMsg = \"user aborted during enumeration. sqlmap \"\n",
                "                warnMsg += \"will display partial output\"\n",
                "                logger.warn(warnMsg)\n",
                "\n",
                "            finally:\n",
                "                outputs = threadData.shared.outputs\n",
                "                kb.suppressResumeInfo = False\n",
                "\n",
                "    if not outputs:\n",
                "        outputs = __errorFields(expression, expressionFields, expressionFieldsList)\n",
                "\n",
                "    if outputs and isinstance(outputs, list) and len(outputs) == 1 and isinstance(outputs[0], basestring):\n",
                "        outputs = outputs[0]\n",
                "\n",
                "    duration = calculateDeltaSeconds(start)\n",
                "\n",
                "    if not kb.bruteMode:\n",
                "        debugMsg = \"performed %d queries in %d seconds\" % (reqCount, duration)\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "    return outputs"
            ]
        ],
        "lib/techniques/union/use.py": [
            [
                "#!/usr/bin/env python\n",
                "\n",
                "\"\"\"\n",
                "$Id$\n",
                "\n",
                "Copyright (c) 2006-2011 sqlmap developers (http://www.sqlmap.org/)\n",
                "See the file 'doc/COPYING' for copying permission\n",
                "\"\"\"\n",
                "\n",
                "import re\n",
                "import threading\n",
                "import time\n",
                "\n",
                "from lib.core.agent import agent\n",
                "from lib.core.common import Backend\n",
                "from lib.core.common import BigArray\n",
                "from lib.core.common import calculateDeltaSeconds\n",
                "from lib.core.common import clearConsoleLine\n",
                "from lib.core.common import dataToStdout\n",
                "from lib.core.common import extractRegexResult\n",
                "from lib.core.common import filterStringValue\n",
                "from lib.core.common import getConsoleWidth\n",
                "from lib.core.common import getUnicode\n",
                "from lib.core.common import initTechnique\n",
                "from lib.core.common import isNumPosStrValue\n",
                "from lib.core.common import listToStrValue\n",
                "from lib.core.common import parseUnionPage\n",
                "from lib.core.common import removeReflectiveValues\n",
                "from lib.core.common import singleTimeWarnMessage\n",
                "from lib.core.convert import safecharencode\n",
                "from lib.core.data import conf\n",
                "from lib.core.data import kb\n",
                "from lib.core.data import logger\n",
                "from lib.core.data import queries\n",
                "from lib.core.enums import DBMS\n",
                "from lib.core.enums import PAYLOAD\n",
                "from lib.core.exception import sqlmapConnectionException\n",
                "from lib.core.exception import sqlmapSyntaxException\n",
                "from lib.core.settings import FROM_TABLE\n",
                "from lib.core.settings import SQL_SCALAR_REGEX\n",
                "from lib.core.settings import TURN_OFF_RESUME_INFO_LIMIT\n",
                "from lib.core.threads import getCurrentThreadData\n",
                "from lib.core.threads import runThreads\n",
                "from lib.core.unescaper import unescaper\n",
                "from lib.request.connect import Connect as Request\n",
                "from lib.utils.resume import resume\n",
                "\n",
                "reqCount = 0\n",
                "\n",
                "def __oneShotUnionUse(expression, unpack=True):\n",
                "    global reqCount\n",
                "\n",
                "    check = \"(?P<result>%s.*%s)\" % (kb.misc.start, kb.misc.stop)\n",
                "    trimcheck = \"%s(?P<result>.*?)</\" % (kb.misc.start)\n",
                "\n",
                "    # Prepare expression with delimiters\n",
                "    expression = agent.concatQuery(expression, unpack)\n",
                "    expression = unescaper.unescape(expression)\n",
                "\n",
                "    if conf.limitStart or conf.limitStop:\n",
                "        where = PAYLOAD.WHERE.NEGATIVE\n",
                "    else:\n",
                "        where = None\n",
                "\n",
                "    # Forge the inband SQL injection request\n",
                "    vector = kb.injection.data[PAYLOAD.TECHNIQUE.UNION].vector\n",
                "    query = agent.forgeInbandQuery(expression, vector[0], vector[1], vector[2], vector[3], vector[4], vector[5])\n",
                "    payload = agent.payload(newValue=query, where=where)\n",
                "\n",
                "    # Perform the request\n",
                "    page, headers = Request.queryPage(payload, content=True, raise404=False)\n",
                "\n",
                "    reqCount += 1\n",
                "\n",
                "    # Parse the returned page to get the exact union-based\n",
                "    # sql injection output\n",
                "    output = reduce(lambda x, y: x if x is not None else y, [ \\\n",
                "            extractRegexResult(check, removeReflectiveValues(page, payload), re.DOTALL | re.IGNORECASE), \\\n",
                "            extractRegexResult(check, removeReflectiveValues(listToStrValue(headers.headers \\\n",
                "            if headers else None), payload, True), re.DOTALL | re.IGNORECASE)], \\\n",
                "            None)\n",
                "\n",
                "    if output is not None:\n",
                "        output = getUnicode(output, kb.pageEncoding)\n",
                "    else:\n",
                "        trimmed = extractRegexResult(trimcheck, removeReflectiveValues(page, payload), re.DOTALL | re.IGNORECASE) \\\n",
                "                or extractRegexResult(trimcheck, removeReflectiveValues(listToStrValue(headers.headers \\\n",
                "                if headers else None), payload, True), re.DOTALL | re.IGNORECASE)\n",
                "\n",
                "        if trimmed:\n",
                "            warnMsg = \"possible server trimmed output detected (due to its length): \"\n",
                "            warnMsg += trimmed\n",
                "            logger.warn(warnMsg)\n",
                "        elif Backend.isDbms(DBMS.MYSQL) and not kb.multiThreadMode:\n",
                "            warnMsg = \"if the problem persists with 'None' values please try to use \"\n",
                "            warnMsg += \"hidden switch --no-cast (fixing problems with some collation \"\n",
                "            warnMsg += \"issues)\"\n",
                "            singleTimeWarnMessage(warnMsg)\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    return output\n"
                ],
                "after": [
                    "    return safecharencode(output) if kb.safeCharEncode else output\n"
                ],
                "parent_version_range": {
                    "start": 99,
                    "end": 100
                },
                "child_version_range": {
                    "start": 99,
                    "end": 100
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "__oneShotUnionUse",
                        "signature": "def __oneShotUnionUse(expression, unpack=True):",
                        "at_line": 49
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: lib/techniques/union/use.py\nCode:\n           def __oneShotUnionUse(expression, unpack=True):\n               ...\n 96  96                warnMsg += \"issues)\"\n 97  97                singleTimeWarnMessage(warnMsg)\n 98  98    \n 99      -     return output\n     99  +     return safecharencode(output) if kb.safeCharEncode else output\n100 100    \n101 101    def configUnion(char=None, columns=None):\n102 102        def __configUnionChar(char):\n         ...\n",
                "file_path": "lib/techniques/union/use.py",
                "identifiers_before": [
                    "output"
                ],
                "identifiers_after": [
                    "kb",
                    "output",
                    "safeCharEncode",
                    "safecharencode"
                ],
                "prefix": [
                    "            warnMsg += \"issues)\"\n",
                    "            singleTimeWarnMessage(warnMsg)\n",
                    "\n"
                ],
                "suffix": [
                    "\n",
                    "def configUnion(char=None, columns=None):\n",
                    "    def __configUnionChar(char):\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "def configUnion(char=None, columns=None):\n",
                "    def __configUnionChar(char):\n",
                "        if not isinstance(char, basestring):\n",
                "            return\n",
                "\n",
                "        kb.uChar = char\n",
                "\n",
                "        if conf.uChar is not None:\n",
                "            kb.uChar = char.replace(\"[CHAR]\", conf.uChar if conf.uChar.isdigit() else \"'%s'\" % conf.uChar.strip(\"'\"))\n",
                "\n",
                "    def __configUnionCols(columns):\n",
                "        if not isinstance(columns, basestring):\n",
                "            return\n",
                "\n",
                "        columns = columns.replace(\" \", \"\")\n",
                "        if \"-\" in columns:\n",
                "            colsStart, colsStop = columns.split(\"-\")\n",
                "        else:\n",
                "            colsStart, colsStop = columns, columns\n",
                "\n",
                "        if not colsStart.isdigit() or not colsStop.isdigit():\n",
                "            raise sqlmapSyntaxException, \"--union-cols must be a range of integers\"\n",
                "\n",
                "        conf.uColsStart = int(colsStart)\n",
                "        conf.uColsStop = int(colsStop)\n",
                "\n",
                "        if conf.uColsStart > conf.uColsStop:\n",
                "            errMsg = \"--union-cols range has to be from lower to \"\n",
                "            errMsg += \"higher number of columns\"\n",
                "            raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    __configUnionChar(char)\n",
                "    __configUnionCols(conf.uCols or columns)\n",
                "\n",
                "def unionUse(expression, unpack=True, dump=False):\n",
                "    \"\"\"\n",
                "    This function tests for an inband SQL injection on the target\n",
                "    url then call its subsidiary function to effectively perform an\n",
                "    inband SQL injection on the affected url\n",
                "    \"\"\"\n",
                "\n",
                "    initTechnique(PAYLOAD.TECHNIQUE.UNION)\n",
                "\n",
                "    global reqCount\n",
                "\n",
                "    count = None\n",
                "    origExpr = expression\n",
                "    startLimit = 0\n",
                "    stopLimit = None\n",
                "    test = True\n",
                "    value = \"\"\n",
                "    reqCount = 0\n",
                "    width = getConsoleWidth()\n",
                "    start = time.time()\n",
                "\n",
                "    _, _, _, _, _, expressionFieldsList, expressionFields, _ = agent.getFields(origExpr)\n",
                "\n",
                "    # We have to check if the SQL query might return multiple entries\n",
                "    # and in such case forge the SQL limiting the query output one\n",
                "    # entry per time\n",
                "    # NOTE: I assume that only queries that get data from a table can\n",
                "    # return multiple entries\n",
                "    if (kb.injection.data[PAYLOAD.TECHNIQUE.UNION].where == PAYLOAD.WHERE.NEGATIVE or \\\n",
                "       (dump and (conf.limitStart or conf.limitStop))) and \\\n",
                "       \" FROM \" in expression.upper() and ((Backend.getIdentifiedDbms() \\\n",
                "       not in FROM_TABLE) or (Backend.getIdentifiedDbms() in FROM_TABLE \\\n",
                "       and not expression.upper().endswith(FROM_TABLE[Backend.getIdentifiedDbms()]))) \\\n",
                "       and not re.search(SQL_SCALAR_REGEX, expression, re.I):\n",
                "\n",
                "        limitRegExp = re.search(queries[Backend.getIdentifiedDbms()].limitregexp.query, expression, re.I)\n",
                "        topLimit = re.search(\"TOP\\s+([\\d]+)\\s+\", expression, re.I)\n",
                "\n",
                "        if limitRegExp or (Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE) and topLimit):\n",
                "            if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n",
                "                limitGroupStart = queries[Backend.getIdentifiedDbms()].limitgroupstart.query\n",
                "                limitGroupStop = queries[Backend.getIdentifiedDbms()].limitgroupstop.query\n",
                "\n",
                "                if limitGroupStart.isdigit():\n",
                "                    startLimit = int(limitRegExp.group(int(limitGroupStart)))\n",
                "\n",
                "                stopLimit = limitRegExp.group(int(limitGroupStop))\n",
                "                limitCond = int(stopLimit) > 1\n",
                "\n",
                "            elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n",
                "                if limitRegExp:\n",
                "                    limitGroupStart = queries[Backend.getIdentifiedDbms()].limitgroupstart.query\n",
                "                    limitGroupStop = queries[Backend.getIdentifiedDbms()].limitgroupstop.query\n",
                "\n",
                "                    if limitGroupStart.isdigit():\n",
                "                        startLimit = int(limitRegExp.group(int(limitGroupStart)))\n",
                "\n",
                "                    stopLimit = limitRegExp.group(int(limitGroupStop))\n",
                "                    limitCond = int(stopLimit) > 1\n",
                "\n",
                "                elif topLimit:\n",
                "                    startLimit = 0\n",
                "                    stopLimit = int(topLimit.group(1))\n",
                "                    limitCond = int(stopLimit) > 1\n",
                "\n",
                "            elif Backend.isDbms(DBMS.ORACLE):\n",
                "                limitCond = False\n",
                "        else:\n",
                "            limitCond = True\n",
                "\n",
                "        # I assume that only queries NOT containing a \"LIMIT #, 1\"\n",
                "        # (or similar depending on the back-end DBMS) can return\n",
                "        # multiple entries\n",
                "        if limitCond:\n",
                "            if limitRegExp:\n",
                "                stopLimit = int(stopLimit)\n",
                "\n",
                "                # From now on we need only the expression until the \" LIMIT \"\n",
                "                # (or similar, depending on the back-end DBMS) word\n",
                "                if Backend.getIdentifiedDbms() in (DBMS.MYSQL, DBMS.PGSQL):\n",
                "                    stopLimit += startLimit\n",
                "                    untilLimitChar = expression.index(queries[Backend.getIdentifiedDbms()].limitstring.query)\n",
                "                    expression = expression[:untilLimitChar]\n",
                "\n",
                "                elif Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n",
                "                    stopLimit += startLimit\n",
                "            elif dump:\n",
                "                if conf.limitStart:\n",
                "                    startLimit = conf.limitStart\n",
                "                if conf.limitStop:\n",
                "                    stopLimit = conf.limitStop\n",
                "\n",
                "            # Count the number of SQL query entries output\n",
                "            countedExpression = expression.replace(expressionFields, \"COUNT(*)\", 1)\n",
                "\n",
                "            if re.search(\" ORDER BY \", expression, re.I):\n",
                "                untilOrderChar = countedExpression.index(\" ORDER BY \")\n",
                "                countedExpression = countedExpression[:untilOrderChar]\n",
                "\n",
                "            count = resume(countedExpression, None)\n",
                "            count = parseUnionPage(count, countedExpression)\n",
                "\n",
                "            if not count or not count.isdigit():\n",
                "                output = __oneShotUnionUse(countedExpression, unpack)\n",
                "\n",
                "                if output:\n",
                "                    count = parseUnionPage(output, countedExpression)\n",
                "\n",
                "            if isNumPosStrValue(count):\n",
                "                if isinstance(stopLimit, int) and stopLimit > 0:\n",
                "                    stopLimit = min(int(count), int(stopLimit))\n",
                "                else:\n",
                "                    stopLimit = int(count)\n",
                "\n",
                "                    infoMsg = \"the SQL query used returns \"\n",
                "                    infoMsg += \"%d entries\" % stopLimit\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "            else:\n",
                "                warnMsg = \"it was not possible to count the number \"\n",
                "                warnMsg += \"of entries for the used SQL query. \"\n",
                "                warnMsg += \"sqlmap will assume that it returns only \"\n",
                "                warnMsg += \"one entry\"\n",
                "                logger.warn(warnMsg)\n",
                "\n",
                "                stopLimit = 1\n",
                "\n",
                "            threadData = getCurrentThreadData()\n",
                "            threadData.shared.limits = iter(xrange(startLimit, stopLimit))\n",
                "            numThreads = min(conf.threads, (stopLimit - startLimit))\n",
                "            threadData.shared.value = BigArray()\n",
                "\n",
                "            if stopLimit > TURN_OFF_RESUME_INFO_LIMIT:\n",
                "                kb.suppressResumeInfo = True\n",
                "                debugMsg = \"suppressing possible resume console info because of \"\n",
                "                debugMsg += \"large number of rows. It might take too long\"\n",
                "                logger.debug(debugMsg)\n",
                "\n",
                "            lockNames = ('limits', 'value')\n",
                "            for lock in lockNames:\n",
                "                kb.locks[lock] = threading.Lock()\n",
                "\n",
                "            try:\n",
                "                def unionThread():\n",
                "                    threadData = getCurrentThreadData()\n",
                "\n",
                "                    while kb.threadContinue:\n",
                "                        kb.locks.limits.acquire()\n",
                "                        try:\n",
                "                            num = threadData.shared.limits.next()\n",
                "                        except StopIteration:\n",
                "                            break\n",
                "                        finally:\n",
                "                            kb.locks.limits.release()\n",
                "\n",
                "                        if Backend.getIdentifiedDbms() in (DBMS.MSSQL, DBMS.SYBASE):\n",
                "                            field = expressionFieldsList[0]\n",
                "                        elif Backend.isDbms(DBMS.ORACLE):\n",
                "                            field = expressionFieldsList\n",
                "                        else:\n",
                "                            field = None\n",
                "\n",
                "                        limitedExpr = agent.limitQuery(num, expression, field)\n",
                "                        output = resume(limitedExpr, None)\n",
                "\n",
                "                        if not output:\n",
                "                            output = __oneShotUnionUse(limitedExpr, unpack)\n",
                "\n",
                "                        if not kb.threadContinue:\n",
                "                            break\n",
                "\n",
                "                        if output:\n",
                "                            if all(map(lambda x: x in output, [kb.misc.start, kb.misc.stop])):\n",
                "                                items = extractRegexResult(r'%s(?P<result>.*?)%s' % (kb.misc.start, kb.misc.stop), output, re.DOTALL | re.IGNORECASE).split(kb.misc.delimiter)\n",
                "                                kb.locks.value.acquire()\n",
                "                                threadData.shared.value.append(items[0] if len(items) == 1 else items)\n",
                "                                kb.locks.value.release()\n",
                "                            else:\n",
                "                                items = output.replace(kb.misc.start, \"\").replace(kb.misc.stop, \"\").split(kb.misc.delimiter)\n",
                "\n",
                "                            if conf.verbose == 1:\n",
                "                                status = \"[%s] [INFO] retrieved: %s\\r\\n\" % (time.strftime(\"%X\"), safecharencode(\",\".join(map(lambda x: \"\\\"%s\\\"\" % x, items))))\n",
                "\n",
                "                                if len(status) > width:\n",
                "                                    status = \"%s...\" % status[:width - 3]\n",
                "\n",
                "                                kb.locks.ioLock.acquire()\n",
                "                                dataToStdout(status, True)\n",
                "                                kb.locks.ioLock.release()\n",
                "\n",
                "                runThreads(numThreads, unionThread)\n",
                "\n",
                "                if conf.verbose == 1:\n",
                "                    clearConsoleLine(True)\n",
                "\n",
                "            except KeyboardInterrupt:\n",
                "                warnMsg = \"user aborted during enumeration. sqlmap \"\n",
                "                warnMsg += \"will display partial output\"\n",
                "                logger.warn(warnMsg)\n",
                "\n",
                "            finally:\n",
                "                value = threadData.shared.value\n",
                "                kb.suppressResumeInfo = False\n",
                "\n",
                "    if not value:\n",
                "        value = __oneShotUnionUse(expression, unpack)\n",
                "\n",
                "    duration = calculateDeltaSeconds(start)\n",
                "\n",
                "    if not kb.bruteMode:\n",
                "        debugMsg = \"performed %d queries in %d seconds\" % (reqCount, duration)\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "    return value"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "def and use of kb.safeCharEncode"
        },
        {
            "edit_hunk_pair": [
                0,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use of kb.safeCharEncode"
        },
        {
            "edit_hunk_pair": [
                0,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "def and use of kb.safeCharEncode"
        },
        {
            "edit_hunk_pair": [
                0,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "def and use of kb.safeCharEncode"
        },
        {
            "edit_hunk_pair": [
                1,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                1,
                4
            ],
            "edit_order": "0 before 1",
            "reason": "move import"
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                3,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "refactor"
        },
        {
            "edit_hunk_pair": [
                3,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "refactor"
        },
        {
            "edit_hunk_pair": [
                3,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "refactor"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        }
    ]
}