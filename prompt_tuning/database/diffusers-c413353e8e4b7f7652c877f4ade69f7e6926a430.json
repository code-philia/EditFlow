{
    "language": "python",
    "commit_url": "https://github.com/huggingface/diffusers/commit/c413353e8e4b7f7652c877f4ade69f7e6926a430",
    "commit_message": "add `encoder_hid_dim` to unet\n\n`encoder_hid_dim` provides an additional projection for the input `encoder_hidden_states` from `encoder_hidden_dim` to `cross_attention_dim`",
    "commit_snapshots": {
        "src/diffusers/models/unet_2d_condition.py": [
            [
                "# Copyright 2023 The HuggingFace Team. All rights reserved.\n",
                "#\n",
                "# Licensed under the Apache License, Version 2.0 (the \"License\");\n",
                "# you may not use this file except in compliance with the License.\n",
                "# You may obtain a copy of the License at\n",
                "#\n",
                "#     http://www.apache.org/licenses/LICENSE-2.0\n",
                "#\n",
                "# Unless required by applicable law or agreed to in writing, software\n",
                "# distributed under the License is distributed on an \"AS IS\" BASIS,\n",
                "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
                "# See the License for the specific language governing permissions and\n",
                "# limitations under the License.\n",
                "from dataclasses import dataclass\n",
                "from typing import Any, Dict, List, Optional, Tuple, Union\n",
                "\n",
                "import torch\n",
                "import torch.nn as nn\n",
                "import torch.utils.checkpoint\n",
                "\n",
                "from ..configuration_utils import ConfigMixin, register_to_config\n",
                "from ..loaders import UNet2DConditionLoadersMixin\n",
                "from ..utils import BaseOutput, logging\n",
                "from .attention_processor import AttentionProcessor, AttnProcessor\n",
                "from .embeddings import GaussianFourierProjection, TimestepEmbedding, Timesteps\n",
                "from .modeling_utils import ModelMixin\n",
                "from .unet_2d_blocks import (\n",
                "    CrossAttnDownBlock2D,\n",
                "    CrossAttnUpBlock2D,\n",
                "    DownBlock2D,\n",
                "    UNetMidBlock2DCrossAttn,\n",
                "    UNetMidBlock2DSimpleCrossAttn,\n",
                "    UpBlock2D,\n",
                "    get_down_block,\n",
                "    get_up_block,\n",
                ")\n",
                "\n",
                "\n",
                "logger = logging.get_logger(__name__)  # pylint: disable=invalid-name\n",
                "\n",
                "\n",
                "@dataclass\n",
                "class UNet2DConditionOutput(BaseOutput):\n",
                "    \"\"\"\n",
                "    Args:\n",
                "        sample (`torch.FloatTensor` of shape `(batch_size, num_channels, height, width)`):\n",
                "            Hidden states conditioned on `encoder_hidden_states` input. Output of last layer of model.\n",
                "    \"\"\"\n",
                "\n",
                "    sample: torch.FloatTensor\n",
                "\n",
                "\n",
                "class UNet2DConditionModel(ModelMixin, ConfigMixin, UNet2DConditionLoadersMixin):\n",
                "    r\"\"\"\n",
                "    UNet2DConditionModel is a conditional 2D UNet model that takes in a noisy sample, conditional state, and a timestep\n",
                "    and returns sample shaped output.\n",
                "\n",
                "    This model inherits from [`ModelMixin`]. Check the superclass documentation for the generic methods the library\n",
                "    implements for all the models (such as downloading or saving, etc.)\n",
                "\n",
                "    Parameters:\n",
                "        sample_size (`int` or `Tuple[int, int]`, *optional*, defaults to `None`):\n",
                "            Height and width of input/output sample.\n",
                "        in_channels (`int`, *optional*, defaults to 4): The number of channels in the input sample.\n",
                "        out_channels (`int`, *optional*, defaults to 4): The number of channels in the output.\n",
                "        center_input_sample (`bool`, *optional*, defaults to `False`): Whether to center the input sample.\n",
                "        flip_sin_to_cos (`bool`, *optional*, defaults to `False`):\n",
                "            Whether to flip the sin to cos in the time embedding.\n",
                "        freq_shift (`int`, *optional*, defaults to 0): The frequency shift to apply to the time embedding.\n",
                "        down_block_types (`Tuple[str]`, *optional*, defaults to `(\"CrossAttnDownBlock2D\", \"CrossAttnDownBlock2D\", \"CrossAttnDownBlock2D\", \"DownBlock2D\")`):\n",
                "            The tuple of downsample blocks to use.\n",
                "        mid_block_type (`str`, *optional*, defaults to `\"UNetMidBlock2DCrossAttn\"`):\n",
                "            The mid block type. Choose from `UNetMidBlock2DCrossAttn` or `UNetMidBlock2DSimpleCrossAttn`, will skip the\n",
                "            mid block layer if `None`.\n",
                "        up_block_types (`Tuple[str]`, *optional*, defaults to `(\"UpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\",)`):\n",
                "            The tuple of upsample blocks to use.\n",
                "        only_cross_attention(`bool` or `Tuple[bool]`, *optional*, default to `False`):\n",
                "            Whether to include self-attention in the basic transformer blocks, see\n",
                "            [`~models.attention.BasicTransformerBlock`].\n",
                "        block_out_channels (`Tuple[int]`, *optional*, defaults to `(320, 640, 1280, 1280)`):\n",
                "            The tuple of output channels for each block.\n",
                "        layers_per_block (`int`, *optional*, defaults to 2): The number of layers per block.\n",
                "        downsample_padding (`int`, *optional*, defaults to 1): The padding to use for the downsampling convolution.\n",
                "        mid_block_scale_factor (`float`, *optional*, defaults to 1.0): The scale factor to use for the mid block.\n",
                "        act_fn (`str`, *optional*, defaults to `\"silu\"`): The activation function to use.\n",
                "        norm_num_groups (`int`, *optional*, defaults to 32): The number of groups to use for the normalization.\n",
                "            If `None`, it will skip the normalization and activation layers in post-processing\n",
                "        norm_eps (`float`, *optional*, defaults to 1e-5): The epsilon to use for the normalization.\n",
                "        cross_attention_dim (`int` or `Tuple[int]`, *optional*, defaults to 1280):\n",
                "            The dimension of the cross attention features.\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        encoder_hid_dim (`int`, *optional*, defaults to None):\n",
                    "            If given, `encoder_hidden_states` will be projected from this dimension to `cross_attention_dim`.\n"
                ],
                "parent_version_range": {
                    "start": 90,
                    "end": 90
                },
                "child_version_range": {
                    "start": 90,
                    "end": 92
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "UNet2DConditionModel",
                        "signature": "class UNet2DConditionModel(ModelMixin, ConfigMixin, UNet2DConditionLoadersMixin):",
                        "at_line": 52
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: src/diffusers/models/unet_2d_condition.py\nCode:\n         class UNet2DConditionModel(ModelMixin, ConfigMixin, UNet2DConditionLoadersMixin):\n             ...\n87 87            norm_eps (`float`, *optional*, defaults to 1e-5): The epsilon to use for the normalization.\n88 88            cross_attention_dim (`int` or `Tuple[int]`, *optional*, defaults to 1280):\n89 89                The dimension of the cross attention features.\n   90  +         encoder_hid_dim (`int`, *optional*, defaults to None):\n   91  +             If given, `encoder_hidden_states` will be projected from this dimension to `cross_attention_dim`.\n90 92            attention_head_dim (`int`, *optional*, defaults to 8): The dimension of the attention heads.\n91 93            resnet_time_scale_shift (`str`, *optional*, defaults to `\"default\"`): Time scale shift config\n92 94                for resnet blocks, see [`~models.resnet.ResnetBlock2D`]. Choose from `default` or `scale_shift`.\n       ...\n",
                "file_path": "src/diffusers/models/unet_2d_condition.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "If",
                    "be",
                    "defaults",
                    "dimension",
                    "encoder_hid_dim",
                    "given",
                    "optional",
                    "projected",
                    "this",
                    "to",
                    "will"
                ],
                "prefix": [
                    "        norm_eps (`float`, *optional*, defaults to 1e-5): The epsilon to use for the normalization.\n",
                    "        cross_attention_dim (`int` or `Tuple[int]`, *optional*, defaults to 1280):\n",
                    "            The dimension of the cross attention features.\n"
                ],
                "suffix": [
                    "        attention_head_dim (`int`, *optional*, defaults to 8): The dimension of the attention heads.\n",
                    "        resnet_time_scale_shift (`str`, *optional*, defaults to `\"default\"`): Time scale shift config\n",
                    "            for resnet blocks, see [`~models.resnet.ResnetBlock2D`]. Choose from `default` or `scale_shift`.\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    4
                ]
            },
            [
                "        attention_head_dim (`int`, *optional*, defaults to 8): The dimension of the attention heads.\n",
                "        resnet_time_scale_shift (`str`, *optional*, defaults to `\"default\"`): Time scale shift config\n",
                "            for resnet blocks, see [`~models.resnet.ResnetBlock2D`]. Choose from `default` or `scale_shift`.\n",
                "        class_embed_type (`str`, *optional*, defaults to None):\n",
                "            The type of class embedding to use which is ultimately summed with the time embeddings. Choose from `None`,\n",
                "            `\"timestep\"`, `\"identity\"`, `\"projection\"`, or `\"simple_projection\"`.\n",
                "        num_class_embeds (`int`, *optional*, defaults to None):\n",
                "            Input dimension of the learnable embedding matrix to be projected to `time_embed_dim`, when performing\n",
                "            class conditioning with `class_embed_type` equal to `None`.\n",
                "        time_embedding_type (`str`, *optional*, default to `positional`):\n",
                "            The type of position embedding to use for timesteps. Choose from `positional` or `fourier`.\n",
                "        timestep_post_act (`str, *optional*, default to `None`):\n",
                "            The second activation function to use in timestep embedding. Choose from `silu`, `mish` and `gelu`.\n",
                "        time_cond_proj_dim (`int`, *optional*, default to `None`):\n",
                "            The dimension of `cond_proj` layer in timestep embedding.\n",
                "        conv_in_kernel (`int`, *optional*, default to `3`): The kernel size of `conv_in` layer.\n",
                "        conv_out_kernel (`int`, *optional*, default to `3`): The kernel size of `conv_out` layer.\n",
                "        projection_class_embeddings_input_dim (`int`, *optional*): The dimension of the `class_labels` input when\n",
                "            using the \"projection\" `class_embed_type`. Required when using the \"projection\" `class_embed_type`.\n",
                "        class_embeddings_concat (`bool`, *optional*, defaults to `False`): Whether to concatenate the time\n",
                "        embeddings with the class embeddings.\n",
                "    \"\"\"\n",
                "\n",
                "    _supports_gradient_checkpointing = True\n",
                "\n",
                "    @register_to_config\n",
                "    def __init__(\n",
                "        self,\n",
                "        sample_size: Optional[int] = None,\n",
                "        in_channels: int = 4,\n",
                "        out_channels: int = 4,\n",
                "        center_input_sample: bool = False,\n",
                "        flip_sin_to_cos: bool = True,\n",
                "        freq_shift: int = 0,\n",
                "        down_block_types: Tuple[str] = (\n",
                "            \"CrossAttnDownBlock2D\",\n",
                "            \"CrossAttnDownBlock2D\",\n",
                "            \"CrossAttnDownBlock2D\",\n",
                "            \"DownBlock2D\",\n",
                "        ),\n",
                "        mid_block_type: Optional[str] = \"UNetMidBlock2DCrossAttn\",\n",
                "        up_block_types: Tuple[str] = (\"UpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\"),\n",
                "        only_cross_attention: Union[bool, Tuple[bool]] = False,\n",
                "        block_out_channels: Tuple[int] = (320, 640, 1280, 1280),\n",
                "        layers_per_block: Union[int, Tuple[int]] = 2,\n",
                "        downsample_padding: int = 1,\n",
                "        mid_block_scale_factor: float = 1,\n",
                "        act_fn: str = \"silu\",\n",
                "        norm_num_groups: Optional[int] = 32,\n",
                "        norm_eps: float = 1e-5,\n",
                "        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        encoder_hid_dim: Optional[int] = None,\n"
                ],
                "parent_version_range": {
                    "start": 141,
                    "end": 141
                },
                "child_version_range": {
                    "start": 143,
                    "end": 144
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "UNet2DConditionModel",
                        "signature": "class UNet2DConditionModel(ModelMixin, ConfigMixin, UNet2DConditionLoadersMixin):",
                        "at_line": 52
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(\n        self,\n        sample_size: Optional[int] = None,\n        in_channels: int = 4,\n        out_channels: int = 4,\n        center_input_sample: bool = False,\n        flip_sin_to_cos: bool = True,\n        freq_shift: int = 0,\n        down_block_types: Tuple[str] = (\n            \"CrossAttnDownBlock2D\",\n            \"CrossAttnDownBlock2D\",\n            \"CrossAttnDownBlock2D\",\n            \"DownBlock2D\",\n        ),\n        mid_block_type: Optional[str] = \"UNetMidBlock2DCrossAttn\",\n        up_block_types: Tuple[str] = (\"UpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\"),\n        only_cross_attention: Union[bool, Tuple[bool]] = False,\n        block_out_channels: Tuple[int] = (320, 640, 1280, 1280),\n        layers_per_block: Union[int, Tuple[int]] = 2,\n        downsample_padding: int = 1,\n        mid_block_scale_factor: float = 1,\n        act_fn: str = \"silu\",\n        norm_num_groups: Optional[int] = 32,\n        norm_eps: float = 1e-5,\n        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n        attention_head_dim: Union[int, Tuple[int]] = 8,\n        dual_cross_attention: bool = False,\n        use_linear_projection: bool = False,\n        class_embed_type: Optional[str] = None,\n        num_class_embeds: Optional[int] = None,\n        upcast_attention: bool = False,\n        resnet_time_scale_shift: str = \"default\",\n        resnet_skip_time_act: bool = False,\n        resnet_out_scale_factor: int = 1.0,\n        time_embedding_type: str = \"positional\",\n        timestep_post_act: Optional[str] = None,\n        time_cond_proj_dim: Optional[int] = None,\n        conv_in_kernel: int = 3,\n        conv_out_kernel: int = 3,\n        projection_class_embeddings_input_dim: Optional[int] = None,\n        class_embeddings_concat: bool = False,\n    ):",
                        "at_line": 116
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: src/diffusers/models/unet_2d_condition.py\nCode:\n           class UNet2DConditionModel(ModelMixin, ConfigMixin, UNet2DConditionLoadersMixin):\n               ...\n               def __init__(\n        self,\n        sample_size: Optional[int] = None,\n        in_channels: int = 4,\n        out_channels: int = 4,\n        center_input_sample: bool = False,\n        flip_sin_to_cos: bool = True,\n        freq_shift: int = 0,\n        down_block_types: Tuple[str] = (\n            \"CrossAttnDownBlock2D\",\n            \"CrossAttnDownBlock2D\",\n            \"CrossAttnDownBlock2D\",\n            \"DownBlock2D\",\n        ),\n        mid_block_type: Optional[str] = \"UNetMidBlock2DCrossAttn\",\n        up_block_types: Tuple[str] = (\"UpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\"),\n        only_cross_attention: Union[bool, Tuple[bool]] = False,\n        block_out_channels: Tuple[int] = (320, 640, 1280, 1280),\n        layers_per_block: Union[int, Tuple[int]] = 2,\n        downsample_padding: int = 1,\n        mid_block_scale_factor: float = 1,\n        act_fn: str = \"silu\",\n        norm_num_groups: Optional[int] = 32,\n        norm_eps: float = 1e-5,\n        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n        attention_head_dim: Union[int, Tuple[int]] = 8,\n        dual_cross_attention: bool = False,\n        use_linear_projection: bool = False,\n        class_embed_type: Optional[str] = None,\n        num_class_embeds: Optional[int] = None,\n        upcast_attention: bool = False,\n        resnet_time_scale_shift: str = \"default\",\n        resnet_skip_time_act: bool = False,\n        resnet_out_scale_factor: int = 1.0,\n        time_embedding_type: str = \"positional\",\n        timestep_post_act: Optional[str] = None,\n        time_cond_proj_dim: Optional[int] = None,\n        conv_in_kernel: int = 3,\n        conv_out_kernel: int = 3,\n        projection_class_embeddings_input_dim: Optional[int] = None,\n        class_embeddings_concat: bool = False,\n    ):\n                   ...\n138 140            norm_num_groups: Optional[int] = 32,\n139 141            norm_eps: float = 1e-5,\n140 142            cross_attention_dim: Union[int, Tuple[int]] = 1280,\n    143  +         encoder_hid_dim: Optional[int] = None,\n141 144            attention_head_dim: Union[int, Tuple[int]] = 8,\n142 145            dual_cross_attention: bool = False,\n143 146            use_linear_projection: bool = False,\n         ...\n",
                "file_path": "src/diffusers/models/unet_2d_condition.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Optional",
                    "encoder_hid_dim",
                    "int"
                ],
                "prefix": [
                    "        norm_num_groups: Optional[int] = 32,\n",
                    "        norm_eps: float = 1e-5,\n",
                    "        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n"
                ],
                "suffix": [
                    "        attention_head_dim: Union[int, Tuple[int]] = 8,\n",
                    "        dual_cross_attention: bool = False,\n",
                    "        use_linear_projection: bool = False,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "encoder_hid_dim",
                            "position": {
                                "start": {
                                    "line": 143,
                                    "column": 8
                                },
                                "end": {
                                    "line": 143,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/diffusers/src/diffusers/models/unet_2d_condition.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "encoder_hid_dim",
                            "position": {
                                "start": {
                                    "line": 143,
                                    "column": 8
                                },
                                "end": {
                                    "line": 143,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/diffusers/src/diffusers/models/unet_2d_condition.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    5
                ]
            },
            [
                "        attention_head_dim: Union[int, Tuple[int]] = 8,\n",
                "        dual_cross_attention: bool = False,\n",
                "        use_linear_projection: bool = False,\n",
                "        class_embed_type: Optional[str] = None,\n",
                "        num_class_embeds: Optional[int] = None,\n",
                "        upcast_attention: bool = False,\n",
                "        resnet_time_scale_shift: str = \"default\",\n",
                "        resnet_skip_time_act: bool = False,\n",
                "        resnet_out_scale_factor: int = 1.0,\n",
                "        time_embedding_type: str = \"positional\",\n",
                "        timestep_post_act: Optional[str] = None,\n",
                "        time_cond_proj_dim: Optional[int] = None,\n",
                "        conv_in_kernel: int = 3,\n",
                "        conv_out_kernel: int = 3,\n",
                "        projection_class_embeddings_input_dim: Optional[int] = None,\n",
                "        class_embeddings_concat: bool = False,\n",
                "    ):\n",
                "        super().__init__()\n",
                "\n",
                "        self.sample_size = sample_size\n",
                "\n",
                "        # Check inputs\n",
                "        if len(down_block_types) != len(up_block_types):\n",
                "            raise ValueError(\n",
                "                f\"Must provide the same number of `down_block_types` as `up_block_types`. `down_block_types`: {down_block_types}. `up_block_types`: {up_block_types}.\"\n",
                "            )\n",
                "\n",
                "        if len(block_out_channels) != len(down_block_types):\n",
                "            raise ValueError(\n",
                "                f\"Must provide the same number of `block_out_channels` as `down_block_types`. `block_out_channels`: {block_out_channels}. `down_block_types`: {down_block_types}.\"\n",
                "            )\n",
                "\n",
                "        if not isinstance(only_cross_attention, bool) and len(only_cross_attention) != len(down_block_types):\n",
                "            raise ValueError(\n",
                "                f\"Must provide the same number of `only_cross_attention` as `down_block_types`. `only_cross_attention`: {only_cross_attention}. `down_block_types`: {down_block_types}.\"\n",
                "            )\n",
                "\n",
                "        if not isinstance(attention_head_dim, int) and len(attention_head_dim) != len(down_block_types):\n",
                "            raise ValueError(\n",
                "                f\"Must provide the same number of `attention_head_dim` as `down_block_types`. `attention_head_dim`: {attention_head_dim}. `down_block_types`: {down_block_types}.\"\n",
                "            )\n",
                "\n",
                "        if isinstance(cross_attention_dim, list) and len(cross_attention_dim) != len(down_block_types):\n",
                "            raise ValueError(\n",
                "                f\"Must provide the same number of `cross_attention_dim` as `down_block_types`. `cross_attention_dim`: {cross_attention_dim}. `down_block_types`: {down_block_types}.\"\n",
                "            )\n",
                "\n",
                "        if not isinstance(layers_per_block, int) and len(layers_per_block) != len(down_block_types):\n",
                "            raise ValueError(\n",
                "                f\"Must provide the same number of `layers_per_block` as `down_block_types`. `layers_per_block`: {layers_per_block}. `down_block_types`: {down_block_types}.\"\n",
                "            )\n",
                "\n",
                "        # input\n",
                "        conv_in_padding = (conv_in_kernel - 1) // 2\n",
                "        self.conv_in = nn.Conv2d(\n",
                "            in_channels, block_out_channels[0], kernel_size=conv_in_kernel, padding=conv_in_padding\n",
                "        )\n",
                "\n",
                "        # time\n",
                "        if time_embedding_type == \"fourier\":\n",
                "            time_embed_dim = block_out_channels[0] * 2\n",
                "            if time_embed_dim % 2 != 0:\n",
                "                raise ValueError(f\"`time_embed_dim` should be divisible by 2, but is {time_embed_dim}.\")\n",
                "            self.time_proj = GaussianFourierProjection(\n",
                "                time_embed_dim // 2, set_W_to_weight=False, log=False, flip_sin_to_cos=flip_sin_to_cos\n",
                "            )\n",
                "            timestep_input_dim = time_embed_dim\n",
                "        elif time_embedding_type == \"positional\":\n",
                "            time_embed_dim = block_out_channels[0] * 4\n",
                "\n",
                "            self.time_proj = Timesteps(block_out_channels[0], flip_sin_to_cos, freq_shift)\n",
                "            timestep_input_dim = block_out_channels[0]\n",
                "        else:\n",
                "            raise ValueError(\n",
                "                f\"{time_embedding_type} does not exist. Please make sure to use one of `fourier` or `positional`.\"\n",
                "            )\n",
                "\n",
                "        self.time_embedding = TimestepEmbedding(\n",
                "            timestep_input_dim,\n",
                "            time_embed_dim,\n",
                "            act_fn=act_fn,\n",
                "            post_act_fn=timestep_post_act,\n",
                "            cond_proj_dim=time_cond_proj_dim,\n",
                "        )\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        if encoder_hid_dim is not None:\n",
                    "            self.encoder_hid_proj = nn.Linear(encoder_hid_dim, cross_attention_dim)\n",
                    "        else:\n",
                    "            self.encoder_hid_proj = None\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 226,
                    "end": 226
                },
                "child_version_range": {
                    "start": 229,
                    "end": 234
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "UNet2DConditionModel",
                        "signature": "class UNet2DConditionModel(ModelMixin, ConfigMixin, UNet2DConditionLoadersMixin):",
                        "at_line": 52
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(\n        self,\n        sample_size: Optional[int] = None,\n        in_channels: int = 4,\n        out_channels: int = 4,\n        center_input_sample: bool = False,\n        flip_sin_to_cos: bool = True,\n        freq_shift: int = 0,\n        down_block_types: Tuple[str] = (\n            \"CrossAttnDownBlock2D\",\n            \"CrossAttnDownBlock2D\",\n            \"CrossAttnDownBlock2D\",\n            \"DownBlock2D\",\n        ),\n        mid_block_type: Optional[str] = \"UNetMidBlock2DCrossAttn\",\n        up_block_types: Tuple[str] = (\"UpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\"),\n        only_cross_attention: Union[bool, Tuple[bool]] = False,\n        block_out_channels: Tuple[int] = (320, 640, 1280, 1280),\n        layers_per_block: Union[int, Tuple[int]] = 2,\n        downsample_padding: int = 1,\n        mid_block_scale_factor: float = 1,\n        act_fn: str = \"silu\",\n        norm_num_groups: Optional[int] = 32,\n        norm_eps: float = 1e-5,\n        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n        attention_head_dim: Union[int, Tuple[int]] = 8,\n        dual_cross_attention: bool = False,\n        use_linear_projection: bool = False,\n        class_embed_type: Optional[str] = None,\n        num_class_embeds: Optional[int] = None,\n        upcast_attention: bool = False,\n        resnet_time_scale_shift: str = \"default\",\n        resnet_skip_time_act: bool = False,\n        resnet_out_scale_factor: int = 1.0,\n        time_embedding_type: str = \"positional\",\n        timestep_post_act: Optional[str] = None,\n        time_cond_proj_dim: Optional[int] = None,\n        conv_in_kernel: int = 3,\n        conv_out_kernel: int = 3,\n        projection_class_embeddings_input_dim: Optional[int] = None,\n        class_embeddings_concat: bool = False,\n    ):",
                        "at_line": 116
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: src/diffusers/models/unet_2d_condition.py\nCode:\n           class UNet2DConditionModel(ModelMixin, ConfigMixin, UNet2DConditionLoadersMixin):\n               ...\n               def __init__(\n        self,\n        sample_size: Optional[int] = None,\n        in_channels: int = 4,\n        out_channels: int = 4,\n        center_input_sample: bool = False,\n        flip_sin_to_cos: bool = True,\n        freq_shift: int = 0,\n        down_block_types: Tuple[str] = (\n            \"CrossAttnDownBlock2D\",\n            \"CrossAttnDownBlock2D\",\n            \"CrossAttnDownBlock2D\",\n            \"DownBlock2D\",\n        ),\n        mid_block_type: Optional[str] = \"UNetMidBlock2DCrossAttn\",\n        up_block_types: Tuple[str] = (\"UpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\", \"CrossAttnUpBlock2D\"),\n        only_cross_attention: Union[bool, Tuple[bool]] = False,\n        block_out_channels: Tuple[int] = (320, 640, 1280, 1280),\n        layers_per_block: Union[int, Tuple[int]] = 2,\n        downsample_padding: int = 1,\n        mid_block_scale_factor: float = 1,\n        act_fn: str = \"silu\",\n        norm_num_groups: Optional[int] = 32,\n        norm_eps: float = 1e-5,\n        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n        attention_head_dim: Union[int, Tuple[int]] = 8,\n        dual_cross_attention: bool = False,\n        use_linear_projection: bool = False,\n        class_embed_type: Optional[str] = None,\n        num_class_embeds: Optional[int] = None,\n        upcast_attention: bool = False,\n        resnet_time_scale_shift: str = \"default\",\n        resnet_skip_time_act: bool = False,\n        resnet_out_scale_factor: int = 1.0,\n        time_embedding_type: str = \"positional\",\n        timestep_post_act: Optional[str] = None,\n        time_cond_proj_dim: Optional[int] = None,\n        conv_in_kernel: int = 3,\n        conv_out_kernel: int = 3,\n        projection_class_embeddings_input_dim: Optional[int] = None,\n        class_embeddings_concat: bool = False,\n    ):\n                   ...\n223 226                cond_proj_dim=time_cond_proj_dim,\n224 227            )\n225 228    \n    229  +         if encoder_hid_dim is not None:\n    230  +             self.encoder_hid_proj = nn.Linear(encoder_hid_dim, cross_attention_dim)\n    231  +         else:\n    232  +             self.encoder_hid_proj = None\n    233  + \n226 234            # class embedding\n227 235            if class_embed_type is None and num_class_embeds is not None:\n228 236                self.class_embedding = nn.Embedding(num_class_embeds, time_embed_dim)\n         ...\n",
                "file_path": "src/diffusers/models/unet_2d_condition.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Linear",
                    "cross_attention_dim",
                    "encoder_hid_dim",
                    "encoder_hid_proj",
                    "nn",
                    "self"
                ],
                "prefix": [
                    "            cond_proj_dim=time_cond_proj_dim,\n",
                    "        )\n",
                    "\n"
                ],
                "suffix": [
                    "        # class embedding\n",
                    "        if class_embed_type is None and num_class_embeds is not None:\n",
                    "            self.class_embedding = nn.Embedding(num_class_embeds, time_embed_dim)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "encoder_hid_dim",
                            "position": {
                                "start": {
                                    "line": 229,
                                    "column": 11
                                },
                                "end": {
                                    "line": 229,
                                    "column": 26
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/diffusers/src/diffusers/models/unet_2d_condition.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "encoder_hid_dim",
                            "position": {
                                "start": {
                                    "line": 230,
                                    "column": 46
                                },
                                "end": {
                                    "line": 230,
                                    "column": 61
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/diffusers/src/diffusers/models/unet_2d_condition.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    6
                ]
            },
            [
                "        # class embedding\n",
                "        if class_embed_type is None and num_class_embeds is not None:\n",
                "            self.class_embedding = nn.Embedding(num_class_embeds, time_embed_dim)\n",
                "        elif class_embed_type == \"timestep\":\n",
                "            self.class_embedding = TimestepEmbedding(timestep_input_dim, time_embed_dim)\n",
                "        elif class_embed_type == \"identity\":\n",
                "            self.class_embedding = nn.Identity(time_embed_dim, time_embed_dim)\n",
                "        elif class_embed_type == \"projection\":\n",
                "            if projection_class_embeddings_input_dim is None:\n",
                "                raise ValueError(\n",
                "                    \"`class_embed_type`: 'projection' requires `projection_class_embeddings_input_dim` be set\"\n",
                "                )\n",
                "            # The projection `class_embed_type` is the same as the timestep `class_embed_type` except\n",
                "            # 1. the `class_labels` inputs are not first converted to sinusoidal embeddings\n",
                "            # 2. it projects from an arbitrary input dimension.\n",
                "            #\n",
                "            # Note that `TimestepEmbedding` is quite general, being mainly linear layers and activations.\n",
                "            # When used for embedding actual timesteps, the timesteps are first converted to sinusoidal embeddings.\n",
                "            # As a result, `TimestepEmbedding` can be passed arbitrary vectors.\n",
                "            self.class_embedding = TimestepEmbedding(projection_class_embeddings_input_dim, time_embed_dim)\n",
                "        elif class_embed_type == \"simple_projection\":\n",
                "            if projection_class_embeddings_input_dim is None:\n",
                "                raise ValueError(\n",
                "                    \"`class_embed_type`: 'simple_projection' requires `projection_class_embeddings_input_dim` be set\"\n",
                "                )\n",
                "            self.class_embedding = nn.Linear(projection_class_embeddings_input_dim, time_embed_dim)\n",
                "        else:\n",
                "            self.class_embedding = None\n",
                "\n",
                "        self.down_blocks = nn.ModuleList([])\n",
                "        self.up_blocks = nn.ModuleList([])\n",
                "\n",
                "        if isinstance(only_cross_attention, bool):\n",
                "            only_cross_attention = [only_cross_attention] * len(down_block_types)\n",
                "\n",
                "        if isinstance(attention_head_dim, int):\n",
                "            attention_head_dim = (attention_head_dim,) * len(down_block_types)\n",
                "\n",
                "        if isinstance(cross_attention_dim, int):\n",
                "            cross_attention_dim = (cross_attention_dim,) * len(down_block_types)\n",
                "\n",
                "        if isinstance(layers_per_block, int):\n",
                "            layers_per_block = [layers_per_block] * len(down_block_types)\n",
                "\n",
                "        if class_embeddings_concat:\n",
                "            # The time embeddings are concatenated with the class embeddings. The dimension of the\n",
                "            # time embeddings passed to the down, middle, and up blocks is twice the dimension of the\n",
                "            # regular time embeddings\n",
                "            blocks_time_embed_dim = time_embed_dim * 2\n",
                "        else:\n",
                "            blocks_time_embed_dim = time_embed_dim\n",
                "\n",
                "        # down\n",
                "        output_channel = block_out_channels[0]\n",
                "        for i, down_block_type in enumerate(down_block_types):\n",
                "            input_channel = output_channel\n",
                "            output_channel = block_out_channels[i]\n",
                "            is_final_block = i == len(block_out_channels) - 1\n",
                "\n",
                "            down_block = get_down_block(\n",
                "                down_block_type,\n",
                "                num_layers=layers_per_block[i],\n",
                "                in_channels=input_channel,\n",
                "                out_channels=output_channel,\n",
                "                temb_channels=blocks_time_embed_dim,\n",
                "                add_downsample=not is_final_block,\n",
                "                resnet_eps=norm_eps,\n",
                "                resnet_act_fn=act_fn,\n",
                "                resnet_groups=norm_num_groups,\n",
                "                cross_attention_dim=cross_attention_dim[i],\n",
                "                attn_num_head_channels=attention_head_dim[i],\n",
                "                downsample_padding=downsample_padding,\n",
                "                dual_cross_attention=dual_cross_attention,\n",
                "                use_linear_projection=use_linear_projection,\n",
                "                only_cross_attention=only_cross_attention[i],\n",
                "                upcast_attention=upcast_attention,\n",
                "                resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "                resnet_skip_time_act=resnet_skip_time_act,\n",
                "                resnet_out_scale_factor=resnet_out_scale_factor,\n",
                "            )\n",
                "            self.down_blocks.append(down_block)\n",
                "\n",
                "        # mid\n",
                "        if mid_block_type == \"UNetMidBlock2DCrossAttn\":\n",
                "            self.mid_block = UNetMidBlock2DCrossAttn(\n",
                "                in_channels=block_out_channels[-1],\n",
                "                temb_channels=blocks_time_embed_dim,\n",
                "                resnet_eps=norm_eps,\n",
                "                resnet_act_fn=act_fn,\n",
                "                output_scale_factor=mid_block_scale_factor,\n",
                "                resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "                cross_attention_dim=cross_attention_dim[-1],\n",
                "                attn_num_head_channels=attention_head_dim[-1],\n",
                "                resnet_groups=norm_num_groups,\n",
                "                dual_cross_attention=dual_cross_attention,\n",
                "                use_linear_projection=use_linear_projection,\n",
                "                upcast_attention=upcast_attention,\n",
                "            )\n",
                "        elif mid_block_type == \"UNetMidBlock2DSimpleCrossAttn\":\n",
                "            self.mid_block = UNetMidBlock2DSimpleCrossAttn(\n",
                "                in_channels=block_out_channels[-1],\n",
                "                temb_channels=blocks_time_embed_dim,\n",
                "                resnet_eps=norm_eps,\n",
                "                resnet_act_fn=act_fn,\n",
                "                output_scale_factor=mid_block_scale_factor,\n",
                "                cross_attention_dim=cross_attention_dim[-1],\n",
                "                attn_num_head_channels=attention_head_dim[-1],\n",
                "                resnet_groups=norm_num_groups,\n",
                "                resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "                skip_time_act=resnet_skip_time_act,\n",
                "            )\n",
                "        elif mid_block_type is None:\n",
                "            self.mid_block = None\n",
                "        else:\n",
                "            raise ValueError(f\"unknown mid_block_type : {mid_block_type}\")\n",
                "\n",
                "        # count how many layers upsample the images\n",
                "        self.num_upsamplers = 0\n",
                "\n",
                "        # up\n",
                "        reversed_block_out_channels = list(reversed(block_out_channels))\n",
                "        reversed_attention_head_dim = list(reversed(attention_head_dim))\n",
                "        reversed_layers_per_block = list(reversed(layers_per_block))\n",
                "        reversed_cross_attention_dim = list(reversed(cross_attention_dim))\n",
                "        only_cross_attention = list(reversed(only_cross_attention))\n",
                "\n",
                "        output_channel = reversed_block_out_channels[0]\n",
                "        for i, up_block_type in enumerate(up_block_types):\n",
                "            is_final_block = i == len(block_out_channels) - 1\n",
                "\n",
                "            prev_output_channel = output_channel\n",
                "            output_channel = reversed_block_out_channels[i]\n",
                "            input_channel = reversed_block_out_channels[min(i + 1, len(block_out_channels) - 1)]\n",
                "\n",
                "            # add upsample block for all BUT final layer\n",
                "            if not is_final_block:\n",
                "                add_upsample = True\n",
                "                self.num_upsamplers += 1\n",
                "            else:\n",
                "                add_upsample = False\n",
                "\n",
                "            up_block = get_up_block(\n",
                "                up_block_type,\n",
                "                num_layers=reversed_layers_per_block[i] + 1,\n",
                "                in_channels=input_channel,\n",
                "                out_channels=output_channel,\n",
                "                prev_output_channel=prev_output_channel,\n",
                "                temb_channels=blocks_time_embed_dim,\n",
                "                add_upsample=add_upsample,\n",
                "                resnet_eps=norm_eps,\n",
                "                resnet_act_fn=act_fn,\n",
                "                resnet_groups=norm_num_groups,\n",
                "                cross_attention_dim=reversed_cross_attention_dim[i],\n",
                "                attn_num_head_channels=reversed_attention_head_dim[i],\n",
                "                dual_cross_attention=dual_cross_attention,\n",
                "                use_linear_projection=use_linear_projection,\n",
                "                only_cross_attention=only_cross_attention[i],\n",
                "                upcast_attention=upcast_attention,\n",
                "                resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "                resnet_skip_time_act=resnet_skip_time_act,\n",
                "                resnet_out_scale_factor=resnet_out_scale_factor,\n",
                "            )\n",
                "            self.up_blocks.append(up_block)\n",
                "            prev_output_channel = output_channel\n",
                "\n",
                "        # out\n",
                "        if norm_num_groups is not None:\n",
                "            self.conv_norm_out = nn.GroupNorm(\n",
                "                num_channels=block_out_channels[0], num_groups=norm_num_groups, eps=norm_eps\n",
                "            )\n",
                "            self.conv_act = nn.SiLU()\n",
                "        else:\n",
                "            self.conv_norm_out = None\n",
                "            self.conv_act = None\n",
                "\n",
                "        conv_out_padding = (conv_out_kernel - 1) // 2\n",
                "        self.conv_out = nn.Conv2d(\n",
                "            block_out_channels[0], out_channels, kernel_size=conv_out_kernel, padding=conv_out_padding\n",
                "        )\n",
                "\n",
                "    @property\n",
                "    def attn_processors(self) -> Dict[str, AttentionProcessor]:\n",
                "        r\"\"\"\n",
                "        Returns:\n",
                "            `dict` of attention processors: A dictionary containing all attention processors used in the model with\n",
                "            indexed by its weight name.\n",
                "        \"\"\"\n",
                "        # set recursively\n",
                "        processors = {}\n",
                "\n",
                "        def fn_recursive_add_processors(name: str, module: torch.nn.Module, processors: Dict[str, AttentionProcessor]):\n",
                "            if hasattr(module, \"set_processor\"):\n",
                "                processors[f\"{name}.processor\"] = module.processor\n",
                "\n",
                "            for sub_name, child in module.named_children():\n",
                "                fn_recursive_add_processors(f\"{name}.{sub_name}\", child, processors)\n",
                "\n",
                "            return processors\n",
                "\n",
                "        for name, module in self.named_children():\n",
                "            fn_recursive_add_processors(name, module, processors)\n",
                "\n",
                "        return processors\n",
                "\n",
                "    def set_attn_processor(self, processor: Union[AttentionProcessor, Dict[str, AttentionProcessor]]):\n",
                "        r\"\"\"\n",
                "        Parameters:\n",
                "            `processor (`dict` of `AttentionProcessor` or `AttentionProcessor`):\n",
                "                The instantiated processor class or a dictionary of processor classes that will be set as the processor\n",
                "                of **all** `Attention` layers.\n",
                "            In case `processor` is a dict, the key needs to define the path to the corresponding cross attention processor. This is strongly recommended when setting trainable attention processors.:\n",
                "\n",
                "        \"\"\"\n",
                "        count = len(self.attn_processors.keys())\n",
                "\n",
                "        if isinstance(processor, dict) and len(processor) != count:\n",
                "            raise ValueError(\n",
                "                f\"A dict of processors was passed, but the number of processors {len(processor)} does not match the\"\n",
                "                f\" number of attention layers: {count}. Please make sure to pass {count} processor classes.\"\n",
                "            )\n",
                "\n",
                "        def fn_recursive_attn_processor(name: str, module: torch.nn.Module, processor):\n",
                "            if hasattr(module, \"set_processor\"):\n",
                "                if not isinstance(processor, dict):\n",
                "                    module.set_processor(processor)\n",
                "                else:\n",
                "                    module.set_processor(processor.pop(f\"{name}.processor\"))\n",
                "\n",
                "            for sub_name, child in module.named_children():\n",
                "                fn_recursive_attn_processor(f\"{name}.{sub_name}\", child, processor)\n",
                "\n",
                "        for name, module in self.named_children():\n",
                "            fn_recursive_attn_processor(name, module, processor)\n",
                "\n",
                "    def set_default_attn_processor(self):\n",
                "        \"\"\"\n",
                "        Disables custom attention processors and sets the default attention implementation.\n",
                "        \"\"\"\n",
                "        self.set_attn_processor(AttnProcessor())\n",
                "\n",
                "    def set_attention_slice(self, slice_size):\n",
                "        r\"\"\"\n",
                "        Enable sliced attention computation.\n",
                "\n",
                "        When this option is enabled, the attention module will split the input tensor in slices, to compute attention\n",
                "        in several steps. This is useful to save some memory in exchange for a small speed decrease.\n",
                "\n",
                "        Args:\n",
                "            slice_size (`str` or `int` or `list(int)`, *optional*, defaults to `\"auto\"`):\n",
                "                When `\"auto\"`, halves the input to the attention heads, so attention will be computed in two steps. If\n",
                "                `\"max\"`, maximum amount of memory will be saved by running only one slice at a time. If a number is\n",
                "                provided, uses as many slices as `attention_head_dim // slice_size`. In this case, `attention_head_dim`\n",
                "                must be a multiple of `slice_size`.\n",
                "        \"\"\"\n",
                "        sliceable_head_dims = []\n",
                "\n",
                "        def fn_recursive_retrieve_sliceable_dims(module: torch.nn.Module):\n",
                "            if hasattr(module, \"set_attention_slice\"):\n",
                "                sliceable_head_dims.append(module.sliceable_head_dim)\n",
                "\n",
                "            for child in module.children():\n",
                "                fn_recursive_retrieve_sliceable_dims(child)\n",
                "\n",
                "        # retrieve number of attention layers\n",
                "        for module in self.children():\n",
                "            fn_recursive_retrieve_sliceable_dims(module)\n",
                "\n",
                "        num_sliceable_layers = len(sliceable_head_dims)\n",
                "\n",
                "        if slice_size == \"auto\":\n",
                "            # half the attention head size is usually a good trade-off between\n",
                "            # speed and memory\n",
                "            slice_size = [dim // 2 for dim in sliceable_head_dims]\n",
                "        elif slice_size == \"max\":\n",
                "            # make smallest slice possible\n",
                "            slice_size = num_sliceable_layers * [1]\n",
                "\n",
                "        slice_size = num_sliceable_layers * [slice_size] if not isinstance(slice_size, list) else slice_size\n",
                "\n",
                "        if len(slice_size) != len(sliceable_head_dims):\n",
                "            raise ValueError(\n",
                "                f\"You have provided {len(slice_size)}, but {self.config} has {len(sliceable_head_dims)} different\"\n",
                "                f\" attention layers. Make sure to match `len(slice_size)` to be {len(sliceable_head_dims)}.\"\n",
                "            )\n",
                "\n",
                "        for i in range(len(slice_size)):\n",
                "            size = slice_size[i]\n",
                "            dim = sliceable_head_dims[i]\n",
                "            if size is not None and size > dim:\n",
                "                raise ValueError(f\"size {size} has to be smaller or equal to {dim}.\")\n",
                "\n",
                "        # Recursively walk through all the children.\n",
                "        # Any children which exposes the set_attention_slice method\n",
                "        # gets the message\n",
                "        def fn_recursive_set_attention_slice(module: torch.nn.Module, slice_size: List[int]):\n",
                "            if hasattr(module, \"set_attention_slice\"):\n",
                "                module.set_attention_slice(slice_size.pop())\n",
                "\n",
                "            for child in module.children():\n",
                "                fn_recursive_set_attention_slice(child, slice_size)\n",
                "\n",
                "        reversed_slice_size = list(reversed(slice_size))\n",
                "        for module in self.children():\n",
                "            fn_recursive_set_attention_slice(module, reversed_slice_size)\n",
                "\n",
                "    def _set_gradient_checkpointing(self, module, value=False):\n",
                "        if isinstance(module, (CrossAttnDownBlock2D, DownBlock2D, CrossAttnUpBlock2D, UpBlock2D)):\n",
                "            module.gradient_checkpointing = value\n",
                "\n",
                "    def forward(\n",
                "        self,\n",
                "        sample: torch.FloatTensor,\n",
                "        timestep: Union[torch.Tensor, float, int],\n",
                "        encoder_hidden_states: torch.Tensor,\n",
                "        class_labels: Optional[torch.Tensor] = None,\n",
                "        timestep_cond: Optional[torch.Tensor] = None,\n",
                "        attention_mask: Optional[torch.Tensor] = None,\n",
                "        cross_attention_kwargs: Optional[Dict[str, Any]] = None,\n",
                "        down_block_additional_residuals: Optional[Tuple[torch.Tensor]] = None,\n",
                "        mid_block_additional_residual: Optional[torch.Tensor] = None,\n",
                "        return_dict: bool = True,\n",
                "    ) -> Union[UNet2DConditionOutput, Tuple]:\n",
                "        r\"\"\"\n",
                "        Args:\n",
                "            sample (`torch.FloatTensor`): (batch, channel, height, width) noisy inputs tensor\n",
                "            timestep (`torch.FloatTensor` or `float` or `int`): (batch) timesteps\n",
                "            encoder_hidden_states (`torch.FloatTensor`): (batch, sequence_length, feature_dim) encoder hidden states\n",
                "            return_dict (`bool`, *optional*, defaults to `True`):\n",
                "                Whether or not to return a [`models.unet_2d_condition.UNet2DConditionOutput`] instead of a plain tuple.\n",
                "            cross_attention_kwargs (`dict`, *optional*):\n",
                "                A kwargs dictionary that if specified is passed along to the `AttentionProcessor` as defined under\n",
                "                `self.processor` in\n",
                "                [diffusers.cross_attention](https://github.com/huggingface/diffusers/blob/main/src/diffusers/models/cross_attention.py).\n",
                "\n",
                "        Returns:\n",
                "            [`~models.unet_2d_condition.UNet2DConditionOutput`] or `tuple`:\n",
                "            [`~models.unet_2d_condition.UNet2DConditionOutput`] if `return_dict` is True, otherwise a `tuple`. When\n",
                "            returning a tuple, the first element is the sample tensor.\n",
                "        \"\"\"\n",
                "        # By default samples have to be AT least a multiple of the overall upsampling factor.\n",
                "        # The overall upsampling factor is equal to 2 ** (# num of upsampling layers).\n",
                "        # However, the upsampling interpolation output size can be forced to fit any upsampling size\n",
                "        # on the fly if necessary.\n",
                "        default_overall_up_factor = 2**self.num_upsamplers\n",
                "\n",
                "        # upsample size should be forwarded when sample is not a multiple of `default_overall_up_factor`\n",
                "        forward_upsample_size = False\n",
                "        upsample_size = None\n",
                "\n",
                "        if any(s % default_overall_up_factor != 0 for s in sample.shape[-2:]):\n",
                "            logger.info(\"Forward upsample size to force interpolation output size.\")\n",
                "            forward_upsample_size = True\n",
                "\n",
                "        # prepare attention_mask\n",
                "        if attention_mask is not None:\n",
                "            attention_mask = (1 - attention_mask.to(sample.dtype)) * -10000.0\n",
                "            attention_mask = attention_mask.unsqueeze(1)\n",
                "\n",
                "        # 0. center input if necessary\n",
                "        if self.config.center_input_sample:\n",
                "            sample = 2 * sample - 1.0\n",
                "\n",
                "        # 1. time\n",
                "        timesteps = timestep\n",
                "        if not torch.is_tensor(timesteps):\n",
                "            # TODO: this requires sync between CPU and GPU. So try to pass timesteps as tensors if you can\n",
                "            # This would be a good case for the `match` statement (Python 3.10+)\n",
                "            is_mps = sample.device.type == \"mps\"\n",
                "            if isinstance(timestep, float):\n",
                "                dtype = torch.float32 if is_mps else torch.float64\n",
                "            else:\n",
                "                dtype = torch.int32 if is_mps else torch.int64\n",
                "            timesteps = torch.tensor([timesteps], dtype=dtype, device=sample.device)\n",
                "        elif len(timesteps.shape) == 0:\n",
                "            timesteps = timesteps[None].to(sample.device)\n",
                "\n",
                "        # broadcast to batch dimension in a way that's compatible with ONNX/Core ML\n",
                "        timesteps = timesteps.expand(sample.shape[0])\n",
                "\n",
                "        t_emb = self.time_proj(timesteps)\n",
                "\n",
                "        # timesteps does not contain any weights and will always return f32 tensors\n",
                "        # but time_embedding might actually be running in fp16. so we need to cast here.\n",
                "        # there might be better ways to encapsulate this.\n",
                "        t_emb = t_emb.to(dtype=self.dtype)\n",
                "\n",
                "        emb = self.time_embedding(t_emb, timestep_cond)\n",
                "\n",
                "        if self.class_embedding is not None:\n",
                "            if class_labels is None:\n",
                "                raise ValueError(\"class_labels should be provided when num_class_embeds > 0\")\n",
                "\n",
                "            if self.config.class_embed_type == \"timestep\":\n",
                "                class_labels = self.time_proj(class_labels)\n",
                "\n",
                "            class_emb = self.class_embedding(class_labels).to(dtype=self.dtype)\n",
                "\n",
                "            if self.config.class_embeddings_concat:\n",
                "                emb = torch.cat([emb, class_emb], dim=-1)\n",
                "            else:\n",
                "                emb = emb + class_emb\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        if self.encoder_hid_proj is not None:\n",
                    "            encoder_hidden_states = self.encoder_hid_proj(encoder_hidden_states)\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 628,
                    "end": 628
                },
                "child_version_range": {
                    "start": 636,
                    "end": 639
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "UNet2DConditionModel",
                        "signature": "class UNet2DConditionModel(ModelMixin, ConfigMixin, UNet2DConditionLoadersMixin):",
                        "at_line": 52
                    },
                    {
                        "type": "function",
                        "name": "forward",
                        "signature": "def forward(\n        self,\n        sample: torch.FloatTensor,\n        timestep: Union[torch.Tensor, float, int],\n        encoder_hidden_states: torch.Tensor,\n        class_labels: Optional[torch.Tensor] = None,\n        timestep_cond: Optional[torch.Tensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        cross_attention_kwargs: Optional[Dict[str, Any]] = None,\n        down_block_additional_residuals: Optional[Tuple[torch.Tensor]] = None,\n        mid_block_additional_residual: Optional[torch.Tensor] = None,\n        return_dict: bool = True,\n    )->Union[UNet2DConditionOutput, Tuple]:",
                        "at_line": 535
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: src/diffusers/models/unet_2d_condition.py\nCode:\n           class UNet2DConditionModel(ModelMixin, ConfigMixin, UNet2DConditionLoadersMixin):\n               ...\n               def forward(\n        self,\n        sample: torch.FloatTensor,\n        timestep: Union[torch.Tensor, float, int],\n        encoder_hidden_states: torch.Tensor,\n        class_labels: Optional[torch.Tensor] = None,\n        timestep_cond: Optional[torch.Tensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        cross_attention_kwargs: Optional[Dict[str, Any]] = None,\n        down_block_additional_residuals: Optional[Tuple[torch.Tensor]] = None,\n        mid_block_additional_residual: Optional[torch.Tensor] = None,\n        return_dict: bool = True,\n    )->Union[UNet2DConditionOutput, Tuple]:\n                   ...\n625 633                else:\n626 634                    emb = emb + class_emb\n627 635    \n    636  +         if self.encoder_hid_proj is not None:\n    637  +             encoder_hidden_states = self.encoder_hid_proj(encoder_hidden_states)\n    638  + \n628 639            # 2. pre-process\n629 640            sample = self.conv_in(sample)\n630 641    \n         ...\n",
                "file_path": "src/diffusers/models/unet_2d_condition.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "encoder_hid_proj",
                    "encoder_hidden_states",
                    "self"
                ],
                "prefix": [
                    "            else:\n",
                    "                emb = emb + class_emb\n",
                    "\n"
                ],
                "suffix": [
                    "        # 2. pre-process\n",
                    "        sample = self.conv_in(sample)\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    7
                ]
            },
            [
                "        # 2. pre-process\n",
                "        sample = self.conv_in(sample)\n",
                "\n",
                "        # 3. down\n",
                "        down_block_res_samples = (sample,)\n",
                "        for downsample_block in self.down_blocks:\n",
                "            if hasattr(downsample_block, \"has_cross_attention\") and downsample_block.has_cross_attention:\n",
                "                sample, res_samples = downsample_block(\n",
                "                    hidden_states=sample,\n",
                "                    temb=emb,\n",
                "                    encoder_hidden_states=encoder_hidden_states,\n",
                "                    attention_mask=attention_mask,\n",
                "                    cross_attention_kwargs=cross_attention_kwargs,\n",
                "                )\n",
                "            else:\n",
                "                sample, res_samples = downsample_block(hidden_states=sample, temb=emb)\n",
                "\n",
                "            down_block_res_samples += res_samples\n",
                "\n",
                "        if down_block_additional_residuals is not None:\n",
                "            new_down_block_res_samples = ()\n",
                "\n",
                "            for down_block_res_sample, down_block_additional_residual in zip(\n",
                "                down_block_res_samples, down_block_additional_residuals\n",
                "            ):\n",
                "                down_block_res_sample = down_block_res_sample + down_block_additional_residual\n",
                "                new_down_block_res_samples += (down_block_res_sample,)\n",
                "\n",
                "            down_block_res_samples = new_down_block_res_samples\n",
                "\n",
                "        # 4. mid\n",
                "        if self.mid_block is not None:\n",
                "            sample = self.mid_block(\n",
                "                sample,\n",
                "                emb,\n",
                "                encoder_hidden_states=encoder_hidden_states,\n",
                "                attention_mask=attention_mask,\n",
                "                cross_attention_kwargs=cross_attention_kwargs,\n",
                "            )\n",
                "\n",
                "        if mid_block_additional_residual is not None:\n",
                "            sample = sample + mid_block_additional_residual\n",
                "\n",
                "        # 5. up\n",
                "        for i, upsample_block in enumerate(self.up_blocks):\n",
                "            is_final_block = i == len(self.up_blocks) - 1\n",
                "\n",
                "            res_samples = down_block_res_samples[-len(upsample_block.resnets) :]\n",
                "            down_block_res_samples = down_block_res_samples[: -len(upsample_block.resnets)]\n",
                "\n",
                "            # if we have not reached the final block and need to forward the\n",
                "            # upsample size, we do it here\n",
                "            if not is_final_block and forward_upsample_size:\n",
                "                upsample_size = down_block_res_samples[-1].shape[2:]\n",
                "\n",
                "            if hasattr(upsample_block, \"has_cross_attention\") and upsample_block.has_cross_attention:\n",
                "                sample = upsample_block(\n",
                "                    hidden_states=sample,\n",
                "                    temb=emb,\n",
                "                    res_hidden_states_tuple=res_samples,\n",
                "                    encoder_hidden_states=encoder_hidden_states,\n",
                "                    cross_attention_kwargs=cross_attention_kwargs,\n",
                "                    upsample_size=upsample_size,\n",
                "                    attention_mask=attention_mask,\n",
                "                )\n",
                "            else:\n",
                "                sample = upsample_block(\n",
                "                    hidden_states=sample, temb=emb, res_hidden_states_tuple=res_samples, upsample_size=upsample_size\n",
                "                )\n",
                "\n",
                "        # 6. post-process\n",
                "        if self.conv_norm_out:\n",
                "            sample = self.conv_norm_out(sample)\n",
                "            sample = self.conv_act(sample)\n",
                "        sample = self.conv_out(sample)\n",
                "\n",
                "        if not return_dict:\n",
                "            return (sample,)\n",
                "\n",
                "        return UNet2DConditionOutput(sample=sample)"
            ]
        ],
        "src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py": [
            [
                "from typing import Any, Dict, List, Optional, Tuple, Union\n",
                "\n",
                "import numpy as np\n",
                "import torch\n",
                "import torch.nn as nn\n",
                "\n",
                "from ...configuration_utils import ConfigMixin, register_to_config\n",
                "from ...models import ModelMixin\n",
                "from ...models.attention import Attention\n",
                "from ...models.attention_processor import AttentionProcessor, AttnAddedKVProcessor, AttnProcessor\n",
                "from ...models.dual_transformer_2d import DualTransformer2DModel\n",
                "from ...models.embeddings import GaussianFourierProjection, TimestepEmbedding, Timesteps\n",
                "from ...models.transformer_2d import Transformer2DModel\n",
                "from ...models.unet_2d_condition import UNet2DConditionOutput\n",
                "from ...utils import logging\n",
                "\n",
                "\n",
                "logger = logging.get_logger(__name__)  # pylint: disable=invalid-name\n",
                "\n",
                "\n",
                "def get_down_block(\n",
                "    down_block_type,\n",
                "    num_layers,\n",
                "    in_channels,\n",
                "    out_channels,\n",
                "    temb_channels,\n",
                "    add_downsample,\n",
                "    resnet_eps,\n",
                "    resnet_act_fn,\n",
                "    attn_num_head_channels,\n",
                "    resnet_groups=None,\n",
                "    cross_attention_dim=None,\n",
                "    downsample_padding=None,\n",
                "    dual_cross_attention=False,\n",
                "    use_linear_projection=False,\n",
                "    only_cross_attention=False,\n",
                "    upcast_attention=False,\n",
                "    resnet_time_scale_shift=\"default\",\n",
                "):\n",
                "    down_block_type = down_block_type[7:] if down_block_type.startswith(\"UNetRes\") else down_block_type\n",
                "    if down_block_type == \"DownBlockFlat\":\n",
                "        return DownBlockFlat(\n",
                "            num_layers=num_layers,\n",
                "            in_channels=in_channels,\n",
                "            out_channels=out_channels,\n",
                "            temb_channels=temb_channels,\n",
                "            add_downsample=add_downsample,\n",
                "            resnet_eps=resnet_eps,\n",
                "            resnet_act_fn=resnet_act_fn,\n",
                "            resnet_groups=resnet_groups,\n",
                "            downsample_padding=downsample_padding,\n",
                "            resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "        )\n",
                "    elif down_block_type == \"CrossAttnDownBlockFlat\":\n",
                "        if cross_attention_dim is None:\n",
                "            raise ValueError(\"cross_attention_dim must be specified for CrossAttnDownBlockFlat\")\n",
                "        return CrossAttnDownBlockFlat(\n",
                "            num_layers=num_layers,\n",
                "            in_channels=in_channels,\n",
                "            out_channels=out_channels,\n",
                "            temb_channels=temb_channels,\n",
                "            add_downsample=add_downsample,\n",
                "            resnet_eps=resnet_eps,\n",
                "            resnet_act_fn=resnet_act_fn,\n",
                "            resnet_groups=resnet_groups,\n",
                "            downsample_padding=downsample_padding,\n",
                "            cross_attention_dim=cross_attention_dim,\n",
                "            attn_num_head_channels=attn_num_head_channels,\n",
                "            dual_cross_attention=dual_cross_attention,\n",
                "            use_linear_projection=use_linear_projection,\n",
                "            only_cross_attention=only_cross_attention,\n",
                "            resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "        )\n",
                "    raise ValueError(f\"{down_block_type} is not supported.\")\n",
                "\n",
                "\n",
                "def get_up_block(\n",
                "    up_block_type,\n",
                "    num_layers,\n",
                "    in_channels,\n",
                "    out_channels,\n",
                "    prev_output_channel,\n",
                "    temb_channels,\n",
                "    add_upsample,\n",
                "    resnet_eps,\n",
                "    resnet_act_fn,\n",
                "    attn_num_head_channels,\n",
                "    resnet_groups=None,\n",
                "    cross_attention_dim=None,\n",
                "    dual_cross_attention=False,\n",
                "    use_linear_projection=False,\n",
                "    only_cross_attention=False,\n",
                "    upcast_attention=False,\n",
                "    resnet_time_scale_shift=\"default\",\n",
                "):\n",
                "    up_block_type = up_block_type[7:] if up_block_type.startswith(\"UNetRes\") else up_block_type\n",
                "    if up_block_type == \"UpBlockFlat\":\n",
                "        return UpBlockFlat(\n",
                "            num_layers=num_layers,\n",
                "            in_channels=in_channels,\n",
                "            out_channels=out_channels,\n",
                "            prev_output_channel=prev_output_channel,\n",
                "            temb_channels=temb_channels,\n",
                "            add_upsample=add_upsample,\n",
                "            resnet_eps=resnet_eps,\n",
                "            resnet_act_fn=resnet_act_fn,\n",
                "            resnet_groups=resnet_groups,\n",
                "            resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "        )\n",
                "    elif up_block_type == \"CrossAttnUpBlockFlat\":\n",
                "        if cross_attention_dim is None:\n",
                "            raise ValueError(\"cross_attention_dim must be specified for CrossAttnUpBlockFlat\")\n",
                "        return CrossAttnUpBlockFlat(\n",
                "            num_layers=num_layers,\n",
                "            in_channels=in_channels,\n",
                "            out_channels=out_channels,\n",
                "            prev_output_channel=prev_output_channel,\n",
                "            temb_channels=temb_channels,\n",
                "            add_upsample=add_upsample,\n",
                "            resnet_eps=resnet_eps,\n",
                "            resnet_act_fn=resnet_act_fn,\n",
                "            resnet_groups=resnet_groups,\n",
                "            cross_attention_dim=cross_attention_dim,\n",
                "            attn_num_head_channels=attn_num_head_channels,\n",
                "            dual_cross_attention=dual_cross_attention,\n",
                "            use_linear_projection=use_linear_projection,\n",
                "            only_cross_attention=only_cross_attention,\n",
                "            resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "        )\n",
                "    raise ValueError(f\"{up_block_type} is not supported.\")\n",
                "\n",
                "\n",
                "# Copied from diffusers.models.unet_2d_condition.UNet2DConditionModel with UNet2DConditionModel->UNetFlatConditionModel, nn.Conv2d->LinearMultiDim, Block2D->BlockFlat\n",
                "class UNetFlatConditionModel(ModelMixin, ConfigMixin):\n",
                "    r\"\"\"\n",
                "    UNetFlatConditionModel is a conditional 2D UNet model that takes in a noisy sample, conditional state, and a\n",
                "    timestep and returns sample shaped output.\n",
                "\n",
                "    This model inherits from [`ModelMixin`]. Check the superclass documentation for the generic methods the library\n",
                "    implements for all the models (such as downloading or saving, etc.)\n",
                "\n",
                "    Parameters:\n",
                "        sample_size (`int` or `Tuple[int, int]`, *optional*, defaults to `None`):\n",
                "            Height and width of input/output sample.\n",
                "        in_channels (`int`, *optional*, defaults to 4): The number of channels in the input sample.\n",
                "        out_channels (`int`, *optional*, defaults to 4): The number of channels in the output.\n",
                "        center_input_sample (`bool`, *optional*, defaults to `False`): Whether to center the input sample.\n",
                "        flip_sin_to_cos (`bool`, *optional*, defaults to `False`):\n",
                "            Whether to flip the sin to cos in the time embedding.\n",
                "        freq_shift (`int`, *optional*, defaults to 0): The frequency shift to apply to the time embedding.\n",
                "        down_block_types (`Tuple[str]`, *optional*, defaults to `(\"CrossAttnDownBlockFlat\", \"CrossAttnDownBlockFlat\", \"CrossAttnDownBlockFlat\", \"DownBlockFlat\")`):\n",
                "            The tuple of downsample blocks to use.\n",
                "        mid_block_type (`str`, *optional*, defaults to `\"UNetMidBlockFlatCrossAttn\"`):\n",
                "            The mid block type. Choose from `UNetMidBlockFlatCrossAttn` or `UNetMidBlockFlatSimpleCrossAttn`, will skip\n",
                "            the mid block layer if `None`.\n",
                "        up_block_types (`Tuple[str]`, *optional*, defaults to `(\"UpBlockFlat\", \"CrossAttnUpBlockFlat\", \"CrossAttnUpBlockFlat\", \"CrossAttnUpBlockFlat\",)`):\n",
                "            The tuple of upsample blocks to use.\n",
                "        only_cross_attention(`bool` or `Tuple[bool]`, *optional*, default to `False`):\n",
                "            Whether to include self-attention in the basic transformer blocks, see\n",
                "            [`~models.attention.BasicTransformerBlock`].\n",
                "        block_out_channels (`Tuple[int]`, *optional*, defaults to `(320, 640, 1280, 1280)`):\n",
                "            The tuple of output channels for each block.\n",
                "        layers_per_block (`int`, *optional*, defaults to 2): The number of layers per block.\n",
                "        downsample_padding (`int`, *optional*, defaults to 1): The padding to use for the downsampling convolution.\n",
                "        mid_block_scale_factor (`float`, *optional*, defaults to 1.0): The scale factor to use for the mid block.\n",
                "        act_fn (`str`, *optional*, defaults to `\"silu\"`): The activation function to use.\n",
                "        norm_num_groups (`int`, *optional*, defaults to 32): The number of groups to use for the normalization.\n",
                "            If `None`, it will skip the normalization and activation layers in post-processing\n",
                "        norm_eps (`float`, *optional*, defaults to 1e-5): The epsilon to use for the normalization.\n",
                "        cross_attention_dim (`int` or `Tuple[int]`, *optional*, defaults to 1280):\n",
                "            The dimension of the cross attention features.\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        encoder_hid_dim (`int`, *optional*, defaults to None):\n",
                    "            If given, `encoder_hidden_states` will be projected from this dimension to `cross_attention_dim`.\n"
                ],
                "parent_version_range": {
                    "start": 171,
                    "end": 171
                },
                "child_version_range": {
                    "start": 171,
                    "end": 173
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "UNetFlatConditionModel",
                        "signature": "class UNetFlatConditionModel(ModelMixin, ConfigMixin):",
                        "at_line": 133
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py\nCode:\n           class UNetFlatConditionModel(ModelMixin, ConfigMixin):\n               ...\n168 168            norm_eps (`float`, *optional*, defaults to 1e-5): The epsilon to use for the normalization.\n169 169            cross_attention_dim (`int` or `Tuple[int]`, *optional*, defaults to 1280):\n170 170                The dimension of the cross attention features.\n    171  +         encoder_hid_dim (`int`, *optional*, defaults to None):\n    172  +             If given, `encoder_hidden_states` will be projected from this dimension to `cross_attention_dim`.\n171 173            attention_head_dim (`int`, *optional*, defaults to 8): The dimension of the attention heads.\n172 174            resnet_time_scale_shift (`str`, *optional*, defaults to `\"default\"`): Time scale shift config\n173 175                for resnet blocks, see [`~models.resnet.ResnetBlockFlat`]. Choose from `default` or `scale_shift`.\n         ...\n",
                "file_path": "src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "If",
                    "be",
                    "defaults",
                    "dimension",
                    "encoder_hid_dim",
                    "given",
                    "optional",
                    "projected",
                    "this",
                    "to",
                    "will"
                ],
                "prefix": [
                    "        norm_eps (`float`, *optional*, defaults to 1e-5): The epsilon to use for the normalization.\n",
                    "        cross_attention_dim (`int` or `Tuple[int]`, *optional*, defaults to 1280):\n",
                    "            The dimension of the cross attention features.\n"
                ],
                "suffix": [
                    "        attention_head_dim (`int`, *optional*, defaults to 8): The dimension of the attention heads.\n",
                    "        resnet_time_scale_shift (`str`, *optional*, defaults to `\"default\"`): Time scale shift config\n",
                    "            for resnet blocks, see [`~models.resnet.ResnetBlockFlat`]. Choose from `default` or `scale_shift`.\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    0
                ]
            },
            [
                "        attention_head_dim (`int`, *optional*, defaults to 8): The dimension of the attention heads.\n",
                "        resnet_time_scale_shift (`str`, *optional*, defaults to `\"default\"`): Time scale shift config\n",
                "            for resnet blocks, see [`~models.resnet.ResnetBlockFlat`]. Choose from `default` or `scale_shift`.\n",
                "        class_embed_type (`str`, *optional*, defaults to None):\n",
                "            The type of class embedding to use which is ultimately summed with the time embeddings. Choose from `None`,\n",
                "            `\"timestep\"`, `\"identity\"`, `\"projection\"`, or `\"simple_projection\"`.\n",
                "        num_class_embeds (`int`, *optional*, defaults to None):\n",
                "            Input dimension of the learnable embedding matrix to be projected to `time_embed_dim`, when performing\n",
                "            class conditioning with `class_embed_type` equal to `None`.\n",
                "        time_embedding_type (`str`, *optional*, default to `positional`):\n",
                "            The type of position embedding to use for timesteps. Choose from `positional` or `fourier`.\n",
                "        timestep_post_act (`str, *optional*, default to `None`):\n",
                "            The second activation function to use in timestep embedding. Choose from `silu`, `mish` and `gelu`.\n",
                "        time_cond_proj_dim (`int`, *optional*, default to `None`):\n",
                "            The dimension of `cond_proj` layer in timestep embedding.\n",
                "        conv_in_kernel (`int`, *optional*, default to `3`): The kernel size of `conv_in` layer.\n",
                "        conv_out_kernel (`int`, *optional*, default to `3`): The kernel size of `conv_out` layer.\n",
                "        projection_class_embeddings_input_dim (`int`, *optional*): The dimension of the `class_labels` input when\n",
                "            using the \"projection\" `class_embed_type`. Required when using the \"projection\" `class_embed_type`.\n",
                "        class_embeddings_concat (`bool`, *optional*, defaults to `False`): Whether to concatenate the time\n",
                "        embeddings with the class embeddings.\n",
                "    \"\"\"\n",
                "\n",
                "    _supports_gradient_checkpointing = True\n",
                "\n",
                "    @register_to_config\n",
                "    def __init__(\n",
                "        self,\n",
                "        sample_size: Optional[int] = None,\n",
                "        in_channels: int = 4,\n",
                "        out_channels: int = 4,\n",
                "        center_input_sample: bool = False,\n",
                "        flip_sin_to_cos: bool = True,\n",
                "        freq_shift: int = 0,\n",
                "        down_block_types: Tuple[str] = (\n",
                "            \"CrossAttnDownBlockFlat\",\n",
                "            \"CrossAttnDownBlockFlat\",\n",
                "            \"CrossAttnDownBlockFlat\",\n",
                "            \"DownBlockFlat\",\n",
                "        ),\n",
                "        mid_block_type: Optional[str] = \"UNetMidBlockFlatCrossAttn\",\n",
                "        up_block_types: Tuple[str] = (\n",
                "            \"UpBlockFlat\",\n",
                "            \"CrossAttnUpBlockFlat\",\n",
                "            \"CrossAttnUpBlockFlat\",\n",
                "            \"CrossAttnUpBlockFlat\",\n",
                "        ),\n",
                "        only_cross_attention: Union[bool, Tuple[bool]] = False,\n",
                "        block_out_channels: Tuple[int] = (320, 640, 1280, 1280),\n",
                "        layers_per_block: Union[int, Tuple[int]] = 2,\n",
                "        downsample_padding: int = 1,\n",
                "        mid_block_scale_factor: float = 1,\n",
                "        act_fn: str = \"silu\",\n",
                "        norm_num_groups: Optional[int] = 32,\n",
                "        norm_eps: float = 1e-5,\n",
                "        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        encoder_hid_dim: Optional[int] = None,\n"
                ],
                "parent_version_range": {
                    "start": 227,
                    "end": 227
                },
                "child_version_range": {
                    "start": 229,
                    "end": 230
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "UNetFlatConditionModel",
                        "signature": "class UNetFlatConditionModel(ModelMixin, ConfigMixin):",
                        "at_line": 133
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(\n        self,\n        sample_size: Optional[int] = None,\n        in_channels: int = 4,\n        out_channels: int = 4,\n        center_input_sample: bool = False,\n        flip_sin_to_cos: bool = True,\n        freq_shift: int = 0,\n        down_block_types: Tuple[str] = (\n            \"CrossAttnDownBlockFlat\",\n            \"CrossAttnDownBlockFlat\",\n            \"CrossAttnDownBlockFlat\",\n            \"DownBlockFlat\",\n        ),\n        mid_block_type: Optional[str] = \"UNetMidBlockFlatCrossAttn\",\n        up_block_types: Tuple[str] = (\n            \"UpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n        ),\n        only_cross_attention: Union[bool, Tuple[bool]] = False,\n        block_out_channels: Tuple[int] = (320, 640, 1280, 1280),\n        layers_per_block: Union[int, Tuple[int]] = 2,\n        downsample_padding: int = 1,\n        mid_block_scale_factor: float = 1,\n        act_fn: str = \"silu\",\n        norm_num_groups: Optional[int] = 32,\n        norm_eps: float = 1e-5,\n        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n        attention_head_dim: Union[int, Tuple[int]] = 8,\n        dual_cross_attention: bool = False,\n        use_linear_projection: bool = False,\n        class_embed_type: Optional[str] = None,\n        num_class_embeds: Optional[int] = None,\n        upcast_attention: bool = False,\n        resnet_time_scale_shift: str = \"default\",\n        resnet_skip_time_act: bool = False,\n        resnet_out_scale_factor: int = 1.0,\n        time_embedding_type: str = \"positional\",\n        timestep_post_act: Optional[str] = None,\n        time_cond_proj_dim: Optional[int] = None,\n        conv_in_kernel: int = 3,\n        conv_out_kernel: int = 3,\n        projection_class_embeddings_input_dim: Optional[int] = None,\n        class_embeddings_concat: bool = False,\n    ):",
                        "at_line": 197
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py\nCode:\n           class UNetFlatConditionModel(ModelMixin, ConfigMixin):\n               ...\n               def __init__(\n        self,\n        sample_size: Optional[int] = None,\n        in_channels: int = 4,\n        out_channels: int = 4,\n        center_input_sample: bool = False,\n        flip_sin_to_cos: bool = True,\n        freq_shift: int = 0,\n        down_block_types: Tuple[str] = (\n            \"CrossAttnDownBlockFlat\",\n            \"CrossAttnDownBlockFlat\",\n            \"CrossAttnDownBlockFlat\",\n            \"DownBlockFlat\",\n        ),\n        mid_block_type: Optional[str] = \"UNetMidBlockFlatCrossAttn\",\n        up_block_types: Tuple[str] = (\n            \"UpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n        ),\n        only_cross_attention: Union[bool, Tuple[bool]] = False,\n        block_out_channels: Tuple[int] = (320, 640, 1280, 1280),\n        layers_per_block: Union[int, Tuple[int]] = 2,\n        downsample_padding: int = 1,\n        mid_block_scale_factor: float = 1,\n        act_fn: str = \"silu\",\n        norm_num_groups: Optional[int] = 32,\n        norm_eps: float = 1e-5,\n        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n        attention_head_dim: Union[int, Tuple[int]] = 8,\n        dual_cross_attention: bool = False,\n        use_linear_projection: bool = False,\n        class_embed_type: Optional[str] = None,\n        num_class_embeds: Optional[int] = None,\n        upcast_attention: bool = False,\n        resnet_time_scale_shift: str = \"default\",\n        resnet_skip_time_act: bool = False,\n        resnet_out_scale_factor: int = 1.0,\n        time_embedding_type: str = \"positional\",\n        timestep_post_act: Optional[str] = None,\n        time_cond_proj_dim: Optional[int] = None,\n        conv_in_kernel: int = 3,\n        conv_out_kernel: int = 3,\n        projection_class_embeddings_input_dim: Optional[int] = None,\n        class_embeddings_concat: bool = False,\n    ):\n                   ...\n224 226            norm_num_groups: Optional[int] = 32,\n225 227            norm_eps: float = 1e-5,\n226 228            cross_attention_dim: Union[int, Tuple[int]] = 1280,\n    229  +         encoder_hid_dim: Optional[int] = None,\n227 230            attention_head_dim: Union[int, Tuple[int]] = 8,\n228 231            dual_cross_attention: bool = False,\n229 232            use_linear_projection: bool = False,\n         ...\n",
                "file_path": "src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Optional",
                    "encoder_hid_dim",
                    "int"
                ],
                "prefix": [
                    "        norm_num_groups: Optional[int] = 32,\n",
                    "        norm_eps: float = 1e-5,\n",
                    "        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n"
                ],
                "suffix": [
                    "        attention_head_dim: Union[int, Tuple[int]] = 8,\n",
                    "        dual_cross_attention: bool = False,\n",
                    "        use_linear_projection: bool = False,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "encoder_hid_dim",
                            "position": {
                                "start": {
                                    "line": 229,
                                    "column": 8
                                },
                                "end": {
                                    "line": 229,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/diffusers/src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "encoder_hid_dim",
                            "position": {
                                "start": {
                                    "line": 229,
                                    "column": 8
                                },
                                "end": {
                                    "line": 229,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/diffusers/src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    1
                ]
            },
            [
                "        attention_head_dim: Union[int, Tuple[int]] = 8,\n",
                "        dual_cross_attention: bool = False,\n",
                "        use_linear_projection: bool = False,\n",
                "        class_embed_type: Optional[str] = None,\n",
                "        num_class_embeds: Optional[int] = None,\n",
                "        upcast_attention: bool = False,\n",
                "        resnet_time_scale_shift: str = \"default\",\n",
                "        resnet_skip_time_act: bool = False,\n",
                "        resnet_out_scale_factor: int = 1.0,\n",
                "        time_embedding_type: str = \"positional\",\n",
                "        timestep_post_act: Optional[str] = None,\n",
                "        time_cond_proj_dim: Optional[int] = None,\n",
                "        conv_in_kernel: int = 3,\n",
                "        conv_out_kernel: int = 3,\n",
                "        projection_class_embeddings_input_dim: Optional[int] = None,\n",
                "        class_embeddings_concat: bool = False,\n",
                "    ):\n",
                "        super().__init__()\n",
                "\n",
                "        self.sample_size = sample_size\n",
                "\n",
                "        # Check inputs\n",
                "        if len(down_block_types) != len(up_block_types):\n",
                "            raise ValueError(\n",
                "                \"Must provide the same number of `down_block_types` as `up_block_types`. `down_block_types`:\"\n",
                "                f\" {down_block_types}. `up_block_types`: {up_block_types}.\"\n",
                "            )\n",
                "\n",
                "        if len(block_out_channels) != len(down_block_types):\n",
                "            raise ValueError(\n",
                "                \"Must provide the same number of `block_out_channels` as `down_block_types`. `block_out_channels`:\"\n",
                "                f\" {block_out_channels}. `down_block_types`: {down_block_types}.\"\n",
                "            )\n",
                "\n",
                "        if not isinstance(only_cross_attention, bool) and len(only_cross_attention) != len(down_block_types):\n",
                "            raise ValueError(\n",
                "                \"Must provide the same number of `only_cross_attention` as `down_block_types`.\"\n",
                "                f\" `only_cross_attention`: {only_cross_attention}. `down_block_types`: {down_block_types}.\"\n",
                "            )\n",
                "\n",
                "        if not isinstance(attention_head_dim, int) and len(attention_head_dim) != len(down_block_types):\n",
                "            raise ValueError(\n",
                "                \"Must provide the same number of `attention_head_dim` as `down_block_types`. `attention_head_dim`:\"\n",
                "                f\" {attention_head_dim}. `down_block_types`: {down_block_types}.\"\n",
                "            )\n",
                "\n",
                "        if isinstance(cross_attention_dim, list) and len(cross_attention_dim) != len(down_block_types):\n",
                "            raise ValueError(\n",
                "                \"Must provide the same number of `cross_attention_dim` as `down_block_types`. `cross_attention_dim`:\"\n",
                "                f\" {cross_attention_dim}. `down_block_types`: {down_block_types}.\"\n",
                "            )\n",
                "\n",
                "        if not isinstance(layers_per_block, int) and len(layers_per_block) != len(down_block_types):\n",
                "            raise ValueError(\n",
                "                \"Must provide the same number of `layers_per_block` as `down_block_types`. `layers_per_block`:\"\n",
                "                f\" {layers_per_block}. `down_block_types`: {down_block_types}.\"\n",
                "            )\n",
                "\n",
                "        # input\n",
                "        conv_in_padding = (conv_in_kernel - 1) // 2\n",
                "        self.conv_in = LinearMultiDim(\n",
                "            in_channels, block_out_channels[0], kernel_size=conv_in_kernel, padding=conv_in_padding\n",
                "        )\n",
                "\n",
                "        # time\n",
                "        if time_embedding_type == \"fourier\":\n",
                "            time_embed_dim = block_out_channels[0] * 2\n",
                "            if time_embed_dim % 2 != 0:\n",
                "                raise ValueError(f\"`time_embed_dim` should be divisible by 2, but is {time_embed_dim}.\")\n",
                "            self.time_proj = GaussianFourierProjection(\n",
                "                time_embed_dim // 2, set_W_to_weight=False, log=False, flip_sin_to_cos=flip_sin_to_cos\n",
                "            )\n",
                "            timestep_input_dim = time_embed_dim\n",
                "        elif time_embedding_type == \"positional\":\n",
                "            time_embed_dim = block_out_channels[0] * 4\n",
                "\n",
                "            self.time_proj = Timesteps(block_out_channels[0], flip_sin_to_cos, freq_shift)\n",
                "            timestep_input_dim = block_out_channels[0]\n",
                "        else:\n",
                "            raise ValueError(\n",
                "                f\"{time_embedding_type} does not exist. Please make sure to use one of `fourier` or `positional`.\"\n",
                "            )\n",
                "\n",
                "        self.time_embedding = TimestepEmbedding(\n",
                "            timestep_input_dim,\n",
                "            time_embed_dim,\n",
                "            act_fn=act_fn,\n",
                "            post_act_fn=timestep_post_act,\n",
                "            cond_proj_dim=time_cond_proj_dim,\n",
                "        )\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        if encoder_hid_dim is not None:\n",
                    "            self.encoder_hid_proj = nn.Linear(encoder_hid_dim, cross_attention_dim)\n",
                    "        else:\n",
                    "            self.encoder_hid_proj = None\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 318,
                    "end": 318
                },
                "child_version_range": {
                    "start": 321,
                    "end": 326
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "UNetFlatConditionModel",
                        "signature": "class UNetFlatConditionModel(ModelMixin, ConfigMixin):",
                        "at_line": 133
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(\n        self,\n        sample_size: Optional[int] = None,\n        in_channels: int = 4,\n        out_channels: int = 4,\n        center_input_sample: bool = False,\n        flip_sin_to_cos: bool = True,\n        freq_shift: int = 0,\n        down_block_types: Tuple[str] = (\n            \"CrossAttnDownBlockFlat\",\n            \"CrossAttnDownBlockFlat\",\n            \"CrossAttnDownBlockFlat\",\n            \"DownBlockFlat\",\n        ),\n        mid_block_type: Optional[str] = \"UNetMidBlockFlatCrossAttn\",\n        up_block_types: Tuple[str] = (\n            \"UpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n        ),\n        only_cross_attention: Union[bool, Tuple[bool]] = False,\n        block_out_channels: Tuple[int] = (320, 640, 1280, 1280),\n        layers_per_block: Union[int, Tuple[int]] = 2,\n        downsample_padding: int = 1,\n        mid_block_scale_factor: float = 1,\n        act_fn: str = \"silu\",\n        norm_num_groups: Optional[int] = 32,\n        norm_eps: float = 1e-5,\n        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n        attention_head_dim: Union[int, Tuple[int]] = 8,\n        dual_cross_attention: bool = False,\n        use_linear_projection: bool = False,\n        class_embed_type: Optional[str] = None,\n        num_class_embeds: Optional[int] = None,\n        upcast_attention: bool = False,\n        resnet_time_scale_shift: str = \"default\",\n        resnet_skip_time_act: bool = False,\n        resnet_out_scale_factor: int = 1.0,\n        time_embedding_type: str = \"positional\",\n        timestep_post_act: Optional[str] = None,\n        time_cond_proj_dim: Optional[int] = None,\n        conv_in_kernel: int = 3,\n        conv_out_kernel: int = 3,\n        projection_class_embeddings_input_dim: Optional[int] = None,\n        class_embeddings_concat: bool = False,\n    ):",
                        "at_line": 197
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py\nCode:\n           class UNetFlatConditionModel(ModelMixin, ConfigMixin):\n               ...\n               def __init__(\n        self,\n        sample_size: Optional[int] = None,\n        in_channels: int = 4,\n        out_channels: int = 4,\n        center_input_sample: bool = False,\n        flip_sin_to_cos: bool = True,\n        freq_shift: int = 0,\n        down_block_types: Tuple[str] = (\n            \"CrossAttnDownBlockFlat\",\n            \"CrossAttnDownBlockFlat\",\n            \"CrossAttnDownBlockFlat\",\n            \"DownBlockFlat\",\n        ),\n        mid_block_type: Optional[str] = \"UNetMidBlockFlatCrossAttn\",\n        up_block_types: Tuple[str] = (\n            \"UpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n            \"CrossAttnUpBlockFlat\",\n        ),\n        only_cross_attention: Union[bool, Tuple[bool]] = False,\n        block_out_channels: Tuple[int] = (320, 640, 1280, 1280),\n        layers_per_block: Union[int, Tuple[int]] = 2,\n        downsample_padding: int = 1,\n        mid_block_scale_factor: float = 1,\n        act_fn: str = \"silu\",\n        norm_num_groups: Optional[int] = 32,\n        norm_eps: float = 1e-5,\n        cross_attention_dim: Union[int, Tuple[int]] = 1280,\n        attention_head_dim: Union[int, Tuple[int]] = 8,\n        dual_cross_attention: bool = False,\n        use_linear_projection: bool = False,\n        class_embed_type: Optional[str] = None,\n        num_class_embeds: Optional[int] = None,\n        upcast_attention: bool = False,\n        resnet_time_scale_shift: str = \"default\",\n        resnet_skip_time_act: bool = False,\n        resnet_out_scale_factor: int = 1.0,\n        time_embedding_type: str = \"positional\",\n        timestep_post_act: Optional[str] = None,\n        time_cond_proj_dim: Optional[int] = None,\n        conv_in_kernel: int = 3,\n        conv_out_kernel: int = 3,\n        projection_class_embeddings_input_dim: Optional[int] = None,\n        class_embeddings_concat: bool = False,\n    ):\n                   ...\n315 318                cond_proj_dim=time_cond_proj_dim,\n316 319            )\n317 320    \n    321  +         if encoder_hid_dim is not None:\n    322  +             self.encoder_hid_proj = nn.Linear(encoder_hid_dim, cross_attention_dim)\n    323  +         else:\n    324  +             self.encoder_hid_proj = None\n    325  + \n318 326            # class embedding\n319 327            if class_embed_type is None and num_class_embeds is not None:\n320 328                self.class_embedding = nn.Embedding(num_class_embeds, time_embed_dim)\n         ...\n",
                "file_path": "src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Linear",
                    "cross_attention_dim",
                    "encoder_hid_dim",
                    "encoder_hid_proj",
                    "nn",
                    "self"
                ],
                "prefix": [
                    "            cond_proj_dim=time_cond_proj_dim,\n",
                    "        )\n",
                    "\n"
                ],
                "suffix": [
                    "        # class embedding\n",
                    "        if class_embed_type is None and num_class_embeds is not None:\n",
                    "            self.class_embedding = nn.Embedding(num_class_embeds, time_embed_dim)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "encoder_hid_dim",
                            "position": {
                                "start": {
                                    "line": 321,
                                    "column": 11
                                },
                                "end": {
                                    "line": 321,
                                    "column": 26
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/diffusers/src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "encoder_hid_dim",
                            "position": {
                                "start": {
                                    "line": 322,
                                    "column": 46
                                },
                                "end": {
                                    "line": 322,
                                    "column": 61
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/diffusers/src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    2
                ]
            },
            [
                "        # class embedding\n",
                "        if class_embed_type is None and num_class_embeds is not None:\n",
                "            self.class_embedding = nn.Embedding(num_class_embeds, time_embed_dim)\n",
                "        elif class_embed_type == \"timestep\":\n",
                "            self.class_embedding = TimestepEmbedding(timestep_input_dim, time_embed_dim)\n",
                "        elif class_embed_type == \"identity\":\n",
                "            self.class_embedding = nn.Identity(time_embed_dim, time_embed_dim)\n",
                "        elif class_embed_type == \"projection\":\n",
                "            if projection_class_embeddings_input_dim is None:\n",
                "                raise ValueError(\n",
                "                    \"`class_embed_type`: 'projection' requires `projection_class_embeddings_input_dim` be set\"\n",
                "                )\n",
                "            # The projection `class_embed_type` is the same as the timestep `class_embed_type` except\n",
                "            # 1. the `class_labels` inputs are not first converted to sinusoidal embeddings\n",
                "            # 2. it projects from an arbitrary input dimension.\n",
                "            #\n",
                "            # Note that `TimestepEmbedding` is quite general, being mainly linear layers and activations.\n",
                "            # When used for embedding actual timesteps, the timesteps are first converted to sinusoidal embeddings.\n",
                "            # As a result, `TimestepEmbedding` can be passed arbitrary vectors.\n",
                "            self.class_embedding = TimestepEmbedding(projection_class_embeddings_input_dim, time_embed_dim)\n",
                "        elif class_embed_type == \"simple_projection\":\n",
                "            if projection_class_embeddings_input_dim is None:\n",
                "                raise ValueError(\n",
                "                    \"`class_embed_type`: 'simple_projection' requires `projection_class_embeddings_input_dim` be set\"\n",
                "                )\n",
                "            self.class_embedding = nn.Linear(projection_class_embeddings_input_dim, time_embed_dim)\n",
                "        else:\n",
                "            self.class_embedding = None\n",
                "\n",
                "        self.down_blocks = nn.ModuleList([])\n",
                "        self.up_blocks = nn.ModuleList([])\n",
                "\n",
                "        if isinstance(only_cross_attention, bool):\n",
                "            only_cross_attention = [only_cross_attention] * len(down_block_types)\n",
                "\n",
                "        if isinstance(attention_head_dim, int):\n",
                "            attention_head_dim = (attention_head_dim,) * len(down_block_types)\n",
                "\n",
                "        if isinstance(cross_attention_dim, int):\n",
                "            cross_attention_dim = (cross_attention_dim,) * len(down_block_types)\n",
                "\n",
                "        if isinstance(layers_per_block, int):\n",
                "            layers_per_block = [layers_per_block] * len(down_block_types)\n",
                "\n",
                "        if class_embeddings_concat:\n",
                "            # The time embeddings are concatenated with the class embeddings. The dimension of the\n",
                "            # time embeddings passed to the down, middle, and up blocks is twice the dimension of the\n",
                "            # regular time embeddings\n",
                "            blocks_time_embed_dim = time_embed_dim * 2\n",
                "        else:\n",
                "            blocks_time_embed_dim = time_embed_dim\n",
                "\n",
                "        # down\n",
                "        output_channel = block_out_channels[0]\n",
                "        for i, down_block_type in enumerate(down_block_types):\n",
                "            input_channel = output_channel\n",
                "            output_channel = block_out_channels[i]\n",
                "            is_final_block = i == len(block_out_channels) - 1\n",
                "\n",
                "            down_block = get_down_block(\n",
                "                down_block_type,\n",
                "                num_layers=layers_per_block[i],\n",
                "                in_channels=input_channel,\n",
                "                out_channels=output_channel,\n",
                "                temb_channels=blocks_time_embed_dim,\n",
                "                add_downsample=not is_final_block,\n",
                "                resnet_eps=norm_eps,\n",
                "                resnet_act_fn=act_fn,\n",
                "                resnet_groups=norm_num_groups,\n",
                "                cross_attention_dim=cross_attention_dim[i],\n",
                "                attn_num_head_channels=attention_head_dim[i],\n",
                "                downsample_padding=downsample_padding,\n",
                "                dual_cross_attention=dual_cross_attention,\n",
                "                use_linear_projection=use_linear_projection,\n",
                "                only_cross_attention=only_cross_attention[i],\n",
                "                upcast_attention=upcast_attention,\n",
                "                resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "                resnet_skip_time_act=resnet_skip_time_act,\n",
                "                resnet_out_scale_factor=resnet_out_scale_factor,\n",
                "            )\n",
                "            self.down_blocks.append(down_block)\n",
                "\n",
                "        # mid\n",
                "        if mid_block_type == \"UNetMidBlockFlatCrossAttn\":\n",
                "            self.mid_block = UNetMidBlockFlatCrossAttn(\n",
                "                in_channels=block_out_channels[-1],\n",
                "                temb_channels=blocks_time_embed_dim,\n",
                "                resnet_eps=norm_eps,\n",
                "                resnet_act_fn=act_fn,\n",
                "                output_scale_factor=mid_block_scale_factor,\n",
                "                resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "                cross_attention_dim=cross_attention_dim[-1],\n",
                "                attn_num_head_channels=attention_head_dim[-1],\n",
                "                resnet_groups=norm_num_groups,\n",
                "                dual_cross_attention=dual_cross_attention,\n",
                "                use_linear_projection=use_linear_projection,\n",
                "                upcast_attention=upcast_attention,\n",
                "            )\n",
                "        elif mid_block_type == \"UNetMidBlockFlatSimpleCrossAttn\":\n",
                "            self.mid_block = UNetMidBlockFlatSimpleCrossAttn(\n",
                "                in_channels=block_out_channels[-1],\n",
                "                temb_channels=blocks_time_embed_dim,\n",
                "                resnet_eps=norm_eps,\n",
                "                resnet_act_fn=act_fn,\n",
                "                output_scale_factor=mid_block_scale_factor,\n",
                "                cross_attention_dim=cross_attention_dim[-1],\n",
                "                attn_num_head_channels=attention_head_dim[-1],\n",
                "                resnet_groups=norm_num_groups,\n",
                "                resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "                skip_time_act=resnet_skip_time_act,\n",
                "            )\n",
                "        elif mid_block_type is None:\n",
                "            self.mid_block = None\n",
                "        else:\n",
                "            raise ValueError(f\"unknown mid_block_type : {mid_block_type}\")\n",
                "\n",
                "        # count how many layers upsample the images\n",
                "        self.num_upsamplers = 0\n",
                "\n",
                "        # up\n",
                "        reversed_block_out_channels = list(reversed(block_out_channels))\n",
                "        reversed_attention_head_dim = list(reversed(attention_head_dim))\n",
                "        reversed_layers_per_block = list(reversed(layers_per_block))\n",
                "        reversed_cross_attention_dim = list(reversed(cross_attention_dim))\n",
                "        only_cross_attention = list(reversed(only_cross_attention))\n",
                "\n",
                "        output_channel = reversed_block_out_channels[0]\n",
                "        for i, up_block_type in enumerate(up_block_types):\n",
                "            is_final_block = i == len(block_out_channels) - 1\n",
                "\n",
                "            prev_output_channel = output_channel\n",
                "            output_channel = reversed_block_out_channels[i]\n",
                "            input_channel = reversed_block_out_channels[min(i + 1, len(block_out_channels) - 1)]\n",
                "\n",
                "            # add upsample block for all BUT final layer\n",
                "            if not is_final_block:\n",
                "                add_upsample = True\n",
                "                self.num_upsamplers += 1\n",
                "            else:\n",
                "                add_upsample = False\n",
                "\n",
                "            up_block = get_up_block(\n",
                "                up_block_type,\n",
                "                num_layers=reversed_layers_per_block[i] + 1,\n",
                "                in_channels=input_channel,\n",
                "                out_channels=output_channel,\n",
                "                prev_output_channel=prev_output_channel,\n",
                "                temb_channels=blocks_time_embed_dim,\n",
                "                add_upsample=add_upsample,\n",
                "                resnet_eps=norm_eps,\n",
                "                resnet_act_fn=act_fn,\n",
                "                resnet_groups=norm_num_groups,\n",
                "                cross_attention_dim=reversed_cross_attention_dim[i],\n",
                "                attn_num_head_channels=reversed_attention_head_dim[i],\n",
                "                dual_cross_attention=dual_cross_attention,\n",
                "                use_linear_projection=use_linear_projection,\n",
                "                only_cross_attention=only_cross_attention[i],\n",
                "                upcast_attention=upcast_attention,\n",
                "                resnet_time_scale_shift=resnet_time_scale_shift,\n",
                "                resnet_skip_time_act=resnet_skip_time_act,\n",
                "                resnet_out_scale_factor=resnet_out_scale_factor,\n",
                "            )\n",
                "            self.up_blocks.append(up_block)\n",
                "            prev_output_channel = output_channel\n",
                "\n",
                "        # out\n",
                "        if norm_num_groups is not None:\n",
                "            self.conv_norm_out = nn.GroupNorm(\n",
                "                num_channels=block_out_channels[0], num_groups=norm_num_groups, eps=norm_eps\n",
                "            )\n",
                "            self.conv_act = nn.SiLU()\n",
                "        else:\n",
                "            self.conv_norm_out = None\n",
                "            self.conv_act = None\n",
                "\n",
                "        conv_out_padding = (conv_out_kernel - 1) // 2\n",
                "        self.conv_out = LinearMultiDim(\n",
                "            block_out_channels[0], out_channels, kernel_size=conv_out_kernel, padding=conv_out_padding\n",
                "        )\n",
                "\n",
                "    @property\n",
                "    def attn_processors(self) -> Dict[str, AttentionProcessor]:\n",
                "        r\"\"\"\n",
                "        Returns:\n",
                "            `dict` of attention processors: A dictionary containing all attention processors used in the model with\n",
                "            indexed by its weight name.\n",
                "        \"\"\"\n",
                "        # set recursively\n",
                "        processors = {}\n",
                "\n",
                "        def fn_recursive_add_processors(name: str, module: torch.nn.Module, processors: Dict[str, AttentionProcessor]):\n",
                "            if hasattr(module, \"set_processor\"):\n",
                "                processors[f\"{name}.processor\"] = module.processor\n",
                "\n",
                "            for sub_name, child in module.named_children():\n",
                "                fn_recursive_add_processors(f\"{name}.{sub_name}\", child, processors)\n",
                "\n",
                "            return processors\n",
                "\n",
                "        for name, module in self.named_children():\n",
                "            fn_recursive_add_processors(name, module, processors)\n",
                "\n",
                "        return processors\n",
                "\n",
                "    def set_attn_processor(self, processor: Union[AttentionProcessor, Dict[str, AttentionProcessor]]):\n",
                "        r\"\"\"\n",
                "        Parameters:\n",
                "            `processor (`dict` of `AttentionProcessor` or `AttentionProcessor`):\n",
                "                The instantiated processor class or a dictionary of processor classes that will be set as the processor\n",
                "                of **all** `Attention` layers.\n",
                "            In case `processor` is a dict, the key needs to define the path to the corresponding cross attention processor. This is strongly recommended when setting trainable attention processors.:\n",
                "\n",
                "        \"\"\"\n",
                "        count = len(self.attn_processors.keys())\n",
                "\n",
                "        if isinstance(processor, dict) and len(processor) != count:\n",
                "            raise ValueError(\n",
                "                f\"A dict of processors was passed, but the number of processors {len(processor)} does not match the\"\n",
                "                f\" number of attention layers: {count}. Please make sure to pass {count} processor classes.\"\n",
                "            )\n",
                "\n",
                "        def fn_recursive_attn_processor(name: str, module: torch.nn.Module, processor):\n",
                "            if hasattr(module, \"set_processor\"):\n",
                "                if not isinstance(processor, dict):\n",
                "                    module.set_processor(processor)\n",
                "                else:\n",
                "                    module.set_processor(processor.pop(f\"{name}.processor\"))\n",
                "\n",
                "            for sub_name, child in module.named_children():\n",
                "                fn_recursive_attn_processor(f\"{name}.{sub_name}\", child, processor)\n",
                "\n",
                "        for name, module in self.named_children():\n",
                "            fn_recursive_attn_processor(name, module, processor)\n",
                "\n",
                "    def set_default_attn_processor(self):\n",
                "        \"\"\"\n",
                "        Disables custom attention processors and sets the default attention implementation.\n",
                "        \"\"\"\n",
                "        self.set_attn_processor(AttnProcessor())\n",
                "\n",
                "    def set_attention_slice(self, slice_size):\n",
                "        r\"\"\"\n",
                "        Enable sliced attention computation.\n",
                "\n",
                "        When this option is enabled, the attention module will split the input tensor in slices, to compute attention\n",
                "        in several steps. This is useful to save some memory in exchange for a small speed decrease.\n",
                "\n",
                "        Args:\n",
                "            slice_size (`str` or `int` or `list(int)`, *optional*, defaults to `\"auto\"`):\n",
                "                When `\"auto\"`, halves the input to the attention heads, so attention will be computed in two steps. If\n",
                "                `\"max\"`, maximum amount of memory will be saved by running only one slice at a time. If a number is\n",
                "                provided, uses as many slices as `attention_head_dim // slice_size`. In this case, `attention_head_dim`\n",
                "                must be a multiple of `slice_size`.\n",
                "        \"\"\"\n",
                "        sliceable_head_dims = []\n",
                "\n",
                "        def fn_recursive_retrieve_sliceable_dims(module: torch.nn.Module):\n",
                "            if hasattr(module, \"set_attention_slice\"):\n",
                "                sliceable_head_dims.append(module.sliceable_head_dim)\n",
                "\n",
                "            for child in module.children():\n",
                "                fn_recursive_retrieve_sliceable_dims(child)\n",
                "\n",
                "        # retrieve number of attention layers\n",
                "        for module in self.children():\n",
                "            fn_recursive_retrieve_sliceable_dims(module)\n",
                "\n",
                "        num_sliceable_layers = len(sliceable_head_dims)\n",
                "\n",
                "        if slice_size == \"auto\":\n",
                "            # half the attention head size is usually a good trade-off between\n",
                "            # speed and memory\n",
                "            slice_size = [dim // 2 for dim in sliceable_head_dims]\n",
                "        elif slice_size == \"max\":\n",
                "            # make smallest slice possible\n",
                "            slice_size = num_sliceable_layers * [1]\n",
                "\n",
                "        slice_size = num_sliceable_layers * [slice_size] if not isinstance(slice_size, list) else slice_size\n",
                "\n",
                "        if len(slice_size) != len(sliceable_head_dims):\n",
                "            raise ValueError(\n",
                "                f\"You have provided {len(slice_size)}, but {self.config} has {len(sliceable_head_dims)} different\"\n",
                "                f\" attention layers. Make sure to match `len(slice_size)` to be {len(sliceable_head_dims)}.\"\n",
                "            )\n",
                "\n",
                "        for i in range(len(slice_size)):\n",
                "            size = slice_size[i]\n",
                "            dim = sliceable_head_dims[i]\n",
                "            if size is not None and size > dim:\n",
                "                raise ValueError(f\"size {size} has to be smaller or equal to {dim}.\")\n",
                "\n",
                "        # Recursively walk through all the children.\n",
                "        # Any children which exposes the set_attention_slice method\n",
                "        # gets the message\n",
                "        def fn_recursive_set_attention_slice(module: torch.nn.Module, slice_size: List[int]):\n",
                "            if hasattr(module, \"set_attention_slice\"):\n",
                "                module.set_attention_slice(slice_size.pop())\n",
                "\n",
                "            for child in module.children():\n",
                "                fn_recursive_set_attention_slice(child, slice_size)\n",
                "\n",
                "        reversed_slice_size = list(reversed(slice_size))\n",
                "        for module in self.children():\n",
                "            fn_recursive_set_attention_slice(module, reversed_slice_size)\n",
                "\n",
                "    def _set_gradient_checkpointing(self, module, value=False):\n",
                "        if isinstance(module, (CrossAttnDownBlockFlat, DownBlockFlat, CrossAttnUpBlockFlat, UpBlockFlat)):\n",
                "            module.gradient_checkpointing = value\n",
                "\n",
                "    def forward(\n",
                "        self,\n",
                "        sample: torch.FloatTensor,\n",
                "        timestep: Union[torch.Tensor, float, int],\n",
                "        encoder_hidden_states: torch.Tensor,\n",
                "        class_labels: Optional[torch.Tensor] = None,\n",
                "        timestep_cond: Optional[torch.Tensor] = None,\n",
                "        attention_mask: Optional[torch.Tensor] = None,\n",
                "        cross_attention_kwargs: Optional[Dict[str, Any]] = None,\n",
                "        down_block_additional_residuals: Optional[Tuple[torch.Tensor]] = None,\n",
                "        mid_block_additional_residual: Optional[torch.Tensor] = None,\n",
                "        return_dict: bool = True,\n",
                "    ) -> Union[UNet2DConditionOutput, Tuple]:\n",
                "        r\"\"\"\n",
                "        Args:\n",
                "            sample (`torch.FloatTensor`): (batch, channel, height, width) noisy inputs tensor\n",
                "            timestep (`torch.FloatTensor` or `float` or `int`): (batch) timesteps\n",
                "            encoder_hidden_states (`torch.FloatTensor`): (batch, sequence_length, feature_dim) encoder hidden states\n",
                "            return_dict (`bool`, *optional*, defaults to `True`):\n",
                "                Whether or not to return a [`models.unet_2d_condition.UNet2DConditionOutput`] instead of a plain tuple.\n",
                "            cross_attention_kwargs (`dict`, *optional*):\n",
                "                A kwargs dictionary that if specified is passed along to the `AttentionProcessor` as defined under\n",
                "                `self.processor` in\n",
                "                [diffusers.cross_attention](https://github.com/huggingface/diffusers/blob/main/src/diffusers/models/cross_attention.py).\n",
                "\n",
                "        Returns:\n",
                "            [`~models.unet_2d_condition.UNet2DConditionOutput`] or `tuple`:\n",
                "            [`~models.unet_2d_condition.UNet2DConditionOutput`] if `return_dict` is True, otherwise a `tuple`. When\n",
                "            returning a tuple, the first element is the sample tensor.\n",
                "        \"\"\"\n",
                "        # By default samples have to be AT least a multiple of the overall upsampling factor.\n",
                "        # The overall upsampling factor is equal to 2 ** (# num of upsampling layers).\n",
                "        # However, the upsampling interpolation output size can be forced to fit any upsampling size\n",
                "        # on the fly if necessary.\n",
                "        default_overall_up_factor = 2**self.num_upsamplers\n",
                "\n",
                "        # upsample size should be forwarded when sample is not a multiple of `default_overall_up_factor`\n",
                "        forward_upsample_size = False\n",
                "        upsample_size = None\n",
                "\n",
                "        if any(s % default_overall_up_factor != 0 for s in sample.shape[-2:]):\n",
                "            logger.info(\"Forward upsample size to force interpolation output size.\")\n",
                "            forward_upsample_size = True\n",
                "\n",
                "        # prepare attention_mask\n",
                "        if attention_mask is not None:\n",
                "            attention_mask = (1 - attention_mask.to(sample.dtype)) * -10000.0\n",
                "            attention_mask = attention_mask.unsqueeze(1)\n",
                "\n",
                "        # 0. center input if necessary\n",
                "        if self.config.center_input_sample:\n",
                "            sample = 2 * sample - 1.0\n",
                "\n",
                "        # 1. time\n",
                "        timesteps = timestep\n",
                "        if not torch.is_tensor(timesteps):\n",
                "            # TODO: this requires sync between CPU and GPU. So try to pass timesteps as tensors if you can\n",
                "            # This would be a good case for the `match` statement (Python 3.10+)\n",
                "            is_mps = sample.device.type == \"mps\"\n",
                "            if isinstance(timestep, float):\n",
                "                dtype = torch.float32 if is_mps else torch.float64\n",
                "            else:\n",
                "                dtype = torch.int32 if is_mps else torch.int64\n",
                "            timesteps = torch.tensor([timesteps], dtype=dtype, device=sample.device)\n",
                "        elif len(timesteps.shape) == 0:\n",
                "            timesteps = timesteps[None].to(sample.device)\n",
                "\n",
                "        # broadcast to batch dimension in a way that's compatible with ONNX/Core ML\n",
                "        timesteps = timesteps.expand(sample.shape[0])\n",
                "\n",
                "        t_emb = self.time_proj(timesteps)\n",
                "\n",
                "        # timesteps does not contain any weights and will always return f32 tensors\n",
                "        # but time_embedding might actually be running in fp16. so we need to cast here.\n",
                "        # there might be better ways to encapsulate this.\n",
                "        t_emb = t_emb.to(dtype=self.dtype)\n",
                "\n",
                "        emb = self.time_embedding(t_emb, timestep_cond)\n",
                "\n",
                "        if self.class_embedding is not None:\n",
                "            if class_labels is None:\n",
                "                raise ValueError(\"class_labels should be provided when num_class_embeds > 0\")\n",
                "\n",
                "            if self.config.class_embed_type == \"timestep\":\n",
                "                class_labels = self.time_proj(class_labels)\n",
                "\n",
                "            class_emb = self.class_embedding(class_labels).to(dtype=self.dtype)\n",
                "\n",
                "            if self.config.class_embeddings_concat:\n",
                "                emb = torch.cat([emb, class_emb], dim=-1)\n",
                "            else:\n",
                "                emb = emb + class_emb\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        if self.encoder_hid_proj is not None:\n",
                    "            encoder_hidden_states = self.encoder_hid_proj(encoder_hidden_states)\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 720,
                    "end": 720
                },
                "child_version_range": {
                    "start": 728,
                    "end": 731
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "UNetFlatConditionModel",
                        "signature": "class UNetFlatConditionModel(ModelMixin, ConfigMixin):",
                        "at_line": 133
                    },
                    {
                        "type": "function",
                        "name": "forward",
                        "signature": "def forward(\n        self,\n        sample: torch.FloatTensor,\n        timestep: Union[torch.Tensor, float, int],\n        encoder_hidden_states: torch.Tensor,\n        class_labels: Optional[torch.Tensor] = None,\n        timestep_cond: Optional[torch.Tensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        cross_attention_kwargs: Optional[Dict[str, Any]] = None,\n        down_block_additional_residuals: Optional[Tuple[torch.Tensor]] = None,\n        mid_block_additional_residual: Optional[torch.Tensor] = None,\n        return_dict: bool = True,\n    )->Union[UNet2DConditionOutput, Tuple]:",
                        "at_line": 627
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py\nCode:\n           class UNetFlatConditionModel(ModelMixin, ConfigMixin):\n               ...\n               def forward(\n        self,\n        sample: torch.FloatTensor,\n        timestep: Union[torch.Tensor, float, int],\n        encoder_hidden_states: torch.Tensor,\n        class_labels: Optional[torch.Tensor] = None,\n        timestep_cond: Optional[torch.Tensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        cross_attention_kwargs: Optional[Dict[str, Any]] = None,\n        down_block_additional_residuals: Optional[Tuple[torch.Tensor]] = None,\n        mid_block_additional_residual: Optional[torch.Tensor] = None,\n        return_dict: bool = True,\n    )->Union[UNet2DConditionOutput, Tuple]:\n                   ...\n717 725                else:\n718 726                    emb = emb + class_emb\n719 727    \n    728  +         if self.encoder_hid_proj is not None:\n    729  +             encoder_hidden_states = self.encoder_hid_proj(encoder_hidden_states)\n    730  + \n720 731            # 2. pre-process\n721 732            sample = self.conv_in(sample)\n722 733    \n         ...\n",
                "file_path": "src/diffusers/pipelines/versatile_diffusion/modeling_text_unet.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "encoder_hid_proj",
                    "encoder_hidden_states",
                    "self"
                ],
                "prefix": [
                    "            else:\n",
                    "                emb = emb + class_emb\n",
                    "\n"
                ],
                "suffix": [
                    "        # 2. pre-process\n",
                    "        sample = self.conv_in(sample)\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    3
                ]
            },
            [
                "        # 2. pre-process\n",
                "        sample = self.conv_in(sample)\n",
                "\n",
                "        # 3. down\n",
                "        down_block_res_samples = (sample,)\n",
                "        for downsample_block in self.down_blocks:\n",
                "            if hasattr(downsample_block, \"has_cross_attention\") and downsample_block.has_cross_attention:\n",
                "                sample, res_samples = downsample_block(\n",
                "                    hidden_states=sample,\n",
                "                    temb=emb,\n",
                "                    encoder_hidden_states=encoder_hidden_states,\n",
                "                    attention_mask=attention_mask,\n",
                "                    cross_attention_kwargs=cross_attention_kwargs,\n",
                "                )\n",
                "            else:\n",
                "                sample, res_samples = downsample_block(hidden_states=sample, temb=emb)\n",
                "\n",
                "            down_block_res_samples += res_samples\n",
                "\n",
                "        if down_block_additional_residuals is not None:\n",
                "            new_down_block_res_samples = ()\n",
                "\n",
                "            for down_block_res_sample, down_block_additional_residual in zip(\n",
                "                down_block_res_samples, down_block_additional_residuals\n",
                "            ):\n",
                "                down_block_res_sample = down_block_res_sample + down_block_additional_residual\n",
                "                new_down_block_res_samples += (down_block_res_sample,)\n",
                "\n",
                "            down_block_res_samples = new_down_block_res_samples\n",
                "\n",
                "        # 4. mid\n",
                "        if self.mid_block is not None:\n",
                "            sample = self.mid_block(\n",
                "                sample,\n",
                "                emb,\n",
                "                encoder_hidden_states=encoder_hidden_states,\n",
                "                attention_mask=attention_mask,\n",
                "                cross_attention_kwargs=cross_attention_kwargs,\n",
                "            )\n",
                "\n",
                "        if mid_block_additional_residual is not None:\n",
                "            sample = sample + mid_block_additional_residual\n",
                "\n",
                "        # 5. up\n",
                "        for i, upsample_block in enumerate(self.up_blocks):\n",
                "            is_final_block = i == len(self.up_blocks) - 1\n",
                "\n",
                "            res_samples = down_block_res_samples[-len(upsample_block.resnets) :]\n",
                "            down_block_res_samples = down_block_res_samples[: -len(upsample_block.resnets)]\n",
                "\n",
                "            # if we have not reached the final block and need to forward the\n",
                "            # upsample size, we do it here\n",
                "            if not is_final_block and forward_upsample_size:\n",
                "                upsample_size = down_block_res_samples[-1].shape[2:]\n",
                "\n",
                "            if hasattr(upsample_block, \"has_cross_attention\") and upsample_block.has_cross_attention:\n",
                "                sample = upsample_block(\n",
                "                    hidden_states=sample,\n",
                "                    temb=emb,\n",
                "                    res_hidden_states_tuple=res_samples,\n",
                "                    encoder_hidden_states=encoder_hidden_states,\n",
                "                    cross_attention_kwargs=cross_attention_kwargs,\n",
                "                    upsample_size=upsample_size,\n",
                "                    attention_mask=attention_mask,\n",
                "                )\n",
                "            else:\n",
                "                sample = upsample_block(\n",
                "                    hidden_states=sample, temb=emb, res_hidden_states_tuple=res_samples, upsample_size=upsample_size\n",
                "                )\n",
                "\n",
                "        # 6. post-process\n",
                "        if self.conv_norm_out:\n",
                "            sample = self.conv_norm_out(sample)\n",
                "            sample = self.conv_act(sample)\n",
                "        sample = self.conv_out(sample)\n",
                "\n",
                "        if not return_dict:\n",
                "            return (sample,)\n",
                "\n",
                "        return UNet2DConditionOutput(sample=sample)\n",
                "\n",
                "\n",
                "class LinearMultiDim(nn.Linear):\n",
                "    def __init__(self, in_features, out_features=None, second_dim=4, *args, **kwargs):\n",
                "        in_features = [in_features, second_dim, 1] if isinstance(in_features, int) else list(in_features)\n",
                "        if out_features is None:\n",
                "            out_features = in_features\n",
                "        out_features = [out_features, second_dim, 1] if isinstance(out_features, int) else list(out_features)\n",
                "        self.in_features_multidim = in_features\n",
                "        self.out_features_multidim = out_features\n",
                "        super().__init__(np.array(in_features).prod(), np.array(out_features).prod())\n",
                "\n",
                "    def forward(self, input_tensor, *args, **kwargs):\n",
                "        shape = input_tensor.shape\n",
                "        n_dim = len(self.in_features_multidim)\n",
                "        input_tensor = input_tensor.reshape(*shape[0:-n_dim], self.in_features)\n",
                "        output_tensor = super().forward(input_tensor)\n",
                "        output_tensor = output_tensor.view(*shape[0:-n_dim], *self.out_features_multidim)\n",
                "        return output_tensor\n",
                "\n",
                "\n",
                "class ResnetBlockFlat(nn.Module):\n",
                "    def __init__(\n",
                "        self,\n",
                "        *,\n",
                "        in_channels,\n",
                "        out_channels=None,\n",
                "        dropout=0.0,\n",
                "        temb_channels=512,\n",
                "        groups=32,\n",
                "        groups_out=None,\n",
                "        pre_norm=True,\n",
                "        eps=1e-6,\n",
                "        time_embedding_norm=\"default\",\n",
                "        use_in_shortcut=None,\n",
                "        second_dim=4,\n",
                "        **kwargs,\n",
                "    ):\n",
                "        super().__init__()\n",
                "        self.pre_norm = pre_norm\n",
                "        self.pre_norm = True\n",
                "\n",
                "        in_channels = [in_channels, second_dim, 1] if isinstance(in_channels, int) else list(in_channels)\n",
                "        self.in_channels_prod = np.array(in_channels).prod()\n",
                "        self.channels_multidim = in_channels\n",
                "\n",
                "        if out_channels is not None:\n",
                "            out_channels = [out_channels, second_dim, 1] if isinstance(out_channels, int) else list(out_channels)\n",
                "            out_channels_prod = np.array(out_channels).prod()\n",
                "            self.out_channels_multidim = out_channels\n",
                "        else:\n",
                "            out_channels_prod = self.in_channels_prod\n",
                "            self.out_channels_multidim = self.channels_multidim\n",
                "        self.time_embedding_norm = time_embedding_norm\n",
                "\n",
                "        if groups_out is None:\n",
                "            groups_out = groups\n",
                "\n",
                "        self.norm1 = torch.nn.GroupNorm(num_groups=groups, num_channels=self.in_channels_prod, eps=eps, affine=True)\n",
                "        self.conv1 = torch.nn.Conv2d(self.in_channels_prod, out_channels_prod, kernel_size=1, padding=0)\n",
                "\n",
                "        if temb_channels is not None:\n",
                "            self.time_emb_proj = torch.nn.Linear(temb_channels, out_channels_prod)\n",
                "        else:\n",
                "            self.time_emb_proj = None\n",
                "\n",
                "        self.norm2 = torch.nn.GroupNorm(num_groups=groups_out, num_channels=out_channels_prod, eps=eps, affine=True)\n",
                "        self.dropout = torch.nn.Dropout(dropout)\n",
                "        self.conv2 = torch.nn.Conv2d(out_channels_prod, out_channels_prod, kernel_size=1, padding=0)\n",
                "\n",
                "        self.nonlinearity = nn.SiLU()\n",
                "\n",
                "        self.use_in_shortcut = (\n",
                "            self.in_channels_prod != out_channels_prod if use_in_shortcut is None else use_in_shortcut\n",
                "        )\n",
                "\n",
                "        self.conv_shortcut = None\n",
                "        if self.use_in_shortcut:\n",
                "            self.conv_shortcut = torch.nn.Conv2d(\n",
                "                self.in_channels_prod, out_channels_prod, kernel_size=1, stride=1, padding=0\n",
                "            )\n",
                "\n",
                "    def forward(self, input_tensor, temb):\n",
                "        shape = input_tensor.shape\n",
                "        n_dim = len(self.channels_multidim)\n",
                "        input_tensor = input_tensor.reshape(*shape[0:-n_dim], self.in_channels_prod, 1, 1)\n",
                "        input_tensor = input_tensor.view(-1, self.in_channels_prod, 1, 1)\n",
                "\n",
                "        hidden_states = input_tensor\n",
                "\n",
                "        hidden_states = self.norm1(hidden_states)\n",
                "        hidden_states = self.nonlinearity(hidden_states)\n",
                "        hidden_states = self.conv1(hidden_states)\n",
                "\n",
                "        if temb is not None:\n",
                "            temb = self.time_emb_proj(self.nonlinearity(temb))[:, :, None, None]\n",
                "            hidden_states = hidden_states + temb\n",
                "\n",
                "        hidden_states = self.norm2(hidden_states)\n",
                "        hidden_states = self.nonlinearity(hidden_states)\n",
                "\n",
                "        hidden_states = self.dropout(hidden_states)\n",
                "        hidden_states = self.conv2(hidden_states)\n",
                "\n",
                "        if self.conv_shortcut is not None:\n",
                "            input_tensor = self.conv_shortcut(input_tensor)\n",
                "\n",
                "        output_tensor = input_tensor + hidden_states\n",
                "\n",
                "        output_tensor = output_tensor.view(*shape[0:-n_dim], -1)\n",
                "        output_tensor = output_tensor.view(*shape[0:-n_dim], *self.out_channels_multidim)\n",
                "\n",
                "        return output_tensor\n",
                "\n",
                "\n",
                "# Copied from diffusers.models.unet_2d_blocks.DownBlock2D with DownBlock2D->DownBlockFlat, ResnetBlock2D->ResnetBlockFlat, Downsample2D->LinearMultiDim\n",
                "class DownBlockFlat(nn.Module):\n",
                "    def __init__(\n",
                "        self,\n",
                "        in_channels: int,\n",
                "        out_channels: int,\n",
                "        temb_channels: int,\n",
                "        dropout: float = 0.0,\n",
                "        num_layers: int = 1,\n",
                "        resnet_eps: float = 1e-6,\n",
                "        resnet_time_scale_shift: str = \"default\",\n",
                "        resnet_act_fn: str = \"swish\",\n",
                "        resnet_groups: int = 32,\n",
                "        resnet_pre_norm: bool = True,\n",
                "        output_scale_factor=1.0,\n",
                "        add_downsample=True,\n",
                "        downsample_padding=1,\n",
                "    ):\n",
                "        super().__init__()\n",
                "        resnets = []\n",
                "\n",
                "        for i in range(num_layers):\n",
                "            in_channels = in_channels if i == 0 else out_channels\n",
                "            resnets.append(\n",
                "                ResnetBlockFlat(\n",
                "                    in_channels=in_channels,\n",
                "                    out_channels=out_channels,\n",
                "                    temb_channels=temb_channels,\n",
                "                    eps=resnet_eps,\n",
                "                    groups=resnet_groups,\n",
                "                    dropout=dropout,\n",
                "                    time_embedding_norm=resnet_time_scale_shift,\n",
                "                    non_linearity=resnet_act_fn,\n",
                "                    output_scale_factor=output_scale_factor,\n",
                "                    pre_norm=resnet_pre_norm,\n",
                "                )\n",
                "            )\n",
                "\n",
                "        self.resnets = nn.ModuleList(resnets)\n",
                "\n",
                "        if add_downsample:\n",
                "            self.downsamplers = nn.ModuleList(\n",
                "                [\n",
                "                    LinearMultiDim(\n",
                "                        out_channels, use_conv=True, out_channels=out_channels, padding=downsample_padding, name=\"op\"\n",
                "                    )\n",
                "                ]\n",
                "            )\n",
                "        else:\n",
                "            self.downsamplers = None\n",
                "\n",
                "        self.gradient_checkpointing = False\n",
                "\n",
                "    def forward(self, hidden_states, temb=None):\n",
                "        output_states = ()\n",
                "\n",
                "        for resnet in self.resnets:\n",
                "            if self.training and self.gradient_checkpointing:\n",
                "\n",
                "                def create_custom_forward(module):\n",
                "                    def custom_forward(*inputs):\n",
                "                        return module(*inputs)\n",
                "\n",
                "                    return custom_forward\n",
                "\n",
                "                hidden_states = torch.utils.checkpoint.checkpoint(create_custom_forward(resnet), hidden_states, temb)\n",
                "            else:\n",
                "                hidden_states = resnet(hidden_states, temb)\n",
                "\n",
                "            output_states += (hidden_states,)\n",
                "\n",
                "        if self.downsamplers is not None:\n",
                "            for downsampler in self.downsamplers:\n",
                "                hidden_states = downsampler(hidden_states)\n",
                "\n",
                "            output_states += (hidden_states,)\n",
                "\n",
                "        return hidden_states, output_states\n",
                "\n",
                "\n",
                "# Copied from diffusers.models.unet_2d_blocks.CrossAttnDownBlock2D with CrossAttnDownBlock2D->CrossAttnDownBlockFlat, ResnetBlock2D->ResnetBlockFlat, Downsample2D->LinearMultiDim\n",
                "class CrossAttnDownBlockFlat(nn.Module):\n",
                "    def __init__(\n",
                "        self,\n",
                "        in_channels: int,\n",
                "        out_channels: int,\n",
                "        temb_channels: int,\n",
                "        dropout: float = 0.0,\n",
                "        num_layers: int = 1,\n",
                "        resnet_eps: float = 1e-6,\n",
                "        resnet_time_scale_shift: str = \"default\",\n",
                "        resnet_act_fn: str = \"swish\",\n",
                "        resnet_groups: int = 32,\n",
                "        resnet_pre_norm: bool = True,\n",
                "        attn_num_head_channels=1,\n",
                "        cross_attention_dim=1280,\n",
                "        output_scale_factor=1.0,\n",
                "        downsample_padding=1,\n",
                "        add_downsample=True,\n",
                "        dual_cross_attention=False,\n",
                "        use_linear_projection=False,\n",
                "        only_cross_attention=False,\n",
                "        upcast_attention=False,\n",
                "    ):\n",
                "        super().__init__()\n",
                "        resnets = []\n",
                "        attentions = []\n",
                "\n",
                "        self.has_cross_attention = True\n",
                "        self.attn_num_head_channels = attn_num_head_channels\n",
                "\n",
                "        for i in range(num_layers):\n",
                "            in_channels = in_channels if i == 0 else out_channels\n",
                "            resnets.append(\n",
                "                ResnetBlockFlat(\n",
                "                    in_channels=in_channels,\n",
                "                    out_channels=out_channels,\n",
                "                    temb_channels=temb_channels,\n",
                "                    eps=resnet_eps,\n",
                "                    groups=resnet_groups,\n",
                "                    dropout=dropout,\n",
                "                    time_embedding_norm=resnet_time_scale_shift,\n",
                "                    non_linearity=resnet_act_fn,\n",
                "                    output_scale_factor=output_scale_factor,\n",
                "                    pre_norm=resnet_pre_norm,\n",
                "                )\n",
                "            )\n",
                "            if not dual_cross_attention:\n",
                "                attentions.append(\n",
                "                    Transformer2DModel(\n",
                "                        attn_num_head_channels,\n",
                "                        out_channels // attn_num_head_channels,\n",
                "                        in_channels=out_channels,\n",
                "                        num_layers=1,\n",
                "                        cross_attention_dim=cross_attention_dim,\n",
                "                        norm_num_groups=resnet_groups,\n",
                "                        use_linear_projection=use_linear_projection,\n",
                "                        only_cross_attention=only_cross_attention,\n",
                "                        upcast_attention=upcast_attention,\n",
                "                    )\n",
                "                )\n",
                "            else:\n",
                "                attentions.append(\n",
                "                    DualTransformer2DModel(\n",
                "                        attn_num_head_channels,\n",
                "                        out_channels // attn_num_head_channels,\n",
                "                        in_channels=out_channels,\n",
                "                        num_layers=1,\n",
                "                        cross_attention_dim=cross_attention_dim,\n",
                "                        norm_num_groups=resnet_groups,\n",
                "                    )\n",
                "                )\n",
                "        self.attentions = nn.ModuleList(attentions)\n",
                "        self.resnets = nn.ModuleList(resnets)\n",
                "\n",
                "        if add_downsample:\n",
                "            self.downsamplers = nn.ModuleList(\n",
                "                [\n",
                "                    LinearMultiDim(\n",
                "                        out_channels, use_conv=True, out_channels=out_channels, padding=downsample_padding, name=\"op\"\n",
                "                    )\n",
                "                ]\n",
                "            )\n",
                "        else:\n",
                "            self.downsamplers = None\n",
                "\n",
                "        self.gradient_checkpointing = False\n",
                "\n",
                "    def forward(\n",
                "        self, hidden_states, temb=None, encoder_hidden_states=None, attention_mask=None, cross_attention_kwargs=None\n",
                "    ):\n",
                "        # TODO(Patrick, William) - attention mask is not used\n",
                "        output_states = ()\n",
                "\n",
                "        for resnet, attn in zip(self.resnets, self.attentions):\n",
                "            if self.training and self.gradient_checkpointing:\n",
                "\n",
                "                def create_custom_forward(module, return_dict=None):\n",
                "                    def custom_forward(*inputs):\n",
                "                        if return_dict is not None:\n",
                "                            return module(*inputs, return_dict=return_dict)\n",
                "                        else:\n",
                "                            return module(*inputs)\n",
                "\n",
                "                    return custom_forward\n",
                "\n",
                "                hidden_states = torch.utils.checkpoint.checkpoint(create_custom_forward(resnet), hidden_states, temb)\n",
                "                hidden_states = torch.utils.checkpoint.checkpoint(\n",
                "                    create_custom_forward(attn, return_dict=False),\n",
                "                    hidden_states,\n",
                "                    encoder_hidden_states,\n",
                "                    cross_attention_kwargs,\n",
                "                )[0]\n",
                "            else:\n",
                "                hidden_states = resnet(hidden_states, temb)\n",
                "                hidden_states = attn(\n",
                "                    hidden_states,\n",
                "                    encoder_hidden_states=encoder_hidden_states,\n",
                "                    cross_attention_kwargs=cross_attention_kwargs,\n",
                "                ).sample\n",
                "\n",
                "            output_states += (hidden_states,)\n",
                "\n",
                "        if self.downsamplers is not None:\n",
                "            for downsampler in self.downsamplers:\n",
                "                hidden_states = downsampler(hidden_states)\n",
                "\n",
                "            output_states += (hidden_states,)\n",
                "\n",
                "        return hidden_states, output_states\n",
                "\n",
                "\n",
                "# Copied from diffusers.models.unet_2d_blocks.UpBlock2D with UpBlock2D->UpBlockFlat, ResnetBlock2D->ResnetBlockFlat, Upsample2D->LinearMultiDim\n",
                "class UpBlockFlat(nn.Module):\n",
                "    def __init__(\n",
                "        self,\n",
                "        in_channels: int,\n",
                "        prev_output_channel: int,\n",
                "        out_channels: int,\n",
                "        temb_channels: int,\n",
                "        dropout: float = 0.0,\n",
                "        num_layers: int = 1,\n",
                "        resnet_eps: float = 1e-6,\n",
                "        resnet_time_scale_shift: str = \"default\",\n",
                "        resnet_act_fn: str = \"swish\",\n",
                "        resnet_groups: int = 32,\n",
                "        resnet_pre_norm: bool = True,\n",
                "        output_scale_factor=1.0,\n",
                "        add_upsample=True,\n",
                "    ):\n",
                "        super().__init__()\n",
                "        resnets = []\n",
                "\n",
                "        for i in range(num_layers):\n",
                "            res_skip_channels = in_channels if (i == num_layers - 1) else out_channels\n",
                "            resnet_in_channels = prev_output_channel if i == 0 else out_channels\n",
                "\n",
                "            resnets.append(\n",
                "                ResnetBlockFlat(\n",
                "                    in_channels=resnet_in_channels + res_skip_channels,\n",
                "                    out_channels=out_channels,\n",
                "                    temb_channels=temb_channels,\n",
                "                    eps=resnet_eps,\n",
                "                    groups=resnet_groups,\n",
                "                    dropout=dropout,\n",
                "                    time_embedding_norm=resnet_time_scale_shift,\n",
                "                    non_linearity=resnet_act_fn,\n",
                "                    output_scale_factor=output_scale_factor,\n",
                "                    pre_norm=resnet_pre_norm,\n",
                "                )\n",
                "            )\n",
                "\n",
                "        self.resnets = nn.ModuleList(resnets)\n",
                "\n",
                "        if add_upsample:\n",
                "            self.upsamplers = nn.ModuleList([LinearMultiDim(out_channels, use_conv=True, out_channels=out_channels)])\n",
                "        else:\n",
                "            self.upsamplers = None\n",
                "\n",
                "        self.gradient_checkpointing = False\n",
                "\n",
                "    def forward(self, hidden_states, res_hidden_states_tuple, temb=None, upsample_size=None):\n",
                "        for resnet in self.resnets:\n",
                "            # pop res hidden states\n",
                "            res_hidden_states = res_hidden_states_tuple[-1]\n",
                "            res_hidden_states_tuple = res_hidden_states_tuple[:-1]\n",
                "            hidden_states = torch.cat([hidden_states, res_hidden_states], dim=1)\n",
                "\n",
                "            if self.training and self.gradient_checkpointing:\n",
                "\n",
                "                def create_custom_forward(module):\n",
                "                    def custom_forward(*inputs):\n",
                "                        return module(*inputs)\n",
                "\n",
                "                    return custom_forward\n",
                "\n",
                "                hidden_states = torch.utils.checkpoint.checkpoint(create_custom_forward(resnet), hidden_states, temb)\n",
                "            else:\n",
                "                hidden_states = resnet(hidden_states, temb)\n",
                "\n",
                "        if self.upsamplers is not None:\n",
                "            for upsampler in self.upsamplers:\n",
                "                hidden_states = upsampler(hidden_states, upsample_size)\n",
                "\n",
                "        return hidden_states\n",
                "\n",
                "\n",
                "# Copied from diffusers.models.unet_2d_blocks.CrossAttnUpBlock2D with CrossAttnUpBlock2D->CrossAttnUpBlockFlat, ResnetBlock2D->ResnetBlockFlat, Upsample2D->LinearMultiDim\n",
                "class CrossAttnUpBlockFlat(nn.Module):\n",
                "    def __init__(\n",
                "        self,\n",
                "        in_channels: int,\n",
                "        out_channels: int,\n",
                "        prev_output_channel: int,\n",
                "        temb_channels: int,\n",
                "        dropout: float = 0.0,\n",
                "        num_layers: int = 1,\n",
                "        resnet_eps: float = 1e-6,\n",
                "        resnet_time_scale_shift: str = \"default\",\n",
                "        resnet_act_fn: str = \"swish\",\n",
                "        resnet_groups: int = 32,\n",
                "        resnet_pre_norm: bool = True,\n",
                "        attn_num_head_channels=1,\n",
                "        cross_attention_dim=1280,\n",
                "        output_scale_factor=1.0,\n",
                "        add_upsample=True,\n",
                "        dual_cross_attention=False,\n",
                "        use_linear_projection=False,\n",
                "        only_cross_attention=False,\n",
                "        upcast_attention=False,\n",
                "    ):\n",
                "        super().__init__()\n",
                "        resnets = []\n",
                "        attentions = []\n",
                "\n",
                "        self.has_cross_attention = True\n",
                "        self.attn_num_head_channels = attn_num_head_channels\n",
                "\n",
                "        for i in range(num_layers):\n",
                "            res_skip_channels = in_channels if (i == num_layers - 1) else out_channels\n",
                "            resnet_in_channels = prev_output_channel if i == 0 else out_channels\n",
                "\n",
                "            resnets.append(\n",
                "                ResnetBlockFlat(\n",
                "                    in_channels=resnet_in_channels + res_skip_channels,\n",
                "                    out_channels=out_channels,\n",
                "                    temb_channels=temb_channels,\n",
                "                    eps=resnet_eps,\n",
                "                    groups=resnet_groups,\n",
                "                    dropout=dropout,\n",
                "                    time_embedding_norm=resnet_time_scale_shift,\n",
                "                    non_linearity=resnet_act_fn,\n",
                "                    output_scale_factor=output_scale_factor,\n",
                "                    pre_norm=resnet_pre_norm,\n",
                "                )\n",
                "            )\n",
                "            if not dual_cross_attention:\n",
                "                attentions.append(\n",
                "                    Transformer2DModel(\n",
                "                        attn_num_head_channels,\n",
                "                        out_channels // attn_num_head_channels,\n",
                "                        in_channels=out_channels,\n",
                "                        num_layers=1,\n",
                "                        cross_attention_dim=cross_attention_dim,\n",
                "                        norm_num_groups=resnet_groups,\n",
                "                        use_linear_projection=use_linear_projection,\n",
                "                        only_cross_attention=only_cross_attention,\n",
                "                        upcast_attention=upcast_attention,\n",
                "                    )\n",
                "                )\n",
                "            else:\n",
                "                attentions.append(\n",
                "                    DualTransformer2DModel(\n",
                "                        attn_num_head_channels,\n",
                "                        out_channels // attn_num_head_channels,\n",
                "                        in_channels=out_channels,\n",
                "                        num_layers=1,\n",
                "                        cross_attention_dim=cross_attention_dim,\n",
                "                        norm_num_groups=resnet_groups,\n",
                "                    )\n",
                "                )\n",
                "        self.attentions = nn.ModuleList(attentions)\n",
                "        self.resnets = nn.ModuleList(resnets)\n",
                "\n",
                "        if add_upsample:\n",
                "            self.upsamplers = nn.ModuleList([LinearMultiDim(out_channels, use_conv=True, out_channels=out_channels)])\n",
                "        else:\n",
                "            self.upsamplers = None\n",
                "\n",
                "        self.gradient_checkpointing = False\n",
                "\n",
                "    def forward(\n",
                "        self,\n",
                "        hidden_states,\n",
                "        res_hidden_states_tuple,\n",
                "        temb=None,\n",
                "        encoder_hidden_states=None,\n",
                "        cross_attention_kwargs=None,\n",
                "        upsample_size=None,\n",
                "        attention_mask=None,\n",
                "    ):\n",
                "        # TODO(Patrick, William) - attention mask is not used\n",
                "        for resnet, attn in zip(self.resnets, self.attentions):\n",
                "            # pop res hidden states\n",
                "            res_hidden_states = res_hidden_states_tuple[-1]\n",
                "            res_hidden_states_tuple = res_hidden_states_tuple[:-1]\n",
                "            hidden_states = torch.cat([hidden_states, res_hidden_states], dim=1)\n",
                "\n",
                "            if self.training and self.gradient_checkpointing:\n",
                "\n",
                "                def create_custom_forward(module, return_dict=None):\n",
                "                    def custom_forward(*inputs):\n",
                "                        if return_dict is not None:\n",
                "                            return module(*inputs, return_dict=return_dict)\n",
                "                        else:\n",
                "                            return module(*inputs)\n",
                "\n",
                "                    return custom_forward\n",
                "\n",
                "                hidden_states = torch.utils.checkpoint.checkpoint(create_custom_forward(resnet), hidden_states, temb)\n",
                "                hidden_states = torch.utils.checkpoint.checkpoint(\n",
                "                    create_custom_forward(attn, return_dict=False),\n",
                "                    hidden_states,\n",
                "                    encoder_hidden_states,\n",
                "                    cross_attention_kwargs,\n",
                "                )[0]\n",
                "            else:\n",
                "                hidden_states = resnet(hidden_states, temb)\n",
                "                hidden_states = attn(\n",
                "                    hidden_states,\n",
                "                    encoder_hidden_states=encoder_hidden_states,\n",
                "                    cross_attention_kwargs=cross_attention_kwargs,\n",
                "                ).sample\n",
                "\n",
                "        if self.upsamplers is not None:\n",
                "            for upsampler in self.upsamplers:\n",
                "                hidden_states = upsampler(hidden_states, upsample_size)\n",
                "\n",
                "        return hidden_states\n",
                "\n",
                "\n",
                "# Copied from diffusers.models.unet_2d_blocks.UNetMidBlock2DCrossAttn with UNetMidBlock2DCrossAttn->UNetMidBlockFlatCrossAttn, ResnetBlock2D->ResnetBlockFlat\n",
                "class UNetMidBlockFlatCrossAttn(nn.Module):\n",
                "    def __init__(\n",
                "        self,\n",
                "        in_channels: int,\n",
                "        temb_channels: int,\n",
                "        dropout: float = 0.0,\n",
                "        num_layers: int = 1,\n",
                "        resnet_eps: float = 1e-6,\n",
                "        resnet_time_scale_shift: str = \"default\",\n",
                "        resnet_act_fn: str = \"swish\",\n",
                "        resnet_groups: int = 32,\n",
                "        resnet_pre_norm: bool = True,\n",
                "        attn_num_head_channels=1,\n",
                "        output_scale_factor=1.0,\n",
                "        cross_attention_dim=1280,\n",
                "        dual_cross_attention=False,\n",
                "        use_linear_projection=False,\n",
                "        upcast_attention=False,\n",
                "    ):\n",
                "        super().__init__()\n",
                "\n",
                "        self.has_cross_attention = True\n",
                "        self.attn_num_head_channels = attn_num_head_channels\n",
                "        resnet_groups = resnet_groups if resnet_groups is not None else min(in_channels // 4, 32)\n",
                "\n",
                "        # there is always at least one resnet\n",
                "        resnets = [\n",
                "            ResnetBlockFlat(\n",
                "                in_channels=in_channels,\n",
                "                out_channels=in_channels,\n",
                "                temb_channels=temb_channels,\n",
                "                eps=resnet_eps,\n",
                "                groups=resnet_groups,\n",
                "                dropout=dropout,\n",
                "                time_embedding_norm=resnet_time_scale_shift,\n",
                "                non_linearity=resnet_act_fn,\n",
                "                output_scale_factor=output_scale_factor,\n",
                "                pre_norm=resnet_pre_norm,\n",
                "            )\n",
                "        ]\n",
                "        attentions = []\n",
                "\n",
                "        for _ in range(num_layers):\n",
                "            if not dual_cross_attention:\n",
                "                attentions.append(\n",
                "                    Transformer2DModel(\n",
                "                        attn_num_head_channels,\n",
                "                        in_channels // attn_num_head_channels,\n",
                "                        in_channels=in_channels,\n",
                "                        num_layers=1,\n",
                "                        cross_attention_dim=cross_attention_dim,\n",
                "                        norm_num_groups=resnet_groups,\n",
                "                        use_linear_projection=use_linear_projection,\n",
                "                        upcast_attention=upcast_attention,\n",
                "                    )\n",
                "                )\n",
                "            else:\n",
                "                attentions.append(\n",
                "                    DualTransformer2DModel(\n",
                "                        attn_num_head_channels,\n",
                "                        in_channels // attn_num_head_channels,\n",
                "                        in_channels=in_channels,\n",
                "                        num_layers=1,\n",
                "                        cross_attention_dim=cross_attention_dim,\n",
                "                        norm_num_groups=resnet_groups,\n",
                "                    )\n",
                "                )\n",
                "            resnets.append(\n",
                "                ResnetBlockFlat(\n",
                "                    in_channels=in_channels,\n",
                "                    out_channels=in_channels,\n",
                "                    temb_channels=temb_channels,\n",
                "                    eps=resnet_eps,\n",
                "                    groups=resnet_groups,\n",
                "                    dropout=dropout,\n",
                "                    time_embedding_norm=resnet_time_scale_shift,\n",
                "                    non_linearity=resnet_act_fn,\n",
                "                    output_scale_factor=output_scale_factor,\n",
                "                    pre_norm=resnet_pre_norm,\n",
                "                )\n",
                "            )\n",
                "\n",
                "        self.attentions = nn.ModuleList(attentions)\n",
                "        self.resnets = nn.ModuleList(resnets)\n",
                "\n",
                "    def forward(\n",
                "        self, hidden_states, temb=None, encoder_hidden_states=None, attention_mask=None, cross_attention_kwargs=None\n",
                "    ):\n",
                "        hidden_states = self.resnets[0](hidden_states, temb)\n",
                "        for attn, resnet in zip(self.attentions, self.resnets[1:]):\n",
                "            hidden_states = attn(\n",
                "                hidden_states,\n",
                "                encoder_hidden_states=encoder_hidden_states,\n",
                "                cross_attention_kwargs=cross_attention_kwargs,\n",
                "            ).sample\n",
                "            hidden_states = resnet(hidden_states, temb)\n",
                "\n",
                "        return hidden_states\n",
                "\n",
                "\n",
                "# Copied from diffusers.models.unet_2d_blocks.UNetMidBlock2DSimpleCrossAttn with UNetMidBlock2DSimpleCrossAttn->UNetMidBlockFlatSimpleCrossAttn, ResnetBlock2D->ResnetBlockFlat\n",
                "class UNetMidBlockFlatSimpleCrossAttn(nn.Module):\n",
                "    def __init__(\n",
                "        self,\n",
                "        in_channels: int,\n",
                "        temb_channels: int,\n",
                "        dropout: float = 0.0,\n",
                "        num_layers: int = 1,\n",
                "        resnet_eps: float = 1e-6,\n",
                "        resnet_time_scale_shift: str = \"default\",\n",
                "        resnet_act_fn: str = \"swish\",\n",
                "        resnet_groups: int = 32,\n",
                "        resnet_pre_norm: bool = True,\n",
                "        attn_num_head_channels=1,\n",
                "        output_scale_factor=1.0,\n",
                "        cross_attention_dim=1280,\n",
                "        skip_time_act=False,\n",
                "    ):\n",
                "        super().__init__()\n",
                "\n",
                "        self.has_cross_attention = True\n",
                "\n",
                "        self.attn_num_head_channels = attn_num_head_channels\n",
                "        resnet_groups = resnet_groups if resnet_groups is not None else min(in_channels // 4, 32)\n",
                "\n",
                "        self.num_heads = in_channels // self.attn_num_head_channels\n",
                "\n",
                "        # there is always at least one resnet\n",
                "        resnets = [\n",
                "            ResnetBlockFlat(\n",
                "                in_channels=in_channels,\n",
                "                out_channels=in_channels,\n",
                "                temb_channels=temb_channels,\n",
                "                eps=resnet_eps,\n",
                "                groups=resnet_groups,\n",
                "                dropout=dropout,\n",
                "                time_embedding_norm=resnet_time_scale_shift,\n",
                "                non_linearity=resnet_act_fn,\n",
                "                output_scale_factor=output_scale_factor,\n",
                "                pre_norm=resnet_pre_norm,\n",
                "                skip_time_act=skip_time_act,\n",
                "            )\n",
                "        ]\n",
                "        attentions = []\n",
                "\n",
                "        for _ in range(num_layers):\n",
                "            attentions.append(\n",
                "                Attention(\n",
                "                    query_dim=in_channels,\n",
                "                    cross_attention_dim=in_channels,\n",
                "                    heads=self.num_heads,\n",
                "                    dim_head=attn_num_head_channels,\n",
                "                    added_kv_proj_dim=cross_attention_dim,\n",
                "                    norm_num_groups=resnet_groups,\n",
                "                    bias=True,\n",
                "                    upcast_softmax=True,\n",
                "                    processor=AttnAddedKVProcessor(),\n",
                "                )\n",
                "            )\n",
                "            resnets.append(\n",
                "                ResnetBlockFlat(\n",
                "                    in_channels=in_channels,\n",
                "                    out_channels=in_channels,\n",
                "                    temb_channels=temb_channels,\n",
                "                    eps=resnet_eps,\n",
                "                    groups=resnet_groups,\n",
                "                    dropout=dropout,\n",
                "                    time_embedding_norm=resnet_time_scale_shift,\n",
                "                    non_linearity=resnet_act_fn,\n",
                "                    output_scale_factor=output_scale_factor,\n",
                "                    pre_norm=resnet_pre_norm,\n",
                "                    skip_time_act=skip_time_act,\n",
                "                )\n",
                "            )\n",
                "\n",
                "        self.attentions = nn.ModuleList(attentions)\n",
                "        self.resnets = nn.ModuleList(resnets)\n",
                "\n",
                "    def forward(\n",
                "        self, hidden_states, temb=None, encoder_hidden_states=None, attention_mask=None, cross_attention_kwargs=None\n",
                "    ):\n",
                "        cross_attention_kwargs = cross_attention_kwargs if cross_attention_kwargs is not None else {}\n",
                "        hidden_states = self.resnets[0](hidden_states, temb)\n",
                "        for attn, resnet in zip(self.attentions, self.resnets[1:]):\n",
                "            # attn\n",
                "            hidden_states = attn(\n",
                "                hidden_states,\n",
                "                encoder_hidden_states=encoder_hidden_states,\n",
                "                attention_mask=attention_mask,\n",
                "                **cross_attention_kwargs,\n",
                "            )\n",
                "\n",
                "            # resnet\n",
                "            hidden_states = resnet(hidden_states, temb)\n",
                "\n",
                "        return hidden_states"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "doc sync"
        },
        {
            "edit_hunk_pair": [
                0,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "clone"
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                1,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "clone"
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                2,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "clone"
        },
        {
            "edit_hunk_pair": [
                3,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "clone"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "doc sync"
        },
        {
            "edit_hunk_pair": [
                5,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                6,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        }
    ]
}