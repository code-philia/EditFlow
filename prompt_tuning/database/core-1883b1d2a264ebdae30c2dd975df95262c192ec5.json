{
    "language": "python",
    "commit_url": "https://github.com/home-assistant/core/commit/1883b1d2a264ebdae30c2dd975df95262c192ec5",
    "commit_message": "Add config reloaded events for automation and scene (#34664)",
    "commit_snapshots": {
        "homeassistant/components/automation/__init__.py": [
            [
                "\"\"\"Allow to set up simple automation rules via the config file.\"\"\"\n",
                "import asyncio\n",
                "import importlib\n",
                "import logging\n",
                "from typing import Any, Awaitable, Callable, List, Optional, Set\n",
                "\n",
                "import voluptuous as vol\n",
                "\n",
                "from homeassistant.const import (\n",
                "    ATTR_ENTITY_ID,\n",
                "    ATTR_NAME,\n",
                "    CONF_DEVICE_ID,\n",
                "    CONF_ENTITY_ID,\n",
                "    CONF_ID,\n",
                "    CONF_PLATFORM,\n",
                "    CONF_ZONE,\n",
                "    EVENT_AUTOMATION_TRIGGERED,\n",
                "    EVENT_HOMEASSISTANT_STARTED,\n",
                "    SERVICE_RELOAD,\n",
                "    SERVICE_TOGGLE,\n",
                "    SERVICE_TURN_OFF,\n",
                "    SERVICE_TURN_ON,\n",
                "    STATE_ON,\n",
                ")\n",
                "from homeassistant.core import Context, CoreState, HomeAssistant, callback\n",
                "from homeassistant.exceptions import HomeAssistantError\n",
                "from homeassistant.helpers import condition, extract_domain_configs, script\n",
                "import homeassistant.helpers.config_validation as cv\n",
                "from homeassistant.helpers.entity import ToggleEntity\n",
                "from homeassistant.helpers.entity_component import EntityComponent\n",
                "from homeassistant.helpers.restore_state import RestoreEntity\n",
                "from homeassistant.helpers.service import async_register_admin_service\n",
                "from homeassistant.helpers.typing import TemplateVarsType\n",
                "from homeassistant.loader import bind_hass\n",
                "from homeassistant.util.dt import parse_datetime, utcnow\n",
                "\n",
                "# mypy: allow-untyped-calls, allow-untyped-defs\n",
                "# mypy: no-check-untyped-defs, no-warn-return-any\n",
                "\n",
                "DOMAIN = \"automation\"\n",
                "ENTITY_ID_FORMAT = DOMAIN + \".{}\"\n",
                "\n",
                "GROUP_NAME_ALL_AUTOMATIONS = \"all automations\"\n",
                "\n",
                "CONF_ALIAS = \"alias\"\n",
                "CONF_DESCRIPTION = \"description\"\n",
                "CONF_HIDE_ENTITY = \"hide_entity\"\n",
                "\n",
                "CONF_CONDITION = \"condition\"\n",
                "CONF_ACTION = \"action\"\n",
                "CONF_TRIGGER = \"trigger\"\n",
                "CONF_CONDITION_TYPE = \"condition_type\"\n",
                "CONF_INITIAL_STATE = \"initial_state\"\n",
                "CONF_SKIP_CONDITION = \"skip_condition\"\n",
                "\n",
                "CONDITION_USE_TRIGGER_VALUES = \"use_trigger_values\"\n",
                "CONDITION_TYPE_AND = \"and\"\n",
                "CONDITION_TYPE_NOT = \"not\"\n",
                "CONDITION_TYPE_OR = \"or\"\n",
                "\n",
                "DEFAULT_CONDITION_TYPE = CONDITION_TYPE_AND\n",
                "DEFAULT_INITIAL_STATE = True\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "EVENT_AUTOMATION_RELOADED = \"automation_reloaded\"\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 63,
                    "end": 63
                },
                "child_version_range": {
                    "start": 63,
                    "end": 65
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 0,
                "hunk_diff": "File: homeassistant/components/automation/__init__.py\nCode:\n  ...\n60 60    DEFAULT_CONDITION_TYPE = CONDITION_TYPE_AND\n61 61    DEFAULT_INITIAL_STATE = True\n62 62    \n   63  + EVENT_AUTOMATION_RELOADED = \"automation_reloaded\"\n   64  + \n63 65    ATTR_LAST_TRIGGERED = \"last_triggered\"\n64 66    ATTR_VARIABLES = \"variables\"\n65 67    SERVICE_TRIGGER = \"trigger\"\n       ...\n",
                "file_path": "homeassistant/components/automation/__init__.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "EVENT_AUTOMATION_RELOADED"
                ],
                "prefix": [
                    "DEFAULT_CONDITION_TYPE = CONDITION_TYPE_AND\n",
                    "DEFAULT_INITIAL_STATE = True\n",
                    "\n"
                ],
                "suffix": [
                    "ATTR_LAST_TRIGGERED = \"last_triggered\"\n",
                    "ATTR_VARIABLES = \"variables\"\n",
                    "SERVICE_TRIGGER = \"trigger\"\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "EVENT_AUTOMATION_RELOADED",
                            "position": {
                                "start": {
                                    "line": 63,
                                    "column": 0
                                },
                                "end": {
                                    "line": 63,
                                    "column": 25
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/automation/__init__.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "EVENT_AUTOMATION_RELOADED",
                            "position": {
                                "start": {
                                    "line": 63,
                                    "column": 0
                                },
                                "end": {
                                    "line": 63,
                                    "column": 25
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/automation/__init__.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "EVENT_AUTOMATION_RELOADED",
                            "position": {
                                "start": {
                                    "line": 63,
                                    "column": 0
                                },
                                "end": {
                                    "line": 63,
                                    "column": 25
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/automation/__init__.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "ATTR_LAST_TRIGGERED = \"last_triggered\"\n",
                "ATTR_VARIABLES = \"variables\"\n",
                "SERVICE_TRIGGER = \"trigger\"\n",
                "\n",
                "_LOGGER = logging.getLogger(__name__)\n",
                "\n",
                "AutomationActionType = Callable[[HomeAssistant, TemplateVarsType], Awaitable[None]]\n",
                "\n",
                "\n",
                "def _platform_validator(config):\n",
                "    \"\"\"Validate it is a valid platform.\"\"\"\n",
                "    try:\n",
                "        platform = importlib.import_module(f\".{config[CONF_PLATFORM]}\", __name__)\n",
                "    except ImportError:\n",
                "        raise vol.Invalid(\"Invalid platform specified\") from None\n",
                "\n",
                "    return platform.TRIGGER_SCHEMA(config)\n",
                "\n",
                "\n",
                "_TRIGGER_SCHEMA = vol.All(\n",
                "    cv.ensure_list,\n",
                "    [\n",
                "        vol.All(\n",
                "            vol.Schema({vol.Required(CONF_PLATFORM): str}, extra=vol.ALLOW_EXTRA),\n",
                "            _platform_validator,\n",
                "        )\n",
                "    ],\n",
                ")\n",
                "\n",
                "_CONDITION_SCHEMA = vol.All(cv.ensure_list, [cv.CONDITION_SCHEMA])\n",
                "\n",
                "PLATFORM_SCHEMA = vol.All(\n",
                "    cv.deprecated(CONF_HIDE_ENTITY, invalidation_version=\"0.110\"),\n",
                "    vol.Schema(\n",
                "        {\n",
                "            # str on purpose\n",
                "            CONF_ID: str,\n",
                "            CONF_ALIAS: cv.string,\n",
                "            vol.Optional(CONF_DESCRIPTION): cv.string,\n",
                "            vol.Optional(CONF_INITIAL_STATE): cv.boolean,\n",
                "            vol.Optional(CONF_HIDE_ENTITY): cv.boolean,\n",
                "            vol.Required(CONF_TRIGGER): _TRIGGER_SCHEMA,\n",
                "            vol.Optional(CONF_CONDITION): _CONDITION_SCHEMA,\n",
                "            vol.Required(CONF_ACTION): cv.SCRIPT_SCHEMA,\n",
                "        }\n",
                "    ),\n",
                ")\n",
                "\n",
                "\n",
                "@bind_hass\n",
                "def is_on(hass, entity_id):\n",
                "    \"\"\"\n",
                "    Return true if specified automation entity_id is on.\n",
                "\n",
                "    Async friendly.\n",
                "    \"\"\"\n",
                "    return hass.states.is_state(entity_id, STATE_ON)\n",
                "\n",
                "\n",
                "@callback\n",
                "def automations_with_entity(hass: HomeAssistant, entity_id: str) -> List[str]:\n",
                "    \"\"\"Return all automations that reference the entity.\"\"\"\n",
                "    if DOMAIN not in hass.data:\n",
                "        return []\n",
                "\n",
                "    component = hass.data[DOMAIN]\n",
                "\n",
                "    return [\n",
                "        automation_entity.entity_id\n",
                "        for automation_entity in component.entities\n",
                "        if entity_id in automation_entity.referenced_entities\n",
                "    ]\n",
                "\n",
                "\n",
                "@callback\n",
                "def entities_in_automation(hass: HomeAssistant, entity_id: str) -> List[str]:\n",
                "    \"\"\"Return all entities in a scene.\"\"\"\n",
                "    if DOMAIN not in hass.data:\n",
                "        return []\n",
                "\n",
                "    component = hass.data[DOMAIN]\n",
                "\n",
                "    automation_entity = component.get_entity(entity_id)\n",
                "\n",
                "    if automation_entity is None:\n",
                "        return []\n",
                "\n",
                "    return list(automation_entity.referenced_entities)\n",
                "\n",
                "\n",
                "@callback\n",
                "def automations_with_device(hass: HomeAssistant, device_id: str) -> List[str]:\n",
                "    \"\"\"Return all automations that reference the device.\"\"\"\n",
                "    if DOMAIN not in hass.data:\n",
                "        return []\n",
                "\n",
                "    component = hass.data[DOMAIN]\n",
                "\n",
                "    return [\n",
                "        automation_entity.entity_id\n",
                "        for automation_entity in component.entities\n",
                "        if device_id in automation_entity.referenced_devices\n",
                "    ]\n",
                "\n",
                "\n",
                "@callback\n",
                "def devices_in_automation(hass: HomeAssistant, entity_id: str) -> List[str]:\n",
                "    \"\"\"Return all devices in a scene.\"\"\"\n",
                "    if DOMAIN not in hass.data:\n",
                "        return []\n",
                "\n",
                "    component = hass.data[DOMAIN]\n",
                "\n",
                "    automation_entity = component.get_entity(entity_id)\n",
                "\n",
                "    if automation_entity is None:\n",
                "        return []\n",
                "\n",
                "    return list(automation_entity.referenced_devices)\n",
                "\n",
                "\n",
                "async def async_setup(hass, config):\n",
                "    \"\"\"Set up the automation.\"\"\"\n",
                "    hass.data[DOMAIN] = component = EntityComponent(_LOGGER, DOMAIN, hass)\n",
                "\n",
                "    await _async_process_config(hass, config, component)\n",
                "\n",
                "    async def trigger_service_handler(entity, service_call):\n",
                "        \"\"\"Handle automation triggers.\"\"\"\n",
                "        await entity.async_trigger(\n",
                "            service_call.data[ATTR_VARIABLES],\n",
                "            skip_condition=service_call.data[CONF_SKIP_CONDITION],\n",
                "            context=service_call.context,\n",
                "        )\n",
                "\n",
                "    component.async_register_entity_service(\n",
                "        SERVICE_TRIGGER,\n",
                "        {\n",
                "            vol.Optional(ATTR_VARIABLES, default={}): dict,\n",
                "            vol.Optional(CONF_SKIP_CONDITION, default=True): bool,\n",
                "        },\n",
                "        trigger_service_handler,\n",
                "    )\n",
                "    component.async_register_entity_service(SERVICE_TOGGLE, {}, \"async_toggle\")\n",
                "    component.async_register_entity_service(SERVICE_TURN_ON, {}, \"async_turn_on\")\n",
                "    component.async_register_entity_service(SERVICE_TURN_OFF, {}, \"async_turn_off\")\n",
                "\n",
                "    async def reload_service_handler(service_call):\n",
                "        \"\"\"Remove all automations and load new ones from config.\"\"\"\n",
                "        conf = await component.async_prepare_reload()\n",
                "        if conf is None:\n",
                "            return\n",
                "        await _async_process_config(hass, conf, component)\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        hass.bus.async_fire(EVENT_AUTOMATION_RELOADED, context=service_call.context)\n"
                ],
                "parent_version_range": {
                    "start": 216,
                    "end": 216
                },
                "child_version_range": {
                    "start": 218,
                    "end": 219
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "async_setup",
                        "signature": "def async_setup(hass, config):",
                        "at_line": 184
                    },
                    {
                        "type": "function",
                        "name": "reload_service_handler",
                        "signature": "def reload_service_handler(service_call):",
                        "at_line": 210
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: homeassistant/components/automation/__init__.py\nCode:\n           def async_setup(hass, config):\n               ...\n               def reload_service_handler(service_call):\n                   ...\n213 215            if conf is None:\n214 216                return\n215 217            await _async_process_config(hass, conf, component)\n    218  +         hass.bus.async_fire(EVENT_AUTOMATION_RELOADED, context=service_call.context)\n216 219    \n217 220        async_register_admin_service(\n218 221            hass, DOMAIN, SERVICE_RELOAD, reload_service_handler, schema=vol.Schema({})\n         ...\n",
                "file_path": "homeassistant/components/automation/__init__.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "EVENT_AUTOMATION_RELOADED",
                    "async_fire",
                    "bus",
                    "context",
                    "hass",
                    "service_call"
                ],
                "prefix": [
                    "        if conf is None:\n",
                    "            return\n",
                    "        await _async_process_config(hass, conf, component)\n"
                ],
                "suffix": [
                    "\n",
                    "    async_register_admin_service(\n",
                    "        hass, DOMAIN, SERVICE_RELOAD, reload_service_handler, schema=vol.Schema({})\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "EVENT_AUTOMATION_RELOADED",
                            "position": {
                                "start": {
                                    "line": 218,
                                    "column": 28
                                },
                                "end": {
                                    "line": 218,
                                    "column": 53
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/automation/__init__.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "    async_register_admin_service(\n",
                "        hass, DOMAIN, SERVICE_RELOAD, reload_service_handler, schema=vol.Schema({})\n",
                "    )\n",
                "\n",
                "    return True\n",
                "\n",
                "\n",
                "class AutomationEntity(ToggleEntity, RestoreEntity):\n",
                "    \"\"\"Entity to show status of entity.\"\"\"\n",
                "\n",
                "    def __init__(\n",
                "        self,\n",
                "        automation_id,\n",
                "        name,\n",
                "        trigger_config,\n",
                "        cond_func,\n",
                "        action_script,\n",
                "        initial_state,\n",
                "    ):\n",
                "        \"\"\"Initialize an automation entity.\"\"\"\n",
                "        self._id = automation_id\n",
                "        self._name = name\n",
                "        self._trigger_config = trigger_config\n",
                "        self._async_detach_triggers = None\n",
                "        self._cond_func = cond_func\n",
                "        self.action_script = action_script\n",
                "        self._last_triggered = None\n",
                "        self._initial_state = initial_state\n",
                "        self._is_enabled = False\n",
                "        self._referenced_entities: Optional[Set[str]] = None\n",
                "        self._referenced_devices: Optional[Set[str]] = None\n",
                "\n",
                "    @property\n",
                "    def name(self):\n",
                "        \"\"\"Name of the automation.\"\"\"\n",
                "        return self._name\n",
                "\n",
                "    @property\n",
                "    def unique_id(self):\n",
                "        \"\"\"Return unique ID.\"\"\"\n",
                "        return self._id\n",
                "\n",
                "    @property\n",
                "    def should_poll(self):\n",
                "        \"\"\"No polling needed for automation entities.\"\"\"\n",
                "        return False\n",
                "\n",
                "    @property\n",
                "    def state_attributes(self):\n",
                "        \"\"\"Return the entity state attributes.\"\"\"\n",
                "        return {ATTR_LAST_TRIGGERED: self._last_triggered}\n",
                "\n",
                "    @property\n",
                "    def is_on(self) -> bool:\n",
                "        \"\"\"Return True if entity is on.\"\"\"\n",
                "        return self._async_detach_triggers is not None or self._is_enabled\n",
                "\n",
                "    @property\n",
                "    def referenced_devices(self):\n",
                "        \"\"\"Return a set of referenced devices.\"\"\"\n",
                "        if self._referenced_devices is not None:\n",
                "            return self._referenced_devices\n",
                "\n",
                "        referenced = self.action_script.referenced_devices\n",
                "\n",
                "        if self._cond_func is not None:\n",
                "            for conf in self._cond_func.config:\n",
                "                referenced |= condition.async_extract_devices(conf)\n",
                "\n",
                "        for conf in self._trigger_config:\n",
                "            device = _trigger_extract_device(conf)\n",
                "            if device is not None:\n",
                "                referenced.add(device)\n",
                "\n",
                "        self._referenced_devices = referenced\n",
                "        return referenced\n",
                "\n",
                "    @property\n",
                "    def referenced_entities(self):\n",
                "        \"\"\"Return a set of referenced entities.\"\"\"\n",
                "        if self._referenced_entities is not None:\n",
                "            return self._referenced_entities\n",
                "\n",
                "        referenced = self.action_script.referenced_entities\n",
                "\n",
                "        if self._cond_func is not None:\n",
                "            for conf in self._cond_func.config:\n",
                "                referenced |= condition.async_extract_entities(conf)\n",
                "\n",
                "        for conf in self._trigger_config:\n",
                "            for entity_id in _trigger_extract_entities(conf):\n",
                "                referenced.add(entity_id)\n",
                "\n",
                "        self._referenced_entities = referenced\n",
                "        return referenced\n",
                "\n",
                "    async def async_added_to_hass(self) -> None:\n",
                "        \"\"\"Startup with initial state or previous state.\"\"\"\n",
                "        await super().async_added_to_hass()\n",
                "\n",
                "        state = await self.async_get_last_state()\n",
                "        if state:\n",
                "            enable_automation = state.state == STATE_ON\n",
                "            last_triggered = state.attributes.get(\"last_triggered\")\n",
                "            if last_triggered is not None:\n",
                "                self._last_triggered = parse_datetime(last_triggered)\n",
                "            _LOGGER.debug(\n",
                "                \"Loaded automation %s with state %s from state \"\n",
                "                \" storage last state %s\",\n",
                "                self.entity_id,\n",
                "                enable_automation,\n",
                "                state,\n",
                "            )\n",
                "        else:\n",
                "            enable_automation = DEFAULT_INITIAL_STATE\n",
                "            _LOGGER.debug(\n",
                "                \"Automation %s not in state storage, state %s from default is used.\",\n",
                "                self.entity_id,\n",
                "                enable_automation,\n",
                "            )\n",
                "\n",
                "        if self._initial_state is not None:\n",
                "            enable_automation = self._initial_state\n",
                "            _LOGGER.debug(\n",
                "                \"Automation %s initial state %s overridden from \"\n",
                "                \"config initial_state\",\n",
                "                self.entity_id,\n",
                "                enable_automation,\n",
                "            )\n",
                "\n",
                "        if enable_automation:\n",
                "            await self.async_enable()\n",
                "\n",
                "    async def async_turn_on(self, **kwargs: Any) -> None:\n",
                "        \"\"\"Turn the entity on and update the state.\"\"\"\n",
                "        await self.async_enable()\n",
                "\n",
                "    async def async_turn_off(self, **kwargs: Any) -> None:\n",
                "        \"\"\"Turn the entity off.\"\"\"\n",
                "        await self.async_disable()\n",
                "\n",
                "    async def async_trigger(self, variables, skip_condition=False, context=None):\n",
                "        \"\"\"Trigger automation.\n",
                "\n",
                "        This method is a coroutine.\n",
                "        \"\"\"\n",
                "        if (\n",
                "            not skip_condition\n",
                "            and self._cond_func is not None\n",
                "            and not self._cond_func(variables)\n",
                "        ):\n",
                "            return\n",
                "\n",
                "        # Create a new context referring to the old context.\n",
                "        parent_id = None if context is None else context.id\n",
                "        trigger_context = Context(parent_id=parent_id)\n",
                "\n",
                "        self.async_set_context(trigger_context)\n",
                "        self.hass.bus.async_fire(\n",
                "            EVENT_AUTOMATION_TRIGGERED,\n",
                "            {ATTR_NAME: self._name, ATTR_ENTITY_ID: self.entity_id},\n",
                "            context=trigger_context,\n",
                "        )\n",
                "\n",
                "        _LOGGER.info(\"Executing %s\", self._name)\n",
                "\n",
                "        try:\n",
                "            await self.action_script.async_run(variables, trigger_context)\n",
                "        except Exception:  # pylint: disable=broad-except\n",
                "            pass\n",
                "\n",
                "        self._last_triggered = utcnow()\n",
                "        self.async_write_ha_state()\n",
                "\n",
                "    async def async_will_remove_from_hass(self):\n",
                "        \"\"\"Remove listeners when removing automation from Home Assistant.\"\"\"\n",
                "        await super().async_will_remove_from_hass()\n",
                "        await self.async_disable()\n",
                "\n",
                "    async def async_enable(self):\n",
                "        \"\"\"Enable this automation entity.\n",
                "\n",
                "        This method is a coroutine.\n",
                "        \"\"\"\n",
                "        if self._is_enabled:\n",
                "            return\n",
                "\n",
                "        self._is_enabled = True\n",
                "\n",
                "        # HomeAssistant is starting up\n",
                "        if self.hass.state != CoreState.not_running:\n",
                "            self._async_detach_triggers = await self._async_attach_triggers(False)\n",
                "            self.async_write_ha_state()\n",
                "            return\n",
                "\n",
                "        async def async_enable_automation(event):\n",
                "            \"\"\"Start automation on startup.\"\"\"\n",
                "            # Don't do anything if no longer enabled or already attached\n",
                "            if not self._is_enabled or self._async_detach_triggers is not None:\n",
                "                return\n",
                "\n",
                "            self._async_detach_triggers = await self._async_attach_triggers(True)\n",
                "\n",
                "        self.hass.bus.async_listen_once(\n",
                "            EVENT_HOMEASSISTANT_STARTED, async_enable_automation\n",
                "        )\n",
                "        self.async_write_ha_state()\n",
                "\n",
                "    async def async_disable(self):\n",
                "        \"\"\"Disable the automation entity.\"\"\"\n",
                "        if not self._is_enabled:\n",
                "            return\n",
                "\n",
                "        self._is_enabled = False\n",
                "\n",
                "        if self._async_detach_triggers is not None:\n",
                "            self._async_detach_triggers()\n",
                "            self._async_detach_triggers = None\n",
                "\n",
                "        self.async_write_ha_state()\n",
                "\n",
                "    async def _async_attach_triggers(\n",
                "        self, home_assistant_start: bool\n",
                "    ) -> Optional[Callable[[], None]]:\n",
                "        \"\"\"Set up the triggers.\"\"\"\n",
                "        info = {\"name\": self._name, \"home_assistant_start\": home_assistant_start}\n",
                "\n",
                "        triggers = []\n",
                "        for conf in self._trigger_config:\n",
                "            platform = importlib.import_module(f\".{conf[CONF_PLATFORM]}\", __name__)\n",
                "\n",
                "            triggers.append(\n",
                "                platform.async_attach_trigger(  # type: ignore\n",
                "                    self.hass, conf, self.async_trigger, info\n",
                "                )\n",
                "            )\n",
                "\n",
                "        results = await asyncio.gather(*triggers)\n",
                "\n",
                "        if None in results:\n",
                "            _LOGGER.error(\"Error setting up trigger %s\", self._name)\n",
                "\n",
                "        removes = [remove for remove in results if remove is not None]\n",
                "        if not removes:\n",
                "            return None\n",
                "\n",
                "        _LOGGER.info(\"Initialized trigger %s\", self._name)\n",
                "\n",
                "        @callback\n",
                "        def remove_triggers():\n",
                "            \"\"\"Remove attached triggers.\"\"\"\n",
                "            for remove in removes:\n",
                "                remove()\n",
                "\n",
                "        return remove_triggers\n",
                "\n",
                "    @property\n",
                "    def device_state_attributes(self):\n",
                "        \"\"\"Return automation attributes.\"\"\"\n",
                "        if self._id is None:\n",
                "            return None\n",
                "\n",
                "        return {CONF_ID: self._id}\n",
                "\n",
                "\n",
                "async def _async_process_config(hass, config, component):\n",
                "    \"\"\"Process config and add automations.\n",
                "\n",
                "    This method is a coroutine.\n",
                "    \"\"\"\n",
                "    entities = []\n",
                "\n",
                "    for config_key in extract_domain_configs(config, DOMAIN):\n",
                "        conf = config[config_key]\n",
                "\n",
                "        for list_no, config_block in enumerate(conf):\n",
                "            automation_id = config_block.get(CONF_ID)\n",
                "            name = config_block.get(CONF_ALIAS) or f\"{config_key} {list_no}\"\n",
                "\n",
                "            initial_state = config_block.get(CONF_INITIAL_STATE)\n",
                "\n",
                "            action_script = script.Script(\n",
                "                hass, config_block.get(CONF_ACTION, {}), name, logger=_LOGGER\n",
                "            )\n",
                "\n",
                "            if CONF_CONDITION in config_block:\n",
                "                cond_func = await _async_process_if(hass, config, config_block)\n",
                "\n",
                "                if cond_func is None:\n",
                "                    continue\n",
                "            else:\n",
                "                cond_func = None\n",
                "\n",
                "            entity = AutomationEntity(\n",
                "                automation_id,\n",
                "                name,\n",
                "                config_block[CONF_TRIGGER],\n",
                "                cond_func,\n",
                "                action_script,\n",
                "                initial_state,\n",
                "            )\n",
                "\n",
                "            entities.append(entity)\n",
                "\n",
                "    if entities:\n",
                "        await component.async_add_entities(entities)\n",
                "\n",
                "\n",
                "async def _async_process_if(hass, config, p_config):\n",
                "    \"\"\"Process if checks.\"\"\"\n",
                "    if_configs = p_config[CONF_CONDITION]\n",
                "\n",
                "    checks = []\n",
                "    for if_config in if_configs:\n",
                "        try:\n",
                "            checks.append(await condition.async_from_config(hass, if_config, False))\n",
                "        except HomeAssistantError as ex:\n",
                "            _LOGGER.warning(\"Invalid condition: %s\", ex)\n",
                "            return None\n",
                "\n",
                "    def if_action(variables=None):\n",
                "        \"\"\"AND all conditions.\"\"\"\n",
                "        return all(check(hass, variables) for check in checks)\n",
                "\n",
                "    if_action.config = if_configs\n",
                "\n",
                "    return if_action\n",
                "\n",
                "\n",
                "@callback\n",
                "def _trigger_extract_device(trigger_conf: dict) -> Optional[str]:\n",
                "    \"\"\"Extract devices from a trigger config.\"\"\"\n",
                "    if trigger_conf[CONF_PLATFORM] != \"device\":\n",
                "        return None\n",
                "\n",
                "    return trigger_conf[CONF_DEVICE_ID]\n",
                "\n",
                "\n",
                "@callback\n",
                "def _trigger_extract_entities(trigger_conf: dict) -> List[str]:\n",
                "    \"\"\"Extract entities from a trigger config.\"\"\"\n",
                "    if trigger_conf[CONF_PLATFORM] in (\"state\", \"numeric_state\"):\n",
                "        return trigger_conf[CONF_ENTITY_ID]\n",
                "\n",
                "    if trigger_conf[CONF_PLATFORM] == \"zone\":\n",
                "        return trigger_conf[CONF_ENTITY_ID] + [trigger_conf[CONF_ZONE]]\n",
                "\n",
                "    if trigger_conf[CONF_PLATFORM] == \"geo_location\":\n",
                "        return [trigger_conf[CONF_ZONE]]\n",
                "\n",
                "    if trigger_conf[CONF_PLATFORM] == \"sun\":\n",
                "        return [\"sun.sun\"]\n",
                "\n",
                "    return []"
            ]
        ],
        "homeassistant/components/homeassistant/scene.py": [
            [
                "\"\"\"Allow users to set and activate scenes.\"\"\"\n",
                "from collections import namedtuple\n",
                "import logging\n",
                "from typing import Any, List\n",
                "\n",
                "import voluptuous as vol\n",
                "\n",
                "from homeassistant import config as conf_util\n",
                "from homeassistant.components.light import ATTR_TRANSITION\n",
                "from homeassistant.components.scene import DOMAIN as SCENE_DOMAIN, STATES, Scene\n",
                "from homeassistant.const import (\n",
                "    ATTR_ENTITY_ID,\n",
                "    ATTR_STATE,\n",
                "    CONF_ENTITIES,\n",
                "    CONF_ICON,\n",
                "    CONF_ID,\n",
                "    CONF_NAME,\n",
                "    CONF_PLATFORM,\n",
                "    SERVICE_RELOAD,\n",
                "    STATE_OFF,\n",
                "    STATE_ON,\n",
                ")\n",
                "from homeassistant.core import DOMAIN as HA_DOMAIN, HomeAssistant, State, callback\n",
                "from homeassistant.exceptions import HomeAssistantError\n",
                "from homeassistant.helpers import (\n",
                "    config_per_platform,\n",
                "    config_validation as cv,\n",
                "    entity_platform,\n",
                ")\n",
                "from homeassistant.helpers.state import async_reproduce_state\n",
                "from homeassistant.loader import async_get_integration\n",
                "\n",
                "\n",
                "def _convert_states(states):\n",
                "    \"\"\"Convert state definitions to State objects.\"\"\"\n",
                "    result = {}\n",
                "\n",
                "    for entity_id in states:\n",
                "        entity_id = cv.entity_id(entity_id)\n",
                "\n",
                "        if isinstance(states[entity_id], dict):\n",
                "            entity_attrs = states[entity_id].copy()\n",
                "            state = entity_attrs.pop(ATTR_STATE, None)\n",
                "            attributes = entity_attrs\n",
                "        else:\n",
                "            state = states[entity_id]\n",
                "            attributes = {}\n",
                "\n",
                "        # YAML translates 'on' to a boolean\n",
                "        # http://yaml.org/type/bool.html\n",
                "        if isinstance(state, bool):\n",
                "            state = STATE_ON if state else STATE_OFF\n",
                "        elif not isinstance(state, str):\n",
                "            raise vol.Invalid(f\"State for {entity_id} should be a string\")\n",
                "\n",
                "        result[entity_id] = State(entity_id, state, attributes)\n",
                "\n",
                "    return result\n",
                "\n",
                "\n",
                "def _ensure_no_intersection(value):\n",
                "    \"\"\"Validate that entities and snapshot_entities do not overlap.\"\"\"\n",
                "    if (\n",
                "        CONF_SNAPSHOT not in value\n",
                "        or CONF_ENTITIES not in value\n",
                "        or all(\n",
                "            entity_id not in value[CONF_SNAPSHOT] for entity_id in value[CONF_ENTITIES]\n",
                "        )\n",
                "    ):\n",
                "        return value\n",
                "\n",
                "    raise vol.Invalid(\"entities and snapshot_entities must not overlap\")\n",
                "\n",
                "\n",
                "CONF_SCENE_ID = \"scene_id\"\n",
                "CONF_SNAPSHOT = \"snapshot_entities\"\n",
                "DATA_PLATFORM = \"homeassistant_scene\"\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "EVENT_SCENE_RELOADED = \"scene_reloaded\"\n"
                ],
                "parent_version_range": {
                    "start": 77,
                    "end": 77
                },
                "child_version_range": {
                    "start": 77,
                    "end": 78
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 2,
                "hunk_diff": "File: homeassistant/components/homeassistant/scene.py\nCode:\n  ...\n74 74    CONF_SCENE_ID = \"scene_id\"\n75 75    CONF_SNAPSHOT = \"snapshot_entities\"\n76 76    DATA_PLATFORM = \"homeassistant_scene\"\n   77  + EVENT_SCENE_RELOADED = \"scene_reloaded\"\n77 78    STATES_SCHEMA = vol.All(dict, _convert_states)\n78 79    \n79 80    \n       ...\n",
                "file_path": "homeassistant/components/homeassistant/scene.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "EVENT_SCENE_RELOADED"
                ],
                "prefix": [
                    "CONF_SCENE_ID = \"scene_id\"\n",
                    "CONF_SNAPSHOT = \"snapshot_entities\"\n",
                    "DATA_PLATFORM = \"homeassistant_scene\"\n"
                ],
                "suffix": [
                    "STATES_SCHEMA = vol.All(dict, _convert_states)\n",
                    "\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "EVENT_SCENE_RELOADED",
                            "position": {
                                "start": {
                                    "line": 77,
                                    "column": 0
                                },
                                "end": {
                                    "line": 77,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/homeassistant/scene.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 8,
                        "detail": {
                            "identifier": "EVENT_SCENE_RELOADED",
                            "position": {
                                "start": {
                                    "line": 77,
                                    "column": 0
                                },
                                "end": {
                                    "line": 77,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/homeassistant/scene.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "EVENT_SCENE_RELOADED",
                            "position": {
                                "start": {
                                    "line": 77,
                                    "column": 0
                                },
                                "end": {
                                    "line": 77,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/homeassistant/scene.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "STATES_SCHEMA = vol.All(dict, _convert_states)\n",
                "\n",
                "\n",
                "PLATFORM_SCHEMA = vol.Schema(\n",
                "    {\n",
                "        vol.Required(CONF_PLATFORM): HA_DOMAIN,\n",
                "        vol.Required(STATES): vol.All(\n",
                "            cv.ensure_list,\n",
                "            [\n",
                "                vol.Schema(\n",
                "                    {\n",
                "                        vol.Optional(CONF_ID): cv.string,\n",
                "                        vol.Required(CONF_NAME): cv.string,\n",
                "                        vol.Optional(CONF_ICON): cv.icon,\n",
                "                        vol.Required(CONF_ENTITIES): STATES_SCHEMA,\n",
                "                    }\n",
                "                )\n",
                "            ],\n",
                "        ),\n",
                "    },\n",
                "    extra=vol.ALLOW_EXTRA,\n",
                ")\n",
                "\n",
                "CREATE_SCENE_SCHEMA = vol.All(\n",
                "    cv.has_at_least_one_key(CONF_ENTITIES, CONF_SNAPSHOT),\n",
                "    _ensure_no_intersection,\n",
                "    vol.Schema(\n",
                "        {\n",
                "            vol.Required(CONF_SCENE_ID): cv.slug,\n",
                "            vol.Optional(CONF_ENTITIES, default={}): STATES_SCHEMA,\n",
                "            vol.Optional(CONF_SNAPSHOT, default=[]): cv.entity_ids,\n",
                "        }\n",
                "    ),\n",
                ")\n",
                "\n",
                "SERVICE_APPLY = \"apply\"\n",
                "SERVICE_CREATE = \"create\"\n",
                "SCENECONFIG = namedtuple(\"SceneConfig\", [CONF_ID, CONF_NAME, CONF_ICON, STATES])\n",
                "_LOGGER = logging.getLogger(__name__)\n",
                "\n",
                "\n",
                "@callback\n",
                "def scenes_with_entity(hass: HomeAssistant, entity_id: str) -> List[str]:\n",
                "    \"\"\"Return all scenes that reference the entity.\"\"\"\n",
                "    if DATA_PLATFORM not in hass.data:\n",
                "        return []\n",
                "\n",
                "    platform = hass.data[DATA_PLATFORM]\n",
                "\n",
                "    return [\n",
                "        scene_entity.entity_id\n",
                "        for scene_entity in platform.entities.values()\n",
                "        if entity_id in scene_entity.scene_config.states\n",
                "    ]\n",
                "\n",
                "\n",
                "@callback\n",
                "def entities_in_scene(hass: HomeAssistant, entity_id: str) -> List[str]:\n",
                "    \"\"\"Return all entities in a scene.\"\"\"\n",
                "    if DATA_PLATFORM not in hass.data:\n",
                "        return []\n",
                "\n",
                "    platform = hass.data[DATA_PLATFORM]\n",
                "\n",
                "    entity = platform.entities.get(entity_id)\n",
                "\n",
                "    if entity is None:\n",
                "        return []\n",
                "\n",
                "    return list(entity.scene_config.states)\n",
                "\n",
                "\n",
                "async def async_setup_platform(hass, config, async_add_entities, discovery_info=None):\n",
                "    \"\"\"Set up Home Assistant scene entries.\"\"\"\n",
                "    _process_scenes_config(hass, async_add_entities, config)\n",
                "\n",
                "    # This platform can be loaded multiple times. Only first time register the service.\n",
                "    if hass.services.has_service(SCENE_DOMAIN, SERVICE_RELOAD):\n",
                "        return\n",
                "\n",
                "    # Store platform for later.\n",
                "    platform = hass.data[DATA_PLATFORM] = entity_platform.current_platform.get()\n",
                "\n",
                "    async def reload_config(call):\n",
                "        \"\"\"Reload the scene config.\"\"\"\n",
                "        try:\n",
                "            conf = await conf_util.async_hass_config_yaml(hass)\n",
                "        except HomeAssistantError as err:\n",
                "            _LOGGER.error(err)\n",
                "            return\n",
                "\n",
                "        integration = await async_get_integration(hass, SCENE_DOMAIN)\n",
                "\n",
                "        conf = await conf_util.async_process_component_config(hass, conf, integration)\n",
                "\n",
                "        if not (conf and platform):\n",
                "            return\n",
                "\n",
                "        await platform.async_reset()\n",
                "\n",
                "        # Extract only the config for the Home Assistant platform, ignore the rest.\n",
                "        for p_type, p_config in config_per_platform(conf, SCENE_DOMAIN):\n",
                "            if p_type != HA_DOMAIN:\n",
                "                continue\n",
                "\n",
                "            _process_scenes_config(hass, async_add_entities, p_config)\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        hass.bus.async_fire(EVENT_SCENE_RELOADED, context=call.context)\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 184,
                    "end": 184
                },
                "child_version_range": {
                    "start": 185,
                    "end": 187
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "async_setup_platform",
                        "signature": "def async_setup_platform(hass, config, async_add_entities, discovery_info=None):",
                        "at_line": 149
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: homeassistant/components/homeassistant/scene.py\nCode:\n           def async_setup_platform(hass, config, async_add_entities, discovery_info=None):\n               ...\n181 182    \n182 183                _process_scenes_config(hass, async_add_entities, p_config)\n183 184    \n    185  +         hass.bus.async_fire(EVENT_SCENE_RELOADED, context=call.context)\n    186  + \n184 187        hass.helpers.service.async_register_admin_service(\n185 188            SCENE_DOMAIN, SERVICE_RELOAD, reload_config\n186 189        )\n         ...\n",
                "file_path": "homeassistant/components/homeassistant/scene.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "EVENT_SCENE_RELOADED",
                    "async_fire",
                    "bus",
                    "call",
                    "context",
                    "hass"
                ],
                "prefix": [
                    "\n",
                    "            _process_scenes_config(hass, async_add_entities, p_config)\n",
                    "\n"
                ],
                "suffix": [
                    "    hass.helpers.service.async_register_admin_service(\n",
                    "        SCENE_DOMAIN, SERVICE_RELOAD, reload_config\n",
                    "    )\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "EVENT_SCENE_RELOADED",
                            "position": {
                                "start": {
                                    "line": 185,
                                    "column": 28
                                },
                                "end": {
                                    "line": 185,
                                    "column": 48
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/homeassistant/scene.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    hass.helpers.service.async_register_admin_service(\n",
                "        SCENE_DOMAIN, SERVICE_RELOAD, reload_config\n",
                "    )\n",
                "\n",
                "    async def apply_service(call):\n",
                "        \"\"\"Apply a scene.\"\"\"\n",
                "        reproduce_options = {}\n",
                "\n",
                "        if ATTR_TRANSITION in call.data:\n",
                "            reproduce_options[ATTR_TRANSITION] = call.data.get(ATTR_TRANSITION)\n",
                "\n",
                "        await async_reproduce_state(\n",
                "            hass,\n",
                "            call.data[CONF_ENTITIES].values(),\n",
                "            context=call.context,\n",
                "            reproduce_options=reproduce_options,\n",
                "        )\n",
                "\n",
                "    hass.services.async_register(\n",
                "        SCENE_DOMAIN,\n",
                "        SERVICE_APPLY,\n",
                "        apply_service,\n",
                "        vol.Schema(\n",
                "            {\n",
                "                vol.Optional(ATTR_TRANSITION): vol.All(\n",
                "                    vol.Coerce(float), vol.Clamp(min=0, max=6553)\n",
                "                ),\n",
                "                vol.Required(CONF_ENTITIES): STATES_SCHEMA,\n",
                "            }\n",
                "        ),\n",
                "    )\n",
                "\n",
                "    async def create_service(call):\n",
                "        \"\"\"Create a scene.\"\"\"\n",
                "        snapshot = call.data[CONF_SNAPSHOT]\n",
                "        entities = call.data[CONF_ENTITIES]\n",
                "\n",
                "        for entity_id in snapshot:\n",
                "            state = hass.states.get(entity_id)\n",
                "            if state is None:\n",
                "                _LOGGER.warning(\n",
                "                    \"Entity %s does not exist and therefore cannot be snapshotted\",\n",
                "                    entity_id,\n",
                "                )\n",
                "                continue\n",
                "            entities[entity_id] = State(entity_id, state.state, state.attributes)\n",
                "\n",
                "        if not entities:\n",
                "            _LOGGER.warning(\"Empty scenes are not allowed\")\n",
                "            return\n",
                "\n",
                "        scene_config = SCENECONFIG(None, call.data[CONF_SCENE_ID], None, entities)\n",
                "        entity_id = f\"{SCENE_DOMAIN}.{scene_config.name}\"\n",
                "        old = platform.entities.get(entity_id)\n",
                "        if old is not None:\n",
                "            if not old.from_service:\n",
                "                _LOGGER.warning(\"The scene %s already exists\", entity_id)\n",
                "                return\n",
                "            await platform.async_remove_entity(entity_id)\n",
                "        async_add_entities([HomeAssistantScene(hass, scene_config, from_service=True)])\n",
                "\n",
                "    hass.services.async_register(\n",
                "        SCENE_DOMAIN, SERVICE_CREATE, create_service, CREATE_SCENE_SCHEMA\n",
                "    )\n",
                "\n",
                "\n",
                "def _process_scenes_config(hass, async_add_entities, config):\n",
                "    \"\"\"Process multiple scenes and add them.\"\"\"\n",
                "    scene_config = config[STATES]\n",
                "\n",
                "    # Check empty list\n",
                "    if not scene_config:\n",
                "        return\n",
                "\n",
                "    async_add_entities(\n",
                "        HomeAssistantScene(\n",
                "            hass,\n",
                "            SCENECONFIG(\n",
                "                scene.get(CONF_ID),\n",
                "                scene[CONF_NAME],\n",
                "                scene.get(CONF_ICON),\n",
                "                scene[CONF_ENTITIES],\n",
                "            ),\n",
                "        )\n",
                "        for scene in scene_config\n",
                "    )\n",
                "\n",
                "\n",
                "class HomeAssistantScene(Scene):\n",
                "    \"\"\"A scene is a group of entities and the states we want them to be.\"\"\"\n",
                "\n",
                "    def __init__(self, hass, scene_config, from_service=False):\n",
                "        \"\"\"Initialize the scene.\"\"\"\n",
                "        self.hass = hass\n",
                "        self.scene_config = scene_config\n",
                "        self.from_service = from_service\n",
                "\n",
                "    @property\n",
                "    def name(self):\n",
                "        \"\"\"Return the name of the scene.\"\"\"\n",
                "        return self.scene_config.name\n",
                "\n",
                "    @property\n",
                "    def icon(self):\n",
                "        \"\"\"Return the icon of the scene.\"\"\"\n",
                "        return self.scene_config.icon\n",
                "\n",
                "    @property\n",
                "    def unique_id(self):\n",
                "        \"\"\"Return unique ID.\"\"\"\n",
                "        return self.scene_config.id\n",
                "\n",
                "    @property\n",
                "    def device_state_attributes(self):\n",
                "        \"\"\"Return the scene state attributes.\"\"\"\n",
                "        attributes = {ATTR_ENTITY_ID: list(self.scene_config.states)}\n",
                "        unique_id = self.unique_id\n",
                "        if unique_id is not None:\n",
                "            attributes[CONF_ID] = unique_id\n",
                "        return attributes\n",
                "\n",
                "    async def async_activate(self, **kwargs: Any) -> None:\n",
                "        \"\"\"Activate scene. Try to get entities into requested state.\"\"\"\n",
                "        await async_reproduce_state(\n",
                "            self.hass,\n",
                "            self.scene_config.states.values(),\n",
                "            context=self._context,\n",
                "            reproduce_options=kwargs,\n",
                "        )"
            ]
        ],
        "tests/components/automation/test_init.py": [
            [
                "\"\"\"The tests for the automation component.\"\"\"\n",
                "from datetime import timedelta\n",
                "\n",
                "import pytest\n",
                "\n",
                "import homeassistant.components.automation as automation\n"
            ],
            {
                "type": "replace",
                "before": [
                    "from homeassistant.components.automation import DOMAIN\n"
                ],
                "after": [
                    "from homeassistant.components.automation import DOMAIN, EVENT_AUTOMATION_RELOADED\n"
                ],
                "parent_version_range": {
                    "start": 6,
                    "end": 7
                },
                "child_version_range": {
                    "start": 6,
                    "end": 7
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 4,
                "hunk_diff": "File: tests/components/automation/test_init.py\nCode:\n  ...\n3 3    import pytest\n4 4    \n5 5    import homeassistant.components.automation as automation\n6    - from homeassistant.components.automation import DOMAIN\n  6  + from homeassistant.components.automation import DOMAIN, EVENT_AUTOMATION_RELOADED\n7 7    from homeassistant.const import (\n8 8        ATTR_ENTITY_ID,\n9 9        ATTR_NAME,\n     ...\n",
                "file_path": "tests/components/automation/test_init.py",
                "identifiers_before": [
                    "DOMAIN",
                    "automation",
                    "components",
                    "homeassistant"
                ],
                "identifiers_after": [
                    "DOMAIN",
                    "EVENT_AUTOMATION_RELOADED",
                    "automation",
                    "components",
                    "homeassistant"
                ],
                "prefix": [
                    "import pytest\n",
                    "\n",
                    "import homeassistant.components.automation as automation\n"
                ],
                "suffix": [
                    "from homeassistant.const import (\n",
                    "    ATTR_ENTITY_ID,\n",
                    "    ATTR_NAME,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "EVENT_AUTOMATION_RELOADED",
                            "position": {
                                "start": {
                                    "line": 6,
                                    "column": 56
                                },
                                "end": {
                                    "line": 6,
                                    "column": 81
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/automation/test_init.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "EVENT_AUTOMATION_RELOADED",
                            "position": {
                                "start": {
                                    "line": 6,
                                    "column": 56
                                },
                                "end": {
                                    "line": 6,
                                    "column": 81
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/automation/test_init.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "from homeassistant.const import (\n",
                "    ATTR_ENTITY_ID,\n",
                "    ATTR_NAME,\n",
                "    EVENT_AUTOMATION_TRIGGERED,\n",
                "    EVENT_HOMEASSISTANT_STARTED,\n",
                "    STATE_OFF,\n",
                "    STATE_ON,\n",
                ")\n",
                "from homeassistant.core import Context, CoreState, State\n",
                "from homeassistant.exceptions import HomeAssistantError, Unauthorized\n",
                "from homeassistant.setup import async_setup_component\n",
                "import homeassistant.util.dt as dt_util\n",
                "\n",
                "from tests.async_mock import Mock, patch\n",
                "from tests.common import (\n",
                "    assert_setup_component,\n",
                "    async_fire_time_changed,\n",
                "    async_mock_service,\n",
                "    mock_restore_cache,\n",
                ")\n",
                "from tests.components.automation import common\n",
                "\n",
                "\n",
                "@pytest.fixture\n",
                "def calls(hass):\n",
                "    \"\"\"Track calls to a mock service.\"\"\"\n",
                "    return async_mock_service(hass, \"test\", \"automation\")\n",
                "\n",
                "\n",
                "async def test_service_data_not_a_dict(hass, calls):\n",
                "    \"\"\"Test service data not dict.\"\"\"\n",
                "    with assert_setup_component(0, automation.DOMAIN):\n",
                "        assert await async_setup_component(\n",
                "            hass,\n",
                "            automation.DOMAIN,\n",
                "            {\n",
                "                automation.DOMAIN: {\n",
                "                    \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                    \"action\": {\"service\": \"test.automation\", \"data\": 100},\n",
                "                }\n",
                "            },\n",
                "        )\n",
                "\n",
                "\n",
                "async def test_service_specify_data(hass, calls):\n",
                "    \"\"\"Test service data.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\n",
                "                    \"service\": \"test.automation\",\n",
                "                    \"data_template\": {\n",
                "                        \"some\": \"{{ trigger.platform }} - \"\n",
                "                        \"{{ trigger.event.event_type }}\"\n",
                "                    },\n",
                "                },\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    time = dt_util.utcnow()\n",
                "\n",
                "    with patch(\"homeassistant.components.automation.utcnow\", return_value=time):\n",
                "        hass.bus.async_fire(\"test_event\")\n",
                "        await hass.async_block_till_done()\n",
                "\n",
                "    assert len(calls) == 1\n",
                "    assert calls[0].data[\"some\"] == \"event - test_event\"\n",
                "    state = hass.states.get(\"automation.hello\")\n",
                "    assert state is not None\n",
                "    assert state.attributes.get(\"last_triggered\") == time\n",
                "\n",
                "\n",
                "async def test_action_delay(hass, calls):\n",
                "    \"\"\"Test action delay.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": [\n",
                "                    {\n",
                "                        \"service\": \"test.automation\",\n",
                "                        \"data_template\": {\n",
                "                            \"some\": \"{{ trigger.platform }} - \"\n",
                "                            \"{{ trigger.event.event_type }}\"\n",
                "                        },\n",
                "                    },\n",
                "                    {\"delay\": {\"minutes\": \"10\"}},\n",
                "                    {\n",
                "                        \"service\": \"test.automation\",\n",
                "                        \"data_template\": {\n",
                "                            \"some\": \"{{ trigger.platform }} - \"\n",
                "                            \"{{ trigger.event.event_type }}\"\n",
                "                        },\n",
                "                    },\n",
                "                ],\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    time = dt_util.utcnow()\n",
                "\n",
                "    with patch(\"homeassistant.components.automation.utcnow\", return_value=time):\n",
                "        hass.bus.async_fire(\"test_event\")\n",
                "        await hass.async_block_till_done()\n",
                "\n",
                "    assert len(calls) == 1\n",
                "    assert calls[0].data[\"some\"] == \"event - test_event\"\n",
                "\n",
                "    future = dt_util.utcnow() + timedelta(minutes=10)\n",
                "    async_fire_time_changed(hass, future)\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(calls) == 2\n",
                "    assert calls[1].data[\"some\"] == \"event - test_event\"\n",
                "\n",
                "    state = hass.states.get(\"automation.hello\")\n",
                "    assert state is not None\n",
                "    assert state.attributes.get(\"last_triggered\") == time\n",
                "\n",
                "\n",
                "async def test_service_specify_entity_id(hass, calls):\n",
                "    \"\"\"Test service data.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\", \"entity_id\": \"hello.world\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "    assert [\"hello.world\"] == calls[0].data.get(ATTR_ENTITY_ID)\n",
                "\n",
                "\n",
                "async def test_service_specify_entity_id_list(hass, calls):\n",
                "    \"\"\"Test service data.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\n",
                "                    \"service\": \"test.automation\",\n",
                "                    \"entity_id\": [\"hello.world\", \"hello.world2\"],\n",
                "                },\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "    assert [\"hello.world\", \"hello.world2\"] == calls[0].data.get(ATTR_ENTITY_ID)\n",
                "\n",
                "\n",
                "async def test_two_triggers(hass, calls):\n",
                "    \"\"\"Test triggers.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"trigger\": [\n",
                "                    {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                    {\"platform\": \"state\", \"entity_id\": \"test.entity\"},\n",
                "                ],\n",
                "                \"action\": {\"service\": \"test.automation\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "    hass.states.async_set(\"test.entity\", \"hello\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 2\n",
                "\n",
                "\n",
                "async def test_trigger_service_ignoring_condition(hass, calls):\n",
                "    \"\"\"Test triggers.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"test\",\n",
                "                \"trigger\": [{\"platform\": \"event\", \"event_type\": \"test_event\"}],\n",
                "                \"condition\": {\n",
                "                    \"condition\": \"state\",\n",
                "                    \"entity_id\": \"non.existing\",\n",
                "                    \"state\": \"beer\",\n",
                "                },\n",
                "                \"action\": {\"service\": \"test.automation\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 0\n",
                "\n",
                "    await hass.services.async_call(\n",
                "        \"automation\", \"trigger\", {\"entity_id\": \"automation.test\"}, blocking=True\n",
                "    )\n",
                "    assert len(calls) == 1\n",
                "\n",
                "    await hass.services.async_call(\n",
                "        \"automation\",\n",
                "        \"trigger\",\n",
                "        {\"entity_id\": \"automation.test\", \"skip_condition\": True},\n",
                "        blocking=True,\n",
                "    )\n",
                "    assert len(calls) == 2\n",
                "\n",
                "    await hass.services.async_call(\n",
                "        \"automation\",\n",
                "        \"trigger\",\n",
                "        {\"entity_id\": \"automation.test\", \"skip_condition\": False},\n",
                "        blocking=True,\n",
                "    )\n",
                "    assert len(calls) == 2\n",
                "\n",
                "\n",
                "async def test_two_conditions_with_and(hass, calls):\n",
                "    \"\"\"Test two and conditions.\"\"\"\n",
                "    entity_id = \"test.entity\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"trigger\": [{\"platform\": \"event\", \"event_type\": \"test_event\"}],\n",
                "                \"condition\": [\n",
                "                    {\"condition\": \"state\", \"entity_id\": entity_id, \"state\": \"100\"},\n",
                "                    {\n",
                "                        \"condition\": \"numeric_state\",\n",
                "                        \"entity_id\": entity_id,\n",
                "                        \"below\": 150,\n",
                "                    },\n",
                "                ],\n",
                "                \"action\": {\"service\": \"test.automation\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    hass.states.async_set(entity_id, 100)\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "    hass.states.async_set(entity_id, 101)\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "    hass.states.async_set(entity_id, 151)\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "\n",
                "async def test_automation_list_setting(hass, calls):\n",
                "    \"\"\"Event is not a valid condition.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: [\n",
                "                {\n",
                "                    \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                    \"action\": {\"service\": \"test.automation\"},\n",
                "                },\n",
                "                {\n",
                "                    \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event_2\"},\n",
                "                    \"action\": {\"service\": \"test.automation\"},\n",
                "                },\n",
                "            ]\n",
                "        },\n",
                "    )\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "    hass.bus.async_fire(\"test_event_2\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 2\n",
                "\n",
                "\n",
                "async def test_automation_calling_two_actions(hass, calls):\n",
                "    \"\"\"Test if we can call two actions from automation async definition.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": [\n",
                "                    {\"service\": \"test.automation\", \"data\": {\"position\": 0}},\n",
                "                    {\"service\": \"test.automation\", \"data\": {\"position\": 1}},\n",
                "                ],\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(calls) == 2\n",
                "    assert calls[0].data[\"position\"] == 0\n",
                "    assert calls[1].data[\"position\"] == 1\n",
                "\n",
                "\n",
                "async def test_shared_context(hass, calls):\n",
                "    \"\"\"Test that the shared context is passed down the chain.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: [\n",
                "                {\n",
                "                    \"alias\": \"hello\",\n",
                "                    \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                    \"action\": {\"event\": \"test_event2\"},\n",
                "                },\n",
                "                {\n",
                "                    \"alias\": \"bye\",\n",
                "                    \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event2\"},\n",
                "                    \"action\": {\"service\": \"test.automation\"},\n",
                "                },\n",
                "            ]\n",
                "        },\n",
                "    )\n",
                "\n",
                "    context = Context()\n",
                "    first_automation_listener = Mock()\n",
                "    event_mock = Mock()\n",
                "\n",
                "    hass.bus.async_listen(\"test_event2\", first_automation_listener)\n",
                "    hass.bus.async_listen(EVENT_AUTOMATION_TRIGGERED, event_mock)\n",
                "    hass.bus.async_fire(\"test_event\", context=context)\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    # Ensure events was fired\n",
                "    assert first_automation_listener.call_count == 1\n",
                "    assert event_mock.call_count == 2\n",
                "\n",
                "    # Verify automation triggered evenet for 'hello' automation\n",
                "    args, _ = event_mock.call_args_list[0]\n",
                "    first_trigger_context = args[0].context\n",
                "    assert first_trigger_context.parent_id == context.id\n",
                "    # Ensure event data has all attributes set\n",
                "    assert args[0].data.get(ATTR_NAME) is not None\n",
                "    assert args[0].data.get(ATTR_ENTITY_ID) is not None\n",
                "\n",
                "    # Ensure context set correctly for event fired by 'hello' automation\n",
                "    args, _ = first_automation_listener.call_args\n",
                "    assert args[0].context is first_trigger_context\n",
                "\n",
                "    # Ensure the 'hello' automation state has the right context\n",
                "    state = hass.states.get(\"automation.hello\")\n",
                "    assert state is not None\n",
                "    assert state.context is first_trigger_context\n",
                "\n",
                "    # Verify automation triggered evenet for 'bye' automation\n",
                "    args, _ = event_mock.call_args_list[1]\n",
                "    second_trigger_context = args[0].context\n",
                "    assert second_trigger_context.parent_id == first_trigger_context.id\n",
                "    # Ensure event data has all attributes set\n",
                "    assert args[0].data.get(ATTR_NAME) is not None\n",
                "    assert args[0].data.get(ATTR_ENTITY_ID) is not None\n",
                "\n",
                "    # Ensure the service call from the second automation\n",
                "    # shares the same context\n",
                "    assert len(calls) == 1\n",
                "    assert calls[0].context is second_trigger_context\n",
                "\n",
                "\n",
                "async def test_services(hass, calls):\n",
                "    \"\"\"Test the automation services for turning entities on/off.\"\"\"\n",
                "    entity_id = \"automation.hello\"\n",
                "\n",
                "    assert hass.states.get(entity_id) is None\n",
                "    assert not automation.is_on(hass, entity_id)\n",
                "\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    assert hass.states.get(entity_id) is not None\n",
                "    assert automation.is_on(hass, entity_id)\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "    await common.async_turn_off(hass, entity_id)\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert not automation.is_on(hass, entity_id)\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "    await common.async_toggle(hass, entity_id)\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert automation.is_on(hass, entity_id)\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 2\n",
                "\n",
                "    await common.async_trigger(hass, entity_id)\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 3\n",
                "\n",
                "    await common.async_turn_off(hass, entity_id)\n",
                "    await hass.async_block_till_done()\n",
                "    await common.async_trigger(hass, entity_id)\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 4\n",
                "\n",
                "    await common.async_turn_on(hass, entity_id)\n",
                "    await hass.async_block_till_done()\n",
                "    assert automation.is_on(hass, entity_id)\n",
                "\n",
                "\n",
                "async def test_reload_config_service(hass, calls, hass_admin_user, hass_read_only_user):\n",
                "    \"\"\"Test the reload config service.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\n",
                "                    \"service\": \"test.automation\",\n",
                "                    \"data_template\": {\"event\": \"{{ trigger.event.event_type }}\"},\n",
                "                },\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "    assert hass.states.get(\"automation.hello\") is not None\n",
                "    assert hass.states.get(\"automation.bye\") is None\n",
                "    listeners = hass.bus.async_listeners()\n",
                "    assert listeners.get(\"test_event\") == 1\n",
                "    assert listeners.get(\"test_event2\") is None\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(calls) == 1\n",
                "    assert calls[0].data.get(\"event\") == \"test_event\"\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    test_reload_event = []\n",
                    "    hass.bus.async_listen(\n",
                    "        EVENT_AUTOMATION_RELOADED, lambda event: test_reload_event.append(event)\n",
                    "    )\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 485,
                    "end": 485
                },
                "child_version_range": {
                    "start": 485,
                    "end": 490
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_reload_config_service",
                        "signature": "def test_reload_config_service(hass, calls, hass_admin_user, hass_read_only_user):",
                        "at_line": 457
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: tests/components/automation/test_init.py\nCode:\n           def test_reload_config_service(hass, calls, hass_admin_user, hass_read_only_user):\n               ...\n482 482        assert len(calls) == 1\n483 483        assert calls[0].data.get(\"event\") == \"test_event\"\n484 484    \n    485  +     test_reload_event = []\n    486  +     hass.bus.async_listen(\n    487  +         EVENT_AUTOMATION_RELOADED, lambda event: test_reload_event.append(event)\n    488  +     )\n    489  + \n485 490        with patch(\n486 491            \"homeassistant.config.load_yaml_config_file\",\n487 492            autospec=True,\n         ...\n",
                "file_path": "tests/components/automation/test_init.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "EVENT_AUTOMATION_RELOADED",
                    "append",
                    "async_listen",
                    "bus",
                    "event",
                    "hass",
                    "test_reload_event"
                ],
                "prefix": [
                    "    assert len(calls) == 1\n",
                    "    assert calls[0].data.get(\"event\") == \"test_event\"\n",
                    "\n"
                ],
                "suffix": [
                    "    with patch(\n",
                    "        \"homeassistant.config.load_yaml_config_file\",\n",
                    "        autospec=True,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "EVENT_AUTOMATION_RELOADED",
                            "position": {
                                "start": {
                                    "line": 487,
                                    "column": 8
                                },
                                "end": {
                                    "line": 487,
                                    "column": 33
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/automation/test_init.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "EVENT_AUTOMATION_RELOADED",
                            "position": {
                                "start": {
                                    "line": 487,
                                    "column": 8
                                },
                                "end": {
                                    "line": 487,
                                    "column": 33
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/automation/test_init.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "test_reload_event",
                            "position": {
                                "start": {
                                    "line": 485,
                                    "column": 4
                                },
                                "end": {
                                    "line": 485,
                                    "column": 21
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/automation/test_init.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    8
                ]
            },
            [
                "    with patch(\n",
                "        \"homeassistant.config.load_yaml_config_file\",\n",
                "        autospec=True,\n",
                "        return_value={\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"bye\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event2\"},\n",
                "                \"action\": {\n",
                "                    \"service\": \"test.automation\",\n",
                "                    \"data_template\": {\"event\": \"{{ trigger.event.event_type }}\"},\n",
                "                },\n",
                "            }\n",
                "        },\n",
                "    ):\n",
                "        with pytest.raises(Unauthorized):\n",
                "            await common.async_reload(hass, Context(user_id=hass_read_only_user.id))\n",
                "            await hass.async_block_till_done()\n",
                "        await common.async_reload(hass, Context(user_id=hass_admin_user.id))\n",
                "        await hass.async_block_till_done()\n",
                "        # De-flake ?!\n",
                "        await hass.async_block_till_done()\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    assert len(test_reload_event) == 1\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 507,
                    "end": 507
                },
                "child_version_range": {
                    "start": 512,
                    "end": 514
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_reload_config_service",
                        "signature": "def test_reload_config_service(hass, calls, hass_admin_user, hass_read_only_user):",
                        "at_line": 457
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: tests/components/automation/test_init.py\nCode:\n           def test_reload_config_service(hass, calls, hass_admin_user, hass_read_only_user):\n               ...\n504 509            # De-flake ?!\n505 510            await hass.async_block_till_done()\n506 511    \n    512  +     assert len(test_reload_event) == 1\n    513  + \n507 514        assert hass.states.get(\"automation.hello\") is None\n508 515        assert hass.states.get(\"automation.bye\") is not None\n509 516        listeners = hass.bus.async_listeners()\n         ...\n",
                "file_path": "tests/components/automation/test_init.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "len",
                    "test_reload_event"
                ],
                "prefix": [
                    "        # De-flake ?!\n",
                    "        await hass.async_block_till_done()\n",
                    "\n"
                ],
                "suffix": [
                    "    assert hass.states.get(\"automation.hello\") is None\n",
                    "    assert hass.states.get(\"automation.bye\") is not None\n",
                    "    listeners = hass.bus.async_listeners()\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "test_reload_event",
                            "position": {
                                "start": {
                                    "line": 512,
                                    "column": 15
                                },
                                "end": {
                                    "line": 512,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/automation/test_init.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    9,
                    10
                ]
            },
            [
                "    assert hass.states.get(\"automation.hello\") is None\n",
                "    assert hass.states.get(\"automation.bye\") is not None\n",
                "    listeners = hass.bus.async_listeners()\n",
                "    assert listeners.get(\"test_event\") is None\n",
                "    assert listeners.get(\"test_event2\") == 1\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "    hass.bus.async_fire(\"test_event2\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 2\n",
                "    assert calls[1].data.get(\"event\") == \"test_event2\"\n",
                "\n",
                "\n",
                "async def test_reload_config_when_invalid_config(hass, calls):\n",
                "    \"\"\"Test the reload config service handling invalid config.\"\"\"\n",
                "    with assert_setup_component(1, automation.DOMAIN):\n",
                "        assert await async_setup_component(\n",
                "            hass,\n",
                "            automation.DOMAIN,\n",
                "            {\n",
                "                automation.DOMAIN: {\n",
                "                    \"alias\": \"hello\",\n",
                "                    \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                    \"action\": {\n",
                "                        \"service\": \"test.automation\",\n",
                "                        \"data_template\": {\"event\": \"{{ trigger.event.event_type }}\"},\n",
                "                    },\n",
                "                }\n",
                "            },\n",
                "        )\n",
                "    assert hass.states.get(\"automation.hello\") is not None\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(calls) == 1\n",
                "    assert calls[0].data.get(\"event\") == \"test_event\"\n",
                "\n",
                "    with patch(\n",
                "        \"homeassistant.config.load_yaml_config_file\",\n",
                "        autospec=True,\n",
                "        return_value={automation.DOMAIN: \"not valid\"},\n",
                "    ):\n",
                "        await common.async_reload(hass)\n",
                "        await hass.async_block_till_done()\n",
                "\n",
                "    assert hass.states.get(\"automation.hello\") is None\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "\n",
                "async def test_reload_config_handles_load_fails(hass, calls):\n",
                "    \"\"\"Test the reload config service.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\n",
                "                    \"service\": \"test.automation\",\n",
                "                    \"data_template\": {\"event\": \"{{ trigger.event.event_type }}\"},\n",
                "                },\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "    assert hass.states.get(\"automation.hello\") is not None\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(calls) == 1\n",
                "    assert calls[0].data.get(\"event\") == \"test_event\"\n",
                "\n",
                "    with patch(\n",
                "        \"homeassistant.config.load_yaml_config_file\",\n",
                "        side_effect=HomeAssistantError(\"bla\"),\n",
                "    ):\n",
                "        await common.async_reload(hass)\n",
                "        await hass.async_block_till_done()\n",
                "\n",
                "    assert hass.states.get(\"automation.hello\") is not None\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 2\n",
                "\n",
                "\n",
                "async def test_automation_restore_state(hass):\n",
                "    \"\"\"Ensure states are restored on startup.\"\"\"\n",
                "    time = dt_util.utcnow()\n",
                "\n",
                "    mock_restore_cache(\n",
                "        hass,\n",
                "        (\n",
                "            State(\"automation.hello\", STATE_ON),\n",
                "            State(\"automation.bye\", STATE_OFF, {\"last_triggered\": time}),\n",
                "        ),\n",
                "    )\n",
                "\n",
                "    config = {\n",
                "        automation.DOMAIN: [\n",
                "            {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event_hello\"},\n",
                "                \"action\": {\"service\": \"test.automation\"},\n",
                "            },\n",
                "            {\n",
                "                \"alias\": \"bye\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event_bye\"},\n",
                "                \"action\": {\"service\": \"test.automation\"},\n",
                "            },\n",
                "        ]\n",
                "    }\n",
                "\n",
                "    assert await async_setup_component(hass, automation.DOMAIN, config)\n",
                "\n",
                "    state = hass.states.get(\"automation.hello\")\n",
                "    assert state\n",
                "    assert state.state == STATE_ON\n",
                "    assert state.attributes[\"last_triggered\"] is None\n",
                "\n",
                "    state = hass.states.get(\"automation.bye\")\n",
                "    assert state\n",
                "    assert state.state == STATE_OFF\n",
                "    assert state.attributes[\"last_triggered\"] == time\n",
                "\n",
                "    calls = async_mock_service(hass, \"test\", \"automation\")\n",
                "\n",
                "    assert automation.is_on(hass, \"automation.bye\") is False\n",
                "\n",
                "    hass.bus.async_fire(\"test_event_bye\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 0\n",
                "\n",
                "    assert automation.is_on(hass, \"automation.hello\")\n",
                "\n",
                "    hass.bus.async_fire(\"test_event_hello\")\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(calls) == 1\n",
                "\n",
                "\n",
                "async def test_initial_value_off(hass):\n",
                "    \"\"\"Test initial value off.\"\"\"\n",
                "    calls = async_mock_service(hass, \"test\", \"automation\")\n",
                "\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"initial_state\": \"off\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\", \"entity_id\": \"hello.world\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "    assert not automation.is_on(hass, \"automation.hello\")\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 0\n",
                "\n",
                "\n",
                "async def test_initial_value_on(hass):\n",
                "    \"\"\"Test initial value on.\"\"\"\n",
                "    hass.state = CoreState.not_running\n",
                "    calls = async_mock_service(hass, \"test\", \"automation\")\n",
                "\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"initial_state\": \"on\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\n",
                "                    \"service\": \"test.automation\",\n",
                "                    \"entity_id\": [\"hello.world\", \"hello.world2\"],\n",
                "                },\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "    assert automation.is_on(hass, \"automation.hello\")\n",
                "\n",
                "    await hass.async_start()\n",
                "    await hass.async_block_till_done()\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "\n",
                "async def test_initial_value_off_but_restore_on(hass):\n",
                "    \"\"\"Test initial value off and restored state is turned on.\"\"\"\n",
                "    hass.state = CoreState.not_running\n",
                "    calls = async_mock_service(hass, \"test\", \"automation\")\n",
                "    mock_restore_cache(hass, (State(\"automation.hello\", STATE_ON),))\n",
                "\n",
                "    await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"initial_state\": \"off\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\", \"entity_id\": \"hello.world\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "    assert not automation.is_on(hass, \"automation.hello\")\n",
                "\n",
                "    await hass.async_start()\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 0\n",
                "\n",
                "\n",
                "async def test_initial_value_on_but_restore_off(hass):\n",
                "    \"\"\"Test initial value on and restored state is turned off.\"\"\"\n",
                "    calls = async_mock_service(hass, \"test\", \"automation\")\n",
                "    mock_restore_cache(hass, (State(\"automation.hello\", STATE_OFF),))\n",
                "\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"initial_state\": \"on\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\", \"entity_id\": \"hello.world\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "    assert automation.is_on(hass, \"automation.hello\")\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "\n",
                "async def test_no_initial_value_and_restore_off(hass):\n",
                "    \"\"\"Test initial value off and restored state is turned on.\"\"\"\n",
                "    calls = async_mock_service(hass, \"test\", \"automation\")\n",
                "    mock_restore_cache(hass, (State(\"automation.hello\", STATE_OFF),))\n",
                "\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\", \"entity_id\": \"hello.world\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "    assert not automation.is_on(hass, \"automation.hello\")\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 0\n",
                "\n",
                "\n",
                "async def test_automation_is_on_if_no_initial_state_or_restore(hass):\n",
                "    \"\"\"Test initial value is on when no initial state or restored state.\"\"\"\n",
                "    calls = async_mock_service(hass, \"test\", \"automation\")\n",
                "\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\", \"entity_id\": \"hello.world\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "    assert automation.is_on(hass, \"automation.hello\")\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 1\n",
                "\n",
                "\n",
                "async def test_automation_not_trigger_on_bootstrap(hass):\n",
                "    \"\"\"Test if automation is not trigger on bootstrap.\"\"\"\n",
                "    hass.state = CoreState.not_running\n",
                "    calls = async_mock_service(hass, \"test\", \"automation\")\n",
                "\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\", \"entity_id\": \"hello.world\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "    assert automation.is_on(hass, \"automation.hello\")\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(calls) == 0\n",
                "\n",
                "    hass.bus.async_fire(EVENT_HOMEASSISTANT_STARTED)\n",
                "    await hass.async_block_till_done()\n",
                "    assert automation.is_on(hass, \"automation.hello\")\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(calls) == 1\n",
                "    assert [\"hello.world\"] == calls[0].data.get(ATTR_ENTITY_ID)\n",
                "\n",
                "\n",
                "async def test_automation_with_error_in_script(hass, caplog):\n",
                "    \"\"\"Test automation with an error in script.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\", \"entity_id\": \"hello.world\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert \"Service not found\" in caplog.text\n",
                "\n",
                "\n",
                "async def test_automation_with_error_in_script_2(hass, caplog):\n",
                "    \"\"\"Test automation with an error in script.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        automation.DOMAIN,\n",
                "        {\n",
                "            automation.DOMAIN: {\n",
                "                \"alias\": \"hello\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": None, \"entity_id\": \"hello.world\"},\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    hass.bus.async_fire(\"test_event\")\n",
                "    await hass.async_block_till_done()\n",
                "    assert \"string value is None\" in caplog.text\n",
                "\n",
                "\n",
                "async def test_automation_restore_last_triggered_with_initial_state(hass):\n",
                "    \"\"\"Ensure last_triggered is restored, even when initial state is set.\"\"\"\n",
                "    time = dt_util.utcnow()\n",
                "\n",
                "    mock_restore_cache(\n",
                "        hass,\n",
                "        (\n",
                "            State(\"automation.hello\", STATE_ON),\n",
                "            State(\"automation.bye\", STATE_ON, {\"last_triggered\": time}),\n",
                "            State(\"automation.solong\", STATE_OFF, {\"last_triggered\": time}),\n",
                "        ),\n",
                "    )\n",
                "\n",
                "    config = {\n",
                "        automation.DOMAIN: [\n",
                "            {\n",
                "                \"alias\": \"hello\",\n",
                "                \"initial_state\": \"off\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\"},\n",
                "            },\n",
                "            {\n",
                "                \"alias\": \"bye\",\n",
                "                \"initial_state\": \"off\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\"},\n",
                "            },\n",
                "            {\n",
                "                \"alias\": \"solong\",\n",
                "                \"initial_state\": \"on\",\n",
                "                \"trigger\": {\"platform\": \"event\", \"event_type\": \"test_event\"},\n",
                "                \"action\": {\"service\": \"test.automation\"},\n",
                "            },\n",
                "        ]\n",
                "    }\n",
                "\n",
                "    await async_setup_component(hass, automation.DOMAIN, config)\n",
                "\n",
                "    state = hass.states.get(\"automation.hello\")\n",
                "    assert state\n",
                "    assert state.state == STATE_OFF\n",
                "    assert state.attributes[\"last_triggered\"] is None\n",
                "\n",
                "    state = hass.states.get(\"automation.bye\")\n",
                "    assert state\n",
                "    assert state.state == STATE_OFF\n",
                "    assert state.attributes[\"last_triggered\"] == time\n",
                "\n",
                "    state = hass.states.get(\"automation.solong\")\n",
                "    assert state\n",
                "    assert state.state == STATE_ON\n",
                "    assert state.attributes[\"last_triggered\"] == time\n",
                "\n",
                "\n",
                "async def test_extraction_functions(hass):\n",
                "    \"\"\"Test extraction functions.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        DOMAIN,\n",
                "        {\n",
                "            DOMAIN: [\n",
                "                {\n",
                "                    \"alias\": \"test1\",\n",
                "                    \"trigger\": {\"platform\": \"state\", \"entity_id\": \"sensor.trigger_1\"},\n",
                "                    \"condition\": {\n",
                "                        \"condition\": \"state\",\n",
                "                        \"entity_id\": \"light.condition_state\",\n",
                "                        \"state\": \"on\",\n",
                "                    },\n",
                "                    \"action\": [\n",
                "                        {\n",
                "                            \"service\": \"test.script\",\n",
                "                            \"data\": {\"entity_id\": \"light.in_both\"},\n",
                "                        },\n",
                "                        {\n",
                "                            \"service\": \"test.script\",\n",
                "                            \"data\": {\"entity_id\": \"light.in_first\"},\n",
                "                        },\n",
                "                        {\n",
                "                            \"domain\": \"light\",\n",
                "                            \"device_id\": \"device-in-both\",\n",
                "                            \"entity_id\": \"light.bla\",\n",
                "                            \"type\": \"turn_on\",\n",
                "                        },\n",
                "                    ],\n",
                "                },\n",
                "                {\n",
                "                    \"alias\": \"test2\",\n",
                "                    \"trigger\": {\n",
                "                        \"platform\": \"device\",\n",
                "                        \"domain\": \"light\",\n",
                "                        \"type\": \"turned_on\",\n",
                "                        \"entity_id\": \"light.trigger_2\",\n",
                "                        \"device_id\": \"trigger-device-2\",\n",
                "                    },\n",
                "                    \"condition\": {\n",
                "                        \"condition\": \"device\",\n",
                "                        \"device_id\": \"condition-device\",\n",
                "                        \"domain\": \"light\",\n",
                "                        \"type\": \"is_on\",\n",
                "                        \"entity_id\": \"light.bla\",\n",
                "                    },\n",
                "                    \"action\": [\n",
                "                        {\n",
                "                            \"service\": \"test.script\",\n",
                "                            \"data\": {\"entity_id\": \"light.in_both\"},\n",
                "                        },\n",
                "                        {\n",
                "                            \"condition\": \"state\",\n",
                "                            \"entity_id\": \"sensor.condition\",\n",
                "                            \"state\": \"100\",\n",
                "                        },\n",
                "                        {\"scene\": \"scene.hello\"},\n",
                "                        {\n",
                "                            \"domain\": \"light\",\n",
                "                            \"device_id\": \"device-in-both\",\n",
                "                            \"entity_id\": \"light.bla\",\n",
                "                            \"type\": \"turn_on\",\n",
                "                        },\n",
                "                        {\n",
                "                            \"domain\": \"light\",\n",
                "                            \"device_id\": \"device-in-last\",\n",
                "                            \"entity_id\": \"light.bla\",\n",
                "                            \"type\": \"turn_on\",\n",
                "                        },\n",
                "                    ],\n",
                "                },\n",
                "            ]\n",
                "        },\n",
                "    )\n",
                "\n",
                "    assert set(automation.automations_with_entity(hass, \"light.in_both\")) == {\n",
                "        \"automation.test1\",\n",
                "        \"automation.test2\",\n",
                "    }\n",
                "    assert set(automation.entities_in_automation(hass, \"automation.test1\")) == {\n",
                "        \"sensor.trigger_1\",\n",
                "        \"light.condition_state\",\n",
                "        \"light.in_both\",\n",
                "        \"light.in_first\",\n",
                "    }\n",
                "    assert set(automation.automations_with_device(hass, \"device-in-both\")) == {\n",
                "        \"automation.test1\",\n",
                "        \"automation.test2\",\n",
                "    }\n",
                "    assert set(automation.devices_in_automation(hass, \"automation.test2\")) == {\n",
                "        \"trigger-device-2\",\n",
                "        \"condition-device\",\n",
                "        \"device-in-both\",\n",
                "        \"device-in-last\",\n",
                "    }"
            ]
        ],
        "tests/components/homeassistant/test_scene.py": [
            [
                "\"\"\"Test Home Assistant scenes.\"\"\"\n",
                "import pytest\n",
                "import voluptuous as vol\n",
                "\n",
                "from homeassistant.components.homeassistant import scene as ha_scene\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "from homeassistant.components.homeassistant.scene import EVENT_SCENE_RELOADED\n"
                ],
                "parent_version_range": {
                    "start": 5,
                    "end": 5
                },
                "child_version_range": {
                    "start": 5,
                    "end": 6
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 7,
                "hunk_diff": "File: tests/components/homeassistant/test_scene.py\nCode:\n  ...\n2 2    import voluptuous as vol\n3 3    \n4 4    from homeassistant.components.homeassistant import scene as ha_scene\n  5  + from homeassistant.components.homeassistant.scene import EVENT_SCENE_RELOADED\n5 6    from homeassistant.setup import async_setup_component\n6 7    \n7 8    from tests.async_mock import patch\n     ...\n",
                "file_path": "tests/components/homeassistant/test_scene.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "EVENT_SCENE_RELOADED",
                    "components",
                    "homeassistant",
                    "scene"
                ],
                "prefix": [
                    "import voluptuous as vol\n",
                    "\n",
                    "from homeassistant.components.homeassistant import scene as ha_scene\n"
                ],
                "suffix": [
                    "from homeassistant.setup import async_setup_component\n",
                    "\n",
                    "from tests.async_mock import patch\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "EVENT_SCENE_RELOADED",
                            "position": {
                                "start": {
                                    "line": 5,
                                    "column": 57
                                },
                                "end": {
                                    "line": 5,
                                    "column": 77
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/homeassistant/test_scene.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 8,
                        "detail": {
                            "identifier": "EVENT_SCENE_RELOADED",
                            "position": {
                                "start": {
                                    "line": 5,
                                    "column": 57
                                },
                                "end": {
                                    "line": 5,
                                    "column": 77
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/homeassistant/test_scene.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "from homeassistant.setup import async_setup_component\n",
                "\n",
                "from tests.async_mock import patch\n",
                "from tests.common import async_mock_service\n",
                "\n",
                "\n",
                "async def test_reload_config_service(hass):\n",
                "    \"\"\"Test the reload config service.\"\"\"\n",
                "    assert await async_setup_component(hass, \"scene\", {})\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    test_reloaded_event = []\n",
                    "    hass.bus.async_listen(\n",
                    "        EVENT_SCENE_RELOADED, lambda event: test_reloaded_event.append(event)\n",
                    "    )\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 15,
                    "end": 15
                },
                "child_version_range": {
                    "start": 16,
                    "end": 21
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_reload_config_service",
                        "signature": "def test_reload_config_service(hass):",
                        "at_line": 11
                    }
                ],
                "idx": 8,
                "hunk_diff": "File: tests/components/homeassistant/test_scene.py\nCode:\n         def test_reload_config_service(hass):\n             ...\n12 13        \"\"\"Test the reload config service.\"\"\"\n13 14        assert await async_setup_component(hass, \"scene\", {})\n14 15    \n   16  +     test_reloaded_event = []\n   17  +     hass.bus.async_listen(\n   18  +         EVENT_SCENE_RELOADED, lambda event: test_reloaded_event.append(event)\n   19  +     )\n   20  + \n15 21        with patch(\n16 22            \"homeassistant.config.load_yaml_config_file\",\n17 23            autospec=True,\n       ...\n",
                "file_path": "tests/components/homeassistant/test_scene.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "EVENT_SCENE_RELOADED",
                    "append",
                    "async_listen",
                    "bus",
                    "event",
                    "hass",
                    "test_reloaded_event"
                ],
                "prefix": [
                    "    \"\"\"Test the reload config service.\"\"\"\n",
                    "    assert await async_setup_component(hass, \"scene\", {})\n",
                    "\n"
                ],
                "suffix": [
                    "    with patch(\n",
                    "        \"homeassistant.config.load_yaml_config_file\",\n",
                    "        autospec=True,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "EVENT_SCENE_RELOADED",
                            "position": {
                                "start": {
                                    "line": 18,
                                    "column": 8
                                },
                                "end": {
                                    "line": 18,
                                    "column": 28
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/homeassistant/test_scene.py",
                            "hunk_idx": 8,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "EVENT_SCENE_RELOADED",
                            "position": {
                                "start": {
                                    "line": 18,
                                    "column": 8
                                },
                                "end": {
                                    "line": 18,
                                    "column": 28
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/homeassistant/test_scene.py",
                            "hunk_idx": 8,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 9,
                        "detail": {
                            "identifier": "test_reloaded_event",
                            "position": {
                                "start": {
                                    "line": 16,
                                    "column": 4
                                },
                                "end": {
                                    "line": 16,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/homeassistant/test_scene.py",
                            "hunk_idx": 8,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 10,
                        "detail": {
                            "identifier": "test_reloaded_event",
                            "position": {
                                "start": {
                                    "line": 16,
                                    "column": 4
                                },
                                "end": {
                                    "line": 16,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/homeassistant/test_scene.py",
                            "hunk_idx": 8,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    5
                ]
            },
            [
                "    with patch(\n",
                "        \"homeassistant.config.load_yaml_config_file\",\n",
                "        autospec=True,\n",
                "        return_value={\"scene\": {\"name\": \"Hallo\", \"entities\": {\"light.kitchen\": \"on\"}}},\n",
                "    ):\n",
                "        await hass.services.async_call(\"scene\", \"reload\", blocking=True)\n",
                "        await hass.async_block_till_done()\n",
                "\n",
                "    assert hass.states.get(\"scene.hallo\") is not None\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    assert len(test_reloaded_event) == 1\n"
                ],
                "parent_version_range": {
                    "start": 24,
                    "end": 24
                },
                "child_version_range": {
                    "start": 30,
                    "end": 31
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_reload_config_service",
                        "signature": "def test_reload_config_service(hass):",
                        "at_line": 11
                    }
                ],
                "idx": 9,
                "hunk_diff": "File: tests/components/homeassistant/test_scene.py\nCode:\n         def test_reload_config_service(hass):\n             ...\n21 27            await hass.async_block_till_done()\n22 28    \n23 29        assert hass.states.get(\"scene.hallo\") is not None\n   30  +     assert len(test_reloaded_event) == 1\n24 31    \n25 32        with patch(\n26 33            \"homeassistant.config.load_yaml_config_file\",\n       ...\n",
                "file_path": "tests/components/homeassistant/test_scene.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "len",
                    "test_reloaded_event"
                ],
                "prefix": [
                    "        await hass.async_block_till_done()\n",
                    "\n",
                    "    assert hass.states.get(\"scene.hallo\") is not None\n"
                ],
                "suffix": [
                    "\n",
                    "    with patch(\n",
                    "        \"homeassistant.config.load_yaml_config_file\",\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 8,
                        "detail": {
                            "identifier": "test_reloaded_event",
                            "position": {
                                "start": {
                                    "line": 30,
                                    "column": 15
                                },
                                "end": {
                                    "line": 30,
                                    "column": 34
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/homeassistant/test_scene.py",
                            "hunk_idx": 9,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    6,
                    10
                ]
            },
            [
                "\n",
                "    with patch(\n",
                "        \"homeassistant.config.load_yaml_config_file\",\n",
                "        autospec=True,\n",
                "        return_value={\"scene\": {\"name\": \"Bye\", \"entities\": {\"light.kitchen\": \"on\"}}},\n",
                "    ):\n",
                "        await hass.services.async_call(\"scene\", \"reload\", blocking=True)\n",
                "        await hass.async_block_till_done()\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    assert len(test_reloaded_event) == 2\n"
                ],
                "parent_version_range": {
                    "start": 33,
                    "end": 33
                },
                "child_version_range": {
                    "start": 40,
                    "end": 41
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_reload_config_service",
                        "signature": "def test_reload_config_service(hass):",
                        "at_line": 11
                    }
                ],
                "idx": 10,
                "hunk_diff": "File: tests/components/homeassistant/test_scene.py\nCode:\n         def test_reload_config_service(hass):\n             ...\n30 37            await hass.services.async_call(\"scene\", \"reload\", blocking=True)\n31 38            await hass.async_block_till_done()\n32 39    \n   40  +     assert len(test_reloaded_event) == 2\n33 41        assert hass.states.get(\"scene.hallo\") is None\n34 42        assert hass.states.get(\"scene.bye\") is not None\n35 43    \n       ...\n",
                "file_path": "tests/components/homeassistant/test_scene.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "len",
                    "test_reloaded_event"
                ],
                "prefix": [
                    "        await hass.services.async_call(\"scene\", \"reload\", blocking=True)\n",
                    "        await hass.async_block_till_done()\n",
                    "\n"
                ],
                "suffix": [
                    "    assert hass.states.get(\"scene.hallo\") is None\n",
                    "    assert hass.states.get(\"scene.bye\") is not None\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 8,
                        "detail": {
                            "identifier": "test_reloaded_event",
                            "position": {
                                "start": {
                                    "line": 40,
                                    "column": 15
                                },
                                "end": {
                                    "line": 40,
                                    "column": 34
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/homeassistant/test_scene.py",
                            "hunk_idx": 10,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    6,
                    9
                ]
            },
            [
                "    assert hass.states.get(\"scene.hallo\") is None\n",
                "    assert hass.states.get(\"scene.bye\") is not None\n",
                "\n",
                "\n",
                "async def test_apply_service(hass):\n",
                "    \"\"\"Test the apply service.\"\"\"\n",
                "    assert await async_setup_component(hass, \"scene\", {})\n",
                "    assert await async_setup_component(hass, \"light\", {\"light\": {\"platform\": \"demo\"}})\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\", \"apply\", {\"entities\": {\"light.bed_light\": \"off\"}}, blocking=True\n",
                "    )\n",
                "\n",
                "    assert hass.states.get(\"light.bed_light\").state == \"off\"\n",
                "\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\",\n",
                "        \"apply\",\n",
                "        {\"entities\": {\"light.bed_light\": {\"state\": \"on\", \"brightness\": 50}}},\n",
                "        blocking=True,\n",
                "    )\n",
                "\n",
                "    state = hass.states.get(\"light.bed_light\")\n",
                "    assert state.state == \"on\"\n",
                "    assert state.attributes[\"brightness\"] == 50\n",
                "\n",
                "    turn_on_calls = async_mock_service(hass, \"light\", \"turn_on\")\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\",\n",
                "        \"apply\",\n",
                "        {\n",
                "            \"transition\": 42,\n",
                "            \"entities\": {\"light.bed_light\": {\"state\": \"on\", \"brightness\": 50}},\n",
                "        },\n",
                "        blocking=True,\n",
                "    )\n",
                "\n",
                "    assert len(turn_on_calls) == 1\n",
                "    assert turn_on_calls[0].domain == \"light\"\n",
                "    assert turn_on_calls[0].service == \"turn_on\"\n",
                "    assert turn_on_calls[0].data.get(\"transition\") == 42\n",
                "    assert turn_on_calls[0].data.get(\"entity_id\") == \"light.bed_light\"\n",
                "    assert turn_on_calls[0].data.get(\"brightness\") == 50\n",
                "\n",
                "\n",
                "async def test_create_service(hass, caplog):\n",
                "    \"\"\"Test the create service.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        \"scene\",\n",
                "        {\"scene\": {\"name\": \"hallo_2\", \"entities\": {\"light.kitchen\": \"on\"}}},\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "    assert hass.states.get(\"scene.hallo\") is None\n",
                "    assert hass.states.get(\"scene.hallo_2\") is not None\n",
                "\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\",\n",
                "        \"create\",\n",
                "        {\"scene_id\": \"hallo\", \"entities\": {}, \"snapshot_entities\": []},\n",
                "        blocking=True,\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "    assert \"Empty scenes are not allowed\" in caplog.text\n",
                "    assert hass.states.get(\"scene.hallo\") is None\n",
                "\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\",\n",
                "        \"create\",\n",
                "        {\n",
                "            \"scene_id\": \"hallo\",\n",
                "            \"entities\": {\"light.bed_light\": {\"state\": \"on\", \"brightness\": 50}},\n",
                "        },\n",
                "        blocking=True,\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    scene = hass.states.get(\"scene.hallo\")\n",
                "    assert scene is not None\n",
                "    assert scene.domain == \"scene\"\n",
                "    assert scene.name == \"hallo\"\n",
                "    assert scene.state == \"scening\"\n",
                "    assert scene.attributes.get(\"entity_id\") == [\"light.bed_light\"]\n",
                "\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\",\n",
                "        \"create\",\n",
                "        {\n",
                "            \"scene_id\": \"hallo\",\n",
                "            \"entities\": {\"light.kitchen_light\": {\"state\": \"on\", \"brightness\": 100}},\n",
                "        },\n",
                "        blocking=True,\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    scene = hass.states.get(\"scene.hallo\")\n",
                "    assert scene is not None\n",
                "    assert scene.domain == \"scene\"\n",
                "    assert scene.name == \"hallo\"\n",
                "    assert scene.state == \"scening\"\n",
                "    assert scene.attributes.get(\"entity_id\") == [\"light.kitchen_light\"]\n",
                "\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\",\n",
                "        \"create\",\n",
                "        {\n",
                "            \"scene_id\": \"hallo_2\",\n",
                "            \"entities\": {\"light.bed_light\": {\"state\": \"on\", \"brightness\": 50}},\n",
                "        },\n",
                "        blocking=True,\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert \"The scene scene.hallo_2 already exists\" in caplog.text\n",
                "    scene = hass.states.get(\"scene.hallo_2\")\n",
                "    assert scene is not None\n",
                "    assert scene.domain == \"scene\"\n",
                "    assert scene.name == \"hallo_2\"\n",
                "    assert scene.state == \"scening\"\n",
                "    assert scene.attributes.get(\"entity_id\") == [\"light.kitchen\"]\n",
                "\n",
                "\n",
                "async def test_snapshot_service(hass, caplog):\n",
                "    \"\"\"Test the snapshot option.\"\"\"\n",
                "    assert await async_setup_component(hass, \"scene\", {\"scene\": {}})\n",
                "    await hass.async_block_till_done()\n",
                "    hass.states.async_set(\"light.my_light\", \"on\", {\"hs_color\": (345, 75)})\n",
                "    assert hass.states.get(\"scene.hallo\") is None\n",
                "\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\",\n",
                "        \"create\",\n",
                "        {\"scene_id\": \"hallo\", \"snapshot_entities\": [\"light.my_light\"]},\n",
                "        blocking=True,\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "    scene = hass.states.get(\"scene.hallo\")\n",
                "    assert scene is not None\n",
                "    assert scene.attributes.get(\"entity_id\") == [\"light.my_light\"]\n",
                "\n",
                "    hass.states.async_set(\"light.my_light\", \"off\", {\"hs_color\": (123, 45)})\n",
                "    turn_on_calls = async_mock_service(hass, \"light\", \"turn_on\")\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\", \"turn_on\", {\"entity_id\": \"scene.hallo\"}, blocking=True\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "    assert len(turn_on_calls) == 1\n",
                "    assert turn_on_calls[0].data.get(\"entity_id\") == \"light.my_light\"\n",
                "    assert turn_on_calls[0].data.get(\"hs_color\") == (345, 75)\n",
                "\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\",\n",
                "        \"create\",\n",
                "        {\"scene_id\": \"hallo_2\", \"snapshot_entities\": [\"light.not_existent\"]},\n",
                "        blocking=True,\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "    assert hass.states.get(\"scene.hallo_2\") is None\n",
                "    assert (\n",
                "        \"Entity light.not_existent does not exist and therefore cannot be snapshotted\"\n",
                "        in caplog.text\n",
                "    )\n",
                "\n",
                "    assert await hass.services.async_call(\n",
                "        \"scene\",\n",
                "        \"create\",\n",
                "        {\n",
                "            \"scene_id\": \"hallo_3\",\n",
                "            \"entities\": {\"light.bed_light\": {\"state\": \"on\", \"brightness\": 50}},\n",
                "            \"snapshot_entities\": [\"light.my_light\"],\n",
                "        },\n",
                "        blocking=True,\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "    scene = hass.states.get(\"scene.hallo_3\")\n",
                "    assert scene is not None\n",
                "    assert \"light.my_light\" in scene.attributes.get(\"entity_id\")\n",
                "    assert \"light.bed_light\" in scene.attributes.get(\"entity_id\")\n",
                "\n",
                "\n",
                "async def test_ensure_no_intersection(hass):\n",
                "    \"\"\"Test that entities and snapshot_entities do not overlap.\"\"\"\n",
                "    assert await async_setup_component(hass, \"scene\", {\"scene\": {}})\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    with pytest.raises(vol.MultipleInvalid) as ex:\n",
                "        assert await hass.services.async_call(\n",
                "            \"scene\",\n",
                "            \"create\",\n",
                "            {\n",
                "                \"scene_id\": \"hallo\",\n",
                "                \"entities\": {\"light.my_light\": {\"state\": \"on\", \"brightness\": 50}},\n",
                "                \"snapshot_entities\": [\"light.my_light\"],\n",
                "            },\n",
                "            blocking=True,\n",
                "        )\n",
                "        await hass.async_block_till_done()\n",
                "    assert \"entities and snapshot_entities must not overlap\" in str(ex.value)\n",
                "    assert hass.states.get(\"scene.hallo\") is None\n",
                "\n",
                "\n",
                "async def test_scenes_with_entity(hass):\n",
                "    \"\"\"Test finding scenes with a specific entity.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        \"scene\",\n",
                "        {\n",
                "            \"scene\": [\n",
                "                {\"name\": \"scene_1\", \"entities\": {\"light.kitchen\": \"on\"}},\n",
                "                {\"name\": \"scene_2\", \"entities\": {\"light.living_room\": \"off\"}},\n",
                "                {\n",
                "                    \"name\": \"scene_3\",\n",
                "                    \"entities\": {\"light.kitchen\": \"on\", \"light.living_room\": \"off\"},\n",
                "                },\n",
                "            ]\n",
                "        },\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert sorted(ha_scene.scenes_with_entity(hass, \"light.kitchen\")) == [\n",
                "        \"scene.scene_1\",\n",
                "        \"scene.scene_3\",\n",
                "    ]\n",
                "\n",
                "\n",
                "async def test_entities_in_scene(hass):\n",
                "    \"\"\"Test finding entities in a scene.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        \"scene\",\n",
                "        {\n",
                "            \"scene\": [\n",
                "                {\"name\": \"scene_1\", \"entities\": {\"light.kitchen\": \"on\"}},\n",
                "                {\"name\": \"scene_2\", \"entities\": {\"light.living_room\": \"off\"}},\n",
                "                {\n",
                "                    \"name\": \"scene_3\",\n",
                "                    \"entities\": {\"light.kitchen\": \"on\", \"light.living_room\": \"off\"},\n",
                "                },\n",
                "            ]\n",
                "        },\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    for scene_id, entities in (\n",
                "        (\"scene.scene_1\", [\"light.kitchen\"]),\n",
                "        (\"scene.scene_2\", [\"light.living_room\"]),\n",
                "        (\"scene.scene_3\", [\"light.kitchen\", \"light.living_room\"]),\n",
                "    ):\n",
                "        assert ha_scene.entities_in_scene(hass, scene_id) == entities\n",
                "\n",
                "\n",
                "async def test_config(hass):\n",
                "    \"\"\"Test passing config in YAML.\"\"\"\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        \"scene\",\n",
                "        {\n",
                "            \"scene\": [\n",
                "                {\n",
                "                    \"id\": \"scene_id\",\n",
                "                    \"name\": \"Scene Icon\",\n",
                "                    \"icon\": \"mdi:party\",\n",
                "                    \"entities\": {\"light.kitchen\": \"on\"},\n",
                "                },\n",
                "                {\n",
                "                    \"name\": \"Scene No Icon\",\n",
                "                    \"entities\": {\"light.kitchen\": {\"state\": \"on\"}},\n",
                "                },\n",
                "            ]\n",
                "        },\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    icon = hass.states.get(\"scene.scene_icon\")\n",
                "    assert icon is not None\n",
                "    assert icon.attributes[\"icon\"] == \"mdi:party\"\n",
                "\n",
                "    no_icon = hass.states.get(\"scene.scene_no_icon\")\n",
                "    assert no_icon is not None\n",
                "    assert \"icon\" not in no_icon.attributes"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                0,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and import"
        },
        {
            "edit_hunk_pair": [
                0,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                1,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "Triggering and listening"
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                2,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "def and import"
        },
        {
            "edit_hunk_pair": [
                2,
                8
            ],
            "edit_order": "bi-directional",
            "reason": "def and import"
        },
        {
            "edit_hunk_pair": [
                3,
                8
            ],
            "edit_order": "bi-directional",
            "reason": "Triggering and listening"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                5,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                7,
                8
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                8,
                9
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                8,
                10
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                9,
                10
            ],
            "edit_order": "bi-directional",
            "reason": "clone"
        }
    ]
}