{
    "language": "python",
    "commit_url": "https://github.com/zulip/zulip/commit/96bfeeb9e604ef42ef30d699b00d1a23ff17d29c",
    "commit_message": "api docs: Expand checking for deprecated fields.\n\nAdded assertion to check that if a deprecated flag is in a field's\nschema, then it should have deprecated mentioned in description\nas well, and moved these checks to a separate function.\nFixes part of #15967.",
    "commit_snapshots": {
        "zerver/lib/markdown/api_arguments_table_generator.py": [
            [
                "import json\n",
                "import os\n",
                "import re\n",
                "from typing import Any, Dict, List, Mapping, Sequence\n",
                "\n",
                "import markdown\n",
                "from django.utils.html import escape as escape_html\n",
                "from markdown.extensions import Extension\n",
                "from markdown.preprocessors import Preprocessor\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "from zerver.openapi.openapi import get_openapi_parameters, likely_deprecated_parameter\n"
                ],
                "after": [
                    "from zerver.openapi.openapi import check_deprecated_consistency, get_openapi_parameters\n"
                ],
                "parent_version_range": {
                    "start": 10,
                    "end": 11
                },
                "child_version_range": {
                    "start": 10,
                    "end": 11
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 0,
                "hunk_diff": "File: zerver/lib/markdown/api_arguments_table_generator.py\nCode:\n  ...\n 7  7    from markdown.extensions import Extension\n 8  8    from markdown.preprocessors import Preprocessor\n 9  9    \n10     - from zerver.openapi.openapi import get_openapi_parameters, likely_deprecated_parameter\n   10  + from zerver.openapi.openapi import check_deprecated_consistency, get_openapi_parameters\n11 11    \n12 12    REGEXP = re.compile(r\"\\{generate_api_arguments_table\\|\\s*(.+?)\\s*\\|\\s*(.+)\\s*\\}\")\n13 13    \n       ...\n",
                "file_path": "zerver/lib/markdown/api_arguments_table_generator.py",
                "identifiers_before": [
                    "get_openapi_parameters",
                    "likely_deprecated_parameter",
                    "openapi",
                    "zerver"
                ],
                "identifiers_after": [
                    "check_deprecated_consistency",
                    "get_openapi_parameters",
                    "openapi",
                    "zerver"
                ],
                "prefix": [
                    "from markdown.extensions import Extension\n",
                    "from markdown.preprocessors import Preprocessor\n",
                    "\n"
                ],
                "suffix": [
                    "\n",
                    "REGEXP = re.compile(r\"\\{generate_api_arguments_table\\|\\s*(.+?)\\s*\\|\\s*(.+)\\s*\\}\")\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "likely_deprecated_parameter",
                            "position": {
                                "start": {
                                    "line": 10,
                                    "column": 59
                                },
                                "end": {
                                    "line": 10,
                                    "column": 86
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_arguments_table_generator.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 10,
                                    "column": 35
                                },
                                "end": {
                                    "line": 10,
                                    "column": 63
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_arguments_table_generator.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 10,
                                    "column": 35
                                },
                                "end": {
                                    "line": 10,
                                    "column": 63
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_arguments_table_generator.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    2
                ]
            },
            [
                "\n",
                "REGEXP = re.compile(r\"\\{generate_api_arguments_table\\|\\s*(.+?)\\s*\\|\\s*(.+)\\s*\\}\")\n",
                "\n",
                "\n",
                "class MarkdownArgumentsTableGenerator(Extension):\n",
                "    def __init__(self, configs: Mapping[str, Any] = {}) -> None:\n",
                "        self.config = {\n",
                "            \"base_path\": [\n",
                "                \".\",\n",
                "                \"Default location from which to evaluate relative paths for the JSON files.\",\n",
                "            ],\n",
                "        }\n",
                "        for key, value in configs.items():\n",
                "            self.setConfig(key, value)\n",
                "\n",
                "    def extendMarkdown(self, md: markdown.Markdown) -> None:\n",
                "        md.preprocessors.register(\n",
                "            APIArgumentsTablePreprocessor(md, self.getConfigs()), \"generate_api_arguments\", 505\n",
                "        )\n",
                "\n",
                "\n",
                "class APIArgumentsTablePreprocessor(Preprocessor):\n",
                "    def __init__(self, md: markdown.Markdown, config: Mapping[str, Any]) -> None:\n",
                "        super().__init__(md)\n",
                "        self.base_path = config[\"base_path\"]\n",
                "\n",
                "    def run(self, lines: List[str]) -> List[str]:\n",
                "        done = False\n",
                "        while not done:\n",
                "            for line in lines:\n",
                "                loc = lines.index(line)\n",
                "                match = REGEXP.search(line)\n",
                "\n",
                "                if not match:\n",
                "                    continue\n",
                "\n",
                "                filename = match.group(1)\n",
                "                doc_name = match.group(2)\n",
                "                filename = os.path.expanduser(filename)\n",
                "\n",
                "                is_openapi_format = filename.endswith(\".yaml\")\n",
                "\n",
                "                if not os.path.isabs(filename):\n",
                "                    parent_dir = self.base_path\n",
                "                    filename = os.path.normpath(os.path.join(parent_dir, filename))\n",
                "\n",
                "                if is_openapi_format:\n",
                "                    endpoint, method = doc_name.rsplit(\":\", 1)\n",
                "                    arguments: List[Dict[str, Any]] = []\n",
                "\n",
                "                    try:\n",
                "                        arguments = get_openapi_parameters(endpoint, method)\n",
                "                    except KeyError as e:\n",
                "                        # Don't raise an exception if the \"parameters\"\n",
                "                        # field is missing; we assume that's because the\n",
                "                        # endpoint doesn't accept any parameters\n",
                "                        if e.args != (\"parameters\",):\n",
                "                            raise e\n",
                "                else:\n",
                "                    with open(filename) as fp:\n",
                "                        json_obj = json.load(fp)\n",
                "                        arguments = json_obj[doc_name]\n",
                "\n",
                "                if arguments:\n",
                "                    text = self.render_table(arguments)\n",
                "                else:\n",
                "                    text = [\"This endpoint does not accept any parameters.\"]\n",
                "                # The line that contains the directive to include the macro\n",
                "                # may be preceded or followed by text or tags, in that case\n",
                "                # we need to make sure that any preceding or following text\n",
                "                # stays the same.\n",
                "                line_split = REGEXP.split(line, maxsplit=0)\n",
                "                preceding = line_split[0]\n",
                "                following = line_split[-1]\n",
                "                text = [preceding, *text, following]\n",
                "                lines = lines[:loc] + text + lines[loc + 1 :]\n",
                "                break\n",
                "            else:\n",
                "                done = True\n",
                "        return lines\n",
                "\n",
                "    def render_table(self, arguments: Sequence[Mapping[str, Any]]) -> List[str]:\n",
                "        # TODO: Fix naming now that this no longer renders a table.\n",
                "        table = []\n",
                "        argument_template = \"\"\"\n",
                "<div class=\"api-argument\" id=\"parameter-{argument}\">\n",
                "    <p class=\"api-argument-name\"><strong>{argument}</strong> <span class=\"api-field-type\">{type}</span> {required} {deprecated} <a href=\"#parameter-{argument}\" class=\"api-argument-hover-link\"><i class=\"fa fa-chain\"></i></a></p>\n",
                "    <div class=\"api-example\">\n",
                "        <span class=\"api-argument-example-label\">Example</span>: <code>{example}</code>\n",
                "    </div>\n",
                "    <div class=\"api-description\">{description}</div>\n",
                "    <hr>\n",
                "</div>\"\"\"\n",
                "\n",
                "        md_engine = markdown.Markdown(extensions=[])\n",
                "        arguments = sorted(arguments, key=lambda argument: \"deprecated\" in argument)\n",
                "        for argument in arguments:\n",
                "            description = argument[\"description\"]\n",
                "            oneof = [\"`\" + str(item) + \"`\" for item in argument.get(\"schema\", {}).get(\"enum\", [])]\n",
                "            if oneof:\n",
                "                description += \"\\nMust be one of: {}.\".format(\", \".join(oneof))\n",
                "\n",
                "            default = argument.get(\"schema\", {}).get(\"default\")\n",
                "            if default is not None:\n",
                "                description += f\"\\nDefaults to `{json.dumps(default)}`.\"\n",
                "            data_type = \"\"\n",
                "            if \"schema\" in argument:\n",
                "                data_type = generate_data_type(argument[\"schema\"])\n",
                "            else:\n",
                "                data_type = generate_data_type(argument[\"content\"][\"application/json\"][\"schema\"])\n",
                "\n",
                "            # TODO: OpenAPI allows indicating where the argument goes\n",
                "            # (path, querystring, form data...).  We should document this detail.\n",
                "            example = \"\"\n",
                "            if \"example\" in argument:\n",
                "                example = argument[\"example\"]\n",
                "            else:\n",
                "                example = json.dumps(argument[\"content\"][\"application/json\"][\"example\"])\n",
                "\n",
                "            required_string: str = \"required\"\n",
                "            if argument.get(\"in\", \"\") == \"path\":\n",
                "                # Any path variable is required\n",
                "                assert argument[\"required\"]\n",
                "                required_string = \"required in path\"\n",
                "\n",
                "            if argument.get(\"required\", False):\n",
                "                required_block = f'<span class=\"api-argument-required\">{required_string}</span>'\n",
                "            else:\n",
                "                required_block = '<span class=\"api-argument-optional\">optional</span>'\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "            # Test to make sure deprecated parameters are marked so.\n",
                    "            if likely_deprecated_parameter(description):\n",
                    "                assert argument[\"deprecated\"]\n"
                ],
                "after": [
                    "            check_deprecated_consistency(argument, description)\n"
                ],
                "parent_version_range": {
                    "start": 141,
                    "end": 144
                },
                "child_version_range": {
                    "start": 141,
                    "end": 142
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for argument in arguments:",
                        "start_line": 107,
                        "end_line": 158
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "APIArgumentsTablePreprocessor",
                        "signature": "class APIArgumentsTablePreprocessor(Preprocessor):",
                        "at_line": 32
                    },
                    {
                        "type": "function",
                        "name": "render_table",
                        "signature": "def render_table(self, arguments: Sequence[Mapping[str, Any]])->List[str]:",
                        "at_line": 92
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: zerver/lib/markdown/api_arguments_table_generator.py\nCode:\n           class APIArgumentsTablePreprocessor(Preprocessor):\n               ...\n               def render_table(self, arguments: Sequence[Mapping[str, Any]])->List[str]:\n                   ...\n138 138                else:\n139 139                    required_block = '<span class=\"api-argument-optional\">optional</span>'\n140 140    \n141      -             # Test to make sure deprecated parameters are marked so.\n142      -             if likely_deprecated_parameter(description):\n143      -                 assert argument[\"deprecated\"]\n    141  +             check_deprecated_consistency(argument, description)\n144 142                if argument.get(\"deprecated\", False):\n145 143                    deprecated_block = '<span class=\"api-argument-deprecated\">Deprecated</span>'\n146 144                else:\n         ...\n",
                "file_path": "zerver/lib/markdown/api_arguments_table_generator.py",
                "identifiers_before": [
                    "argument",
                    "description",
                    "likely_deprecated_parameter"
                ],
                "identifiers_after": [
                    "argument",
                    "check_deprecated_consistency",
                    "description"
                ],
                "prefix": [
                    "            else:\n",
                    "                required_block = '<span class=\"api-argument-optional\">optional</span>'\n",
                    "\n"
                ],
                "suffix": [
                    "            if argument.get(\"deprecated\", False):\n",
                    "                deprecated_block = '<span class=\"api-argument-deprecated\">Deprecated</span>'\n",
                    "            else:\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "likely_deprecated_parameter",
                            "position": {
                                "start": {
                                    "line": 142,
                                    "column": 15
                                },
                                "end": {
                                    "line": 142,
                                    "column": 42
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_arguments_table_generator.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 141,
                                    "column": 12
                                },
                                "end": {
                                    "line": 141,
                                    "column": 40
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_arguments_table_generator.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 141,
                                    "column": 12
                                },
                                "end": {
                                    "line": 141,
                                    "column": 40
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_arguments_table_generator.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "            if argument.get(\"deprecated\", False):\n",
                "                deprecated_block = '<span class=\"api-argument-deprecated\">Deprecated</span>'\n",
                "            else:\n",
                "                deprecated_block = \"\"\n",
                "\n",
                "            table.append(\n",
                "                argument_template.format(\n",
                "                    argument=argument.get(\"argument\") or argument.get(\"name\"),\n",
                "                    example=escape_html(example),\n",
                "                    required=required_block,\n",
                "                    deprecated=deprecated_block,\n",
                "                    description=md_engine.convert(description),\n",
                "                    type=data_type,\n",
                "                )\n",
                "            )\n",
                "\n",
                "        return table\n",
                "\n",
                "\n",
                "def makeExtension(*args: Any, **kwargs: str) -> MarkdownArgumentsTableGenerator:\n",
                "    return MarkdownArgumentsTableGenerator(kwargs)\n",
                "\n",
                "\n",
                "def generate_data_type(schema: Mapping[str, Any]) -> str:\n",
                "    data_type = \"\"\n",
                "    if \"oneOf\" in schema:\n",
                "        for item in schema[\"oneOf\"]:\n",
                "            data_type = data_type + generate_data_type(item) + \" | \"\n",
                "        data_type = data_type[:-3]\n",
                "    elif \"items\" in schema:\n",
                "        data_type = \"(\" + generate_data_type(schema[\"items\"]) + \")[]\"\n",
                "    else:\n",
                "        data_type = schema[\"type\"]\n",
                "    return data_type"
            ]
        ],
        "zerver/lib/markdown/api_return_values_table_generator.py": [
            [
                "import copy\n",
                "import json\n",
                "import re\n",
                "from typing import Any, Dict, List, Mapping, Optional\n",
                "\n",
                "import markdown\n",
                "from markdown.extensions import Extension\n",
                "from markdown.preprocessors import Preprocessor\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "from zerver.openapi.openapi import get_openapi_return_values, likely_deprecated_parameter\n"
                ],
                "after": [
                    "from zerver.openapi.openapi import check_deprecated_consistency, get_openapi_return_values\n"
                ],
                "parent_version_range": {
                    "start": 9,
                    "end": 10
                },
                "child_version_range": {
                    "start": 9,
                    "end": 10
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 2,
                "hunk_diff": "File: zerver/lib/markdown/api_return_values_table_generator.py\nCode:\n  ...\n 6  6    from markdown.extensions import Extension\n 7  7    from markdown.preprocessors import Preprocessor\n 8  8    \n 9     - from zerver.openapi.openapi import get_openapi_return_values, likely_deprecated_parameter\n    9  + from zerver.openapi.openapi import check_deprecated_consistency, get_openapi_return_values\n10 10    \n11 11    from .api_arguments_table_generator import generate_data_type\n12 12    \n       ...\n",
                "file_path": "zerver/lib/markdown/api_return_values_table_generator.py",
                "identifiers_before": [
                    "get_openapi_return_values",
                    "likely_deprecated_parameter",
                    "openapi",
                    "zerver"
                ],
                "identifiers_after": [
                    "check_deprecated_consistency",
                    "get_openapi_return_values",
                    "openapi",
                    "zerver"
                ],
                "prefix": [
                    "from markdown.extensions import Extension\n",
                    "from markdown.preprocessors import Preprocessor\n",
                    "\n"
                ],
                "suffix": [
                    "\n",
                    "from .api_arguments_table_generator import generate_data_type\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "likely_deprecated_parameter",
                            "position": {
                                "start": {
                                    "line": 9,
                                    "column": 62
                                },
                                "end": {
                                    "line": 9,
                                    "column": 89
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_return_values_table_generator.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 9,
                                    "column": 35
                                },
                                "end": {
                                    "line": 9,
                                    "column": 63
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_return_values_table_generator.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 9,
                                    "column": 35
                                },
                                "end": {
                                    "line": 9,
                                    "column": 63
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_return_values_table_generator.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    0
                ]
            },
            [
                "\n",
                "from .api_arguments_table_generator import generate_data_type\n",
                "\n",
                "REGEXP = re.compile(r\"\\{generate_return_values_table\\|\\s*(.+?)\\s*\\|\\s*(.+)\\s*\\}\")\n",
                "\n",
                "\n",
                "class MarkdownReturnValuesTableGenerator(Extension):\n",
                "    def __init__(self, configs: Mapping[str, Any] = {}) -> None:\n",
                "        self.config: Dict[str, Any] = {}\n",
                "\n",
                "    def extendMarkdown(self, md: markdown.Markdown) -> None:\n",
                "        md.preprocessors.register(\n",
                "            APIReturnValuesTablePreprocessor(md, self.getConfigs()), \"generate_return_values\", 510\n",
                "        )\n",
                "\n",
                "\n",
                "class APIReturnValuesTablePreprocessor(Preprocessor):\n",
                "    def __init__(self, md: markdown.Markdown, config: Mapping[str, Any]) -> None:\n",
                "        super().__init__(md)\n",
                "\n",
                "    def run(self, lines: List[str]) -> List[str]:\n",
                "        done = False\n",
                "        while not done:\n",
                "            for line in lines:\n",
                "                loc = lines.index(line)\n",
                "                match = REGEXP.search(line)\n",
                "\n",
                "                if not match:\n",
                "                    continue\n",
                "\n",
                "                doc_name = match.group(2)\n",
                "                endpoint, method = doc_name.rsplit(\":\", 1)\n",
                "                return_values: Dict[str, Any] = {}\n",
                "                return_values = get_openapi_return_values(endpoint, method)\n",
                "                text: List[str] = []\n",
                "                if endpoint != \"/events\":\n",
                "                    text = self.render_table(return_values, 0)\n",
                "                else:\n",
                "                    return_values = copy.deepcopy(return_values)\n",
                "                    events = return_values[\"events\"].pop(\"items\", None)\n",
                "                    text = self.render_table(return_values, 0)\n",
                "                    # Another heading for the events documentation\n",
                "                    text.append(\"\\n\\n## Events\\n\\n\")\n",
                "                    text += self.render_events(events)\n",
                "                line_split = REGEXP.split(line, maxsplit=0)\n",
                "                preceding = line_split[0]\n",
                "                following = line_split[-1]\n",
                "                text = [preceding, *text, following]\n",
                "                lines = lines[:loc] + text + lines[loc + 1 :]\n",
                "                break\n",
                "            else:\n",
                "                done = True\n",
                "        return lines\n",
                "\n",
                "    def render_desc(\n",
                "        self, description: str, spacing: int, data_type: str, return_value: Optional[str] = None\n",
                "    ) -> str:\n",
                "        description = description.replace(\"\\n\", \"\\n\" + ((spacing + 4) * \" \"))\n",
                "        if return_value is None:\n",
                "            # HACK: It's not clear how to use OpenAPI data to identify\n",
                "            # the `key` fields for objects where e.g. the keys are\n",
                "            # user/stream IDs being mapped to data associated with\n",
                "            # those IDs.  We hackily describe those fields by\n",
                "            # requiring that the descriptions be written as `key_name:\n",
                "            # key_description` and parsing for that pattern; we need\n",
                "            # to be careful to skip cases where we'd have `Note: ...`\n",
                "            # on a later line.\n",
                "            #\n",
                "            # More correctly, we should be doing something that looks at the types;\n",
                "            # print statements and test_api_doc_endpoint is useful for testing.\n",
                "            arr = description.split(\": \", 1)\n",
                "            if len(arr) == 1 or \"\\n\" in arr[0]:\n",
                "                return (spacing * \" \") + \"* \" + description\n",
                "            (key_name, key_description) = arr\n",
                "            return (\n",
                "                (spacing * \" \")\n",
                "                + \"* \"\n",
                "                + key_name\n",
                "                + \": \"\n",
                "                + '<span class=\"api-field-type\">'\n",
                "                + data_type\n",
                "                + \"</span> \"\n",
                "                + key_description\n",
                "            )\n",
                "        return (\n",
                "            (spacing * \" \")\n",
                "            + \"* `\"\n",
                "            + return_value\n",
                "            + \"`: \"\n",
                "            + '<span class=\"api-field-type\">'\n",
                "            + data_type\n",
                "            + \"</span> \"\n",
                "            + description\n",
                "        )\n",
                "\n",
                "    def render_table(self, return_values: Dict[str, Any], spacing: int) -> List[str]:\n",
                "        IGNORE = [\"result\", \"msg\"]\n",
                "        ans = []\n",
                "        for return_value in return_values:\n",
                "            if return_value in IGNORE:\n",
                "                continue\n",
                "            if \"oneOf\" in return_values[return_value]:\n",
                "                # For elements using oneOf there are two descriptions. The first description\n",
                "                # should be at level with the oneOf and should contain the basic non-specific\n",
                "                # description of the endpoint. Then for each element of oneOf there is a\n",
                "                # specialized description for that particular case. The description used\n",
                "                # right below is the main description.\n",
                "                data_type = generate_data_type(return_values[return_value])\n",
                "                ans.append(\n",
                "                    self.render_desc(\n",
                "                        return_values[return_value][\"description\"], spacing, data_type, return_value\n",
                "                    )\n",
                "                )\n",
                "                for element in return_values[return_value][\"oneOf\"]:\n",
                "                    if \"description\" not in element:\n",
                "                        continue\n",
                "                    # Add the specialized description of the oneOf element.\n",
                "                    data_type = generate_data_type(element)\n",
                "                    ans.append(self.render_desc(element[\"description\"], spacing + 4, data_type))\n",
                "                    # If the oneOf element is an object schema then render the documentation\n",
                "                    # of its keys.\n",
                "                    if \"properties\" in element:\n",
                "                        ans += self.render_table(element[\"properties\"], spacing + 8)\n",
                "                continue\n",
                "            description = return_values[return_value][\"description\"]\n",
                "            data_type = generate_data_type(return_values[return_value])\n"
            ],
            {
                "type": "replace",
                "before": [
                    "            # Test to make sure deprecated keys are marked appropriately.\n",
                    "            if likely_deprecated_parameter(description):\n",
                    "                assert return_values[return_value][\"deprecated\"]\n"
                ],
                "after": [
                    "            check_deprecated_consistency(return_values[return_value], description)\n"
                ],
                "parent_version_range": {
                    "start": 136,
                    "end": 139
                },
                "child_version_range": {
                    "start": 136,
                    "end": 137
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for return_value in return_values:",
                        "start_line": 108,
                        "end_line": 162
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "APIReturnValuesTablePreprocessor",
                        "signature": "class APIReturnValuesTablePreprocessor(Preprocessor):",
                        "at_line": 26
                    },
                    {
                        "type": "function",
                        "name": "render_table",
                        "signature": "def render_table(self, return_values: Dict[str, Any], spacing: int)->List[str]:",
                        "at_line": 105
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: zerver/lib/markdown/api_return_values_table_generator.py\nCode:\n           class APIReturnValuesTablePreprocessor(Preprocessor):\n               ...\n               def render_table(self, return_values: Dict[str, Any], spacing: int)->List[str]:\n                   ...\n133 133                    continue\n134 134                description = return_values[return_value][\"description\"]\n135 135                data_type = generate_data_type(return_values[return_value])\n136      -             # Test to make sure deprecated keys are marked appropriately.\n137      -             if likely_deprecated_parameter(description):\n138      -                 assert return_values[return_value][\"deprecated\"]\n    136  +             check_deprecated_consistency(return_values[return_value], description)\n139 137                ans.append(self.render_desc(description, spacing, data_type, return_value))\n140 138                if \"properties\" in return_values[return_value]:\n141 139                    ans += self.render_table(return_values[return_value][\"properties\"], spacing + 4)\n         ...\n",
                "file_path": "zerver/lib/markdown/api_return_values_table_generator.py",
                "identifiers_before": [
                    "description",
                    "likely_deprecated_parameter",
                    "return_value",
                    "return_values"
                ],
                "identifiers_after": [
                    "check_deprecated_consistency",
                    "description",
                    "return_value",
                    "return_values"
                ],
                "prefix": [
                    "                continue\n",
                    "            description = return_values[return_value][\"description\"]\n",
                    "            data_type = generate_data_type(return_values[return_value])\n"
                ],
                "suffix": [
                    "            ans.append(self.render_desc(description, spacing, data_type, return_value))\n",
                    "            if \"properties\" in return_values[return_value]:\n",
                    "                ans += self.render_table(return_values[return_value][\"properties\"], spacing + 4)\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "likely_deprecated_parameter",
                            "position": {
                                "start": {
                                    "line": 137,
                                    "column": 15
                                },
                                "end": {
                                    "line": 137,
                                    "column": 42
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_return_values_table_generator.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 136,
                                    "column": 12
                                },
                                "end": {
                                    "line": 136,
                                    "column": 40
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_return_values_table_generator.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 136,
                                    "column": 12
                                },
                                "end": {
                                    "line": 136,
                                    "column": 40
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/lib/markdown/api_return_values_table_generator.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "            ans.append(self.render_desc(description, spacing, data_type, return_value))\n",
                "            if \"properties\" in return_values[return_value]:\n",
                "                ans += self.render_table(return_values[return_value][\"properties\"], spacing + 4)\n",
                "            if return_values[return_value].get(\"additionalProperties\", False):\n",
                "                data_type = generate_data_type(return_values[return_value][\"additionalProperties\"])\n",
                "                ans.append(\n",
                "                    self.render_desc(\n",
                "                        return_values[return_value][\"additionalProperties\"][\"description\"],\n",
                "                        spacing + 4,\n",
                "                        data_type,\n",
                "                    )\n",
                "                )\n",
                "                if \"properties\" in return_values[return_value][\"additionalProperties\"]:\n",
                "                    ans += self.render_table(\n",
                "                        return_values[return_value][\"additionalProperties\"][\"properties\"],\n",
                "                        spacing + 8,\n",
                "                    )\n",
                "            if (\n",
                "                \"items\" in return_values[return_value]\n",
                "                and \"properties\" in return_values[return_value][\"items\"]\n",
                "            ):\n",
                "                ans += self.render_table(\n",
                "                    return_values[return_value][\"items\"][\"properties\"], spacing + 4\n",
                "                )\n",
                "        return ans\n",
                "\n",
                "    def render_events(self, events_dict: Dict[str, Any]) -> List[str]:\n",
                "        text: List[str] = []\n",
                "        # Use argument section design for better visuals\n",
                "        # Directly using `###` for subheading causes errors so use h3 with made up id.\n",
                "        argument_template = (\n",
                "            '<div class=\"api-argument\"><p class=\"api-argument-name\"><h3 id=\"{h3_id}\">'\n",
                "            + \" {event_type} {op}</h3></p></div> \\n{description}\\n\\n\\n\"\n",
                "        )\n",
                "        for events in events_dict[\"oneOf\"]:\n",
                "            # `id` is present in every event so it will be redundant to display\n",
                "            # it every time. So remove it from the dictionary.\n",
                "            events[\"properties\"].pop(\"id\")\n",
                "            event_type: Dict[str, Any] = events[\"properties\"].pop(\"type\")\n",
                "            event_type_str: str = event_type[\"enum\"][0]\n",
                "            # Internal hyperlink name\n",
                "            h3_id: str = event_type_str\n",
                "            event_type_str = f'<span class=\"api-argument-required\"> {event_type_str}</span>'\n",
                "            op: Optional[Dict[str, Any]] = events[\"properties\"].pop(\"op\", None)\n",
                "            op_str: str = \"\"\n",
                "            if op is not None:\n",
                "                op_str = op[\"enum\"][0]\n",
                "                h3_id += \"-\" + op_str\n",
                "                op_str = f'<span class=\"api-argument-deprecated\">op: {op_str}</span>'\n",
                "            description = events[\"description\"]\n",
                "            text.append(\n",
                "                argument_template.format(\n",
                "                    event_type=event_type_str, op=op_str, description=description, h3_id=h3_id\n",
                "                )\n",
                "            )\n",
                "            text += self.render_table(events[\"properties\"], 0)\n",
                "            # This part is for adding examples of individual events\n",
                "            text.append(\"**Example**\")\n",
                "            text.append(\"\\n```json\\n\")\n",
                "            example = json.dumps(events[\"example\"], indent=4)\n",
                "            text.append(example)\n",
                "            text.append(\"```\\n\\n\")\n",
                "        return text\n",
                "\n",
                "\n",
                "def makeExtension(*args: Any, **kwargs: str) -> MarkdownReturnValuesTableGenerator:\n",
                "    return MarkdownReturnValuesTableGenerator(kwargs)"
            ]
        ],
        "zerver/openapi/openapi.py": [
            [
                "# Zulip's OpenAPI-based API documentation system is documented at\n",
                "#   https://zulip.readthedocs.io/en/latest/documentation/api.html\n",
                "#\n",
                "# This file contains helper functions to interact with the OpenAPI\n",
                "# definitions and validate that Zulip's implementation matches what is\n",
                "# described in our documentation.\n",
                "\n",
                "import os\n",
                "import re\n",
                "from typing import Any, Dict, List, Optional, Set\n",
                "\n",
                "from jsonschema.exceptions import ValidationError as JsonSchemaValidationError\n",
                "from openapi_core import create_spec\n",
                "from openapi_core.testing import MockRequest\n",
                "from openapi_core.validation.request.validators import RequestValidator\n",
                "from openapi_schema_validator import OAS30Validator\n",
                "\n",
                "OPENAPI_SPEC_PATH = os.path.abspath(\n",
                "    os.path.join(os.path.dirname(__file__), \"../openapi/zulip.yaml\")\n",
                ")\n",
                "\n",
                "# A list of endpoint-methods such that the endpoint\n",
                "# has documentation but not with this particular method.\n",
                "EXCLUDE_UNDOCUMENTED_ENDPOINTS = {\n",
                "    (\"/realm/emoji/{emoji_name}\", \"delete\"),\n",
                "    (\"/users\", \"patch\"),\n",
                "}\n",
                "# Consists of endpoints with some documentation remaining.\n",
                "# These are skipped but return true as the validator cannot exclude objects\n",
                "EXCLUDE_DOCUMENTED_ENDPOINTS = {\n",
                "    (\"/settings/notifications\", \"patch\"),\n",
                "}\n",
                "\n",
                "# Most of our code expects allOf to be preprocessed away because that is what\n",
                "# yamole did.  Its algorithm for doing so is not standards compliant, but we\n",
                "# replicate it here.\n",
                "def naively_merge(a: Dict[str, object], b: Dict[str, object]) -> Dict[str, object]:\n",
                "    ret: Dict[str, object] = a.copy()\n",
                "    for key, b_value in b.items():\n",
                "        if key == \"example\" or key not in ret:\n",
                "            ret[key] = b_value\n",
                "            continue\n",
                "        a_value = ret[key]\n",
                "        if isinstance(b_value, list):\n",
                "            assert isinstance(a_value, list)\n",
                "            ret[key] = a_value + b_value\n",
                "        elif isinstance(b_value, dict):\n",
                "            assert isinstance(a_value, dict)\n",
                "            ret[key] = naively_merge(a_value, b_value)\n",
                "    return ret\n",
                "\n",
                "\n",
                "def naively_merge_allOf(obj: object) -> object:\n",
                "    if isinstance(obj, dict):\n",
                "        return naively_merge_allOf_dict(obj)\n",
                "    elif isinstance(obj, list):\n",
                "        return list(map(naively_merge_allOf, obj))\n",
                "    else:\n",
                "        return obj\n",
                "\n",
                "\n",
                "def naively_merge_allOf_dict(obj: Dict[str, object]) -> Dict[str, object]:\n",
                "    if \"allOf\" in obj:\n",
                "        ret = obj.copy()\n",
                "        subschemas = ret.pop(\"allOf\")\n",
                "        ret = naively_merge_allOf_dict(ret)\n",
                "        assert isinstance(subschemas, list)\n",
                "        for subschema in subschemas:\n",
                "            assert isinstance(subschema, dict)\n",
                "            ret = naively_merge(ret, naively_merge_allOf_dict(subschema))\n",
                "        return ret\n",
                "    return {key: naively_merge_allOf(value) for key, value in obj.items()}\n",
                "\n",
                "\n",
                "class OpenAPISpec:\n",
                "    def __init__(self, openapi_path: str) -> None:\n",
                "        self.openapi_path = openapi_path\n",
                "        self.mtime: Optional[float] = None\n",
                "        self._openapi: Dict[str, Any] = {}\n",
                "        self._endpoints_dict: Dict[str, str] = {}\n",
                "        self._request_validator: Optional[RequestValidator] = None\n",
                "\n",
                "    def check_reload(self) -> None:\n",
                "        # Because importing yaml takes significant time, and we only\n",
                "        # use python-yaml for our API docs, importing it lazily here\n",
                "        # is a significant optimization to `manage.py` startup.\n",
                "        #\n",
                "        # There is a bit of a race here...we may have two processes\n",
                "        # accessing this module level object and both trying to\n",
                "        # populate self.data at the same time.  Hopefully this will\n",
                "        # only cause some extra processing at startup and not data\n",
                "        # corruption.\n",
                "\n",
                "        import yaml\n",
                "        from jsonref import JsonRef\n",
                "\n",
                "        with open(self.openapi_path) as f:\n",
                "            mtime = os.fstat(f.fileno()).st_mtime\n",
                "            # Using == rather than >= to cover the corner case of users placing an\n",
                "            # earlier version than the current one\n",
                "            if self.mtime == mtime:\n",
                "                return\n",
                "\n",
                "            openapi = yaml.load(f, Loader=yaml.CSafeLoader)\n",
                "\n",
                "        spec = create_spec(openapi)\n",
                "        self._request_validator = RequestValidator(spec)\n",
                "        self._openapi = naively_merge_allOf_dict(JsonRef.replace_refs(openapi))\n",
                "        self.create_endpoints_dict()\n",
                "        self.mtime = mtime\n",
                "\n",
                "    def create_endpoints_dict(self) -> None:\n",
                "        # Algorithm description:\n",
                "        # We have 2 types of endpoints\n",
                "        # 1.with path arguments 2. without path arguments\n",
                "        # In validate_against_openapi_schema we directly check\n",
                "        # if we have a without path endpoint, since it does not\n",
                "        # require regex. Hence they are not part of the regex dict\n",
                "        # and now we are left with only:\n",
                "        # endpoint with path arguments.\n",
                "        # Now for this case, the regex has been created carefully,\n",
                "        # numeric arguments are matched with [0-9] only and\n",
                "        # emails are matched with their regex. This is why there are zero\n",
                "        # collisions. Hence if this regex matches\n",
                "        # an incorrect endpoint then there is some backend problem.\n",
                "        # For example if we have users/{name}/presence then it will\n",
                "        # conflict with users/me/presence even in the backend.\n",
                "        # Care should be taken though that if we have special strings\n",
                "        # such as email they must be substituted with proper regex.\n",
                "\n",
                "        email_regex = r\"([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})\"\n",
                "        self._endpoints_dict = {}\n",
                "        for endpoint in self._openapi[\"paths\"]:\n",
                "            if \"{\" not in endpoint:\n",
                "                continue\n",
                "            path_regex = \"^\" + endpoint + \"$\"\n",
                "            # Numeric arguments have id at their end\n",
                "            # so find such arguments and replace them with numeric\n",
                "            # regex\n",
                "            path_regex = re.sub(r\"{[^}]*id}\", r\"[0-9]*\", path_regex)\n",
                "            # Email arguments end with email\n",
                "            path_regex = re.sub(r\"{[^}]*email}\", email_regex, path_regex)\n",
                "            # All other types of arguments are supposed to be\n",
                "            # all-encompassing string.\n",
                "            path_regex = re.sub(r\"{[^}]*}\", r\"[^\\/]*\", path_regex)\n",
                "            path_regex = path_regex.replace(r\"/\", r\"\\/\")\n",
                "            self._endpoints_dict[path_regex] = endpoint\n",
                "\n",
                "    def openapi(self) -> Dict[str, Any]:\n",
                "        \"\"\"Reload the OpenAPI file if it has been modified after the last time\n",
                "        it was read, and then return the parsed data.\n",
                "        \"\"\"\n",
                "        self.check_reload()\n",
                "        assert len(self._openapi) > 0\n",
                "        return self._openapi\n",
                "\n",
                "    def endpoints_dict(self) -> Dict[str, str]:\n",
                "        \"\"\"Reload the OpenAPI file if it has been modified after the last time\n",
                "        it was read, and then return the parsed data.\n",
                "        \"\"\"\n",
                "        self.check_reload()\n",
                "        assert len(self._endpoints_dict) > 0\n",
                "        return self._endpoints_dict\n",
                "\n",
                "    def request_validator(self) -> RequestValidator:\n",
                "        \"\"\"Reload the OpenAPI file if it has been modified after the last time\n",
                "        it was read, and then return the openapi_core validator object. Similar\n",
                "        to preceding functions. Used for proper access to OpenAPI objects.\n",
                "        \"\"\"\n",
                "        self.check_reload()\n",
                "        assert self._request_validator is not None\n",
                "        return self._request_validator\n",
                "\n",
                "\n",
                "class SchemaError(Exception):\n",
                "    pass\n",
                "\n",
                "\n",
                "openapi_spec = OpenAPISpec(OPENAPI_SPEC_PATH)\n",
                "\n",
                "\n",
                "def get_schema(endpoint: str, method: str, status_code: str) -> Dict[str, Any]:\n",
                "    if len(status_code) == 3 and (\n",
                "        \"oneOf\"\n",
                "        in openapi_spec.openapi()[\"paths\"][endpoint][method.lower()][\"responses\"][status_code][\n",
                "            \"content\"\n",
                "        ][\"application/json\"][\"schema\"]\n",
                "    ):\n",
                "        # Currently at places where multiple schemas are defined they only\n",
                "        # differ in example so either can be used.\n",
                "        status_code += \"_0\"\n",
                "    if len(status_code) == 3:\n",
                "        schema = openapi_spec.openapi()[\"paths\"][endpoint][method.lower()][\"responses\"][\n",
                "            status_code\n",
                "        ][\"content\"][\"application/json\"][\"schema\"]\n",
                "        return schema\n",
                "    else:\n",
                "        subschema_index = int(status_code[4])\n",
                "        status_code = status_code[0:3]\n",
                "        schema = openapi_spec.openapi()[\"paths\"][endpoint][method.lower()][\"responses\"][\n",
                "            status_code\n",
                "        ][\"content\"][\"application/json\"][\"schema\"][\"oneOf\"][subschema_index]\n",
                "        return schema\n",
                "\n",
                "\n",
                "def get_openapi_fixture(endpoint: str, method: str, status_code: str = \"200\") -> Dict[str, Any]:\n",
                "    \"\"\"Fetch a fixture from the full spec object.\"\"\"\n",
                "    return get_schema(endpoint, method, status_code)[\"example\"]\n",
                "\n",
                "\n",
                "def get_openapi_description(endpoint: str, method: str) -> str:\n",
                "    \"\"\"Fetch a description from the full spec object.\"\"\"\n",
                "    return openapi_spec.openapi()[\"paths\"][endpoint][method.lower()][\"description\"]\n",
                "\n",
                "\n",
                "def get_openapi_paths() -> Set[str]:\n",
                "    return set(openapi_spec.openapi()[\"paths\"].keys())\n",
                "\n",
                "\n",
                "def get_openapi_parameters(\n",
                "    endpoint: str, method: str, include_url_parameters: bool = True\n",
                ") -> List[Dict[str, Any]]:\n",
                "    operation = openapi_spec.openapi()[\"paths\"][endpoint][method.lower()]\n",
                "    # We do a `.get()` for this last bit to distinguish documented\n",
                "    # endpoints with no parameters (empty list) from undocumented\n",
                "    # endpoints (KeyError exception).\n",
                "    parameters = operation.get(\"parameters\", [])\n",
                "    # Also, we skip parameters defined in the URL.\n",
                "    if not include_url_parameters:\n",
                "        parameters = [parameter for parameter in parameters if parameter[\"in\"] != \"path\"]\n",
                "    return parameters\n",
                "\n",
                "\n",
                "def get_openapi_return_values(endpoint: str, method: str) -> List[Dict[str, Any]]:\n",
                "    operation = openapi_spec.openapi()[\"paths\"][endpoint][method.lower()]\n",
                "    schema = operation[\"responses\"][\"200\"][\"content\"][\"application/json\"][\"schema\"]\n",
                "    # In cases where we have used oneOf, the schemas only differ in examples\n",
                "    # So we can choose any.\n",
                "    if \"oneOf\" in schema:\n",
                "        schema = schema[\"oneOf\"][0]\n",
                "    return schema[\"properties\"]\n",
                "\n",
                "\n",
                "def find_openapi_endpoint(path: str) -> Optional[str]:\n",
                "    for path_regex, endpoint in openapi_spec.endpoints_dict().items():\n",
                "        matches = re.match(path_regex, path)\n",
                "        if matches:\n",
                "            return endpoint\n",
                "    return None\n",
                "\n",
                "\n",
                "def get_event_type(event: Dict[str, Any]) -> str:\n",
                "    return event[\"type\"] + \":\" + event.get(\"op\", \"\")\n",
                "\n",
                "\n",
                "def fix_events(content: Dict[str, Any]) -> None:\n",
                "    \"\"\"Remove undocumented events from events array. This is a makeshift\n",
                "    function so that further documentation of `/events` can happen with\n",
                "    only zulip.yaml changes and minimal other changes. It should be removed\n",
                "    as soon as `/events` documentation is complete.\n",
                "    \"\"\"\n",
                "    # 'user' is deprecated so remove its occurrences from the events array\n",
                "    for event in content[\"events\"]:\n",
                "        event.pop(\"user\", None)\n",
                "\n",
                "\n",
                "def validate_against_openapi_schema(\n",
                "    content: Dict[str, Any],\n",
                "    path: str,\n",
                "    method: str,\n",
                "    status_code: str,\n",
                "    display_brief_error: bool = False,\n",
                ") -> bool:\n",
                "    \"\"\"Compare a \"content\" dict with the defined schema for a specific method\n",
                "    in an endpoint. Return true if validated and false if skipped.\n",
                "    \"\"\"\n",
                "\n",
                "    # This first set of checks are primarily training wheels that we\n",
                "    # hope to eliminate over time as we improve our API documentation.\n",
                "\n",
                "    # No 500 responses have been documented, so skip them\n",
                "    if status_code.startswith(\"5\"):\n",
                "        return False\n",
                "    if path not in openapi_spec.openapi()[\"paths\"].keys():\n",
                "        endpoint = find_openapi_endpoint(path)\n",
                "        # If it doesn't match it hasn't been documented yet.\n",
                "        if endpoint is None:\n",
                "            return False\n",
                "    else:\n",
                "        endpoint = path\n",
                "    # Excluded endpoint/methods\n",
                "    if (endpoint, method) in EXCLUDE_UNDOCUMENTED_ENDPOINTS:\n",
                "        return False\n",
                "    # Return true for endpoints with only response documentation remaining\n",
                "    if (endpoint, method) in EXCLUDE_DOCUMENTED_ENDPOINTS:\n",
                "        return True\n",
                "    # Check if the response matches its code\n",
                "    if status_code.startswith(\"2\") and (content.get(\"result\", \"success\").lower() != \"success\"):\n",
                "        raise SchemaError(\"Response is not 200 but is validating against 200 schema\")\n",
                "    # Code is not declared but appears in various 400 responses. If\n",
                "    # common, it can be added to 400 response schema\n",
                "    if status_code.startswith(\"4\"):\n",
                "        # This return statement should ideally be not here. But since\n",
                "        # we have not defined 400 responses for various paths this has\n",
                "        # been added as all 400 have the same schema.  When all 400\n",
                "        # response have been defined this should be removed.\n",
                "        return True\n",
                "    # The actual work of validating that the response matches the\n",
                "    # schema is done via the third-party OAS30Validator.\n",
                "    schema = get_schema(endpoint, method, status_code)\n",
                "    if endpoint == \"/events\" and method == \"get\":\n",
                "        # This a temporary function for checking only documented events\n",
                "        # as all events haven't been documented yet.\n",
                "        # TODO: Remove this after all events have been documented.\n",
                "        fix_events(content)\n",
                "\n",
                "    validator = OAS30Validator(schema)\n",
                "    try:\n",
                "        validator.validate(content)\n",
                "    except JsonSchemaValidationError as error:\n",
                "        if not display_brief_error:\n",
                "            raise error\n",
                "\n",
                "        # display_brief_error is designed to avoid printing 1000 lines\n",
                "        # of output when the schema to validate is extremely large\n",
                "        # (E.g. the several dozen format variants for individual\n",
                "        # events returned by GET /events) and instead just display the\n",
                "        # specific variant we expect to match the response.\n",
                "        brief_error_display_schema = {\"nullable\": False, \"oneOf\": list()}\n",
                "        brief_error_display_schema_oneOf = []\n",
                "        brief_error_validator_value = []\n",
                "\n",
                "        for validator_value in error.validator_value:\n",
                "            if validator_value[\"example\"][\"type\"] == error.instance[\"type\"]:\n",
                "                brief_error_validator_value.append(validator_value)\n",
                "\n",
                "        for i_schema in error.schema[\"oneOf\"]:\n",
                "            if i_schema[\"example\"][\"type\"] == error.instance[\"type\"]:\n",
                "                brief_error_display_schema_oneOf.append(i_schema)\n",
                "        brief_error_display_schema[\"oneOf\"] = brief_error_display_schema_oneOf\n",
                "\n",
                "        # Field list from https://python-jsonschema.readthedocs.io/en/stable/errors/\n",
                "        raise JsonSchemaValidationError(\n",
                "            message=error.message,\n",
                "            validator=error.validator,\n",
                "            path=error.path,\n",
                "            instance=error.instance,\n",
                "            schema_path=error.schema_path,\n",
                "            schema=brief_error_display_schema,\n",
                "            validator_value=brief_error_validator_value,\n",
                "            cause=error.cause,\n",
                "        )\n",
                "\n",
                "    return True\n",
                "\n",
                "\n",
                "def validate_schema(schema: Dict[str, Any]) -> None:\n",
                "    \"\"\"Check if opaque objects are present in the OpenAPI spec; this is an\n",
                "    important part of our policy for ensuring every detail of Zulip's\n",
                "    API responses is correct.\n",
                "\n",
                "    This is done by checking for the presence of the\n",
                "    `additionalProperties` attribute for all objects (dictionaries).\n",
                "    \"\"\"\n",
                "    if \"oneOf\" in schema:\n",
                "        for subschema in schema[\"oneOf\"]:\n",
                "            validate_schema(subschema)\n",
                "    elif schema[\"type\"] == \"array\":\n",
                "        validate_schema(schema[\"items\"])\n",
                "    elif schema[\"type\"] == \"object\":\n",
                "        if \"additionalProperties\" not in schema:\n",
                "            raise SchemaError(\n",
                "                \"additionalProperties needs to be defined for objects to make\"\n",
                "                + \"sure they have no additional properties left to be documented.\"\n",
                "            )\n",
                "        for property_schema in schema.get(\"properties\", {}).values():\n",
                "            validate_schema(property_schema)\n",
                "        if schema[\"additionalProperties\"]:\n",
                "            validate_schema(schema[\"additionalProperties\"])\n",
                "\n",
                "\n",
                "def to_python_type(py_type: str) -> type:\n",
                "    \"\"\"Transform an OpenAPI-like type to a Python one.\n",
                "    https://swagger.io/docs/specification/data-models/data-types\n",
                "    \"\"\"\n",
                "    TYPES = {\n",
                "        \"string\": str,\n",
                "        \"number\": float,\n",
                "        \"integer\": int,\n",
                "        \"boolean\": bool,\n",
                "        \"array\": list,\n",
                "        \"object\": dict,\n",
                "    }\n",
                "\n",
                "    return TYPES[py_type]\n",
                "\n",
                "\n",
                "def likely_deprecated_parameter(parameter_description: str) -> bool:\n",
                "    if \"**Changes**: Deprecated\" in parameter_description:\n",
                "        return True\n",
                "\n",
                "    return \"**Deprecated**\" in parameter_description\n",
                "\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "def check_deprecated_consistency(argument: Dict[str, Any], description: str) -> None:\n",
                    "    # Test to make sure deprecated parameters are marked so.\n",
                    "    if likely_deprecated_parameter(description):\n",
                    "        assert argument[\"deprecated\"]\n",
                    "    if \"deprecated\" in argument:\n",
                    "        assert likely_deprecated_parameter(description)\n",
                    "\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 404,
                    "end": 404
                },
                "child_version_range": {
                    "start": 404,
                    "end": 412
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 4,
                "hunk_diff": "File: zerver/openapi/openapi.py\nCode:\n  ...\n401 401        return \"**Deprecated**\" in parameter_description\n402 402    \n403 403    \n    404  + def check_deprecated_consistency(argument: Dict[str, Any], description: str) -> None:\n    405  +     # Test to make sure deprecated parameters are marked so.\n    406  +     if likely_deprecated_parameter(description):\n    407  +         assert argument[\"deprecated\"]\n    408  +     if \"deprecated\" in argument:\n    409  +         assert likely_deprecated_parameter(description)\n    410  + \n    411  + \n404 412    # Skip those JSON endpoints whose query parameters are different from\n405 413    # their `/api/v1` counterpart.  This is a legacy code issue that we\n406 414    # plan to fix by changing the implementation.\n         ...\n",
                "file_path": "zerver/openapi/openapi.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Any",
                    "Dict",
                    "argument",
                    "check_deprecated_consistency",
                    "description",
                    "likely_deprecated_parameter",
                    "str"
                ],
                "prefix": [
                    "    return \"**Deprecated**\" in parameter_description\n",
                    "\n",
                    "\n"
                ],
                "suffix": [
                    "# Skip those JSON endpoints whose query parameters are different from\n",
                    "# their `/api/v1` counterpart.  This is a legacy code issue that we\n",
                    "# plan to fix by changing the implementation.\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 404,
                                    "column": 4
                                },
                                "end": {
                                    "line": 404,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/openapi/openapi.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 404,
                                    "column": 4
                                },
                                "end": {
                                    "line": 404,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/openapi/openapi.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 404,
                                    "column": 4
                                },
                                "end": {
                                    "line": 404,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/openapi/openapi.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "check_deprecated_consistency",
                            "position": {
                                "start": {
                                    "line": 404,
                                    "column": 4
                                },
                                "end": {
                                    "line": 404,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zerver/openapi/openapi.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "# Skip those JSON endpoints whose query parameters are different from\n",
                "# their `/api/v1` counterpart.  This is a legacy code issue that we\n",
                "# plan to fix by changing the implementation.\n",
                "SKIP_JSON = {\n",
                "    (\"/fetch_api_key\", \"post\"),\n",
                "}\n",
                "\n",
                "\n",
                "def validate_request(\n",
                "    url: str,\n",
                "    method: str,\n",
                "    data: Dict[str, Any],\n",
                "    http_headers: Dict[str, Any],\n",
                "    json_url: bool,\n",
                "    status_code: str,\n",
                "    intentionally_undocumented: bool = False,\n",
                ") -> None:\n",
                "    # Some JSON endpoints have different parameters compared to\n",
                "    # their `/api/v1` counterparts.\n",
                "    if json_url and (url, method) in SKIP_JSON:\n",
                "        return\n",
                "\n",
                "    # TODO: Add support for file upload endpoints that lack the /json/\n",
                "    # or /api/v1/ prefix.\n",
                "    if url == \"/user_uploads\" or url.startswith(\"/realm/emoji/\"):\n",
                "        return\n",
                "\n",
                "    # Now using the openapi_core APIs, validate the request schema\n",
                "    # against the OpenAPI documentation.\n",
                "    mock_request = MockRequest(\n",
                "        \"http://localhost:9991/\", method, \"/api/v1\" + url, headers=http_headers, args=data\n",
                "    )\n",
                "    result = openapi_spec.request_validator().validate(mock_request)\n",
                "    if len(result.errors) != 0:\n",
                "        # Requests that do not validate against the OpenAPI spec must either:\n",
                "        # * Have returned a 400 (bad request) error\n",
                "        # * Have returned a 200 (success) with this request marked as intentionally\n",
                "        # undocumented behavior.\n",
                "        if status_code.startswith(\"4\"):\n",
                "            return\n",
                "        if status_code.startswith(\"2\") and intentionally_undocumented:\n",
                "            return\n",
                "\n",
                "    # If no errors are raised, then validation is successful\n",
                "    if len(result.errors) == 0:\n",
                "        return\n",
                "\n",
                "    # Show a block error message explaining the options for fixing it.\n",
                "    msg = f\"\"\"\n",
                "\n",
                "Error!  The OpenAPI schema for {method} {url} is not consistent\n",
                "with the parameters passed in this HTTP request.  Consider:\n",
                "\n",
                "* Updating the OpenAPI schema defined in zerver/openapi/zulip.yaml\n",
                "* Adjusting the test to pass valid parameters.  If the test\n",
                "  fails due to intentionally_undocumented features, you need to pass\n",
                "  `intentionally_undocumented=True` to self.client_{method.lower()} or\n",
                "  self.api_{method.lower()} to document your intent.\n",
                "\n",
                "See https://zulip.readthedocs.io/en/latest/documentation/api.html for help.\n",
                "\n",
                "The errors logged by the OpenAPI validator are below:\\n\"\"\"\n",
                "    for error in result.errors:\n",
                "        msg += f\"* {str(error)}\\n\"\n",
                "    raise SchemaError(msg)"
            ]
        ]
    },
    "edit_order": [
        [
            4,
            0,
            1,
            2,
            3
        ],
        [
            1,
            0,
            4,
            2,
            3
        ]
    ],
    "partial_orders": [
        {
            "edit_hunk_pair": [
                1,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "refactor",
            "scenario of 0 -> 1": "edit 0 is first refactored into a method, then exisiting code and logic is moved to edit 1 as a new function",
            "scenario of 1 -> 0": "unlikely that user will rewrite the logic all over again in edit 1, then delete it in edit 0"
        },
        {
            "edit_hunk_pair": [
                4,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "Edit 0 defined the function used in Edit 1",
            "scenario of 0 -> 1": "user may define the function in edit 0, then use it in edit 1",
            "scenario of 1 -> 0": "user may first use the function in edit 1, then driven by error, define and implement it in edit 0"
        },
        {
            "edit_hunk_pair": [
                3,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "Edit 1 imports the function used in Edit 0",
            "scenario of 0 -> 1": "user may frist use it in edit 0, the driven by error, import it in edit 1",
            "scenario of 1 -> 0": "user may import the function in edit 1 frist, then use it in edit 0"
        },
        {
            "edit_hunk_pair": [
                1,
                0
            ],
            "edit_order": "bi-directional",
            "reason": "Edit 1 imports the function used in Edit 0",
            "scenario of 0 -> 1": "user may first use it in edit 0, the driven by error, use it in edit 1",
            "scenario of 1 -> 0": "user may first import the function in edit 1, then use it in edit 0"
        },
        {
            "edit_hunk_pair": [
                0,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "code clones",
            "scenario of 0 -> 1": "user are editing code clones in batch, encounter edit 0 first, then found edit 1",
            "scenario of 1 -> 0": "user are editing code clones in batch, encounter edit 1 first, then found edit 0"
        },
        {
            "edit_hunk_pair": [
                1,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "code clones",
            "scenario of 0 -> 1": "user are editing code clones in batch, encounter edit 0 first, then found edit 1",
            "scenario of 1 -> 0": "user are editing code clones in batch, encounter edit 1 first, then found edit 0"
        },
        {
            "edit_hunk_pair": [
                0,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "define import",
            "scenario of 0 -> 1": "import before define",
            "scenario of 1 -> 0": "define before import"
        },
        {
            "edit_hunk_pair": [
                2,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "define import",
            "scenario of 0 -> 1": "import before define",
            "scenario of 1 -> 0": "define before import"
        }
    ]
}