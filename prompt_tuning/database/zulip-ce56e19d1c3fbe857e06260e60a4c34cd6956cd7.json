{
    "language": "python",
    "commit_url": "https://github.com/zulip/zulip/commit/ce56e19d1c3fbe857e06260e60a4c34cd6956cd7",
    "commit_message": "stripe: Separate activation of free trial for remote realm/server.\n\nAdd a separate setting to only enable free trial for remote\nrealm / server.",
    "commit_snapshots": {
        "corporate/lib/stripe.py": [
            [
                "import logging\n",
                "import math\n",
                "import os\n",
                "import secrets\n",
                "from abc import ABC, abstractmethod\n",
                "from dataclasses import dataclass\n",
                "from datetime import datetime, timedelta\n",
                "from decimal import Decimal\n",
                "from enum import Enum\n",
                "from functools import wraps\n",
                "from typing import Any, Callable, Dict, Generator, Optional, Tuple, TypedDict, TypeVar, Union\n",
                "from urllib.parse import urlencode, urljoin\n",
                "\n",
                "import stripe\n",
                "from django import forms\n",
                "from django.conf import settings\n",
                "from django.core import signing\n",
                "from django.core.signing import Signer\n",
                "from django.db import transaction\n",
                "from django.urls import reverse\n",
                "from django.utils.timezone import now as timezone_now\n",
                "from django.utils.translation import gettext as _\n",
                "from django.utils.translation import gettext_lazy\n",
                "from django.utils.translation import override as override_language\n",
                "from typing_extensions import ParamSpec, override\n",
                "\n",
                "from corporate.models import (\n",
                "    Customer,\n",
                "    CustomerPlan,\n",
                "    LicenseLedger,\n",
                "    PaymentIntent,\n",
                "    Session,\n",
                "    SponsoredPlanTypes,\n",
                "    ZulipSponsorshipRequest,\n",
                "    get_current_plan_by_customer,\n",
                "    get_current_plan_by_realm,\n",
                "    get_customer_by_realm,\n",
                "    get_customer_by_remote_realm,\n",
                "    get_customer_by_remote_server,\n",
                ")\n",
                "from zerver.lib.exceptions import JsonableError\n",
                "from zerver.lib.logging_util import log_to_file\n",
                "from zerver.lib.send_email import (\n",
                "    FromAddress,\n",
                "    send_email,\n",
                "    send_email_to_billing_admins_and_realm_owners,\n",
                ")\n",
                "from zerver.lib.timestamp import datetime_to_timestamp, timestamp_to_datetime\n",
                "from zerver.lib.url_encoding import append_url_query_string\n",
                "from zerver.lib.utils import assert_is_not_none\n",
                "from zerver.models import (\n",
                "    Realm,\n",
                "    RealmAuditLog,\n",
                "    UserProfile,\n",
                "    get_org_type_display_name,\n",
                "    get_realm,\n",
                "    get_system_bot,\n",
                ")\n",
                "from zilencer.lib.remote_counts import MissingDataError\n",
                "from zilencer.models import (\n",
                "    RemoteRealm,\n",
                "    RemoteRealmAuditLog,\n",
                "    RemoteRealmBillingUser,\n",
                "    RemoteServerBillingUser,\n",
                "    RemoteZulipServer,\n",
                "    RemoteZulipServerAuditLog,\n",
                "    get_remote_realm_guest_and_non_guest_count,\n",
                "    get_remote_server_guest_and_non_guest_count,\n",
                "    has_stale_audit_log,\n",
                ")\n",
                "from zproject.config import get_secret\n",
                "\n",
                "stripe.api_key = get_secret(\"stripe_secret_key\")\n",
                "\n",
                "BILLING_LOG_PATH = os.path.join(\n",
                "    \"/var/log/zulip\" if not settings.DEVELOPMENT else settings.DEVELOPMENT_LOG_DIRECTORY,\n",
                "    \"billing.log\",\n",
                ")\n",
                "billing_logger = logging.getLogger(\"corporate.stripe\")\n",
                "log_to_file(billing_logger, BILLING_LOG_PATH)\n",
                "log_to_file(logging.getLogger(\"stripe\"), BILLING_LOG_PATH)\n",
                "\n",
                "ParamT = ParamSpec(\"ParamT\")\n",
                "ReturnT = TypeVar(\"ReturnT\")\n",
                "\n",
                "MIN_INVOICED_LICENSES = 30\n",
                "MAX_INVOICED_LICENSES = 1000\n",
                "DEFAULT_INVOICE_DAYS_UNTIL_DUE = 30\n",
                "\n",
                "VALID_BILLING_MODALITY_VALUES = [\"send_invoice\", \"charge_automatically\"]\n",
                "VALID_BILLING_SCHEDULE_VALUES = [\"annual\", \"monthly\"]\n",
                "VALID_LICENSE_MANAGEMENT_VALUES = [\"automatic\", \"manual\"]\n",
                "\n",
                "CARD_CAPITALIZATION = {\n",
                "    \"amex\": \"American Express\",\n",
                "    \"diners\": \"Diners Club\",\n",
                "    \"discover\": \"Discover\",\n",
                "    \"jcb\": \"JCB\",\n",
                "    \"mastercard\": \"Mastercard\",\n",
                "    \"unionpay\": \"UnionPay\",\n",
                "    \"visa\": \"Visa\",\n",
                "}\n",
                "\n",
                "# The version of Stripe API the billing system supports.\n",
                "STRIPE_API_VERSION = \"2020-08-27\"\n",
                "\n",
                "stripe.api_version = STRIPE_API_VERSION\n",
                "\n",
                "\n",
                "# This function imitates the behavior of the format_money in billing/helpers.ts\n",
                "def format_money(cents: float) -> str:\n",
                "    # allow for small floating point errors\n",
                "    cents = math.ceil(cents - 0.001)\n",
                "    if cents % 100 == 0:\n",
                "        precision = 0\n",
                "    else:\n",
                "        precision = 2\n",
                "\n",
                "    dollars = cents / 100\n",
                "    # Format the number as a string with the correct number of decimal places\n",
                "    return f\"{dollars:.{precision}f}\"\n",
                "\n",
                "\n",
                "def format_discount_percentage(discount: Optional[Decimal]) -> Optional[str]:\n",
                "    if type(discount) is not Decimal or discount == Decimal(0):\n",
                "        return None\n",
                "\n",
                "    # Even though it looks like /activity/support only finds integers valid,\n",
                "    # this will look good for any custom discounts that we apply.\n",
                "    if discount * 100 % 100 == 0:\n",
                "        precision = 0\n",
                "    else:\n",
                "        precision = 2  # nocoverage\n",
                "    return f\"{discount:.{precision}f}\"\n",
                "\n",
                "\n",
                "def get_latest_seat_count(realm: Realm) -> int:\n",
                "    return get_seat_count(realm, extra_non_guests_count=0, extra_guests_count=0)\n",
                "\n",
                "\n",
                "def get_seat_count(\n",
                "    realm: Realm, extra_non_guests_count: int = 0, extra_guests_count: int = 0\n",
                ") -> int:\n",
                "    non_guests = (\n",
                "        UserProfile.objects.filter(realm=realm, is_active=True, is_bot=False)\n",
                "        .exclude(role=UserProfile.ROLE_GUEST)\n",
                "        .count()\n",
                "    ) + extra_non_guests_count\n",
                "\n",
                "    # This guest count calculation should match the similar query in render_stats().\n",
                "    guests = (\n",
                "        UserProfile.objects.filter(\n",
                "            realm=realm, is_active=True, is_bot=False, role=UserProfile.ROLE_GUEST\n",
                "        ).count()\n",
                "        + extra_guests_count\n",
                "    )\n",
                "\n",
                "    # This formula achieves the pricing of the first 5*N guests\n",
                "    # being free of charge (where N is the number of non-guests in the organization)\n",
                "    # and each consecutive one being worth 1/5 the non-guest price.\n",
                "    return max(non_guests, math.ceil(guests / 5))\n",
                "\n",
                "\n",
                "def sign_string(string: str) -> Tuple[str, str]:\n",
                "    salt = secrets.token_hex(32)\n",
                "    signer = Signer(salt=salt)\n",
                "    return signer.sign(string), salt\n",
                "\n",
                "\n",
                "def unsign_string(signed_string: str, salt: str) -> str:\n",
                "    signer = Signer(salt=salt)\n",
                "    return signer.unsign(signed_string)\n",
                "\n",
                "\n",
                "def unsign_seat_count(signed_seat_count: str, salt: str) -> int:\n",
                "    try:\n",
                "        return int(unsign_string(signed_seat_count, salt))\n",
                "    except signing.BadSignature:\n",
                "        raise BillingError(\"tampered seat count\")\n",
                "\n",
                "\n",
                "def validate_licenses(\n",
                "    charge_automatically: bool,\n",
                "    licenses: Optional[int],\n",
                "    seat_count: int,\n",
                "    exempt_from_license_number_check: bool,\n",
                "    min_licenses_for_plan: int,\n",
                ") -> None:\n",
                "    min_licenses = max(seat_count, min_licenses_for_plan)\n",
                "    max_licenses = None\n",
                "    if not charge_automatically:\n",
                "        min_licenses = max(seat_count, MIN_INVOICED_LICENSES)\n",
                "        max_licenses = MAX_INVOICED_LICENSES\n",
                "\n",
                "    if licenses is None or (not exempt_from_license_number_check and licenses < min_licenses):\n",
                "        raise BillingError(\n",
                "            \"not enough licenses\",\n",
                "            _(\n",
                "                \"You must purchase licenses for all active users in your organization (minimum {min_licenses}).\"\n",
                "            ).format(min_licenses=min_licenses),\n",
                "        )\n",
                "\n",
                "    if max_licenses is not None and licenses > max_licenses:\n",
                "        message = _(\n",
                "            \"Invoices with more than {max_licenses} licenses can't be processed from this page. To\"\n",
                "            \" complete the upgrade, please contact {email}.\"\n",
                "        ).format(max_licenses=max_licenses, email=settings.ZULIP_ADMINISTRATOR)\n",
                "        raise BillingError(\"too many licenses\", message)\n",
                "\n",
                "\n",
                "def check_upgrade_parameters(\n",
                "    billing_modality: str,\n",
                "    schedule: str,\n",
                "    license_management: Optional[str],\n",
                "    licenses: Optional[int],\n",
                "    seat_count: int,\n",
                "    exempt_from_license_number_check: bool,\n",
                "    min_licenses_for_plan: int,\n",
                ") -> None:\n",
                "    if billing_modality not in VALID_BILLING_MODALITY_VALUES:  # nocoverage\n",
                "        raise BillingError(\"unknown billing_modality\", \"\")\n",
                "    if schedule not in VALID_BILLING_SCHEDULE_VALUES:  # nocoverage\n",
                "        raise BillingError(\"unknown schedule\")\n",
                "    if license_management not in VALID_LICENSE_MANAGEMENT_VALUES:  # nocoverage\n",
                "        raise BillingError(\"unknown license_management\")\n",
                "    validate_licenses(\n",
                "        billing_modality == \"charge_automatically\",\n",
                "        licenses,\n",
                "        seat_count,\n",
                "        exempt_from_license_number_check,\n",
                "        min_licenses_for_plan,\n",
                "    )\n",
                "\n",
                "\n",
                "# Be extremely careful changing this function. Historical billing periods\n",
                "# are not stored anywhere, and are just computed on the fly using this\n",
                "# function. Any change you make here should return the same value (or be\n",
                "# within a few seconds) for basically any value from when the billing system\n",
                "# went online to within a year from now.\n",
                "def add_months(dt: datetime, months: int) -> datetime:\n",
                "    assert months >= 0\n",
                "    # It's fine that the max day in Feb is 28 for leap years.\n",
                "    MAX_DAY_FOR_MONTH = {\n",
                "        1: 31,\n",
                "        2: 28,\n",
                "        3: 31,\n",
                "        4: 30,\n",
                "        5: 31,\n",
                "        6: 30,\n",
                "        7: 31,\n",
                "        8: 31,\n",
                "        9: 30,\n",
                "        10: 31,\n",
                "        11: 30,\n",
                "        12: 31,\n",
                "    }\n",
                "    year = dt.year\n",
                "    month = dt.month + months\n",
                "    while month > 12:\n",
                "        year += 1\n",
                "        month -= 12\n",
                "    day = min(dt.day, MAX_DAY_FOR_MONTH[month])\n",
                "    # datetimes don't support leap seconds, so don't need to worry about those\n",
                "    return dt.replace(year=year, month=month, day=day)\n",
                "\n",
                "\n",
                "def next_month(billing_cycle_anchor: datetime, dt: datetime) -> datetime:\n",
                "    estimated_months = round((dt - billing_cycle_anchor).days * 12.0 / 365)\n",
                "    for months in range(max(estimated_months - 1, 0), estimated_months + 2):\n",
                "        proposed_next_month = add_months(billing_cycle_anchor, months)\n",
                "        if 20 < (proposed_next_month - dt).days < 40:\n",
                "            return proposed_next_month\n",
                "    raise AssertionError(\n",
                "        \"Something wrong in next_month calculation with \"\n",
                "        f\"billing_cycle_anchor: {billing_cycle_anchor}, dt: {dt}\"\n",
                "    )\n",
                "\n",
                "\n",
                "def start_of_next_billing_cycle(plan: CustomerPlan, event_time: datetime) -> datetime:\n",
                "    months_per_period = {\n",
                "        CustomerPlan.BILLING_SCHEDULE_ANNUAL: 12,\n",
                "        CustomerPlan.BILLING_SCHEDULE_MONTHLY: 1,\n",
                "    }[plan.billing_schedule]\n",
                "    periods = 1\n",
                "    dt = plan.billing_cycle_anchor\n",
                "    while dt <= event_time:\n",
                "        dt = add_months(plan.billing_cycle_anchor, months_per_period * periods)\n",
                "        periods += 1\n",
                "    return dt\n",
                "\n",
                "\n",
                "def next_invoice_date(plan: CustomerPlan) -> Optional[datetime]:\n",
                "    if plan.status == CustomerPlan.ENDED:\n",
                "        return None\n",
                "    assert plan.next_invoice_date is not None  # for mypy\n",
                "    months_per_period = {\n",
                "        CustomerPlan.BILLING_SCHEDULE_ANNUAL: 12,\n",
                "        CustomerPlan.BILLING_SCHEDULE_MONTHLY: 1,\n",
                "    }[plan.billing_schedule]\n",
                "    if plan.automanage_licenses:\n",
                "        months_per_period = 1\n",
                "    periods = 1\n",
                "    dt = plan.billing_cycle_anchor\n",
                "    while dt <= plan.next_invoice_date:\n",
                "        dt = add_months(plan.billing_cycle_anchor, months_per_period * periods)\n",
                "        periods += 1\n",
                "    return dt\n",
                "\n",
                "\n",
                "def renewal_amount(\n",
                "    plan: CustomerPlan, event_time: datetime, last_ledger_entry: Optional[LicenseLedger] = None\n",
                ") -> int:  # nocoverage: TODO\n",
                "    if plan.fixed_price is not None:\n",
                "        return plan.fixed_price\n",
                "    new_plan = None\n",
                "    if last_ledger_entry is None:\n",
                "        realm = plan.customer.realm\n",
                "        billing_session = RealmBillingSession(user=None, realm=realm)\n",
                "        new_plan, last_ledger_entry = billing_session.make_end_of_cycle_updates_if_needed(\n",
                "            plan, event_time\n",
                "        )\n",
                "    if last_ledger_entry is None:\n",
                "        return 0\n",
                "    if last_ledger_entry.licenses_at_next_renewal is None:\n",
                "        return 0\n",
                "    if new_plan is not None:\n",
                "        plan = new_plan\n",
                "    assert plan.price_per_license is not None  # for mypy\n",
                "    return plan.price_per_license * last_ledger_entry.licenses_at_next_renewal\n",
                "\n",
                "\n",
                "def get_amount_to_credit_for_plan_tier_change(\n",
                "    current_plan: CustomerPlan, plan_change_date: datetime\n",
                ") -> int:\n",
                "    last_renewal_ledger = (\n",
                "        LicenseLedger.objects.filter(is_renewal=True, plan=current_plan).order_by(\"id\").last()\n",
                "    )\n",
                "    assert last_renewal_ledger is not None\n",
                "    assert current_plan.price_per_license is not None\n",
                "\n",
                "    next_renewal_date = start_of_next_billing_cycle(current_plan, plan_change_date)\n",
                "\n",
                "    last_renewal_amount = last_renewal_ledger.licenses * current_plan.price_per_license\n",
                "    last_renewal_date = last_renewal_ledger.event_time\n",
                "\n",
                "    prorated_fraction = 1 - (plan_change_date - last_renewal_date) / (\n",
                "        next_renewal_date - last_renewal_date\n",
                "    )\n",
                "    amount_to_credit_back = math.ceil(last_renewal_amount * prorated_fraction)\n",
                "\n",
                "    return amount_to_credit_back\n",
                "\n",
                "\n",
                "def get_idempotency_key(ledger_entry: LicenseLedger) -> Optional[str]:\n",
                "    if settings.TEST_SUITE:\n",
                "        return None\n",
                "    return f\"ledger_entry:{ledger_entry.id}\"  # nocoverage\n",
                "\n",
                "\n",
                "def cents_to_dollar_string(cents: int) -> str:\n",
                "    return f\"{cents / 100.:,.2f}\"\n",
                "\n",
                "\n",
                "# Should only be called if the customer is being charged automatically\n",
                "def payment_method_string(stripe_customer: stripe.Customer) -> str:\n",
                "    assert stripe_customer.invoice_settings is not None\n",
                "    default_payment_method = stripe_customer.invoice_settings.default_payment_method\n",
                "    if default_payment_method is None:\n",
                "        return _(\"No payment method on file.\")\n",
                "\n",
                "    assert isinstance(default_payment_method, stripe.PaymentMethod)\n",
                "    if default_payment_method.type == \"card\":\n",
                "        assert default_payment_method.card is not None\n",
                "        brand_name = default_payment_method.card.brand\n",
                "        if brand_name in CARD_CAPITALIZATION:\n",
                "            brand_name = CARD_CAPITALIZATION[default_payment_method.card.brand]\n",
                "        return _(\"{brand} ending in {last4}\").format(\n",
                "            brand=brand_name,\n",
                "            last4=default_payment_method.card.last4,\n",
                "        )\n",
                "    # There might be one-off stuff we do for a particular customer that\n",
                "    # would land them here. E.g. by default we don't support ACH for\n",
                "    # automatic payments, but in theory we could add it for a customer via\n",
                "    # the Stripe dashboard.\n",
                "    return _(\"Unknown payment method. Please contact {email}.\").format(\n",
                "        email=settings.ZULIP_ADMINISTRATOR,\n",
                "    )  # nocoverage\n",
                "\n",
                "\n",
                "def build_support_url(support_view: str, query_text: str) -> str:\n",
                "    support_realm_url = get_realm(settings.STAFF_SUBDOMAIN).uri\n",
                "    support_url = urljoin(support_realm_url, reverse(support_view))\n",
                "    query = urlencode({\"q\": query_text})\n",
                "    support_url = append_url_query_string(support_url, query)\n",
                "    return support_url\n",
                "\n",
                "\n",
                "class BillingError(JsonableError):\n",
                "    data_fields = [\"error_description\"]\n",
                "    # error messages\n",
                "    CONTACT_SUPPORT = gettext_lazy(\"Something went wrong. Please contact {email}.\")\n",
                "    TRY_RELOADING = gettext_lazy(\"Something went wrong. Please reload the page.\")\n",
                "\n",
                "    # description is used only for tests\n",
                "    def __init__(self, description: str, message: Optional[str] = None) -> None:\n",
                "        self.error_description = description\n",
                "        if message is None:\n",
                "            message = BillingError.CONTACT_SUPPORT.format(email=settings.ZULIP_ADMINISTRATOR)\n",
                "        super().__init__(message)\n",
                "\n",
                "\n",
                "class LicenseLimitError(Exception):\n",
                "    pass\n",
                "\n",
                "\n",
                "class StripeCardError(BillingError):\n",
                "    pass\n",
                "\n",
                "\n",
                "class StripeConnectionError(BillingError):\n",
                "    pass\n",
                "\n",
                "\n",
                "class UpgradeWithExistingPlanError(BillingError):\n",
                "    def __init__(self) -> None:\n",
                "        super().__init__(\n",
                "            \"subscribing with existing subscription\",\n",
                "            \"The organization is already subscribed to a plan. Please reload the billing page.\",\n",
                "        )\n",
                "\n",
                "\n",
                "class InvalidPlanUpgradeError(BillingError):  # nocoverage\n",
                "    def __init__(self, message: str) -> None:\n",
                "        super().__init__(\n",
                "            \"invalid plan upgrade\",\n",
                "            message,\n",
                "        )\n",
                "\n",
                "\n",
                "class InvalidBillingScheduleError(Exception):\n",
                "    def __init__(self, billing_schedule: int) -> None:\n",
                "        self.message = f\"Unknown billing_schedule: {billing_schedule}\"\n",
                "        super().__init__(self.message)\n",
                "\n",
                "\n",
                "class InvalidTierError(Exception):\n",
                "    def __init__(self, tier: int) -> None:\n",
                "        self.message = f\"Unknown tier: {tier}\"\n",
                "        super().__init__(self.message)\n",
                "\n",
                "\n",
                "def catch_stripe_errors(func: Callable[ParamT, ReturnT]) -> Callable[ParamT, ReturnT]:\n",
                "    @wraps(func)\n",
                "    def wrapped(*args: ParamT.args, **kwargs: ParamT.kwargs) -> ReturnT:\n",
                "        try:\n",
                "            return func(*args, **kwargs)\n",
                "        # See https://stripe.com/docs/api/python#error_handling, though\n",
                "        # https://stripe.com/docs/api/ruby#error_handling suggests there are additional fields, and\n",
                "        # https://stripe.com/docs/error-codes gives a more detailed set of error codes\n",
                "        except stripe.error.StripeError as e:\n",
                "            assert isinstance(e.json_body, dict)\n",
                "            err = e.json_body.get(\"error\", {})\n",
                "            if isinstance(e, stripe.error.CardError):\n",
                "                billing_logger.info(\n",
                "                    \"Stripe card error: %s %s %s %s\",\n",
                "                    e.http_status,\n",
                "                    err.get(\"type\"),\n",
                "                    err.get(\"code\"),\n",
                "                    err.get(\"param\"),\n",
                "                )\n",
                "                # TODO: Look into i18n for this\n",
                "                raise StripeCardError(\"card error\", err.get(\"message\"))\n",
                "            billing_logger.error(\n",
                "                \"Stripe error: %s %s %s %s\",\n",
                "                e.http_status,\n",
                "                err.get(\"type\"),\n",
                "                err.get(\"code\"),\n",
                "                err.get(\"param\"),\n",
                "            )\n",
                "            if isinstance(\n",
                "                e, (stripe.error.RateLimitError, stripe.error.APIConnectionError)\n",
                "            ):  # nocoverage TODO\n",
                "                raise StripeConnectionError(\n",
                "                    \"stripe connection error\",\n",
                "                    _(\"Something went wrong. Please wait a few seconds and try again.\"),\n",
                "                )\n",
                "            raise BillingError(\"other stripe error\")\n",
                "\n",
                "    return wrapped\n",
                "\n",
                "\n",
                "@catch_stripe_errors\n",
                "def stripe_get_customer(stripe_customer_id: str) -> stripe.Customer:\n",
                "    return stripe.Customer.retrieve(\n",
                "        stripe_customer_id, expand=[\"invoice_settings\", \"invoice_settings.default_payment_method\"]\n",
                "    )\n",
                "\n",
                "\n",
                "def sponsorship_org_type_key_helper(d: Any) -> int:\n",
                "    return d[1][\"display_order\"]\n",
                "\n",
                "\n",
                "class PriceArgs(TypedDict, total=False):\n",
                "    amount: int\n",
                "    unit_amount: int\n",
                "    quantity: int\n",
                "\n",
                "\n",
                "@dataclass\n",
                "class StripeCustomerData:\n",
                "    description: str\n",
                "    email: str\n",
                "    metadata: Dict[str, Any]\n",
                "\n",
                "\n",
                "@dataclass\n",
                "class StripePaymentIntentData:\n",
                "    amount: int\n",
                "    description: str\n",
                "    plan_name: str\n",
                "    email: str\n",
                "\n",
                "\n",
                "@dataclass\n",
                "class UpgradeRequest:\n",
                "    billing_modality: str\n",
                "    schedule: str\n",
                "    signed_seat_count: str\n",
                "    salt: str\n",
                "    license_management: Optional[str]\n",
                "    licenses: Optional[int]\n",
                "    tier: int\n",
                "    remote_server_plan_start_date: Optional[str]\n",
                "\n",
                "\n",
                "@dataclass\n",
                "class InitialUpgradeRequest:\n",
                "    manual_license_management: bool\n",
                "    tier: int\n",
                "    success_message: str = \"\"\n",
                "\n",
                "\n",
                "@dataclass\n",
                "class UpdatePlanRequest:\n",
                "    status: Optional[int]\n",
                "    licenses: Optional[int]\n",
                "    licenses_at_next_renewal: Optional[int]\n",
                "    schedule: Optional[int]\n",
                "\n",
                "\n",
                "@dataclass\n",
                "class EventStatusRequest:\n",
                "    stripe_session_id: Optional[str]\n",
                "    stripe_payment_intent_id: Optional[str]\n",
                "\n",
                "\n",
                "class SupportType(Enum):\n",
                "    approve_sponsorship = 1\n",
                "    update_sponsorship_status = 2\n",
                "    attach_discount = 3\n",
                "    update_billing_modality = 4\n",
                "    modify_plan = 5\n",
                "\n",
                "\n",
                "class SupportViewRequest(TypedDict, total=False):\n",
                "    support_type: SupportType\n",
                "    sponsorship_status: Optional[bool]\n",
                "    discount: Optional[Decimal]\n",
                "    billing_modality: Optional[str]\n",
                "    plan_modification: Optional[str]\n",
                "    new_plan_tier: Optional[int]\n",
                "\n",
                "\n",
                "class AuditLogEventType(Enum):\n",
                "    STRIPE_CUSTOMER_CREATED = 1\n",
                "    STRIPE_CARD_CHANGED = 2\n",
                "    CUSTOMER_PLAN_CREATED = 3\n",
                "    DISCOUNT_CHANGED = 4\n",
                "    SPONSORSHIP_APPROVED = 5\n",
                "    SPONSORSHIP_PENDING_STATUS_CHANGED = 6\n",
                "    BILLING_MODALITY_CHANGED = 7\n",
                "    CUSTOMER_SWITCHED_FROM_MONTHLY_TO_ANNUAL_PLAN = 8\n",
                "    CUSTOMER_SWITCHED_FROM_ANNUAL_TO_MONTHLY_PLAN = 9\n",
                "    BILLING_ENTITY_PLAN_TYPE_CHANGED = 10\n",
                "\n",
                "\n",
                "class PlanTierChangeType(Enum):\n",
                "    INVALID = 1\n",
                "    UPGRADE = 2\n",
                "    DOWNGRADE = 3\n",
                "\n",
                "\n",
                "class BillingSessionAuditLogEventError(Exception):\n",
                "    def __init__(self, event_type: AuditLogEventType) -> None:\n",
                "        self.message = f\"Unknown audit log event type: {event_type}\"\n",
                "        super().__init__(self.message)\n",
                "\n",
                "\n",
                "class UpgradePageParams(TypedDict):\n",
                "    annual_price: int\n",
                "    demo_organization_scheduled_deletion_date: Optional[datetime]\n",
                "    monthly_price: int\n",
                "    seat_count: int\n",
                "    billing_base_url: str\n",
                "\n",
                "\n",
                "class UpgradePageSessionTypeSpecificContext(TypedDict):\n",
                "    customer_name: str\n",
                "    email: str\n",
                "    is_demo_organization: bool\n",
                "    demo_organization_scheduled_deletion_date: Optional[datetime]\n",
                "    is_self_hosting: bool\n",
                "\n",
                "\n",
                "class SponsorshipApplicantInfo(TypedDict):\n",
                "    name: str\n",
                "    role: str\n",
                "    email: str\n",
                "\n",
                "\n",
                "class SponsorshipRequestSessionSpecificContext(TypedDict):\n",
                "    # We don't store UserProfile for remote realms.\n",
                "    realm_user: Optional[UserProfile]\n",
                "    user_info: SponsorshipApplicantInfo\n",
                "    # TODO: Call this what we end up calling it for /support page.\n",
                "    realm_string_id: str\n",
                "\n",
                "\n",
                "class UpgradePageContext(TypedDict):\n",
                "    customer_name: str\n",
                "    default_invoice_days_until_due: int\n",
                "    discount_percent: Optional[str]\n",
                "    email: str\n",
                "    exempt_from_license_number_check: bool\n",
                "    free_trial_days: Optional[int]\n",
                "    free_trial_end_date: Optional[str]\n",
                "    is_demo_organization: bool\n",
                "    manual_license_management: bool\n",
                "    using_min_licenses_for_plan: bool\n",
                "    page_params: UpgradePageParams\n",
                "    payment_method: Optional[str]\n",
                "    plan: str\n",
                "    remote_server_legacy_plan_end_date: Optional[str]\n",
                "    salt: str\n",
                "    seat_count: int\n",
                "    signed_seat_count: str\n",
                "    success_message: str\n",
                "\n",
                "\n",
                "class SponsorshipRequestForm(forms.Form):\n",
                "    website = forms.URLField(max_length=ZulipSponsorshipRequest.MAX_ORG_URL_LENGTH, required=False)\n",
                "    organization_type = forms.IntegerField()\n",
                "    description = forms.CharField(widget=forms.Textarea)\n",
                "    expected_total_users = forms.CharField(widget=forms.Textarea)\n",
                "    paid_users_count = forms.CharField(widget=forms.Textarea)\n",
                "    paid_users_description = forms.CharField(widget=forms.Textarea, required=False)\n",
                "    requested_plan = forms.ChoiceField(\n",
                "        choices=[(plan.value, plan.name) for plan in SponsoredPlanTypes], required=False\n",
                "    )\n",
                "\n",
                "\n",
                "class BillingSession(ABC):\n",
                "    @property\n",
                "    @abstractmethod\n",
                "    def billing_entity_display_name(self) -> str:\n",
                "        pass\n",
                "\n",
                "    @property\n",
                "    @abstractmethod\n",
                "    def billing_session_url(self) -> str:\n",
                "        pass\n",
                "\n",
                "    @property\n",
                "    @abstractmethod\n",
                "    def billing_base_url(self) -> str:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def support_url(self) -> str:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_customer(self) -> Optional[Customer]:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_email(self) -> str:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def current_count_for_billed_licenses(self, event_time: datetime = timezone_now()) -> int:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_audit_log_event(self, event_type: AuditLogEventType) -> int:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def write_to_audit_log(\n",
                "        self,\n",
                "        event_type: AuditLogEventType,\n",
                "        event_time: datetime,\n",
                "        *,\n",
                "        extra_data: Optional[Dict[str, Any]] = None,\n",
                "    ) -> None:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_data_for_stripe_customer(self) -> StripeCustomerData:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def update_data_for_checkout_session_and_payment_intent(\n",
                "        self, metadata: Dict[str, Any]\n",
                "    ) -> Dict[str, Any]:\n",
                "        pass\n",
                "\n",
                "    def get_data_for_stripe_payment_intent(\n",
                "        self,\n",
                "        price_per_license: int,\n",
                "        licenses: int,\n",
                "        plan_tier: int,\n",
                "        email: str,\n",
                "    ) -> StripePaymentIntentData:\n",
                "        if hasattr(self, \"support_session\") and self.support_session:  # nocoverage\n",
                "            raise BillingError(\n",
                "                \"invalid support session\",\n",
                "                \"Support requests do not set any stripe billing information.\",\n",
                "            )\n",
                "\n",
                "        amount = price_per_license * licenses\n",
                "\n",
                "        plan_name = CustomerPlan.name_from_tier(plan_tier)\n",
                "        description = f\"Upgrade to {plan_name}, ${price_per_license/100} x {licenses}\"\n",
                "        return StripePaymentIntentData(\n",
                "            amount=amount,\n",
                "            description=description,\n",
                "            plan_name=plan_name,\n",
                "            email=email,\n",
                "        )\n",
                "\n",
                "    @abstractmethod\n",
                "    def update_or_create_customer(\n",
                "        self, stripe_customer_id: Optional[str] = None, *, defaults: Optional[Dict[str, Any]] = None\n",
                "    ) -> Customer:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def do_change_plan_type(self, *, tier: Optional[int], is_sponsored: bool = False) -> None:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def process_downgrade(self, plan: CustomerPlan) -> None:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def approve_sponsorship(self) -> str:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def is_sponsored(self) -> bool:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_sponsorship_request_session_specific_context(\n",
                "        self,\n",
                "    ) -> SponsorshipRequestSessionSpecificContext:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def save_org_type_from_request_sponsorship_session(self, org_type: int) -> None:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_upgrade_page_session_type_specific_context(\n",
                "        self,\n",
                "    ) -> UpgradePageSessionTypeSpecificContext:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_type_of_plan_tier_change(\n",
                "        self, current_plan_tier: int, new_plan_tier: int\n",
                "    ) -> PlanTierChangeType:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def has_billing_access(self) -> bool:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def on_paid_plan(self) -> bool:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def add_sponsorship_info_to_context(self, context: Dict[str, Any]) -> None:\n",
                "        pass\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_metadata_for_stripe_update_card(self) -> Dict[str, Any]:\n",
                "        pass\n",
                "\n",
                "    def is_sponsored_or_pending(self, customer: Optional[Customer]) -> bool:\n",
                "        if (customer is not None and customer.sponsorship_pending) or self.is_sponsored():\n",
                "            return True\n",
                "        return False\n",
                "\n",
                "    def get_remote_server_legacy_plan(\n",
                "        self, customer: Optional[Customer], status: int = CustomerPlan.ACTIVE\n",
                "    ) -> Optional[CustomerPlan]:\n",
                "        # status = CustomerPlan.ACTIVE means that the legacy plan is not scheduled for an upgrade.\n",
                "        # status = CustomerPlan.SWITCH_PLAN_TIER_AT_PLAN_END means that the legacy plan is scheduled for an upgrade.\n",
                "        if customer is None:\n",
                "            return None\n",
                "\n",
                "        return CustomerPlan.objects.filter(\n",
                "            customer=customer,\n",
                "            tier=CustomerPlan.TIER_SELF_HOSTED_LEGACY,\n",
                "            status=status,\n",
                "            next_invoice_date=None,\n",
                "        ).first()\n",
                "\n",
                "    def get_formatted_remote_server_legacy_plan_end_date(\n",
                "        self, customer: Optional[Customer], status: int = CustomerPlan.ACTIVE\n",
                "    ) -> Optional[str]:  # nocoverage\n",
                "        plan = self.get_remote_server_legacy_plan(customer, status)\n",
                "        if plan is None:\n",
                "            return None\n",
                "\n",
                "        assert plan.end_date is not None\n",
                "        return plan.end_date.strftime(\"%B %d, %Y\")\n",
                "\n",
                "    def get_legacy_remote_server_next_plan(\n",
                "        self, customer: Customer\n",
                "    ) -> Optional[CustomerPlan]:  # nocoverage\n",
                "        legacy_plan = self.get_remote_server_legacy_plan(\n",
                "            customer, CustomerPlan.SWITCH_PLAN_TIER_AT_PLAN_END\n",
                "        )\n",
                "        if legacy_plan is None:\n",
                "            return None\n",
                "\n",
                "        # This also asserts that such a plan should exist.\n",
                "        assert legacy_plan.end_date is not None\n",
                "        return CustomerPlan.objects.get(\n",
                "            customer=customer,\n",
                "            billing_cycle_anchor=legacy_plan.end_date,\n",
                "            status=CustomerPlan.NEVER_STARTED,\n",
                "        )\n",
                "\n",
                "    def get_legacy_remote_server_next_plan_name(\n",
                "        self, customer: Customer\n",
                "    ) -> Optional[str]:  # nocoverage\n",
                "        next_plan = self.get_legacy_remote_server_next_plan(customer)\n",
                "        if next_plan is None:\n",
                "            return None\n",
                "        return next_plan.name\n",
                "\n",
                "    @catch_stripe_errors\n",
                "    def create_stripe_customer(self) -> Customer:\n",
                "        stripe_customer_data = self.get_data_for_stripe_customer()\n",
                "        stripe_customer = stripe.Customer.create(\n",
                "            description=stripe_customer_data.description,\n",
                "            email=stripe_customer_data.email,\n",
                "            metadata=stripe_customer_data.metadata,\n",
                "        )\n",
                "        event_time = timestamp_to_datetime(stripe_customer.created)\n",
                "        with transaction.atomic():\n",
                "            self.write_to_audit_log(AuditLogEventType.STRIPE_CUSTOMER_CREATED, event_time)\n",
                "            customer = self.update_or_create_customer(stripe_customer.id)\n",
                "        return customer\n",
                "\n",
                "    @catch_stripe_errors\n",
                "    def replace_payment_method(\n",
                "        self, stripe_customer_id: str, payment_method: str, pay_invoices: bool = False\n",
                "    ) -> None:\n",
                "        stripe.Customer.modify(\n",
                "            stripe_customer_id, invoice_settings={\"default_payment_method\": payment_method}\n",
                "        )\n",
                "        self.write_to_audit_log(AuditLogEventType.STRIPE_CARD_CHANGED, timezone_now())\n",
                "        if pay_invoices:\n",
                "            for stripe_invoice in stripe.Invoice.list(\n",
                "                collection_method=\"charge_automatically\",\n",
                "                customer=stripe_customer_id,\n",
                "                status=\"open\",\n",
                "            ):\n",
                "                # The stripe customer with the associated ID will get either a receipt\n",
                "                # or a \"failed payment\" email, but the in-app messaging could be clearer\n",
                "                # here (e.g. it could explicitly tell the user that there were payment(s)\n",
                "                # and that they succeeded or failed). Worth fixing if we notice that a\n",
                "                # lot of cards end up failing at this step.\n",
                "                stripe.Invoice.pay(stripe_invoice)\n",
                "\n",
                "    # Returns Customer instead of stripe_customer so that we don't make a Stripe\n",
                "    # API call if there's nothing to update\n",
                "    @catch_stripe_errors\n",
                "    def update_or_create_stripe_customer(self, payment_method: Optional[str] = None) -> Customer:\n",
                "        customer = self.get_customer()\n",
                "        if customer is None or customer.stripe_customer_id is None:\n",
                "            # A stripe.PaymentMethod should be attached to a stripe.Customer via\n",
                "            # a stripe.SetupIntent or stripe.PaymentIntent. Here we just want to\n",
                "            # create a new stripe.Customer.\n",
                "            assert payment_method is None\n",
                "            # We could do a better job of handling race conditions here, but if two\n",
                "            # people try to upgrade at exactly the same time, the main bad thing that\n",
                "            # will happen is that we will create an extra stripe.Customer that we can\n",
                "            # delete or ignore.\n",
                "            return self.create_stripe_customer()\n",
                "        if payment_method is not None:\n",
                "            self.replace_payment_method(customer.stripe_customer_id, payment_method, True)\n",
                "        return customer\n",
                "\n",
                "    def create_stripe_payment_intent(\n",
                "        self, price_per_license: int, licenses: int, metadata: Dict[str, Any]\n",
                "    ) -> str:\n",
                "        # NOTE: This charges users immediately.\n",
                "        customer = self.get_customer()\n",
                "        assert customer is not None and customer.stripe_customer_id is not None\n",
                "        payment_intent_data = self.get_data_for_stripe_payment_intent(\n",
                "            price_per_license, licenses, metadata[\"plan_tier\"], self.get_email()\n",
                "        )\n",
                "        # Ensure customers have a default payment method set.\n",
                "        stripe_customer = stripe_get_customer(customer.stripe_customer_id)\n",
                "        if not stripe_customer_has_credit_card_as_default_payment_method(stripe_customer):\n",
                "            raise BillingError(\n",
                "                \"no payment method\",\n",
                "                \"Please add a credit card before upgrading.\",\n",
                "            )\n",
                "\n",
                "        assert stripe_customer.invoice_settings is not None\n",
                "        assert stripe_customer.invoice_settings.default_payment_method is not None\n",
                "        try:\n",
                "            # Try to charge user immediately, and if that fails, we inform the user about the failure.\n",
                "            stripe_payment_intent = stripe.PaymentIntent.create(\n",
                "                amount=payment_intent_data.amount,\n",
                "                currency=\"usd\",\n",
                "                customer=customer.stripe_customer_id,\n",
                "                description=payment_intent_data.description,\n",
                "                receipt_email=payment_intent_data.email,\n",
                "                confirm=True,\n",
                "                statement_descriptor=payment_intent_data.plan_name,\n",
                "                metadata=metadata,\n",
                "                off_session=True,\n",
                "                payment_method=stripe_customer.invoice_settings.default_payment_method,\n",
                "            )\n",
                "        except stripe.error.CardError as e:\n",
                "            raise StripeCardError(\"card error\", e.user_message)\n",
                "\n",
                "        PaymentIntent.objects.create(\n",
                "            customer=customer,\n",
                "            stripe_payment_intent_id=stripe_payment_intent.id,\n",
                "            status=PaymentIntent.get_status_integer_from_status_text(stripe_payment_intent.status),\n",
                "        )\n",
                "        return stripe_payment_intent.id\n",
                "\n",
                "    def create_card_update_session_for_upgrade(\n",
                "        self,\n",
                "        manual_license_management: bool,\n",
                "    ) -> Dict[str, Any]:\n",
                "        metadata = self.get_metadata_for_stripe_update_card()\n",
                "        customer = self.update_or_create_stripe_customer()\n",
                "        cancel_url = f\"{self.billing_session_url}/upgrade/\"\n",
                "        if manual_license_management:\n",
                "            cancel_url = f\"{self.billing_session_url}/upgrade/?manual_license_management=true\"\n",
                "\n",
                "        stripe_session = stripe.checkout.Session.create(\n",
                "            cancel_url=cancel_url,\n",
                "            customer=customer.stripe_customer_id,\n",
                "            metadata=metadata,\n",
                "            mode=\"setup\",\n",
                "            payment_method_types=[\"card\"],\n",
                "            success_url=f\"{self.billing_session_url}/billing/event_status?stripe_session_id={{CHECKOUT_SESSION_ID}}\",\n",
                "        )\n",
                "        Session.objects.create(\n",
                "            stripe_session_id=stripe_session.id,\n",
                "            customer=customer,\n",
                "            type=Session.CARD_UPDATE_FROM_UPGRADE_PAGE,\n",
                "            is_manual_license_management_upgrade_session=manual_license_management,\n",
                "        )\n",
                "        return {\n",
                "            \"stripe_session_url\": stripe_session.url,\n",
                "            \"stripe_session_id\": stripe_session.id,\n",
                "        }\n",
                "\n",
                "    def create_card_update_session(self) -> Dict[str, Any]:\n",
                "        metadata = self.get_metadata_for_stripe_update_card()\n",
                "        customer = self.get_customer()\n",
                "        assert customer is not None and customer.stripe_customer_id is not None\n",
                "        stripe_session = stripe.checkout.Session.create(\n",
                "            cancel_url=f\"{self.billing_session_url}/billing/\",\n",
                "            customer=customer.stripe_customer_id,\n",
                "            metadata=metadata,\n",
                "            mode=\"setup\",\n",
                "            payment_method_types=[\"card\"],\n",
                "            success_url=f\"{self.billing_session_url}/billing/event_status?stripe_session_id={{CHECKOUT_SESSION_ID}}\",\n",
                "        )\n",
                "        Session.objects.create(\n",
                "            stripe_session_id=stripe_session.id,\n",
                "            customer=customer,\n",
                "            type=Session.CARD_UPDATE_FROM_BILLING_PAGE,\n",
                "        )\n",
                "        return {\n",
                "            \"stripe_session_url\": stripe_session.url,\n",
                "            \"stripe_session_id\": stripe_session.id,\n",
                "        }\n",
                "\n",
                "    def apply_discount_to_plan(\n",
                "        self,\n",
                "        plan: CustomerPlan,\n",
                "        discount: Decimal,\n",
                "    ) -> None:\n",
                "        plan.discount = discount\n",
                "        plan.price_per_license = get_price_per_license(plan.tier, plan.billing_schedule, discount)\n",
                "        plan.save(update_fields=[\"discount\", \"price_per_license\"])\n",
                "\n",
                "    def attach_discount_to_customer(self, new_discount: Decimal) -> str:\n",
                "        customer = self.get_customer()\n",
                "        old_discount = None\n",
                "        if customer is not None:\n",
                "            old_discount = customer.default_discount\n",
                "            customer.default_discount = new_discount\n",
                "            customer.save(update_fields=[\"default_discount\"])\n",
                "        else:\n",
                "            customer = self.update_or_create_customer(defaults={\"default_discount\": new_discount})\n",
                "        plan = get_current_plan_by_customer(customer)\n",
                "        if plan is not None:\n",
                "            self.apply_discount_to_plan(plan, new_discount)\n",
                "\n",
                "            # If the customer has a next plan, apply discount to that plan as well.\n",
                "            # Make this a check on CustomerPlan.SWITCH_PLAN_TIER_AT_PLAN_END status\n",
                "            # if we support this for other plans.\n",
                "            next_plan = self.get_legacy_remote_server_next_plan(customer)\n",
                "            if next_plan is not None:  # nocoverage\n",
                "                self.apply_discount_to_plan(next_plan, new_discount)\n",
                "\n",
                "        self.write_to_audit_log(\n",
                "            event_type=AuditLogEventType.DISCOUNT_CHANGED,\n",
                "            event_time=timezone_now(),\n",
                "            extra_data={\"old_discount\": old_discount, \"new_discount\": new_discount},\n",
                "        )\n",
                "        if old_discount is None:\n",
                "            old_discount = Decimal(0)\n",
                "        return f\"Discount for {self.billing_entity_display_name} changed to {new_discount}% from {old_discount}%.\"\n",
                "\n",
                "    def update_customer_sponsorship_status(self, sponsorship_pending: bool) -> str:\n",
                "        customer = self.get_customer()\n",
                "        if customer is None:\n",
                "            customer = self.update_or_create_customer()\n",
                "        customer.sponsorship_pending = sponsorship_pending\n",
                "        customer.save(update_fields=[\"sponsorship_pending\"])\n",
                "        self.write_to_audit_log(\n",
                "            event_type=AuditLogEventType.SPONSORSHIP_PENDING_STATUS_CHANGED,\n",
                "            event_time=timezone_now(),\n",
                "            extra_data={\"sponsorship_pending\": sponsorship_pending},\n",
                "        )\n",
                "\n",
                "        if sponsorship_pending:\n",
                "            success_message = f\"{self.billing_entity_display_name} marked as pending sponsorship.\"\n",
                "        else:\n",
                "            success_message = (\n",
                "                f\"{self.billing_entity_display_name} is no longer pending sponsorship.\"\n",
                "            )\n",
                "        return success_message\n",
                "\n",
                "    def update_billing_modality_of_current_plan(self, charge_automatically: bool) -> str:\n",
                "        customer = self.get_customer()\n",
                "        if customer is not None:\n",
                "            plan = get_current_plan_by_customer(customer)\n",
                "            if plan is not None:\n",
                "                plan.charge_automatically = charge_automatically\n",
                "                plan.save(update_fields=[\"charge_automatically\"])\n",
                "                self.write_to_audit_log(\n",
                "                    event_type=AuditLogEventType.BILLING_MODALITY_CHANGED,\n",
                "                    event_time=timezone_now(),\n",
                "                    extra_data={\"charge_automatically\": charge_automatically},\n",
                "                )\n",
                "        if charge_automatically:\n",
                "            success_message = f\"Billing collection method of {self.billing_entity_display_name} updated to charge automatically.\"\n",
                "        else:\n",
                "            success_message = f\"Billing collection method of {self.billing_entity_display_name} updated to send invoice.\"\n",
                "        return success_message\n",
                "\n",
                "    def setup_upgrade_payment_intent_and_charge(\n",
                "        self,\n",
                "        plan_tier: int,\n",
                "        seat_count: int,\n",
                "        licenses: int,\n",
                "        license_management: str,\n",
                "        billing_schedule: int,\n",
                "        billing_modality: str,\n",
                "    ) -> str:\n",
                "        customer = self.update_or_create_stripe_customer()\n",
                "        assert customer is not None  # for mypy\n",
                "        price_per_license = get_price_per_license(\n",
                "            plan_tier, billing_schedule, customer.default_discount\n",
                "        )\n",
                "        general_metadata = {\n",
                "            \"billing_modality\": billing_modality,\n",
                "            \"billing_schedule\": billing_schedule,\n",
                "            \"licenses\": licenses,\n",
                "            \"license_management\": license_management,\n",
                "            \"price_per_license\": price_per_license,\n",
                "            \"seat_count\": seat_count,\n",
                "            \"type\": \"upgrade\",\n",
                "            \"plan_tier\": plan_tier,\n",
                "        }\n",
                "        updated_metadata = self.update_data_for_checkout_session_and_payment_intent(\n",
                "            general_metadata\n",
                "        )\n",
                "        stripe_payment_intent_id = self.create_stripe_payment_intent(\n",
                "            price_per_license, licenses, updated_metadata\n",
                "        )\n",
                "        return stripe_payment_intent_id\n",
                "\n",
                "    def ensure_current_plan_is_upgradable(\n",
                "        self, customer: Customer, new_plan_tier: int\n",
                "    ) -> None:  # nocoverage\n",
                "        # Upgrade for customers with an existing plan is only supported for remote servers right now.\n",
                "        if not hasattr(self, \"remote_server\"):\n",
                "            ensure_customer_does_not_have_active_plan(customer)\n",
                "            return\n",
                "\n",
                "        plan = get_current_plan_by_customer(customer)\n",
                "        assert plan is not None\n",
                "        type_of_plan_change = self.get_type_of_plan_tier_change(plan.tier, new_plan_tier)\n",
                "        if type_of_plan_change != PlanTierChangeType.UPGRADE:\n",
                "            raise InvalidPlanUpgradeError(\n",
                "                f\"Cannot upgrade from {plan.name} to {CustomerPlan.name_from_tier(new_plan_tier)}\"\n",
                "            )\n",
                "\n",
                "    @catch_stripe_errors\n",
                "    def process_initial_upgrade(\n",
                "        self,\n",
                "        plan_tier: int,\n",
                "        licenses: int,\n",
                "        automanage_licenses: bool,\n",
                "        billing_schedule: int,\n",
                "        charge_automatically: bool,\n",
                "        free_trial: bool,\n",
                "        remote_server_legacy_plan: Optional[CustomerPlan] = None,\n",
                "        should_schedule_upgrade_for_legacy_remote_server: bool = False,\n",
                "    ) -> None:\n",
                "        customer = self.update_or_create_stripe_customer()\n",
                "        assert customer.stripe_customer_id is not None  # for mypy\n",
                "        self.ensure_current_plan_is_upgradable(customer, plan_tier)\n",
                "        billing_cycle_anchor = None\n",
                "        if should_schedule_upgrade_for_legacy_remote_server:  # nocoverage\n",
                "            assert remote_server_legacy_plan is not None\n",
                "            billing_cycle_anchor = remote_server_legacy_plan.end_date\n",
                "\n",
                "        (\n",
                "            billing_cycle_anchor,\n",
                "            next_invoice_date,\n",
                "            period_end,\n",
                "            price_per_license,\n",
                "        ) = compute_plan_parameters(\n",
                "            plan_tier,\n",
                "            automanage_licenses,\n",
                "            billing_schedule,\n",
                "            customer.default_discount,\n",
                "            free_trial,\n",
                "            billing_cycle_anchor,\n",
                "        )\n",
                "\n",
                "        # TODO: The correctness of this relies on user creation, deactivation, etc being\n",
                "        # in a transaction.atomic() with the relevant RealmAuditLog entries\n",
                "        with transaction.atomic():\n",
                "            if customer.exempt_from_license_number_check:\n",
                "                billed_licenses = licenses\n",
                "            else:\n",
                "                # billed_licenses can be greater than licenses if users are added between the start of\n",
                "                # this function (process_initial_upgrade) and now\n",
                "                current_licenses_count = self.current_count_for_billed_licenses()\n",
                "                billed_licenses = max(current_licenses_count, licenses)\n",
                "            plan_params = {\n",
                "                \"automanage_licenses\": automanage_licenses,\n",
                "                \"charge_automatically\": charge_automatically,\n",
                "                \"price_per_license\": price_per_license,\n",
                "                \"discount\": customer.default_discount,\n",
                "                \"billing_cycle_anchor\": billing_cycle_anchor,\n",
                "                \"billing_schedule\": billing_schedule,\n",
                "                \"tier\": plan_tier,\n",
                "            }\n",
                "            if free_trial:\n",
                "                plan_params[\"status\"] = CustomerPlan.FREE_TRIAL\n",
                "\n",
                "                if charge_automatically:\n",
                "                    # Ensure free trial customers not paying via invoice have a default payment method set\n",
                "                    stripe_customer = stripe_get_customer(customer.stripe_customer_id)\n",
                "                    if not stripe_customer_has_credit_card_as_default_payment_method(\n",
                "                        stripe_customer\n",
                "                    ):\n",
                "                        raise BillingError(\n",
                "                            \"no payment method\",\n",
                "                            _(\"Please add a credit card before starting your free trial.\"),\n",
                "                        )\n",
                "\n",
                "            event_time = billing_cycle_anchor\n",
                "            if should_schedule_upgrade_for_legacy_remote_server:  # nocoverage\n",
                "                # In this code path, we are currently on a legacy plan\n",
                "                # and are scheduling an upgrade to a non-legacy plan\n",
                "                # that should occur when the legacy plan expires.\n",
                "                #\n",
                "                # We will create a new NEVER_STARTED plan for the\n",
                "                # customer, scheduled to start when the current one\n",
                "                # expires.\n",
                "                assert remote_server_legacy_plan is not None\n",
                "                if charge_automatically:\n",
                "                    # Ensure customers not paying via invoice have a default payment method set.\n",
                "                    stripe_customer = stripe_get_customer(customer.stripe_customer_id)\n",
                "                    if not stripe_customer_has_credit_card_as_default_payment_method(\n",
                "                        stripe_customer\n",
                "                    ):\n",
                "                        raise BillingError(\n",
                "                            \"no payment method\",\n",
                "                            _(\"Please add a credit card to schedule upgrade.\"),\n",
                "                        )\n",
                "\n",
                "                # Settings status > CustomerPLan.LIVE_STATUS_THRESHOLD makes sure we don't have\n",
                "                # to worry about this plan being used for any other purpose.\n",
                "                # NOTE: This is the 2nd plan for the customer.\n",
                "                plan_params[\"status\"] = CustomerPlan.NEVER_STARTED\n",
                "                event_time = timezone_now().replace(microsecond=0)\n",
                "\n",
                "                # Schedule switching to the new plan at plan end date.\n",
                "                assert remote_server_legacy_plan.end_date == billing_cycle_anchor\n",
                "                remote_server_legacy_plan.status = CustomerPlan.SWITCH_PLAN_TIER_AT_PLAN_END\n",
                "                remote_server_legacy_plan.save(update_fields=[\"status\"])\n",
                "            elif remote_server_legacy_plan is not None:  # nocoverage\n",
                "                remote_server_legacy_plan.status = CustomerPlan.ENDED\n",
                "                remote_server_legacy_plan.save(update_fields=[\"status\"])\n",
                "\n",
                "            plan = CustomerPlan.objects.create(\n",
                "                customer=customer, next_invoice_date=next_invoice_date, **plan_params\n",
                "            )\n",
                "\n",
                "            if plan.status < CustomerPlan.LIVE_STATUS_THRESHOLD:\n",
                "                # LicenseLedger entries are way for us to charge customer and track their license usage.\n",
                "                # So, we should only create these entries for live plans.\n",
                "                ledger_entry = LicenseLedger.objects.create(\n",
                "                    plan=plan,\n",
                "                    is_renewal=True,\n",
                "                    event_time=event_time,\n",
                "                    licenses=billed_licenses,\n",
                "                    licenses_at_next_renewal=billed_licenses,\n",
                "                )\n",
                "                plan.invoiced_through = ledger_entry\n",
                "                plan.save(update_fields=[\"invoiced_through\"])\n",
                "\n",
                "            self.write_to_audit_log(\n",
                "                event_type=AuditLogEventType.CUSTOMER_PLAN_CREATED,\n",
                "                event_time=event_time,\n",
                "                extra_data=plan_params,\n",
                "            )\n",
                "\n",
                "        if not (free_trial or should_schedule_upgrade_for_legacy_remote_server):\n",
                "            assert plan is not None\n",
                "            stripe.InvoiceItem.create(\n",
                "                currency=\"usd\",\n",
                "                customer=customer.stripe_customer_id,\n",
                "                description=plan.name,\n",
                "                discountable=False,\n",
                "                period={\n",
                "                    \"start\": datetime_to_timestamp(billing_cycle_anchor),\n",
                "                    \"end\": datetime_to_timestamp(period_end),\n",
                "                },\n",
                "                quantity=billed_licenses,\n",
                "                unit_amount=price_per_license,\n",
                "            )\n",
                "\n",
                "            if charge_automatically:\n",
                "                collection_method = \"charge_automatically\"\n",
                "                days_until_due = None\n",
                "            else:\n",
                "                collection_method = \"send_invoice\"\n",
                "                days_until_due = DEFAULT_INVOICE_DAYS_UNTIL_DUE\n",
                "\n",
                "            stripe_invoice = stripe.Invoice.create(\n",
                "                auto_advance=True,\n",
                "                collection_method=collection_method,\n",
                "                customer=customer.stripe_customer_id,\n",
                "                days_until_due=days_until_due,\n",
                "                statement_descriptor=plan.name,\n",
                "            )\n",
                "            stripe.Invoice.finalize_invoice(stripe_invoice)\n",
                "\n",
                "        if plan.status < CustomerPlan.LIVE_STATUS_THRESHOLD:\n",
                "            # Tier and usage limit change will happen when plan becomes live.\n",
                "            self.do_change_plan_type(tier=plan_tier)\n",
                "\n",
                "    def do_upgrade(self, upgrade_request: UpgradeRequest) -> Dict[str, Any]:\n",
                "        customer = self.get_customer()\n",
                "        if customer is not None:\n",
                "            self.ensure_current_plan_is_upgradable(customer, upgrade_request.tier)\n",
                "        billing_modality = upgrade_request.billing_modality\n",
                "        schedule = upgrade_request.schedule\n",
                "        license_management = upgrade_request.license_management\n",
                "        licenses = upgrade_request.licenses\n",
                "\n",
                "        seat_count = unsign_seat_count(upgrade_request.signed_seat_count, upgrade_request.salt)\n",
                "        if billing_modality == \"charge_automatically\" and license_management == \"automatic\":\n",
                "            licenses = seat_count\n",
                "        if billing_modality == \"send_invoice\":\n",
                "            schedule = \"annual\"\n",
                "            license_management = \"manual\"\n",
                "\n",
                "        exempt_from_license_number_check = (\n",
                "            customer is not None and customer.exempt_from_license_number_check\n",
                "        )\n",
                "        check_upgrade_parameters(\n",
                "            billing_modality,\n",
                "            schedule,\n",
                "            license_management,\n",
                "            licenses,\n",
                "            seat_count,\n",
                "            exempt_from_license_number_check,\n",
                "            self.min_licenses_for_plan(upgrade_request.tier),\n",
                "        )\n",
                "        assert licenses is not None and license_management is not None\n",
                "        automanage_licenses = license_management == \"automatic\"\n",
                "        charge_automatically = billing_modality == \"charge_automatically\"\n",
                "\n",
                "        billing_schedule = {\n",
                "            \"annual\": CustomerPlan.BILLING_SCHEDULE_ANNUAL,\n",
                "            \"monthly\": CustomerPlan.BILLING_SCHEDULE_MONTHLY,\n",
                "        }[schedule]\n",
                "        data: Dict[str, Any] = {}\n",
                "        free_trial = is_free_trial_offer_enabled()\n",
                "        remote_server_legacy_plan = self.get_remote_server_legacy_plan(customer)\n",
                "        should_schedule_upgrade_for_legacy_remote_server = (\n",
                "            remote_server_legacy_plan is not None\n",
                "            and upgrade_request.remote_server_plan_start_date == \"billing_cycle_end_date\"\n",
                "        )\n",
                "        # Directly upgrade free trial orgs or invoice payment orgs to standard plan.\n",
                "        if (\n",
                "            should_schedule_upgrade_for_legacy_remote_server\n",
                "            or free_trial\n",
                "            or not charge_automatically\n",
                "        ):\n",
                "            self.process_initial_upgrade(\n",
                "                upgrade_request.tier,\n",
                "                licenses,\n",
                "                automanage_licenses,\n",
                "                billing_schedule,\n",
                "                charge_automatically,\n",
                "                is_free_trial_offer_enabled(),\n",
                "                remote_server_legacy_plan,\n",
                "                should_schedule_upgrade_for_legacy_remote_server,\n",
                "            )\n",
                "            data[\"organization_upgrade_successful\"] = True\n",
                "        else:\n",
                "            stripe_payment_intent_id = self.setup_upgrade_payment_intent_and_charge(\n",
                "                upgrade_request.tier,\n",
                "                seat_count,\n",
                "                licenses,\n",
                "                license_management,\n",
                "                billing_schedule,\n",
                "                billing_modality,\n",
                "            )\n",
                "            data[\"stripe_payment_intent_id\"] = stripe_payment_intent_id\n",
                "        return data\n",
                "\n",
                "    def do_change_schedule_after_free_trial(self, plan: CustomerPlan, schedule: int) -> None:\n",
                "        # Change the billing frequency of the plan after the free trial ends.\n",
                "        assert schedule in (\n",
                "            CustomerPlan.BILLING_SCHEDULE_MONTHLY,\n",
                "            CustomerPlan.BILLING_SCHEDULE_ANNUAL,\n",
                "        )\n",
                "        last_ledger_entry = LicenseLedger.objects.filter(plan=plan).order_by(\"-id\").first()\n",
                "        assert last_ledger_entry is not None\n",
                "        licenses_at_next_renewal = last_ledger_entry.licenses_at_next_renewal\n",
                "        assert licenses_at_next_renewal is not None\n",
                "        assert plan.next_invoice_date is not None\n",
                "        next_billing_cycle = plan.next_invoice_date\n",
                "\n",
                "        if plan.fixed_price is not None:  # nocoverage\n",
                "            raise BillingError(\"Customer is already on monthly fixed plan.\")\n",
                "\n",
                "        plan.status = CustomerPlan.ENDED\n",
                "        plan.save(update_fields=[\"status\"])\n",
                "\n",
                "        discount = plan.customer.default_discount or plan.discount\n",
                "        _, _, _, price_per_license = compute_plan_parameters(\n",
                "            tier=plan.tier,\n",
                "            automanage_licenses=plan.automanage_licenses,\n",
                "            billing_schedule=schedule,\n",
                "            discount=plan.discount,\n",
                "        )\n",
                "\n",
                "        new_plan = CustomerPlan.objects.create(\n",
                "            customer=plan.customer,\n",
                "            billing_schedule=schedule,\n",
                "            automanage_licenses=plan.automanage_licenses,\n",
                "            charge_automatically=plan.charge_automatically,\n",
                "            price_per_license=price_per_license,\n",
                "            discount=discount,\n",
                "            billing_cycle_anchor=plan.billing_cycle_anchor,\n",
                "            tier=plan.tier,\n",
                "            status=CustomerPlan.FREE_TRIAL,\n",
                "            next_invoice_date=next_billing_cycle,\n",
                "            invoiced_through=None,\n",
                "            invoicing_status=CustomerPlan.INVOICING_STATUS_INITIAL_INVOICE_TO_BE_SENT,\n",
                "        )\n",
                "\n",
                "        LicenseLedger.objects.create(\n",
                "            plan=new_plan,\n",
                "            is_renewal=True,\n",
                "            event_time=plan.billing_cycle_anchor,\n",
                "            licenses=licenses_at_next_renewal,\n",
                "            licenses_at_next_renewal=licenses_at_next_renewal,\n",
                "        )\n",
                "\n",
                "        if schedule == CustomerPlan.BILLING_SCHEDULE_ANNUAL:\n",
                "            self.write_to_audit_log(\n",
                "                event_type=AuditLogEventType.CUSTOMER_SWITCHED_FROM_MONTHLY_TO_ANNUAL_PLAN,\n",
                "                event_time=timezone_now(),\n",
                "                extra_data={\n",
                "                    \"monthly_plan_id\": plan.id,\n",
                "                    \"annual_plan_id\": new_plan.id,\n",
                "                },\n",
                "            )\n",
                "        else:\n",
                "            self.write_to_audit_log(\n",
                "                event_type=AuditLogEventType.CUSTOMER_SWITCHED_FROM_ANNUAL_TO_MONTHLY_PLAN,\n",
                "                event_time=timezone_now(),\n",
                "                extra_data={\n",
                "                    \"annual_plan_id\": plan.id,\n",
                "                    \"monthly_plan_id\": new_plan.id,\n",
                "                },\n",
                "            )\n",
                "\n",
                "    def get_next_billing_cycle(self, plan: CustomerPlan) -> datetime:\n",
                "        last_ledger_renewal = (\n",
                "            LicenseLedger.objects.filter(plan=plan, is_renewal=True).order_by(\"-id\").first()\n",
                "        )\n",
                "        assert last_ledger_renewal is not None\n",
                "        last_renewal = last_ledger_renewal.event_time\n",
                "\n",
                "        if plan.status in (\n",
                "            CustomerPlan.FREE_TRIAL,\n",
                "            CustomerPlan.DOWNGRADE_AT_END_OF_FREE_TRIAL,\n",
                "        ):\n",
                "            assert plan.next_invoice_date is not None\n",
                "            next_billing_cycle = plan.next_invoice_date\n",
                "        elif plan.status == CustomerPlan.SWITCH_PLAN_TIER_AT_PLAN_END:  # nocoverage\n",
                "            assert plan.end_date is not None\n",
                "            next_billing_cycle = plan.end_date\n",
                "        else:\n",
                "            next_billing_cycle = start_of_next_billing_cycle(plan, last_renewal)\n",
                "\n",
                "        return next_billing_cycle\n",
                "\n",
                "    # event_time should roughly be timezone_now(). Not designed to handle\n",
                "    # event_times in the past or future\n",
                "    @transaction.atomic\n",
                "    def make_end_of_cycle_updates_if_needed(\n",
                "        self, plan: CustomerPlan, event_time: datetime\n",
                "    ) -> Tuple[Optional[CustomerPlan], Optional[LicenseLedger]]:\n",
                "        last_ledger_entry = LicenseLedger.objects.filter(plan=plan).order_by(\"-id\").first()\n",
                "        next_billing_cycle = self.get_next_billing_cycle(plan)\n",
                "        event_in_next_billing_cycle = next_billing_cycle <= event_time\n",
                "\n",
                "        if event_in_next_billing_cycle and last_ledger_entry is not None:\n",
                "            licenses_at_next_renewal = last_ledger_entry.licenses_at_next_renewal\n",
                "            assert licenses_at_next_renewal is not None\n",
                "            if plan.status == CustomerPlan.ACTIVE:\n",
                "                return None, LicenseLedger.objects.create(\n",
                "                    plan=plan,\n",
                "                    is_renewal=True,\n",
                "                    event_time=next_billing_cycle,\n",
                "                    licenses=licenses_at_next_renewal,\n",
                "                    licenses_at_next_renewal=licenses_at_next_renewal,\n",
                "                )\n",
                "            if plan.is_free_trial():\n",
                "                plan.invoiced_through = last_ledger_entry\n",
                "                plan.billing_cycle_anchor = next_billing_cycle.replace(microsecond=0)\n",
                "                plan.status = CustomerPlan.ACTIVE\n",
                "                plan.save(update_fields=[\"invoiced_through\", \"billing_cycle_anchor\", \"status\"])\n",
                "                return None, LicenseLedger.objects.create(\n",
                "                    plan=plan,\n",
                "                    is_renewal=True,\n",
                "                    event_time=next_billing_cycle,\n",
                "                    licenses=licenses_at_next_renewal,\n",
                "                    licenses_at_next_renewal=licenses_at_next_renewal,\n",
                "                )\n",
                "\n",
                "            if plan.status == CustomerPlan.SWITCH_PLAN_TIER_AT_PLAN_END:  # nocoverage\n",
                "                # Only plan tier we do this for right now.\n",
                "                assert plan.tier == CustomerPlan.TIER_SELF_HOSTED_LEGACY\n",
                "                plan.status = CustomerPlan.ENDED\n",
                "                plan.save(update_fields=[\"status\"])\n",
                "\n",
                "                assert plan.end_date is not None\n",
                "                new_plan = CustomerPlan.objects.get(\n",
                "                    customer=plan.customer,\n",
                "                    billing_cycle_anchor=plan.end_date,\n",
                "                    status=CustomerPlan.NEVER_STARTED,\n",
                "                )\n",
                "                new_plan.status = CustomerPlan.ACTIVE\n",
                "                new_plan.save(update_fields=[\"status\"])\n",
                "                self.do_change_plan_type(tier=new_plan.tier)\n",
                "                return None, LicenseLedger.objects.create(\n",
                "                    plan=new_plan,\n",
                "                    is_renewal=True,\n",
                "                    event_time=next_billing_cycle,\n",
                "                    licenses=licenses_at_next_renewal,\n",
                "                    licenses_at_next_renewal=licenses_at_next_renewal,\n",
                "                )\n",
                "\n",
                "            if plan.status == CustomerPlan.SWITCH_TO_ANNUAL_AT_END_OF_CYCLE:\n",
                "                if plan.fixed_price is not None:  # nocoverage\n",
                "                    raise NotImplementedError(\"Can't switch fixed priced monthly plan to annual.\")\n",
                "\n",
                "                plan.status = CustomerPlan.ENDED\n",
                "                plan.save(update_fields=[\"status\"])\n",
                "\n",
                "                discount = plan.customer.default_discount or plan.discount\n",
                "                _, _, _, price_per_license = compute_plan_parameters(\n",
                "                    tier=plan.tier,\n",
                "                    automanage_licenses=plan.automanage_licenses,\n",
                "                    billing_schedule=CustomerPlan.BILLING_SCHEDULE_ANNUAL,\n",
                "                    discount=plan.discount,\n",
                "                )\n",
                "\n",
                "                new_plan = CustomerPlan.objects.create(\n",
                "                    customer=plan.customer,\n",
                "                    billing_schedule=CustomerPlan.BILLING_SCHEDULE_ANNUAL,\n",
                "                    automanage_licenses=plan.automanage_licenses,\n",
                "                    charge_automatically=plan.charge_automatically,\n",
                "                    price_per_license=price_per_license,\n",
                "                    discount=discount,\n",
                "                    billing_cycle_anchor=next_billing_cycle,\n",
                "                    tier=plan.tier,\n",
                "                    status=CustomerPlan.ACTIVE,\n",
                "                    next_invoice_date=next_billing_cycle,\n",
                "                    invoiced_through=None,\n",
                "                    invoicing_status=CustomerPlan.INVOICING_STATUS_INITIAL_INVOICE_TO_BE_SENT,\n",
                "                )\n",
                "\n",
                "                new_plan_ledger_entry = LicenseLedger.objects.create(\n",
                "                    plan=new_plan,\n",
                "                    is_renewal=True,\n",
                "                    event_time=next_billing_cycle,\n",
                "                    licenses=licenses_at_next_renewal,\n",
                "                    licenses_at_next_renewal=licenses_at_next_renewal,\n",
                "                )\n",
                "\n",
                "                self.write_to_audit_log(\n",
                "                    event_type=AuditLogEventType.CUSTOMER_SWITCHED_FROM_MONTHLY_TO_ANNUAL_PLAN,\n",
                "                    event_time=event_time,\n",
                "                    extra_data={\n",
                "                        \"monthly_plan_id\": plan.id,\n",
                "                        \"annual_plan_id\": new_plan.id,\n",
                "                    },\n",
                "                )\n",
                "                return new_plan, new_plan_ledger_entry\n",
                "\n",
                "            if plan.status == CustomerPlan.SWITCH_TO_MONTHLY_AT_END_OF_CYCLE:\n",
                "                if plan.fixed_price is not None:  # nocoverage\n",
                "                    raise BillingError(\"Customer is already on monthly fixed plan.\")\n",
                "\n",
                "                plan.status = CustomerPlan.ENDED\n",
                "                plan.save(update_fields=[\"status\"])\n",
                "\n",
                "                discount = plan.customer.default_discount or plan.discount\n",
                "                _, _, _, price_per_license = compute_plan_parameters(\n",
                "                    tier=plan.tier,\n",
                "                    automanage_licenses=plan.automanage_licenses,\n",
                "                    billing_schedule=CustomerPlan.BILLING_SCHEDULE_MONTHLY,\n",
                "                    discount=plan.discount,\n",
                "                )\n",
                "\n",
                "                new_plan = CustomerPlan.objects.create(\n",
                "                    customer=plan.customer,\n",
                "                    billing_schedule=CustomerPlan.BILLING_SCHEDULE_MONTHLY,\n",
                "                    automanage_licenses=plan.automanage_licenses,\n",
                "                    charge_automatically=plan.charge_automatically,\n",
                "                    price_per_license=price_per_license,\n",
                "                    discount=discount,\n",
                "                    billing_cycle_anchor=next_billing_cycle,\n",
                "                    tier=plan.tier,\n",
                "                    status=CustomerPlan.ACTIVE,\n",
                "                    next_invoice_date=next_billing_cycle,\n",
                "                    invoiced_through=None,\n",
                "                    invoicing_status=CustomerPlan.INVOICING_STATUS_INITIAL_INVOICE_TO_BE_SENT,\n",
                "                )\n",
                "\n",
                "                new_plan_ledger_entry = LicenseLedger.objects.create(\n",
                "                    plan=new_plan,\n",
                "                    is_renewal=True,\n",
                "                    event_time=next_billing_cycle,\n",
                "                    licenses=licenses_at_next_renewal,\n",
                "                    licenses_at_next_renewal=licenses_at_next_renewal,\n",
                "                )\n",
                "\n",
                "                self.write_to_audit_log(\n",
                "                    event_type=AuditLogEventType.CUSTOMER_SWITCHED_FROM_ANNUAL_TO_MONTHLY_PLAN,\n",
                "                    event_time=event_time,\n",
                "                    extra_data={\n",
                "                        \"annual_plan_id\": plan.id,\n",
                "                        \"monthly_plan_id\": new_plan.id,\n",
                "                    },\n",
                "                )\n",
                "                return new_plan, new_plan_ledger_entry\n",
                "\n",
                "            if plan.status == CustomerPlan.DOWNGRADE_AT_END_OF_FREE_TRIAL:\n",
                "                self.downgrade_now_without_creating_additional_invoices(plan)\n",
                "\n",
                "            if plan.status == CustomerPlan.DOWNGRADE_AT_END_OF_CYCLE:\n",
                "                self.process_downgrade(plan)\n",
                "\n",
                "            return None, None\n",
                "        return None, last_ledger_entry\n",
                "\n",
                "    def get_next_plan(self, plan: CustomerPlan) -> Optional[CustomerPlan]:  # nocoverage\n",
                "        if plan.status == CustomerPlan.SWITCH_PLAN_TIER_AT_PLAN_END:\n",
                "            assert plan.end_date is not None\n",
                "            return CustomerPlan.objects.filter(\n",
                "                customer=plan.customer,\n",
                "                billing_cycle_anchor=plan.end_date,\n",
                "                status=CustomerPlan.NEVER_STARTED,\n",
                "            ).first()\n",
                "        return None\n",
                "\n",
                "    def get_billing_context_from_plan(\n",
                "        self,\n",
                "        customer: Customer,\n",
                "        plan: CustomerPlan,\n",
                "        last_ledger_entry: LicenseLedger,\n",
                "        now: datetime,\n",
                "    ) -> Dict[str, Any]:\n",
                "        downgrade_at_end_of_cycle = plan.status == CustomerPlan.DOWNGRADE_AT_END_OF_CYCLE\n",
                "        downgrade_at_end_of_free_trial = plan.status == CustomerPlan.DOWNGRADE_AT_END_OF_FREE_TRIAL\n",
                "        switch_to_annual_at_end_of_cycle = (\n",
                "            plan.status == CustomerPlan.SWITCH_TO_ANNUAL_AT_END_OF_CYCLE\n",
                "        )\n",
                "        switch_to_monthly_at_end_of_cycle = (\n",
                "            plan.status == CustomerPlan.SWITCH_TO_MONTHLY_AT_END_OF_CYCLE\n",
                "        )\n",
                "        licenses = last_ledger_entry.licenses\n",
                "        licenses_at_next_renewal = last_ledger_entry.licenses_at_next_renewal\n",
                "        assert licenses_at_next_renewal is not None\n",
                "        min_licenses_for_plan = self.min_licenses_for_plan(plan.tier)\n",
                "        seat_count = self.current_count_for_billed_licenses()\n",
                "        using_min_licenses_for_plan = (\n",
                "            min_licenses_for_plan == licenses_at_next_renewal\n",
                "            and licenses_at_next_renewal > seat_count\n",
                "        )\n",
                "\n",
                "        # Should do this in JavaScript, using the user's time zone\n",
                "        if plan.is_free_trial() or downgrade_at_end_of_free_trial:\n",
                "            assert plan.next_invoice_date is not None\n",
                "            renewal_date = \"{dt:%B} {dt.day}, {dt.year}\".format(dt=plan.next_invoice_date)\n",
                "        else:\n",
                "            renewal_date = \"{dt:%B} {dt.day}, {dt.year}\".format(\n",
                "                dt=start_of_next_billing_cycle(plan, now)\n",
                "            )\n",
                "\n",
                "        billing_frequency = CustomerPlan.BILLING_SCHEDULES[plan.billing_schedule]\n",
                "\n",
                "        if switch_to_annual_at_end_of_cycle:\n",
                "            annual_price_per_license = get_price_per_license(\n",
                "                plan.tier, CustomerPlan.BILLING_SCHEDULE_ANNUAL, customer.default_discount\n",
                "            )\n",
                "            renewal_cents = annual_price_per_license * licenses_at_next_renewal\n",
                "            price_per_license = format_money(annual_price_per_license / 12)\n",
                "        elif switch_to_monthly_at_end_of_cycle:\n",
                "            monthly_price_per_license = get_price_per_license(\n",
                "                plan.tier, CustomerPlan.BILLING_SCHEDULE_MONTHLY, customer.default_discount\n",
                "            )\n",
                "            renewal_cents = monthly_price_per_license * licenses_at_next_renewal\n",
                "            price_per_license = format_money(monthly_price_per_license)\n",
                "        else:\n",
                "            renewal_cents = renewal_amount(plan, now, last_ledger_entry)\n",
                "\n",
                "            if plan.price_per_license is None:\n",
                "                price_per_license = \"\"\n",
                "            elif billing_frequency == \"Annual\":\n",
                "                price_per_license = format_money(plan.price_per_license / 12)\n",
                "            else:\n",
                "                price_per_license = format_money(plan.price_per_license)\n",
                "\n",
                "        charge_automatically = plan.charge_automatically\n",
                "        assert customer.stripe_customer_id is not None  # for mypy\n",
                "        stripe_customer = stripe_get_customer(customer.stripe_customer_id)\n",
                "        if charge_automatically:\n",
                "            payment_method = payment_method_string(stripe_customer)\n",
                "        else:\n",
                "            payment_method = \"Billed by invoice\"\n",
                "\n",
                "        fixed_price = (\n",
                "            cents_to_dollar_string(plan.fixed_price) if plan.fixed_price is not None else None\n",
                "        )\n",
                "        remote_server_legacy_plan_end_date = self.get_formatted_remote_server_legacy_plan_end_date(\n",
                "            customer, status=CustomerPlan.SWITCH_PLAN_TIER_AT_PLAN_END\n",
                "        )\n",
                "        legacy_remote_server_next_plan_name = self.get_legacy_remote_server_next_plan_name(customer)\n",
                "        is_self_hosted_billing = not isinstance(self, RealmBillingSession)\n",
                "        context = {\n",
                "            \"plan_name\": plan.name,\n",
                "            \"has_active_plan\": True,\n",
                "            \"free_trial\": plan.is_free_trial(),\n",
                "            \"downgrade_at_end_of_cycle\": downgrade_at_end_of_cycle,\n",
                "            \"downgrade_at_end_of_free_trial\": downgrade_at_end_of_free_trial,\n",
                "            \"automanage_licenses\": plan.automanage_licenses,\n",
                "            \"switch_to_annual_at_end_of_cycle\": switch_to_annual_at_end_of_cycle,\n",
                "            \"switch_to_monthly_at_end_of_cycle\": switch_to_monthly_at_end_of_cycle,\n",
                "            \"licenses\": licenses,\n",
                "            \"licenses_at_next_renewal\": licenses_at_next_renewal,\n",
                "            \"seat_count\": seat_count,\n",
                "            \"renewal_date\": renewal_date,\n",
                "            \"renewal_amount\": cents_to_dollar_string(renewal_cents),\n",
                "            \"payment_method\": payment_method,\n",
                "            \"charge_automatically\": charge_automatically,\n",
                "            \"stripe_email\": stripe_customer.email,\n",
                "            \"CustomerPlan\": CustomerPlan,\n",
                "            \"billing_frequency\": billing_frequency,\n",
                "            \"fixed_price\": fixed_price,\n",
                "            \"price_per_license\": price_per_license,\n",
                "            \"is_sponsorship_pending\": customer.sponsorship_pending,\n",
                "            \"sponsorship_plan_name\": self.get_sponsorship_plan_name(\n",
                "                customer, is_self_hosted_billing\n",
                "            ),\n",
                "            \"discount_percent\": format_discount_percentage(customer.default_discount),\n",
                "            \"is_self_hosted_billing\": is_self_hosted_billing,\n",
                "            \"is_server_on_legacy_plan\": remote_server_legacy_plan_end_date is not None,\n",
                "            \"remote_server_legacy_plan_end_date\": remote_server_legacy_plan_end_date,\n",
                "            \"legacy_remote_server_next_plan_name\": legacy_remote_server_next_plan_name,\n",
                "            \"using_min_licenses_for_plan\": using_min_licenses_for_plan,\n",
                "        }\n",
                "        return context\n",
                "\n",
                "    def get_billing_page_context(self) -> Dict[str, Any]:\n",
                "        now = timezone_now()\n",
                "\n",
                "        customer = self.get_customer()\n",
                "        assert customer is not None\n",
                "\n",
                "        plan = get_current_plan_by_customer(customer)\n",
                "        assert plan is not None\n",
                "\n",
                "        new_plan, last_ledger_entry = self.make_end_of_cycle_updates_if_needed(plan, now)\n",
                "        assert last_ledger_entry is not None\n",
                "        plan = new_plan if new_plan is not None else plan\n",
                "\n",
                "        context = self.get_billing_context_from_plan(customer, plan, last_ledger_entry, now)\n",
                "\n",
                "        next_plan = self.get_next_plan(plan)\n",
                "        if next_plan is not None:  # nocoverage\n",
                "            next_plan_context = self.get_billing_context_from_plan(\n",
                "                customer, next_plan, last_ledger_entry, now\n",
                "            )\n",
                "            # Settings we want to display from the next plan instead of the current one.\n",
                "            # HACK: Our billing page is not designed to handle two plans, so while this is hacky,\n",
                "            # it's the easiest way to get the UI we want without making things too complicated for us.\n",
                "            keys = [\n",
                "                \"renewal_amount\",\n",
                "                \"payment_method\",\n",
                "                \"charge_automatically\",\n",
                "                \"billing_frequency\",\n",
                "                \"fixed_price\",\n",
                "                \"price_per_license\",\n",
                "                \"discount_percent\",\n",
                "                \"using_min_licenses_for_plan\",\n",
                "            ]\n",
                "\n",
                "            for key in keys:\n",
                "                context[key] = next_plan_context[key]\n",
                "        return context\n",
                "\n",
                "    def get_initial_upgrade_context(\n",
                "        self, initial_upgrade_request: InitialUpgradeRequest\n",
                "    ) -> Tuple[Optional[str], Optional[UpgradePageContext]]:\n",
                "        customer = self.get_customer()\n",
                "\n",
                "        if self.is_sponsored_or_pending(customer):\n",
                "            return f\"{self.billing_session_url}/sponsorship\", None\n",
                "\n",
                "        remote_server_legacy_plan_end_date = self.get_formatted_remote_server_legacy_plan_end_date(\n",
                "            customer\n",
                "        )\n",
                "        # Show upgrade page for remote servers on legacy plan.\n",
                "        if customer is not None and remote_server_legacy_plan_end_date is None:\n",
                "            customer_plan = get_current_plan_by_customer(customer)\n",
                "            if customer_plan is not None:\n",
                "                return f\"{self.billing_session_url}/billing\", None\n",
                "\n",
                "        percent_off = Decimal(0)\n",
                "        if customer is not None and customer.default_discount is not None:\n",
                "            percent_off = customer.default_discount\n",
                "\n",
                "        exempt_from_license_number_check = (\n",
                "            customer is not None and customer.exempt_from_license_number_check\n",
                "        )\n",
                "\n",
                "        # Check if user was successful in adding a card and we are rendering the page again.\n",
                "        current_payment_method = None\n",
                "        if customer is not None and customer_has_credit_card_as_default_payment_method(customer):\n",
                "            assert customer.stripe_customer_id is not None\n",
                "            stripe_customer = stripe_get_customer(customer.stripe_customer_id)\n",
                "            payment_method = payment_method_string(stripe_customer)\n",
                "            # Show \"Update card\" button if user has already added a card.\n",
                "            current_payment_method = None if \"ending in\" not in payment_method else payment_method\n",
                "\n",
                "        tier = initial_upgrade_request.tier\n",
                "        customer_specific_context = self.get_upgrade_page_session_type_specific_context()\n",
                "        min_licenses_for_plan = self.min_licenses_for_plan(tier)\n",
                "        seat_count = self.current_count_for_billed_licenses()\n",
                "        using_min_licenses_for_plan = min_licenses_for_plan > seat_count\n",
                "        if using_min_licenses_for_plan:\n",
                "            seat_count = min_licenses_for_plan\n",
                "        signed_seat_count, salt = sign_string(str(seat_count))\n",
                "\n",
                "        free_trial_days = None\n",
                "        free_trial_end_date = None\n",
                "        # Don't show free trial for remote servers on legacy plan.\n",
                "        if remote_server_legacy_plan_end_date is None:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "            free_trial_days = get_free_trial_days()\n"
                ],
                "after": [
                    "            is_self_hosted_billing = not isinstance(self, RealmBillingSession)\n",
                    "            free_trial_days = get_free_trial_days(is_self_hosted_billing)\n"
                ],
                "parent_version_range": {
                    "start": 1815,
                    "end": 1816
                },
                "child_version_range": {
                    "start": 1815,
                    "end": 1817
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if remote_server_legacy_plan_end_date is None:",
                        "start_line": 1814,
                        "end_line": 1822
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "BillingSession",
                        "signature": "class BillingSession(ABC):",
                        "at_line": 661
                    },
                    {
                        "type": "function",
                        "name": "get_initial_upgrade_context",
                        "signature": "def get_initial_upgrade_context(\n        self, initial_upgrade_request: InitialUpgradeRequest\n    )->Tuple[Optional[str], Optional[UpgradePageContext]]:",
                        "at_line": 1768
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: corporate/lib/stripe.py\nCode:\n             class BillingSession(ABC):\n                 ...\n                 def get_initial_upgrade_context(\n        self, initial_upgrade_request: InitialUpgradeRequest\n    )->Tuple[Optional[str], Optional[UpgradePageContext]]:\n                     ...\n1812 1812            free_trial_end_date = None\n1813 1813            # Don't show free trial for remote servers on legacy plan.\n1814 1814            if remote_server_legacy_plan_end_date is None:\n1815       -             free_trial_days = get_free_trial_days()\n     1815  +             is_self_hosted_billing = not isinstance(self, RealmBillingSession)\n     1816  +             free_trial_days = get_free_trial_days(is_self_hosted_billing)\n1816 1817                if free_trial_days is not None:\n1817 1818                    _, _, free_trial_end, _ = compute_plan_parameters(\n           ...\n",
                "file_path": "corporate/lib/stripe.py",
                "identifiers_before": [
                    "free_trial_days",
                    "get_free_trial_days"
                ],
                "identifiers_after": [
                    "RealmBillingSession",
                    "free_trial_days",
                    "get_free_trial_days",
                    "is_self_hosted_billing",
                    "isinstance",
                    "self"
                ],
                "prefix": [
                    "        free_trial_end_date = None\n",
                    "        # Don't show free trial for remote servers on legacy plan.\n",
                    "        if remote_server_legacy_plan_end_date is None:\n"
                ],
                "suffix": [
                    "            if free_trial_days is not None:\n",
                    "                _, _, free_trial_end, _ = compute_plan_parameters(\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 1815,
                                    "column": 30
                                },
                                "end": {
                                    "line": 1815,
                                    "column": 49
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 1816,
                                    "column": 30
                                },
                                "end": {
                                    "line": 1816,
                                    "column": 49
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "is_self_hosted_billing",
                            "position": {
                                "start": {
                                    "line": 1815,
                                    "column": 12
                                },
                                "end": {
                                    "line": 1815,
                                    "column": 34
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "            if free_trial_days is not None:\n",
                "                _, _, free_trial_end, _ = compute_plan_parameters(\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                    tier, False, CustomerPlan.BILLING_SCHEDULE_ANNUAL, None, True\n"
                ],
                "after": [
                    "                    tier,\n",
                    "                    False,\n",
                    "                    CustomerPlan.BILLING_SCHEDULE_ANNUAL,\n",
                    "                    None,\n",
                    "                    True,\n",
                    "                    is_self_hosted_billing=is_self_hosted_billing,\n"
                ],
                "parent_version_range": {
                    "start": 1818,
                    "end": 1819
                },
                "child_version_range": {
                    "start": 1819,
                    "end": 1825
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if remote_server_legacy_plan_end_date is None:",
                        "start_line": 1814,
                        "end_line": 1822
                    },
                    {
                        "type": "if_statement",
                        "statement": "if free_trial_days is not None:",
                        "start_line": 1816,
                        "end_line": 1822
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "BillingSession",
                        "signature": "class BillingSession(ABC):",
                        "at_line": 661
                    },
                    {
                        "type": "function",
                        "name": "get_initial_upgrade_context",
                        "signature": "def get_initial_upgrade_context(\n        self, initial_upgrade_request: InitialUpgradeRequest\n    )->Tuple[Optional[str], Optional[UpgradePageContext]]:",
                        "at_line": 1768
                    },
                    {
                        "type": "call",
                        "name": "compute_plan_parameters",
                        "signature": "compute_plan_parameters(\n                    tier, False, CustomerPlan.BILLING_SCHEDULE_ANNUAL, None, True\n                )",
                        "at_line": 1817,
                        "argument": "tier"
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: corporate/lib/stripe.py\nCode:\n             class BillingSession(ABC):\n                 ...\n                 def get_initial_upgrade_context(\n        self, initial_upgrade_request: InitialUpgradeRequest\n    )->Tuple[Optional[str], Optional[UpgradePageContext]]:\n                     ...\n1816 1817                if free_trial_days is not None:\n1817 1818                    _, _, free_trial_end, _ = compute_plan_parameters(\n1818       -                     tier, False, CustomerPlan.BILLING_SCHEDULE_ANNUAL, None, True\n     1819  +                     tier,\n     1820  +                     False,\n     1821  +                     CustomerPlan.BILLING_SCHEDULE_ANNUAL,\n     1822  +                     None,\n     1823  +                     True,\n     1824  +                     is_self_hosted_billing=is_self_hosted_billing,\n1819 1825                    )\n1820 1826                    free_trial_end_date = (\n1821 1827                        f\"{free_trial_end:%B} {free_trial_end.day}, {free_trial_end.year}\"\n           ...\n",
                "file_path": "corporate/lib/stripe.py",
                "identifiers_before": [
                    "BILLING_SCHEDULE_ANNUAL",
                    "CustomerPlan",
                    "tier"
                ],
                "identifiers_after": [
                    "BILLING_SCHEDULE_ANNUAL",
                    "CustomerPlan",
                    "is_self_hosted_billing",
                    "tier"
                ],
                "prefix": [
                    "            if free_trial_days is not None:\n",
                    "                _, _, free_trial_end, _ = compute_plan_parameters(\n"
                ],
                "suffix": [
                    "                )\n",
                    "                free_trial_end_date = (\n",
                    "                    f\"{free_trial_end:%B} {free_trial_end.day}, {free_trial_end.year}\"\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "is_self_hosted_billing",
                            "position": {
                                "start": {
                                    "line": 1824,
                                    "column": 43
                                },
                                "end": {
                                    "line": 1824,
                                    "column": 65
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "is_self_hosted_billing",
                            "position": {
                                "start": {
                                    "line": 1824,
                                    "column": 20
                                },
                                "end": {
                                    "line": 1824,
                                    "column": 42
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                )\n",
                "                free_trial_end_date = (\n",
                "                    f\"{free_trial_end:%B} {free_trial_end.day}, {free_trial_end.year}\"\n",
                "                )\n",
                "\n",
                "        context: UpgradePageContext = {\n",
                "            \"customer_name\": customer_specific_context[\"customer_name\"],\n",
                "            \"default_invoice_days_until_due\": DEFAULT_INVOICE_DAYS_UNTIL_DUE,\n",
                "            \"discount_percent\": format_discount_percentage(percent_off),\n",
                "            \"email\": customer_specific_context[\"email\"],\n",
                "            \"exempt_from_license_number_check\": exempt_from_license_number_check,\n",
                "            \"free_trial_days\": free_trial_days,\n",
                "            \"free_trial_end_date\": free_trial_end_date,\n",
                "            \"is_demo_organization\": customer_specific_context[\"is_demo_organization\"],\n",
                "            \"remote_server_legacy_plan_end_date\": remote_server_legacy_plan_end_date,\n",
                "            \"manual_license_management\": initial_upgrade_request.manual_license_management,\n",
                "            \"page_params\": {\n",
                "                \"annual_price\": get_price_per_license(\n",
                "                    tier, CustomerPlan.BILLING_SCHEDULE_ANNUAL, percent_off\n",
                "                ),\n",
                "                \"demo_organization_scheduled_deletion_date\": customer_specific_context[\n",
                "                    \"demo_organization_scheduled_deletion_date\"\n",
                "                ],\n",
                "                \"monthly_price\": get_price_per_license(\n",
                "                    tier, CustomerPlan.BILLING_SCHEDULE_MONTHLY, percent_off\n",
                "                ),\n",
                "                \"seat_count\": seat_count,\n",
                "                \"billing_base_url\": self.billing_base_url,\n",
                "            },\n",
                "            \"using_min_licenses_for_plan\": using_min_licenses_for_plan,\n",
                "            \"payment_method\": current_payment_method,\n",
                "            \"plan\": CustomerPlan.name_from_tier(tier),\n",
                "            \"salt\": salt,\n",
                "            \"seat_count\": seat_count,\n",
                "            \"signed_seat_count\": signed_seat_count,\n",
                "            \"success_message\": initial_upgrade_request.success_message,\n",
                "        }\n",
                "\n",
                "        return None, context\n",
                "\n",
                "    def min_licenses_for_plan(self, tier: int) -> int:\n",
                "        if tier == CustomerPlan.TIER_SELF_HOSTED_BUSINESS:\n",
                "            return 10\n",
                "        return 1\n",
                "\n",
                "    def downgrade_at_the_end_of_billing_cycle(self, plan: Optional[CustomerPlan] = None) -> None:\n",
                "        if plan is None:  # nocoverage\n",
                "            # TODO: Add test coverage. Right now, this logic is used\n",
                "            # in production but mocked in tests.\n",
                "            customer = self.get_customer()\n",
                "            assert customer is not None\n",
                "            plan = get_current_plan_by_customer(customer)\n",
                "        assert plan is not None\n",
                "        do_change_plan_status(plan, CustomerPlan.DOWNGRADE_AT_END_OF_CYCLE)\n",
                "\n",
                "    def void_all_open_invoices(self) -> int:\n",
                "        customer = self.get_customer()\n",
                "        if customer is None:\n",
                "            return 0\n",
                "        invoices = get_all_invoices_for_customer(customer)\n",
                "        voided_invoices_count = 0\n",
                "        for invoice in invoices:\n",
                "            if invoice.status == \"open\":\n",
                "                assert invoice.id is not None\n",
                "                stripe.Invoice.void_invoice(invoice.id)\n",
                "                voided_invoices_count += 1\n",
                "        return voided_invoices_count\n",
                "\n",
                "    # During realm deactivation we instantly downgrade the plan to Limited.\n",
                "    # Extra users added in the final month are not charged. Also used\n",
                "    # for the cancellation of Free Trial.\n",
                "    def downgrade_now_without_creating_additional_invoices(\n",
                "        self,\n",
                "        plan: Optional[CustomerPlan] = None,\n",
                "    ) -> None:\n",
                "        if plan is None:\n",
                "            customer = self.get_customer()\n",
                "            if customer is None:\n",
                "                return\n",
                "            plan = get_current_plan_by_customer(customer)\n",
                "            if plan is None:\n",
                "                return  # nocoverage\n",
                "\n",
                "        self.process_downgrade(plan)\n",
                "        plan.invoiced_through = LicenseLedger.objects.filter(plan=plan).order_by(\"id\").last()\n",
                "        plan.next_invoice_date = next_invoice_date(plan)\n",
                "        plan.save(update_fields=[\"invoiced_through\", \"next_invoice_date\"])\n",
                "\n",
                "    def do_update_plan(self, update_plan_request: UpdatePlanRequest) -> None:\n",
                "        customer = self.get_customer()\n",
                "        assert customer is not None\n",
                "        plan = get_current_plan_by_customer(customer)\n",
                "        assert plan is not None  # for mypy\n",
                "\n",
                "        new_plan, last_ledger_entry = self.make_end_of_cycle_updates_if_needed(plan, timezone_now())\n",
                "        if new_plan is not None:\n",
                "            raise JsonableError(\n",
                "                _(\n",
                "                    \"Unable to update the plan. The plan has been expired and replaced with a new plan.\"\n",
                "                )\n",
                "            )\n",
                "\n",
                "        if last_ledger_entry is None:\n",
                "            raise JsonableError(_(\"Unable to update the plan. The plan has ended.\"))\n",
                "\n",
                "        status = update_plan_request.status\n",
                "        if status is not None:\n",
                "            if status == CustomerPlan.ACTIVE:\n",
                "                assert plan.status < CustomerPlan.LIVE_STATUS_THRESHOLD\n",
                "                with transaction.atomic():  # nocoverage\n",
                "                    # Switch to a different plan was cancelled. We end the next plan\n",
                "                    # and set the current one as active.\n",
                "                    if plan.status == CustomerPlan.SWITCH_PLAN_TIER_AT_PLAN_END:\n",
                "                        next_plan = self.get_next_plan(plan)\n",
                "                        assert next_plan is not None\n",
                "                        do_change_plan_status(next_plan, CustomerPlan.ENDED)\n",
                "                    do_change_plan_status(plan, status)\n",
                "            elif status == CustomerPlan.DOWNGRADE_AT_END_OF_CYCLE:\n",
                "                assert not plan.is_free_trial()\n",
                "                assert plan.status < CustomerPlan.LIVE_STATUS_THRESHOLD\n",
                "                self.downgrade_at_the_end_of_billing_cycle(plan=plan)\n",
                "            elif status == CustomerPlan.SWITCH_TO_ANNUAL_AT_END_OF_CYCLE:\n",
                "                assert plan.billing_schedule == CustomerPlan.BILLING_SCHEDULE_MONTHLY\n",
                "                assert plan.status < CustomerPlan.LIVE_STATUS_THRESHOLD\n",
                "                # Customer needs to switch to an active plan first to avoid unexpected behavior.\n",
                "                assert plan.status != CustomerPlan.DOWNGRADE_AT_END_OF_CYCLE\n",
                "                # Switching billing frequency for free trial should happen instantly.\n",
                "                assert not plan.is_free_trial()\n",
                "                assert plan.fixed_price is None\n",
                "                do_change_plan_status(plan, status)\n",
                "            elif status == CustomerPlan.SWITCH_TO_MONTHLY_AT_END_OF_CYCLE:\n",
                "                assert plan.billing_schedule == CustomerPlan.BILLING_SCHEDULE_ANNUAL\n",
                "                assert plan.status < CustomerPlan.LIVE_STATUS_THRESHOLD\n",
                "                # Customer needs to switch to an active plan first to avoid unexpected behavior.\n",
                "                assert plan.status != CustomerPlan.DOWNGRADE_AT_END_OF_CYCLE\n",
                "                # Switching billing frequency for free trial should happen instantly.\n",
                "                assert not plan.is_free_trial()\n",
                "                assert plan.fixed_price is None\n",
                "                do_change_plan_status(plan, status)\n",
                "            elif status == CustomerPlan.ENDED:\n",
                "                # Not used right now on billing page but kept in case we need it.\n",
                "                assert plan.is_free_trial()\n",
                "                self.downgrade_now_without_creating_additional_invoices(plan=plan)\n",
                "            elif status == CustomerPlan.DOWNGRADE_AT_END_OF_FREE_TRIAL:\n",
                "                assert plan.is_free_trial()\n",
                "                do_change_plan_status(plan, status)\n",
                "            elif status == CustomerPlan.FREE_TRIAL:\n",
                "                if update_plan_request.schedule is not None:\n",
                "                    self.do_change_schedule_after_free_trial(plan, update_plan_request.schedule)\n",
                "                else:\n",
                "                    assert plan.status == CustomerPlan.DOWNGRADE_AT_END_OF_FREE_TRIAL\n",
                "                    do_change_plan_status(plan, status)\n",
                "            return\n",
                "\n",
                "        licenses = update_plan_request.licenses\n",
                "        if licenses is not None:\n",
                "            if plan.is_free_trial():  # nocoverage\n",
                "                raise JsonableError(\n",
                "                    _(\"Cannot update licenses in the current billing period for free trial plan.\")\n",
                "                )\n",
                "            if plan.automanage_licenses:\n",
                "                raise JsonableError(\n",
                "                    _(\n",
                "                        \"Unable to update licenses manually. Your plan is on automatic license management.\"\n",
                "                    )\n",
                "                )\n",
                "            if last_ledger_entry.licenses == licenses:\n",
                "                raise JsonableError(\n",
                "                    _(\n",
                "                        \"Your plan is already on {licenses} licenses in the current billing period.\"\n",
                "                    ).format(licenses=licenses)\n",
                "                )\n",
                "            if last_ledger_entry.licenses > licenses:\n",
                "                raise JsonableError(\n",
                "                    _(\"You cannot decrease the licenses in the current billing period.\")\n",
                "                )\n",
                "            validate_licenses(\n",
                "                plan.charge_automatically,\n",
                "                licenses,\n",
                "                self.current_count_for_billed_licenses(),\n",
                "                plan.customer.exempt_from_license_number_check,\n",
                "                self.min_licenses_for_plan(plan.tier),\n",
                "            )\n",
                "            self.update_license_ledger_for_manual_plan(plan, timezone_now(), licenses=licenses)\n",
                "            return\n",
                "\n",
                "        licenses_at_next_renewal = update_plan_request.licenses_at_next_renewal\n",
                "        if licenses_at_next_renewal is not None:\n",
                "            if plan.automanage_licenses:\n",
                "                raise JsonableError(\n",
                "                    _(\n",
                "                        \"Unable to update licenses manually. Your plan is on automatic license management.\"\n",
                "                    )\n",
                "                )\n",
                "            if plan.status in (\n",
                "                CustomerPlan.DOWNGRADE_AT_END_OF_CYCLE,\n",
                "                CustomerPlan.DOWNGRADE_AT_END_OF_FREE_TRIAL,\n",
                "            ):  # nocoverage\n",
                "                raise JsonableError(\n",
                "                    _(\n",
                "                        \"Cannot change the licenses for next billing cycle for a plan that is being downgraded.\"\n",
                "                    )\n",
                "                )\n",
                "            if last_ledger_entry.licenses_at_next_renewal == licenses_at_next_renewal:\n",
                "                raise JsonableError(\n",
                "                    _(\n",
                "                        \"Your plan is already scheduled to renew with {licenses_at_next_renewal} licenses.\"\n",
                "                    ).format(licenses_at_next_renewal=licenses_at_next_renewal)\n",
                "                )\n",
                "            validate_licenses(\n",
                "                plan.charge_automatically,\n",
                "                licenses_at_next_renewal,\n",
                "                self.current_count_for_billed_licenses(),\n",
                "                plan.customer.exempt_from_license_number_check,\n",
                "                self.min_licenses_for_plan(plan.tier),\n",
                "            )\n",
                "            self.update_license_ledger_for_manual_plan(\n",
                "                plan, timezone_now(), licenses_at_next_renewal=licenses_at_next_renewal\n",
                "            )\n",
                "            return\n",
                "\n",
                "        raise JsonableError(_(\"Nothing to change.\"))\n",
                "\n",
                "    def switch_plan_tier(self, current_plan: CustomerPlan, new_plan_tier: int) -> None:\n",
                "        assert current_plan.status == CustomerPlan.SWITCH_PLAN_TIER_NOW\n",
                "        assert current_plan.next_invoice_date is not None\n",
                "        next_billing_cycle = current_plan.next_invoice_date\n",
                "\n",
                "        current_plan.end_date = next_billing_cycle\n",
                "        current_plan.status = CustomerPlan.ENDED\n",
                "        current_plan.save(update_fields=[\"status\", \"end_date\"])\n",
                "\n",
                "        new_price_per_license = get_price_per_license(\n",
                "            new_plan_tier, current_plan.billing_schedule, current_plan.customer.default_discount\n",
                "        )\n",
                "\n",
                "        new_plan_billing_cycle_anchor = current_plan.end_date.replace(microsecond=0)\n",
                "\n",
                "        new_plan = CustomerPlan.objects.create(\n",
                "            customer=current_plan.customer,\n",
                "            status=CustomerPlan.ACTIVE,\n",
                "            automanage_licenses=current_plan.automanage_licenses,\n",
                "            charge_automatically=current_plan.charge_automatically,\n",
                "            price_per_license=new_price_per_license,\n",
                "            discount=current_plan.customer.default_discount,\n",
                "            billing_schedule=current_plan.billing_schedule,\n",
                "            tier=new_plan_tier,\n",
                "            billing_cycle_anchor=new_plan_billing_cycle_anchor,\n",
                "            invoicing_status=CustomerPlan.INVOICING_STATUS_INITIAL_INVOICE_TO_BE_SENT,\n",
                "            next_invoice_date=new_plan_billing_cycle_anchor,\n",
                "        )\n",
                "\n",
                "        current_plan_last_ledger = (\n",
                "            LicenseLedger.objects.filter(plan=current_plan).order_by(\"id\").last()\n",
                "        )\n",
                "        assert current_plan_last_ledger is not None\n",
                "        licenses_for_new_plan = current_plan_last_ledger.licenses_at_next_renewal\n",
                "        assert licenses_for_new_plan is not None\n",
                "        LicenseLedger.objects.create(\n",
                "            plan=new_plan,\n",
                "            is_renewal=True,\n",
                "            event_time=new_plan_billing_cycle_anchor,\n",
                "            licenses=licenses_for_new_plan,\n",
                "            licenses_at_next_renewal=licenses_for_new_plan,\n",
                "        )\n",
                "\n",
                "    def invoice_plan(self, plan: CustomerPlan, event_time: datetime) -> None:\n",
                "        if plan.invoicing_status == CustomerPlan.INVOICING_STATUS_STARTED:\n",
                "            raise NotImplementedError(\n",
                "                \"Plan with invoicing_status==STARTED needs manual resolution.\"\n",
                "            )\n",
                "        if not plan.customer.stripe_customer_id:\n",
                "            raise BillingError(\n",
                "                f\"Customer has a paid plan without a Stripe customer ID: {plan.customer!s}\"\n",
                "            )\n",
                "\n",
                "        # Updating a CustomerPlan with a status to switch the plan tier,\n",
                "        # is done via switch_plan_tier, so we do not need to make end of\n",
                "        # cycle updates for that case.\n",
                "        if plan.status is not CustomerPlan.SWITCH_PLAN_TIER_NOW:\n",
                "            self.make_end_of_cycle_updates_if_needed(plan, event_time)\n",
                "\n",
                "        if plan.invoicing_status == CustomerPlan.INVOICING_STATUS_INITIAL_INVOICE_TO_BE_SENT:\n",
                "            invoiced_through_id = -1\n",
                "            licenses_base = None\n",
                "        else:\n",
                "            assert plan.invoiced_through is not None\n",
                "            licenses_base = plan.invoiced_through.licenses\n",
                "            invoiced_through_id = plan.invoiced_through.id\n",
                "\n",
                "        invoice_item_created = False\n",
                "        for ledger_entry in LicenseLedger.objects.filter(\n",
                "            plan=plan, id__gt=invoiced_through_id, event_time__lte=event_time\n",
                "        ).order_by(\"id\"):\n",
                "            price_args: PriceArgs = {}\n",
                "            if ledger_entry.is_renewal:\n",
                "                if plan.fixed_price is not None:\n",
                "                    price_args = {\"amount\": plan.fixed_price}\n",
                "                else:\n",
                "                    assert plan.price_per_license is not None  # needed for mypy\n",
                "                    price_args = {\n",
                "                        \"unit_amount\": plan.price_per_license,\n",
                "                        \"quantity\": ledger_entry.licenses,\n",
                "                    }\n",
                "                description = f\"{plan.name} - renewal\"\n",
                "            elif licenses_base is not None and ledger_entry.licenses != licenses_base:\n",
                "                assert plan.price_per_license\n",
                "                last_ledger_entry_renewal = (\n",
                "                    LicenseLedger.objects.filter(\n",
                "                        plan=plan, is_renewal=True, event_time__lte=ledger_entry.event_time\n",
                "                    )\n",
                "                    .order_by(\"-id\")\n",
                "                    .first()\n",
                "                )\n",
                "                assert last_ledger_entry_renewal is not None\n",
                "                last_renewal = last_ledger_entry_renewal.event_time\n",
                "                billing_period_end = start_of_next_billing_cycle(plan, ledger_entry.event_time)\n",
                "                plan_renewal_or_end_date = get_plan_renewal_or_end_date(\n",
                "                    plan, ledger_entry.event_time\n",
                "                )\n",
                "                proration_fraction = (plan_renewal_or_end_date - ledger_entry.event_time) / (\n",
                "                    billing_period_end - last_renewal\n",
                "                )\n",
                "                price_args = {\n",
                "                    \"unit_amount\": int(plan.price_per_license * proration_fraction + 0.5),\n",
                "                    \"quantity\": ledger_entry.licenses - licenses_base,\n",
                "                }\n",
                "                description = \"Additional license ({} - {})\".format(\n",
                "                    ledger_entry.event_time.strftime(\"%b %-d, %Y\"),\n",
                "                    plan_renewal_or_end_date.strftime(\"%b %-d, %Y\"),\n",
                "                )\n",
                "\n",
                "            if price_args:\n",
                "                plan.invoiced_through = ledger_entry\n",
                "                plan.invoicing_status = CustomerPlan.INVOICING_STATUS_STARTED\n",
                "                plan.save(update_fields=[\"invoicing_status\", \"invoiced_through\"])\n",
                "                stripe.InvoiceItem.create(\n",
                "                    currency=\"usd\",\n",
                "                    customer=plan.customer.stripe_customer_id,\n",
                "                    description=description,\n",
                "                    discountable=False,\n",
                "                    period={\n",
                "                        \"start\": datetime_to_timestamp(ledger_entry.event_time),\n",
                "                        \"end\": datetime_to_timestamp(\n",
                "                            get_plan_renewal_or_end_date(plan, ledger_entry.event_time)\n",
                "                        ),\n",
                "                    },\n",
                "                    idempotency_key=get_idempotency_key(ledger_entry),\n",
                "                    **price_args,\n",
                "                )\n",
                "                invoice_item_created = True\n",
                "            plan.invoiced_through = ledger_entry\n",
                "            plan.invoicing_status = CustomerPlan.INVOICING_STATUS_DONE\n",
                "            plan.save(update_fields=[\"invoicing_status\", \"invoiced_through\"])\n",
                "            licenses_base = ledger_entry.licenses\n",
                "\n",
                "        if invoice_item_created:\n",
                "            if plan.charge_automatically:\n",
                "                collection_method = \"charge_automatically\"\n",
                "                days_until_due = None\n",
                "            else:\n",
                "                collection_method = \"send_invoice\"\n",
                "                days_until_due = DEFAULT_INVOICE_DAYS_UNTIL_DUE\n",
                "            stripe_invoice = stripe.Invoice.create(\n",
                "                auto_advance=True,\n",
                "                collection_method=collection_method,\n",
                "                customer=plan.customer.stripe_customer_id,\n",
                "                days_until_due=days_until_due,\n",
                "                statement_descriptor=plan.name,\n",
                "            )\n",
                "            stripe.Invoice.finalize_invoice(stripe_invoice)\n",
                "\n",
                "        plan.next_invoice_date = next_invoice_date(plan)\n",
                "        plan.save(update_fields=[\"next_invoice_date\"])\n",
                "\n",
                "    def do_change_plan_to_new_tier(self, new_plan_tier: int) -> str:\n",
                "        customer = self.get_customer()\n",
                "        assert customer is not None\n",
                "        current_plan = get_current_plan_by_customer(customer)\n",
                "\n",
                "        if not current_plan or current_plan.status != CustomerPlan.ACTIVE:\n",
                "            raise BillingError(\"Organization does not have an active plan\")\n",
                "\n",
                "        if not current_plan.customer.stripe_customer_id:\n",
                "            raise BillingError(\"Organization missing Stripe customer.\")\n",
                "\n",
                "        type_of_tier_change = self.get_type_of_plan_tier_change(current_plan.tier, new_plan_tier)\n",
                "\n",
                "        if type_of_tier_change == PlanTierChangeType.INVALID:\n",
                "            raise BillingError(\"Invalid change of customer plan tier.\")\n",
                "\n",
                "        if type_of_tier_change == PlanTierChangeType.UPGRADE:\n",
                "            plan_switch_time = timezone_now()\n",
                "            current_plan.status = CustomerPlan.SWITCH_PLAN_TIER_NOW\n",
                "            current_plan.next_invoice_date = plan_switch_time\n",
                "            current_plan.save(update_fields=[\"status\", \"next_invoice_date\"])\n",
                "\n",
                "            self.do_change_plan_type(tier=new_plan_tier)\n",
                "\n",
                "            amount_to_credit_for_early_termination = get_amount_to_credit_for_plan_tier_change(\n",
                "                current_plan, plan_switch_time\n",
                "            )\n",
                "            stripe.Customer.create_balance_transaction(\n",
                "                current_plan.customer.stripe_customer_id,\n",
                "                amount=-1 * amount_to_credit_for_early_termination,\n",
                "                currency=\"usd\",\n",
                "                description=\"Credit from early termination of active plan\",\n",
                "            )\n",
                "            self.switch_plan_tier(current_plan, new_plan_tier)\n",
                "            self.invoice_plan(current_plan, plan_switch_time)\n",
                "            new_plan = get_current_plan_by_customer(customer)\n",
                "            assert new_plan is not None  # for mypy\n",
                "            self.invoice_plan(new_plan, plan_switch_time)\n",
                "            return f\"{self.billing_entity_display_name} upgraded to {new_plan.name}\"\n",
                "\n",
                "        # TODO: Implement downgrade that is a change from and to a paid plan\n",
                "        # tier. This should keep the same billing cycle schedule and change\n",
                "        # the plan when it's next invoiced vs immediately. Note this will need\n",
                "        # new CustomerPlan.status value, e.g. SWITCH_PLAN_TIER_AT_PLAN_END.\n",
                "        assert type_of_tier_change == PlanTierChangeType.DOWNGRADE  # nocoverage\n",
                "        return \"\"  # nocoverage\n",
                "\n",
                "    def get_event_status(self, event_status_request: EventStatusRequest) -> Dict[str, Any]:\n",
                "        customer = self.get_customer()\n",
                "\n",
                "        if customer is None:\n",
                "            raise JsonableError(_(\"No customer for this organization!\"))\n",
                "\n",
                "        stripe_session_id = event_status_request.stripe_session_id\n",
                "        if stripe_session_id is not None:\n",
                "            try:\n",
                "                session = Session.objects.get(\n",
                "                    stripe_session_id=stripe_session_id, customer=customer\n",
                "                )\n",
                "            except Session.DoesNotExist:\n",
                "                raise JsonableError(_(\"Session not found\"))\n",
                "\n",
                "            if (\n",
                "                session.type == Session.CARD_UPDATE_FROM_BILLING_PAGE\n",
                "                and not self.has_billing_access()\n",
                "            ):\n",
                "                raise JsonableError(_(\"Must be a billing administrator or an organization owner\"))\n",
                "            return {\"session\": session.to_dict()}\n",
                "\n",
                "        stripe_payment_intent_id = event_status_request.stripe_payment_intent_id\n",
                "        if stripe_payment_intent_id is not None:\n",
                "            payment_intent = PaymentIntent.objects.filter(\n",
                "                stripe_payment_intent_id=stripe_payment_intent_id,\n",
                "                customer=customer,\n",
                "            ).last()\n",
                "\n",
                "            if payment_intent is None:\n",
                "                raise JsonableError(_(\"Payment intent not found\"))\n",
                "            return {\"payment_intent\": payment_intent.to_dict()}\n",
                "\n",
                "        raise JsonableError(_(\"Pass stripe_session_id or stripe_payment_intent_id\"))\n",
                "\n",
                "    def get_sponsorship_plan_name(\n",
                "        self, customer: Optional[Customer], is_remotely_hosted: bool\n",
                "    ) -> str:\n",
                "        if customer is not None and customer.sponsorship_pending:\n",
                "            # For sponsorship pending requests, we also show the type of sponsorship requested.\n",
                "            # In other cases, we just show the plan user is currently on.\n",
                "            sponsorship_request = (\n",
                "                ZulipSponsorshipRequest.objects.filter(customer=customer).order_by(\"-id\").first()\n",
                "            )\n",
                "            # It's possible that we marked `customer.sponsorship_pending` via support page\n",
                "            # without user submitting a sponsorship request.\n",
                "            if sponsorship_request is not None and sponsorship_request.requested_plan not in (\n",
                "                None,\n",
                "                SponsoredPlanTypes.UNSPECIFIED.value,\n",
                "            ):  # nocoverage\n",
                "                return sponsorship_request.requested_plan\n",
                "\n",
                "        # We only support sponsorships for these plans.\n",
                "        sponsored_plan_name = CustomerPlan.name_from_tier(CustomerPlan.TIER_CLOUD_STANDARD)\n",
                "        if is_remotely_hosted:\n",
                "            sponsored_plan_name = CustomerPlan.name_from_tier(\n",
                "                CustomerPlan.TIER_SELF_HOSTED_COMMUNITY\n",
                "            )\n",
                "\n",
                "        return sponsored_plan_name\n",
                "\n",
                "    def get_sponsorship_request_context(self) -> Optional[Dict[str, Any]]:\n",
                "        customer = self.get_customer()\n",
                "        is_remotely_hosted = isinstance(\n",
                "            self, (RemoteRealmBillingSession, RemoteServerBillingSession)\n",
                "        )\n",
                "\n",
                "        plan_name = \"Zulip Cloud Free\"\n",
                "        if is_remotely_hosted:\n",
                "            plan_name = \"Self-managed\"\n",
                "\n",
                "        context: Dict[str, Any] = {\n",
                "            \"billing_base_url\": self.billing_base_url,\n",
                "            \"is_remotely_hosted\": is_remotely_hosted,\n",
                "            \"sponsorship_plan_name\": self.get_sponsorship_plan_name(customer, is_remotely_hosted),\n",
                "            \"plan_name\": plan_name,\n",
                "        }\n",
                "\n",
                "        if customer is not None and customer.sponsorship_pending:\n",
                "            if self.on_paid_plan():\n",
                "                return None\n",
                "\n",
                "            context[\"is_sponsorship_pending\"] = True\n",
                "\n",
                "        if self.is_sponsored():\n",
                "            context[\"is_sponsored\"] = True\n",
                "\n",
                "        if customer is not None:\n",
                "            plan = get_current_plan_by_customer(customer)\n",
                "            if plan is not None:\n",
                "                context[\"plan_name\"] = plan.name\n",
                "                context[\"free_trial\"] = plan.is_free_trial()\n",
                "\n",
                "        self.add_sponsorship_info_to_context(context)\n",
                "        return context\n",
                "\n",
                "    def request_sponsorship(self, form: SponsorshipRequestForm) -> None:\n",
                "        if not form.is_valid():\n",
                "            message = \" \".join(\n",
                "                error[\"message\"]\n",
                "                for error_list in form.errors.get_json_data().values()\n",
                "                for error in error_list\n",
                "            )\n",
                "            raise BillingError(\"Form validation error\", message=message)\n",
                "\n",
                "        request_context = self.get_sponsorship_request_session_specific_context()\n",
                "        with transaction.atomic():\n",
                "            # Ensures customer is created first before updating sponsorship status.\n",
                "            self.update_customer_sponsorship_status(True)\n",
                "            sponsorship_request = ZulipSponsorshipRequest(\n",
                "                customer=self.get_customer(),\n",
                "                requested_by=request_context[\"realm_user\"],\n",
                "                org_website=form.cleaned_data[\"website\"],\n",
                "                org_description=form.cleaned_data[\"description\"],\n",
                "                org_type=form.cleaned_data[\"organization_type\"],\n",
                "                expected_total_users=form.cleaned_data[\"expected_total_users\"],\n",
                "                paid_users_count=form.cleaned_data[\"paid_users_count\"],\n",
                "                paid_users_description=form.cleaned_data[\"paid_users_description\"],\n",
                "                requested_plan=form.cleaned_data[\"requested_plan\"],\n",
                "            )\n",
                "            sponsorship_request.save()\n",
                "\n",
                "            org_type = form.cleaned_data[\"organization_type\"]\n",
                "            self.save_org_type_from_request_sponsorship_session(org_type)\n",
                "\n",
                "            if request_context[\"realm_user\"] is not None:\n",
                "                # TODO: Refactor to not create an import cycle.\n",
                "                from zerver.actions.users import do_change_is_billing_admin\n",
                "\n",
                "                do_change_is_billing_admin(request_context[\"realm_user\"], True)\n",
                "\n",
                "            org_type_display_name = get_org_type_display_name(org_type)\n",
                "\n",
                "        user_info = request_context[\"user_info\"]\n",
                "        support_url = self.support_url()\n",
                "        context = {\n",
                "            \"requested_by\": user_info[\"name\"],\n",
                "            \"user_role\": user_info[\"role\"],\n",
                "            \"billing_entity\": self.billing_entity_display_name,\n",
                "            \"support_url\": support_url,\n",
                "            \"organization_type\": org_type_display_name,\n",
                "            \"website\": sponsorship_request.org_website,\n",
                "            \"description\": sponsorship_request.org_description,\n",
                "            \"expected_total_users\": sponsorship_request.expected_total_users,\n",
                "            \"paid_users_count\": sponsorship_request.paid_users_count,\n",
                "            \"paid_users_description\": sponsorship_request.paid_users_description,\n",
                "            \"requested_plan\": sponsorship_request.requested_plan,\n",
                "        }\n",
                "        send_email(\n",
                "            \"zerver/emails/sponsorship_request\",\n",
                "            to_emails=[FromAddress.SUPPORT],\n",
                "            # Sent to the server's support team, so this email is not user-facing.\n",
                "            from_name=\"Zulip sponsorship request\",\n",
                "            from_address=FromAddress.tokenized_no_reply_address(),\n",
                "            reply_to_email=user_info[\"email\"],\n",
                "            context=context,\n",
                "        )\n",
                "\n",
                "    def process_support_view_request(self, support_request: SupportViewRequest) -> str:\n",
                "        support_type = support_request[\"support_type\"]\n",
                "        success_message = \"\"\n",
                "\n",
                "        if support_type == SupportType.approve_sponsorship:\n",
                "            success_message = self.approve_sponsorship()\n",
                "        elif support_type == SupportType.update_sponsorship_status:\n",
                "            assert support_request[\"sponsorship_status\"] is not None\n",
                "            sponsorship_status = support_request[\"sponsorship_status\"]\n",
                "            success_message = self.update_customer_sponsorship_status(sponsorship_status)\n",
                "        elif support_type == SupportType.attach_discount:\n",
                "            assert support_request[\"discount\"] is not None\n",
                "            new_discount = support_request[\"discount\"]\n",
                "            success_message = self.attach_discount_to_customer(new_discount)\n",
                "        elif support_type == SupportType.update_billing_modality:\n",
                "            assert support_request[\"billing_modality\"] is not None\n",
                "            assert support_request[\"billing_modality\"] in VALID_BILLING_MODALITY_VALUES\n",
                "            charge_automatically = support_request[\"billing_modality\"] == \"charge_automatically\"\n",
                "            success_message = self.update_billing_modality_of_current_plan(charge_automatically)\n",
                "        elif support_type == SupportType.modify_plan:\n",
                "            assert support_request[\"plan_modification\"] is not None\n",
                "            plan_modification = support_request[\"plan_modification\"]\n",
                "            if plan_modification == \"downgrade_at_billing_cycle_end\":\n",
                "                self.downgrade_at_the_end_of_billing_cycle()\n",
                "                success_message = f\"{self.billing_entity_display_name} marked for downgrade at the end of billing cycle\"\n",
                "            elif plan_modification == \"downgrade_now_without_additional_licenses\":\n",
                "                self.downgrade_now_without_creating_additional_invoices()\n",
                "                success_message = f\"{self.billing_entity_display_name} downgraded without creating additional invoices\"\n",
                "            elif plan_modification == \"downgrade_now_void_open_invoices\":\n",
                "                self.downgrade_now_without_creating_additional_invoices()\n",
                "                voided_invoices_count = self.void_all_open_invoices()\n",
                "                success_message = f\"{self.billing_entity_display_name} downgraded and voided {voided_invoices_count} open invoices\"\n",
                "            else:\n",
                "                assert plan_modification == \"upgrade_plan_tier\"\n",
                "                assert support_request[\"new_plan_tier\"] is not None\n",
                "                new_plan_tier = support_request[\"new_plan_tier\"]\n",
                "                success_message = self.do_change_plan_to_new_tier(new_plan_tier)\n",
                "\n",
                "        return success_message\n",
                "\n",
                "    def update_license_ledger_for_manual_plan(\n",
                "        self,\n",
                "        plan: CustomerPlan,\n",
                "        event_time: datetime,\n",
                "        licenses: Optional[int] = None,\n",
                "        licenses_at_next_renewal: Optional[int] = None,\n",
                "    ) -> None:\n",
                "        if licenses is not None:\n",
                "            if not plan.customer.exempt_from_license_number_check:\n",
                "                assert self.current_count_for_billed_licenses() <= licenses\n",
                "            assert licenses > plan.licenses()\n",
                "            LicenseLedger.objects.create(\n",
                "                plan=plan,\n",
                "                event_time=event_time,\n",
                "                licenses=licenses,\n",
                "                licenses_at_next_renewal=licenses,\n",
                "            )\n",
                "        elif licenses_at_next_renewal is not None:\n",
                "            if not plan.customer.exempt_from_license_number_check:\n",
                "                assert self.current_count_for_billed_licenses() <= licenses_at_next_renewal\n",
                "            LicenseLedger.objects.create(\n",
                "                plan=plan,\n",
                "                event_time=event_time,\n",
                "                licenses=plan.licenses(),\n",
                "                licenses_at_next_renewal=licenses_at_next_renewal,\n",
                "            )\n",
                "        else:\n",
                "            raise AssertionError(\"Pass licenses or licenses_at_next_renewal\")\n",
                "\n",
                "    def update_license_ledger_for_automanaged_plan(\n",
                "        self, plan: CustomerPlan, event_time: datetime\n",
                "    ) -> Optional[CustomerPlan]:\n",
                "        new_plan, last_ledger_entry = self.make_end_of_cycle_updates_if_needed(plan, event_time)\n",
                "        if last_ledger_entry is None:\n",
                "            return None\n",
                "        if new_plan is not None:\n",
                "            plan = new_plan\n",
                "        licenses_at_next_renewal = self.current_count_for_billed_licenses(event_time)\n",
                "        licenses = max(licenses_at_next_renewal, last_ledger_entry.licenses)\n",
                "\n",
                "        LicenseLedger.objects.create(\n",
                "            plan=plan,\n",
                "            event_time=event_time,\n",
                "            licenses=licenses,\n",
                "            licenses_at_next_renewal=licenses_at_next_renewal,\n",
                "        )\n",
                "\n",
                "        # Returning plan is particularly helpful for 'sync_license_ledger_if_needed'.\n",
                "        # If a new plan is created during the end of cycle update, then that function\n",
                "        # needs the updated plan for a correct LicenseLedger update.\n",
                "        return plan\n",
                "\n",
                "\n",
                "class RealmBillingSession(BillingSession):\n",
                "    def __init__(\n",
                "        self,\n",
                "        user: Optional[UserProfile] = None,\n",
                "        realm: Optional[Realm] = None,\n",
                "        *,\n",
                "        support_session: bool = False,\n",
                "    ) -> None:\n",
                "        self.user = user\n",
                "        assert user is not None or realm is not None\n",
                "        if support_session:\n",
                "            assert user is not None and user.is_staff\n",
                "        self.support_session = support_session\n",
                "\n",
                "        if user is not None and realm is not None:\n",
                "            assert user.is_staff or user.realm == realm\n",
                "            self.realm = realm\n",
                "        elif user is not None:\n",
                "            self.realm = user.realm\n",
                "        else:\n",
                "            assert realm is not None  # for mypy\n",
                "            self.realm = realm\n",
                "\n",
                "    PAID_PLANS = [\n",
                "        Realm.PLAN_TYPE_STANDARD,\n",
                "        Realm.PLAN_TYPE_PLUS,\n",
                "    ]\n",
                "\n",
                "    @override\n",
                "    @property\n",
                "    def billing_entity_display_name(self) -> str:\n",
                "        return self.realm.string_id\n",
                "\n",
                "    @override\n",
                "    @property\n",
                "    def billing_session_url(self) -> str:\n",
                "        return self.realm.uri\n",
                "\n",
                "    @override\n",
                "    @property\n",
                "    def billing_base_url(self) -> str:\n",
                "        return \"\"\n",
                "\n",
                "    @override\n",
                "    def support_url(self) -> str:\n",
                "        return build_support_url(\"support\", self.realm.string_id)\n",
                "\n",
                "    @override\n",
                "    def get_customer(self) -> Optional[Customer]:\n",
                "        return get_customer_by_realm(self.realm)\n",
                "\n",
                "    @override\n",
                "    def get_email(self) -> str:\n",
                "        assert self.user is not None\n",
                "        return self.user.delivery_email\n",
                "\n",
                "    @override\n",
                "    def current_count_for_billed_licenses(self, event_time: datetime = timezone_now()) -> int:\n",
                "        return get_latest_seat_count(self.realm)\n",
                "\n",
                "    @override\n",
                "    def get_audit_log_event(self, event_type: AuditLogEventType) -> int:\n",
                "        if event_type is AuditLogEventType.STRIPE_CUSTOMER_CREATED:\n",
                "            return RealmAuditLog.STRIPE_CUSTOMER_CREATED\n",
                "        elif event_type is AuditLogEventType.STRIPE_CARD_CHANGED:\n",
                "            return RealmAuditLog.STRIPE_CARD_CHANGED\n",
                "        elif event_type is AuditLogEventType.CUSTOMER_PLAN_CREATED:\n",
                "            return RealmAuditLog.CUSTOMER_PLAN_CREATED\n",
                "        elif event_type is AuditLogEventType.DISCOUNT_CHANGED:\n",
                "            return RealmAuditLog.REALM_DISCOUNT_CHANGED\n",
                "        elif event_type is AuditLogEventType.SPONSORSHIP_APPROVED:\n",
                "            return RealmAuditLog.REALM_SPONSORSHIP_APPROVED\n",
                "        elif event_type is AuditLogEventType.SPONSORSHIP_PENDING_STATUS_CHANGED:\n",
                "            return RealmAuditLog.REALM_SPONSORSHIP_PENDING_STATUS_CHANGED\n",
                "        elif event_type is AuditLogEventType.BILLING_MODALITY_CHANGED:\n",
                "            return RealmAuditLog.REALM_BILLING_MODALITY_CHANGED\n",
                "        elif event_type is AuditLogEventType.CUSTOMER_SWITCHED_FROM_MONTHLY_TO_ANNUAL_PLAN:\n",
                "            return RealmAuditLog.CUSTOMER_SWITCHED_FROM_MONTHLY_TO_ANNUAL_PLAN\n",
                "        elif event_type is AuditLogEventType.CUSTOMER_SWITCHED_FROM_ANNUAL_TO_MONTHLY_PLAN:\n",
                "            return RealmAuditLog.CUSTOMER_SWITCHED_FROM_ANNUAL_TO_MONTHLY_PLAN\n",
                "        else:\n",
                "            raise BillingSessionAuditLogEventError(event_type)\n",
                "\n",
                "    @override\n",
                "    def write_to_audit_log(\n",
                "        self,\n",
                "        event_type: AuditLogEventType,\n",
                "        event_time: datetime,\n",
                "        *,\n",
                "        extra_data: Optional[Dict[str, Any]] = None,\n",
                "    ) -> None:\n",
                "        audit_log_event = self.get_audit_log_event(event_type)\n",
                "        audit_log_data = {\n",
                "            \"realm\": self.realm,\n",
                "            \"event_type\": audit_log_event,\n",
                "            \"event_time\": event_time,\n",
                "        }\n",
                "\n",
                "        if extra_data:\n",
                "            audit_log_data[\"extra_data\"] = extra_data\n",
                "\n",
                "        if self.user is not None:\n",
                "            audit_log_data[\"acting_user\"] = self.user\n",
                "\n",
                "        RealmAuditLog.objects.create(**audit_log_data)\n",
                "\n",
                "    @override\n",
                "    def get_data_for_stripe_customer(self) -> StripeCustomerData:\n",
                "        # Support requests do not set any stripe billing information.\n",
                "        assert self.support_session is False\n",
                "        assert self.user is not None\n",
                "        metadata: Dict[str, Any] = {}\n",
                "        metadata[\"realm_id\"] = self.realm.id\n",
                "        metadata[\"realm_str\"] = self.realm.string_id\n",
                "        realm_stripe_customer_data = StripeCustomerData(\n",
                "            description=f\"{self.realm.string_id} ({self.realm.name})\",\n",
                "            email=self.get_email(),\n",
                "            metadata=metadata,\n",
                "        )\n",
                "        return realm_stripe_customer_data\n",
                "\n",
                "    @override\n",
                "    def update_data_for_checkout_session_and_payment_intent(\n",
                "        self, metadata: Dict[str, Any]\n",
                "    ) -> Dict[str, Any]:\n",
                "        assert self.user is not None\n",
                "        updated_metadata = dict(\n",
                "            user_email=self.get_email(),\n",
                "            realm_id=self.realm.id,\n",
                "            realm_str=self.realm.string_id,\n",
                "            user_id=self.user.id,\n",
                "            **metadata,\n",
                "        )\n",
                "        return updated_metadata\n",
                "\n",
                "    @override\n",
                "    def update_or_create_customer(\n",
                "        self, stripe_customer_id: Optional[str] = None, *, defaults: Optional[Dict[str, Any]] = None\n",
                "    ) -> Customer:\n",
                "        if stripe_customer_id is not None:\n",
                "            # Support requests do not set any stripe billing information.\n",
                "            assert self.support_session is False\n",
                "            customer, created = Customer.objects.update_or_create(\n",
                "                realm=self.realm, defaults={\"stripe_customer_id\": stripe_customer_id}\n",
                "            )\n",
                "            from zerver.actions.users import do_change_is_billing_admin\n",
                "\n",
                "            assert self.user is not None\n",
                "            do_change_is_billing_admin(self.user, True)\n",
                "            return customer\n",
                "        else:\n",
                "            customer, created = Customer.objects.update_or_create(\n",
                "                realm=self.realm, defaults=defaults\n",
                "            )\n",
                "            return customer\n",
                "\n",
                "    @override\n",
                "    def do_change_plan_type(self, *, tier: Optional[int], is_sponsored: bool = False) -> None:\n",
                "        from zerver.actions.realm_settings import do_change_realm_plan_type\n",
                "\n",
                "        # This function needs to translate between the different\n",
                "        # formats of CustomerPlan.tier and Realm.plan_type.\n",
                "        if is_sponsored:\n",
                "            plan_type = Realm.PLAN_TYPE_STANDARD_FREE\n",
                "        elif tier == CustomerPlan.TIER_CLOUD_STANDARD:\n",
                "            plan_type = Realm.PLAN_TYPE_STANDARD\n",
                "        elif (\n",
                "            tier == CustomerPlan.TIER_CLOUD_PLUS\n",
                "        ):  # nocoverage # Plus plan doesn't use this code path yet.\n",
                "            plan_type = Realm.PLAN_TYPE_PLUS\n",
                "        else:\n",
                "            raise AssertionError(\"Unexpected tier\")\n",
                "        do_change_realm_plan_type(self.realm, plan_type, acting_user=self.user)\n",
                "\n",
                "    @override\n",
                "    def process_downgrade(self, plan: CustomerPlan) -> None:\n",
                "        from zerver.actions.realm_settings import do_change_realm_plan_type\n",
                "\n",
                "        assert plan.customer.realm is not None\n",
                "        do_change_realm_plan_type(plan.customer.realm, Realm.PLAN_TYPE_LIMITED, acting_user=None)\n",
                "        plan.status = CustomerPlan.ENDED\n",
                "        plan.save(update_fields=[\"status\"])\n",
                "\n",
                "    @override\n",
                "    def approve_sponsorship(self) -> str:\n",
                "        # Sponsorship approval is only a support admin action.\n",
                "        assert self.support_session\n",
                "\n",
                "        from zerver.actions.message_send import internal_send_private_message\n",
                "\n",
                "        self.do_change_plan_type(tier=None, is_sponsored=True)\n",
                "        customer = self.get_customer()\n",
                "        if customer is not None and customer.sponsorship_pending:\n",
                "            customer.sponsorship_pending = False\n",
                "            customer.save(update_fields=[\"sponsorship_pending\"])\n",
                "            self.write_to_audit_log(\n",
                "                event_type=AuditLogEventType.SPONSORSHIP_APPROVED, event_time=timezone_now()\n",
                "            )\n",
                "        notification_bot = get_system_bot(settings.NOTIFICATION_BOT, self.realm.id)\n",
                "        for user in self.realm.get_human_billing_admin_and_realm_owner_users():\n",
                "            with override_language(user.default_language):\n",
                "                # Using variable to make life easier for translators if these details change.\n",
                "                message = _(\n",
                "                    \"Your organization's request for sponsored hosting has been approved! \"\n",
                "                    \"You have been upgraded to {plan_name}, free of charge. {emoji}\\n\\n\"\n",
                "                    \"If you could {begin_link}list Zulip as a sponsor on your website{end_link}, \"\n",
                "                    \"we would really appreciate it!\"\n",
                "                ).format(\n",
                "                    # TODO: Don't hardcode plan names.\n",
                "                    plan_name=\"Zulip Cloud Standard\",\n",
                "                    emoji=\":tada:\",\n",
                "                    begin_link=\"[\",\n",
                "                    end_link=\"](/help/linking-to-zulip-website)\",\n",
                "                )\n",
                "                internal_send_private_message(notification_bot, user, message)\n",
                "        return f\"Sponsorship approved for {self.billing_entity_display_name}\"\n",
                "\n",
                "    @override\n",
                "    def is_sponsored(self) -> bool:\n",
                "        return self.realm.plan_type == self.realm.PLAN_TYPE_STANDARD_FREE\n",
                "\n",
                "    @override\n",
                "    def get_metadata_for_stripe_update_card(self) -> Dict[str, Any]:\n",
                "        assert self.user is not None\n",
                "        return {\n",
                "            \"type\": \"card_update\",\n",
                "            \"user_id\": self.user.id,\n",
                "        }\n",
                "\n",
                "    @override\n",
                "    def get_upgrade_page_session_type_specific_context(\n",
                "        self,\n",
                "    ) -> UpgradePageSessionTypeSpecificContext:\n",
                "        assert self.user is not None\n",
                "        return UpgradePageSessionTypeSpecificContext(\n",
                "            customer_name=self.realm.name,\n",
                "            email=self.get_email(),\n",
                "            is_demo_organization=self.realm.demo_organization_scheduled_deletion_date is not None,\n",
                "            demo_organization_scheduled_deletion_date=self.realm.demo_organization_scheduled_deletion_date,\n",
                "            is_self_hosting=False,\n",
                "        )\n",
                "\n",
                "    @override\n",
                "    def get_type_of_plan_tier_change(\n",
                "        self, current_plan_tier: int, new_plan_tier: int\n",
                "    ) -> PlanTierChangeType:\n",
                "        valid_plan_tiers = [CustomerPlan.TIER_CLOUD_STANDARD, CustomerPlan.TIER_CLOUD_PLUS]\n",
                "        if (\n",
                "            current_plan_tier not in valid_plan_tiers\n",
                "            or new_plan_tier not in valid_plan_tiers\n",
                "            or current_plan_tier == new_plan_tier\n",
                "        ):\n",
                "            return PlanTierChangeType.INVALID\n",
                "        if (\n",
                "            current_plan_tier == CustomerPlan.TIER_CLOUD_STANDARD\n",
                "            and new_plan_tier == CustomerPlan.TIER_CLOUD_PLUS\n",
                "        ):\n",
                "            return PlanTierChangeType.UPGRADE\n",
                "        else:  # nocoverage, not currently implemented\n",
                "            assert current_plan_tier == CustomerPlan.TIER_CLOUD_PLUS\n",
                "            assert new_plan_tier == CustomerPlan.TIER_CLOUD_STANDARD\n",
                "            return PlanTierChangeType.DOWNGRADE\n",
                "\n",
                "    @override\n",
                "    def has_billing_access(self) -> bool:\n",
                "        assert self.user is not None\n",
                "        return self.user.has_billing_access\n",
                "\n",
                "    @override\n",
                "    def on_paid_plan(self) -> bool:\n",
                "        return self.realm.plan_type in self.PAID_PLANS\n",
                "\n",
                "    @override\n",
                "    def add_sponsorship_info_to_context(self, context: Dict[str, Any]) -> None:\n",
                "        context.update(\n",
                "            realm_org_type=self.realm.org_type,\n",
                "            sorted_org_types=sorted(\n",
                "                (\n",
                "                    [org_type_name, org_type]\n",
                "                    for (org_type_name, org_type) in Realm.ORG_TYPES.items()\n",
                "                    if not org_type.get(\"hidden\")\n",
                "                ),\n",
                "                key=sponsorship_org_type_key_helper,\n",
                "            ),\n",
                "        )\n",
                "        context[\"org_name\"] = self.realm.name\n",
                "\n",
                "    @override\n",
                "    def get_sponsorship_request_session_specific_context(\n",
                "        self,\n",
                "    ) -> SponsorshipRequestSessionSpecificContext:\n",
                "        assert self.user is not None\n",
                "        return SponsorshipRequestSessionSpecificContext(\n",
                "            realm_user=self.user,\n",
                "            user_info=SponsorshipApplicantInfo(\n",
                "                name=self.user.full_name,\n",
                "                email=self.get_email(),\n",
                "                role=self.user.get_role_name(),\n",
                "            ),\n",
                "            realm_string_id=self.realm.string_id,\n",
                "        )\n",
                "\n",
                "    @override\n",
                "    def save_org_type_from_request_sponsorship_session(self, org_type: int) -> None:\n",
                "        # TODO: Use the actions.py method for this.\n",
                "        if self.realm.org_type != org_type:\n",
                "            self.realm.org_type = org_type\n",
                "            self.realm.save(update_fields=[\"org_type\"])\n",
                "\n",
                "    def update_license_ledger_if_needed(self, event_time: datetime) -> None:\n",
                "        customer = self.get_customer()\n",
                "        if customer is None:\n",
                "            return\n",
                "        plan = get_current_plan_by_customer(customer)\n",
                "        if plan is None:\n",
                "            return\n",
                "        if not plan.automanage_licenses:\n",
                "            return\n",
                "        self.update_license_ledger_for_automanaged_plan(plan, event_time)\n",
                "\n",
                "\n",
                "class RemoteRealmBillingSession(BillingSession):  # nocoverage\n",
                "    def __init__(\n",
                "        self,\n",
                "        remote_realm: RemoteRealm,\n",
                "        support_staff: Optional[UserProfile] = None,\n",
                "    ) -> None:\n",
                "        self.remote_realm = remote_realm\n",
                "        if support_staff is not None:\n",
                "            assert support_staff.is_staff\n",
                "            self.support_session = True\n",
                "        else:\n",
                "            self.support_session = False\n",
                "\n",
                "    @override\n",
                "    @property\n",
                "    def billing_entity_display_name(self) -> str:\n",
                "        return self.remote_realm.name\n",
                "\n",
                "    @override\n",
                "    @property\n",
                "    def billing_session_url(self) -> str:\n",
                "        return f\"{settings.EXTERNAL_URI_SCHEME}{settings.SELF_HOSTING_MANAGEMENT_SUBDOMAIN}.{settings.EXTERNAL_HOST}/realm/{self.remote_realm.uuid}\"\n",
                "\n",
                "    @override\n",
                "    @property\n",
                "    def billing_base_url(self) -> str:\n",
                "        return f\"/realm/{self.remote_realm.uuid}\"\n",
                "\n",
                "    @override\n",
                "    def support_url(self) -> str:\n",
                "        return build_support_url(\"remote_servers_support\", self.remote_realm.server.hostname)\n",
                "\n",
                "    @override\n",
                "    def get_customer(self) -> Optional[Customer]:\n",
                "        return get_customer_by_remote_realm(self.remote_realm)\n",
                "\n",
                "    @override\n",
                "    def get_email(self) -> str:\n",
                "        # BUG: This is an email for the whole server. We probably\n",
                "        # need a separable field here.\n",
                "        return self.remote_realm.server.contact_email\n",
                "\n",
                "    @override\n",
                "    def current_count_for_billed_licenses(self, event_time: datetime = timezone_now()) -> int:\n",
                "        if has_stale_audit_log(self.remote_realm.server):\n",
                "            raise MissingDataError\n",
                "        remote_realm_counts = get_remote_realm_guest_and_non_guest_count(\n",
                "            self.remote_realm, event_time\n",
                "        )\n",
                "        return remote_realm_counts.non_guest_user_count + remote_realm_counts.guest_user_count\n",
                "\n",
                "    @override\n",
                "    def get_audit_log_event(self, event_type: AuditLogEventType) -> int:\n",
                "        if event_type is AuditLogEventType.STRIPE_CUSTOMER_CREATED:\n",
                "            return RemoteRealmAuditLog.STRIPE_CUSTOMER_CREATED\n",
                "        elif event_type is AuditLogEventType.STRIPE_CARD_CHANGED:\n",
                "            return RemoteRealmAuditLog.STRIPE_CARD_CHANGED\n",
                "        elif event_type is AuditLogEventType.CUSTOMER_PLAN_CREATED:\n",
                "            return RemoteRealmAuditLog.CUSTOMER_PLAN_CREATED\n",
                "        elif event_type is AuditLogEventType.DISCOUNT_CHANGED:\n",
                "            return RemoteRealmAuditLog.REMOTE_SERVER_DISCOUNT_CHANGED\n",
                "        elif event_type is AuditLogEventType.SPONSORSHIP_APPROVED:\n",
                "            return RemoteRealmAuditLog.REMOTE_SERVER_SPONSORSHIP_APPROVED\n",
                "        elif event_type is AuditLogEventType.SPONSORSHIP_PENDING_STATUS_CHANGED:\n",
                "            return RemoteRealmAuditLog.REMOTE_SERVER_SPONSORSHIP_PENDING_STATUS_CHANGED\n",
                "        elif event_type is AuditLogEventType.BILLING_MODALITY_CHANGED:\n",
                "            return RemoteRealmAuditLog.REMOTE_SERVER_BILLING_MODALITY_CHANGED\n",
                "        elif event_type is AuditLogEventType.BILLING_ENTITY_PLAN_TYPE_CHANGED:\n",
                "            return RemoteRealmAuditLog.REMOTE_SERVER_PLAN_TYPE_CHANGED\n",
                "        elif event_type is AuditLogEventType.CUSTOMER_SWITCHED_FROM_MONTHLY_TO_ANNUAL_PLAN:\n",
                "            return RemoteRealmAuditLog.CUSTOMER_SWITCHED_FROM_MONTHLY_TO_ANNUAL_PLAN\n",
                "        elif event_type is AuditLogEventType.CUSTOMER_SWITCHED_FROM_ANNUAL_TO_MONTHLY_PLAN:\n",
                "            return RemoteRealmAuditLog.CUSTOMER_SWITCHED_FROM_ANNUAL_TO_MONTHLY_PLAN\n",
                "        else:\n",
                "            raise BillingSessionAuditLogEventError(event_type)\n",
                "\n",
                "    @override\n",
                "    def write_to_audit_log(\n",
                "        self,\n",
                "        event_type: AuditLogEventType,\n",
                "        event_time: datetime,\n",
                "        *,\n",
                "        extra_data: Optional[Dict[str, Any]] = None,\n",
                "    ) -> None:\n",
                "        # These audit logs don't use all the fields of `RemoteRealmAuditLog`:\n",
                "        #\n",
                "        # * remote_id is None because this is not synced from a remote table.\n",
                "        # * realm_id is None because we do not aim to store both remote_realm\n",
                "        #   and the legacy realm_id field.\n",
                "        audit_log_event = self.get_audit_log_event(event_type)\n",
                "        log_data = {\n",
                "            \"server\": self.remote_realm.server,\n",
                "            \"remote_realm\": self.remote_realm,\n",
                "            \"event_type\": audit_log_event,\n",
                "            \"event_time\": event_time,\n",
                "        }\n",
                "\n",
                "        if extra_data:\n",
                "            log_data[\"extra_data\"] = extra_data\n",
                "\n",
                "        RemoteRealmAuditLog.objects.create(**log_data)\n",
                "\n",
                "    @override\n",
                "    def get_data_for_stripe_customer(self) -> StripeCustomerData:\n",
                "        # Support requests do not set any stripe billing information.\n",
                "        assert self.support_session is False\n",
                "        metadata: Dict[str, Any] = {}\n",
                "        metadata[\"remote_realm_uuid\"] = self.remote_realm.uuid\n",
                "        metadata[\"remote_realm_host\"] = str(self.remote_realm.host)\n",
                "        realm_stripe_customer_data = StripeCustomerData(\n",
                "            description=str(self.remote_realm),\n",
                "            email=self.get_email(),\n",
                "            metadata=metadata,\n",
                "        )\n",
                "        return realm_stripe_customer_data\n",
                "\n",
                "    @override\n",
                "    def update_data_for_checkout_session_and_payment_intent(\n",
                "        self, metadata: Dict[str, Any]\n",
                "    ) -> Dict[str, Any]:\n",
                "        # TODO: Figure out what this should do.\n",
                "        updated_metadata = dict(\n",
                "            **metadata,\n",
                "        )\n",
                "        return updated_metadata\n",
                "\n",
                "    @override\n",
                "    def update_or_create_customer(\n",
                "        self, stripe_customer_id: Optional[str] = None, *, defaults: Optional[Dict[str, Any]] = None\n",
                "    ) -> Customer:\n",
                "        if stripe_customer_id is not None:\n",
                "            # Support requests do not set any stripe billing information.\n",
                "            assert self.support_session is False\n",
                "            customer, created = Customer.objects.update_or_create(\n",
                "                remote_realm=self.remote_realm,\n",
                "                defaults={\"stripe_customer_id\": stripe_customer_id},\n",
                "            )\n",
                "            return customer\n",
                "        else:\n",
                "            customer, created = Customer.objects.update_or_create(\n",
                "                remote_realm=self.remote_realm, defaults=defaults\n",
                "            )\n",
                "            return customer\n",
                "\n",
                "    @override\n",
                "    def do_change_plan_type(self, *, tier: Optional[int], is_sponsored: bool = False) -> None:\n",
                "        if is_sponsored:\n",
                "            plan_type = RemoteRealm.PLAN_TYPE_COMMUNITY\n",
                "        elif tier == CustomerPlan.TIER_SELF_HOSTED_BUSINESS:\n",
                "            plan_type = RemoteRealm.PLAN_TYPE_BUSINESS\n",
                "        elif (\n",
                "            tier == CustomerPlan.TIER_SELF_HOSTED_PLUS\n",
                "        ):  # nocoverage # Plus plan doesn't use this code path yet.\n",
                "            plan_type = RemoteRealm.PLAN_TYPE_ENTERPRISE\n",
                "        else:\n",
                "            raise AssertionError(\"Unexpected tier\")\n",
                "\n",
                "        # TODO: Audit logging and set usage limits.\n",
                "\n",
                "        self.remote_realm.plan_type = plan_type\n",
                "        self.remote_realm.save(update_fields=[\"plan_type\"])\n",
                "\n",
                "    @override\n",
                "    def approve_sponsorship(self) -> str:\n",
                "        # Sponsorship approval is only a support admin action.\n",
                "        assert self.support_session\n",
                "\n",
                "        self.do_change_plan_type(tier=None, is_sponsored=True)\n",
                "        customer = self.get_customer()\n",
                "        if customer is not None and customer.sponsorship_pending:\n",
                "            customer.sponsorship_pending = False\n",
                "            customer.save(update_fields=[\"sponsorship_pending\"])\n",
                "            self.write_to_audit_log(\n",
                "                event_type=AuditLogEventType.SPONSORSHIP_APPROVED, event_time=timezone_now()\n",
                "            )\n",
                "        emailed_string = \"\"\n",
                "        billing_emails = list(\n",
                "            RemoteRealmBillingUser.objects.filter(remote_realm_id=self.remote_realm.id).values_list(\n",
                "                \"email\", flat=True\n",
                "            )\n",
                "        )\n",
                "        if len(billing_emails) > 0:\n",
                "            send_email(\n",
                "                \"zerver/emails/sponsorship_approved_community_plan\",\n",
                "                to_emails=billing_emails,\n",
                "                from_address=\"sales@zulip.com\",\n",
                "                context={\n",
                "                    \"billing_entity\": self.billing_entity_display_name,\n",
                "                    \"plans_link\": \"https://zulip.com/plans/#self-hosted\",\n",
                "                    \"link_to_zulip\": \"https://zulip.com/help/linking-to-zulip-website\",\n",
                "                },\n",
                "            )\n",
                "            emailed_string = \"Emailed existing billing users.\"\n",
                "        else:\n",
                "            emailed_string = \"No billing users exist to email.\"\n",
                "\n",
                "        return f\"Sponsorship approved for {self.billing_entity_display_name}; \" + emailed_string\n",
                "\n",
                "    @override\n",
                "    def is_sponsored(self) -> bool:\n",
                "        return self.remote_realm.plan_type == self.remote_realm.PLAN_TYPE_COMMUNITY\n",
                "\n",
                "    @override\n",
                "    def get_metadata_for_stripe_update_card(self) -> Dict[str, Any]:\n",
                "        return {\n",
                "            \"type\": \"card_update\",\n",
                "            # TODO: Add user identity metadata from the remote realm identity\n",
                "            # \"user_id\": user.id,\n",
                "        }\n",
                "\n",
                "    @override\n",
                "    def get_upgrade_page_session_type_specific_context(\n",
                "        self,\n",
                "    ) -> UpgradePageSessionTypeSpecificContext:\n",
                "        return UpgradePageSessionTypeSpecificContext(\n",
                "            customer_name=self.remote_realm.host,\n",
                "            email=self.get_email(),\n",
                "            is_demo_organization=False,\n",
                "            demo_organization_scheduled_deletion_date=None,\n",
                "            is_self_hosting=True,\n",
                "        )\n",
                "\n",
                "    @override\n",
                "    def process_downgrade(self, plan: CustomerPlan) -> None:\n",
                "        with transaction.atomic():\n",
                "            old_plan_type = self.remote_realm.plan_type\n",
                "            new_plan_type = RemoteRealm.PLAN_TYPE_SELF_HOSTED\n",
                "            self.remote_realm.plan_type = new_plan_type\n",
                "            self.remote_realm.save(update_fields=[\"plan_type\"])\n",
                "            self.write_to_audit_log(\n",
                "                event_type=AuditLogEventType.BILLING_ENTITY_PLAN_TYPE_CHANGED,\n",
                "                event_time=timezone_now(),\n",
                "                extra_data={\"old_value\": old_plan_type, \"new_value\": new_plan_type},\n",
                "            )\n",
                "\n",
                "        plan.status = CustomerPlan.ENDED\n",
                "        plan.save(update_fields=[\"status\"])\n",
                "\n",
                "    @override\n",
                "    def get_type_of_plan_tier_change(\n",
                "        self, current_plan_tier: int, new_plan_tier: int\n",
                "    ) -> PlanTierChangeType:\n",
                "        valid_plan_tiers = [\n",
                "            CustomerPlan.TIER_SELF_HOSTED_BUSINESS,\n",
                "            CustomerPlan.TIER_SELF_HOSTED_PLUS,\n",
                "        ]\n",
                "        if (\n",
                "            current_plan_tier not in valid_plan_tiers\n",
                "            or new_plan_tier not in valid_plan_tiers\n",
                "            or current_plan_tier == new_plan_tier\n",
                "        ):\n",
                "            return PlanTierChangeType.INVALID\n",
                "        if (\n",
                "            current_plan_tier == CustomerPlan.TIER_SELF_HOSTED_BUSINESS\n",
                "            and new_plan_tier == CustomerPlan.TIER_SELF_HOSTED_PLUS\n",
                "        ):\n",
                "            return PlanTierChangeType.UPGRADE\n",
                "        else:\n",
                "            assert current_plan_tier == CustomerPlan.TIER_SELF_HOSTED_PLUS\n",
                "            assert new_plan_tier == CustomerPlan.TIER_SELF_HOSTED_BUSINESS\n",
                "            return PlanTierChangeType.DOWNGRADE\n",
                "\n",
                "    @override\n",
                "    def has_billing_access(self) -> bool:\n",
                "        # We don't currently have a way to authenticate a remote\n",
                "        # session that isn't authorized for billing access.\n",
                "        return True\n",
                "\n",
                "    PAID_PLANS = [\n",
                "        RemoteRealm.PLAN_TYPE_BUSINESS,\n",
                "        RemoteRealm.PLAN_TYPE_ENTERPRISE,\n",
                "    ]\n",
                "\n",
                "    @override\n",
                "    def on_paid_plan(self) -> bool:\n",
                "        return self.remote_realm.plan_type in self.PAID_PLANS\n",
                "\n",
                "    @override\n",
                "    def add_sponsorship_info_to_context(self, context: Dict[str, Any]) -> None:\n",
                "        context.update(\n",
                "            realm_org_type=self.remote_realm.org_type,\n",
                "            sorted_org_types=sorted(\n",
                "                (\n",
                "                    [org_type_name, org_type]\n",
                "                    for (org_type_name, org_type) in Realm.ORG_TYPES.items()\n",
                "                    if not org_type.get(\"hidden\")\n",
                "                ),\n",
                "                key=sponsorship_org_type_key_helper,\n",
                "            ),\n",
                "        )\n",
                "        context[\"org_name\"] = self.remote_realm.host\n",
                "\n",
                "    @override\n",
                "    def get_sponsorship_request_session_specific_context(\n",
                "        self,\n",
                "    ) -> SponsorshipRequestSessionSpecificContext:\n",
                "        return SponsorshipRequestSessionSpecificContext(\n",
                "            realm_user=None,\n",
                "            user_info=SponsorshipApplicantInfo(\n",
                "                # TODO: Plumb through the session data on the acting user.\n",
                "                name=\"Remote realm administrator\",\n",
                "                email=self.get_email(),\n",
                "                # TODO: Set user_role when determining which set of users can access the page.\n",
                "                role=\"Remote realm administrator\",\n",
                "            ),\n",
                "            # TODO: Check if this works on support page.\n",
                "            realm_string_id=self.remote_realm.host,\n",
                "        )\n",
                "\n",
                "    @override\n",
                "    def save_org_type_from_request_sponsorship_session(self, org_type: int) -> None:\n",
                "        if self.remote_realm.org_type != org_type:\n",
                "            self.remote_realm.org_type = org_type\n",
                "            self.remote_realm.save(update_fields=[\"org_type\"])\n",
                "\n",
                "    def sync_license_ledger_if_needed(self) -> None:\n",
                "        # Updates the license ledger based on RemoteRealmAuditLog\n",
                "        # entries.\n",
                "        #\n",
                "        # Supports backfilling entries from weeks if the past if\n",
                "        # needed when we receive audit logs, making any end-of-cycle\n",
                "        # updates that happen to be scheduled inside the interval that\n",
                "        # we are processing.\n",
                "        #\n",
                "        # But this support is fragile, in that it does not handle the\n",
                "        # possibility that some other code path changed or ended the\n",
                "        # customer's current plan at some point after\n",
                "        # last_ledger.event_time but before the event times for the\n",
                "        # audit logs we will be processing.\n",
                "        customer = self.get_customer()\n",
                "        if customer is None:\n",
                "            return\n",
                "        plan = get_current_plan_by_customer(customer)\n",
                "        if plan is None:\n",
                "            return\n",
                "        if not plan.automanage_licenses:\n",
                "            return\n",
                "\n",
                "        # It's an invariant that any current plan have at least an\n",
                "        # initial ledger entry.\n",
                "        last_ledger = LicenseLedger.objects.filter(plan=plan).order_by(\"id\").last()\n",
                "        assert last_ledger is not None\n",
                "\n",
                "        # New audit logs since last_ledger for the plan was created.\n",
                "        new_audit_logs = (\n",
                "            RemoteRealmAuditLog.objects.filter(\n",
                "                remote_realm=self.remote_realm,\n",
                "                event_time__gt=last_ledger.event_time,\n",
                "                event_type__in=RemoteRealmAuditLog.SYNCED_BILLING_EVENTS,\n",
                "            )\n",
                "            .exclude(extra_data={})\n",
                "            .order_by(\"event_time\")\n",
                "        )\n",
                "\n",
                "        for audit_log in new_audit_logs:\n",
                "            plan = self.update_license_ledger_for_automanaged_plan(plan, audit_log.event_time)\n",
                "            if plan is None:\n",
                "                return\n",
                "\n",
                "\n",
                "class RemoteServerBillingSession(BillingSession):  # nocoverage\n",
                "    \"\"\"Billing session for pre-8.0 servers that do not yet support\n",
                "    creating RemoteRealm objects.\"\"\"\n",
                "\n",
                "    def __init__(\n",
                "        self,\n",
                "        remote_server: RemoteZulipServer,\n",
                "        remote_billing_user: Optional[RemoteServerBillingUser] = None,\n",
                "        support_staff: Optional[UserProfile] = None,\n",
                "    ) -> None:\n",
                "        self.remote_server = remote_server\n",
                "        self.remote_billing_user = remote_billing_user\n",
                "        if support_staff is not None:\n",
                "            assert support_staff.is_staff\n",
                "            self.support_session = True\n",
                "        else:\n",
                "            self.support_session = False\n",
                "\n",
                "    @override\n",
                "    @property\n",
                "    def billing_entity_display_name(self) -> str:\n",
                "        return self.remote_server.hostname\n",
                "\n",
                "    @override\n",
                "    @property\n",
                "    def billing_session_url(self) -> str:\n",
                "        return f\"{settings.EXTERNAL_URI_SCHEME}{settings.SELF_HOSTING_MANAGEMENT_SUBDOMAIN}.{settings.EXTERNAL_HOST}/server/{self.remote_server.uuid}\"\n",
                "\n",
                "    @override\n",
                "    @property\n",
                "    def billing_base_url(self) -> str:\n",
                "        return f\"/server/{self.remote_server.uuid}\"\n",
                "\n",
                "    @override\n",
                "    def support_url(self) -> str:\n",
                "        return build_support_url(\"remote_servers_support\", self.remote_server.hostname)\n",
                "\n",
                "    @override\n",
                "    def get_customer(self) -> Optional[Customer]:\n",
                "        return get_customer_by_remote_server(self.remote_server)\n",
                "\n",
                "    @override\n",
                "    def get_email(self) -> str:\n",
                "        return self.remote_server.contact_email\n",
                "\n",
                "    @override\n",
                "    def current_count_for_billed_licenses(self, event_time: datetime = timezone_now()) -> int:\n",
                "        if has_stale_audit_log(self.remote_server):\n",
                "            raise MissingDataError\n",
                "        remote_server_counts = get_remote_server_guest_and_non_guest_count(\n",
                "            self.remote_server.id, event_time\n",
                "        )\n",
                "        return remote_server_counts.non_guest_user_count + remote_server_counts.guest_user_count\n",
                "\n",
                "    @override\n",
                "    def get_audit_log_event(self, event_type: AuditLogEventType) -> int:\n",
                "        if event_type is AuditLogEventType.STRIPE_CUSTOMER_CREATED:\n",
                "            return RemoteZulipServerAuditLog.STRIPE_CUSTOMER_CREATED\n",
                "        elif event_type is AuditLogEventType.STRIPE_CARD_CHANGED:\n",
                "            return RemoteZulipServerAuditLog.STRIPE_CARD_CHANGED\n",
                "        elif event_type is AuditLogEventType.CUSTOMER_PLAN_CREATED:\n",
                "            return RemoteZulipServerAuditLog.CUSTOMER_PLAN_CREATED\n",
                "        elif event_type is AuditLogEventType.DISCOUNT_CHANGED:\n",
                "            return RemoteZulipServerAuditLog.REMOTE_SERVER_DISCOUNT_CHANGED\n",
                "        elif event_type is AuditLogEventType.SPONSORSHIP_APPROVED:\n",
                "            return RemoteZulipServerAuditLog.REMOTE_SERVER_SPONSORSHIP_APPROVED\n",
                "        elif event_type is AuditLogEventType.SPONSORSHIP_PENDING_STATUS_CHANGED:\n",
                "            return RemoteZulipServerAuditLog.REMOTE_SERVER_SPONSORSHIP_PENDING_STATUS_CHANGED\n",
                "        elif event_type is AuditLogEventType.BILLING_MODALITY_CHANGED:\n",
                "            return RemoteZulipServerAuditLog.REMOTE_SERVER_BILLING_MODALITY_CHANGED\n",
                "        elif event_type is AuditLogEventType.BILLING_ENTITY_PLAN_TYPE_CHANGED:\n",
                "            return RemoteZulipServerAuditLog.REMOTE_SERVER_PLAN_TYPE_CHANGED\n",
                "        elif event_type is AuditLogEventType.CUSTOMER_SWITCHED_FROM_MONTHLY_TO_ANNUAL_PLAN:\n",
                "            return RemoteZulipServerAuditLog.CUSTOMER_SWITCHED_FROM_MONTHLY_TO_ANNUAL_PLAN\n",
                "        elif event_type is AuditLogEventType.CUSTOMER_SWITCHED_FROM_ANNUAL_TO_MONTHLY_PLAN:\n",
                "            return RemoteZulipServerAuditLog.CUSTOMER_SWITCHED_FROM_ANNUAL_TO_MONTHLY_PLAN\n",
                "        else:\n",
                "            raise BillingSessionAuditLogEventError(event_type)\n",
                "\n",
                "    @override\n",
                "    def write_to_audit_log(\n",
                "        self,\n",
                "        event_type: AuditLogEventType,\n",
                "        event_time: datetime,\n",
                "        *,\n",
                "        extra_data: Optional[Dict[str, Any]] = None,\n",
                "    ) -> None:\n",
                "        audit_log_event = self.get_audit_log_event(event_type)\n",
                "        log_data = {\n",
                "            \"server\": self.remote_server,\n",
                "            \"event_type\": audit_log_event,\n",
                "            \"event_time\": event_time,\n",
                "        }\n",
                "\n",
                "        if extra_data:\n",
                "            log_data[\"extra_data\"] = extra_data\n",
                "\n",
                "        RemoteZulipServerAuditLog.objects.create(**log_data)\n",
                "\n",
                "    @override\n",
                "    def get_data_for_stripe_customer(self) -> StripeCustomerData:\n",
                "        # Support requests do not set any stripe billing information.\n",
                "        assert self.support_session is False\n",
                "        metadata: Dict[str, Any] = {}\n",
                "        metadata[\"remote_server_uuid\"] = self.remote_server.uuid\n",
                "        metadata[\"remote_server_str\"] = str(self.remote_server)\n",
                "        realm_stripe_customer_data = StripeCustomerData(\n",
                "            description=str(self.remote_server),\n",
                "            email=self.get_email(),\n",
                "            metadata=metadata,\n",
                "        )\n",
                "        return realm_stripe_customer_data\n",
                "\n",
                "    @override\n",
                "    def update_data_for_checkout_session_and_payment_intent(\n",
                "        self, metadata: Dict[str, Any]\n",
                "    ) -> Dict[str, Any]:\n",
                "        updated_metadata = dict(\n",
                "            server=self.remote_server,\n",
                "            email=self.get_email(),\n",
                "            **metadata,\n",
                "        )\n",
                "        return updated_metadata\n",
                "\n",
                "    @override\n",
                "    def update_or_create_customer(\n",
                "        self, stripe_customer_id: Optional[str] = None, *, defaults: Optional[Dict[str, Any]] = None\n",
                "    ) -> Customer:\n",
                "        if stripe_customer_id is not None:\n",
                "            # Support requests do not set any stripe billing information.\n",
                "            assert self.support_session is False\n",
                "            customer, created = Customer.objects.update_or_create(\n",
                "                remote_server=self.remote_server,\n",
                "                defaults={\"stripe_customer_id\": stripe_customer_id},\n",
                "            )\n",
                "            return customer\n",
                "        else:\n",
                "            customer, created = Customer.objects.update_or_create(\n",
                "                remote_server=self.remote_server, defaults=defaults\n",
                "            )\n",
                "            return customer\n",
                "\n",
                "    @override\n",
                "    def do_change_plan_type(self, *, tier: Optional[int], is_sponsored: bool = False) -> None:\n",
                "        # TODO: Create actual plan types.\n",
                "\n",
                "        # This function needs to translate between the different\n",
                "        # formats of CustomerPlan.tier and RealmZulipServer.plan_type.\n",
                "        if is_sponsored:\n",
                "            plan_type = RemoteZulipServer.PLAN_TYPE_COMMUNITY\n",
                "        elif tier == CustomerPlan.TIER_SELF_HOSTED_BUSINESS:\n",
                "            plan_type = RemoteZulipServer.PLAN_TYPE_BUSINESS\n",
                "        elif (\n",
                "            tier == CustomerPlan.TIER_SELF_HOSTED_PLUS\n",
                "        ):  # nocoverage # Plus plan doesn't use this code path yet.\n",
                "            plan_type = RemoteZulipServer.PLAN_TYPE_ENTERPRISE\n",
                "        else:\n",
                "            raise AssertionError(\"Unexpected tier\")\n",
                "\n",
                "        # TODO: Audit logging and set usage limits.\n",
                "\n",
                "        self.remote_server.plan_type = plan_type\n",
                "        self.remote_server.save(update_fields=[\"plan_type\"])\n",
                "\n",
                "    @override\n",
                "    def approve_sponsorship(self) -> str:\n",
                "        # Sponsorship approval is only a support admin action.\n",
                "        assert self.support_session\n",
                "\n",
                "        self.do_change_plan_type(tier=None, is_sponsored=True)\n",
                "        customer = self.get_customer()\n",
                "        if customer is not None and customer.sponsorship_pending:\n",
                "            customer.sponsorship_pending = False\n",
                "            customer.save(update_fields=[\"sponsorship_pending\"])\n",
                "            self.write_to_audit_log(\n",
                "                event_type=AuditLogEventType.SPONSORSHIP_APPROVED, event_time=timezone_now()\n",
                "            )\n",
                "        # TODO: Use the emails in RemoteZulipServerBillingUser for this email.\n",
                "        send_email(\n",
                "            \"zerver/emails/sponsorship_approved_community_plan\",\n",
                "            to_emails=[self.remote_server.contact_email],\n",
                "            from_address=\"sales@zulip.com\",\n",
                "            context={\n",
                "                \"billing_entity\": self.billing_entity_display_name,\n",
                "                \"plans_link\": \"https://zulip.com/plans/#self-hosted\",\n",
                "                \"link_to_zulip\": \"https://zulip.com/help/linking-to-zulip-website\",\n",
                "            },\n",
                "        )\n",
                "        return f\"Sponsorship approved for {self.billing_entity_display_name}\"\n",
                "\n",
                "    @override\n",
                "    def process_downgrade(self, plan: CustomerPlan) -> None:\n",
                "        with transaction.atomic():\n",
                "            old_plan_type = self.remote_server.plan_type\n",
                "            new_plan_type = RemoteZulipServer.PLAN_TYPE_SELF_HOSTED\n",
                "            self.remote_server.plan_type = new_plan_type\n",
                "            self.remote_server.save(update_fields=[\"plan_type\"])\n",
                "            self.write_to_audit_log(\n",
                "                event_type=AuditLogEventType.BILLING_ENTITY_PLAN_TYPE_CHANGED,\n",
                "                event_time=timezone_now(),\n",
                "                extra_data={\"old_value\": old_plan_type, \"new_value\": new_plan_type},\n",
                "            )\n",
                "\n",
                "        plan.status = CustomerPlan.ENDED\n",
                "        plan.save(update_fields=[\"status\"])\n",
                "\n",
                "    @override\n",
                "    def is_sponsored(self) -> bool:\n",
                "        return self.remote_server.plan_type == self.remote_server.PLAN_TYPE_COMMUNITY\n",
                "\n",
                "    @override\n",
                "    def get_metadata_for_stripe_update_card(self) -> Dict[str, Any]:\n",
                "        return {\n",
                "            \"type\": \"card_update\",\n",
                "            # TODO: Maybe add some user identity metadata from the remote server identity\n",
                "            # \"user_id\": user.id,\n",
                "        }\n",
                "\n",
                "    @override\n",
                "    def get_upgrade_page_session_type_specific_context(\n",
                "        self,\n",
                "    ) -> UpgradePageSessionTypeSpecificContext:\n",
                "        return UpgradePageSessionTypeSpecificContext(\n",
                "            customer_name=self.remote_server.hostname,\n",
                "            email=self.get_email(),\n",
                "            is_demo_organization=False,\n",
                "            demo_organization_scheduled_deletion_date=None,\n",
                "            is_self_hosting=True,\n",
                "        )\n",
                "\n",
                "    @override\n",
                "    def get_type_of_plan_tier_change(\n",
                "        self, current_plan_tier: int, new_plan_tier: int\n",
                "    ) -> PlanTierChangeType:\n",
                "        valid_plan_tiers = [\n",
                "            CustomerPlan.TIER_SELF_HOSTED_LEGACY,\n",
                "            CustomerPlan.TIER_SELF_HOSTED_BUSINESS,\n",
                "            CustomerPlan.TIER_SELF_HOSTED_PLUS,\n",
                "        ]\n",
                "        if (\n",
                "            current_plan_tier not in valid_plan_tiers\n",
                "            or new_plan_tier not in valid_plan_tiers\n",
                "            or current_plan_tier == new_plan_tier\n",
                "        ):\n",
                "            return PlanTierChangeType.INVALID\n",
                "\n",
                "        if current_plan_tier == CustomerPlan.TIER_SELF_HOSTED_LEGACY and new_plan_tier in (\n",
                "            CustomerPlan.TIER_SELF_HOSTED_BUSINESS,\n",
                "            CustomerPlan.TIER_SELF_HOSTED_PLUS,\n",
                "        ):\n",
                "            return PlanTierChangeType.UPGRADE\n",
                "        elif (\n",
                "            current_plan_tier == CustomerPlan.TIER_SELF_HOSTED_BUSINESS\n",
                "            and new_plan_tier == CustomerPlan.TIER_SELF_HOSTED_PLUS\n",
                "        ):\n",
                "            return PlanTierChangeType.UPGRADE\n",
                "        elif (\n",
                "            current_plan_tier == CustomerPlan.TIER_SELF_HOSTED_BUSINESS\n",
                "            and new_plan_tier == CustomerPlan.TIER_SELF_HOSTED_LEGACY\n",
                "        ):\n",
                "            return PlanTierChangeType.DOWNGRADE\n",
                "        else:\n",
                "            assert current_plan_tier == CustomerPlan.TIER_SELF_HOSTED_PLUS\n",
                "            assert new_plan_tier == CustomerPlan.TIER_SELF_HOSTED_BUSINESS\n",
                "            return PlanTierChangeType.DOWNGRADE\n",
                "\n",
                "    @override\n",
                "    def has_billing_access(self) -> bool:\n",
                "        # We don't currently have a way to authenticate a remote\n",
                "        # session that isn't authorized for billing access.\n",
                "        return True\n",
                "\n",
                "    PAID_PLANS = [\n",
                "        RemoteZulipServer.PLAN_TYPE_BUSINESS,\n",
                "        RemoteZulipServer.PLAN_TYPE_ENTERPRISE,\n",
                "    ]\n",
                "\n",
                "    @override\n",
                "    def on_paid_plan(self) -> bool:\n",
                "        return self.remote_server.plan_type in self.PAID_PLANS\n",
                "\n",
                "    @override\n",
                "    def add_sponsorship_info_to_context(self, context: Dict[str, Any]) -> None:\n",
                "        context.update(\n",
                "            realm_org_type=self.remote_server.org_type,\n",
                "            sorted_org_types=sorted(\n",
                "                (\n",
                "                    [org_type_name, org_type]\n",
                "                    for (org_type_name, org_type) in Realm.ORG_TYPES.items()\n",
                "                    if not org_type.get(\"hidden\")\n",
                "                ),\n",
                "                key=sponsorship_org_type_key_helper,\n",
                "            ),\n",
                "        )\n",
                "        context[\"org_name\"] = self.remote_server.hostname\n",
                "\n",
                "    @override\n",
                "    def get_sponsorship_request_session_specific_context(\n",
                "        self,\n",
                "    ) -> SponsorshipRequestSessionSpecificContext:\n",
                "        return SponsorshipRequestSessionSpecificContext(\n",
                "            realm_user=None,\n",
                "            user_info=SponsorshipApplicantInfo(\n",
                "                # TODO: Figure out a better story here. We don't\n",
                "                # actually have a name or other details on the person\n",
                "                # doing this flow, but could ask for it in the login\n",
                "                # form if desired.\n",
                "                name=\"Remote server administrator\",\n",
                "                email=self.get_email(),\n",
                "                role=\"Remote server administrator\",\n",
                "            ),\n",
                "            # TODO: Check if this works on support page.\n",
                "            realm_string_id=self.remote_server.hostname,\n",
                "        )\n",
                "\n",
                "    @override\n",
                "    def save_org_type_from_request_sponsorship_session(self, org_type: int) -> None:\n",
                "        if self.remote_server.org_type != org_type:\n",
                "            self.remote_server.org_type = org_type\n",
                "            self.remote_server.save(update_fields=[\"org_type\"])\n",
                "\n",
                "    def add_server_to_legacy_plan(\n",
                "        self,\n",
                "        renewal_date: datetime,\n",
                "        end_date: datetime,\n",
                "    ) -> None:\n",
                "        # Set stripe_customer_id to None to avoid customer being charged without a payment method.\n",
                "        customer = Customer.objects.create(\n",
                "            remote_server=self.remote_server, stripe_customer_id=None\n",
                "        )\n",
                "\n",
                "        # Servers on legacy plan which are scheduled to be upgraded have 2 plans.\n",
                "        # This plan will be used to track the current status of SWITCH_PLAN_TIER_AT_PLAN_END\n",
                "        # and will not charge the customer. The other plan will be used to track the new plan\n",
                "        # customer will move to the end of this plan.\n",
                "        legacy_plan_anchor = renewal_date\n",
                "        legacy_plan_params = {\n",
                "            \"billing_cycle_anchor\": legacy_plan_anchor,\n",
                "            \"status\": CustomerPlan.ACTIVE,\n",
                "            \"tier\": CustomerPlan.TIER_SELF_HOSTED_LEGACY,\n",
                "            # End when the new plan starts.\n",
                "            \"end_date\": end_date,\n",
                "            # The primary mechanism for preventing charges under this\n",
                "            # plan is setting a null `next_invoice_date`, but setting\n",
                "            # a 0 price is useful defense in depth here.\n",
                "            \"next_invoice_date\": None,\n",
                "            \"price_per_license\": 0,\n",
                "            \"billing_schedule\": CustomerPlan.BILLING_SCHEDULE_ANNUAL,\n",
                "            \"automanage_licenses\": True,\n",
                "        }\n",
                "        legacy_plan = CustomerPlan.objects.create(\n",
                "            customer=customer,\n",
                "            **legacy_plan_params,\n",
                "        )\n",
                "\n",
                "        # Create a ledger entry for the legacy plan for tracking purposes.\n",
                "        billed_licenses = self.current_count_for_billed_licenses()\n",
                "        ledger_entry = LicenseLedger.objects.create(\n",
                "            plan=legacy_plan,\n",
                "            is_renewal=True,\n",
                "            event_time=legacy_plan_anchor,\n",
                "            licenses=billed_licenses,\n",
                "            licenses_at_next_renewal=billed_licenses,\n",
                "        )\n",
                "        legacy_plan.invoiced_through = ledger_entry\n",
                "        legacy_plan.save(update_fields=[\"invoiced_through\"])\n",
                "        self.write_to_audit_log(\n",
                "            event_type=AuditLogEventType.CUSTOMER_PLAN_CREATED,\n",
                "            event_time=legacy_plan_anchor,\n",
                "            extra_data=legacy_plan_params,\n",
                "        )\n",
                "\n",
                "\n",
                "def stripe_customer_has_credit_card_as_default_payment_method(\n",
                "    stripe_customer: stripe.Customer,\n",
                ") -> bool:\n",
                "    assert stripe_customer.invoice_settings is not None\n",
                "    if not stripe_customer.invoice_settings.default_payment_method:\n",
                "        return False\n",
                "    assert isinstance(stripe_customer.invoice_settings.default_payment_method, stripe.PaymentMethod)\n",
                "    return stripe_customer.invoice_settings.default_payment_method.type == \"card\"\n",
                "\n",
                "\n",
                "def customer_has_credit_card_as_default_payment_method(customer: Customer) -> bool:\n",
                "    if not customer.stripe_customer_id:\n",
                "        return False\n",
                "    stripe_customer = stripe_get_customer(customer.stripe_customer_id)\n",
                "    return stripe_customer_has_credit_card_as_default_payment_method(stripe_customer)\n",
                "\n",
                "\n",
                "def calculate_discounted_price_per_license(\n",
                "    original_price_per_license: int, discount: Decimal\n",
                ") -> int:\n",
                "    # There are no fractional cents in Stripe, so round down to nearest integer.\n",
                "    return int(float(original_price_per_license * (1 - discount / 100)) + 0.00001)\n",
                "\n",
                "\n",
                "def get_price_per_license(\n",
                "    tier: int, billing_schedule: int, discount: Optional[Decimal] = None\n",
                ") -> int:\n",
                "    price_map: Dict[int, Dict[str, int]] = {\n",
                "        CustomerPlan.TIER_CLOUD_STANDARD: {\"Annual\": 8000, \"Monthly\": 800},\n",
                "        CustomerPlan.TIER_CLOUD_PLUS: {\"Annual\": 16000, \"Monthly\": 1600},\n",
                "        # Placeholder self-hosted plan for development.\n",
                "        CustomerPlan.TIER_SELF_HOSTED_BUSINESS: {\"Annual\": 8000, \"Monthly\": 800},\n",
                "        # To help with processing discount request on support page.\n",
                "        CustomerPlan.TIER_SELF_HOSTED_LEGACY: {\"Annual\": 0, \"Monthly\": 0},\n",
                "    }\n",
                "\n",
                "    try:\n",
                "        price_per_license = price_map[tier][CustomerPlan.BILLING_SCHEDULES[billing_schedule]]\n",
                "    except KeyError:\n",
                "        if tier not in price_map:\n",
                "            raise InvalidTierError(tier)\n",
                "        else:  # nocoverage\n",
                "            raise InvalidBillingScheduleError(billing_schedule)\n",
                "\n",
                "    if discount is not None:\n",
                "        price_per_license = calculate_discounted_price_per_license(price_per_license, discount)\n",
                "    return price_per_license\n",
                "\n",
                "\n",
                "def compute_plan_parameters(\n",
                "    tier: int,\n",
                "    automanage_licenses: bool,\n",
                "    billing_schedule: int,\n",
                "    discount: Optional[Decimal],\n",
                "    free_trial: bool = False,\n",
                "    billing_cycle_anchor: Optional[datetime] = None,\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    is_self_hosted_billing: bool = False,\n"
                ],
                "parent_version_range": {
                    "start": 3602,
                    "end": 3602
                },
                "child_version_range": {
                    "start": 3608,
                    "end": 3609
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "compute_plan_parameters",
                        "signature": "def compute_plan_parameters(\n    tier: int,\n    automanage_licenses: bool,\n    billing_schedule: int,\n    discount: Optional[Decimal],\n    free_trial: bool = False,\n    billing_cycle_anchor: Optional[datetime] = None,\n)->Tuple[datetime, datetime, datetime, int]:",
                        "at_line": 3595
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: corporate/lib/stripe.py\nCode:\n             def compute_plan_parameters(\n    tier: int,\n    automanage_licenses: bool,\n    billing_schedule: int,\n    discount: Optional[Decimal],\n    free_trial: bool = False,\n    billing_cycle_anchor: Optional[datetime] = None,\n)->Tuple[datetime, datetime, datetime, int]:\n                 ...\n3599 3605        discount: Optional[Decimal],\n3600 3606        free_trial: bool = False,\n3601 3607        billing_cycle_anchor: Optional[datetime] = None,\n     3608  +     is_self_hosted_billing: bool = False,\n3602 3609    ) -> Tuple[datetime, datetime, datetime, int]:\n3603 3610        # Everything in Stripe is stored as timestamps with 1 second resolution,\n3604 3611        # so standardize on 1 second resolution.\n           ...\n",
                "file_path": "corporate/lib/stripe.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "bool",
                    "is_self_hosted_billing"
                ],
                "prefix": [
                    "    discount: Optional[Decimal],\n",
                    "    free_trial: bool = False,\n",
                    "    billing_cycle_anchor: Optional[datetime] = None,\n"
                ],
                "suffix": [
                    ") -> Tuple[datetime, datetime, datetime, int]:\n",
                    "    # Everything in Stripe is stored as timestamps with 1 second resolution,\n",
                    "    # so standardize on 1 second resolution.\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "is_self_hosted_billing",
                            "position": {
                                "start": {
                                    "line": 3608,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3608,
                                    "column": 26
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "is_self_hosted_billing",
                            "position": {
                                "start": {
                                    "line": 3608,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3608,
                                    "column": 26
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                ") -> Tuple[datetime, datetime, datetime, int]:\n",
                "    # Everything in Stripe is stored as timestamps with 1 second resolution,\n",
                "    # so standardize on 1 second resolution.\n",
                "    # TODO talk about leap seconds?\n",
                "    if billing_cycle_anchor is None:\n",
                "        billing_cycle_anchor = timezone_now().replace(microsecond=0)\n",
                "\n",
                "    if billing_schedule == CustomerPlan.BILLING_SCHEDULE_ANNUAL:\n",
                "        period_end = add_months(billing_cycle_anchor, 12)\n",
                "    elif billing_schedule == CustomerPlan.BILLING_SCHEDULE_MONTHLY:\n",
                "        period_end = add_months(billing_cycle_anchor, 1)\n",
                "    else:  # nocoverage\n",
                "        raise InvalidBillingScheduleError(billing_schedule)\n",
                "\n",
                "    price_per_license = get_price_per_license(tier, billing_schedule, discount)\n",
                "\n",
                "    next_invoice_date = period_end\n",
                "    if automanage_licenses:\n",
                "        next_invoice_date = add_months(billing_cycle_anchor, 1)\n",
                "    if free_trial:\n",
                "        period_end = billing_cycle_anchor + timedelta(\n"
            ],
            {
                "type": "replace",
                "before": [
                    "            days=assert_is_not_none(get_free_trial_days())\n"
                ],
                "after": [
                    "            days=assert_is_not_none(get_free_trial_days(is_self_hosted_billing))\n"
                ],
                "parent_version_range": {
                    "start": 3623,
                    "end": 3624
                },
                "child_version_range": {
                    "start": 3630,
                    "end": 3631
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if free_trial:",
                        "start_line": 3621,
                        "end_line": 3625
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "compute_plan_parameters",
                        "signature": "def compute_plan_parameters(\n    tier: int,\n    automanage_licenses: bool,\n    billing_schedule: int,\n    discount: Optional[Decimal],\n    free_trial: bool = False,\n    billing_cycle_anchor: Optional[datetime] = None,\n)->Tuple[datetime, datetime, datetime, int]:",
                        "at_line": 3595
                    },
                    {
                        "type": "call",
                        "name": "timedelta",
                        "signature": "timedelta(\n            days=assert_is_not_none(get_free_trial_days())\n        )",
                        "at_line": 3622,
                        "argument": "days=..."
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: corporate/lib/stripe.py\nCode:\n             def compute_plan_parameters(\n    tier: int,\n    automanage_licenses: bool,\n    billing_schedule: int,\n    discount: Optional[Decimal],\n    free_trial: bool = False,\n    billing_cycle_anchor: Optional[datetime] = None,\n)->Tuple[datetime, datetime, datetime, int]:\n                 ...\n3620 3627            next_invoice_date = add_months(billing_cycle_anchor, 1)\n3621 3628        if free_trial:\n3622 3629            period_end = billing_cycle_anchor + timedelta(\n3623       -             days=assert_is_not_none(get_free_trial_days())\n     3630  +             days=assert_is_not_none(get_free_trial_days(is_self_hosted_billing))\n3624 3631            )\n3625 3632            next_invoice_date = period_end\n3626 3633        return billing_cycle_anchor, next_invoice_date, period_end, price_per_license\n           ...\n",
                "file_path": "corporate/lib/stripe.py",
                "identifiers_before": [
                    "assert_is_not_none",
                    "days",
                    "get_free_trial_days"
                ],
                "identifiers_after": [
                    "assert_is_not_none",
                    "days",
                    "get_free_trial_days",
                    "is_self_hosted_billing"
                ],
                "prefix": [
                    "        next_invoice_date = add_months(billing_cycle_anchor, 1)\n",
                    "    if free_trial:\n",
                    "        period_end = billing_cycle_anchor + timedelta(\n"
                ],
                "suffix": [
                    "        )\n",
                    "        next_invoice_date = period_end\n",
                    "    return billing_cycle_anchor, next_invoice_date, period_end, price_per_license\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3623,
                                    "column": 36
                                },
                                "end": {
                                    "line": 3623,
                                    "column": 55
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3630,
                                    "column": 36
                                },
                                "end": {
                                    "line": 3630,
                                    "column": 55
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "is_self_hosted_billing",
                            "position": {
                                "start": {
                                    "line": 3630,
                                    "column": 56
                                },
                                "end": {
                                    "line": 3630,
                                    "column": 78
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        )\n",
                "        next_invoice_date = period_end\n",
                "    return billing_cycle_anchor, next_invoice_date, period_end, price_per_license\n",
                "\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "def get_free_trial_days() -> Optional[int]:\n"
                ],
                "after": [
                    "def get_free_trial_days(is_self_hosted_billing: bool = False) -> Optional[int]:\n",
                    "    if is_self_hosted_billing:\n",
                    "        return settings.SELF_HOSTING_FREE_TRIAL_DAYS\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 3629,
                    "end": 3630
                },
                "child_version_range": {
                    "start": 3636,
                    "end": 3640
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_free_trial_days",
                        "signature": "def get_free_trial_days()->Optional[int]:",
                        "at_line": 3629
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: corporate/lib/stripe.py\nCode:\n3626 3633        return billing_cycle_anchor, next_invoice_date, period_end, price_per_license\n3627 3634    \n3628 3635    \n3629       - def get_free_trial_days() -> Optional[int]:\n     3636  + def get_free_trial_days(is_self_hosted_billing: bool = False) -> Optional[int]:\n     3637  +     if is_self_hosted_billing:\n     3638  +         return settings.SELF_HOSTING_FREE_TRIAL_DAYS\n     3639  + \n3630 3640        return settings.CLOUD_FREE_TRIAL_DAYS\n3631 3641    \n3632 3642    \n           ...\n",
                "file_path": "corporate/lib/stripe.py",
                "identifiers_before": [
                    "Optional",
                    "get_free_trial_days",
                    "int"
                ],
                "identifiers_after": [
                    "Optional",
                    "SELF_HOSTING_FREE_TRIAL_DAYS",
                    "bool",
                    "get_free_trial_days",
                    "int",
                    "is_self_hosted_billing",
                    "settings"
                ],
                "prefix": [
                    "    return billing_cycle_anchor, next_invoice_date, period_end, price_per_license\n",
                    "\n",
                    "\n"
                ],
                "suffix": [
                    "    return settings.CLOUD_FREE_TRIAL_DAYS\n",
                    "\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3629,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3629,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3629,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3629,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3629,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3629,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3629,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3629,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3629,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3629,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3636,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3636,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3636,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3636,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3636,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3636,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3636,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3636,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 3636,
                                    "column": 4
                                },
                                "end": {
                                    "line": 3636,
                                    "column": 23
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/lib/stripe.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "    return settings.CLOUD_FREE_TRIAL_DAYS\n",
                "\n",
                "\n",
                "def is_free_trial_offer_enabled() -> bool:\n",
                "    return settings.CLOUD_FREE_TRIAL_DAYS not in (None, 0)\n",
                "\n",
                "\n",
                "def ensure_customer_does_not_have_active_plan(customer: Customer) -> None:\n",
                "    if get_current_plan_by_customer(customer) is not None:\n",
                "        # Unlikely race condition from two people upgrading (clicking \"Make payment\")\n",
                "        # at exactly the same time. Doesn't fully resolve the race condition, but having\n",
                "        # a check here reduces the likelihood.\n",
                "        billing_logger.warning(\n",
                "            \"Upgrade of %s failed because of existing active plan.\",\n",
                "            str(customer),\n",
                "        )\n",
                "        raise UpgradeWithExistingPlanError\n",
                "\n",
                "\n",
                "@transaction.atomic\n",
                "def do_change_remote_server_plan_type(remote_server: RemoteZulipServer, plan_type: int) -> None:\n",
                "    old_value = remote_server.plan_type\n",
                "    remote_server.plan_type = plan_type\n",
                "    remote_server.save(update_fields=[\"plan_type\"])\n",
                "    RemoteZulipServerAuditLog.objects.create(\n",
                "        event_type=RealmAuditLog.REMOTE_SERVER_PLAN_TYPE_CHANGED,\n",
                "        server=remote_server,\n",
                "        event_time=timezone_now(),\n",
                "        extra_data={\"old_value\": old_value, \"new_value\": plan_type},\n",
                "    )\n",
                "\n",
                "\n",
                "@transaction.atomic\n",
                "def do_deactivate_remote_server(remote_server: RemoteZulipServer) -> None:\n",
                "    if remote_server.deactivated:\n",
                "        billing_logger.warning(\n",
                "            \"Cannot deactivate remote server with ID %d, server has already been deactivated.\",\n",
                "            remote_server.id,\n",
                "        )\n",
                "        return\n",
                "\n",
                "    remote_server.deactivated = True\n",
                "    remote_server.save(update_fields=[\"deactivated\"])\n",
                "    RemoteZulipServerAuditLog.objects.create(\n",
                "        event_type=RealmAuditLog.REMOTE_SERVER_DEACTIVATED,\n",
                "        server=remote_server,\n",
                "        event_time=timezone_now(),\n",
                "    )\n",
                "\n",
                "\n",
                "def get_plan_renewal_or_end_date(plan: CustomerPlan, event_time: datetime) -> datetime:\n",
                "    billing_period_end = start_of_next_billing_cycle(plan, event_time)\n",
                "\n",
                "    if plan.end_date is not None and plan.end_date < billing_period_end:\n",
                "        return plan.end_date\n",
                "    return billing_period_end\n",
                "\n",
                "\n",
                "def invoice_plans_as_needed(event_time: Optional[datetime] = None) -> None:\n",
                "    if event_time is None:  # nocoverage\n",
                "        event_time = timezone_now()\n",
                "    # TODO: Add RemoteRealmBillingSession and RemoteServerBillingSession cases.\n",
                "    for plan in CustomerPlan.objects.filter(next_invoice_date__lte=event_time):\n",
                "        if plan.customer.realm is not None:\n",
                "            RealmBillingSession(realm=plan.customer.realm).invoice_plan(plan, event_time)\n",
                "        # TODO: Assert that we never invoice legacy plans.\n",
                "\n",
                "\n",
                "def is_realm_on_free_trial(realm: Realm) -> bool:\n",
                "    plan = get_current_plan_by_realm(realm)\n",
                "    return plan is not None and plan.is_free_trial()\n",
                "\n",
                "\n",
                "def do_change_plan_status(plan: CustomerPlan, status: int) -> None:\n",
                "    plan.status = status\n",
                "    plan.save(update_fields=[\"status\"])\n",
                "    billing_logger.info(\n",
                "        \"Change plan status: Customer.id: %s, CustomerPlan.id: %s, status: %s\",\n",
                "        plan.customer.id,\n",
                "        plan.id,\n",
                "        status,\n",
                "    )\n",
                "\n",
                "\n",
                "def get_all_invoices_for_customer(customer: Customer) -> Generator[stripe.Invoice, None, None]:\n",
                "    if customer.stripe_customer_id is None:\n",
                "        return\n",
                "\n",
                "    invoices = stripe.Invoice.list(customer=customer.stripe_customer_id, limit=100)\n",
                "    while len(invoices):\n",
                "        for invoice in invoices:\n",
                "            yield invoice\n",
                "            last_invoice = invoice\n",
                "        invoices = stripe.Invoice.list(\n",
                "            customer=customer.stripe_customer_id, starting_after=last_invoice, limit=100\n",
                "        )\n",
                "\n",
                "\n",
                "def customer_has_last_n_invoices_open(customer: Customer, n: int) -> bool:\n",
                "    if customer.stripe_customer_id is None:  # nocoverage\n",
                "        return False\n",
                "\n",
                "    open_invoice_count = 0\n",
                "    for invoice in stripe.Invoice.list(customer=customer.stripe_customer_id, limit=n):\n",
                "        if invoice.status == \"open\":\n",
                "            open_invoice_count += 1\n",
                "    return open_invoice_count == n\n",
                "\n",
                "\n",
                "def downgrade_small_realms_behind_on_payments_as_needed() -> None:\n",
                "    customers = Customer.objects.all().exclude(stripe_customer_id=None).exclude(realm=None)\n",
                "    for customer in customers:\n",
                "        realm = customer.realm\n",
                "        assert realm is not None\n",
                "\n",
                "        # For larger realms, we generally want to talk to the customer\n",
                "        # before downgrading or cancelling invoices; so this logic only applies with 5.\n",
                "        if get_latest_seat_count(realm) >= 5:\n",
                "            continue\n",
                "\n",
                "        if get_current_plan_by_customer(customer) is not None:\n",
                "            # Only customers with last 2 invoices open should be downgraded.\n",
                "            if not customer_has_last_n_invoices_open(customer, 2):\n",
                "                continue\n",
                "\n",
                "            # We've now decided to downgrade this customer and void all invoices, and the below will execute this.\n",
                "            billing_session = RealmBillingSession(user=None, realm=realm)\n",
                "            billing_session.downgrade_now_without_creating_additional_invoices()\n",
                "            billing_session.void_all_open_invoices()\n",
                "            context: Dict[str, Union[str, Realm]] = {\n",
                "                \"upgrade_url\": f\"{realm.uri}{reverse('upgrade_page')}\",\n",
                "                \"realm\": realm,\n",
                "            }\n",
                "            send_email_to_billing_admins_and_realm_owners(\n",
                "                \"zerver/emails/realm_auto_downgraded\",\n",
                "                realm,\n",
                "                from_name=FromAddress.security_email_from_name(language=realm.default_language),\n",
                "                from_address=FromAddress.tokenized_no_reply_address(),\n",
                "                language=realm.default_language,\n",
                "                context=context,\n",
                "            )\n",
                "        else:\n",
                "            if customer_has_last_n_invoices_open(customer, 1):\n",
                "                # If a small realm, without an active plan, has\n",
                "                # the last invoice open, void the open invoices.\n",
                "                billing_session = RealmBillingSession(user=None, realm=realm)\n",
                "                billing_session.void_all_open_invoices()"
            ]
        ],
        "corporate/views/portico.py": [
            [
                "from dataclasses import asdict, dataclass\n",
                "from typing import Optional\n",
                "from urllib.parse import urlencode\n",
                "\n",
                "import orjson\n",
                "from django.conf import settings\n",
                "from django.contrib.auth.views import redirect_to_login\n",
                "from django.http import HttpRequest, HttpResponse, HttpResponseRedirect\n",
                "from django.template.response import TemplateResponse\n",
                "from django.urls import reverse\n",
                "\n",
                "from corporate.lib.decorator import (\n",
                "    authenticated_remote_realm_management_endpoint,\n",
                "    authenticated_remote_server_management_endpoint,\n",
                ")\n",
                "from corporate.lib.stripe import (\n",
                "    RemoteRealmBillingSession,\n",
                "    RemoteServerBillingSession,\n",
                "    get_free_trial_days,\n",
                ")\n",
                "from corporate.models import CustomerPlan, get_current_plan_by_customer, get_customer_by_realm\n",
                "from zerver.context_processors import get_realm_from_request, latest_info_context\n",
                "from zerver.decorator import add_google_analytics\n",
                "from zerver.lib.github import (\n",
                "    InvalidPlatformError,\n",
                "    get_latest_github_release_download_link_for_platform,\n",
                ")\n",
                "from zerver.lib.realm_description import get_realm_text_description\n",
                "from zerver.lib.realm_icon import get_realm_icon_url\n",
                "from zerver.lib.subdomains import is_subdomain_root_or_alias\n",
                "from zerver.models import Realm\n",
                "\n",
                "\n",
                "@add_google_analytics\n",
                "def apps_view(request: HttpRequest, platform: Optional[str] = None) -> HttpResponse:\n",
                "    if not settings.CORPORATE_ENABLED:\n",
                "        # This seems impossible (CORPORATE_ENABLED set to false when\n",
                "        # rendering a \"corporate\" view) -- but we add it to make\n",
                "        # testing possible.  Tests default to running with the\n",
                "        # \"corporate\" app installed, and unsetting that is difficult,\n",
                "        # as one cannot easily reload the URL resolution -- so we add\n",
                "        # a redirect here, equivalent to the one zerver would have\n",
                "        # installed when \"corporate\" is not enabled, to make the\n",
                "        # behaviour testable with CORPORATE_ENABLED set to false.\n",
                "        return HttpResponseRedirect(\"https://zulip.com/apps/\", status=301)\n",
                "    return TemplateResponse(\n",
                "        request,\n",
                "        \"corporate/apps.html\",\n",
                "    )\n",
                "\n",
                "\n",
                "def app_download_link_redirect(request: HttpRequest, platform: str) -> HttpResponse:\n",
                "    try:\n",
                "        download_link = get_latest_github_release_download_link_for_platform(platform)\n",
                "        return HttpResponseRedirect(download_link, status=302)\n",
                "    except InvalidPlatformError:\n",
                "        return TemplateResponse(request, \"404.html\", status=404)\n",
                "\n",
                "\n",
                "def is_customer_on_free_trial(customer_plan: CustomerPlan) -> bool:\n",
                "    return customer_plan.status in (\n",
                "        CustomerPlan.FREE_TRIAL,\n",
                "        CustomerPlan.DOWNGRADE_AT_END_OF_FREE_TRIAL,\n",
                "    )\n",
                "\n",
                "\n",
                "@dataclass\n",
                "class PlansPageContext:\n",
                "    sponsorship_url: str\n",
                "    free_trial_days: Optional[int]\n",
                "    on_free_trial: bool = False\n",
                "    sponsorship_pending: bool = False\n",
                "    is_sponsored: bool = False\n",
                "\n",
                "    is_cloud_realm: bool = False\n",
                "    is_self_hosted_realm: bool = False\n",
                "\n",
                "    is_new_customer: bool = False\n",
                "    on_free_tier: bool = False\n",
                "    customer_plan: Optional[CustomerPlan] = None\n",
                "    is_legacy_server_with_scheduled_upgrade: bool = False\n",
                "    legacy_server_new_plan: Optional[CustomerPlan] = None\n",
                "\n",
                "    billing_base_url: str = \"\"\n",
                "\n",
                "\n",
                "@add_google_analytics\n",
                "def plans_view(request: HttpRequest) -> HttpResponse:\n",
                "    realm = get_realm_from_request(request)\n",
                "    context = PlansPageContext(\n",
                "        is_cloud_realm=True,\n",
                "        sponsorship_url=reverse(\"sponsorship_request\"),\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        free_trial_days=get_free_trial_days(),\n"
                ],
                "after": [
                    "        free_trial_days=get_free_trial_days(False),\n"
                ],
                "parent_version_range": {
                    "start": 92,
                    "end": 93
                },
                "child_version_range": {
                    "start": 92,
                    "end": 93
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "plans_view",
                        "signature": "def plans_view(request: HttpRequest)->HttpResponse:",
                        "at_line": 87
                    },
                    {
                        "type": "call",
                        "name": "PlansPageContext",
                        "signature": "PlansPageContext(\n        is_cloud_realm=True,\n        sponsorship_url=reverse(\"sponsorship_request\"),\n        free_trial_days=get_free_trial_days(),\n        is_sponsored=realm is not None and realm.plan_type == Realm.PLAN_TYPE_STANDARD_FREE,\n    )",
                        "at_line": 89,
                        "argument": "free_trial_days=..."
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: corporate/views/portico.py\nCode:\n         def plans_view(request: HttpRequest)->HttpResponse:\n             ...\n89 89        context = PlansPageContext(\n90 90            is_cloud_realm=True,\n91 91            sponsorship_url=reverse(\"sponsorship_request\"),\n92     -         free_trial_days=get_free_trial_days(),\n   92  +         free_trial_days=get_free_trial_days(False),\n93 93            is_sponsored=realm is not None and realm.plan_type == Realm.PLAN_TYPE_STANDARD_FREE,\n94 94        )\n95 95        if is_subdomain_root_or_alias(request):\n       ...\n",
                "file_path": "corporate/views/portico.py",
                "identifiers_before": [
                    "free_trial_days",
                    "get_free_trial_days"
                ],
                "identifiers_after": [
                    "free_trial_days",
                    "get_free_trial_days"
                ],
                "prefix": [
                    "    context = PlansPageContext(\n",
                    "        is_cloud_realm=True,\n",
                    "        sponsorship_url=reverse(\"sponsorship_request\"),\n"
                ],
                "suffix": [
                    "        is_sponsored=realm is not None and realm.plan_type == Realm.PLAN_TYPE_STANDARD_FREE,\n",
                    "    )\n",
                    "    if is_subdomain_root_or_alias(request):\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 92,
                                    "column": 24
                                },
                                "end": {
                                    "line": 92,
                                    "column": 43
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/views/portico.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 92,
                                    "column": 24
                                },
                                "end": {
                                    "line": 92,
                                    "column": 43
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/views/portico.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    6,
                    7
                ]
            },
            [
                "        is_sponsored=realm is not None and realm.plan_type == Realm.PLAN_TYPE_STANDARD_FREE,\n",
                "    )\n",
                "    if is_subdomain_root_or_alias(request):\n",
                "        # If we're on the root domain, we make this link first ask you which organization.\n",
                "        context.sponsorship_url = f\"/accounts/go/?{urlencode({'next': context.sponsorship_url})}\"\n",
                "\n",
                "    if realm is not None:\n",
                "        if realm.plan_type == Realm.PLAN_TYPE_SELF_HOSTED and settings.PRODUCTION:\n",
                "            return HttpResponseRedirect(\"https://zulip.com/plans/\")\n",
                "        if not request.user.is_authenticated:\n",
                "            return redirect_to_login(next=\"/plans/\")\n",
                "        if request.user.is_guest:\n",
                "            return TemplateResponse(request, \"404.html\", status=404)\n",
                "\n",
                "        customer = get_customer_by_realm(realm)\n",
                "        context.on_free_tier = customer is None and not context.is_sponsored\n",
                "        if customer is not None:\n",
                "            context.sponsorship_pending = customer.sponsorship_pending\n",
                "            context.customer_plan = get_current_plan_by_customer(customer)\n",
                "            if context.customer_plan is None:\n",
                "                # Cloud realms on free tier don't have active customer plan unless they are sponsored.\n",
                "                context.on_free_tier = not context.is_sponsored\n",
                "            else:\n",
                "                context.on_free_trial = is_customer_on_free_trial(context.customer_plan)\n",
                "\n",
                "    context.is_new_customer = (\n",
                "        not context.on_free_tier and context.customer_plan is None and not context.is_sponsored\n",
                "    )\n",
                "    return TemplateResponse(\n",
                "        request,\n",
                "        \"corporate/plans.html\",\n",
                "        context=asdict(context),\n",
                "    )\n",
                "\n",
                "\n",
                "@add_google_analytics\n",
                "@authenticated_remote_realm_management_endpoint\n",
                "def remote_realm_plans_page(\n",
                "    request: HttpRequest, billing_session: RemoteRealmBillingSession\n",
                ") -> HttpResponse:  # nocoverage\n",
                "    customer = billing_session.get_customer()\n",
                "    context = PlansPageContext(\n",
                "        is_self_hosted_realm=True,\n",
                "        sponsorship_url=reverse(\n",
                "            \"remote_realm_sponsorship_page\", args=(billing_session.remote_realm.uuid,)\n",
                "        ),\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        free_trial_days=get_free_trial_days(),\n"
                ],
                "after": [
                    "        free_trial_days=get_free_trial_days(True),\n"
                ],
                "parent_version_range": {
                    "start": 139,
                    "end": 140
                },
                "child_version_range": {
                    "start": 139,
                    "end": 140
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "remote_realm_plans_page",
                        "signature": "def remote_realm_plans_page(\n    request: HttpRequest, billing_session: RemoteRealmBillingSession\n)->HttpResponse:",
                        "at_line": 130
                    },
                    {
                        "type": "call",
                        "name": "PlansPageContext",
                        "signature": "PlansPageContext(\n        is_self_hosted_realm=True,\n        sponsorship_url=reverse(\n            \"remote_realm_sponsorship_page\", args=(billing_session.remote_realm.uuid,)\n        ),\n        free_trial_days=get_free_trial_days(),\n        billing_base_url=billing_session.billing_base_url,\n        is_sponsored=billing_session.is_sponsored(),\n    )",
                        "at_line": 134,
                        "argument": "free_trial_days=..."
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: corporate/views/portico.py\nCode:\n           def remote_realm_plans_page(\n    request: HttpRequest, billing_session: RemoteRealmBillingSession\n)->HttpResponse:\n               ...\n               PlansPageContext(\n        is_self_hosted_realm=True,\n        sponsorship_url=reverse(\n            \"remote_realm_sponsorship_page\", args=(billing_session.remote_realm.uuid,)\n        ),\n        free_trial_days=get_free_trial_days(),\n        billing_base_url=billing_session.billing_base_url,\n        is_sponsored=billing_session.is_sponsored(),\n    )\n                   ...\n136 136            sponsorship_url=reverse(\n137 137                \"remote_realm_sponsorship_page\", args=(billing_session.remote_realm.uuid,)\n138 138            ),\n139      -         free_trial_days=get_free_trial_days(),\n    139  +         free_trial_days=get_free_trial_days(True),\n140 140            billing_base_url=billing_session.billing_base_url,\n141 141            is_sponsored=billing_session.is_sponsored(),\n142 142        )\n         ...\n",
                "file_path": "corporate/views/portico.py",
                "identifiers_before": [
                    "free_trial_days",
                    "get_free_trial_days"
                ],
                "identifiers_after": [
                    "free_trial_days",
                    "get_free_trial_days"
                ],
                "prefix": [
                    "        sponsorship_url=reverse(\n",
                    "            \"remote_realm_sponsorship_page\", args=(billing_session.remote_realm.uuid,)\n",
                    "        ),\n"
                ],
                "suffix": [
                    "        billing_base_url=billing_session.billing_base_url,\n",
                    "        is_sponsored=billing_session.is_sponsored(),\n",
                    "    )\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 139,
                                    "column": 24
                                },
                                "end": {
                                    "line": 139,
                                    "column": 43
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/views/portico.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 139,
                                    "column": 24
                                },
                                "end": {
                                    "line": 139,
                                    "column": 43
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/views/portico.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    5,
                    7
                ]
            },
            [
                "        billing_base_url=billing_session.billing_base_url,\n",
                "        is_sponsored=billing_session.is_sponsored(),\n",
                "    )\n",
                "\n",
                "    context.on_free_tier = customer is None and not context.is_sponsored\n",
                "    if customer is not None:\n",
                "        context.sponsorship_pending = customer.sponsorship_pending\n",
                "        context.customer_plan = get_current_plan_by_customer(customer)\n",
                "        if context.customer_plan is None:\n",
                "            context.on_free_tier = not context.is_sponsored\n",
                "        else:\n",
                "            context.on_free_trial = is_customer_on_free_trial(context.customer_plan)\n",
                "\n",
                "    context.is_new_customer = (\n",
                "        not context.on_free_tier and context.customer_plan is None and not context.is_sponsored\n",
                "    )\n",
                "    return TemplateResponse(\n",
                "        request,\n",
                "        \"corporate/plans.html\",\n",
                "        context=asdict(context),\n",
                "    )\n",
                "\n",
                "\n",
                "@add_google_analytics\n",
                "@authenticated_remote_server_management_endpoint\n",
                "def remote_server_plans_page(\n",
                "    request: HttpRequest, billing_session: RemoteServerBillingSession\n",
                ") -> HttpResponse:  # nocoverage\n",
                "    customer = billing_session.get_customer()\n",
                "    context = PlansPageContext(\n",
                "        is_self_hosted_realm=True,\n",
                "        sponsorship_url=reverse(\n",
                "            \"remote_server_sponsorship_page\", args=(billing_session.remote_server.uuid,)\n",
                "        ),\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        free_trial_days=get_free_trial_days(),\n"
                ],
                "after": [
                    "        free_trial_days=get_free_trial_days(True),\n"
                ],
                "parent_version_range": {
                    "start": 174,
                    "end": 175
                },
                "child_version_range": {
                    "start": 174,
                    "end": 175
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "remote_server_plans_page",
                        "signature": "def remote_server_plans_page(\n    request: HttpRequest, billing_session: RemoteServerBillingSession\n)->HttpResponse:",
                        "at_line": 165
                    },
                    {
                        "type": "call",
                        "name": "PlansPageContext",
                        "signature": "PlansPageContext(\n        is_self_hosted_realm=True,\n        sponsorship_url=reverse(\n            \"remote_server_sponsorship_page\", args=(billing_session.remote_server.uuid,)\n        ),\n        free_trial_days=get_free_trial_days(),\n        billing_base_url=billing_session.billing_base_url,\n        is_sponsored=billing_session.is_sponsored(),\n    )",
                        "at_line": 169,
                        "argument": "free_trial_days=..."
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: corporate/views/portico.py\nCode:\n           def remote_server_plans_page(\n    request: HttpRequest, billing_session: RemoteServerBillingSession\n)->HttpResponse:\n               ...\n               PlansPageContext(\n        is_self_hosted_realm=True,\n        sponsorship_url=reverse(\n            \"remote_server_sponsorship_page\", args=(billing_session.remote_server.uuid,)\n        ),\n        free_trial_days=get_free_trial_days(),\n        billing_base_url=billing_session.billing_base_url,\n        is_sponsored=billing_session.is_sponsored(),\n    )\n                   ...\n171 171            sponsorship_url=reverse(\n172 172                \"remote_server_sponsorship_page\", args=(billing_session.remote_server.uuid,)\n173 173            ),\n174      -         free_trial_days=get_free_trial_days(),\n    174  +         free_trial_days=get_free_trial_days(True),\n175 175            billing_base_url=billing_session.billing_base_url,\n176 176            is_sponsored=billing_session.is_sponsored(),\n177 177        )\n         ...\n",
                "file_path": "corporate/views/portico.py",
                "identifiers_before": [
                    "free_trial_days",
                    "get_free_trial_days"
                ],
                "identifiers_after": [
                    "free_trial_days",
                    "get_free_trial_days"
                ],
                "prefix": [
                    "        sponsorship_url=reverse(\n",
                    "            \"remote_server_sponsorship_page\", args=(billing_session.remote_server.uuid,)\n",
                    "        ),\n"
                ],
                "suffix": [
                    "        billing_base_url=billing_session.billing_base_url,\n",
                    "        is_sponsored=billing_session.is_sponsored(),\n",
                    "    )\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 174,
                                    "column": 24
                                },
                                "end": {
                                    "line": 174,
                                    "column": 43
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/views/portico.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "get_free_trial_days",
                            "position": {
                                "start": {
                                    "line": 174,
                                    "column": 24
                                },
                                "end": {
                                    "line": 174,
                                    "column": 43
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/corporate/views/portico.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    5,
                    6
                ]
            },
            [
                "        billing_base_url=billing_session.billing_base_url,\n",
                "        is_sponsored=billing_session.is_sponsored(),\n",
                "    )\n",
                "\n",
                "    context.on_free_tier = customer is None and not context.is_sponsored\n",
                "    if customer is not None:\n",
                "        context.sponsorship_pending = customer.sponsorship_pending\n",
                "        context.customer_plan = get_current_plan_by_customer(customer)\n",
                "        if context.customer_plan is None:\n",
                "            context.on_free_tier = not context.is_sponsored\n",
                "        else:\n",
                "            context.on_free_tier = context.customer_plan.tier in (\n",
                "                CustomerPlan.TIER_SELF_HOSTED_LEGACY,\n",
                "                CustomerPlan.TIER_SELF_HOSTED_BASE,\n",
                "            )\n",
                "            context.on_free_trial = is_customer_on_free_trial(context.customer_plan)\n",
                "            context.is_legacy_server_with_scheduled_upgrade = (\n",
                "                context.customer_plan.status == CustomerPlan.SWITCH_PLAN_TIER_AT_PLAN_END\n",
                "            )\n",
                "            if context.is_legacy_server_with_scheduled_upgrade:\n",
                "                assert context.customer_plan.end_date is not None\n",
                "                context.legacy_server_new_plan = CustomerPlan.objects.get(\n",
                "                    customer=customer,\n",
                "                    billing_cycle_anchor=context.customer_plan.end_date,\n",
                "                    status=CustomerPlan.NEVER_STARTED,\n",
                "                )\n",
                "\n",
                "    context.is_new_customer = (\n",
                "        not context.on_free_tier and context.customer_plan is None and not context.is_sponsored\n",
                "    )\n",
                "    return TemplateResponse(\n",
                "        request,\n",
                "        \"corporate/plans.html\",\n",
                "        context=asdict(context),\n",
                "    )\n",
                "\n",
                "\n",
                "@add_google_analytics\n",
                "def team_view(request: HttpRequest) -> HttpResponse:\n",
                "    if not settings.ZILENCER_ENABLED:\n",
                "        return HttpResponseRedirect(\"https://zulip.com/team/\", status=301)\n",
                "\n",
                "    try:\n",
                "        with open(settings.CONTRIBUTOR_DATA_FILE_PATH, \"rb\") as f:\n",
                "            data = orjson.loads(f.read())\n",
                "    except FileNotFoundError:\n",
                "        data = {\"contributors\": [], \"date\": \"Never ran.\"}\n",
                "\n",
                "    return TemplateResponse(\n",
                "        request,\n",
                "        \"corporate/team.html\",\n",
                "        context={\n",
                "            \"page_params\": {\n",
                "                \"contributors\": data[\"contributors\"],\n",
                "            },\n",
                "            \"date\": data[\"date\"],\n",
                "        },\n",
                "    )\n",
                "\n",
                "\n",
                "@add_google_analytics\n",
                "def landing_view(request: HttpRequest, template_name: str) -> HttpResponse:\n",
                "    return TemplateResponse(request, template_name, latest_info_context())\n",
                "\n",
                "\n",
                "@add_google_analytics\n",
                "def hello_view(request: HttpRequest) -> HttpResponse:\n",
                "    return TemplateResponse(request, \"corporate/hello.html\", latest_info_context())\n",
                "\n",
                "\n",
                "@add_google_analytics\n",
                "def communities_view(request: HttpRequest) -> HttpResponse:\n",
                "    eligible_realms = []\n",
                "    unique_org_type_ids = set()\n",
                "    want_to_be_advertised_realms = (\n",
                "        Realm.objects.filter(\n",
                "            want_advertise_in_communities_directory=True,\n",
                "        )\n",
                "        .exclude(\n",
                "            # Filter out realms who haven't changed their description from the default.\n",
                "            description=\"\",\n",
                "        )\n",
                "        .order_by(\"name\")\n",
                "    )\n",
                "    for realm in want_to_be_advertised_realms:\n",
                "        open_to_public = not realm.invite_required and not realm.emails_restricted_to_domains\n",
                "        if realm.allow_web_public_streams_access() or open_to_public:\n",
                "            [org_type] = (\n",
                "                org_type\n",
                "                for org_type in Realm.ORG_TYPES\n",
                "                if Realm.ORG_TYPES[org_type][\"id\"] == realm.org_type\n",
                "            )\n",
                "            eligible_realms.append(\n",
                "                {\n",
                "                    \"id\": realm.id,\n",
                "                    \"name\": realm.name,\n",
                "                    \"realm_url\": realm.uri,\n",
                "                    \"logo_url\": get_realm_icon_url(realm),\n",
                "                    \"description\": get_realm_text_description(realm),\n",
                "                    \"org_type_key\": org_type,\n",
                "                }\n",
                "            )\n",
                "            unique_org_type_ids.add(realm.org_type)\n",
                "\n",
                "    # Custom list of org filters to show.\n",
                "    CATEGORIES_TO_OFFER = [\n",
                "        \"opensource\",\n",
                "        \"research\",\n",
                "        \"community\",\n",
                "    ]\n",
                "\n",
                "    # Remove org_types for which there are no open organizations.\n",
                "    org_types = dict()\n",
                "    for org_type in CATEGORIES_TO_OFFER:\n",
                "        if Realm.ORG_TYPES[org_type][\"id\"] in unique_org_type_ids:\n",
                "            org_types[org_type] = Realm.ORG_TYPES[org_type]\n",
                "\n",
                "    # This code is not required right bot could be useful in future.\n",
                "    # If we ever decided to show all the ORG_TYPES.\n",
                "    # Remove `Unspecified` ORG_TYPE\n",
                "    # org_types.pop(\"unspecified\", None)\n",
                "\n",
                "    # Change display name of non-profit orgs.\n",
                "    # if org_types.get(\"nonprofit\"):  # nocoverage\n",
                "    #    org_types[\"nonprofit\"][\"name\"] = \"Non-profit\"\n",
                "\n",
                "    return TemplateResponse(\n",
                "        request,\n",
                "        \"corporate/communities.html\",\n",
                "        context={\n",
                "            \"eligible_realms\": eligible_realms,\n",
                "            \"org_types\": org_types,\n",
                "        },\n",
                "    )"
            ]
        ],
        "zproject/default_settings.py": [
            [
                "import os\n",
                "from email.headerregistry import Address\n",
                "from typing import TYPE_CHECKING, Any, Dict, List, Literal, Optional, Tuple\n",
                "\n",
                "from django_auth_ldap.config import GroupOfUniqueNamesType, LDAPGroupType\n",
                "\n",
                "from scripts.lib.zulip_tools import deport\n",
                "from zproject.settings_types import JwtAuthKey, OIDCIdPConfigDict, SAMLIdPConfigDict\n",
                "\n",
                "from .config import DEVELOPMENT, PRODUCTION, get_secret\n",
                "\n",
                "if TYPE_CHECKING:\n",
                "    from django_auth_ldap.config import LDAPSearch\n",
                "\n",
                "if PRODUCTION:  # nocoverage\n",
                "    from .prod_settings import EXTERNAL_HOST, ZULIP_ADMINISTRATOR\n",
                "else:\n",
                "    from .dev_settings import EXTERNAL_HOST, ZULIP_ADMINISTRATOR\n",
                "\n",
                "DEBUG = DEVELOPMENT\n",
                "\n",
                "EXTERNAL_HOST_WITHOUT_PORT = deport(EXTERNAL_HOST)\n",
                "\n",
                "STATIC_URL: Optional[str] = None\n",
                "\n",
                "# These settings are intended for the server admin to set.  We document them in\n",
                "# prod_settings_template.py, and in the initial /etc/zulip/settings.py on a new\n",
                "# install of the Zulip server.\n",
                "\n",
                "# Extra HTTP \"Host\" values to allow (standard ones added in computed_settings.py)\n",
                "ALLOWED_HOSTS: List[str] = []\n",
                "\n",
                "# Basic email settings\n",
                "NOREPLY_EMAIL_ADDRESS = Address(username=\"noreply\", domain=EXTERNAL_HOST_WITHOUT_PORT).addr_spec\n",
                "ADD_TOKENS_TO_NOREPLY_ADDRESS = True\n",
                "TOKENIZED_NOREPLY_EMAIL_ADDRESS = Address(\n",
                "    username=\"noreply-{token}\", domain=EXTERNAL_HOST_WITHOUT_PORT\n",
                ").addr_spec\n",
                "PHYSICAL_ADDRESS = \"\"\n",
                "FAKE_EMAIL_DOMAIN = EXTERNAL_HOST_WITHOUT_PORT\n",
                "\n",
                "# SMTP settings\n",
                "EMAIL_HOST: Optional[str] = None\n",
                "# Other settings, like EMAIL_HOST_USER, EMAIL_PORT, and EMAIL_USE_TLS,\n",
                "# we leave up to Django's defaults.\n",
                "\n",
                "# LDAP auth\n",
                "AUTH_LDAP_SERVER_URI = \"\"\n",
                "AUTH_LDAP_BIND_DN = \"\"\n",
                "AUTH_LDAP_USER_SEARCH: Optional[\"LDAPSearch\"] = None\n",
                "LDAP_APPEND_DOMAIN: Optional[str] = None\n",
                "LDAP_EMAIL_ATTR: Optional[str] = None\n",
                "AUTH_LDAP_REVERSE_EMAIL_SEARCH: Optional[\"LDAPSearch\"] = None\n",
                "AUTH_LDAP_USERNAME_ATTR: Optional[str] = None\n",
                "# AUTH_LDAP_USER_ATTR_MAP is uncommented in prod_settings_template.py,\n",
                "# so the value here mainly serves to help document the default.\n",
                "AUTH_LDAP_USER_ATTR_MAP: Dict[str, str] = {\n",
                "    \"full_name\": \"cn\",\n",
                "}\n",
                "# Automatically deactivate users not found by the AUTH_LDAP_USER_SEARCH query.\n",
                "LDAP_DEACTIVATE_NON_MATCHING_USERS: Optional[bool] = None\n",
                "# AUTH_LDAP_CONNECTION_OPTIONS: we set ldap.OPT_REFERRALS in settings.py if unset.\n",
                "AUTH_LDAP_CONNECTION_OPTIONS: Dict[int, object] = {}\n",
                "# Disable django-auth-ldap caching, to prevent problems with OU changes.\n",
                "AUTH_LDAP_CACHE_TIMEOUT = 0\n",
                "# Disable syncing user on each login; Using sync_ldap_user_data cron is recommended.\n",
                "AUTH_LDAP_ALWAYS_UPDATE_USER = False\n",
                "# Development-only settings for fake LDAP authentication; used to\n",
                "# support local development of LDAP auth without an LDAP server.\n",
                "# Detailed docs in zproject/dev_settings.py.\n",
                "FAKE_LDAP_MODE: Optional[str] = None\n",
                "FAKE_LDAP_NUM_USERS = 8\n",
                "AUTH_LDAP_ADVANCED_REALM_ACCESS_CONTROL: Optional[Dict[str, Any]] = None\n",
                "LDAP_SYNCHRONIZED_GROUPS_BY_REALM: Dict[str, List[str]] = {}\n",
                "AUTH_LDAP_GROUP_TYPE: LDAPGroupType = GroupOfUniqueNamesType()\n",
                "\n",
                "# Social auth; we support providing values for some of these\n",
                "# settings in zulip-secrets.conf instead of settings.py in development.\n",
                "SOCIAL_AUTH_GITHUB_KEY = get_secret(\"social_auth_github_key\", development_only=True)\n",
                "SOCIAL_AUTH_GITHUB_ORG_NAME: Optional[str] = None\n",
                "SOCIAL_AUTH_GITHUB_TEAM_ID: Optional[str] = None\n",
                "SOCIAL_AUTH_GITLAB_KEY = get_secret(\"social_auth_gitlab_key\", development_only=True)\n",
                "SOCIAL_AUTH_SUBDOMAIN: Optional[str] = None\n",
                "SOCIAL_AUTH_AZUREAD_OAUTH2_KEY = get_secret(\"social_auth_azuread_oauth2_key\", development_only=True)\n",
                "SOCIAL_AUTH_GOOGLE_KEY = get_secret(\"social_auth_google_key\", development_only=True)\n",
                "# SAML:\n",
                "SOCIAL_AUTH_SAML_SP_ENTITY_ID: Optional[str] = None\n",
                "SOCIAL_AUTH_SAML_SP_PUBLIC_CERT = \"\"\n",
                "SOCIAL_AUTH_SAML_SP_PRIVATE_KEY = \"\"\n",
                "SOCIAL_AUTH_SAML_ORG_INFO: Optional[Dict[str, Dict[str, str]]] = None\n",
                "SOCIAL_AUTH_SAML_TECHNICAL_CONTACT: Optional[Dict[str, str]] = None\n",
                "SOCIAL_AUTH_SAML_SUPPORT_CONTACT: Optional[Dict[str, str]] = None\n",
                "SOCIAL_AUTH_SAML_ENABLED_IDPS: Dict[str, SAMLIdPConfigDict] = {}\n",
                "SOCIAL_AUTH_SAML_SECURITY_CONFIG: Dict[str, Any] = {}\n",
                "# Set this to True to enforce that any configured IdP needs to specify\n",
                "# the limit_to_subdomains setting to be considered valid:\n",
                "SAML_REQUIRE_LIMIT_TO_SUBDOMAINS = False\n",
                "\n",
                "# Historical name for SOCIAL_AUTH_GITHUB_KEY; still allowed in production.\n",
                "GOOGLE_OAUTH2_CLIENT_ID: Optional[str] = None\n",
                "\n",
                "# Apple:\n",
                "SOCIAL_AUTH_APPLE_SERVICES_ID = get_secret(\"social_auth_apple_services_id\", development_only=True)\n",
                "SOCIAL_AUTH_APPLE_APP_ID = get_secret(\"social_auth_apple_app_id\", development_only=True)\n",
                "SOCIAL_AUTH_APPLE_KEY = get_secret(\"social_auth_apple_key\", development_only=True)\n",
                "SOCIAL_AUTH_APPLE_TEAM = get_secret(\"social_auth_apple_team\", development_only=True)\n",
                "SOCIAL_AUTH_APPLE_SCOPE = [\"name\", \"email\"]\n",
                "SOCIAL_AUTH_APPLE_EMAIL_AS_USERNAME = True\n",
                "\n",
                "# Generic OpenID Connect:\n",
                "SOCIAL_AUTH_OIDC_ENABLED_IDPS: Dict[str, OIDCIdPConfigDict] = {}\n",
                "SOCIAL_AUTH_OIDC_FULL_NAME_VALIDATED = False\n",
                "\n",
                "SOCIAL_AUTH_SYNC_CUSTOM_ATTRS_DICT: Dict[str, Dict[str, Dict[str, str]]] = {}\n",
                "\n",
                "# Other auth\n",
                "SSO_APPEND_DOMAIN: Optional[str] = None\n",
                "CUSTOM_HOME_NOT_LOGGED_IN: Optional[str] = None\n",
                "\n",
                "VIDEO_ZOOM_CLIENT_ID = get_secret(\"video_zoom_client_id\", development_only=True)\n",
                "VIDEO_ZOOM_CLIENT_SECRET = get_secret(\"video_zoom_client_secret\")\n",
                "\n",
                "# Email gateway\n",
                "EMAIL_GATEWAY_PATTERN = \"\"\n",
                "EMAIL_GATEWAY_LOGIN: Optional[str] = None\n",
                "EMAIL_GATEWAY_IMAP_SERVER: Optional[str] = None\n",
                "EMAIL_GATEWAY_IMAP_PORT: Optional[int] = None\n",
                "EMAIL_GATEWAY_IMAP_FOLDER: Optional[str] = None\n",
                "# Not documented for in /etc/zulip/settings.py, since it's rarely needed.\n",
                "EMAIL_GATEWAY_EXTRA_PATTERN_HACK: Optional[str] = None\n",
                "\n",
                "# Error reporting\n",
                "ERROR_REPORTING = True\n",
                "LOGGING_SHOW_MODULE = False\n",
                "LOGGING_SHOW_PID = False\n",
                "\n",
                "# Sentry.io error defaults to off\n",
                "SENTRY_DSN: Optional[str] = None\n",
                "SENTRY_FRONTEND_DSN: Optional[str] = None\n",
                "SENTRY_FRONTEND_SAMPLE_RATE: float = 1.0\n",
                "SENTRY_FRONTEND_TRACE_RATE: float = 0.1\n",
                "\n",
                "# File uploads and avatars\n",
                "# TODO: Rename MAX_FILE_UPLOAD_SIZE to have unit in name.\n",
                "DEFAULT_AVATAR_URI: Optional[str] = None\n",
                "DEFAULT_LOGO_URI: Optional[str] = None\n",
                "S3_AVATAR_BUCKET = \"\"\n",
                "S3_AUTH_UPLOADS_BUCKET = \"\"\n",
                "S3_REGION: Optional[str] = None\n",
                "S3_ENDPOINT_URL: Optional[str] = None\n",
                "S3_SKIP_PROXY = True\n",
                "S3_UPLOADS_STORAGE_CLASS: Literal[\n",
                "    \"GLACIER_IR\",\n",
                "    \"INTELLIGENT_TIERING\",\n",
                "    \"ONEZONE_IA\",\n",
                "    \"REDUCED_REDUNDANCY\",\n",
                "    \"STANDARD\",\n",
                "    \"STANDARD_IA\",\n",
                "] = \"STANDARD\"\n",
                "LOCAL_UPLOADS_DIR: Optional[str] = None\n",
                "LOCAL_AVATARS_DIR: Optional[str] = None\n",
                "LOCAL_FILES_DIR: Optional[str] = None\n",
                "MAX_FILE_UPLOAD_SIZE = 25\n",
                "\n",
                "# Jitsi Meet video call integration; set to None to disable integration.\n",
                "JITSI_SERVER_URL: Optional[str] = \"https://meet.jit.si\"\n",
                "\n",
                "# GIPHY API key.\n",
                "GIPHY_API_KEY = get_secret(\"giphy_api_key\")\n",
                "\n",
                "# Allow setting BigBlueButton settings in zulip-secrets.conf in\n",
                "# development; this is useful since there are no public BigBlueButton servers.\n",
                "BIG_BLUE_BUTTON_URL = get_secret(\"big_blue_button_url\", development_only=True)\n",
                "\n",
                "# Max state storage per user\n",
                "# TODO: Add this to zproject/prod_settings_template.py once stateful bots are fully functional.\n",
                "USER_STATE_SIZE_LIMIT = 10000000\n",
                "# Max size of a single configuration entry of an embedded bot.\n",
                "BOT_CONFIG_SIZE_LIMIT = 10000\n",
                "\n",
                "# External service configuration\n",
                "CAMO_URI = \"\"\n",
                "MEMCACHED_LOCATION = \"127.0.0.1:11211\"\n",
                "MEMCACHED_USERNAME = None if get_secret(\"memcached_password\") is None else \"zulip@localhost\"\n",
                "RABBITMQ_HOST = \"127.0.0.1\"\n",
                "RABBITMQ_PORT = 5672\n",
                "RABBITMQ_USERNAME = \"zulip\"\n",
                "RABBITMQ_USE_TLS = False\n",
                "REDIS_HOST = \"127.0.0.1\"\n",
                "REDIS_PORT = 6379\n",
                "REMOTE_POSTGRES_HOST = \"\"\n",
                "REMOTE_POSTGRES_PORT = \"\"\n",
                "REMOTE_POSTGRES_SSLMODE = \"\"\n",
                "THUMBNAIL_IMAGES = False\n",
                "\n",
                "TORNADO_PORTS: List[int] = []\n",
                "USING_TORNADO = True\n",
                "\n",
                "# ToS/Privacy templates\n",
                "POLICIES_DIRECTORY: str = \"zerver/policies_absent\"\n",
                "\n",
                "# Security\n",
                "ENABLE_FILE_LINKS = False\n",
                "ENABLE_GRAVATAR = True\n",
                "INLINE_IMAGE_PREVIEW = True\n",
                "INLINE_URL_EMBED_PREVIEW = True\n",
                "NAME_CHANGES_DISABLED = False\n",
                "AVATAR_CHANGES_DISABLED = False\n",
                "PASSWORD_MIN_LENGTH = 6\n",
                "PASSWORD_MIN_GUESSES = 10000\n",
                "PUSH_NOTIFICATION_BOUNCER_URL: Optional[str] = None\n",
                "PUSH_NOTIFICATION_REDACT_CONTENT = False\n",
                "SUBMIT_USAGE_STATISTICS = True\n",
                "PROMOTE_SPONSORING_ZULIP = True\n",
                "RATE_LIMITING = True\n",
                "RATE_LIMITING_AUTHENTICATE = True\n",
                "RATE_LIMIT_TOR_TOGETHER = False\n",
                "SEND_LOGIN_EMAILS = True\n",
                "EMBEDDED_BOTS_ENABLED = False\n",
                "\n",
                "DEFAULT_RATE_LIMITING_RULES = {\n",
                "    # Limits total number of API requests per unit time by each user.\n",
                "    # Rate limiting general API access protects the server against\n",
                "    # clients causing unreasonable server load.\n",
                "    \"api_by_user\": [\n",
                "        # 200 requests per limit\n",
                "        (60, 200),\n",
                "    ],\n",
                "    # Limits total number of unauthenticated API requests (primarily\n",
                "    # used by the public access option). Since these are\n",
                "    # unauthenticated requests, each IP address is a separate bucket.\n",
                "    \"api_by_ip\": [\n",
                "        (60, 100),\n",
                "    ],\n",
                "    # Limits total requests to the Mobile Push Notifications Service\n",
                "    # by each individual Zulip server that is using the service. This\n",
                "    # is a Zulip Cloud setting that has no effect on self-hosted Zulip\n",
                "    # servers that are not hosting their own copy of the push\n",
                "    # notifications service.\n",
                "    \"api_by_remote_server\": [\n",
                "        (60, 1000),\n",
                "    ],\n",
                "    # Limits how many authentication attempts with login+password can\n",
                "    # be made to a single username. This applies to the authentication\n",
                "    # backends such as LDAP or email+password where a login+password\n",
                "    # gets submitted to the Zulip server. No limit is applied for\n",
                "    # external authentication methods (like GitHub SSO), since with\n",
                "    # those authentication backends, we only receive a username if\n",
                "    # authentication is successful.\n",
                "    \"authenticate_by_username\": [\n",
                "        # 5 failed login attempts within 30 minutes\n",
                "        (1800, 5),\n",
                "    ],\n",
                "    # Limits how many requests a user can make to change their email\n",
                "    # address. A low/strict limit is recommended here, since there is\n",
                "    # not real use case for triggering several of these from a single\n",
                "    # user account, and by definition, the emails are sent to an email\n",
                "    # address that does not already have a relationship with Zulip, so\n",
                "    # this feature can be abused to attack the server's spam\n",
                "    # reputation. Applies in addition to sends_email_by_ip.\n",
                "    \"email_change_by_user\": [\n",
                "        # 2 emails per hour, and up to 5 per day.\n",
                "        (3600, 2),\n",
                "        (86400, 5),\n",
                "    ],\n",
                "    # Limits how many requests to send password reset emails can be\n",
                "    # made for a single email address. A low/strict limit is\n",
                "    # desirable, since this feature could be used to spam users with\n",
                "    # password reset emails, given their email address. Applies in\n",
                "    # addition to sends_email_by_ip, below.\n",
                "    \"password_reset_form_by_email\": [\n",
                "        # 2 emails per hour, and up to 5 per day.\n",
                "        (3600, 2),\n",
                "        (86400, 5),\n",
                "    ],\n",
                "    # This limit applies to all requests which directly trigger the\n",
                "    # sending of an email, restricting the number per IP address. This\n",
                "    # is a general anti-spam measure.\n",
                "    \"sends_email_by_ip\": [\n",
                "        (86400, 5),\n",
                "    ],\n",
                "    # Limits access to uploaded files, in web-public contexts, done by\n",
                "    # unauthenticated users. Each file gets its own bucket, and every\n",
                "    # access to the file by an unauthenticated user counts towards the\n",
                "    # limit.  This is important to prevent abuse of Zulip's file\n",
                "    # uploads feature for file distribution.\n",
                "    \"spectator_attachment_access_by_file\": [\n",
                "        # 1000 per day per file\n",
                "        (86400, 1000),\n",
                "    ],\n",
                "}\n",
                "# Rate limiting defaults can be individually overridden by adding\n",
                "# entries in this object, which is merged with\n",
                "# DEFAULT_RATE_LIMITING_RULES.\n",
                "RATE_LIMITING_RULES: Dict[str, List[Tuple[int, int]]] = {}\n",
                "\n",
                "# Two factor authentication is not yet implementation-complete\n",
                "TWO_FACTOR_AUTHENTICATION_ENABLED = False\n",
                "\n",
                "# This is used to send all hotspots for convenient manual testing\n",
                "# in development mode.\n",
                "ALWAYS_SEND_ALL_HOTSPOTS = False\n",
                "\n",
                "# The new user tutorial is enabled by default, but can be disabled for\n",
                "# self-hosters who want to disable the tutorial entirely on their system.\n",
                "TUTORIAL_ENABLED = True\n",
                "\n",
                "# We log emails in development environment for accessing\n",
                "# them easily through /emails page\n",
                "DEVELOPMENT_LOG_EMAILS = DEVELOPMENT\n",
                "\n",
                "# The push bouncer expects to get its requests on the root subdomain,\n",
                "# but that makes it more of a hassle to test bouncer endpoints in\n",
                "# the development environment - so this setting allows us to disable\n",
                "# that check.\n",
                "DEVELOPMENT_DISABLE_PUSH_BOUNCER_DOMAIN_CHECK = False\n",
                "\n",
                "\n",
                "# These settings are not documented in prod_settings_template.py.\n",
                "# They should either be documented here, or documented there.\n",
                "#\n",
                "# Settings that it makes sense to document here instead of in\n",
                "# prod_settings_template.py are those that\n",
                "#  * don't make sense to change in production, but rather are intended\n",
                "#    for dev and test environments; or\n",
                "#  * don't make sense to change on a typical production server with\n",
                "#    one or a handful of realms, though they might on an installation\n",
                "#    like Zulip Cloud or to work around a problem on another server.\n",
                "\n",
                "NOTIFICATION_BOT = \"notification-bot@zulip.com\"\n",
                "EMAIL_GATEWAY_BOT = \"emailgateway@zulip.com\"\n",
                "NAGIOS_SEND_BOT = \"nagios-send-bot@zulip.com\"\n",
                "NAGIOS_RECEIVE_BOT = \"nagios-receive-bot@zulip.com\"\n",
                "WELCOME_BOT = \"welcome-bot@zulip.com\"\n",
                "REMINDER_BOT = \"reminder-bot@zulip.com\"\n",
                "\n",
                "# The following bots are optional system bots not enabled by\n",
                "# default.  The default ones are defined in INTERNAL_BOTS, in settings.py.\n",
                "\n",
                "# These are extra bot users for our end-to-end Nagios message\n",
                "# sending tests.\n",
                "NAGIOS_STAGING_SEND_BOT = \"nagios-staging-send-bot@zulip.com\" if PRODUCTION else None\n",
                "NAGIOS_STAGING_RECEIVE_BOT = \"nagios-staging-receive-bot@zulip.com\" if PRODUCTION else None\n",
                "# SYSTEM_BOT_REALM would be a constant always set to 'zulip',\n",
                "# except that it isn't that on Zulip Cloud.  We will likely do a\n",
                "# migration and eliminate this parameter in the future.\n",
                "SYSTEM_BOT_REALM = \"zulipinternal\"\n",
                "\n",
                "# Structurally, we will probably eventually merge\n",
                "# analytics into part of the main server, rather\n",
                "# than a separate app.\n",
                "EXTRA_INSTALLED_APPS = [\"analytics\"]\n",
                "\n",
                "# Used to construct URLs to point to the Zulip server.  Since we\n",
                "# only support HTTPS in production, this is just for development.\n",
                "EXTERNAL_URI_SCHEME = \"https://\"\n",
                "\n",
                "# Whether anyone can create a new organization on the Zulip server.\n",
                "OPEN_REALM_CREATION = False\n",
                "\n",
                "# Whether it's possible to create web-public streams on this server.\n",
                "WEB_PUBLIC_STREAMS_ENABLED = False\n",
                "\n",
                "# Setting for where the system bot users are.  Likely has no\n",
                "# purpose now that the REALMS_HAVE_SUBDOMAINS migration is finished.\n",
                "SYSTEM_ONLY_REALMS = {\"zulip\"}\n",
                "\n",
                "# Default deadline for demo organizations\n",
                "DEMO_ORG_DEADLINE_DAYS = 30\n",
                "\n",
                "# Alternate hostnames to serve particular realms on, in addition to\n",
                "# their usual subdomains.  Keys are realm string_ids (aka subdomains),\n",
                "# and values are alternate hosts.\n",
                "# The values will also be added to ALLOWED_HOSTS.\n",
                "REALM_HOSTS: Dict[str, str] = {}\n",
                "\n",
                "# Map used to rewrite the URIs for certain realms during mobile\n",
                "# authentication.  This, combined with adding the relevant hosts to\n",
                "# ALLOWED_HOSTS, can be used for environments where security policies\n",
                "# mean that a different hostname must be used for mobile access.\n",
                "REALM_MOBILE_REMAP_URIS: Dict[str, str] = {}\n",
                "\n",
                "# Whether the server is using the PGroonga full-text search\n",
                "# backend.  Plan is to turn this on for everyone after further\n",
                "# testing.\n",
                "USING_PGROONGA = False\n",
                "\n",
                "# How Django should send emails.  Set for most contexts in settings.py, but\n",
                "# available for sysadmin override in unusual cases.\n",
                "EMAIL_BACKEND: Optional[str] = None\n",
                "\n",
                "# Whether to give admins a warning in the web app that email isn't set up.\n",
                "# Set in settings.py when email isn't configured.\n",
                "WARN_NO_EMAIL = False\n",
                "\n",
                "# If True, disable rate-limiting and other filters on sending error messages\n",
                "# to admins, and enable logging on the error-reporting itself.  Useful\n",
                "# mainly in development.\n",
                "DEBUG_ERROR_REPORTING = False\n",
                "\n",
                "# Whether to flush memcached after data migrations.  Because of\n",
                "# how we do deployments in a way that avoids reusing memcached,\n",
                "# this is disabled in production, but we need it in development.\n",
                "POST_MIGRATION_CACHE_FLUSHING = False\n",
                "\n",
                "# Settings for APNS.  Only needed on push.zulipchat.com or if\n",
                "# rebuilding the mobile app with a different push notifications\n",
                "# server.\n",
                "APNS_CERT_FILE: Optional[str] = None\n",
                "APNS_TOKEN_KEY_FILE: Optional[str] = None\n",
                "APNS_TOKEN_KEY_ID = get_secret(\"apns_token_key_id\", development_only=True)\n",
                "APNS_TEAM_ID = get_secret(\"apns_team_id\", development_only=True)\n",
                "APNS_SANDBOX = True\n",
                "# APNS_TOPIC is obsolete. Clients now pass the APNs topic to use.\n",
                "# ZULIP_IOS_APP_ID is obsolete. Clients now pass the iOS app ID to use for APNs.\n",
                "\n",
                "# Limits related to the size of file uploads; last few in MB.\n",
                "DATA_UPLOAD_MAX_MEMORY_SIZE = 25 * 1024 * 1024\n",
                "MAX_AVATAR_FILE_SIZE_MIB = 5\n",
                "MAX_ICON_FILE_SIZE_MIB = 5\n",
                "MAX_LOGO_FILE_SIZE_MIB = 5\n",
                "MAX_EMOJI_FILE_SIZE_MIB = 5\n",
                "\n",
                "# Limits to help prevent spam, in particular by sending invitations.\n",
                "#\n",
                "# A non-admin user who's joined an open realm this recently can't invite at all.\n",
                "INVITES_MIN_USER_AGE_DAYS = 3\n",
                "# Default for a realm's `max_invites`; which applies per day,\n",
                "# and only applies if OPEN_REALM_CREATION is true.\n",
                "INVITES_DEFAULT_REALM_DAILY_MAX = 100\n",
                "# Global rate-limit (list of pairs (days, max)) on invites from new realms.\n",
                "# Only applies if OPEN_REALM_CREATION is true.\n",
                "INVITES_NEW_REALM_LIMIT_DAYS = [(1, 100)]\n",
                "# Definition of a new realm for INVITES_NEW_REALM_LIMIT.\n",
                "INVITES_NEW_REALM_DAYS = 7\n",
                "\n",
                "# Controls for which links are published in portico footers/headers/etc.\n",
                "REGISTER_LINK_DISABLED: Optional[bool] = None\n",
                "LOGIN_LINK_DISABLED = False\n",
                "FIND_TEAM_LINK_DISABLED = True\n",
                "\n",
                "# What domains to treat like the root domain\n",
                "ROOT_SUBDOMAIN_ALIASES = [\"www\"]\n",
                "# Whether the root domain is a landing page or can host a realm.\n",
                "ROOT_DOMAIN_LANDING_PAGE = False\n",
                "\n",
                "# Subdomain for serving endpoints to users from self-hosted deployments.\n",
                "SELF_HOSTING_MANAGEMENT_SUBDOMAIN: Optional[str] = None\n",
                "\n",
                "# If using the Zephyr mirroring supervisord configuration, the\n",
                "# hostname to connect to in order to transfer credentials from webathena.\n",
                "PERSONAL_ZMIRROR_SERVER: Optional[str] = None\n",
                "\n",
                "# When security-relevant links in emails expire.\n",
                "CONFIRMATION_LINK_DEFAULT_VALIDITY_DAYS = 1\n",
                "INVITATION_LINK_VALIDITY_DAYS = 10\n",
                "REALM_CREATION_LINK_VALIDITY_DAYS = 7\n",
                "\n",
                "# Version number for ToS.  Change this if you want to force every\n",
                "# user to click through to re-accept terms of service before using\n",
                "# Zulip again on the web.\n",
                "TERMS_OF_SERVICE_VERSION: Optional[str] = None\n",
                "# HTML template path (e.g. \"corporate/zulipchat_migration_tos.html\")\n",
                "# displayed to users when increasing TERMS_OF_SERVICE_VERSION when a\n",
                "# user is to accept the terms of service for the first time, but\n",
                "# already has an account. This primarily comes up when doing a data\n",
                "# import.\n",
                "FIRST_TIME_TERMS_OF_SERVICE_TEMPLATE: Optional[str] = None\n",
                "# Custom message (HTML allowed) to be displayed to explain why users\n",
                "# need to re-accept the terms of service when a new major version is\n",
                "# written.\n",
                "TERMS_OF_SERVICE_MESSAGE: Optional[str] = None\n",
                "\n",
                "# Configuration for JWT auth (sign in and API key fetch)\n",
                "JWT_AUTH_KEYS: Dict[str, JwtAuthKey] = {}\n",
                "\n",
                "# https://docs.djangoproject.com/en/3.2/ref/settings/#std:setting-SERVER_EMAIL\n",
                "# Django setting for what from address to use in error emails.\n",
                "SERVER_EMAIL = ZULIP_ADMINISTRATOR\n",
                "# Django setting for who receives error emails.\n",
                "ADMINS = ((\"Zulip Administrator\", ZULIP_ADMINISTRATOR),)\n",
                "\n",
                "# From address for welcome emails.\n",
                "WELCOME_EMAIL_SENDER: Optional[Dict[str, str]] = None\n",
                "\n",
                "# Whether to send periodic digests of activity.\n",
                "SEND_DIGEST_EMAILS = True\n",
                "# The variable part of email sender names to be used for outgoing emails.\n",
                "INSTALLATION_NAME = EXTERNAL_HOST\n",
                "\n",
                "# Used to change the Zulip logo in portico pages.\n",
                "CUSTOM_LOGO_URL: Optional[str] = None\n",
                "\n",
                "# Random salt used when deterministically generating passwords in\n",
                "# development.\n",
                "INITIAL_PASSWORD_SALT: Optional[str] = None\n",
                "\n",
                "# Settings configuring the special instrumentation of the send_event\n",
                "# code path used in generating API documentation for /events.\n",
                "LOG_API_EVENT_TYPES = False\n",
                "\n",
                "# Used to control whether certain management commands are run on\n",
                "# the server.\n",
                "# TODO: Replace this with a smarter \"run on only one server\" system.\n",
                "STAGING = False\n",
                "\n",
                "# Presence tuning parameters. These values were hardcoded in clients\n",
                "# before Zulip 7.0 (feature level 164); modern clients should get them\n",
                "# via the /register API response, making it possible to tune these to\n",
                "# adjust the trade-off between freshness and presence-induced load.\n",
                "#\n",
                "# The default for OFFLINE_THRESHOLD_SECS is chosen as\n",
                "# `PRESENCE_PING_INTERVAL_SECS * 3 + 20`, which is designed to allow 2\n",
                "# round trips, plus an extra in case an update fails. See\n",
                "# https://zulip.readthedocs.io/en/latest/subsystems/presence.html for\n",
                "# details on the presence architecture.\n",
                "#\n",
                "# How long to wait before clients should treat a user as offline.\n",
                "OFFLINE_THRESHOLD_SECS = 200\n",
                "# How often a client should ping by asking for presence data of all users.\n",
                "PRESENCE_PING_INTERVAL_SECS = 60\n",
                "# Zulip sends immediate presence updates via the events system when a\n",
                "# user joins or becomes online. In larger organizations, this can\n",
                "# become prohibitively expensive, so we limit how many active users an\n",
                "# organization can have before these presence update events are\n",
                "# disabled.\n",
                "USER_LIMIT_FOR_SENDING_PRESENCE_UPDATE_EVENTS = 100\n",
                "\n",
                "# Controls the how much newer a user presence update needs to be\n",
                "# than the currently saved last_active_time or last_connected_time in order for us to\n",
                "# update the database state. E.g. If set to 0, we will do\n",
                "# a database write each time a client sends a presence update.\n",
                "PRESENCE_UPDATE_MIN_FREQ_SECONDS = 55\n",
                "\n",
                "# Controls the timedelta between last_connected_time and last_active_time\n",
                "# within which the user should be considered ACTIVE for the purposes of\n",
                "# legacy presence events. That is - when sending a presence update about a user to clients,\n",
                "# we will specify ACTIVE status  as long as the timedelta is within this limit and IDLE otherwise.\n",
                "PRESENCE_LEGACY_EVENT_OFFSET_FOR_ACTIVITY_SECONDS = 70\n",
                "\n",
                "# How many days deleted messages data should be kept before being\n",
                "# permanently deleted.\n",
                "ARCHIVED_DATA_VACUUMING_DELAY_DAYS = 30\n",
                "\n",
                "# Enables billing pages and plan-based feature gates. If False, all features\n",
                "# are available to all realms.\n",
                "BILLING_ENABLED = False\n",
                "\n",
                "CLOUD_FREE_TRIAL_DAYS: Optional[int] = int(get_secret(\"cloud_free_trial_days\", \"0\"))\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "SELF_HOSTING_FREE_TRIAL_DAYS: Optional[int] = int(get_secret(\"self_hosting_free_trial_days\", \"0\"))\n"
                ],
                "parent_version_range": {
                    "start": 549,
                    "end": 549
                },
                "child_version_range": {
                    "start": 549,
                    "end": 550
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "call",
                        "name": "int",
                        "signature": "int(get_secret(\"cloud_free_trial_days\", \"0\"))",
                        "at_line": 548,
                        "argument": "get_secret(\"cloud_free_trial_d..."
                    }
                ],
                "idx": 8,
                "hunk_diff": "File: zproject/default_settings.py\nCode:\n546 546    BILLING_ENABLED = False\n547 547    \n548 548    CLOUD_FREE_TRIAL_DAYS: Optional[int] = int(get_secret(\"cloud_free_trial_days\", \"0\"))\n    549  + SELF_HOSTING_FREE_TRIAL_DAYS: Optional[int] = int(get_secret(\"self_hosting_free_trial_days\", \"0\"))\n549 550    \n550 551    # Custom message (supports HTML) to be shown in the navbar of landing pages. Used mainly for\n551 552    # making announcements.\n         ...\n",
                "file_path": "zproject/default_settings.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Optional",
                    "SELF_HOSTING_FREE_TRIAL_DAYS",
                    "get_secret",
                    "int"
                ],
                "prefix": [
                    "BILLING_ENABLED = False\n",
                    "\n",
                    "CLOUD_FREE_TRIAL_DAYS: Optional[int] = int(get_secret(\"cloud_free_trial_days\", \"0\"))\n"
                ],
                "suffix": [
                    "\n",
                    "# Custom message (supports HTML) to be shown in the navbar of landing pages. Used mainly for\n",
                    "# making announcements.\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "# Custom message (supports HTML) to be shown in the navbar of landing pages. Used mainly for\n",
                "# making announcements.\n",
                "LANDING_PAGE_NAVBAR_MESSAGE: Optional[str] = None\n",
                "\n",
                "# Automatically catch-up soft deactivated users when running the\n",
                "# `soft-deactivate-users` cron. Turn this off if the server has 10Ks of\n",
                "# users, and you would like to save some disk space. Soft-deactivated\n",
                "# returning users would still be caught-up normally.\n",
                "AUTO_CATCH_UP_SOFT_DEACTIVATED_USERS = True\n",
                "\n",
                "# Enables Google Analytics on selected portico pages.\n",
                "GOOGLE_ANALYTICS_ID: Optional[str] = None\n",
                "\n",
                "# This is overridden by dev_settings.py for droplets.\n",
                "IS_DEV_DROPLET = False\n",
                "\n",
                "# Used by puppet/zulip_ops/files/cron.d/check_send_receive_time.\n",
                "NAGIOS_BOT_HOST = EXTERNAL_HOST\n",
                "\n",
                "# Use half of the available CPUs for data import purposes.\n",
                "DEFAULT_DATA_EXPORT_IMPORT_PARALLELISM = (len(os.sched_getaffinity(0)) // 2) or 1\n",
                "\n",
                "# How long after the last upgrade to nag users that the server needs\n",
                "# to be upgraded because of likely security releases in the meantime.\n",
                "# Default is 18 months, constructed as 12 months before someone should\n",
                "# upgrade, plus 6 months for the system administrator to get around to it.\n",
                "SERVER_UPGRADE_NAG_DEADLINE_DAYS = 30 * 18\n",
                "\n",
                "# How long servers have to respond to outgoing webhook requests\n",
                "OUTGOING_WEBHOOK_TIMEOUT_SECONDS = 10\n",
                "\n",
                "# Maximum length of message content allowed.\n",
                "# Any message content exceeding this limit will be truncated.\n",
                "# See: `_internal_prep_message` function in zerver/actions/message_send.py.\n",
                "MAX_MESSAGE_LENGTH = 10000\n",
                "\n",
                "# The maximum number of drafts to send in the response to /register.\n",
                "# More drafts, should they exist for some crazy reason, could be\n",
                "# fetched in a separate request.\n",
                "MAX_DRAFTS_IN_REGISTER_RESPONSE = 1000\n",
                "\n",
                "# How long before a client should assume that another client sending\n",
                "# typing notifications has gone away and expire the active typing\n",
                "# indicator.\n",
                "TYPING_STARTED_EXPIRY_PERIOD_MILLISECONDS = 45000\n",
                "\n",
                "# How long after a user has stopped interacting with the compose UI\n",
                "# that a client should send a stop notification to the server.\n",
                "TYPING_STOPPED_WAIT_PERIOD_MILLISECONDS = 12000\n",
                "\n",
                "# How often a client should send start notifications to the server to\n",
                "# indicate that the user is still interacting with the compose UI.\n",
                "TYPING_STARTED_WAIT_PERIOD_MILLISECONDS = 30000\n",
                "\n",
                "# The maximum number of subscribers for a stream to have typing\n",
                "# notifications enabled. Default is set to avoid excessive Tornado\n",
                "# load in large organizations.\n",
                "MAX_STREAM_SIZE_FOR_TYPING_NOTIFICATIONS = 100\n",
                "\n",
                "# Limiting guest access to other users via the\n",
                "# can_access_all_users_group setting makes presence queries much more\n",
                "# expensive. This can be a significant performance problem for\n",
                "# installations with thousands of users with many guests limited in\n",
                "# this way, pending further optimization of the relevant code paths.\n",
                "CAN_ACCESS_ALL_USERS_GROUP_LIMITS_PRESENCE = False\n",
                "\n",
                "# General expiry time for signed tokens we may generate\n",
                "# in some places through the codebase.\n",
                "SIGNED_ACCESS_TOKEN_VALIDITY_IN_SECONDS = 60"
            ]
        ]
    },
    "edit_order": [
        [
            4,
            0,
            1,
            2,
            3,
            5,
            6,
            7,
            8
        ]
    ],
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "define and use of variable is_self_hosted_billing",
            "scenario of 0 -> 1": "define before use",
            "scenario of 1 -> 0": "use before define"
        },
        {
            "edit_hunk_pair": [
                0,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "update get_free_trail_days()",
            "scenario of 0 -> 1": "use before use",
            "scenario of 1 -> 0": "use before use"
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "update compute_plan_parameters()",
            "scenario of 0 -> 1": "use before define",
            "scenario of 1 -> 0": "define before use"
        },
        {
            "edit_hunk_pair": [
                1,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "update compute_plan_parameters()",
            "scenario of 0 -> 1": "use before implement",
            "scenario of 1 -> 0": "implement before use"
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "update compute_plan_parameters()",
            "scenario of 0 -> 1": "define before use",
            "scenario of 1 -> 0": "use before define"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "update get_free_trial_days()",
            "scenario of 0 -> 1": "use before use",
            "scenario of 1 -> 0": "use before use"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "update get_free_trial_days()",
            "scenario of 0 -> 1": "define before use",
            "scenario of 1 -> 0": "use before define"
        },
        {
            "edit_hunk_pair": [
                4,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "update get_free_trial_days()",
            "scenario of 0 -> 1": "define before use",
            "scenario of 1 -> 0": "use before define"
        },
        {
            "edit_hunk_pair": [
                4,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "update get_free_trial_days()",
            "scenario of 0 -> 1": "define before use",
            "scenario of 1 -> 0": "use before define"
        },
        {
            "edit_hunk_pair": [
                4,
                8
            ],
            "edit_order": "bi-directional",
            "reason": "use SELF_HOSTING_FREE_TRIAL_DAYS",
            "scenario of 0 -> 1": "use before define",
            "scenario of 1 -> 0": "def before use"
        },
        {
            "edit_hunk_pair": [
                5,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "update get_free_trial_days()",
            "scenario of 0 -> 1": "use before use",
            "scenario of 1 -> 0": "use before use"
        },
        {
            "edit_hunk_pair": [
                5,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "update get_free_trial_days()",
            "scenario of 0 -> 1": "use before use",
            "scenario of 1 -> 0": "use before use"
        },
        {
            "edit_hunk_pair": [
                6,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "update get_free_trial_days()",
            "scenario of 0 -> 1": "use before use",
            "scenario of 1 -> 0": "use before use"
        }
    ]
}