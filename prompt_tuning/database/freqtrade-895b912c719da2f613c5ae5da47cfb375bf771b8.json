{
    "language": "python",
    "commit_url": "https://github.com/freqtrade/freqtrade/commit/895b912c719da2f613c5ae5da47cfb375bf771b8",
    "commit_message": "Fix recently introduced lookahead bias in backtesting\n\ncloses #5388",
    "commit_snapshots": {
        "freqtrade/optimize/backtesting.py": [
            [
                "# pragma pylint: disable=missing-docstring, W0212, too-many-arguments\n",
                "\n",
                "\"\"\"\n",
                "This module contains the backtesting logic\n",
                "\"\"\"\n",
                "import logging\n",
                "from collections import defaultdict\n",
                "from copy import deepcopy\n",
                "from datetime import datetime, timedelta, timezone\n",
                "from typing import Any, Dict, List, Optional, Tuple\n",
                "\n",
                "from pandas import DataFrame\n",
                "\n",
                "from freqtrade.configuration import TimeRange, remove_credentials, validate_config_consistency\n",
                "from freqtrade.constants import DATETIME_PRINT_FORMAT\n",
                "from freqtrade.data import history\n",
                "from freqtrade.data.btanalysis import trade_list_to_dataframe\n",
                "from freqtrade.data.converter import trim_dataframe, trim_dataframes\n",
                "from freqtrade.data.dataprovider import DataProvider\n",
                "from freqtrade.enums import BacktestState, SellType\n",
                "from freqtrade.exceptions import DependencyException, OperationalException\n",
                "from freqtrade.exchange import timeframe_to_minutes, timeframe_to_seconds\n",
                "from freqtrade.mixins import LoggingMixin\n",
                "from freqtrade.optimize.bt_progress import BTProgress\n",
                "from freqtrade.optimize.optimize_reports import (generate_backtest_stats, show_backtest_results,\n",
                "                                                 store_backtest_stats)\n",
                "from freqtrade.persistence import LocalTrade, PairLocks, Trade\n",
                "from freqtrade.plugins.pairlistmanager import PairListManager\n",
                "from freqtrade.plugins.protectionmanager import ProtectionManager\n",
                "from freqtrade.resolvers import ExchangeResolver, StrategyResolver\n",
                "from freqtrade.strategy.interface import IStrategy, SellCheckTuple\n",
                "from freqtrade.strategy.strategy_wrapper import strategy_safe_wrapper\n",
                "from freqtrade.wallets import Wallets\n",
                "\n",
                "\n",
                "logger = logging.getLogger(__name__)\n",
                "\n",
                "# Indexes for backtest tuples\n",
                "DATE_IDX = 0\n",
                "BUY_IDX = 1\n",
                "OPEN_IDX = 2\n",
                "CLOSE_IDX = 3\n",
                "SELL_IDX = 4\n",
                "LOW_IDX = 5\n",
                "HIGH_IDX = 6\n",
                "BUY_TAG_IDX = 7\n",
                "\n",
                "\n",
                "class Backtesting:\n",
                "    \"\"\"\n",
                "    Backtesting class, this class contains all the logic to run a backtest\n",
                "\n",
                "    To run a backtest:\n",
                "    backtesting = Backtesting(config)\n",
                "    backtesting.start()\n",
                "    \"\"\"\n",
                "\n",
                "    def __init__(self, config: Dict[str, Any]) -> None:\n",
                "\n",
                "        LoggingMixin.show_output = False\n",
                "        self.config = config\n",
                "        self.results: Optional[Dict[str, Any]] = None\n",
                "\n",
                "        # Reset keys for backtesting\n",
                "        remove_credentials(self.config)\n",
                "        self.strategylist: List[IStrategy] = []\n",
                "        self.all_results: Dict[str, Dict] = {}\n",
                "\n",
                "        self.exchange = ExchangeResolver.load_exchange(self.config['exchange']['name'], self.config)\n",
                "        self.dataprovider = DataProvider(self.config, None)\n",
                "\n",
                "        if self.config.get('strategy_list', None):\n",
                "            for strat in list(self.config['strategy_list']):\n",
                "                stratconf = deepcopy(self.config)\n",
                "                stratconf['strategy'] = strat\n",
                "                self.strategylist.append(StrategyResolver.load_strategy(stratconf))\n",
                "                validate_config_consistency(stratconf)\n",
                "\n",
                "        else:\n",
                "            # No strategy list specified, only one strategy\n",
                "            self.strategylist.append(StrategyResolver.load_strategy(self.config))\n",
                "            validate_config_consistency(self.config)\n",
                "\n",
                "        if \"timeframe\" not in self.config:\n",
                "            raise OperationalException(\"Timeframe (ticker interval) needs to be set in either \"\n",
                "                                       \"configuration or as cli argument `--timeframe 5m`\")\n",
                "        self.timeframe = str(self.config.get('timeframe'))\n",
                "        self.timeframe_min = timeframe_to_minutes(self.timeframe)\n",
                "\n",
                "        self.pairlists = PairListManager(self.exchange, self.config)\n",
                "        if 'VolumePairList' in self.pairlists.name_list:\n",
                "            raise OperationalException(\"VolumePairList not allowed for backtesting.\")\n",
                "        if 'PerformanceFilter' in self.pairlists.name_list:\n",
                "            raise OperationalException(\"PerformanceFilter not allowed for backtesting.\")\n",
                "\n",
                "        if len(self.strategylist) > 1 and 'PrecisionFilter' in self.pairlists.name_list:\n",
                "            raise OperationalException(\n",
                "                \"PrecisionFilter not allowed for backtesting multiple strategies.\"\n",
                "            )\n",
                "\n",
                "        self.dataprovider.add_pairlisthandler(self.pairlists)\n",
                "        self.pairlists.refresh_pairlist()\n",
                "\n",
                "        if len(self.pairlists.whitelist) == 0:\n",
                "            raise OperationalException(\"No pair in whitelist.\")\n",
                "\n",
                "        if config.get('fee', None) is not None:\n",
                "            self.fee = config['fee']\n",
                "        else:\n",
                "            self.fee = self.exchange.get_fee(symbol=self.pairlists.whitelist[0])\n",
                "\n",
                "        Trade.use_db = False\n",
                "        Trade.reset_trades()\n",
                "        PairLocks.timeframe = self.config['timeframe']\n",
                "        PairLocks.use_db = False\n",
                "        PairLocks.reset_locks()\n",
                "\n",
                "        self.wallets = Wallets(self.config, self.exchange, log=False)\n",
                "\n",
                "        self.timerange = TimeRange.parse_timerange(\n",
                "            None if self.config.get('timerange') is None else str(self.config.get('timerange')))\n",
                "\n",
                "        # Get maximum required startup period\n",
                "        self.required_startup = max([strat.startup_candle_count for strat in self.strategylist])\n",
                "        # Add maximum startup candle count to configuration for informative pairs support\n",
                "        self.config['startup_candle_count'] = self.required_startup\n",
                "        self.exchange.validate_required_startup_candles(self.required_startup, self.timeframe)\n",
                "\n",
                "        self.progress = BTProgress()\n",
                "        self.abort = False\n",
                "\n",
                "    def __del__(self):\n",
                "        self.cleanup()\n",
                "\n",
                "    def cleanup(self):\n",
                "        LoggingMixin.show_output = True\n",
                "        PairLocks.use_db = True\n",
                "        Trade.use_db = True\n",
                "\n",
                "    def _set_strategy(self, strategy: IStrategy):\n",
                "        \"\"\"\n",
                "        Load strategy into backtesting\n",
                "        \"\"\"\n",
                "        self.strategy: IStrategy = strategy\n",
                "        strategy.dp = self.dataprovider\n",
                "        # Attach Wallets to Strategy baseclass\n",
                "        IStrategy.wallets = self.wallets\n",
                "        # Set stoploss_on_exchange to false for backtesting,\n",
                "        # since a \"perfect\" stoploss-sell is assumed anyway\n",
                "        # And the regular \"stoploss\" function would not apply to that case\n",
                "        self.strategy.order_types['stoploss_on_exchange'] = False\n",
                "\n",
                "    def _load_protections(self, strategy: IStrategy):\n",
                "        if self.config.get('enable_protections', False):\n",
                "            conf = self.config\n",
                "            if hasattr(strategy, 'protections'):\n",
                "                conf = deepcopy(conf)\n",
                "                conf['protections'] = strategy.protections\n",
                "            self.protections = ProtectionManager(self.config, strategy.protections)\n",
                "\n",
                "    def load_bt_data(self) -> Tuple[Dict[str, DataFrame], TimeRange]:\n",
                "        \"\"\"\n",
                "        Loads backtest data and returns the data combined with the timerange\n",
                "        as tuple.\n",
                "        \"\"\"\n",
                "        self.progress.init_step(BacktestState.DATALOAD, 1)\n",
                "\n",
                "        data = history.load_data(\n",
                "            datadir=self.config['datadir'],\n",
                "            pairs=self.pairlists.whitelist,\n",
                "            timeframe=self.timeframe,\n",
                "            timerange=self.timerange,\n",
                "            startup_candles=self.required_startup,\n",
                "            fail_without_data=True,\n",
                "            data_format=self.config.get('dataformat_ohlcv', 'json'),\n",
                "        )\n",
                "\n",
                "        min_date, max_date = history.get_timerange(data)\n",
                "\n",
                "        logger.info(f'Loading data from {min_date.strftime(DATETIME_PRINT_FORMAT)} '\n",
                "                    f'up to {max_date.strftime(DATETIME_PRINT_FORMAT)} '\n",
                "                    f'({(max_date - min_date).days} days).')\n",
                "\n",
                "        # Adjust startts forward if not enough data is available\n",
                "        self.timerange.adjust_start_if_necessary(timeframe_to_seconds(self.timeframe),\n",
                "                                                 self.required_startup, min_date)\n",
                "\n",
                "        self.progress.set_new_value(1)\n",
                "        return data, self.timerange\n",
                "\n",
                "    def prepare_backtest(self, enable_protections):\n",
                "        \"\"\"\n",
                "        Backtesting setup method - called once for every call to \"backtest()\".\n",
                "        \"\"\"\n",
                "        PairLocks.use_db = False\n",
                "        PairLocks.timeframe = self.config['timeframe']\n",
                "        Trade.use_db = False\n",
                "        PairLocks.reset_locks()\n",
                "        Trade.reset_trades()\n",
                "        self.rejected_trades = 0\n",
                "        self.dataprovider.clear_cache()\n",
                "        self._load_protections(self.strategy)\n",
                "\n",
                "    def check_abort(self):\n",
                "        \"\"\"\n",
                "        Check if abort was requested, raise DependencyException if that's the case\n",
                "        Only applies to Interactive backtest mode (webserver mode)\n",
                "        \"\"\"\n",
                "        if self.abort:\n",
                "            self.abort = False\n",
                "            raise DependencyException(\"Stop requested\")\n",
                "\n",
                "    def _get_ohlcv_as_lists(self, processed: Dict[str, DataFrame]) -> Dict[str, Tuple]:\n",
                "        \"\"\"\n",
                "        Helper function to convert a processed dataframes into lists for performance reasons.\n",
                "\n",
                "        Used by backtest() - so keep this optimized for performance.\n",
                "        \"\"\"\n",
                "        # Every change to this headers list must evaluate further usages of the resulting tuple\n",
                "        # and eventually change the constants for indexes at the top\n",
                "        headers = ['date', 'buy', 'open', 'close', 'sell', 'low', 'high']\n",
                "        data: Dict = {}\n",
                "        self.progress.init_step(BacktestState.CONVERT, len(processed))\n",
                "\n",
                "        # Create dict with data\n",
                "        for pair, pair_data in processed.items():\n",
                "            self.check_abort()\n",
                "            self.progress.increment()\n",
                "            has_buy_tag = 'buy_tag' in pair_data\n",
                "            headers = headers + ['buy_tag'] if has_buy_tag else headers\n",
                "            if not pair_data.empty:\n",
                "                pair_data.loc[:, 'buy'] = 0  # cleanup if buy_signal is exist\n",
                "                pair_data.loc[:, 'sell'] = 0  # cleanup if sell_signal is exist\n",
                "                if has_buy_tag:\n",
                "                    pair_data.loc[:, 'buy_tag'] = None  # cleanup if buy_tag is exist\n",
                "\n",
                "            df_analyzed = self.strategy.advise_sell(\n",
                "                self.strategy.advise_buy(pair_data, {'pair': pair}), {'pair': pair}).copy()\n",
                "            # Trim startup period from analyzed dataframe\n",
                "            df_analyzed = trim_dataframe(df_analyzed, self.timerange,\n",
                "                                         startup_candles=self.required_startup)\n",
                "            # To avoid using data from future, we use buy/sell signals shifted\n",
                "            # from the previous candle\n",
                "            df_analyzed.loc[:, 'buy'] = df_analyzed.loc[:, 'buy'].shift(1)\n",
                "            df_analyzed.loc[:, 'sell'] = df_analyzed.loc[:, 'sell'].shift(1)\n",
                "            if has_buy_tag:\n",
                "                df_analyzed.loc[:, 'buy_tag'] = df_analyzed.loc[:, 'buy_tag'].shift(1)\n",
                "\n",
                "            df_analyzed.drop(df_analyzed.head(1).index, inplace=True)\n",
                "\n",
                "            # Update dataprovider cache\n",
                "            self.dataprovider._set_cached_df(pair, self.timeframe, df_analyzed)\n",
                "\n",
                "            # Convert from Pandas to list for performance reasons\n",
                "            # (Looping Pandas is slow.)\n",
                "            data[pair] = df_analyzed[headers].values.tolist()\n",
                "        return data\n",
                "\n",
                "    def _get_close_rate(self, sell_row: Tuple, trade: LocalTrade, sell: SellCheckTuple,\n",
                "                        trade_dur: int) -> float:\n",
                "        \"\"\"\n",
                "        Get close rate for backtesting result\n",
                "        \"\"\"\n",
                "        # Special handling if high or low hit STOP_LOSS or ROI\n",
                "        if sell.sell_type in (SellType.STOP_LOSS, SellType.TRAILING_STOP_LOSS):\n",
                "            if trade.stop_loss > sell_row[HIGH_IDX]:\n",
                "                # our stoploss was already higher than candle high,\n",
                "                # possibly due to a cancelled trade exit.\n",
                "                # sell at open price.\n",
                "                return sell_row[OPEN_IDX]\n",
                "\n",
                "            # Special case: trailing triggers within same candle as trade opened. Assume most\n",
                "            # pessimistic price movement, which is moving just enough to arm stoploss and\n",
                "            # immediately going down to stop price.\n",
                "            if sell.sell_type == SellType.TRAILING_STOP_LOSS and trade_dur == 0:\n",
                "                if (\n",
                "                    not self.strategy.use_custom_stoploss and self.strategy.trailing_stop\n",
                "                    and self.strategy.trailing_only_offset_is_reached\n",
                "                    and self.strategy.trailing_stop_positive_offset is not None\n",
                "                    and self.strategy.trailing_stop_positive\n",
                "                ):\n",
                "                    # Worst case: price reaches stop_positive_offset and dives down.\n",
                "                    stop_rate = (sell_row[OPEN_IDX] *\n",
                "                                 (1 + abs(self.strategy.trailing_stop_positive_offset) -\n",
                "                                  abs(self.strategy.trailing_stop_positive)))\n",
                "                else:\n",
                "                    # Worst case: price ticks tiny bit above open and dives down.\n",
                "                    stop_rate = sell_row[OPEN_IDX] * (1 - abs(trade.stop_loss_pct))\n",
                "                    assert stop_rate < sell_row[HIGH_IDX]\n",
                "                return stop_rate\n",
                "\n",
                "            # Set close_rate to stoploss\n",
                "            return trade.stop_loss\n",
                "        elif sell.sell_type == (SellType.ROI):\n",
                "            roi_entry, roi = self.strategy.min_roi_reached_entry(trade_dur)\n",
                "            if roi is not None and roi_entry is not None:\n",
                "                if roi == -1 and roi_entry % self.timeframe_min == 0:\n",
                "                    # When forceselling with ROI=-1, the roi time will always be equal to trade_dur.\n",
                "                    # If that entry is a multiple of the timeframe (so on candle open)\n",
                "                    # - we'll use open instead of close\n",
                "                    return sell_row[OPEN_IDX]\n",
                "\n",
                "                # - (Expected abs profit + open_rate + open_fee) / (fee_close -1)\n",
                "                close_rate = - (trade.open_rate * roi + trade.open_rate *\n",
                "                                (1 + trade.fee_open)) / (trade.fee_close - 1)\n",
                "\n",
                "                if (trade_dur > 0 and trade_dur == roi_entry\n",
                "                        and roi_entry % self.timeframe_min == 0\n",
                "                        and sell_row[OPEN_IDX] > close_rate):\n",
                "                    # new ROI entry came into effect.\n",
                "                    # use Open rate if open_rate > calculated sell rate\n",
                "                    return sell_row[OPEN_IDX]\n",
                "\n",
                "                # Use the maximum between close_rate and low as we\n",
                "                # cannot sell outside of a candle.\n",
                "                # Applies when a new ROI setting comes in place and the whole candle is above that.\n",
                "                return min(max(close_rate, sell_row[LOW_IDX]), sell_row[HIGH_IDX])\n",
                "\n",
                "            else:\n",
                "                # This should not be reached...\n",
                "                return sell_row[OPEN_IDX]\n",
                "        else:\n",
                "            return sell_row[OPEN_IDX]\n",
                "\n",
                "    def _get_sell_trade_entry(self, trade: LocalTrade, sell_row: Tuple) -> Optional[LocalTrade]:\n",
                "\n",
                "        sell = self.strategy.should_sell(trade, sell_row[OPEN_IDX],  # type: ignore\n",
                "                                         sell_row[DATE_IDX].to_pydatetime(), sell_row[BUY_IDX],\n",
                "                                         sell_row[SELL_IDX],\n",
                "                                         low=sell_row[LOW_IDX], high=sell_row[HIGH_IDX])\n",
                "\n",
                "        if sell.sell_flag:\n",
                "            trade.close_date = sell_row[DATE_IDX].to_pydatetime()\n",
                "            trade.sell_reason = sell.sell_reason\n",
                "            trade_dur = int((trade.close_date_utc - trade.open_date_utc).total_seconds() // 60)\n",
                "            closerate = self._get_close_rate(sell_row, trade, sell, trade_dur)\n",
                "\n",
                "            # Confirm trade exit:\n",
                "            time_in_force = self.strategy.order_time_in_force['sell']\n",
                "            if not strategy_safe_wrapper(self.strategy.confirm_trade_exit, default_retval=True)(\n",
                "                    pair=trade.pair, trade=trade, order_type='limit', amount=trade.amount,\n",
                "                    rate=closerate,\n",
                "                    time_in_force=time_in_force,\n",
                "                    sell_reason=sell.sell_reason,\n",
                "                    current_time=sell_row[DATE_IDX].to_pydatetime()):\n",
                "                return None\n",
                "\n",
                "            trade.close(closerate, show_msg=False)\n",
                "            return trade\n",
                "\n",
                "        return None\n",
                "\n",
                "    def _enter_trade(self, pair: str, row: List) -> Optional[LocalTrade]:\n",
                "        try:\n",
                "            stake_amount = self.wallets.get_trade_stake_amount(pair, None)\n",
                "        except DependencyException:\n",
                "            return None\n",
                "\n",
                "        min_stake_amount = self.exchange.get_min_pair_stake_amount(pair, row[OPEN_IDX], -0.05) or 0\n",
                "        max_stake_amount = self.wallets.get_available_stake_amount()\n",
                "\n",
                "        stake_amount = strategy_safe_wrapper(self.strategy.custom_stake_amount,\n",
                "                                             default_retval=stake_amount)(\n",
                "            pair=pair, current_time=row[DATE_IDX].to_pydatetime(), current_rate=row[OPEN_IDX],\n",
                "            proposed_stake=stake_amount, min_stake=min_stake_amount, max_stake=max_stake_amount)\n",
                "        stake_amount = self.wallets._validate_stake_amount(pair, stake_amount, min_stake_amount)\n",
                "\n",
                "        if not stake_amount:\n",
                "            return None\n",
                "\n",
                "        order_type = self.strategy.order_types['buy']\n",
                "        time_in_force = self.strategy.order_time_in_force['sell']\n",
                "        # Confirm trade entry:\n",
                "        if not strategy_safe_wrapper(self.strategy.confirm_trade_entry, default_retval=True)(\n",
                "                pair=pair, order_type=order_type, amount=stake_amount, rate=row[OPEN_IDX],\n",
                "                time_in_force=time_in_force, current_time=row[DATE_IDX].to_pydatetime()):\n",
                "            return None\n",
                "\n",
                "        if stake_amount and (not min_stake_amount or stake_amount > min_stake_amount):\n",
                "            # Enter trade\n",
                "            has_buy_tag = len(row) >= BUY_TAG_IDX + 1\n",
                "            trade = LocalTrade(\n",
                "                pair=pair,\n",
                "                open_rate=row[OPEN_IDX],\n",
                "                open_date=row[DATE_IDX].to_pydatetime(),\n",
                "                stake_amount=stake_amount,\n",
                "                amount=round(stake_amount / row[OPEN_IDX], 8),\n",
                "                fee_open=self.fee,\n",
                "                fee_close=self.fee,\n",
                "                is_open=True,\n",
                "                buy_tag=row[BUY_TAG_IDX] if has_buy_tag else None,\n",
                "                exchange='backtesting',\n",
                "            )\n",
                "            return trade\n",
                "        return None\n",
                "\n",
                "    def handle_left_open(self, open_trades: Dict[str, List[LocalTrade]],\n",
                "                         data: Dict[str, List[Tuple]]) -> List[LocalTrade]:\n",
                "        \"\"\"\n",
                "        Handling of left open trades at the end of backtesting\n",
                "        \"\"\"\n",
                "        trades = []\n",
                "        for pair in open_trades.keys():\n",
                "            if len(open_trades[pair]) > 0:\n",
                "                for trade in open_trades[pair]:\n",
                "                    sell_row = data[pair][-1]\n",
                "\n",
                "                    trade.close_date = sell_row[DATE_IDX].to_pydatetime()\n",
                "                    trade.sell_reason = SellType.FORCE_SELL.value\n",
                "                    trade.close(sell_row[OPEN_IDX], show_msg=False)\n",
                "                    LocalTrade.close_bt_trade(trade)\n",
                "                    # Deepcopy object to have wallets update correctly\n",
                "                    trade1 = deepcopy(trade)\n",
                "                    trade1.is_open = True\n",
                "                    trades.append(trade1)\n",
                "        return trades\n",
                "\n",
                "    def trade_slot_available(self, max_open_trades: int, open_trade_count: int) -> bool:\n",
                "        # Always allow trades when max_open_trades is enabled.\n",
                "        if max_open_trades <= 0 or open_trade_count < max_open_trades:\n",
                "            return True\n",
                "        # Rejected trade\n",
                "        self.rejected_trades += 1\n",
                "        return False\n",
                "\n",
                "    def backtest(self, processed: Dict,\n",
                "                 start_date: datetime, end_date: datetime,\n",
                "                 max_open_trades: int = 0, position_stacking: bool = False,\n",
                "                 enable_protections: bool = False) -> Dict[str, Any]:\n",
                "        \"\"\"\n",
                "        Implement backtesting functionality\n",
                "\n",
                "        NOTE: This method is used by Hyperopt at each iteration. Please keep it optimized.\n",
                "        Of course try to not have ugly code. By some accessor are sometime slower than functions.\n",
                "        Avoid extensive logging in this method and functions it calls.\n",
                "\n",
                "        :param processed: a processed dictionary with format {pair, data}\n",
                "        :param start_date: backtesting timerange start datetime\n",
                "        :param end_date: backtesting timerange end datetime\n",
                "        :param max_open_trades: maximum number of concurrent trades, <= 0 means unlimited\n",
                "        :param position_stacking: do we allow position stacking?\n",
                "        :param enable_protections: Should protections be enabled?\n",
                "        :return: DataFrame with trades (results of backtesting)\n",
                "        \"\"\"\n",
                "        trades: List[LocalTrade] = []\n",
                "        self.prepare_backtest(enable_protections)\n",
                "\n",
                "        # Use dict of lists with data for performance\n",
                "        # (looping lists is a lot faster than pandas DataFrames)\n",
                "        data: Dict = self._get_ohlcv_as_lists(processed)\n",
                "\n",
                "        # Indexes per pair, so some pairs are allowed to have a missing start.\n",
                "        indexes: Dict = defaultdict(int)\n",
                "        tmp = start_date + timedelta(minutes=self.timeframe_min)\n",
                "\n",
                "        open_trades: Dict[str, List[LocalTrade]] = defaultdict(list)\n",
                "        open_trade_count = 0\n",
                "\n",
                "        self.progress.init_step(BacktestState.BACKTEST, int(\n",
                "            (end_date - start_date) / timedelta(minutes=self.timeframe_min)))\n",
                "\n",
                "        # Loop timerange and get candle for each pair at that point in time\n",
                "        while tmp <= end_date:\n",
                "            open_trade_count_start = open_trade_count\n",
                "            self.check_abort()\n",
                "            for i, pair in enumerate(data):\n",
                "                row_index = indexes[pair]\n",
                "                try:\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "                    # Row is treated as \"current incomplete candle\".\n",
                    "                    # Buy / sell signals are shifted by 1 to compensate for this.\n"
                ],
                "parent_version_range": {
                    "start": 468,
                    "end": 468
                },
                "child_version_range": {
                    "start": 468,
                    "end": 470
                },
                "control_flow": [
                    {
                        "type": "while_statement",
                        "statement": "while tmp <= end_date:",
                        "start_line": 462,
                        "end_line": 521
                    },
                    {
                        "type": "for_statement",
                        "statement": "for i, pair in enumerate(data):",
                        "start_line": 465,
                        "end_line": 517
                    },
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 467,
                        "end_line": 472
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Backtesting",
                        "signature": "class Backtesting:",
                        "at_line": 48
                    },
                    {
                        "type": "function",
                        "name": "backtest",
                        "signature": "def backtest(self, processed: Dict,\n                 start_date: datetime, end_date: datetime,\n                 max_open_trades: int = 0, position_stacking: bool = False,\n                 enable_protections: bool = False)->Dict[str, Any]:",
                        "at_line": 425
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: freqtrade/optimize/backtesting.py\nCode:\n           class Backtesting:\n               ...\n               def backtest(self, processed: Dict,\n                 start_date: datetime, end_date: datetime,\n                 max_open_trades: int = 0, position_stacking: bool = False,\n                 enable_protections: bool = False)->Dict[str, Any]:\n                   ...\n465 465                for i, pair in enumerate(data):\n466 466                    row_index = indexes[pair]\n467 467                    try:\n    468  +                     # Row is treated as \"current incomplete candle\".\n    469  +                     # Buy / sell signals are shifted by 1 to compensate for this.\n468 470                        row = data[pair][row_index]\n469 471                    except IndexError:\n470 472                        # missing Data for one pair at the end.\n         ...\n",
                "file_path": "freqtrade/optimize/backtesting.py",
                "identifiers_before": [],
                "identifiers_after": [],
                "prefix": [
                    "            for i, pair in enumerate(data):\n",
                    "                row_index = indexes[pair]\n",
                    "                try:\n"
                ],
                "suffix": [
                    "                    row = data[pair][row_index]\n",
                    "                except IndexError:\n",
                    "                    # missing Data for one pair at the end.\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                    row = data[pair][row_index]\n",
                "                except IndexError:\n",
                "                    # missing Data for one pair at the end.\n",
                "                    # Warnings for this are shown during data loading\n",
                "                    continue\n",
                "\n",
                "                # Waits until the time-counter reaches the start of the data for this pair.\n",
                "                if row[DATE_IDX] > tmp:\n",
                "                    continue\n",
                "\n"
            ],
            {
                "type": "delete",
                "before": [
                    "                row_index += 1\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 478,
                    "end": 479
                },
                "child_version_range": {
                    "start": 480,
                    "end": 480
                },
                "control_flow": [
                    {
                        "type": "while_statement",
                        "statement": "while tmp <= end_date:",
                        "start_line": 462,
                        "end_line": 521
                    },
                    {
                        "type": "for_statement",
                        "statement": "for i, pair in enumerate(data):",
                        "start_line": 465,
                        "end_line": 517
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Backtesting",
                        "signature": "class Backtesting:",
                        "at_line": 48
                    },
                    {
                        "type": "function",
                        "name": "backtest",
                        "signature": "def backtest(self, processed: Dict,\n                 start_date: datetime, end_date: datetime,\n                 max_open_trades: int = 0, position_stacking: bool = False,\n                 enable_protections: bool = False)->Dict[str, Any]:",
                        "at_line": 425
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: freqtrade/optimize/backtesting.py\nCode:\n           class Backtesting:\n               ...\n               def backtest(self, processed: Dict,\n                 start_date: datetime, end_date: datetime,\n                 max_open_trades: int = 0, position_stacking: bool = False,\n                 enable_protections: bool = False)->Dict[str, Any]:\n                   ...\n475 477                    if row[DATE_IDX] > tmp:\n476 478                        continue\n477 479    \n478      -                 row_index += 1\n479 480                    self.dataprovider._set_dataframe_max_index(row_index)\n         ...\n",
                "file_path": "freqtrade/optimize/backtesting.py",
                "identifiers_before": [
                    "row_index"
                ],
                "identifiers_after": [],
                "prefix": [
                    "                if row[DATE_IDX] > tmp:\n",
                    "                    continue\n",
                    "\n"
                ],
                "suffix": [
                    "                self.dataprovider._set_dataframe_max_index(row_index)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                self.dataprovider._set_dataframe_max_index(row_index)\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "                row_index += 1\n"
                ],
                "parent_version_range": {
                    "start": 480,
                    "end": 480
                },
                "child_version_range": {
                    "start": 481,
                    "end": 482
                },
                "control_flow": [
                    {
                        "type": "while_statement",
                        "statement": "while tmp <= end_date:",
                        "start_line": 462,
                        "end_line": 521
                    },
                    {
                        "type": "for_statement",
                        "statement": "for i, pair in enumerate(data):",
                        "start_line": 465,
                        "end_line": 517
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Backtesting",
                        "signature": "class Backtesting:",
                        "at_line": 48
                    },
                    {
                        "type": "function",
                        "name": "backtest",
                        "signature": "def backtest(self, processed: Dict,\n                 start_date: datetime, end_date: datetime,\n                 max_open_trades: int = 0, position_stacking: bool = False,\n                 enable_protections: bool = False)->Dict[str, Any]:",
                        "at_line": 425
                    },
                    {
                        "type": "call",
                        "name": "self.dataprovider._set_dataframe_max_index",
                        "signature": "self.dataprovider._set_dataframe_max_index(row_index)",
                        "at_line": 479,
                        "argument": "row_index"
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: freqtrade/optimize/backtesting.py\nCode:\n           class Backtesting:\n               ...\n               def backtest(self, processed: Dict,\n                 start_date: datetime, end_date: datetime,\n                 max_open_trades: int = 0, position_stacking: bool = False,\n                 enable_protections: bool = False)->Dict[str, Any]:\n                   ...\n479 480                    self.dataprovider._set_dataframe_max_index(row_index)\n    481  +                 row_index += 1\n480 482                    indexes[pair] = row_index\n481 483    \n482 484                    # without positionstacking, we can only have one open trade per pair.\n         ...\n",
                "file_path": "freqtrade/optimize/backtesting.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "row_index"
                ],
                "prefix": [
                    "                self.dataprovider._set_dataframe_max_index(row_index)\n"
                ],
                "suffix": [
                    "                indexes[pair] = row_index\n",
                    "\n",
                    "                # without positionstacking, we can only have one open trade per pair.\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                indexes[pair] = row_index\n",
                "\n",
                "                # without positionstacking, we can only have one open trade per pair.\n",
                "                # max_open_trades must be respected\n",
                "                # don't open on the last row\n",
                "                if (\n",
                "                    (position_stacking or len(open_trades[pair]) == 0)\n",
                "                    and self.trade_slot_available(max_open_trades, open_trade_count_start)\n",
                "                    and tmp != end_date\n",
                "                    and row[BUY_IDX] == 1\n",
                "                    and row[SELL_IDX] != 1\n",
                "                    and not PairLocks.is_pair_locked(pair, row[DATE_IDX])\n",
                "                ):\n",
                "                    trade = self._enter_trade(pair, row)\n",
                "                    if trade:\n",
                "                        # TODO: hacky workaround to avoid opening > max_open_trades\n",
                "                        # This emulates previous behaviour - not sure if this is correct\n",
                "                        # Prevents buying if the trade-slot was freed in this candle\n",
                "                        open_trade_count_start += 1\n",
                "                        open_trade_count += 1\n",
                "                        # logger.debug(f\"{pair} - Emulate creation of new trade: {trade}.\")\n",
                "                        open_trades[pair].append(trade)\n",
                "                        LocalTrade.add_bt_trade(trade)\n",
                "\n",
                "                for trade in open_trades[pair]:\n",
                "                    # also check the buying candle for sell conditions.\n",
                "                    trade_entry = self._get_sell_trade_entry(trade, row)\n",
                "                    # Sell occurred\n",
                "                    if trade_entry:\n",
                "                        # logger.debug(f\"{pair} - Backtesting sell {trade}\")\n",
                "                        open_trade_count -= 1\n",
                "                        open_trades[pair].remove(trade)\n",
                "\n",
                "                        LocalTrade.close_bt_trade(trade)\n",
                "                        trades.append(trade_entry)\n",
                "                        if enable_protections:\n",
                "                            self.protections.stop_per_pair(pair, row[DATE_IDX])\n",
                "                            self.protections.global_stop(tmp)\n",
                "\n",
                "            # Move time one configured time_interval ahead.\n",
                "            self.progress.increment()\n",
                "            tmp += timedelta(minutes=self.timeframe_min)\n",
                "\n",
                "        trades += self.handle_left_open(open_trades, data=data)\n",
                "        self.wallets.update()\n",
                "\n",
                "        results = trade_list_to_dataframe(trades)\n",
                "        return {\n",
                "            'results': results,\n",
                "            'config': self.strategy.config,\n",
                "            'locks': PairLocks.get_all_locks(),\n",
                "            'rejected_signals': self.rejected_trades,\n",
                "            'final_balance': self.wallets.get_total(self.strategy.config['stake_currency']),\n",
                "        }\n",
                "\n",
                "    def backtest_one_strategy(self, strat: IStrategy, data: Dict[str, DataFrame],\n",
                "                              timerange: TimeRange):\n",
                "        self.progress.init_step(BacktestState.ANALYZE, 0)\n",
                "\n",
                "        logger.info(\"Running backtesting for Strategy %s\", strat.get_strategy_name())\n",
                "        backtest_start_time = datetime.now(timezone.utc)\n",
                "        self._set_strategy(strat)\n",
                "\n",
                "        strategy_safe_wrapper(self.strategy.bot_loop_start, supress_error=True)()\n",
                "\n",
                "        # Use max_open_trades in backtesting, except --disable-max-market-positions is set\n",
                "        if self.config.get('use_max_market_positions', True):\n",
                "            # Must come from strategy config, as the strategy may modify this setting.\n",
                "            max_open_trades = self.strategy.config['max_open_trades']\n",
                "        else:\n",
                "            logger.info(\n",
                "                'Ignoring max_open_trades (--disable-max-market-positions was used) ...')\n",
                "            max_open_trades = 0\n",
                "\n",
                "        # need to reprocess data every time to populate signals\n",
                "        preprocessed = self.strategy.advise_all_indicators(data)\n",
                "\n",
                "        # Trim startup period from analyzed dataframe\n",
                "        preprocessed_tmp = trim_dataframes(preprocessed, timerange, self.required_startup)\n",
                "\n",
                "        if not preprocessed_tmp:\n",
                "            raise OperationalException(\n",
                "                \"No data left after adjusting for startup candles.\")\n",
                "\n",
                "        # Use preprocessed_tmp for date generation (the trimmed dataframe).\n",
                "        # Backtesting will re-trim the dataframes after buy/sell signal generation.\n",
                "        min_date, max_date = history.get_timerange(preprocessed_tmp)\n",
                "        logger.info(f'Backtesting with data from {min_date.strftime(DATETIME_PRINT_FORMAT)} '\n",
                "                    f'up to {max_date.strftime(DATETIME_PRINT_FORMAT)} '\n",
                "                    f'({(max_date - min_date).days} days).')\n",
                "        # Execute backtest and store results\n",
                "        results = self.backtest(\n",
                "            processed=preprocessed,\n",
                "            start_date=min_date,\n",
                "            end_date=max_date,\n",
                "            max_open_trades=max_open_trades,\n",
                "            position_stacking=self.config.get('position_stacking', False),\n",
                "            enable_protections=self.config.get('enable_protections', False),\n",
                "        )\n",
                "        backtest_end_time = datetime.now(timezone.utc)\n",
                "        results.update({\n",
                "            'backtest_start_time': int(backtest_start_time.timestamp()),\n",
                "            'backtest_end_time': int(backtest_end_time.timestamp()),\n",
                "        })\n",
                "        self.all_results[self.strategy.get_strategy_name()] = results\n",
                "\n",
                "        return min_date, max_date\n",
                "\n",
                "    def start(self) -> None:\n",
                "        \"\"\"\n",
                "        Run backtesting end-to-end\n",
                "        :return: None\n",
                "        \"\"\"\n",
                "        data: Dict[str, Any] = {}\n",
                "\n",
                "        data, timerange = self.load_bt_data()\n",
                "        logger.info(\"Dataload complete. Calculating indicators\")\n",
                "\n",
                "        for strat in self.strategylist:\n",
                "            min_date, max_date = self.backtest_one_strategy(strat, data, timerange)\n",
                "        if len(self.strategylist) > 0:\n",
                "\n",
                "            self.results = generate_backtest_stats(data, self.all_results,\n",
                "                                                   min_date=min_date, max_date=max_date)\n",
                "\n",
                "            if self.config.get('export', 'none') == 'trades':\n",
                "                store_backtest_stats(self.config['exportfilename'], self.results)\n",
                "\n",
                "            # Show backtest results\n",
                "            show_backtest_results(self.config, self.results)"
            ]
        ],
        "tests/optimize/test_backtesting.py": [
            [
                "# pragma pylint: disable=missing-docstring, W0212, line-too-long, C0103, unused-argument\n",
                "\n",
                "import random\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "from datetime import timedelta\n"
                ],
                "parent_version_range": {
                    "start": 3,
                    "end": 3
                },
                "child_version_range": {
                    "start": 3,
                    "end": 4
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 3,
                "hunk_diff": "File: tests/optimize/test_backtesting.py\nCode:\n  ...\n0 0    # pragma pylint: disable=missing-docstring, W0212, line-too-long, C0103, unused-argument\n1 1    \n2 2    import random\n  3  + from datetime import timedelta\n3 4    from pathlib import Path\n4 5    from unittest.mock import MagicMock, PropertyMock\n5 6    \n     ...\n",
                "file_path": "tests/optimize/test_backtesting.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "datetime",
                    "timedelta"
                ],
                "prefix": [
                    "# pragma pylint: disable=missing-docstring, W0212, line-too-long, C0103, unused-argument\n",
                    "\n",
                    "import random\n"
                ],
                "suffix": [
                    "from pathlib import Path\n",
                    "from unittest.mock import MagicMock, PropertyMock\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "timedelta",
                            "position": {
                                "start": {
                                    "line": 3,
                                    "column": 21
                                },
                                "end": {
                                    "line": 3,
                                    "column": 30
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/freqtrade/tests/optimize/test_backtesting.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "from pathlib import Path\n",
                "from unittest.mock import MagicMock, PropertyMock\n",
                "\n",
                "import numpy as np\n",
                "import pandas as pd\n",
                "import pytest\n",
                "from arrow import Arrow\n",
                "\n",
                "from freqtrade.commands.optimize_commands import setup_optimize_configuration, start_backtesting\n",
                "from freqtrade.configuration import TimeRange\n",
                "from freqtrade.data import history\n",
                "from freqtrade.data.btanalysis import BT_DATA_COLUMNS, evaluate_result_multi\n",
                "from freqtrade.data.converter import clean_ohlcv_dataframe\n",
                "from freqtrade.data.dataprovider import DataProvider\n",
                "from freqtrade.data.history import get_timerange\n",
                "from freqtrade.enums import RunMode, SellType\n",
                "from freqtrade.exceptions import DependencyException, OperationalException\n",
                "from freqtrade.optimize.backtesting import Backtesting\n",
                "from freqtrade.persistence import LocalTrade\n",
                "from freqtrade.resolvers import StrategyResolver\n",
                "from tests.conftest import (get_args, log_has, log_has_re, patch_exchange,\n",
                "                            patched_configuration_load_config_file)\n",
                "\n",
                "\n",
                "ORDER_TYPES = [\n",
                "    {\n",
                "        'buy': 'limit',\n",
                "        'sell': 'limit',\n",
                "        'stoploss': 'limit',\n",
                "        'stoploss_on_exchange': False\n",
                "    },\n",
                "    {\n",
                "        'buy': 'limit',\n",
                "        'sell': 'limit',\n",
                "        'stoploss': 'limit',\n",
                "        'stoploss_on_exchange': True\n",
                "    }]\n",
                "\n",
                "\n",
                "def trim_dictlist(dict_list, num):\n",
                "    new = {}\n",
                "    for pair, pair_data in dict_list.items():\n",
                "        new[pair] = pair_data[num:].reset_index()\n",
                "    return new\n",
                "\n",
                "\n",
                "def load_data_test(what, testdatadir):\n",
                "    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n",
                "    data = history.load_pair_history(pair='UNITTEST/BTC', datadir=testdatadir,\n",
                "                                     timeframe='1m', timerange=timerange,\n",
                "                                     drop_incomplete=False,\n",
                "                                     fill_up_missing=False)\n",
                "\n",
                "    base = 0.001\n",
                "    if what == 'raise':\n",
                "        data.loc[:, 'open'] = data.index * base\n",
                "        data.loc[:, 'high'] = data.index * base + 0.0001\n",
                "        data.loc[:, 'low'] = data.index * base - 0.0001\n",
                "        data.loc[:, 'close'] = data.index * base\n",
                "\n",
                "    if what == 'lower':\n",
                "        data.loc[:, 'open'] = 1 - data.index * base\n",
                "        data.loc[:, 'high'] = 1 - data.index * base + 0.0001\n",
                "        data.loc[:, 'low'] = 1 - data.index * base - 0.0001\n",
                "        data.loc[:, 'close'] = 1 - data.index * base\n",
                "\n",
                "    if what == 'sine':\n",
                "        hz = 0.1  # frequency\n",
                "        data.loc[:, 'open'] = np.sin(data.index * hz) / 1000 + base\n",
                "        data.loc[:, 'high'] = np.sin(data.index * hz) / 1000 + base + 0.0001\n",
                "        data.loc[:, 'low'] = np.sin(data.index * hz) / 1000 + base - 0.0001\n",
                "        data.loc[:, 'close'] = np.sin(data.index * hz) / 1000 + base\n",
                "\n",
                "    return {'UNITTEST/BTC': clean_ohlcv_dataframe(data, timeframe='1m', pair='UNITTEST/BTC',\n",
                "                                                  fill_missing=True)}\n",
                "\n",
                "\n",
                "def simple_backtest(config, contour, mocker, testdatadir) -> None:\n",
                "    patch_exchange(mocker)\n",
                "    config['timeframe'] = '1m'\n",
                "    backtesting = Backtesting(config)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "\n",
                "    data = load_data_test(contour, testdatadir)\n",
                "    processed = backtesting.strategy.advise_all_indicators(data)\n",
                "    min_date, max_date = get_timerange(processed)\n",
                "    assert isinstance(processed, dict)\n",
                "    results = backtesting.backtest(\n",
                "        processed=processed,\n",
                "        start_date=min_date,\n",
                "        end_date=max_date,\n",
                "        max_open_trades=1,\n",
                "        position_stacking=False,\n",
                "        enable_protections=config.get('enable_protections', False),\n",
                "    )\n",
                "    # results :: <class 'pandas.core.frame.DataFrame'>\n",
                "    return results\n",
                "\n",
                "\n",
                "# FIX: fixturize this?\n",
                "def _make_backtest_conf(mocker, datadir, conf=None, pair='UNITTEST/BTC'):\n",
                "    data = history.load_data(datadir=datadir, timeframe='1m', pairs=[pair])\n",
                "    data = trim_dictlist(data, -201)\n",
                "    patch_exchange(mocker)\n",
                "    backtesting = Backtesting(conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    processed = backtesting.strategy.advise_all_indicators(data)\n",
                "    min_date, max_date = get_timerange(processed)\n",
                "    return {\n",
                "        'processed': processed,\n",
                "        'start_date': min_date,\n",
                "        'end_date': max_date,\n",
                "        'max_open_trades': 10,\n",
                "        'position_stacking': False,\n",
                "    }\n",
                "\n",
                "\n",
                "def _trend(signals, buy_value, sell_value):\n",
                "    n = len(signals['low'])\n",
                "    buy = np.zeros(n)\n",
                "    sell = np.zeros(n)\n",
                "    for i in range(0, len(signals['buy'])):\n",
                "        if random.random() > 0.5:  # Both buy and sell signals at same timeframe\n",
                "            buy[i] = buy_value\n",
                "            sell[i] = sell_value\n",
                "    signals['buy'] = buy\n",
                "    signals['sell'] = sell\n",
                "    return signals\n",
                "\n",
                "\n",
                "def _trend_alternate(dataframe=None, metadata=None):\n",
                "    signals = dataframe\n",
                "    low = signals['low']\n",
                "    n = len(low)\n",
                "    buy = np.zeros(n)\n",
                "    sell = np.zeros(n)\n",
                "    for i in range(0, len(buy)):\n",
                "        if i % 2 == 0:\n",
                "            buy[i] = 1\n",
                "        else:\n",
                "            sell[i] = 1\n",
                "    signals['buy'] = buy\n",
                "    signals['sell'] = sell\n",
                "    return dataframe\n",
                "\n",
                "\n",
                "# Unit tests\n",
                "def test_setup_optimize_configuration_without_arguments(mocker, default_conf, caplog) -> None:\n",
                "    patched_configuration_load_config_file(mocker, default_conf)\n",
                "\n",
                "    args = [\n",
                "        'backtesting',\n",
                "        '--config', 'config.json',\n",
                "        '--strategy', 'DefaultStrategy',\n",
                "        '--export', 'none'\n",
                "    ]\n",
                "\n",
                "    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n",
                "    assert 'max_open_trades' in config\n",
                "    assert 'stake_currency' in config\n",
                "    assert 'stake_amount' in config\n",
                "    assert 'exchange' in config\n",
                "    assert 'pair_whitelist' in config['exchange']\n",
                "    assert 'datadir' in config\n",
                "    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n",
                "    assert 'timeframe' in config\n",
                "    assert not log_has_re('Parameter -i/--ticker-interval detected .*', caplog)\n",
                "\n",
                "    assert 'position_stacking' not in config\n",
                "    assert not log_has('Parameter --enable-position-stacking detected ...', caplog)\n",
                "\n",
                "    assert 'timerange' not in config\n",
                "    assert 'export' in config\n",
                "    assert config['export'] == 'none'\n",
                "    assert 'runmode' in config\n",
                "    assert config['runmode'] == RunMode.BACKTEST\n",
                "\n",
                "\n",
                "def test_setup_bt_configuration_with_arguments(mocker, default_conf, caplog) -> None:\n",
                "    patched_configuration_load_config_file(mocker, default_conf)\n",
                "    mocker.patch(\n",
                "        'freqtrade.configuration.configuration.create_datadir',\n",
                "        lambda c, x: x\n",
                "    )\n",
                "\n",
                "    args = [\n",
                "        'backtesting',\n",
                "        '--config', 'config.json',\n",
                "        '--strategy', 'DefaultStrategy',\n",
                "        '--datadir', '/foo/bar',\n",
                "        '--timeframe', '1m',\n",
                "        '--enable-position-stacking',\n",
                "        '--disable-max-market-positions',\n",
                "        '--timerange', ':100',\n",
                "        '--export-filename', 'foo_bar.json',\n",
                "        '--fee', '0',\n",
                "    ]\n",
                "\n",
                "    config = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n",
                "    assert 'max_open_trades' in config\n",
                "    assert 'stake_currency' in config\n",
                "    assert 'stake_amount' in config\n",
                "    assert 'exchange' in config\n",
                "    assert 'pair_whitelist' in config['exchange']\n",
                "    assert 'datadir' in config\n",
                "    assert config['runmode'] == RunMode.BACKTEST\n",
                "\n",
                "    assert log_has('Using data directory: {} ...'.format(config['datadir']), caplog)\n",
                "    assert 'timeframe' in config\n",
                "    assert log_has('Parameter -i/--timeframe detected ... Using timeframe: 1m ...',\n",
                "                   caplog)\n",
                "\n",
                "    assert 'position_stacking' in config\n",
                "    assert log_has('Parameter --enable-position-stacking detected ...', caplog)\n",
                "\n",
                "    assert 'use_max_market_positions' in config\n",
                "    assert log_has('Parameter --disable-max-market-positions detected ...', caplog)\n",
                "    assert log_has('max_open_trades set to unlimited ...', caplog)\n",
                "\n",
                "    assert 'timerange' in config\n",
                "    assert log_has('Parameter --timerange detected: {} ...'.format(config['timerange']), caplog)\n",
                "\n",
                "    assert 'export' in config\n",
                "    assert 'exportfilename' in config\n",
                "    assert isinstance(config['exportfilename'], Path)\n",
                "    assert log_has('Storing backtest results to {} ...'.format(config['exportfilename']), caplog)\n",
                "\n",
                "    assert 'fee' in config\n",
                "    assert log_has('Parameter --fee detected, setting fee to: {} ...'.format(config['fee']), caplog)\n",
                "\n",
                "\n",
                "def test_setup_optimize_configuration_stake_amount(mocker, default_conf, caplog) -> None:\n",
                "\n",
                "    patched_configuration_load_config_file(mocker, default_conf)\n",
                "\n",
                "    args = [\n",
                "        'backtesting',\n",
                "        '--config', 'config.json',\n",
                "        '--strategy', 'DefaultStrategy',\n",
                "        '--stake-amount', '1',\n",
                "        '--starting-balance', '2'\n",
                "    ]\n",
                "\n",
                "    conf = setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n",
                "    assert isinstance(conf, dict)\n",
                "\n",
                "    args = [\n",
                "        'backtesting',\n",
                "        '--config', 'config.json',\n",
                "        '--strategy', 'DefaultStrategy',\n",
                "        '--stake-amount', '1',\n",
                "        '--starting-balance', '0.5'\n",
                "    ]\n",
                "    with pytest.raises(OperationalException, match=r\"Starting balance .* smaller .*\"):\n",
                "        setup_optimize_configuration(get_args(args), RunMode.BACKTEST)\n",
                "\n",
                "\n",
                "def test_start(mocker, fee, default_conf, caplog) -> None:\n",
                "    start_mock = MagicMock()\n",
                "    mocker.patch('freqtrade.exchange.Exchange.get_fee', fee)\n",
                "    patch_exchange(mocker)\n",
                "    mocker.patch('freqtrade.optimize.backtesting.Backtesting.start', start_mock)\n",
                "    patched_configuration_load_config_file(mocker, default_conf)\n",
                "\n",
                "    args = [\n",
                "        'backtesting',\n",
                "        '--config', 'config.json',\n",
                "        '--strategy', 'DefaultStrategy',\n",
                "    ]\n",
                "    pargs = get_args(args)\n",
                "    start_backtesting(pargs)\n",
                "    assert log_has('Starting freqtrade in Backtesting mode', caplog)\n",
                "    assert start_mock.call_count == 1\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\"order_types\", ORDER_TYPES)\n",
                "def test_backtesting_init(mocker, default_conf, order_types) -> None:\n",
                "    \"\"\"\n",
                "    Check that stoploss_on_exchange is set to False while backtesting\n",
                "    since backtesting assumes a perfect stoploss anyway.\n",
                "    \"\"\"\n",
                "    default_conf[\"order_types\"] = order_types\n",
                "    patch_exchange(mocker)\n",
                "    get_fee = mocker.patch('freqtrade.exchange.Exchange.get_fee', MagicMock(return_value=0.5))\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    assert backtesting.config == default_conf\n",
                "    assert backtesting.timeframe == '5m'\n",
                "    assert callable(backtesting.strategy.advise_all_indicators)\n",
                "    assert callable(backtesting.strategy.advise_buy)\n",
                "    assert callable(backtesting.strategy.advise_sell)\n",
                "    assert isinstance(backtesting.strategy.dp, DataProvider)\n",
                "    get_fee.assert_called()\n",
                "    assert backtesting.fee == 0.5\n",
                "    assert not backtesting.strategy.order_types[\"stoploss_on_exchange\"]\n",
                "\n",
                "\n",
                "def test_backtesting_init_no_timeframe(mocker, default_conf, caplog) -> None:\n",
                "    patch_exchange(mocker)\n",
                "    del default_conf['timeframe']\n",
                "    default_conf['strategy_list'] = ['DefaultStrategy',\n",
                "                                     'SampleStrategy']\n",
                "\n",
                "    mocker.patch('freqtrade.exchange.Exchange.get_fee', MagicMock(return_value=0.5))\n",
                "    with pytest.raises(OperationalException):\n",
                "        Backtesting(default_conf)\n",
                "    log_has(\"Ticker-interval needs to be set in either configuration \"\n",
                "            \"or as cli argument `--ticker-interval 5m`\", caplog)\n",
                "\n",
                "\n",
                "def test_data_with_fee(default_conf, mocker, testdatadir) -> None:\n",
                "    patch_exchange(mocker)\n",
                "    default_conf['fee'] = 0.1234\n",
                "\n",
                "    fee_mock = mocker.patch('freqtrade.exchange.Exchange.get_fee', MagicMock(return_value=0.5))\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    assert backtesting.fee == 0.1234\n",
                "    assert fee_mock.call_count == 0\n",
                "\n",
                "    default_conf['fee'] = 0.0\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    assert backtesting.fee == 0.0\n",
                "    assert fee_mock.call_count == 0\n",
                "\n",
                "\n",
                "def test_data_to_dataframe_bt(default_conf, mocker, testdatadir) -> None:\n",
                "    patch_exchange(mocker)\n",
                "    timerange = TimeRange.parse_timerange('1510694220-1510700340')\n",
                "    data = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange,\n",
                "                             fill_up_missing=True)\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    processed = backtesting.strategy.advise_all_indicators(data)\n",
                "    assert len(processed['UNITTEST/BTC']) == 102\n",
                "\n",
                "    # Load strategy to compare the result between Backtesting function and strategy are the same\n",
                "    default_conf.update({'strategy': 'DefaultStrategy'})\n",
                "    strategy = StrategyResolver.load_strategy(default_conf)\n",
                "\n",
                "    processed2 = strategy.advise_all_indicators(data)\n",
                "    assert processed['UNITTEST/BTC'].equals(processed2['UNITTEST/BTC'])\n",
                "\n",
                "\n",
                "def test_backtest_abort(default_conf, mocker, testdatadir) -> None:\n",
                "    patch_exchange(mocker)\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting.check_abort()\n",
                "\n",
                "    backtesting.abort = True\n",
                "\n",
                "    with pytest.raises(DependencyException, match=\"Stop requested\"):\n",
                "        backtesting.check_abort()\n",
                "    # abort flag resets\n",
                "    assert backtesting.abort is False\n",
                "    assert backtesting.progress.progress == 0\n",
                "\n",
                "\n",
                "def test_backtesting_start(default_conf, mocker, testdatadir, caplog) -> None:\n",
                "    def get_timerange(input1):\n",
                "        return Arrow(2017, 11, 14, 21, 17), Arrow(2017, 11, 14, 22, 59)\n",
                "\n",
                "    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n",
                "    patch_exchange(mocker)\n",
                "    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n",
                "    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n",
                "    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n",
                "    sbs = mocker.patch('freqtrade.optimize.backtesting.store_backtest_stats')\n",
                "    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist',\n",
                "                 PropertyMock(return_value=['UNITTEST/BTC']))\n",
                "\n",
                "    default_conf['timeframe'] = '1m'\n",
                "    default_conf['datadir'] = testdatadir\n",
                "    default_conf['export'] = 'trades'\n",
                "    default_conf['exportfilename'] = 'export.txt'\n",
                "    default_conf['timerange'] = '-1510694220'\n",
                "\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    backtesting.strategy.bot_loop_start = MagicMock()\n",
                "    backtesting.start()\n",
                "    # check the logs, that will contain the backtest result\n",
                "    exists = [\n",
                "        'Backtesting with data from 2017-11-14 21:17:00 '\n",
                "        'up to 2017-11-14 22:59:00 (0 days).'\n",
                "    ]\n",
                "    for line in exists:\n",
                "        assert log_has(line, caplog)\n",
                "    assert backtesting.strategy.dp._pairlists is not None\n",
                "    assert backtesting.strategy.bot_loop_start.call_count == 1\n",
                "    assert sbs.call_count == 1\n",
                "\n",
                "\n",
                "def test_backtesting_start_no_data(default_conf, mocker, caplog, testdatadir) -> None:\n",
                "    def get_timerange(input1):\n",
                "        return Arrow(2017, 11, 14, 21, 17), Arrow(2017, 11, 14, 22, 59)\n",
                "\n",
                "    mocker.patch('freqtrade.data.history.history_utils.load_pair_history',\n",
                "                 MagicMock(return_value=pd.DataFrame()))\n",
                "    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n",
                "    patch_exchange(mocker)\n",
                "    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n",
                "    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist',\n",
                "                 PropertyMock(return_value=['UNITTEST/BTC']))\n",
                "\n",
                "    default_conf['timeframe'] = \"1m\"\n",
                "    default_conf['datadir'] = testdatadir\n",
                "    default_conf['export'] = 'none'\n",
                "    default_conf['timerange'] = '20180101-20180102'\n",
                "\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    with pytest.raises(OperationalException, match='No data found. Terminating.'):\n",
                "        backtesting.start()\n",
                "\n",
                "\n",
                "def test_backtesting_no_pair_left(default_conf, mocker, caplog, testdatadir) -> None:\n",
                "    mocker.patch('freqtrade.exchange.Exchange.exchange_has', MagicMock(return_value=True))\n",
                "    mocker.patch('freqtrade.data.history.history_utils.load_pair_history',\n",
                "                 MagicMock(return_value=pd.DataFrame()))\n",
                "    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n",
                "    patch_exchange(mocker)\n",
                "    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n",
                "    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist',\n",
                "                 PropertyMock(return_value=[]))\n",
                "\n",
                "    default_conf['timeframe'] = \"1m\"\n",
                "    default_conf['datadir'] = testdatadir\n",
                "    default_conf['export'] = 'none'\n",
                "    default_conf['timerange'] = '20180101-20180102'\n",
                "\n",
                "    with pytest.raises(OperationalException, match='No pair in whitelist.'):\n",
                "        Backtesting(default_conf)\n",
                "\n",
                "    default_conf['pairlists'] = [{\"method\": \"VolumePairList\", \"number_assets\": 5}]\n",
                "    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting.'):\n",
                "        Backtesting(default_conf)\n",
                "\n",
                "\n",
                "def test_backtesting_pairlist_list(default_conf, mocker, caplog, testdatadir, tickers) -> None:\n",
                "    mocker.patch('freqtrade.exchange.Exchange.exchange_has', MagicMock(return_value=True))\n",
                "    mocker.patch('freqtrade.exchange.Exchange.get_tickers', tickers)\n",
                "    mocker.patch('freqtrade.exchange.Exchange.price_to_precision', lambda s, x, y: y)\n",
                "    mocker.patch('freqtrade.data.history.get_timerange', get_timerange)\n",
                "    patch_exchange(mocker)\n",
                "    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n",
                "    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist',\n",
                "                 PropertyMock(return_value=['XRP/BTC']))\n",
                "    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.refresh_pairlist')\n",
                "\n",
                "    default_conf['ticker_interval'] = \"1m\"\n",
                "    default_conf['datadir'] = testdatadir\n",
                "    default_conf['export'] = 'none'\n",
                "    # Use stoploss from strategy\n",
                "    del default_conf['stoploss']\n",
                "    default_conf['timerange'] = '20180101-20180102'\n",
                "\n",
                "    default_conf['pairlists'] = [{\"method\": \"VolumePairList\", \"number_assets\": 5}]\n",
                "    with pytest.raises(OperationalException, match='VolumePairList not allowed for backtesting.'):\n",
                "        Backtesting(default_conf)\n",
                "\n",
                "    default_conf['pairlists'] = [{\"method\": \"StaticPairList\"}, {\"method\": \"PerformanceFilter\"}]\n",
                "    with pytest.raises(OperationalException,\n",
                "                       match='PerformanceFilter not allowed for backtesting.'):\n",
                "        Backtesting(default_conf)\n",
                "\n",
                "    default_conf['pairlists'] = [{\"method\": \"StaticPairList\"}, {\"method\": \"PrecisionFilter\"}, ]\n",
                "    Backtesting(default_conf)\n",
                "\n",
                "    # Multiple strategies\n",
                "    default_conf['strategy_list'] = ['DefaultStrategy', 'TestStrategyLegacy']\n",
                "    with pytest.raises(OperationalException,\n",
                "                       match='PrecisionFilter not allowed for backtesting multiple strategies.'):\n",
                "        Backtesting(default_conf)\n",
                "\n",
                "\n",
                "def test_backtest__enter_trade(default_conf, fee, mocker) -> None:\n",
                "    default_conf['use_sell_signal'] = False\n",
                "    mocker.patch('freqtrade.exchange.Exchange.get_fee', fee)\n",
                "    mocker.patch(\"freqtrade.exchange.Exchange.get_min_pair_stake_amount\", return_value=0.00001)\n",
                "    patch_exchange(mocker)\n",
                "    default_conf['stake_amount'] = 'unlimited'\n",
                "    default_conf['max_open_trades'] = 2\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    pair = 'UNITTEST/BTC'\n",
                "    row = [\n",
                "        pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0),\n",
                "        1,  # Sell\n",
                "        0.001,  # Open\n",
                "        0.0011,  # Close\n",
                "        0,  # Sell\n",
                "        0.00099,  # Low\n",
                "        0.0012,  # High\n",
                "        '',  # Buy Signal Name\n",
                "    ]\n",
                "    trade = backtesting._enter_trade(pair, row=row)\n",
                "    assert isinstance(trade, LocalTrade)\n",
                "    assert trade.stake_amount == 495\n",
                "\n",
                "    # Fake 2 trades, so there's not enough amount for the next trade left.\n",
                "    LocalTrade.trades_open.append(trade)\n",
                "    LocalTrade.trades_open.append(trade)\n",
                "    trade = backtesting._enter_trade(pair, row=row)\n",
                "    assert trade is None\n",
                "    LocalTrade.trades_open.pop()\n",
                "    trade = backtesting._enter_trade(pair, row=row)\n",
                "    assert trade is not None\n",
                "\n",
                "    backtesting.strategy.custom_stake_amount = lambda **kwargs: 123.5\n",
                "    trade = backtesting._enter_trade(pair, row=row)\n",
                "    assert trade\n",
                "    assert trade.stake_amount == 123.5\n",
                "\n",
                "    # In case of error - use proposed stake\n",
                "    backtesting.strategy.custom_stake_amount = lambda **kwargs: 20 / 0\n",
                "    trade = backtesting._enter_trade(pair, row=row)\n",
                "    assert trade\n",
                "    assert trade.stake_amount == 495\n",
                "\n",
                "    # Stake-amount too high!\n",
                "    mocker.patch(\"freqtrade.exchange.Exchange.get_min_pair_stake_amount\", return_value=600.0)\n",
                "\n",
                "    trade = backtesting._enter_trade(pair, row=row)\n",
                "    assert trade is None\n",
                "\n",
                "    # Stake-amount throwing error\n",
                "    mocker.patch(\"freqtrade.wallets.Wallets.get_trade_stake_amount\",\n",
                "                 side_effect=DependencyException)\n",
                "\n",
                "    trade = backtesting._enter_trade(pair, row=row)\n",
                "    assert trade is None\n",
                "\n",
                "    backtesting.cleanup()\n",
                "\n",
                "\n",
                "def test_backtest_one(default_conf, fee, mocker, testdatadir) -> None:\n",
                "    default_conf['use_sell_signal'] = False\n",
                "    mocker.patch('freqtrade.exchange.Exchange.get_fee', fee)\n",
                "    mocker.patch(\"freqtrade.exchange.Exchange.get_min_pair_stake_amount\", return_value=0.00001)\n",
                "    patch_exchange(mocker)\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    pair = 'UNITTEST/BTC'\n",
                "    timerange = TimeRange('date', None, 1517227800, 0)\n",
                "    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'],\n",
                "                             timerange=timerange)\n",
                "    processed = backtesting.strategy.advise_all_indicators(data)\n",
                "    min_date, max_date = get_timerange(processed)\n",
                "    result = backtesting.backtest(\n",
                "        processed=processed,\n",
                "        start_date=min_date,\n",
                "        end_date=max_date,\n",
                "        max_open_trades=10,\n",
                "        position_stacking=False,\n",
                "    )\n",
                "    results = result['results']\n",
                "    assert not results.empty\n",
                "    assert len(results) == 2\n",
                "\n",
                "    expected = pd.DataFrame(\n",
                "        {'pair': [pair, pair],\n",
                "         'stake_amount': [0.001, 0.001],\n",
                "         'amount': [0.00957442, 0.0097064],\n",
                "         'open_date': pd.to_datetime([Arrow(2018, 1, 29, 18, 40, 0).datetime,\n",
                "                                      Arrow(2018, 1, 30, 3, 30, 0).datetime], utc=True\n",
                "                                     ),\n",
                "         'close_date': pd.to_datetime([Arrow(2018, 1, 29, 22, 35, 0).datetime,\n",
                "                                       Arrow(2018, 1, 30, 4, 10, 0).datetime], utc=True),\n",
                "         'open_rate': [0.104445, 0.10302485],\n",
                "         'close_rate': [0.104969, 0.103541],\n",
                "         'fee_open': [0.0025, 0.0025],\n",
                "         'fee_close': [0.0025, 0.0025],\n",
                "         'trade_duration': [235, 40],\n",
                "         'profit_ratio': [0.0, 0.0],\n",
                "         'profit_abs': [0.0, 0.0],\n",
                "         'sell_reason': [SellType.ROI.value, SellType.ROI.value],\n",
                "         'initial_stop_loss_abs': [0.0940005, 0.09272236],\n",
                "         'initial_stop_loss_ratio': [-0.1, -0.1],\n",
                "         'stop_loss_abs': [0.0940005, 0.09272236],\n",
                "         'stop_loss_ratio': [-0.1, -0.1],\n",
                "         'min_rate': [0.1038, 0.10302485],\n",
                "         'max_rate': [0.10501, 0.1038888],\n",
                "         'is_open': [False, False],\n",
                "         'buy_tag': [None, None],\n",
                "         })\n",
                "    pd.testing.assert_frame_equal(results, expected)\n",
                "    data_pair = processed[pair]\n",
                "    for _, t in results.iterrows():\n",
                "        ln = data_pair.loc[data_pair[\"date\"] == t[\"open_date\"]]\n",
                "        # Check open trade rate alignes to open rate\n",
                "        assert ln is not None\n",
                "        assert round(ln.iloc[0][\"open\"], 6) == round(t[\"open_rate\"], 6)\n",
                "        # check close trade rate alignes to close rate or is between high and low\n",
                "        ln = data_pair.loc[data_pair[\"date\"] == t[\"close_date\"]]\n",
                "        assert (round(ln.iloc[0][\"open\"], 6) == round(t[\"close_rate\"], 6) or\n",
                "                round(ln.iloc[0][\"low\"], 6) < round(\n",
                "                t[\"close_rate\"], 6) < round(ln.iloc[0][\"high\"], 6))\n",
                "\n",
                "\n",
                "def test_backtest_1min_timeframe(default_conf, fee, mocker, testdatadir) -> None:\n",
                "    default_conf['use_sell_signal'] = False\n",
                "    mocker.patch('freqtrade.exchange.Exchange.get_fee', fee)\n",
                "    mocker.patch(\"freqtrade.exchange.Exchange.get_min_pair_stake_amount\", return_value=0.00001)\n",
                "    patch_exchange(mocker)\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "\n",
                "    # Run a backtesting for an exiting 1min timeframe\n",
                "    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n",
                "    data = history.load_data(datadir=testdatadir, timeframe='1m', pairs=['UNITTEST/BTC'],\n",
                "                             timerange=timerange)\n",
                "    processed = backtesting.strategy.advise_all_indicators(data)\n",
                "    min_date, max_date = get_timerange(processed)\n",
                "    results = backtesting.backtest(\n",
                "        processed=processed,\n",
                "        start_date=min_date,\n",
                "        end_date=max_date,\n",
                "        max_open_trades=1,\n",
                "        position_stacking=False,\n",
                "    )\n",
                "    assert not results['results'].empty\n",
                "    assert len(results['results']) == 1\n",
                "\n",
                "\n",
                "def test_processed(default_conf, mocker, testdatadir) -> None:\n",
                "    patch_exchange(mocker)\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "\n",
                "    dict_of_tickerrows = load_data_test('raise', testdatadir)\n",
                "    dataframes = backtesting.strategy.advise_all_indicators(dict_of_tickerrows)\n",
                "    dataframe = dataframes['UNITTEST/BTC']\n",
                "    cols = dataframe.columns\n",
                "    # assert the dataframe got some of the indicator columns\n",
                "    for col in ['close', 'high', 'low', 'open', 'date',\n",
                "                'ema10', 'rsi', 'fastd', 'plus_di']:\n",
                "        assert col in cols\n",
                "\n",
                "\n",
                "def test_backtest_pricecontours_protections(default_conf, fee, mocker, testdatadir) -> None:\n",
                "    # While this test IS a copy of test_backtest_pricecontours, it's needed to ensure\n",
                "    # results do not carry-over to the next run, which is not given by using parametrize.\n",
                "    default_conf['protections'] = [\n",
                "        {\n",
                "            \"method\": \"CooldownPeriod\",\n",
                "            \"stop_duration\": 3,\n",
                "        }]\n",
                "\n",
                "    default_conf['enable_protections'] = True\n",
                "    mocker.patch('freqtrade.exchange.Exchange.get_fee', fee)\n",
                "    mocker.patch(\"freqtrade.exchange.Exchange.get_min_pair_stake_amount\", return_value=0.00001)\n",
                "    tests = [\n",
                "        ['sine', 9],\n",
                "        ['raise', 10],\n",
                "        ['lower', 0],\n",
                "        ['sine', 9],\n",
                "        ['raise', 10],\n",
                "    ]\n",
                "    # While buy-signals are unrealistic, running backtesting\n",
                "    # over and over again should not cause different results\n",
                "    for [contour, numres] in tests:\n",
                "        assert len(simple_backtest(default_conf, contour, mocker, testdatadir)['results']) == numres\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize('protections,contour,expected', [\n",
                "    (None, 'sine', 35),\n",
                "    (None, 'raise', 19),\n",
                "    (None, 'lower', 0),\n",
                "    (None, 'sine', 35),\n",
                "    (None, 'raise', 19),\n",
                "    ([{\"method\": \"CooldownPeriod\", \"stop_duration\": 3}], 'sine', 9),\n",
                "    ([{\"method\": \"CooldownPeriod\", \"stop_duration\": 3}], 'raise', 10),\n",
                "    ([{\"method\": \"CooldownPeriod\", \"stop_duration\": 3}], 'lower', 0),\n",
                "    ([{\"method\": \"CooldownPeriod\", \"stop_duration\": 3}], 'sine', 9),\n",
                "    ([{\"method\": \"CooldownPeriod\", \"stop_duration\": 3}], 'raise', 10),\n",
                "])\n",
                "def test_backtest_pricecontours(default_conf, fee, mocker, testdatadir,\n",
                "                                protections, contour, expected) -> None:\n",
                "    if protections:\n",
                "        default_conf['protections'] = protections\n",
                "        default_conf['enable_protections'] = True\n",
                "\n",
                "    mocker.patch(\"freqtrade.exchange.Exchange.get_min_pair_stake_amount\", return_value=0.00001)\n",
                "    mocker.patch('freqtrade.exchange.Exchange.get_fee', fee)\n",
                "    # While buy-signals are unrealistic, running backtesting\n",
                "    # over and over again should not cause different results\n",
                "    assert len(simple_backtest(default_conf, contour, mocker, testdatadir)['results']) == expected\n",
                "\n",
                "\n",
                "def test_backtest_clash_buy_sell(mocker, default_conf, testdatadir):\n",
                "    # Override the default buy trend function in our default_strategy\n",
                "    def fun(dataframe=None, pair=None):\n",
                "        buy_value = 1\n",
                "        sell_value = 1\n",
                "        return _trend(dataframe, buy_value, sell_value)\n",
                "\n",
                "    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    backtesting.strategy.advise_buy = fun  # Override\n",
                "    backtesting.strategy.advise_sell = fun  # Override\n",
                "    result = backtesting.backtest(**backtest_conf)\n",
                "    assert result['results'].empty\n",
                "\n",
                "\n",
                "def test_backtest_only_sell(mocker, default_conf, testdatadir):\n",
                "    # Override the default buy trend function in our default_strategy\n",
                "    def fun(dataframe=None, pair=None):\n",
                "        buy_value = 0\n",
                "        sell_value = 1\n",
                "        return _trend(dataframe, buy_value, sell_value)\n",
                "\n",
                "    backtest_conf = _make_backtest_conf(mocker, conf=default_conf, datadir=testdatadir)\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    backtesting.strategy.advise_buy = fun  # Override\n",
                "    backtesting.strategy.advise_sell = fun  # Override\n",
                "    result = backtesting.backtest(**backtest_conf)\n",
                "    assert result['results'].empty\n",
                "\n",
                "\n",
                "def test_backtest_alternate_buy_sell(default_conf, fee, mocker, testdatadir):\n",
                "    mocker.patch(\"freqtrade.exchange.Exchange.get_min_pair_stake_amount\", return_value=0.00001)\n",
                "    mocker.patch('freqtrade.exchange.Exchange.get_fee', fee)\n",
                "    backtest_conf = _make_backtest_conf(mocker, conf=default_conf,\n",
                "                                        pair='UNITTEST/BTC', datadir=testdatadir)\n",
                "    default_conf['timeframe'] = '1m'\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting.required_startup = 0\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    backtesting.strategy.advise_buy = _trend_alternate  # Override\n",
                "    backtesting.strategy.advise_sell = _trend_alternate  # Override\n",
                "    result = backtesting.backtest(**backtest_conf)\n",
                "    # 200 candles in backtest data\n",
                "    # won't buy on first (shifted by 1)\n",
                "    # 100 buys signals\n",
                "    results = result['results']\n",
                "    assert len(results) == 100\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    # Cached data should be 200 (no change since required_startup is 0)\n",
                    "    assert len(backtesting.dataprovider.get_analyzed_dataframe('UNITTEST/BTC', '1m')[0]) == 200\n"
                ],
                "after": [
                    "    # Cached data should be 199 (missing 1 candle at the start)\n",
                    "    analyzed_df = backtesting.dataprovider.get_analyzed_dataframe('UNITTEST/BTC', '1m')[0]\n",
                    "    assert len(analyzed_df) == 199\n",
                    "    # Expect last candle to be 1 below end date (as the last candle is assumed as \"incomplete\"\n",
                    "    # during backtesting)\n",
                    "    expected_last_candle_date = backtest_conf['end_date'] - timedelta(minutes=1)\n",
                    "    assert analyzed_df.iloc[-1]['date'].to_pydatetime() == expected_last_candle_date\n"
                ],
                "parent_version_range": {
                    "start": 743,
                    "end": 745
                },
                "child_version_range": {
                    "start": 744,
                    "end": 751
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_backtest_alternate_buy_sell",
                        "signature": "def test_backtest_alternate_buy_sell(default_conf, fee, mocker, testdatadir):",
                        "at_line": 726
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: tests/optimize/test_backtesting.py\nCode:\n           def test_backtest_alternate_buy_sell(default_conf, fee, mocker, testdatadir):\n               ...\n740 741        # 100 buys signals\n741 742        results = result['results']\n742 743        assert len(results) == 100\n743      -     # Cached data should be 200 (no change since required_startup is 0)\n744      -     assert len(backtesting.dataprovider.get_analyzed_dataframe('UNITTEST/BTC', '1m')[0]) == 200\n    744  +     # Cached data should be 199 (missing 1 candle at the start)\n    745  +     analyzed_df = backtesting.dataprovider.get_analyzed_dataframe('UNITTEST/BTC', '1m')[0]\n    746  +     assert len(analyzed_df) == 199\n    747  +     # Expect last candle to be 1 below end date (as the last candle is assumed as \"incomplete\"\n    748  +     # during backtesting)\n    749  +     expected_last_candle_date = backtest_conf['end_date'] - timedelta(minutes=1)\n    750  +     assert analyzed_df.iloc[-1]['date'].to_pydatetime() == expected_last_candle_date\n745 751    \n746 752        # One trade was force-closed at the end\n747 753        assert len(results.loc[results['is_open']]) == 0\n         ...\n",
                "file_path": "tests/optimize/test_backtesting.py",
                "identifiers_before": [
                    "backtesting",
                    "dataprovider",
                    "get_analyzed_dataframe",
                    "len"
                ],
                "identifiers_after": [
                    "analyzed_df",
                    "backtest_conf",
                    "backtesting",
                    "dataprovider",
                    "expected_last_candle_date",
                    "get_analyzed_dataframe",
                    "iloc",
                    "len",
                    "minutes",
                    "timedelta",
                    "to_pydatetime"
                ],
                "prefix": [
                    "    # 100 buys signals\n",
                    "    results = result['results']\n",
                    "    assert len(results) == 100\n"
                ],
                "suffix": [
                    "\n",
                    "    # One trade was force-closed at the end\n",
                    "    assert len(results.loc[results['is_open']]) == 0\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "timedelta",
                            "position": {
                                "start": {
                                    "line": 749,
                                    "column": 60
                                },
                                "end": {
                                    "line": 749,
                                    "column": 69
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/freqtrade/tests/optimize/test_backtesting.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "    # One trade was force-closed at the end\n",
                "    assert len(results.loc[results['is_open']]) == 0\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\"pair\", ['ADA/BTC', 'LTC/BTC'])\n",
                "@pytest.mark.parametrize(\"tres\", [0, 20, 30])\n",
                "def test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):\n",
                "\n",
                "    def _trend_alternate_hold(dataframe=None, metadata=None):\n",
                "        \"\"\"\n",
                "        Buy every xth candle - sell every other xth -2 (hold on to pairs a bit)\n",
                "        \"\"\"\n",
                "        if metadata['pair'] in ('ETH/BTC', 'LTC/BTC'):\n",
                "            multi = 20\n",
                "        else:\n",
                "            multi = 18\n",
                "        dataframe['buy'] = np.where(dataframe.index % multi == 0, 1, 0)\n",
                "        dataframe['sell'] = np.where((dataframe.index + multi - 2) % multi == 0, 1, 0)\n",
                "        return dataframe\n",
                "\n",
                "    mocker.patch(\"freqtrade.exchange.Exchange.get_min_pair_stake_amount\", return_value=0.00001)\n",
                "    mocker.patch('freqtrade.exchange.Exchange.get_fee', fee)\n",
                "    patch_exchange(mocker)\n",
                "\n",
                "    pairs = ['ADA/BTC', 'DASH/BTC', 'ETH/BTC', 'LTC/BTC', 'NXT/BTC']\n",
                "    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=pairs)\n",
                "    # Only use 500 lines to increase performance\n",
                "    data = trim_dictlist(data, -500)\n",
                "\n",
                "    # Remove data for one pair from the beginning of the data\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    data[pair] = data[pair][tres:].reset_index()\n"
                ],
                "after": [
                    "    if tres > 0:\n",
                    "        data[pair] = data[pair][tres:].reset_index()\n"
                ],
                "parent_version_range": {
                    "start": 776,
                    "end": 777
                },
                "child_version_range": {
                    "start": 782,
                    "end": 784
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_backtest_multi_pair",
                        "signature": "def test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):",
                        "at_line": 752
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: tests/optimize/test_backtesting.py\nCode:\n           def test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):\n               ...\n773 779        data = trim_dictlist(data, -500)\n774 780    \n775 781        # Remove data for one pair from the beginning of the data\n776      -     data[pair] = data[pair][tres:].reset_index()\n    782  +     if tres > 0:\n    783  +         data[pair] = data[pair][tres:].reset_index()\n777 784        default_conf['timeframe'] = '5m'\n778 785    \n779 786        backtesting = Backtesting(default_conf)\n         ...\n",
                "file_path": "tests/optimize/test_backtesting.py",
                "identifiers_before": [
                    "data",
                    "pair",
                    "reset_index",
                    "tres"
                ],
                "identifiers_after": [
                    "data",
                    "pair",
                    "reset_index",
                    "tres"
                ],
                "prefix": [
                    "    data = trim_dictlist(data, -500)\n",
                    "\n",
                    "    # Remove data for one pair from the beginning of the data\n"
                ],
                "suffix": [
                    "    default_conf['timeframe'] = '5m'\n",
                    "\n",
                    "    backtesting = Backtesting(default_conf)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    default_conf['timeframe'] = '5m'\n",
                "\n",
                "    backtesting = Backtesting(default_conf)\n",
                "    backtesting._set_strategy(backtesting.strategylist[0])\n",
                "    backtesting.strategy.advise_buy = _trend_alternate_hold  # Override\n",
                "    backtesting.strategy.advise_sell = _trend_alternate_hold  # Override\n",
                "\n",
                "    processed = backtesting.strategy.advise_all_indicators(data)\n",
                "    min_date, max_date = get_timerange(processed)\n",
                "    backtest_conf = {\n",
                "        'processed': processed,\n",
                "        'start_date': min_date,\n",
                "        'end_date': max_date,\n",
                "        'max_open_trades': 3,\n",
                "        'position_stacking': False,\n",
                "    }\n",
                "\n",
                "    results = backtesting.backtest(**backtest_conf)\n",
                "\n",
                "    # Make sure we have parallel trades\n",
                "    assert len(evaluate_result_multi(results['results'], '5m', 2)) > 0\n",
                "    # make sure we don't have trades with more than configured max_open_trades\n",
                "    assert len(evaluate_result_multi(results['results'], '5m', 3)) == 0\n",
                "\n",
                "    # Cached data correctly removed amounts\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    removed_candles = len(data[pair]) - 1 - backtesting.strategy.startup_candle_count\n"
                ],
                "after": [
                    "    offset = 2 if tres == 0 else 1\n",
                    "    removed_candles = len(data[pair]) - offset - backtesting.strategy.startup_candle_count\n"
                ],
                "parent_version_range": {
                    "start": 802,
                    "end": 803
                },
                "child_version_range": {
                    "start": 809,
                    "end": 811
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_backtest_multi_pair",
                        "signature": "def test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):",
                        "at_line": 752
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: tests/optimize/test_backtesting.py\nCode:\n           def test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):\n               ...\n799 806        assert len(evaluate_result_multi(results['results'], '5m', 3)) == 0\n800 807    \n801 808        # Cached data correctly removed amounts\n802      -     removed_candles = len(data[pair]) - 1 - backtesting.strategy.startup_candle_count\n    809  +     offset = 2 if tres == 0 else 1\n    810  +     removed_candles = len(data[pair]) - offset - backtesting.strategy.startup_candle_count\n803 811        assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n         ...\n",
                "file_path": "tests/optimize/test_backtesting.py",
                "identifiers_before": [
                    "backtesting",
                    "data",
                    "len",
                    "pair",
                    "removed_candles",
                    "startup_candle_count",
                    "strategy"
                ],
                "identifiers_after": [
                    "backtesting",
                    "data",
                    "len",
                    "offset",
                    "pair",
                    "removed_candles",
                    "startup_candle_count",
                    "strategy",
                    "tres"
                ],
                "prefix": [
                    "    assert len(evaluate_result_multi(results['results'], '5m', 3)) == 0\n",
                    "\n",
                    "    # Cached data correctly removed amounts\n"
                ],
                "suffix": [
                    "    assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    assert len(backtesting.dataprovider.get_analyzed_dataframe(\n",
                    "        'NXT/BTC', '5m')[0]) == len(data['NXT/BTC']) - 2 - backtesting.strategy.startup_candle_count\n"
                ],
                "parent_version_range": {
                    "start": 804,
                    "end": 804
                },
                "child_version_range": {
                    "start": 812,
                    "end": 814
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_backtest_multi_pair",
                        "signature": "def test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):",
                        "at_line": 752
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: tests/optimize/test_backtesting.py\nCode:\n           def test_backtest_multi_pair(default_conf, fee, mocker, tres, pair, testdatadir):\n               ...\n803 811        assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n    812  +     assert len(backtesting.dataprovider.get_analyzed_dataframe(\n    813  +         'NXT/BTC', '5m')[0]) == len(data['NXT/BTC']) - 2 - backtesting.strategy.startup_candle_count\n804 814    \n805 815        backtest_conf = {\n806 816            'processed': processed,\n         ...\n",
                "file_path": "tests/optimize/test_backtesting.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "backtesting",
                    "data",
                    "dataprovider",
                    "get_analyzed_dataframe",
                    "len",
                    "startup_candle_count",
                    "strategy"
                ],
                "prefix": [
                    "    assert len(backtesting.dataprovider.get_analyzed_dataframe(pair, '5m')[0]) == removed_candles\n"
                ],
                "suffix": [
                    "\n",
                    "    backtest_conf = {\n",
                    "        'processed': processed,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "    backtest_conf = {\n",
                "        'processed': processed,\n",
                "        'start_date': min_date,\n",
                "        'end_date': max_date,\n",
                "        'max_open_trades': 1,\n",
                "        'position_stacking': False,\n",
                "    }\n",
                "    results = backtesting.backtest(**backtest_conf)\n",
                "    assert len(evaluate_result_multi(results['results'], '5m', 1)) == 0\n",
                "\n",
                "\n",
                "def test_backtest_start_timerange(default_conf, mocker, caplog, testdatadir):\n",
                "\n",
                "    patch_exchange(mocker)\n",
                "    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest')\n",
                "    mocker.patch('freqtrade.optimize.backtesting.generate_backtest_stats')\n",
                "    mocker.patch('freqtrade.optimize.backtesting.show_backtest_results')\n",
                "    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist',\n",
                "                 PropertyMock(return_value=['UNITTEST/BTC']))\n",
                "    patched_configuration_load_config_file(mocker, default_conf)\n",
                "\n",
                "    args = [\n",
                "        'backtesting',\n",
                "        '--config', 'config.json',\n",
                "        '--strategy', 'DefaultStrategy',\n",
                "        '--datadir', str(testdatadir),\n",
                "        '--timeframe', '1m',\n",
                "        '--timerange', '1510694220-1510700340',\n",
                "        '--enable-position-stacking',\n",
                "        '--disable-max-market-positions'\n",
                "    ]\n",
                "    args = get_args(args)\n",
                "    start_backtesting(args)\n",
                "    # check the logs, that will contain the backtest result\n",
                "    exists = [\n",
                "        'Parameter -i/--timeframe detected ... Using timeframe: 1m ...',\n",
                "        'Ignoring max_open_trades (--disable-max-market-positions was used) ...',\n",
                "        'Parameter --timerange detected: 1510694220-1510700340 ...',\n",
                "        f'Using data directory: {testdatadir} ...',\n",
                "        'Loading data from 2017-11-14 20:57:00 '\n",
                "        'up to 2017-11-14 22:58:00 (0 days).',\n",
                "        'Backtesting with data from 2017-11-14 21:17:00 '\n",
                "        'up to 2017-11-14 22:58:00 (0 days).',\n",
                "        'Parameter --enable-position-stacking detected ...'\n",
                "    ]\n",
                "\n",
                "    for line in exists:\n",
                "        assert log_has(line, caplog)\n",
                "\n",
                "\n",
                "@pytest.mark.filterwarnings(\"ignore:deprecated\")\n",
                "def test_backtest_start_multi_strat(default_conf, mocker, caplog, testdatadir):\n",
                "\n",
                "    default_conf.update({\n",
                "        \"use_sell_signal\": True,\n",
                "        \"sell_profit_only\": False,\n",
                "        \"sell_profit_offset\": 0.0,\n",
                "        \"ignore_roi_if_buy_signal\": False,\n",
                "    })\n",
                "    patch_exchange(mocker)\n",
                "    backtestmock = MagicMock(return_value={\n",
                "        'results': pd.DataFrame(columns=BT_DATA_COLUMNS),\n",
                "        'config': default_conf,\n",
                "        'locks': [],\n",
                "        'rejected_signals': 20,\n",
                "        'final_balance': 1000,\n",
                "    })\n",
                "    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist',\n",
                "                 PropertyMock(return_value=['UNITTEST/BTC']))\n",
                "    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n",
                "    text_table_mock = MagicMock()\n",
                "    sell_reason_mock = MagicMock()\n",
                "    strattable_mock = MagicMock()\n",
                "    strat_summary = MagicMock()\n",
                "\n",
                "    mocker.patch.multiple('freqtrade.optimize.optimize_reports',\n",
                "                          text_table_bt_results=text_table_mock,\n",
                "                          text_table_strategy=strattable_mock,\n",
                "                          generate_pair_metrics=MagicMock(),\n",
                "                          generate_sell_reason_stats=sell_reason_mock,\n",
                "                          generate_strategy_comparison=strat_summary,\n",
                "                          generate_daily_stats=MagicMock(),\n",
                "                          )\n",
                "    patched_configuration_load_config_file(mocker, default_conf)\n",
                "\n",
                "    args = [\n",
                "        'backtesting',\n",
                "        '--config', 'config.json',\n",
                "        '--datadir', str(testdatadir),\n",
                "        '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'),\n",
                "        '--timeframe', '1m',\n",
                "        '--timerange', '1510694220-1510700340',\n",
                "        '--enable-position-stacking',\n",
                "        '--disable-max-market-positions',\n",
                "        '--strategy-list',\n",
                "        'DefaultStrategy',\n",
                "        'TestStrategyLegacy',\n",
                "    ]\n",
                "    args = get_args(args)\n",
                "    start_backtesting(args)\n",
                "    # 2 backtests, 4 tables\n",
                "    assert backtestmock.call_count == 2\n",
                "    assert text_table_mock.call_count == 4\n",
                "    assert strattable_mock.call_count == 1\n",
                "    assert sell_reason_mock.call_count == 2\n",
                "    assert strat_summary.call_count == 1\n",
                "\n",
                "    # check the logs, that will contain the backtest result\n",
                "    exists = [\n",
                "        'Parameter -i/--timeframe detected ... Using timeframe: 1m ...',\n",
                "        'Ignoring max_open_trades (--disable-max-market-positions was used) ...',\n",
                "        'Parameter --timerange detected: 1510694220-1510700340 ...',\n",
                "        f'Using data directory: {testdatadir} ...',\n",
                "        'Loading data from 2017-11-14 20:57:00 '\n",
                "        'up to 2017-11-14 22:58:00 (0 days).',\n",
                "        'Backtesting with data from 2017-11-14 21:17:00 '\n",
                "        'up to 2017-11-14 22:58:00 (0 days).',\n",
                "        'Parameter --enable-position-stacking detected ...',\n",
                "        'Running backtesting for Strategy DefaultStrategy',\n",
                "        'Running backtesting for Strategy TestStrategyLegacy',\n",
                "    ]\n",
                "\n",
                "    for line in exists:\n",
                "        assert log_has(line, caplog)\n",
                "\n",
                "\n",
                "@pytest.mark.filterwarnings(\"ignore:deprecated\")\n",
                "def test_backtest_start_multi_strat_nomock(default_conf, mocker, caplog, testdatadir, capsys):\n",
                "    default_conf.update({\n",
                "        \"use_sell_signal\": True,\n",
                "        \"sell_profit_only\": False,\n",
                "        \"sell_profit_offset\": 0.0,\n",
                "        \"ignore_roi_if_buy_signal\": False,\n",
                "    })\n",
                "    patch_exchange(mocker)\n",
                "    result1 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC'],\n",
                "                            'profit_ratio': [0.0, 0.0],\n",
                "                            'profit_abs': [0.0, 0.0],\n",
                "                            'open_date': pd.to_datetime(['2018-01-29 18:40:00',\n",
                "                                                         '2018-01-30 03:30:00', ], utc=True\n",
                "                                                        ),\n",
                "                            'close_date': pd.to_datetime(['2018-01-29 20:45:00',\n",
                "                                                          '2018-01-30 05:35:00', ], utc=True),\n",
                "                            'trade_duration': [235, 40],\n",
                "                            'is_open': [False, False],\n",
                "                            'stake_amount': [0.01, 0.01],\n",
                "                            'open_rate': [0.104445, 0.10302485],\n",
                "                            'close_rate': [0.104969, 0.103541],\n",
                "                            'sell_reason': [SellType.ROI, SellType.ROI]\n",
                "                            })\n",
                "    result2 = pd.DataFrame({'pair': ['XRP/BTC', 'LTC/BTC', 'ETH/BTC'],\n",
                "                            'profit_ratio': [0.03, 0.01, 0.1],\n",
                "                            'profit_abs': [0.01, 0.02, 0.2],\n",
                "                            'open_date': pd.to_datetime(['2018-01-29 18:40:00',\n",
                "                                                         '2018-01-30 03:30:00',\n",
                "                                                         '2018-01-30 05:30:00'], utc=True\n",
                "                                                        ),\n",
                "                            'close_date': pd.to_datetime(['2018-01-29 20:45:00',\n",
                "                                                          '2018-01-30 05:35:00',\n",
                "                                                          '2018-01-30 08:30:00'], utc=True),\n",
                "                            'trade_duration': [47, 40, 20],\n",
                "                            'is_open': [False, False, False],\n",
                "                            'stake_amount': [0.01, 0.01, 0.01],\n",
                "                            'open_rate': [0.104445, 0.10302485, 0.122541],\n",
                "                            'close_rate': [0.104969, 0.103541, 0.123541],\n",
                "                            'sell_reason': [SellType.ROI, SellType.ROI, SellType.STOP_LOSS]\n",
                "                            })\n",
                "    backtestmock = MagicMock(side_effect=[\n",
                "        {\n",
                "            'results': result1,\n",
                "            'config': default_conf,\n",
                "            'locks': [],\n",
                "            'rejected_signals': 20,\n",
                "            'final_balance': 1000,\n",
                "        },\n",
                "        {\n",
                "            'results': result2,\n",
                "            'config': default_conf,\n",
                "            'locks': [],\n",
                "            'rejected_signals': 20,\n",
                "            'final_balance': 1000,\n",
                "        }\n",
                "    ])\n",
                "    mocker.patch('freqtrade.plugins.pairlistmanager.PairListManager.whitelist',\n",
                "                 PropertyMock(return_value=['UNITTEST/BTC']))\n",
                "    mocker.patch('freqtrade.optimize.backtesting.Backtesting.backtest', backtestmock)\n",
                "\n",
                "    patched_configuration_load_config_file(mocker, default_conf)\n",
                "\n",
                "    args = [\n",
                "        'backtesting',\n",
                "        '--config', 'config.json',\n",
                "        '--datadir', str(testdatadir),\n",
                "        '--strategy-path', str(Path(__file__).parents[1] / 'strategy/strats'),\n",
                "        '--timeframe', '1m',\n",
                "        '--timerange', '1510694220-1510700340',\n",
                "        '--enable-position-stacking',\n",
                "        '--disable-max-market-positions',\n",
                "        '--strategy-list',\n",
                "        'DefaultStrategy',\n",
                "        'TestStrategyLegacy',\n",
                "    ]\n",
                "    args = get_args(args)\n",
                "    start_backtesting(args)\n",
                "\n",
                "    # check the logs, that will contain the backtest result\n",
                "    exists = [\n",
                "        'Parameter -i/--timeframe detected ... Using timeframe: 1m ...',\n",
                "        'Ignoring max_open_trades (--disable-max-market-positions was used) ...',\n",
                "        'Parameter --timerange detected: 1510694220-1510700340 ...',\n",
                "        f'Using data directory: {testdatadir} ...',\n",
                "        'Loading data from 2017-11-14 20:57:00 '\n",
                "        'up to 2017-11-14 22:58:00 (0 days).',\n",
                "        'Backtesting with data from 2017-11-14 21:17:00 '\n",
                "        'up to 2017-11-14 22:58:00 (0 days).',\n",
                "        'Parameter --enable-position-stacking detected ...',\n",
                "        'Running backtesting for Strategy DefaultStrategy',\n",
                "        'Running backtesting for Strategy TestStrategyLegacy',\n",
                "    ]\n",
                "\n",
                "    for line in exists:\n",
                "        assert log_has(line, caplog)\n",
                "\n",
                "    captured = capsys.readouterr()\n",
                "    assert 'BACKTESTING REPORT' in captured.out\n",
                "    assert 'SELL REASON STATS' in captured.out\n",
                "    assert 'LEFT OPEN TRADES REPORT' in captured.out\n",
                "    assert '2017-11-14 21:17:00 -> 2017-11-14 22:58:00 | Max open trades : 1' in captured.out\n",
                "    assert 'STRATEGY SUMMARY' in captured.out"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "0 before 1",
            "reason": "move"
        },
        {
            "edit_hunk_pair": [
                1,
                4
            ],
            "edit_order": "0 before 1",
            "reason": "implement and test"
        },
        {
            "edit_hunk_pair": [
                2,
                4
            ],
            "edit_order": "0 before 1",
            "reason": "implement and test"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                5,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                6,
                7
            ],
            "edit_order": "no relation",
            "reason": "no direct evidence"
        }
    ]
}