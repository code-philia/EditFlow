{
    "language": "python",
    "commit_url": "https://github.com/3b1b/manim/commit/98b0d266d2475926a606331923cca3dc1dea97ad",
    "commit_message": "Make sure skip_animations and start_at_animation_number play well together",
    "commit_snapshots": {
        "manimlib/config.py": [
            [
                "import argparse\n",
                "import colour\n",
                "import inspect\n",
                "import importlib\n",
                "import os\n",
                "import sys\n",
                "import yaml\n",
                "from contextlib import contextmanager\n",
                "from screeninfo import get_monitors\n",
                "\n",
                "from manimlib.utils.config_ops import merge_dicts_recursively\n",
                "from manimlib.utils.init_config import init_customization\n",
                "from manimlib.logger import log\n",
                "\n",
                "\n",
                "__config_file__ = \"custom_config.yml\"\n",
                "\n",
                "\n",
                "def parse_cli():\n",
                "    try:\n",
                "        parser = argparse.ArgumentParser()\n",
                "        module_location = parser.add_mutually_exclusive_group()\n",
                "        module_location.add_argument(\n",
                "            \"file\",\n",
                "            nargs=\"?\",\n",
                "            help=\"path to file holding the python code for the scene\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"scene_names\",\n",
                "            nargs=\"*\",\n",
                "            help=\"Name of the Scene class you want to see\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-w\", \"--write_file\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Render the scene as a movie file\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-s\", \"--skip_animations\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Save the last frame\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-l\", \"--low_quality\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Render at a low quality (for faster rendering)\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-m\", \"--medium_quality\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Render at a medium quality\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"--hd\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Render at a 1080p\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"--uhd\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Render at a 4k\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-f\", \"--full_screen\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Show window in full screen\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-g\", \"--save_pngs\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Save each frame as a png\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-i\", \"--gif\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Save the video as gif\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-t\", \"--transparent\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Render to a movie file with an alpha channel\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-q\", \"--quiet\",\n",
                "            action=\"store_true\",\n",
                "            help=\"\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-a\", \"--write_all\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Write all the scenes from a file\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-o\", \"--open\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Automatically open the saved file once its done\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"--finder\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Show the output file in finder\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"--config\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Guide for automatic configuration\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"--file_name\",\n",
                "            help=\"Name for the movie or image file\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-n\", \"--start_at_animation_number\",\n",
                "            help=\"Start rendering not from the first animation, but\"\n",
                "                 \"from another, specified by its index.  If you pass\"\n",
                "                 \"in two comma separated values, e.g. \\\"3,6\\\", it will end\"\n",
                "                 \"the rendering at the second value\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-e\", \"--embed\",\n",
                "            help=\"Takes a line number as an argument, and results\"\n",
                "                 \"in the scene being called as if the line `self.embed()`\"\n",
                "                 \"was inserted into the scene code at that line number.\"\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-r\", \"--resolution\",\n",
                "            help=\"Resolution, passed as \\\"WxH\\\", e.g. \\\"1920x1080\\\"\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"--frame_rate\",\n",
                "            help=\"Frame rate, as an integer\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-c\", \"--color\",\n",
                "            help=\"Background color\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"--leave_progress_bars\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Leave progress bars displayed in terminal\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"--video_dir\",\n",
                "            help=\"Directory to write video\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"--config_file\",\n",
                "            help=\"Path to the custom configuration file\",\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"-v\", \"--version\",\n",
                "            action=\"store_true\",\n",
                "            help=\"Display the version of manimgl\"\n",
                "        )\n",
                "        parser.add_argument(\n",
                "            \"--log-level\",\n",
                "            help=\"Level of messages to Display, can be DEBUG / INFO / WARNING / ERROR / CRITICAL\"\n",
                "        )\n",
                "        args = parser.parse_args()\n",
                "        return args\n",
                "    except argparse.ArgumentError as err:\n",
                "        log.error(str(err))\n",
                "        sys.exit(2)\n",
                "\n",
                "\n",
                "def get_manim_dir():\n",
                "    manimlib_module = importlib.import_module(\"manimlib\")\n",
                "    manimlib_dir = os.path.dirname(inspect.getabsfile(manimlib_module))\n",
                "    return os.path.abspath(os.path.join(manimlib_dir, \"..\"))\n",
                "\n",
                "\n",
                "def get_module(file_name):\n",
                "    if file_name is None:\n",
                "        return None\n",
                "    module_name = file_name.replace(os.sep, \".\").replace(\".py\", \"\")\n",
                "    spec = importlib.util.spec_from_file_location(module_name, file_name)\n",
                "    module = importlib.util.module_from_spec(spec)\n",
                "    spec.loader.exec_module(module)\n",
                "    return module\n",
                "\n",
                "\n",
                "@contextmanager\n",
                "def insert_embed_line(file_name, lineno):\n",
                "    with open(file_name, 'r') as fp:\n",
                "        lines = fp.readlines()\n",
                "    line = lines[lineno - 1]\n",
                "    n_spaces = len(line) - len(line.lstrip())\n",
                "    lines.insert(lineno - 1, \" \" * n_spaces + \"self.embed()\\n\")\n",
                "\n",
                "    alt_file = file_name.replace(\".py\", \"_inserted_embed.py\")\n",
                "    with open(alt_file, 'w') as fp:\n",
                "        fp.writelines(lines)\n",
                "\n",
                "    try:\n",
                "        yield alt_file\n",
                "    finally:\n",
                "        os.remove(alt_file)\n",
                "\n",
                "\n",
                "def get_custom_config():\n",
                "    global __config_file__\n",
                "\n",
                "    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\")\n",
                "\n",
                "    if os.path.exists(global_defaults_file):\n",
                "        with open(global_defaults_file, \"r\") as file:\n",
                "            config = yaml.safe_load(file)\n",
                "\n",
                "        if os.path.exists(__config_file__):\n",
                "            with open(__config_file__, \"r\") as file:\n",
                "                local_defaults = yaml.safe_load(file)\n",
                "            if local_defaults:\n",
                "                config = merge_dicts_recursively(\n",
                "                    config,\n",
                "                    local_defaults,\n",
                "                )\n",
                "    else:\n",
                "        with open(__config_file__, \"r\") as file:\n",
                "            config = yaml.safe_load(file)\n",
                "\n",
                "    return config\n",
                "\n",
                "\n",
                "def check_temporary_storage(config):\n",
                "    if config[\"directories\"][\"temporary_storage\"] == \"\" and sys.platform == \"win32\":\n",
                "        log.warning(\n",
                "            \"You may be using Windows platform and have not specified the path of\"\n",
                "            \" `temporary_storage`, which may cause OSError. So it is recommended\"\n",
                "            \" to specify the `temporary_storage` in the config file (.yml)\"\n",
                "        )\n",
                "\n",
                "\n",
                "def get_configuration(args):\n",
                "    global __config_file__\n",
                "\n",
                "    # ensure __config_file__ always exists\n",
                "    if args.config_file is not None:\n",
                "        if not os.path.exists(args.config_file):\n",
                "            log.error(f\"Can't find {args.config_file}.\")\n",
                "            if sys.platform == 'win32':\n",
                "                log.info(f\"Copying default configuration file to {args.config_file}...\")\n",
                "                os.system(f\"copy default_config.yml {args.config_file}\")\n",
                "            elif sys.platform in [\"linux2\", \"darwin\"]:\n",
                "                log.info(f\"Copying default configuration file to {args.config_file}...\")\n",
                "                os.system(f\"cp default_config.yml {args.config_file}\")\n",
                "            else:\n",
                "                log.info(\"Please create the configuration file manually.\")\n",
                "            log.info(\"Read configuration from default_config.yml.\")\n",
                "        else:\n",
                "            __config_file__ = args.config_file\n",
                "\n",
                "    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\")\n",
                "\n",
                "    if not (os.path.exists(global_defaults_file) or os.path.exists(__config_file__)):\n",
                "        log.info(\"There is no configuration file detected. Switch to the config file initializer:\")\n",
                "        init_customization()\n",
                "\n",
                "    elif not os.path.exists(__config_file__):\n",
                "        log.info(f\"Using the default configuration file, which you can modify in `{global_defaults_file}`\")\n",
                "        log.info(\n",
                "            \"If you want to create a local configuration file, you can create a file named\"\n",
                "            f\" `{__config_file__}`, or run `manimgl --config`\"\n",
                "        )\n",
                "\n",
                "    custom_config = get_custom_config()\n",
                "    check_temporary_storage(custom_config)\n",
                "\n",
                "    write_file = any([args.write_file, args.open, args.finder])\n",
                "    if args.transparent:\n",
                "        file_ext = \".mov\"\n",
                "    elif args.gif:\n",
                "        file_ext = \".gif\"\n",
                "    else:\n",
                "        file_ext = \".mp4\"\n",
                "\n",
                "    file_writer_config = {\n",
                "        \"write_to_movie\": not args.skip_animations and write_file,\n",
                "        \"break_into_partial_movies\": custom_config[\"break_into_partial_movies\"],\n",
                "        \"save_last_frame\": args.skip_animations and write_file,\n",
                "        \"save_pngs\": args.save_pngs,\n",
                "        # If -t is passed in (for transparent), this will be RGBA\n",
                "        \"png_mode\": \"RGBA\" if args.transparent else \"RGB\",\n",
                "        \"movie_file_extension\": file_ext,\n",
                "        \"mirror_module_path\": custom_config[\"directories\"][\"mirror_module_path\"],\n",
                "        \"output_directory\": args.video_dir or custom_config[\"directories\"][\"output\"],\n",
                "        \"file_name\": args.file_name,\n",
                "        \"input_file_path\": args.file or \"\",\n",
                "        \"open_file_upon_completion\": args.open,\n",
                "        \"show_file_location_upon_completion\": args.finder,\n",
                "        \"quiet\": args.quiet,\n",
                "    }\n",
                "\n",
                "    if args.embed is None:\n",
                "        module = get_module(args.file)\n",
                "    else:\n",
                "        with insert_embed_line(args.file, int(args.embed)) as alt_file:\n",
                "            module = get_module(alt_file)\n",
                "\n",
                "    config = {\n",
                "        \"module\": module,\n",
                "        \"scene_names\": args.scene_names,\n",
                "        \"file_writer_config\": file_writer_config,\n",
                "        \"quiet\": args.quiet or args.write_all,\n",
                "        \"write_all\": args.write_all,\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        \"skip_animations\": args.skip_animations,\n"
                ],
                "parent_version_range": {
                    "start": 304,
                    "end": 304
                },
                "child_version_range": {
                    "start": 304,
                    "end": 305
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_configuration",
                        "signature": "def get_configuration(args):",
                        "at_line": 232
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: manimlib/config.py\nCode:\n           def get_configuration(args):\n               ...\n301 301            \"file_writer_config\": file_writer_config,\n302 302            \"quiet\": args.quiet or args.write_all,\n303 303            \"write_all\": args.write_all,\n    304  +         \"skip_animations\": args.skip_animations,\n304 305            \"start_at_animation_number\": args.start_at_animation_number,\n         ...\n",
                "file_path": "manimlib/config.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "args",
                    "skip_animations"
                ],
                "prefix": [
                    "        \"file_writer_config\": file_writer_config,\n",
                    "        \"quiet\": args.quiet or args.write_all,\n",
                    "        \"write_all\": args.write_all,\n"
                ],
                "suffix": [
                    "        \"start_at_animation_number\": args.start_at_animation_number,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        \"start_at_animation_number\": args.start_at_animation_number,\n"
            ],
            {
                "type": "delete",
                "before": [
                    "        \"preview\": not write_file,\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 305,
                    "end": 306
                },
                "child_version_range": {
                    "start": 306,
                    "end": 306
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_configuration",
                        "signature": "def get_configuration(args):",
                        "at_line": 232
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: manimlib/config.py\nCode:\n           def get_configuration(args):\n               ...\n304 305            \"start_at_animation_number\": args.start_at_animation_number,\n305      -         \"preview\": not write_file,\n306 306            \"end_at_animation_number\": None,\n         ...\n",
                "file_path": "manimlib/config.py",
                "identifiers_before": [
                    "write_file"
                ],
                "identifiers_after": [],
                "prefix": [
                    "        \"start_at_animation_number\": args.start_at_animation_number,\n"
                ],
                "suffix": [
                    "        \"end_at_animation_number\": None,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        \"end_at_animation_number\": None,\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        \"preview\": not write_file,\n"
                ],
                "parent_version_range": {
                    "start": 307,
                    "end": 307
                },
                "child_version_range": {
                    "start": 307,
                    "end": 308
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_configuration",
                        "signature": "def get_configuration(args):",
                        "at_line": 232
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: manimlib/config.py\nCode:\n           def get_configuration(args):\n               ...\n306 306            \"end_at_animation_number\": None,\n    307  +         \"preview\": not write_file,\n307 308            \"leave_progress_bars\": args.leave_progress_bars,\n308 309        }\n309 310    \n         ...\n",
                "file_path": "manimlib/config.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "write_file"
                ],
                "prefix": [
                    "        \"end_at_animation_number\": None,\n"
                ],
                "suffix": [
                    "        \"leave_progress_bars\": args.leave_progress_bars,\n",
                    "    }\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        \"leave_progress_bars\": args.leave_progress_bars,\n",
                "    }\n",
                "\n",
                "    # Camera configuration\n",
                "    config[\"camera_config\"] = get_camera_configuration(args, custom_config)\n",
                "\n",
                "    # Default to making window half the screen size\n",
                "    # but make it full screen if -f is passed in\n",
                "    monitors = get_monitors()\n",
                "    mon_index = custom_config[\"window_monitor\"]\n",
                "    monitor = monitors[min(mon_index, len(monitors) - 1)]\n",
                "    window_width = monitor.width\n",
                "    if not (args.full_screen or custom_config[\"full_screen\"]):\n",
                "        window_width //= 2\n",
                "    window_height = window_width * 9 // 16\n",
                "    config[\"window_config\"] = {\n",
                "        \"size\": (window_width, window_height),\n",
                "    }\n",
                "\n",
                "    # Arguments related to skipping\n",
                "    stan = config[\"start_at_animation_number\"]\n",
                "    if stan is not None:\n",
                "        if \",\" in stan:\n",
                "            start, end = stan.split(\",\")\n",
                "            config[\"start_at_animation_number\"] = int(start)\n",
                "            config[\"end_at_animation_number\"] = int(end)\n",
                "        else:\n",
                "            config[\"start_at_animation_number\"] = int(stan)\n",
                "\n"
            ],
            {
                "type": "delete",
                "before": [
                    "    config[\"skip_animations\"] = any([\n",
                    "        args.skip_animations,\n",
                    "        args.start_at_animation_number,\n",
                    "    ])\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 336,
                    "end": 340
                },
                "child_version_range": {
                    "start": 337,
                    "end": 337
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_configuration",
                        "signature": "def get_configuration(args):",
                        "at_line": 232
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: manimlib/config.py\nCode:\n           def get_configuration(args):\n               ...\n333 334            else:\n334 335                config[\"start_at_animation_number\"] = int(stan)\n335 336    \n336      -     config[\"skip_animations\"] = any([\n337      -         args.skip_animations,\n338      -         args.start_at_animation_number,\n339      -     ])\n340 337        return config\n341 338    \n342 339    \n         ...\n",
                "file_path": "manimlib/config.py",
                "identifiers_before": [
                    "any",
                    "args",
                    "config",
                    "skip_animations",
                    "start_at_animation_number"
                ],
                "identifiers_after": [],
                "prefix": [
                    "        else:\n",
                    "            config[\"start_at_animation_number\"] = int(stan)\n",
                    "\n"
                ],
                "suffix": [
                    "    return config\n",
                    "\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    return config\n",
                "\n",
                "\n",
                "def get_camera_configuration(args, custom_config):\n",
                "    camera_config = {}\n",
                "    camera_qualities = get_custom_config()[\"camera_qualities\"]\n",
                "    if args.low_quality:\n",
                "        quality = camera_qualities[\"low\"]\n",
                "    elif args.medium_quality:\n",
                "        quality = camera_qualities[\"medium\"]\n",
                "    elif args.hd:\n",
                "        quality = camera_qualities[\"high\"]\n",
                "    elif args.uhd:\n",
                "        quality = camera_qualities[\"ultra_high\"]\n",
                "    else:\n",
                "        quality = camera_qualities[camera_qualities[\"default_quality\"]]\n",
                "\n",
                "    if args.resolution:\n",
                "        quality[\"resolution\"] = args.resolution\n",
                "    if args.frame_rate:\n",
                "        quality[\"frame_rate\"] = int(args.frame_rate)\n",
                "\n",
                "    width_str, height_str = quality[\"resolution\"].split(\"x\")\n",
                "    width = int(width_str)\n",
                "    height = int(height_str)\n",
                "\n",
                "    camera_config.update({\n",
                "        \"pixel_width\": width,\n",
                "        \"pixel_height\": height,\n",
                "        \"frame_rate\": quality[\"frame_rate\"],\n",
                "    })\n",
                "\n",
                "    try:\n",
                "        bg_color = args.color or custom_config[\"style\"][\"background_color\"]\n",
                "        camera_config[\"background_color\"] = colour.Color(bg_color)\n",
                "    except ValueError as err:\n",
                "        log.error(\"Please use a valid color\")\n",
                "        log.error(err)\n",
                "        sys.exit(2)\n",
                "\n",
                "    # If rendering a transparent image/move, make sure the\n",
                "    # scene has a background opacity of 0\n",
                "    if args.transparent:\n",
                "        camera_config[\"background_opacity\"] = 0\n",
                "\n",
                "    return camera_config"
            ]
        ],
        "manimlib/scene/scene.py": [
            [
                "import inspect\n",
                "import random\n",
                "import platform\n",
                "import itertools as it\n",
                "from functools import wraps\n",
                "\n",
                "from tqdm import tqdm as ProgressDisplay\n",
                "import numpy as np\n",
                "import time\n",
                "\n",
                "from manimlib.animation.animation import prepare_animation\n",
                "from manimlib.animation.transform import MoveToTarget\n",
                "from manimlib.camera.camera import Camera\n",
                "from manimlib.constants import DEFAULT_WAIT_TIME\n",
                "from manimlib.mobject.mobject import Mobject\n",
                "from manimlib.mobject.mobject import Point\n",
                "from manimlib.scene.scene_file_writer import SceneFileWriter\n",
                "from manimlib.utils.config_ops import digest_config\n",
                "from manimlib.utils.family_ops import extract_mobject_family_members\n",
                "from manimlib.utils.family_ops import restructure_list_to_exclude_certain_family_members\n",
                "from manimlib.event_handler.event_type import EventType\n",
                "from manimlib.event_handler import EVENT_DISPATCHER\n",
                "from manimlib.logger import log\n",
                "\n",
                "\n",
                "class Scene(object):\n",
                "    CONFIG = {\n",
                "        \"window_config\": {},\n",
                "        \"camera_class\": Camera,\n",
                "        \"camera_config\": {},\n",
                "        \"file_writer_config\": {},\n",
                "        \"skip_animations\": False,\n",
                "        \"always_update_mobjects\": False,\n",
                "        \"random_seed\": 0,\n",
                "        \"start_at_animation_number\": None,\n",
                "        \"end_at_animation_number\": None,\n",
                "        \"leave_progress_bars\": False,\n",
                "        \"preview\": True,\n",
                "        \"linger_after_completion\": True,\n",
                "    }\n",
                "\n",
                "    def __init__(self, **kwargs):\n",
                "        digest_config(self, kwargs)\n",
                "        if self.preview:\n",
                "            from manimlib.window import Window\n",
                "            self.window = Window(scene=self, **self.window_config)\n",
                "            self.camera_config[\"ctx\"] = self.window.ctx\n",
                "            self.camera_config[\"frame_rate\"] = 30  # Where's that 30 from?\n",
                "        else:\n",
                "            self.window = None\n",
                "\n",
                "        self.camera = self.camera_class(**self.camera_config)\n",
                "        self.file_writer = SceneFileWriter(self, **self.file_writer_config)\n",
                "        self.mobjects = [self.camera.frame]\n",
                "        self.num_plays = 0\n",
                "        self.time = 0\n",
                "        self.skip_time = 0\n",
                "        self.original_skipping_status = self.skip_animations\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        if self.start_at_animation_number is not None:\n",
                    "            self.skip_animations = True\n"
                ],
                "parent_version_range": {
                    "start": 58,
                    "end": 58
                },
                "child_version_range": {
                    "start": 58,
                    "end": 60
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Scene",
                        "signature": "class Scene(object):",
                        "at_line": 25
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(self, **kwargs):",
                        "at_line": 41
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: manimlib/scene/scene.py\nCode:\n         class Scene(object):\n             ...\n             def __init__(self, **kwargs):\n                 ...\n55 55            self.time = 0\n56 56            self.skip_time = 0\n57 57            self.original_skipping_status = self.skip_animations\n   58  +         if self.start_at_animation_number is not None:\n   59  +             self.skip_animations = True\n58 60    \n59 61            # Items associated with interaction\n60 62            self.mouse_point = Point()\n       ...\n",
                "file_path": "manimlib/scene/scene.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "self",
                    "skip_animations",
                    "start_at_animation_number"
                ],
                "prefix": [
                    "        self.time = 0\n",
                    "        self.skip_time = 0\n",
                    "        self.original_skipping_status = self.skip_animations\n"
                ],
                "suffix": [
                    "\n",
                    "        # Items associated with interaction\n",
                    "        self.mouse_point = Point()\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "        # Items associated with interaction\n",
                "        self.mouse_point = Point()\n",
                "        self.mouse_drag_point = Point()\n",
                "\n",
                "        # Much nicer to work with deterministic scenes\n",
                "        if self.random_seed is not None:\n",
                "            random.seed(self.random_seed)\n",
                "            np.random.seed(self.random_seed)\n",
                "\n",
                "    def run(self):\n",
                "        self.virtual_animation_start_time = 0\n",
                "        self.real_animation_start_time = time.time()\n",
                "        self.file_writer.begin()\n",
                "\n",
                "        self.setup()\n",
                "        try:\n",
                "            self.construct()\n",
                "        except EndSceneEarlyException:\n",
                "            pass\n",
                "        self.tear_down()\n",
                "\n",
                "    def setup(self):\n",
                "        \"\"\"\n",
                "        This is meant to be implement by any scenes which\n",
                "        are comonly subclassed, and have some common setup\n",
                "        involved before the construct method is called.\n",
                "        \"\"\"\n",
                "        pass\n",
                "\n",
                "    def construct(self):\n",
                "        # Where all the animation happens\n",
                "        # To be implemented in subclasses\n",
                "        pass\n",
                "\n",
                "    def tear_down(self):\n",
                "        self.stop_skipping()\n",
                "        self.file_writer.finish()\n",
                "        if self.window and self.linger_after_completion:\n",
                "            self.interact()\n",
                "\n",
                "    def interact(self):\n",
                "        # If there is a window, enter a loop\n",
                "        # which updates the frame while under\n",
                "        # the hood calling the pyglet event loop\n",
                "        log.info(\"Tips: You are now in the interactive mode. Now you can use the keyboard\"\n",
                "            \" and the mouse to interact with the scene. Just press `q` if you want to quit.\")\n",
                "        self.quit_interaction = False\n",
                "        self.lock_static_mobject_data()\n",
                "        while not (self.window.is_closing or self.quit_interaction):\n",
                "            self.update_frame(1 / self.camera.frame_rate)\n",
                "        if self.window.is_closing:\n",
                "            self.window.destroy()\n",
                "        if self.quit_interaction:\n",
                "            self.unlock_mobject_data()\n",
                "\n",
                "    def embed(self):\n",
                "        if not self.preview:\n",
                "            # If the scene is just being\n",
                "            # written, ignore embed calls\n",
                "            return\n",
                "        self.stop_skipping()\n",
                "        self.linger_after_completion = False\n",
                "        self.update_frame()\n",
                "\n",
                "        # Save scene state at the point of embedding\n",
                "        self.save_state()\n",
                "\n",
                "        from IPython.terminal.embed import InteractiveShellEmbed\n",
                "        shell = InteractiveShellEmbed()\n",
                "        # Have the frame update after each command\n",
                "        shell.events.register('post_run_cell', lambda *a, **kw: self.update_frame())\n",
                "        # Use the locals of the caller as the local namespace\n",
                "        # once embedded, and add a few custom shortcuts\n",
                "        local_ns = inspect.currentframe().f_back.f_locals\n",
                "        local_ns[\"touch\"] = self.interact\n",
                "        for term in (\"play\", \"wait\", \"add\", \"remove\", \"clear\", \"save_state\", \"restore\"):\n",
                "            local_ns[term] = getattr(self, term)\n",
                "        log.info(\"Tips: Now the embed iPython terminal is open. But you can't interact with\"\n",
                "                 \" the window directly. To do so, you need to type `touch()` or `self.interact()`\")\n",
                "        shell(local_ns=local_ns, stack_depth=2)\n",
                "        # End scene when exiting an embed.\n",
                "        raise EndSceneEarlyException()\n",
                "\n",
                "    def __str__(self):\n",
                "        return self.__class__.__name__\n",
                "\n",
                "    # Only these methods should touch the camera\n",
                "    def get_image(self):\n",
                "        return self.camera.get_image()\n",
                "\n",
                "    def show(self):\n",
                "        self.update_frame(ignore_skipping=True)\n",
                "        self.get_image().show()\n",
                "\n",
                "    def update_frame(self, dt=0, ignore_skipping=False):\n",
                "        self.increment_time(dt)\n",
                "        self.update_mobjects(dt)\n",
                "        if self.skip_animations and not ignore_skipping:\n",
                "            return\n",
                "\n",
                "        if self.window:\n",
                "            self.window.clear()\n",
                "        self.camera.clear()\n",
                "        self.camera.capture(*self.mobjects)\n",
                "\n",
                "        if self.window:\n",
                "            self.window.swap_buffers()\n",
                "            vt = self.time - self.virtual_animation_start_time\n",
                "            rt = time.time() - self.real_animation_start_time\n",
                "            if rt < vt:\n",
                "                self.update_frame(0)\n",
                "\n",
                "    def emit_frame(self):\n",
                "        if not self.skip_animations:\n",
                "            self.file_writer.write_frame(self.camera)\n",
                "\n",
                "    # Related to updating\n",
                "    def update_mobjects(self, dt):\n",
                "        for mobject in self.mobjects:\n",
                "            mobject.update(dt)\n",
                "\n",
                "    def should_update_mobjects(self):\n",
                "        return self.always_update_mobjects or any([\n",
                "            len(mob.get_family_updaters()) > 0\n",
                "            for mob in self.mobjects\n",
                "        ])\n",
                "\n",
                "    # Related to time\n",
                "    def get_time(self):\n",
                "        return self.time\n",
                "\n",
                "    def increment_time(self, dt):\n",
                "        self.time += dt\n",
                "\n",
                "    # Related to internal mobject organization\n",
                "    def get_top_level_mobjects(self):\n",
                "        # Return only those which are not in the family\n",
                "        # of another mobject from the scene\n",
                "        mobjects = self.get_mobjects()\n",
                "        families = [m.get_family() for m in mobjects]\n",
                "\n",
                "        def is_top_level(mobject):\n",
                "            num_families = sum([\n",
                "                (mobject in family)\n",
                "                for family in families\n",
                "            ])\n",
                "            return num_families == 1\n",
                "        return list(filter(is_top_level, mobjects))\n",
                "\n",
                "    def get_mobject_family_members(self):\n",
                "        return extract_mobject_family_members(self.mobjects)\n",
                "\n",
                "    def add(self, *new_mobjects):\n",
                "        \"\"\"\n",
                "        Mobjects will be displayed, from background to\n",
                "        foreground in the order with which they are added.\n",
                "        \"\"\"\n",
                "        self.remove(*new_mobjects)\n",
                "        self.mobjects += new_mobjects\n",
                "        return self\n",
                "\n",
                "    def add_mobjects_among(self, values):\n",
                "        \"\"\"\n",
                "        This is meant mostly for quick prototyping,\n",
                "        e.g. to add all mobjects defined up to a point,\n",
                "        call self.add_mobjects_among(locals().values())\n",
                "        \"\"\"\n",
                "        self.add(*filter(\n",
                "            lambda m: isinstance(m, Mobject),\n",
                "            values\n",
                "        ))\n",
                "        return self\n",
                "\n",
                "    def remove(self, *mobjects_to_remove):\n",
                "        self.mobjects = restructure_list_to_exclude_certain_family_members(\n",
                "            self.mobjects, mobjects_to_remove\n",
                "        )\n",
                "        return self\n",
                "\n",
                "    def bring_to_front(self, *mobjects):\n",
                "        self.add(*mobjects)\n",
                "        return self\n",
                "\n",
                "    def bring_to_back(self, *mobjects):\n",
                "        self.remove(*mobjects)\n",
                "        self.mobjects = list(mobjects) + self.mobjects\n",
                "        return self\n",
                "\n",
                "    def clear(self):\n",
                "        self.mobjects = []\n",
                "        return self\n",
                "\n",
                "    def get_mobjects(self):\n",
                "        return list(self.mobjects)\n",
                "\n",
                "    def get_mobject_copies(self):\n",
                "        return [m.copy() for m in self.mobjects]\n",
                "\n",
                "    def point_to_mobject(self, point, search_set=None, buff=0):\n",
                "        \"\"\"\n",
                "        E.g. if clicking on the scene, this returns the top layer mobject\n",
                "        under a given point\n",
                "        \"\"\"\n",
                "        if search_set is None:\n",
                "            search_set = self.mobjects\n",
                "        for mobject in reversed(search_set):\n",
                "            if mobject.is_point_touching(point, buff=buff):\n",
                "                return mobject\n",
                "        return None\n",
                "\n",
                "    # Related to skipping\n",
                "    def update_skipping_status(self):\n",
                "        if self.start_at_animation_number is not None:\n",
                "            if self.num_plays == self.start_at_animation_number:\n",
                "                self.stop_skipping()\n",
                "        if self.end_at_animation_number is not None:\n",
                "            if self.num_plays >= self.end_at_animation_number:\n",
                "                raise EndSceneEarlyException()\n",
                "\n",
                "    def stop_skipping(self):\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        if self.skip_animations:\n",
                    "            self.skip_animations = False\n",
                    "            self.skip_time += self.time\n"
                ],
                "after": [
                    "        self.virtual_animation_start_time = self.time\n",
                    "        self.skip_animations = False\n"
                ],
                "parent_version_range": {
                    "start": 279,
                    "end": 282
                },
                "child_version_range": {
                    "start": 281,
                    "end": 283
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if self.skip_animations:",
                        "start_line": 279,
                        "end_line": 281
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Scene",
                        "signature": "class Scene(object):",
                        "at_line": 25
                    },
                    {
                        "type": "function",
                        "name": "stop_skipping",
                        "signature": "def stop_skipping(self):",
                        "at_line": 278
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: manimlib/scene/scene.py\nCode:\n           class Scene(object):\n               ...\n276 278                    raise EndSceneEarlyException()\n277 279    \n278 280        def stop_skipping(self):\n279      -         if self.skip_animations:\n280      -             self.skip_animations = False\n281      -             self.skip_time += self.time\n    281  +         self.virtual_animation_start_time = self.time\n    282  +         self.skip_animations = False\n282 283    \n283 284        # Methods associated with running animations\n284 285        def get_time_progression(self, run_time, n_iterations=None, desc=\"\", override_skip_animations=False):\n         ...\n",
                "file_path": "manimlib/scene/scene.py",
                "identifiers_before": [
                    "self",
                    "skip_animations",
                    "skip_time",
                    "time"
                ],
                "identifiers_after": [
                    "self",
                    "skip_animations",
                    "time",
                    "virtual_animation_start_time"
                ],
                "prefix": [
                    "                raise EndSceneEarlyException()\n",
                    "\n",
                    "    def stop_skipping(self):\n"
                ],
                "suffix": [
                    "\n",
                    "    # Methods associated with running animations\n",
                    "    def get_time_progression(self, run_time, n_iterations=None, desc=\"\", override_skip_animations=False):\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "    # Methods associated with running animations\n",
                "    def get_time_progression(self, run_time, n_iterations=None, desc=\"\", override_skip_animations=False):\n",
                "        if self.skip_animations and not override_skip_animations:\n",
                "            return [run_time]\n",
                "        else:\n",
                "            step = 1 / self.camera.frame_rate\n",
                "            times = np.arange(0, run_time, step)\n",
                "\n",
                "        if self.file_writer.has_progress_display:\n",
                "            self.file_writer.set_progress_display_subdescription(desc)\n",
                "            return times\n",
                "\n",
                "        return ProgressDisplay(\n",
                "            times,\n",
                "            total=n_iterations,\n",
                "            leave=self.leave_progress_bars,\n",
                "            ascii=True if platform.system() == 'Windows' else None,\n",
                "            desc=desc,\n",
                "        )\n",
                "\n",
                "    def get_run_time(self, animations):\n",
                "        return np.max([animation.run_time for animation in animations])\n",
                "\n",
                "    def get_animation_time_progression(self, animations):\n",
                "        run_time = self.get_run_time(animations)\n",
                "        description = f\"{self.num_plays} {animations[0]}\"\n",
                "        if len(animations) > 1:\n",
                "            description += \", etc.\"\n",
                "        time_progression = self.get_time_progression(run_time, desc=description)\n",
                "        return time_progression\n",
                "\n",
                "    def get_wait_time_progression(self, duration, stop_condition=None):\n",
                "        kw = {\"desc\": f\"{self.num_plays} Waiting\"}\n",
                "        if stop_condition is not None:\n",
                "            kw[\"n_iterations\"] = -1  # So it doesn't show % progress\n",
                "            kw[\"override_skip_animations\"] = True\n",
                "        return self.get_time_progression(duration, **kw)\n",
                "\n",
                "    def anims_from_play_args(self, *args, **kwargs):\n",
                "        \"\"\"\n",
                "        Each arg can either be an animation, or a mobject method\n",
                "        followed by that methods arguments (and potentially follow\n",
                "        by a dict of kwargs for that method).\n",
                "        This animation list is built by going through the args list,\n",
                "        and each animation is simply added, but when a mobject method\n",
                "        s hit, a MoveToTarget animation is built using the args that\n",
                "        follow up until either another animation is hit, another method\n",
                "        is hit, or the args list runs out.\n",
                "        \"\"\"\n",
                "        animations = []\n",
                "        state = {\n",
                "            \"curr_method\": None,\n",
                "            \"last_method\": None,\n",
                "            \"method_args\": [],\n",
                "        }\n",
                "\n",
                "        def compile_method(state):\n",
                "            if state[\"curr_method\"] is None:\n",
                "                return\n",
                "            mobject = state[\"curr_method\"].__self__\n",
                "            if state[\"last_method\"] and state[\"last_method\"].__self__ is mobject:\n",
                "                animations.pop()\n",
                "                # method should already have target then.\n",
                "            else:\n",
                "                mobject.generate_target()\n",
                "            #\n",
                "            if len(state[\"method_args\"]) > 0 and isinstance(state[\"method_args\"][-1], dict):\n",
                "                method_kwargs = state[\"method_args\"].pop()\n",
                "            else:\n",
                "                method_kwargs = {}\n",
                "            state[\"curr_method\"].__func__(\n",
                "                mobject.target,\n",
                "                *state[\"method_args\"],\n",
                "                **method_kwargs\n",
                "            )\n",
                "            animations.append(MoveToTarget(mobject))\n",
                "            state[\"last_method\"] = state[\"curr_method\"]\n",
                "            state[\"curr_method\"] = None\n",
                "            state[\"method_args\"] = []\n",
                "\n",
                "        for arg in args:\n",
                "            if inspect.ismethod(arg):\n",
                "                compile_method(state)\n",
                "                state[\"curr_method\"] = arg\n",
                "            elif state[\"curr_method\"] is not None:\n",
                "                state[\"method_args\"].append(arg)\n",
                "            elif isinstance(arg, Mobject):\n",
                "                raise Exception(\"\"\"\n",
                "                    I think you may have invoked a method\n",
                "                    you meant to pass in as a Scene.play argument\n",
                "                \"\"\")\n",
                "            else:\n",
                "                try:\n",
                "                    anim = prepare_animation(arg)\n",
                "                except TypeError:\n",
                "                    raise TypeError(f\"Unexpected argument {arg} passed to Scene.play()\")\n",
                "\n",
                "                compile_method(state)\n",
                "                animations.append(anim)\n",
                "        compile_method(state)\n",
                "\n",
                "        for animation in animations:\n",
                "            # This is where kwargs to play like run_time and rate_func\n",
                "            # get applied to all animations\n",
                "            animation.update_config(**kwargs)\n",
                "\n",
                "        return animations\n",
                "\n",
                "    def handle_play_like_call(func):\n",
                "        @wraps(func)\n",
                "        def wrapper(self, *args, **kwargs):\n",
                "            self.update_skipping_status()\n",
                "            should_write = not self.skip_animations\n",
                "            if should_write:\n",
                "                self.file_writer.begin_animation()\n",
                "\n",
                "            if self.window:\n",
                "                self.real_animation_start_time = time.time()\n",
                "                self.virtual_animation_start_time = self.time\n",
                "\n",
                "            func(self, *args, **kwargs)\n",
                "\n",
                "            if should_write:\n",
                "                self.file_writer.end_animation()\n",
                "\n",
                "            self.num_plays += 1\n",
                "        return wrapper\n",
                "\n",
                "    def lock_static_mobject_data(self, *animations):\n",
                "        movers = list(it.chain(*[\n",
                "            anim.mobject.get_family()\n",
                "            for anim in animations\n",
                "        ]))\n",
                "        for mobject in self.mobjects:\n",
                "            if mobject in movers or mobject.get_family_updaters():\n",
                "                continue\n",
                "            self.camera.set_mobjects_as_static(mobject)\n",
                "\n",
                "    def unlock_mobject_data(self):\n",
                "        self.camera.release_static_mobjects()\n",
                "\n",
                "    def begin_animations(self, animations):\n",
                "        for animation in animations:\n",
                "            animation.begin()\n",
                "            # Anything animated that's not already in the\n",
                "            # scene gets added to the scene.  Note, for\n",
                "            # animated mobjects that are in the family of\n",
                "            # those on screen, this can result in a restructuring\n",
                "            # of the scene.mobjects list, which is usually desired.\n",
                "            if animation.mobject not in self.mobjects:\n",
                "                self.add(animation.mobject)\n",
                "\n",
                "    def progress_through_animations(self, animations):\n",
                "        last_t = 0\n",
                "        for t in self.get_animation_time_progression(animations):\n",
                "            dt = t - last_t\n",
                "            last_t = t\n",
                "            for animation in animations:\n",
                "                animation.update_mobjects(dt)\n",
                "                alpha = t / animation.run_time\n",
                "                animation.interpolate(alpha)\n",
                "            self.update_frame(dt)\n",
                "            self.emit_frame()\n",
                "\n",
                "    def finish_animations(self, animations):\n",
                "        for animation in animations:\n",
                "            animation.finish()\n",
                "            animation.clean_up_from_scene(self)\n",
                "        if self.skip_animations:\n",
                "            self.update_mobjects(self.get_run_time(animations))\n",
                "        else:\n",
                "            self.update_mobjects(0)\n",
                "\n",
                "    @handle_play_like_call\n",
                "    def play(self, *args, **kwargs):\n",
                "        if len(args) == 0:\n",
                "            log.warning(\"Called Scene.play with no animations\")\n",
                "            return\n",
                "        animations = self.anims_from_play_args(*args, **kwargs)\n",
                "        self.lock_static_mobject_data(*animations)\n",
                "        self.begin_animations(animations)\n",
                "        self.progress_through_animations(animations)\n",
                "        self.finish_animations(animations)\n",
                "        self.unlock_mobject_data()\n",
                "\n",
                "    @handle_play_like_call\n",
                "    def wait(self, duration=DEFAULT_WAIT_TIME, stop_condition=None):\n",
                "        self.update_mobjects(dt=0)  # Any problems with this?\n",
                "        if self.should_update_mobjects():\n",
                "            self.lock_static_mobject_data()\n",
                "            time_progression = self.get_wait_time_progression(duration, stop_condition)\n",
                "            last_t = 0\n",
                "            for t in time_progression:\n",
                "                dt = t - last_t\n",
                "                last_t = t\n",
                "                self.update_frame(dt)\n",
                "                self.emit_frame()\n",
                "                if stop_condition is not None and stop_condition():\n",
                "                    time_progression.close()\n",
                "                    break\n",
                "            self.unlock_mobject_data()\n",
                "        else:\n",
                "            self.update_frame(duration)\n",
                "            for n in self.get_wait_time_progression(duration):\n",
                "                self.emit_frame()\n",
                "        return self\n",
                "\n",
                "    def wait_until(self, stop_condition, max_time=60):\n",
                "        self.wait(max_time, stop_condition=stop_condition)\n",
                "\n",
                "    def force_skipping(self):\n",
                "        self.original_skipping_status = self.skip_animations\n",
                "        self.skip_animations = True\n",
                "        return self\n",
                "\n",
                "    def revert_to_original_skipping_status(self):\n",
                "        if hasattr(self, \"original_skipping_status\"):\n",
                "            self.skip_animations = self.original_skipping_status\n",
                "        return self\n",
                "\n",
                "    def add_sound(self, sound_file, time_offset=0, gain=None, **kwargs):\n",
                "        if self.skip_animations:\n",
                "            return\n",
                "        time = self.get_time() + time_offset\n",
                "        self.file_writer.add_sound(sound_file, time, gain, **kwargs)\n",
                "\n",
                "    # Helpers for interactive development\n",
                "    def save_state(self):\n",
                "        self.saved_state = {\n",
                "            \"mobjects\": self.mobjects,\n",
                "            \"mobject_states\": [\n",
                "                mob.copy()\n",
                "                for mob in self.mobjects\n",
                "            ],\n",
                "        }\n",
                "\n",
                "    def restore(self):\n",
                "        if not hasattr(self, \"saved_state\"):\n",
                "            raise Exception(\"Trying to restore scene without having saved\")\n",
                "        mobjects = self.saved_state[\"mobjects\"]\n",
                "        states = self.saved_state[\"mobject_states\"]\n",
                "        for mob, state in zip(mobjects, states):\n",
                "            mob.become(state)\n",
                "        self.mobjects = mobjects\n",
                "\n",
                "    # Event handling\n",
                "\n",
                "    def on_mouse_motion(self, point, d_point):\n",
                "        self.mouse_point.move_to(point)\n",
                "\n",
                "        event_data = {\"point\": point, \"d_point\": d_point}\n",
                "        propagate_event = EVENT_DISPATCHER.dispatch(EventType.MouseMotionEvent, **event_data)\n",
                "        if propagate_event is not None and propagate_event is False:\n",
                "            return\n",
                "\n",
                "        frame = self.camera.frame\n",
                "        if self.window.is_key_pressed(ord(\"d\")):\n",
                "            frame.increment_theta(-d_point[0])\n",
                "            frame.increment_phi(d_point[1])\n",
                "        elif self.window.is_key_pressed(ord(\"s\")):\n",
                "            shift = -d_point\n",
                "            shift[0] *= frame.get_width() / 2\n",
                "            shift[1] *= frame.get_height() / 2\n",
                "            transform = frame.get_inverse_camera_rotation_matrix()\n",
                "            shift = np.dot(np.transpose(transform), shift)\n",
                "            frame.shift(shift)\n",
                "\n",
                "    def on_mouse_drag(self, point, d_point, buttons, modifiers):\n",
                "        self.mouse_drag_point.move_to(point)\n",
                "\n",
                "        event_data = {\"point\": point, \"d_point\": d_point, \"buttons\": buttons, \"modifiers\": modifiers}\n",
                "        propagate_event = EVENT_DISPATCHER.dispatch(EventType.MouseDragEvent, **event_data)\n",
                "        if propagate_event is not None and propagate_event is False:\n",
                "            return\n",
                "\n",
                "    def on_mouse_press(self, point, button, mods):\n",
                "        event_data = {\"point\": point, \"button\": button, \"mods\": mods}\n",
                "        propagate_event = EVENT_DISPATCHER.dispatch(EventType.MousePressEvent, **event_data)\n",
                "        if propagate_event is not None and propagate_event is False:\n",
                "            return\n",
                "\n",
                "    def on_mouse_release(self, point, button, mods):\n",
                "        event_data = {\"point\": point, \"button\": button, \"mods\": mods}\n",
                "        propagate_event = EVENT_DISPATCHER.dispatch(EventType.MouseReleaseEvent, **event_data)\n",
                "        if propagate_event is not None and propagate_event is False:\n",
                "            return\n",
                "\n",
                "    def on_mouse_scroll(self, point, offset):\n",
                "        event_data = {\"point\": point, \"offset\": offset}\n",
                "        propagate_event = EVENT_DISPATCHER.dispatch(EventType.MouseScrollEvent, **event_data)\n",
                "        if propagate_event is not None and propagate_event is False:\n",
                "            return\n",
                "\n",
                "        frame = self.camera.frame\n",
                "        if self.window.is_key_pressed(ord(\"z\")):\n",
                "            factor = 1 + np.arctan(10 * offset[1])\n",
                "            frame.scale(1/factor, about_point=point)\n",
                "        else:\n",
                "            transform = frame.get_inverse_camera_rotation_matrix()\n",
                "            shift = np.dot(np.transpose(transform), offset)\n",
                "            frame.shift(-20.0 * shift)\n",
                "\n",
                "    def on_key_release(self, symbol, modifiers):\n",
                "        event_data = {\"symbol\": symbol, \"modifiers\": modifiers}\n",
                "        propagate_event = EVENT_DISPATCHER.dispatch(EventType.KeyReleaseEvent, **event_data)\n",
                "        if propagate_event is not None and propagate_event is False:\n",
                "            return\n",
                "\n",
                "    def on_key_press(self, symbol, modifiers):\n",
                "        try:\n",
                "            char = chr(symbol)\n",
                "        except OverflowError:\n",
                "            log.warning(\"The value of the pressed key is too large.\")\n",
                "            return\n",
                "\n",
                "        event_data = {\"symbol\": symbol, \"modifiers\": modifiers}\n",
                "        propagate_event = EVENT_DISPATCHER.dispatch(EventType.KeyPressEvent, **event_data)\n",
                "        if propagate_event is not None and propagate_event is False:\n",
                "            return\n",
                "\n",
                "        if char == \"r\":\n",
                "            self.camera.frame.to_default_state()\n",
                "        elif char == \"q\":\n",
                "            self.quit_interaction = True\n",
                "\n",
                "    def on_resize(self, width: int, height: int):\n",
                "        self.camera.reset_pixel_shape(width, height)\n",
                "\n",
                "    def on_show(self):\n",
                "        pass\n",
                "\n",
                "    def on_hide(self):\n",
                "        pass\n",
                "\n",
                "    def on_close(self):\n",
                "        pass\n",
                "\n",
                "\n",
                "class EndSceneEarlyException(Exception):\n",
                "    pass"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "refactor"
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "0 before 1",
            "reason": "move"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        }
    ]
}