{
    "language": "python",
    "commit_url": "https://github.com/numpy/numpy/commit/3cdcbe0f8402e795262341837afe39a279d9b888",
    "commit_message": "MAINT: Improve error message from sorting with duplicate key\n\nFixes #9082",
    "commit_snapshots": {
        "numpy/core/_internal.py": [
            [
                "\"\"\"\n",
                "A place for code to be called from core C-code.\n",
                "\n",
                "Some things are more easily handled Python.\n",
                "\n",
                "\"\"\"\n",
                "from __future__ import division, absolute_import, print_function\n",
                "\n",
                "import re\n",
                "import sys\n",
                "\n",
                "from numpy.compat import basestring\n",
                "from .multiarray import dtype, array, ndarray\n",
                "try:\n",
                "    import ctypes\n",
                "except ImportError:\n",
                "    ctypes = None\n",
                "from .numerictypes import object_\n",
                "\n",
                "if (sys.byteorder == 'little'):\n",
                "    _nbo = b'<'\n",
                "else:\n",
                "    _nbo = b'>'\n",
                "\n",
                "def _makenames_list(adict, align):\n",
                "    allfields = []\n",
                "    fnames = list(adict.keys())\n",
                "    for fname in fnames:\n",
                "        obj = adict[fname]\n",
                "        n = len(obj)\n",
                "        if not isinstance(obj, tuple) or n not in [2, 3]:\n",
                "            raise ValueError(\"entry not a 2- or 3- tuple\")\n",
                "        if (n > 2) and (obj[2] == fname):\n",
                "            continue\n",
                "        num = int(obj[1])\n",
                "        if (num < 0):\n",
                "            raise ValueError(\"invalid offset.\")\n",
                "        format = dtype(obj[0], align=align)\n",
                "        if (n > 2):\n",
                "            title = obj[2]\n",
                "        else:\n",
                "            title = None\n",
                "        allfields.append((fname, format, num, title))\n",
                "    # sort by offsets\n",
                "    allfields.sort(key=lambda x: x[2])\n",
                "    names = [x[0] for x in allfields]\n",
                "    formats = [x[1] for x in allfields]\n",
                "    offsets = [x[2] for x in allfields]\n",
                "    titles = [x[3] for x in allfields]\n",
                "\n",
                "    return names, formats, offsets, titles\n",
                "\n",
                "# Called in PyArray_DescrConverter function when\n",
                "#  a dictionary without \"names\" and \"formats\"\n",
                "#  fields is used as a data-type descriptor.\n",
                "def _usefields(adict, align):\n",
                "    try:\n",
                "        names = adict[-1]\n",
                "    except KeyError:\n",
                "        names = None\n",
                "    if names is None:\n",
                "        names, formats, offsets, titles = _makenames_list(adict, align)\n",
                "    else:\n",
                "        formats = []\n",
                "        offsets = []\n",
                "        titles = []\n",
                "        for name in names:\n",
                "            res = adict[name]\n",
                "            formats.append(res[0])\n",
                "            offsets.append(res[1])\n",
                "            if (len(res) > 2):\n",
                "                titles.append(res[2])\n",
                "            else:\n",
                "                titles.append(None)\n",
                "\n",
                "    return dtype({\"names\": names,\n",
                "                  \"formats\": formats,\n",
                "                  \"offsets\": offsets,\n",
                "                  \"titles\": titles}, align)\n",
                "\n",
                "\n",
                "# construct an array_protocol descriptor list\n",
                "#  from the fields attribute of a descriptor\n",
                "# This calls itself recursively but should eventually hit\n",
                "#  a descriptor that has no fields and then return\n",
                "#  a simple typestring\n",
                "\n",
                "def _array_descr(descriptor):\n",
                "    fields = descriptor.fields\n",
                "    if fields is None:\n",
                "        subdtype = descriptor.subdtype\n",
                "        if subdtype is None:\n",
                "            if descriptor.metadata is None:\n",
                "                return descriptor.str\n",
                "            else:\n",
                "                new = descriptor.metadata.copy()\n",
                "                if new:\n",
                "                    return (descriptor.str, new)\n",
                "                else:\n",
                "                    return descriptor.str\n",
                "        else:\n",
                "            return (_array_descr(subdtype[0]), subdtype[1])\n",
                "\n",
                "    names = descriptor.names\n",
                "    ordered_fields = [fields[x] + (x,) for x in names]\n",
                "    result = []\n",
                "    offset = 0\n",
                "    for field in ordered_fields:\n",
                "        if field[1] > offset:\n",
                "            num = field[1] - offset\n",
                "            result.append(('', '|V%d' % num))\n",
                "            offset += num\n",
                "        if len(field) > 3:\n",
                "            name = (field[2], field[3])\n",
                "        else:\n",
                "            name = field[2]\n",
                "        if field[0].subdtype:\n",
                "            tup = (name, _array_descr(field[0].subdtype[0]),\n",
                "                   field[0].subdtype[1])\n",
                "        else:\n",
                "            tup = (name, _array_descr(field[0]))\n",
                "        offset += field[0].itemsize\n",
                "        result.append(tup)\n",
                "\n",
                "    if descriptor.itemsize > offset:\n",
                "        num = descriptor.itemsize - offset\n",
                "        result.append(('', '|V%d' % num))\n",
                "\n",
                "    return result\n",
                "\n",
                "# Build a new array from the information in a pickle.\n",
                "# Note that the name numpy.core._internal._reconstruct is embedded in\n",
                "# pickles of ndarrays made with NumPy before release 1.0\n",
                "# so don't remove the name here, or you'll\n",
                "# break backward compatibility.\n",
                "def _reconstruct(subtype, shape, dtype):\n",
                "    return ndarray.__new__(subtype, shape, dtype)\n",
                "\n",
                "\n",
                "# format_re was originally from numarray by J. Todd Miller\n",
                "\n",
                "format_re = re.compile(br'(?P<order1>[<>|=]?)'\n",
                "                       br'(?P<repeats> *[(]?[ ,0-9L]*[)]? *)'\n",
                "                       br'(?P<order2>[<>|=]?)'\n",
                "                       br'(?P<dtype>[A-Za-z0-9.?]*(?:\\[[a-zA-Z0-9,.]+\\])?)')\n",
                "sep_re = re.compile(br'\\s*,\\s*')\n",
                "space_re = re.compile(br'\\s+$')\n",
                "\n",
                "# astr is a string (perhaps comma separated)\n",
                "\n",
                "_convorder = {b'=': _nbo}\n",
                "\n",
                "def _commastring(astr):\n",
                "    startindex = 0\n",
                "    result = []\n",
                "    while startindex < len(astr):\n",
                "        mo = format_re.match(astr, pos=startindex)\n",
                "        try:\n",
                "            (order1, repeats, order2, dtype) = mo.groups()\n",
                "        except (TypeError, AttributeError):\n",
                "            raise ValueError('format number %d of \"%s\" is not recognized' %\n",
                "                                            (len(result)+1, astr))\n",
                "        startindex = mo.end()\n",
                "        # Separator or ending padding\n",
                "        if startindex < len(astr):\n",
                "            if space_re.match(astr, pos=startindex):\n",
                "                startindex = len(astr)\n",
                "            else:\n",
                "                mo = sep_re.match(astr, pos=startindex)\n",
                "                if not mo:\n",
                "                    raise ValueError(\n",
                "                        'format number %d of \"%s\" is not recognized' %\n",
                "                        (len(result)+1, astr))\n",
                "                startindex = mo.end()\n",
                "\n",
                "        if order2 == b'':\n",
                "            order = order1\n",
                "        elif order1 == b'':\n",
                "            order = order2\n",
                "        else:\n",
                "            order1 = _convorder.get(order1, order1)\n",
                "            order2 = _convorder.get(order2, order2)\n",
                "            if (order1 != order2):\n",
                "                raise ValueError(\n",
                "                    'inconsistent byte-order specification %s and %s' %\n",
                "                    (order1, order2))\n",
                "            order = order1\n",
                "\n",
                "        if order in [b'|', b'=', _nbo]:\n",
                "            order = b''\n",
                "        dtype = order + dtype\n",
                "        if (repeats == b''):\n",
                "            newitem = dtype\n",
                "        else:\n",
                "            newitem = (dtype, eval(repeats))\n",
                "        result.append(newitem)\n",
                "\n",
                "    return result\n",
                "\n",
                "class dummy_ctype(object):\n",
                "    def __init__(self, cls):\n",
                "        self._cls = cls\n",
                "    def __mul__(self, other):\n",
                "        return self\n",
                "    def __call__(self, *other):\n",
                "        return self._cls(other)\n",
                "    def __eq__(self, other):\n",
                "        return self._cls == other._cls\n",
                "\n",
                "def _getintp_ctype():\n",
                "    val = _getintp_ctype.cache\n",
                "    if val is not None:\n",
                "        return val\n",
                "    if ctypes is None:\n",
                "        import numpy as np\n",
                "        val = dummy_ctype(np.intp)\n",
                "    else:\n",
                "        char = dtype('p').char\n",
                "        if (char == 'i'):\n",
                "            val = ctypes.c_int\n",
                "        elif char == 'l':\n",
                "            val = ctypes.c_long\n",
                "        elif char == 'q':\n",
                "            val = ctypes.c_longlong\n",
                "        else:\n",
                "            val = ctypes.c_long\n",
                "    _getintp_ctype.cache = val\n",
                "    return val\n",
                "_getintp_ctype.cache = None\n",
                "\n",
                "# Used for .ctypes attribute of ndarray\n",
                "\n",
                "class _missing_ctypes(object):\n",
                "    def cast(self, num, obj):\n",
                "        return num\n",
                "\n",
                "    def c_void_p(self, num):\n",
                "        return num\n",
                "\n",
                "class _ctypes(object):\n",
                "    def __init__(self, array, ptr=None):\n",
                "        if ctypes:\n",
                "            self._ctypes = ctypes\n",
                "        else:\n",
                "            self._ctypes = _missing_ctypes()\n",
                "        self._arr = array\n",
                "        self._data = ptr\n",
                "        if self._arr.ndim == 0:\n",
                "            self._zerod = True\n",
                "        else:\n",
                "            self._zerod = False\n",
                "\n",
                "    def data_as(self, obj):\n",
                "        return self._ctypes.cast(self._data, obj)\n",
                "\n",
                "    def shape_as(self, obj):\n",
                "        if self._zerod:\n",
                "            return None\n",
                "        return (obj*self._arr.ndim)(*self._arr.shape)\n",
                "\n",
                "    def strides_as(self, obj):\n",
                "        if self._zerod:\n",
                "            return None\n",
                "        return (obj*self._arr.ndim)(*self._arr.strides)\n",
                "\n",
                "    def get_data(self):\n",
                "        return self._data\n",
                "\n",
                "    def get_shape(self):\n",
                "        return self.shape_as(_getintp_ctype())\n",
                "\n",
                "    def get_strides(self):\n",
                "        return self.strides_as(_getintp_ctype())\n",
                "\n",
                "    def get_as_parameter(self):\n",
                "        return self._ctypes.c_void_p(self._data)\n",
                "\n",
                "    data = property(get_data, None, doc=\"c-types data\")\n",
                "    shape = property(get_shape, None, doc=\"c-types shape\")\n",
                "    strides = property(get_strides, None, doc=\"c-types strides\")\n",
                "    _as_parameter_ = property(get_as_parameter, None, doc=\"_as parameter_\")\n",
                "\n",
                "\n"
            ],
            {
                "type": "delete",
                "before": [
                    "# Given a datatype and an order object\n",
                    "#  return a new names tuple\n",
                    "#  with the order indicated\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 283,
                    "end": 286
                },
                "child_version_range": {
                    "start": 283,
                    "end": 283
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 0,
                "hunk_diff": "File: numpy/core/_internal.py\nCode:\n  ...\n280 280        _as_parameter_ = property(get_as_parameter, None, doc=\"_as parameter_\")\n281 281    \n282 282    \n283      - # Given a datatype and an order object\n284      - #  return a new names tuple\n285      - #  with the order indicated\n286 283    def _newnames(datatype, order):\n         ...\n",
                "file_path": "numpy/core/_internal.py",
                "identifiers_before": [],
                "identifiers_after": [],
                "prefix": [
                    "    _as_parameter_ = property(get_as_parameter, None, doc=\"_as parameter_\")\n",
                    "\n",
                    "\n"
                ],
                "suffix": [
                    "def _newnames(datatype, order):\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "def _newnames(datatype, order):\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    \"\"\"\n",
                    "    Given a datatype and an order object, return a new names tuple, with the\n",
                    "    order indicated\n",
                    "    \"\"\"\n"
                ],
                "parent_version_range": {
                    "start": 287,
                    "end": 287
                },
                "child_version_range": {
                    "start": 284,
                    "end": 288
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "_newnames",
                        "signature": "def _newnames(datatype, order):",
                        "at_line": 286
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: numpy/core/_internal.py\nCode:\n286 283    def _newnames(datatype, order):\n    284  +     \"\"\"\n    285  +     Given a datatype and an order object, return a new names tuple, with the\n    286  +     order indicated\n    287  +     \"\"\"\n287 288        oldnames = datatype.names\n288 289        nameslist = list(oldnames)\n289 290        if isinstance(order, str):\n         ...\n",
                "file_path": "numpy/core/_internal.py",
                "identifiers_before": [],
                "identifiers_after": [],
                "prefix": [
                    "def _newnames(datatype, order):\n"
                ],
                "suffix": [
                    "    oldnames = datatype.names\n",
                    "    nameslist = list(oldnames)\n",
                    "    if isinstance(order, str):\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    oldnames = datatype.names\n",
                "    nameslist = list(oldnames)\n",
                "    if isinstance(order, str):\n",
                "        order = [order]\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    seen = set()\n"
                ],
                "parent_version_range": {
                    "start": 291,
                    "end": 291
                },
                "child_version_range": {
                    "start": 292,
                    "end": 293
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if isinstance(order, str):",
                        "start_line": 289,
                        "end_line": 290
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "_newnames",
                        "signature": "def _newnames(datatype, order):",
                        "at_line": 286
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: numpy/core/_internal.py\nCode:\n           def _newnames(datatype, order):\n               ...\n288 289        nameslist = list(oldnames)\n289 290        if isinstance(order, str):\n290 291            order = [order]\n    292  +     seen = set()\n291 293        if isinstance(order, (list, tuple)):\n292 294            for name in order:\n293 295                try:\n         ...\n",
                "file_path": "numpy/core/_internal.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "seen",
                    "set"
                ],
                "prefix": [
                    "    nameslist = list(oldnames)\n",
                    "    if isinstance(order, str):\n",
                    "        order = [order]\n"
                ],
                "suffix": [
                    "    if isinstance(order, (list, tuple)):\n",
                    "        for name in order:\n",
                    "            try:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "seen",
                            "position": {
                                "start": {
                                    "line": 292,
                                    "column": 4
                                },
                                "end": {
                                    "line": 292,
                                    "column": 8
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/numpy/numpy/core/_internal.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "seen",
                            "position": {
                                "start": {
                                    "line": 292,
                                    "column": 4
                                },
                                "end": {
                                    "line": 292,
                                    "column": 8
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/numpy/numpy/core/_internal.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "    if isinstance(order, (list, tuple)):\n",
                "        for name in order:\n",
                "            try:\n",
                "                nameslist.remove(name)\n",
                "            except ValueError:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                raise ValueError(\"unknown field name: %s\" % (name,))\n"
                ],
                "after": [
                    "                if name in seen:\n",
                    "                    raise ValueError(\"duplicate field name: %s\" % (name,))\n",
                    "                else:\n",
                    "                    raise ValueError(\"unknown field name: %s\" % (name,))\n",
                    "            seen.add(name)\n"
                ],
                "parent_version_range": {
                    "start": 296,
                    "end": 297
                },
                "child_version_range": {
                    "start": 298,
                    "end": 303
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if isinstance(order, (list, tuple)):",
                        "start_line": 291,
                        "end_line": 297
                    },
                    {
                        "type": "for_statement",
                        "statement": "for name in order:",
                        "start_line": 292,
                        "end_line": 296
                    },
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 293,
                        "end_line": 296
                    },
                    {
                        "type": "except_clause",
                        "statement": "except ValueError:",
                        "start_line": 295,
                        "end_line": 296
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "_newnames",
                        "signature": "def _newnames(datatype, order):",
                        "at_line": 286
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: numpy/core/_internal.py\nCode:\n           def _newnames(datatype, order):\n               ...\n293 295                try:\n294 296                    nameslist.remove(name)\n295 297                except ValueError:\n296      -                 raise ValueError(\"unknown field name: %s\" % (name,))\n    298  +                 if name in seen:\n    299  +                     raise ValueError(\"duplicate field name: %s\" % (name,))\n    300  +                 else:\n    301  +                     raise ValueError(\"unknown field name: %s\" % (name,))\n    302  +             seen.add(name)\n297 303            return tuple(list(order) + nameslist)\n298 304        raise ValueError(\"unsupported order value: %s\" % (order,))\n299 305    \n         ...\n",
                "file_path": "numpy/core/_internal.py",
                "identifiers_before": [
                    "ValueError",
                    "name"
                ],
                "identifiers_after": [
                    "ValueError",
                    "add",
                    "name",
                    "seen"
                ],
                "prefix": [
                    "            try:\n",
                    "                nameslist.remove(name)\n",
                    "            except ValueError:\n"
                ],
                "suffix": [
                    "        return tuple(list(order) + nameslist)\n",
                    "    raise ValueError(\"unsupported order value: %s\" % (order,))\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "seen",
                            "position": {
                                "start": {
                                    "line": 298,
                                    "column": 27
                                },
                                "end": {
                                    "line": 298,
                                    "column": 31
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/numpy/numpy/core/_internal.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "seen",
                            "position": {
                                "start": {
                                    "line": 302,
                                    "column": 12
                                },
                                "end": {
                                    "line": 302,
                                    "column": 16
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/numpy/numpy/core/_internal.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        return tuple(list(order) + nameslist)\n",
                "    raise ValueError(\"unsupported order value: %s\" % (order,))\n",
                "\n",
                "def _copy_fields(ary):\n",
                "    \"\"\"Return copy of structured array with padding between fields removed.\n",
                "\n",
                "    Parameters\n",
                "    ----------\n",
                "    ary : ndarray\n",
                "       Structured array from which to remove padding bytes\n",
                "\n",
                "    Returns\n",
                "    -------\n",
                "    ary_copy : ndarray\n",
                "       Copy of ary with padding bytes removed\n",
                "    \"\"\"\n",
                "    dt = ary.dtype\n",
                "    copy_dtype = {'names': dt.names,\n",
                "                  'formats': [dt.fields[name][0] for name in dt.names]}\n",
                "    return array(ary, dtype=copy_dtype, copy=True)\n",
                "\n",
                "def _getfield_is_safe(oldtype, newtype, offset):\n",
                "    \"\"\" Checks safety of getfield for object arrays.\n",
                "\n",
                "    As in _view_is_safe, we need to check that memory containing objects is not\n",
                "    reinterpreted as a non-object datatype and vice versa.\n",
                "\n",
                "    Parameters\n",
                "    ----------\n",
                "    oldtype : data-type\n",
                "        Data type of the original ndarray.\n",
                "    newtype : data-type\n",
                "        Data type of the field being accessed by ndarray.getfield\n",
                "    offset : int\n",
                "        Offset of the field being accessed by ndarray.getfield\n",
                "\n",
                "    Raises\n",
                "    ------\n",
                "    TypeError\n",
                "        If the field access is invalid\n",
                "\n",
                "    \"\"\"\n",
                "    if newtype.hasobject or oldtype.hasobject:\n",
                "        if offset == 0 and newtype == oldtype:\n",
                "            return\n",
                "        if oldtype.names:\n",
                "            for name in oldtype.names:\n",
                "                if (oldtype.fields[name][1] == offset and\n",
                "                        oldtype.fields[name][0] == newtype):\n",
                "                    return\n",
                "        raise TypeError(\"Cannot get/set field of an object array\")\n",
                "    return\n",
                "\n",
                "def _view_is_safe(oldtype, newtype):\n",
                "    \"\"\" Checks safety of a view involving object arrays, for example when\n",
                "    doing::\n",
                "\n",
                "        np.zeros(10, dtype=oldtype).view(newtype)\n",
                "\n",
                "    Parameters\n",
                "    ----------\n",
                "    oldtype : data-type\n",
                "        Data type of original ndarray\n",
                "    newtype : data-type\n",
                "        Data type of the view\n",
                "\n",
                "    Raises\n",
                "    ------\n",
                "    TypeError\n",
                "        If the new type is incompatible with the old type.\n",
                "\n",
                "    \"\"\"\n",
                "\n",
                "    # if the types are equivalent, there is no problem.\n",
                "    # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))\n",
                "    if oldtype == newtype:\n",
                "        return\n",
                "\n",
                "    if newtype.hasobject or oldtype.hasobject:\n",
                "        raise TypeError(\"Cannot change data-type for object array.\")\n",
                "    return\n",
                "\n",
                "# Given a string containing a PEP 3118 format specifier,\n",
                "# construct a NumPy dtype\n",
                "\n",
                "_pep3118_native_map = {\n",
                "    '?': '?',\n",
                "    'c': 'S1',\n",
                "    'b': 'b',\n",
                "    'B': 'B',\n",
                "    'h': 'h',\n",
                "    'H': 'H',\n",
                "    'i': 'i',\n",
                "    'I': 'I',\n",
                "    'l': 'l',\n",
                "    'L': 'L',\n",
                "    'q': 'q',\n",
                "    'Q': 'Q',\n",
                "    'e': 'e',\n",
                "    'f': 'f',\n",
                "    'd': 'd',\n",
                "    'g': 'g',\n",
                "    'Zf': 'F',\n",
                "    'Zd': 'D',\n",
                "    'Zg': 'G',\n",
                "    's': 'S',\n",
                "    'w': 'U',\n",
                "    'O': 'O',\n",
                "    'x': 'V',  # padding\n",
                "}\n",
                "_pep3118_native_typechars = ''.join(_pep3118_native_map.keys())\n",
                "\n",
                "_pep3118_standard_map = {\n",
                "    '?': '?',\n",
                "    'c': 'S1',\n",
                "    'b': 'b',\n",
                "    'B': 'B',\n",
                "    'h': 'i2',\n",
                "    'H': 'u2',\n",
                "    'i': 'i4',\n",
                "    'I': 'u4',\n",
                "    'l': 'i4',\n",
                "    'L': 'u4',\n",
                "    'q': 'i8',\n",
                "    'Q': 'u8',\n",
                "    'e': 'f2',\n",
                "    'f': 'f',\n",
                "    'd': 'd',\n",
                "    'Zf': 'F',\n",
                "    'Zd': 'D',\n",
                "    's': 'S',\n",
                "    'w': 'U',\n",
                "    'O': 'O',\n",
                "    'x': 'V',  # padding\n",
                "}\n",
                "_pep3118_standard_typechars = ''.join(_pep3118_standard_map.keys())\n",
                "\n",
                "def _dtype_from_pep3118(spec):\n",
                "\n",
                "    class Stream(object):\n",
                "        def __init__(self, s):\n",
                "            self.s = s\n",
                "            self.byteorder = '@'\n",
                "\n",
                "        def advance(self, n):\n",
                "            res = self.s[:n]\n",
                "            self.s = self.s[n:]\n",
                "            return res\n",
                "\n",
                "        def consume(self, c):\n",
                "            if self.s[:len(c)] == c:\n",
                "                self.advance(len(c))\n",
                "                return True\n",
                "            return False\n",
                "\n",
                "        def consume_until(self, c):\n",
                "            if callable(c):\n",
                "                i = 0\n",
                "                while i < len(self.s) and not c(self.s[i]):\n",
                "                    i = i + 1\n",
                "                return self.advance(i)\n",
                "            else:\n",
                "                i = self.s.index(c)\n",
                "                res = self.advance(i)\n",
                "                self.advance(len(c))\n",
                "                return res\n",
                "\n",
                "        @property\n",
                "        def next(self):\n",
                "            return self.s[0]\n",
                "\n",
                "        def __bool__(self):\n",
                "            return bool(self.s)\n",
                "        __nonzero__ = __bool__\n",
                "\n",
                "    stream = Stream(spec)\n",
                "\n",
                "    dtype, align = __dtype_from_pep3118(stream, is_subdtype=False)\n",
                "    return dtype\n",
                "\n",
                "def __dtype_from_pep3118(stream, is_subdtype):\n",
                "    field_spec = dict(\n",
                "        names=[],\n",
                "        formats=[],\n",
                "        offsets=[],\n",
                "        itemsize=0\n",
                "    )\n",
                "    offset = 0\n",
                "    common_alignment = 1\n",
                "    is_padding = False\n",
                "\n",
                "    # Parse spec\n",
                "    while stream:\n",
                "        value = None\n",
                "\n",
                "        # End of structure, bail out to upper level\n",
                "        if stream.consume('}'):\n",
                "            break\n",
                "\n",
                "        # Sub-arrays (1)\n",
                "        shape = None\n",
                "        if stream.consume('('):\n",
                "            shape = stream.consume_until(')')\n",
                "            shape = tuple(map(int, shape.split(',')))\n",
                "\n",
                "        # Byte order\n",
                "        if stream.next in ('@', '=', '<', '>', '^', '!'):\n",
                "            byteorder = stream.advance(1)\n",
                "            if byteorder == '!':\n",
                "                byteorder = '>'\n",
                "            stream.byteorder = byteorder\n",
                "\n",
                "        # Byte order characters also control native vs. standard type sizes\n",
                "        if stream.byteorder in ('@', '^'):\n",
                "            type_map = _pep3118_native_map\n",
                "            type_map_chars = _pep3118_native_typechars\n",
                "        else:\n",
                "            type_map = _pep3118_standard_map\n",
                "            type_map_chars = _pep3118_standard_typechars\n",
                "\n",
                "        # Item sizes\n",
                "        itemsize_str = stream.consume_until(lambda c: not c.isdigit())\n",
                "        if itemsize_str:\n",
                "            itemsize = int(itemsize_str)\n",
                "        else:\n",
                "            itemsize = 1\n",
                "\n",
                "        # Data types\n",
                "        is_padding = False\n",
                "\n",
                "        if stream.consume('T{'):\n",
                "            value, align = __dtype_from_pep3118(\n",
                "                stream, is_subdtype=True)\n",
                "        elif stream.next in type_map_chars:\n",
                "            if stream.next == 'Z':\n",
                "                typechar = stream.advance(2)\n",
                "            else:\n",
                "                typechar = stream.advance(1)\n",
                "\n",
                "            is_padding = (typechar == 'x')\n",
                "            dtypechar = type_map[typechar]\n",
                "            if dtypechar in 'USV':\n",
                "                dtypechar += '%d' % itemsize\n",
                "                itemsize = 1\n",
                "            numpy_byteorder = {'@': '=', '^': '='}.get(\n",
                "                stream.byteorder, stream.byteorder)\n",
                "            value = dtype(numpy_byteorder + dtypechar)\n",
                "            align = value.alignment\n",
                "        else:\n",
                "            raise ValueError(\"Unknown PEP 3118 data type specifier %r\" % stream.s)\n",
                "\n",
                "        #\n",
                "        # Native alignment may require padding\n",
                "        #\n",
                "        # Here we assume that the presence of a '@' character implicitly implies\n",
                "        # that the start of the array is *already* aligned.\n",
                "        #\n",
                "        extra_offset = 0\n",
                "        if stream.byteorder == '@':\n",
                "            start_padding = (-offset) % align\n",
                "            intra_padding = (-value.itemsize) % align\n",
                "\n",
                "            offset += start_padding\n",
                "\n",
                "            if intra_padding != 0:\n",
                "                if itemsize > 1 or (shape is not None and _prod(shape) > 1):\n",
                "                    # Inject internal padding to the end of the sub-item\n",
                "                    value = _add_trailing_padding(value, intra_padding)\n",
                "                else:\n",
                "                    # We can postpone the injection of internal padding,\n",
                "                    # as the item appears at most once\n",
                "                    extra_offset += intra_padding\n",
                "\n",
                "            # Update common alignment\n",
                "            common_alignment = _lcm(align, common_alignment)\n",
                "\n",
                "        # Convert itemsize to sub-array\n",
                "        if itemsize != 1:\n",
                "            value = dtype((value, (itemsize,)))\n",
                "\n",
                "        # Sub-arrays (2)\n",
                "        if shape is not None:\n",
                "            value = dtype((value, shape))\n",
                "\n",
                "        # Field name\n",
                "        if stream.consume(':'):\n",
                "            name = stream.consume_until(':')\n",
                "        else:\n",
                "            name = None\n",
                "\n",
                "        if not (is_padding and name is None):\n",
                "            if name is not None and name in field_spec['names']:\n",
                "                raise RuntimeError(\"Duplicate field name '%s' in PEP3118 format\"\n",
                "                                   % name)\n",
                "            field_spec['names'].append(name)\n",
                "            field_spec['formats'].append(value)\n",
                "            field_spec['offsets'].append(offset)\n",
                "\n",
                "        offset += value.itemsize\n",
                "        offset += extra_offset\n",
                "\n",
                "        field_spec['itemsize'] = offset\n",
                "\n",
                "    # extra final padding for aligned types\n",
                "    if stream.byteorder == '@':\n",
                "        field_spec['itemsize'] += (-offset) % common_alignment\n",
                "\n",
                "    # Check if this was a simple 1-item type, and unwrap it\n",
                "    if (field_spec['names'] == [None]\n",
                "            and field_spec['offsets'][0] == 0\n",
                "            and field_spec['itemsize'] == field_spec['formats'][0].itemsize\n",
                "            and not is_subdtype):\n",
                "        ret = field_spec['formats'][0]\n",
                "    else:\n",
                "        _fix_names(field_spec)\n",
                "        ret = dtype(field_spec)\n",
                "\n",
                "    # Finished\n",
                "    return ret, common_alignment\n",
                "\n",
                "def _fix_names(field_spec):\n",
                "    \"\"\" Replace names which are None with the next unused f%d name \"\"\"\n",
                "    names = field_spec['names']\n",
                "    for i, name in enumerate(names):\n",
                "        if name is not None:\n",
                "            continue\n",
                "\n",
                "        j = 0\n",
                "        while True:\n",
                "            name = 'f{}'.format(j)\n",
                "            if name not in names:\n",
                "                break\n",
                "            j = j + 1\n",
                "        names[i] = name\n",
                "\n",
                "def _add_trailing_padding(value, padding):\n",
                "    \"\"\"Inject the specified number of padding bytes at the end of a dtype\"\"\"\n",
                "    if value.fields is None:\n",
                "        field_spec = dict(\n",
                "            names=['f0'],\n",
                "            formats=[value],\n",
                "            offsets=[0],\n",
                "            itemsize=value.itemsize\n",
                "        )\n",
                "    else:\n",
                "        fields = value.fields\n",
                "        names = value.names\n",
                "        field_spec = dict(\n",
                "            names=names,\n",
                "            formats=[fields[name][0] for name in names],\n",
                "            offsets=[fields[name][1] for name in names],\n",
                "            itemsize=value.itemsize\n",
                "        )\n",
                "\n",
                "    field_spec['itemsize'] += padding\n",
                "    return dtype(field_spec)\n",
                "\n",
                "def _prod(a):\n",
                "    p = 1\n",
                "    for x in a:\n",
                "        p *= x\n",
                "    return p\n",
                "\n",
                "def _gcd(a, b):\n",
                "    \"\"\"Calculate the greatest common divisor of a and b\"\"\"\n",
                "    while b:\n",
                "        a, b = b, a % b\n",
                "    return a\n",
                "\n",
                "def _lcm(a, b):\n",
                "    return a // _gcd(a, b) * b\n",
                "\n",
                "# Exception used in shares_memory()\n",
                "class TooHardError(RuntimeError):\n",
                "    pass\n",
                "\n",
                "class AxisError(ValueError, IndexError):\n",
                "    \"\"\" Axis supplied was invalid. \"\"\"\n",
                "    def __init__(self, axis, ndim=None, msg_prefix=None):\n",
                "        # single-argument form just delegates to base class\n",
                "        if ndim is None and msg_prefix is None:\n",
                "            msg = axis\n",
                "\n",
                "        # do the string formatting here, to save work in the C code\n",
                "        else:\n",
                "            msg = (\"axis {} is out of bounds for array of dimension {}\"\n",
                "                   .format(axis, ndim))\n",
                "            if msg_prefix is not None:\n",
                "                msg = \"{}: {}\".format(msg_prefix, msg)\n",
                "\n",
                "        super(AxisError, self).__init__(msg)\n",
                "\n",
                "\n",
                "def array_ufunc_errmsg_formatter(ufunc, method, *inputs, **kwargs):\n",
                "    \"\"\" Format the error message for when __array_ufunc__ gives up. \"\"\"\n",
                "    args_string = ', '.join(['{!r}'.format(arg) for arg in inputs] +\n",
                "                            ['{}={!r}'.format(k, v)\n",
                "                             for k, v in kwargs.items()])\n",
                "    args = inputs + kwargs.get('out', ())\n",
                "    types_string = ', '.join(repr(type(arg).__name__) for arg in args)\n",
                "    return ('operand type(s) do not implement __array_ufunc__'\n",
                "            '({!r}, {!r}, {}): {}'\n",
                "            .format(ufunc, method, args_string, types_string))\n",
                "\n",
                "def _ufunc_doc_signature_formatter(ufunc):\n",
                "    \"\"\"\n",
                "    Builds a signature string which resembles PEP 457\n",
                "\n",
                "    This is used to construct the first line of the docstring\n",
                "    \"\"\"\n",
                "\n",
                "    # input arguments are simple\n",
                "    if ufunc.nin == 1:\n",
                "        in_args = 'x'\n",
                "    else:\n",
                "        in_args = ', '.join('x{}'.format(i+1) for i in range(ufunc.nin))\n",
                "\n",
                "    # output arguments are both keyword or positional\n",
                "    if ufunc.nout == 0:\n",
                "        out_args = ', /, out=()'\n",
                "    elif ufunc.nout == 1:\n",
                "        out_args = ', /, out=None'\n",
                "    else:\n",
                "        out_args = '[, {positional}], / [, out={default}]'.format(\n",
                "            positional=', '.join(\n",
                "                'out{}'.format(i+1) for i in range(ufunc.nout)),\n",
                "            default=repr((None,)*ufunc.nout)\n",
                "        )\n",
                "\n",
                "    # keyword only args depend on whether this is a gufunc\n",
                "    kwargs = (\n",
                "        \", casting='same_kind'\"\n",
                "        \", order='K'\"\n",
                "        \", dtype=None\"\n",
                "        \", subok=True\"\n",
                "        \"[, signature\"\n",
                "        \", extobj]\"\n",
                "    )\n",
                "    if ufunc.signature is None:\n",
                "        kwargs = \", where=True\" + kwargs\n",
                "\n",
                "    # join all the parts together\n",
                "    return '{name}({in_args}{out_args}, *{kwargs})'.format(\n",
                "        name=ufunc.__name__,\n",
                "        in_args=in_args,\n",
                "        out_args=out_args,\n",
                "        kwargs=kwargs\n",
                "    )"
            ]
        ],
        "numpy/core/tests/test_multiarray.py": [
            [
                "from __future__ import division, absolute_import, print_function\n",
                "\n",
                "import collections\n",
                "import tempfile\n",
                "import sys\n",
                "import shutil\n",
                "import warnings\n",
                "import operator\n",
                "import io\n",
                "import itertools\n",
                "import functools\n",
                "import ctypes\n",
                "import os\n",
                "import gc\n",
                "from contextlib import contextmanager\n",
                "if sys.version_info[0] >= 3:\n",
                "    import builtins\n",
                "else:\n",
                "    import __builtin__ as builtins\n",
                "from decimal import Decimal\n",
                "\n",
                "\n",
                "import numpy as np\n",
                "from numpy.compat import strchar, unicode\n",
                "from test_print import in_foreign_locale\n",
                "from numpy.core.multiarray_tests import (\n",
                "    test_neighborhood_iterator, test_neighborhood_iterator_oob,\n",
                "    test_pydatamem_seteventhook_start, test_pydatamem_seteventhook_end,\n",
                "    test_inplace_increment, get_buffer_info, test_as_c_array,\n",
                "    )\n",
                "from numpy.testing import (\n",
                "    TestCase, run_module_suite, assert_, assert_raises, assert_warns,\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    assert_equal, assert_almost_equal, assert_array_equal,\n"
                ],
                "after": [
                    "    assert_equal, assert_almost_equal, assert_array_equal, assert_raises_regex,\n"
                ],
                "parent_version_range": {
                    "start": 32,
                    "end": 33
                },
                "child_version_range": {
                    "start": 32,
                    "end": 33
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 4,
                "hunk_diff": "File: numpy/core/tests/test_multiarray.py\nCode:\n  ...\n29 29        )\n30 30    from numpy.testing import (\n31 31        TestCase, run_module_suite, assert_, assert_raises, assert_warns,\n32     -     assert_equal, assert_almost_equal, assert_array_equal,\n   32  +     assert_equal, assert_almost_equal, assert_array_equal, assert_raises_regex,\n33 33        assert_array_almost_equal, assert_allclose, IS_PYPY, HAS_REFCOUNT,\n34 34        assert_array_less, runstring, dec, SkipTest, temppath, suppress_warnings\n35 35        )\n       ...\n",
                "file_path": "numpy/core/tests/test_multiarray.py",
                "identifiers_before": [
                    "assert_almost_equal",
                    "assert_array_equal",
                    "assert_equal"
                ],
                "identifiers_after": [
                    "assert_almost_equal",
                    "assert_array_equal",
                    "assert_equal",
                    "assert_raises_regex"
                ],
                "prefix": [
                    "    )\n",
                    "from numpy.testing import (\n",
                    "    TestCase, run_module_suite, assert_, assert_raises, assert_warns,\n"
                ],
                "suffix": [
                    "    assert_array_almost_equal, assert_allclose, IS_PYPY, HAS_REFCOUNT,\n",
                    "    assert_array_less, runstring, dec, SkipTest, temppath, suppress_warnings\n",
                    "    )\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "assert_raises_regex",
                            "position": {
                                "start": {
                                    "line": 32,
                                    "column": 59
                                },
                                "end": {
                                    "line": 32,
                                    "column": 78
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/numpy/numpy/core/tests/test_multiarray.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "    assert_array_almost_equal, assert_allclose, IS_PYPY, HAS_REFCOUNT,\n",
                "    assert_array_less, runstring, dec, SkipTest, temppath, suppress_warnings\n",
                "    )\n",
                "\n",
                "# Need to test an object that does not fully implement math interface\n",
                "from datetime import timedelta\n",
                "\n",
                "\n",
                "if sys.version_info[:2] > (3, 2):\n",
                "    # In Python 3.3 the representation of empty shape, strides and sub-offsets\n",
                "    # is an empty tuple instead of None.\n",
                "    # http://docs.python.org/dev/whatsnew/3.3.html#api-changes\n",
                "    EMPTY = ()\n",
                "else:\n",
                "    EMPTY = None\n",
                "\n",
                "\n",
                "def _aligned_zeros(shape, dtype=float, order=\"C\", align=None):\n",
                "    \"\"\"Allocate a new ndarray with aligned memory.\"\"\"\n",
                "    dtype = np.dtype(dtype)\n",
                "    if dtype == np.dtype(object):\n",
                "        # Can't do this, fall back to standard allocation (which\n",
                "        # should always be sufficiently aligned)\n",
                "        if align is not None:\n",
                "            raise ValueError(\"object array alignment not supported\")\n",
                "        return np.zeros(shape, dtype=dtype, order=order)\n",
                "    if align is None:\n",
                "        align = dtype.alignment\n",
                "    if not hasattr(shape, '__len__'):\n",
                "        shape = (shape,)\n",
                "    size = functools.reduce(operator.mul, shape) * dtype.itemsize\n",
                "    buf = np.empty(size + align + 1, np.uint8)\n",
                "    offset = buf.__array_interface__['data'][0] % align\n",
                "    if offset != 0:\n",
                "        offset = align - offset\n",
                "    # Note: slices producing 0-size arrays do not necessarily change\n",
                "    # data pointer --- so we use and allocate size+1\n",
                "    buf = buf[offset:offset+size+1][:-1]\n",
                "    data = np.ndarray(shape, dtype, buf, order=order)\n",
                "    data.fill(0)\n",
                "    return data\n",
                "\n",
                "\n",
                "class TestFlags(TestCase):\n",
                "    def setUp(self):\n",
                "        self.a = np.arange(10)\n",
                "\n",
                "    def test_writeable(self):\n",
                "        mydict = locals()\n",
                "        self.a.flags.writeable = False\n",
                "        self.assertRaises(ValueError, runstring, 'self.a[0] = 3', mydict)\n",
                "        self.assertRaises(ValueError, runstring, 'self.a[0:1].itemset(3)', mydict)\n",
                "        self.a.flags.writeable = True\n",
                "        self.a[0] = 5\n",
                "        self.a[0] = 0\n",
                "\n",
                "    def test_otherflags(self):\n",
                "        assert_equal(self.a.flags.carray, True)\n",
                "        assert_equal(self.a.flags.farray, False)\n",
                "        assert_equal(self.a.flags.behaved, True)\n",
                "        assert_equal(self.a.flags.fnc, False)\n",
                "        assert_equal(self.a.flags.forc, True)\n",
                "        assert_equal(self.a.flags.owndata, True)\n",
                "        assert_equal(self.a.flags.writeable, True)\n",
                "        assert_equal(self.a.flags.aligned, True)\n",
                "        assert_equal(self.a.flags.updateifcopy, False)\n",
                "\n",
                "    def test_string_align(self):\n",
                "        a = np.zeros(4, dtype=np.dtype('|S4'))\n",
                "        assert_(a.flags.aligned)\n",
                "        # not power of two are accessed byte-wise and thus considered aligned\n",
                "        a = np.zeros(5, dtype=np.dtype('|S4'))\n",
                "        assert_(a.flags.aligned)\n",
                "\n",
                "    def test_void_align(self):\n",
                "        a = np.zeros(4, dtype=np.dtype([(\"a\", \"i4\"), (\"b\", \"i4\")]))\n",
                "        assert_(a.flags.aligned)\n",
                "\n",
                "\n",
                "class TestHash(TestCase):\n",
                "    # see #3793\n",
                "    def test_int(self):\n",
                "        for st, ut, s in [(np.int8, np.uint8, 8),\n",
                "                          (np.int16, np.uint16, 16),\n",
                "                          (np.int32, np.uint32, 32),\n",
                "                          (np.int64, np.uint64, 64)]:\n",
                "            for i in range(1, s):\n",
                "                assert_equal(hash(st(-2**i)), hash(-2**i),\n",
                "                             err_msg=\"%r: -2**%d\" % (st, i))\n",
                "                assert_equal(hash(st(2**(i - 1))), hash(2**(i - 1)),\n",
                "                             err_msg=\"%r: 2**%d\" % (st, i - 1))\n",
                "                assert_equal(hash(st(2**i - 1)), hash(2**i - 1),\n",
                "                             err_msg=\"%r: 2**%d - 1\" % (st, i))\n",
                "\n",
                "                i = max(i - 1, 1)\n",
                "                assert_equal(hash(ut(2**(i - 1))), hash(2**(i - 1)),\n",
                "                             err_msg=\"%r: 2**%d\" % (ut, i - 1))\n",
                "                assert_equal(hash(ut(2**i - 1)), hash(2**i - 1),\n",
                "                             err_msg=\"%r: 2**%d - 1\" % (ut, i))\n",
                "\n",
                "\n",
                "class TestAttributes(TestCase):\n",
                "    def setUp(self):\n",
                "        self.one = np.arange(10)\n",
                "        self.two = np.arange(20).reshape(4, 5)\n",
                "        self.three = np.arange(60, dtype=np.float64).reshape(2, 5, 6)\n",
                "\n",
                "    def test_attributes(self):\n",
                "        assert_equal(self.one.shape, (10,))\n",
                "        assert_equal(self.two.shape, (4, 5))\n",
                "        assert_equal(self.three.shape, (2, 5, 6))\n",
                "        self.three.shape = (10, 3, 2)\n",
                "        assert_equal(self.three.shape, (10, 3, 2))\n",
                "        self.three.shape = (2, 5, 6)\n",
                "        assert_equal(self.one.strides, (self.one.itemsize,))\n",
                "        num = self.two.itemsize\n",
                "        assert_equal(self.two.strides, (5*num, num))\n",
                "        num = self.three.itemsize\n",
                "        assert_equal(self.three.strides, (30*num, 6*num, num))\n",
                "        assert_equal(self.one.ndim, 1)\n",
                "        assert_equal(self.two.ndim, 2)\n",
                "        assert_equal(self.three.ndim, 3)\n",
                "        num = self.two.itemsize\n",
                "        assert_equal(self.two.size, 20)\n",
                "        assert_equal(self.two.nbytes, 20*num)\n",
                "        assert_equal(self.two.itemsize, self.two.dtype.itemsize)\n",
                "        assert_equal(self.two.base, np.arange(20))\n",
                "\n",
                "    def test_dtypeattr(self):\n",
                "        assert_equal(self.one.dtype, np.dtype(np.int_))\n",
                "        assert_equal(self.three.dtype, np.dtype(np.float_))\n",
                "        assert_equal(self.one.dtype.char, 'l')\n",
                "        assert_equal(self.three.dtype.char, 'd')\n",
                "        self.assertTrue(self.three.dtype.str[0] in '<>')\n",
                "        assert_equal(self.one.dtype.str[1], 'i')\n",
                "        assert_equal(self.three.dtype.str[1], 'f')\n",
                "\n",
                "    def test_int_subclassing(self):\n",
                "        # Regression test for https://github.com/numpy/numpy/pull/3526\n",
                "\n",
                "        numpy_int = np.int_(0)\n",
                "\n",
                "        if sys.version_info[0] >= 3:\n",
                "            # On Py3k int_ should not inherit from int, because it's not\n",
                "            # fixed-width anymore\n",
                "            assert_equal(isinstance(numpy_int, int), False)\n",
                "        else:\n",
                "            # Otherwise, it should inherit from int...\n",
                "            assert_equal(isinstance(numpy_int, int), True)\n",
                "\n",
                "            # ... and fast-path checks on C-API level should also work\n",
                "            from numpy.core.multiarray_tests import test_int_subclass\n",
                "            assert_equal(test_int_subclass(numpy_int), True)\n",
                "\n",
                "    def test_stridesattr(self):\n",
                "        x = self.one\n",
                "\n",
                "        def make_array(size, offset, strides):\n",
                "            return np.ndarray(size, buffer=x, dtype=int,\n",
                "                              offset=offset*x.itemsize,\n",
                "                              strides=strides*x.itemsize)\n",
                "\n",
                "        assert_equal(make_array(4, 4, -1), np.array([4, 3, 2, 1]))\n",
                "        self.assertRaises(ValueError, make_array, 4, 4, -2)\n",
                "        self.assertRaises(ValueError, make_array, 4, 2, -1)\n",
                "        self.assertRaises(ValueError, make_array, 8, 3, 1)\n",
                "        assert_equal(make_array(8, 3, 0), np.array([3]*8))\n",
                "        # Check behavior reported in gh-2503:\n",
                "        self.assertRaises(ValueError, make_array, (2, 3), 5, np.array([-2, -3]))\n",
                "        make_array(0, 0, 10)\n",
                "\n",
                "    def test_set_stridesattr(self):\n",
                "        x = self.one\n",
                "\n",
                "        def make_array(size, offset, strides):\n",
                "            try:\n",
                "                r = np.ndarray([size], dtype=int, buffer=x,\n",
                "                               offset=offset*x.itemsize)\n",
                "            except Exception as e:\n",
                "                raise RuntimeError(e)\n",
                "            r.strides = strides = strides*x.itemsize\n",
                "            return r\n",
                "\n",
                "        assert_equal(make_array(4, 4, -1), np.array([4, 3, 2, 1]))\n",
                "        assert_equal(make_array(7, 3, 1), np.array([3, 4, 5, 6, 7, 8, 9]))\n",
                "        self.assertRaises(ValueError, make_array, 4, 4, -2)\n",
                "        self.assertRaises(ValueError, make_array, 4, 2, -1)\n",
                "        self.assertRaises(RuntimeError, make_array, 8, 3, 1)\n",
                "        # Check that the true extent of the array is used.\n",
                "        # Test relies on as_strided base not exposing a buffer.\n",
                "        x = np.lib.stride_tricks.as_strided(np.arange(1), (10, 10), (0, 0))\n",
                "\n",
                "        def set_strides(arr, strides):\n",
                "            arr.strides = strides\n",
                "\n",
                "        self.assertRaises(ValueError, set_strides, x, (10*x.itemsize, x.itemsize))\n",
                "\n",
                "        # Test for offset calculations:\n",
                "        x = np.lib.stride_tricks.as_strided(np.arange(10, dtype=np.int8)[-1],\n",
                "                                                    shape=(10,), strides=(-1,))\n",
                "        self.assertRaises(ValueError, set_strides, x[::-1], -1)\n",
                "        a = x[::-1]\n",
                "        a.strides = 1\n",
                "        a[::2].strides = 2\n",
                "\n",
                "    def test_fill(self):\n",
                "        for t in \"?bhilqpBHILQPfdgFDGO\":\n",
                "            x = np.empty((3, 2, 1), t)\n",
                "            y = np.empty((3, 2, 1), t)\n",
                "            x.fill(1)\n",
                "            y[...] = 1\n",
                "            assert_equal(x, y)\n",
                "\n",
                "    def test_fill_max_uint64(self):\n",
                "        x = np.empty((3, 2, 1), dtype=np.uint64)\n",
                "        y = np.empty((3, 2, 1), dtype=np.uint64)\n",
                "        value = 2**64 - 1\n",
                "        y[...] = value\n",
                "        x.fill(value)\n",
                "        assert_array_equal(x, y)\n",
                "\n",
                "    def test_fill_struct_array(self):\n",
                "        # Filling from a scalar\n",
                "        x = np.array([(0, 0.0), (1, 1.0)], dtype='i4,f8')\n",
                "        x.fill(x[0])\n",
                "        assert_equal(x['f1'][1], x['f1'][0])\n",
                "        # Filling from a tuple that can be converted\n",
                "        # to a scalar\n",
                "        x = np.zeros(2, dtype=[('a', 'f8'), ('b', 'i4')])\n",
                "        x.fill((3.5, -2))\n",
                "        assert_array_equal(x['a'], [3.5, 3.5])\n",
                "        assert_array_equal(x['b'], [-2, -2])\n",
                "\n",
                "\n",
                "class TestArrayConstruction(TestCase):\n",
                "    def test_array(self):\n",
                "        d = np.ones(6)\n",
                "        r = np.array([d, d])\n",
                "        assert_equal(r, np.ones((2, 6)))\n",
                "\n",
                "        d = np.ones(6)\n",
                "        tgt = np.ones((2, 6))\n",
                "        r = np.array([d, d])\n",
                "        assert_equal(r, tgt)\n",
                "        tgt[1] = 2\n",
                "        r = np.array([d, d + 1])\n",
                "        assert_equal(r, tgt)\n",
                "\n",
                "        d = np.ones(6)\n",
                "        r = np.array([[d, d]])\n",
                "        assert_equal(r, np.ones((1, 2, 6)))\n",
                "\n",
                "        d = np.ones(6)\n",
                "        r = np.array([[d, d], [d, d]])\n",
                "        assert_equal(r, np.ones((2, 2, 6)))\n",
                "\n",
                "        d = np.ones((6, 6))\n",
                "        r = np.array([d, d])\n",
                "        assert_equal(r, np.ones((2, 6, 6)))\n",
                "\n",
                "        d = np.ones((6, ))\n",
                "        r = np.array([[d, d + 1], d + 2])\n",
                "        assert_equal(len(r), 2)\n",
                "        assert_equal(r[0], [d, d + 1])\n",
                "        assert_equal(r[1], d + 2)\n",
                "\n",
                "        tgt = np.ones((2, 3), dtype=np.bool)\n",
                "        tgt[0, 2] = False\n",
                "        tgt[1, 0:2] = False\n",
                "        r = np.array([[True, True, False], [False, False, True]])\n",
                "        assert_equal(r, tgt)\n",
                "        r = np.array([[True, False], [True, False], [False, True]])\n",
                "        assert_equal(r, tgt.T)\n",
                "\n",
                "    def test_array_empty(self):\n",
                "        assert_raises(TypeError, np.array)\n",
                "\n",
                "    def test_array_copy_false(self):\n",
                "        d = np.array([1, 2, 3])\n",
                "        e = np.array(d, copy=False)\n",
                "        d[1] = 3\n",
                "        assert_array_equal(e, [1, 3, 3])\n",
                "        e = np.array(d, copy=False, order='F')\n",
                "        d[1] = 4\n",
                "        assert_array_equal(e, [1, 4, 3])\n",
                "        e[2] = 7\n",
                "        assert_array_equal(d, [1, 4, 7])\n",
                "\n",
                "    def test_array_copy_true(self):\n",
                "        d = np.array([[1,2,3], [1, 2, 3]])\n",
                "        e = np.array(d, copy=True)\n",
                "        d[0, 1] = 3\n",
                "        e[0, 2] = -7\n",
                "        assert_array_equal(e, [[1, 2, -7], [1, 2, 3]])\n",
                "        assert_array_equal(d, [[1, 3, 3], [1, 2, 3]])\n",
                "        e = np.array(d, copy=True, order='F')\n",
                "        d[0, 1] = 5\n",
                "        e[0, 2] = 7\n",
                "        assert_array_equal(e, [[1, 3, 7], [1, 2, 3]])\n",
                "        assert_array_equal(d, [[1, 5, 3], [1,2,3]])\n",
                "\n",
                "    def test_array_cont(self):\n",
                "        d = np.ones(10)[::2]\n",
                "        assert_(np.ascontiguousarray(d).flags.c_contiguous)\n",
                "        assert_(np.ascontiguousarray(d).flags.f_contiguous)\n",
                "        assert_(np.asfortranarray(d).flags.c_contiguous)\n",
                "        assert_(np.asfortranarray(d).flags.f_contiguous)\n",
                "        d = np.ones((10, 10))[::2,::2]\n",
                "        assert_(np.ascontiguousarray(d).flags.c_contiguous)\n",
                "        assert_(np.asfortranarray(d).flags.f_contiguous)\n",
                "\n",
                "\n",
                "class TestAssignment(TestCase):\n",
                "    def test_assignment_broadcasting(self):\n",
                "        a = np.arange(6).reshape(2, 3)\n",
                "\n",
                "        # Broadcasting the input to the output\n",
                "        a[...] = np.arange(3)\n",
                "        assert_equal(a, [[0, 1, 2], [0, 1, 2]])\n",
                "        a[...] = np.arange(2).reshape(2, 1)\n",
                "        assert_equal(a, [[0, 0, 0], [1, 1, 1]])\n",
                "\n",
                "        # For compatibility with <= 1.5, a limited version of broadcasting\n",
                "        # the output to the input.\n",
                "        #\n",
                "        # This behavior is inconsistent with NumPy broadcasting\n",
                "        # in general, because it only uses one of the two broadcasting\n",
                "        # rules (adding a new \"1\" dimension to the left of the shape),\n",
                "        # applied to the output instead of an input. In NumPy 2.0, this kind\n",
                "        # of broadcasting assignment will likely be disallowed.\n",
                "        a[...] = np.arange(6)[::-1].reshape(1, 2, 3)\n",
                "        assert_equal(a, [[5, 4, 3], [2, 1, 0]])\n",
                "        # The other type of broadcasting would require a reduction operation.\n",
                "\n",
                "        def assign(a, b):\n",
                "            a[...] = b\n",
                "\n",
                "        assert_raises(ValueError, assign, a, np.arange(12).reshape(2, 2, 3))\n",
                "\n",
                "    def test_assignment_errors(self):\n",
                "        # Address issue #2276\n",
                "        class C:\n",
                "            pass\n",
                "        a = np.zeros(1)\n",
                "\n",
                "        def assign(v):\n",
                "            a[0] = v\n",
                "\n",
                "        assert_raises((AttributeError, TypeError), assign, C())\n",
                "        assert_raises(ValueError, assign, [1])\n",
                "\n",
                "    def test_unicode_assignment(self):\n",
                "        # gh-5049\n",
                "        from numpy.core.numeric import set_string_function\n",
                "\n",
                "        @contextmanager\n",
                "        def inject_str(s):\n",
                "            \"\"\" replace ndarray.__str__ temporarily \"\"\"\n",
                "            set_string_function(lambda x: s, repr=False)\n",
                "            try:\n",
                "                yield\n",
                "            finally:\n",
                "                set_string_function(None, repr=False)\n",
                "\n",
                "        a1d = np.array([u'test'])\n",
                "        a0d = np.array(u'done')\n",
                "        with inject_str(u'bad'):\n",
                "            a1d[0] = a0d  # previously this would invoke __str__\n",
                "        assert_equal(a1d[0], u'done')\n",
                "\n",
                "        # this would crash for the same reason\n",
                "        np.array([np.array(u'\\xe5\\xe4\\xf6')])\n",
                "\n",
                "    def test_stringlike_empty_list(self):\n",
                "        # gh-8902\n",
                "        u = np.array([u'done'])\n",
                "        b = np.array([b'done'])\n",
                "\n",
                "        class bad_sequence(object):\n",
                "            def __getitem__(self): pass\n",
                "            def __len__(self): raise RuntimeError\n",
                "\n",
                "        assert_raises(ValueError, operator.setitem, u, 0, [])\n",
                "        assert_raises(ValueError, operator.setitem, b, 0, [])\n",
                "\n",
                "        assert_raises(ValueError, operator.setitem, u, 0, bad_sequence())\n",
                "        assert_raises(ValueError, operator.setitem, b, 0, bad_sequence())\n",
                "\n",
                "    def test_longdouble_assignment(self):\n",
                "        # only relevant if longdouble is larger than float\n",
                "        # we're looking for loss of precision\n",
                "\n",
                "        # gh-8902\n",
                "        tinyb = np.nextafter(np.longdouble(0), 1)\n",
                "        tinya =  np.nextafter(np.longdouble(0), -1)\n",
                "        tiny1d = np.array([tinya])\n",
                "        assert_equal(tiny1d[0], tinya)\n",
                "\n",
                "        # scalar = scalar\n",
                "        tiny1d[0] = tinyb\n",
                "        assert_equal(tiny1d[0], tinyb)\n",
                "\n",
                "        # 0d = scalar\n",
                "        tiny1d[0, ...] = tinya\n",
                "        assert_equal(tiny1d[0], tinya)\n",
                "\n",
                "        # 0d = 0d\n",
                "        tiny1d[0, ...] = tinyb[...]\n",
                "        assert_equal(tiny1d[0], tinyb)\n",
                "\n",
                "        # scalar = 0d\n",
                "        tiny1d[0] = tinyb[...]\n",
                "        assert_equal(tiny1d[0], tinyb)\n",
                "\n",
                "        arr = np.array([np.array(tinya)])\n",
                "        assert_equal(arr[0], tinya)\n",
                "\n",
                "\n",
                "class TestDtypedescr(TestCase):\n",
                "    def test_construction(self):\n",
                "        d1 = np.dtype('i4')\n",
                "        assert_equal(d1, np.dtype(np.int32))\n",
                "        d2 = np.dtype('f8')\n",
                "        assert_equal(d2, np.dtype(np.float64))\n",
                "\n",
                "    def test_byteorders(self):\n",
                "        self.assertNotEqual(np.dtype('<i4'), np.dtype('>i4'))\n",
                "        self.assertNotEqual(np.dtype([('a', '<i4')]), np.dtype([('a', '>i4')]))\n",
                "\n",
                "\n",
                "class TestZeroRank(TestCase):\n",
                "    def setUp(self):\n",
                "        self.d = np.array(0), np.array('x', object)\n",
                "\n",
                "    def test_ellipsis_subscript(self):\n",
                "        a, b = self.d\n",
                "        self.assertEqual(a[...], 0)\n",
                "        self.assertEqual(b[...], 'x')\n",
                "        self.assertTrue(a[...].base is a)  # `a[...] is a` in numpy <1.9.\n",
                "        self.assertTrue(b[...].base is b)  # `b[...] is b` in numpy <1.9.\n",
                "\n",
                "    def test_empty_subscript(self):\n",
                "        a, b = self.d\n",
                "        self.assertEqual(a[()], 0)\n",
                "        self.assertEqual(b[()], 'x')\n",
                "        self.assertTrue(type(a[()]) is a.dtype.type)\n",
                "        self.assertTrue(type(b[()]) is str)\n",
                "\n",
                "    def test_invalid_subscript(self):\n",
                "        a, b = self.d\n",
                "        self.assertRaises(IndexError, lambda x: x[0], a)\n",
                "        self.assertRaises(IndexError, lambda x: x[0], b)\n",
                "        self.assertRaises(IndexError, lambda x: x[np.array([], int)], a)\n",
                "        self.assertRaises(IndexError, lambda x: x[np.array([], int)], b)\n",
                "\n",
                "    def test_ellipsis_subscript_assignment(self):\n",
                "        a, b = self.d\n",
                "        a[...] = 42\n",
                "        self.assertEqual(a, 42)\n",
                "        b[...] = ''\n",
                "        self.assertEqual(b.item(), '')\n",
                "\n",
                "    def test_empty_subscript_assignment(self):\n",
                "        a, b = self.d\n",
                "        a[()] = 42\n",
                "        self.assertEqual(a, 42)\n",
                "        b[()] = ''\n",
                "        self.assertEqual(b.item(), '')\n",
                "\n",
                "    def test_invalid_subscript_assignment(self):\n",
                "        a, b = self.d\n",
                "\n",
                "        def assign(x, i, v):\n",
                "            x[i] = v\n",
                "\n",
                "        self.assertRaises(IndexError, assign, a, 0, 42)\n",
                "        self.assertRaises(IndexError, assign, b, 0, '')\n",
                "        self.assertRaises(ValueError, assign, a, (), '')\n",
                "\n",
                "    def test_newaxis(self):\n",
                "        a, b = self.d\n",
                "        self.assertEqual(a[np.newaxis].shape, (1,))\n",
                "        self.assertEqual(a[..., np.newaxis].shape, (1,))\n",
                "        self.assertEqual(a[np.newaxis, ...].shape, (1,))\n",
                "        self.assertEqual(a[..., np.newaxis].shape, (1,))\n",
                "        self.assertEqual(a[np.newaxis, ..., np.newaxis].shape, (1, 1))\n",
                "        self.assertEqual(a[..., np.newaxis, np.newaxis].shape, (1, 1))\n",
                "        self.assertEqual(a[np.newaxis, np.newaxis, ...].shape, (1, 1))\n",
                "        self.assertEqual(a[(np.newaxis,)*10].shape, (1,)*10)\n",
                "\n",
                "    def test_invalid_newaxis(self):\n",
                "        a, b = self.d\n",
                "\n",
                "        def subscript(x, i):\n",
                "            x[i]\n",
                "\n",
                "        self.assertRaises(IndexError, subscript, a, (np.newaxis, 0))\n",
                "        self.assertRaises(IndexError, subscript, a, (np.newaxis,)*50)\n",
                "\n",
                "    def test_constructor(self):\n",
                "        x = np.ndarray(())\n",
                "        x[()] = 5\n",
                "        self.assertEqual(x[()], 5)\n",
                "        y = np.ndarray((), buffer=x)\n",
                "        y[()] = 6\n",
                "        self.assertEqual(x[()], 6)\n",
                "\n",
                "    def test_output(self):\n",
                "        x = np.array(2)\n",
                "        self.assertRaises(ValueError, np.add, x, [1], x)\n",
                "\n",
                "\n",
                "class TestScalarIndexing(TestCase):\n",
                "    def setUp(self):\n",
                "        self.d = np.array([0, 1])[0]\n",
                "\n",
                "    def test_ellipsis_subscript(self):\n",
                "        a = self.d\n",
                "        self.assertEqual(a[...], 0)\n",
                "        self.assertEqual(a[...].shape, ())\n",
                "\n",
                "    def test_empty_subscript(self):\n",
                "        a = self.d\n",
                "        self.assertEqual(a[()], 0)\n",
                "        self.assertEqual(a[()].shape, ())\n",
                "\n",
                "    def test_invalid_subscript(self):\n",
                "        a = self.d\n",
                "        self.assertRaises(IndexError, lambda x: x[0], a)\n",
                "        self.assertRaises(IndexError, lambda x: x[np.array([], int)], a)\n",
                "\n",
                "    def test_invalid_subscript_assignment(self):\n",
                "        a = self.d\n",
                "\n",
                "        def assign(x, i, v):\n",
                "            x[i] = v\n",
                "\n",
                "        self.assertRaises(TypeError, assign, a, 0, 42)\n",
                "\n",
                "    def test_newaxis(self):\n",
                "        a = self.d\n",
                "        self.assertEqual(a[np.newaxis].shape, (1,))\n",
                "        self.assertEqual(a[..., np.newaxis].shape, (1,))\n",
                "        self.assertEqual(a[np.newaxis, ...].shape, (1,))\n",
                "        self.assertEqual(a[..., np.newaxis].shape, (1,))\n",
                "        self.assertEqual(a[np.newaxis, ..., np.newaxis].shape, (1, 1))\n",
                "        self.assertEqual(a[..., np.newaxis, np.newaxis].shape, (1, 1))\n",
                "        self.assertEqual(a[np.newaxis, np.newaxis, ...].shape, (1, 1))\n",
                "        self.assertEqual(a[(np.newaxis,)*10].shape, (1,)*10)\n",
                "\n",
                "    def test_invalid_newaxis(self):\n",
                "        a = self.d\n",
                "\n",
                "        def subscript(x, i):\n",
                "            x[i]\n",
                "\n",
                "        self.assertRaises(IndexError, subscript, a, (np.newaxis, 0))\n",
                "        self.assertRaises(IndexError, subscript, a, (np.newaxis,)*50)\n",
                "\n",
                "    def test_overlapping_assignment(self):\n",
                "        # With positive strides\n",
                "        a = np.arange(4)\n",
                "        a[:-1] = a[1:]\n",
                "        assert_equal(a, [1, 2, 3, 3])\n",
                "\n",
                "        a = np.arange(4)\n",
                "        a[1:] = a[:-1]\n",
                "        assert_equal(a, [0, 0, 1, 2])\n",
                "\n",
                "        # With positive and negative strides\n",
                "        a = np.arange(4)\n",
                "        a[:] = a[::-1]\n",
                "        assert_equal(a, [3, 2, 1, 0])\n",
                "\n",
                "        a = np.arange(6).reshape(2, 3)\n",
                "        a[::-1,:] = a[:, ::-1]\n",
                "        assert_equal(a, [[5, 4, 3], [2, 1, 0]])\n",
                "\n",
                "        a = np.arange(6).reshape(2, 3)\n",
                "        a[::-1, ::-1] = a[:, ::-1]\n",
                "        assert_equal(a, [[3, 4, 5], [0, 1, 2]])\n",
                "\n",
                "        # With just one element overlapping\n",
                "        a = np.arange(5)\n",
                "        a[:3] = a[2:]\n",
                "        assert_equal(a, [2, 3, 4, 3, 4])\n",
                "\n",
                "        a = np.arange(5)\n",
                "        a[2:] = a[:3]\n",
                "        assert_equal(a, [0, 1, 0, 1, 2])\n",
                "\n",
                "        a = np.arange(5)\n",
                "        a[2::-1] = a[2:]\n",
                "        assert_equal(a, [4, 3, 2, 3, 4])\n",
                "\n",
                "        a = np.arange(5)\n",
                "        a[2:] = a[2::-1]\n",
                "        assert_equal(a, [0, 1, 2, 1, 0])\n",
                "\n",
                "        a = np.arange(5)\n",
                "        a[2::-1] = a[:1:-1]\n",
                "        assert_equal(a, [2, 3, 4, 3, 4])\n",
                "\n",
                "        a = np.arange(5)\n",
                "        a[:1:-1] = a[2::-1]\n",
                "        assert_equal(a, [0, 1, 0, 1, 2])\n",
                "\n",
                "\n",
                "class TestCreation(TestCase):\n",
                "    def test_from_attribute(self):\n",
                "        class x(object):\n",
                "            def __array__(self, dtype=None):\n",
                "                pass\n",
                "\n",
                "        self.assertRaises(ValueError, np.array, x())\n",
                "\n",
                "    def test_from_string(self):\n",
                "        types = np.typecodes['AllInteger'] + np.typecodes['Float']\n",
                "        nstr = ['123', '123']\n",
                "        result = np.array([123, 123], dtype=int)\n",
                "        for type in types:\n",
                "            msg = 'String conversion for %s' % type\n",
                "            assert_equal(np.array(nstr, dtype=type), result, err_msg=msg)\n",
                "\n",
                "    def test_void(self):\n",
                "        arr = np.array([], dtype='V')\n",
                "        assert_equal(arr.dtype.kind, 'V')\n",
                "\n",
                "    def test_too_big_error(self):\n",
                "        # 45341 is the smallest integer greater than sqrt(2**31 - 1).\n",
                "        # 3037000500 is the smallest integer greater than sqrt(2**63 - 1).\n",
                "        # We want to make sure that the square byte array with those dimensions\n",
                "        # is too big on 32 or 64 bit systems respectively.\n",
                "        if np.iinfo('intp').max == 2**31 - 1:\n",
                "            shape = (46341, 46341)\n",
                "        elif np.iinfo('intp').max == 2**63 - 1:\n",
                "            shape = (3037000500, 3037000500)\n",
                "        else:\n",
                "            return\n",
                "        assert_raises(ValueError, np.empty, shape, dtype=np.int8)\n",
                "        assert_raises(ValueError, np.zeros, shape, dtype=np.int8)\n",
                "        assert_raises(ValueError, np.ones, shape, dtype=np.int8)\n",
                "\n",
                "    def test_zeros(self):\n",
                "        types = np.typecodes['AllInteger'] + np.typecodes['AllFloat']\n",
                "        for dt in types:\n",
                "            d = np.zeros((13,), dtype=dt)\n",
                "            assert_equal(np.count_nonzero(d), 0)\n",
                "            # true for ieee floats\n",
                "            assert_equal(d.sum(), 0)\n",
                "            assert_(not d.any())\n",
                "\n",
                "            d = np.zeros(2, dtype='(2,4)i4')\n",
                "            assert_equal(np.count_nonzero(d), 0)\n",
                "            assert_equal(d.sum(), 0)\n",
                "            assert_(not d.any())\n",
                "\n",
                "            d = np.zeros(2, dtype='4i4')\n",
                "            assert_equal(np.count_nonzero(d), 0)\n",
                "            assert_equal(d.sum(), 0)\n",
                "            assert_(not d.any())\n",
                "\n",
                "            d = np.zeros(2, dtype='(2,4)i4, (2,4)i4')\n",
                "            assert_equal(np.count_nonzero(d), 0)\n",
                "\n",
                "    @dec.slow\n",
                "    def test_zeros_big(self):\n",
                "        # test big array as they might be allocated different by the system\n",
                "        types = np.typecodes['AllInteger'] + np.typecodes['AllFloat']\n",
                "        for dt in types:\n",
                "            d = np.zeros((30 * 1024**2,), dtype=dt)\n",
                "            assert_(not d.any())\n",
                "            # This test can fail on 32-bit systems due to insufficient\n",
                "            # contiguous memory. Deallocating the previous array increases the\n",
                "            # chance of success.\n",
                "            del(d)\n",
                "\n",
                "    def test_zeros_obj(self):\n",
                "        # test initialization from PyLong(0)\n",
                "        d = np.zeros((13,), dtype=object)\n",
                "        assert_array_equal(d, [0] * 13)\n",
                "        assert_equal(np.count_nonzero(d), 0)\n",
                "\n",
                "    def test_zeros_obj_obj(self):\n",
                "        d = np.zeros(10, dtype=[('k', object, 2)])\n",
                "        assert_array_equal(d['k'], 0)\n",
                "\n",
                "    def test_zeros_like_like_zeros(self):\n",
                "        # test zeros_like returns the same as zeros\n",
                "        for c in np.typecodes['All']:\n",
                "            if c == 'V':\n",
                "                continue\n",
                "            d = np.zeros((3,3), dtype=c)\n",
                "            assert_array_equal(np.zeros_like(d), d)\n",
                "            assert_equal(np.zeros_like(d).dtype, d.dtype)\n",
                "        # explicitly check some special cases\n",
                "        d = np.zeros((3,3), dtype='S5')\n",
                "        assert_array_equal(np.zeros_like(d), d)\n",
                "        assert_equal(np.zeros_like(d).dtype, d.dtype)\n",
                "        d = np.zeros((3,3), dtype='U5')\n",
                "        assert_array_equal(np.zeros_like(d), d)\n",
                "        assert_equal(np.zeros_like(d).dtype, d.dtype)\n",
                "\n",
                "        d = np.zeros((3,3), dtype='<i4')\n",
                "        assert_array_equal(np.zeros_like(d), d)\n",
                "        assert_equal(np.zeros_like(d).dtype, d.dtype)\n",
                "        d = np.zeros((3,3), dtype='>i4')\n",
                "        assert_array_equal(np.zeros_like(d), d)\n",
                "        assert_equal(np.zeros_like(d).dtype, d.dtype)\n",
                "\n",
                "        d = np.zeros((3,3), dtype='<M8[s]')\n",
                "        assert_array_equal(np.zeros_like(d), d)\n",
                "        assert_equal(np.zeros_like(d).dtype, d.dtype)\n",
                "        d = np.zeros((3,3), dtype='>M8[s]')\n",
                "        assert_array_equal(np.zeros_like(d), d)\n",
                "        assert_equal(np.zeros_like(d).dtype, d.dtype)\n",
                "\n",
                "        d = np.zeros((3,3), dtype='f4,f4')\n",
                "        assert_array_equal(np.zeros_like(d), d)\n",
                "        assert_equal(np.zeros_like(d).dtype, d.dtype)\n",
                "\n",
                "    def test_empty_unicode(self):\n",
                "        # don't throw decode errors on garbage memory\n",
                "        for i in range(5, 100, 5):\n",
                "            d = np.empty(i, dtype='U')\n",
                "            str(d)\n",
                "\n",
                "    def test_sequence_non_homogenous(self):\n",
                "        assert_equal(np.array([4, 2**80]).dtype, np.object)\n",
                "        assert_equal(np.array([4, 2**80, 4]).dtype, np.object)\n",
                "        assert_equal(np.array([2**80, 4]).dtype, np.object)\n",
                "        assert_equal(np.array([2**80] * 3).dtype, np.object)\n",
                "        assert_equal(np.array([[1, 1],[1j, 1j]]).dtype, np.complex)\n",
                "        assert_equal(np.array([[1j, 1j],[1, 1]]).dtype, np.complex)\n",
                "        assert_equal(np.array([[1, 1, 1],[1, 1j, 1.], [1, 1, 1]]).dtype, np.complex)\n",
                "\n",
                "    @dec.skipif(sys.version_info[0] >= 3)\n",
                "    def test_sequence_long(self):\n",
                "        assert_equal(np.array([long(4), long(4)]).dtype, np.long)\n",
                "        assert_equal(np.array([long(4), 2**80]).dtype, np.object)\n",
                "        assert_equal(np.array([long(4), 2**80, long(4)]).dtype, np.object)\n",
                "        assert_equal(np.array([2**80, long(4)]).dtype, np.object)\n",
                "\n",
                "    def test_non_sequence_sequence(self):\n",
                "        \"\"\"Should not segfault.\n",
                "\n",
                "        Class Fail breaks the sequence protocol for new style classes, i.e.,\n",
                "        those derived from object. Class Map is a mapping type indicated by\n",
                "        raising a ValueError. At some point we may raise a warning instead\n",
                "        of an error in the Fail case.\n",
                "\n",
                "        \"\"\"\n",
                "        class Fail(object):\n",
                "            def __len__(self):\n",
                "                return 1\n",
                "\n",
                "            def __getitem__(self, index):\n",
                "                raise ValueError()\n",
                "\n",
                "        class Map(object):\n",
                "            def __len__(self):\n",
                "                return 1\n",
                "\n",
                "            def __getitem__(self, index):\n",
                "                raise KeyError()\n",
                "\n",
                "        a = np.array([Map()])\n",
                "        assert_(a.shape == (1,))\n",
                "        assert_(a.dtype == np.dtype(object))\n",
                "        assert_raises(ValueError, np.array, [Fail()])\n",
                "\n",
                "    def test_no_len_object_type(self):\n",
                "        # gh-5100, want object array from iterable object without len()\n",
                "        class Point2:\n",
                "            def __init__(self):\n",
                "                pass\n",
                "\n",
                "            def __getitem__(self, ind):\n",
                "                if ind in [0, 1]:\n",
                "                    return ind\n",
                "                else:\n",
                "                    raise IndexError()\n",
                "        d = np.array([Point2(), Point2(), Point2()])\n",
                "        assert_equal(d.dtype, np.dtype(object))\n",
                "\n",
                "    def test_false_len_sequence(self):\n",
                "        # gh-7264, segfault for this example\n",
                "        class C:\n",
                "            def __getitem__(self, i):\n",
                "                raise IndexError\n",
                "            def __len__(self):\n",
                "                return 42\n",
                "\n",
                "        assert_raises(ValueError, np.array, C()) # segfault?\n",
                "\n",
                "    def test_failed_len_sequence(self):\n",
                "        # gh-7393\n",
                "        class A(object):\n",
                "            def __init__(self, data):\n",
                "                self._data = data\n",
                "            def __getitem__(self, item):\n",
                "                return type(self)(self._data[item])\n",
                "            def __len__(self):\n",
                "                return len(self._data)\n",
                "\n",
                "        # len(d) should give 3, but len(d[0]) will fail\n",
                "        d = A([1,2,3])\n",
                "        assert_equal(len(np.array(d)), 3)\n",
                "\n",
                "    def test_array_too_big(self):\n",
                "        # Test that array creation succeeds for arrays addressable by intp\n",
                "        # on the byte level and fails for too large arrays.\n",
                "        buf = np.zeros(100)\n",
                "\n",
                "        max_bytes = np.iinfo(np.intp).max\n",
                "        for dtype in [\"intp\", \"S20\", \"b\"]:\n",
                "            dtype = np.dtype(dtype)\n",
                "            itemsize = dtype.itemsize\n",
                "\n",
                "            np.ndarray(buffer=buf, strides=(0,),\n",
                "                       shape=(max_bytes//itemsize,), dtype=dtype)\n",
                "            assert_raises(ValueError, np.ndarray, buffer=buf, strides=(0,),\n",
                "                          shape=(max_bytes//itemsize + 1,), dtype=dtype)\n",
                "\n",
                "\n",
                "class TestStructured(TestCase):\n",
                "    def test_subarray_field_access(self):\n",
                "        a = np.zeros((3, 5), dtype=[('a', ('i4', (2, 2)))])\n",
                "        a['a'] = np.arange(60).reshape(3, 5, 2, 2)\n",
                "\n",
                "        # Since the subarray is always in C-order, a transpose\n",
                "        # does not swap the subarray:\n",
                "        assert_array_equal(a.T['a'], a['a'].transpose(1, 0, 2, 3))\n",
                "\n",
                "        # In Fortran order, the subarray gets appended\n",
                "        # like in all other cases, not prepended as a special case\n",
                "        b = a.copy(order='F')\n",
                "        assert_equal(a['a'].shape, b['a'].shape)\n",
                "        assert_equal(a.T['a'].shape, a.T.copy()['a'].shape)\n",
                "\n",
                "    def test_subarray_comparison(self):\n",
                "        # Check that comparisons between record arrays with\n",
                "        # multi-dimensional field types work properly\n",
                "        a = np.rec.fromrecords(\n",
                "            [([1, 2, 3], 'a', [[1, 2], [3, 4]]), ([3, 3, 3], 'b', [[0, 0], [0, 0]])],\n",
                "            dtype=[('a', ('f4', 3)), ('b', np.object), ('c', ('i4', (2, 2)))])\n",
                "        b = a.copy()\n",
                "        assert_equal(a == b, [True, True])\n",
                "        assert_equal(a != b, [False, False])\n",
                "        b[1].b = 'c'\n",
                "        assert_equal(a == b, [True, False])\n",
                "        assert_equal(a != b, [False, True])\n",
                "        for i in range(3):\n",
                "            b[0].a = a[0].a\n",
                "            b[0].a[i] = 5\n",
                "            assert_equal(a == b, [False, False])\n",
                "            assert_equal(a != b, [True, True])\n",
                "        for i in range(2):\n",
                "            for j in range(2):\n",
                "                b = a.copy()\n",
                "                b[0].c[i, j] = 10\n",
                "                assert_equal(a == b, [False, True])\n",
                "                assert_equal(a != b, [True, False])\n",
                "\n",
                "        # Check that broadcasting with a subarray works\n",
                "        a = np.array([[(0,)], [(1,)]], dtype=[('a', 'f8')])\n",
                "        b = np.array([(0,), (0,), (1,)], dtype=[('a', 'f8')])\n",
                "        assert_equal(a == b, [[True, True, False], [False, False, True]])\n",
                "        assert_equal(b == a, [[True, True, False], [False, False, True]])\n",
                "        a = np.array([[(0,)], [(1,)]], dtype=[('a', 'f8', (1,))])\n",
                "        b = np.array([(0,), (0,), (1,)], dtype=[('a', 'f8', (1,))])\n",
                "        assert_equal(a == b, [[True, True, False], [False, False, True]])\n",
                "        assert_equal(b == a, [[True, True, False], [False, False, True]])\n",
                "        a = np.array([[([0, 0],)], [([1, 1],)]], dtype=[('a', 'f8', (2,))])\n",
                "        b = np.array([([0, 0],), ([0, 1],), ([1, 1],)], dtype=[('a', 'f8', (2,))])\n",
                "        assert_equal(a == b, [[True, False, False], [False, False, True]])\n",
                "        assert_equal(b == a, [[True, False, False], [False, False, True]])\n",
                "\n",
                "        # Check that broadcasting Fortran-style arrays with a subarray work\n",
                "        a = np.array([[([0, 0],)], [([1, 1],)]], dtype=[('a', 'f8', (2,))], order='F')\n",
                "        b = np.array([([0, 0],), ([0, 1],), ([1, 1],)], dtype=[('a', 'f8', (2,))])\n",
                "        assert_equal(a == b, [[True, False, False], [False, False, True]])\n",
                "        assert_equal(b == a, [[True, False, False], [False, False, True]])\n",
                "\n",
                "        # Check that incompatible sub-array shapes don't result to broadcasting\n",
                "        x = np.zeros((1,), dtype=[('a', ('f4', (1, 2))), ('b', 'i1')])\n",
                "        y = np.zeros((1,), dtype=[('a', ('f4', (2,))), ('b', 'i1')])\n",
                "        # This comparison invokes deprecated behaviour, and will probably\n",
                "        # start raising an error eventually. What we really care about in this\n",
                "        # test is just that it doesn't return True.\n",
                "        with suppress_warnings() as sup:\n",
                "            sup.filter(FutureWarning, \"elementwise == comparison failed\")\n",
                "            assert_equal(x == y, False)\n",
                "\n",
                "        x = np.zeros((1,), dtype=[('a', ('f4', (2, 1))), ('b', 'i1')])\n",
                "        y = np.zeros((1,), dtype=[('a', ('f4', (2,))), ('b', 'i1')])\n",
                "        # This comparison invokes deprecated behaviour, and will probably\n",
                "        # start raising an error eventually. What we really care about in this\n",
                "        # test is just that it doesn't return True.\n",
                "        with suppress_warnings() as sup:\n",
                "            sup.filter(FutureWarning, \"elementwise == comparison failed\")\n",
                "            assert_equal(x == y, False)\n",
                "\n",
                "        # Check that structured arrays that are different only in\n",
                "        # byte-order work\n",
                "        a = np.array([(5, 42), (10, 1)], dtype=[('a', '>i8'), ('b', '<f8')])\n",
                "        b = np.array([(5, 43), (10, 1)], dtype=[('a', '<i8'), ('b', '>f8')])\n",
                "        assert_equal(a == b, [False, True])\n",
                "\n",
                "    def test_casting(self):\n",
                "        # Check that casting a structured array to change its byte order\n",
                "        # works\n",
                "        a = np.array([(1,)], dtype=[('a', '<i4')])\n",
                "        assert_(np.can_cast(a.dtype, [('a', '>i4')], casting='unsafe'))\n",
                "        b = a.astype([('a', '>i4')])\n",
                "        assert_equal(b, a.byteswap().newbyteorder())\n",
                "        assert_equal(a['a'][0], b['a'][0])\n",
                "\n",
                "        # Check that equality comparison works on structured arrays if\n",
                "        # they are 'equiv'-castable\n",
                "        a = np.array([(5, 42), (10, 1)], dtype=[('a', '>i4'), ('b', '<f8')])\n",
                "        b = np.array([(42, 5), (1, 10)], dtype=[('b', '>f8'), ('a', '<i4')])\n",
                "        assert_(np.can_cast(a.dtype, b.dtype, casting='equiv'))\n",
                "        assert_equal(a == b, [True, True])\n",
                "\n",
                "        # Check that 'equiv' casting can reorder fields and change byte\n",
                "        # order\n",
                "        # New in 1.12: This behavior changes in 1.13, test for dep warning\n",
                "        assert_(np.can_cast(a.dtype, b.dtype, casting='equiv'))\n",
                "        with assert_warns(FutureWarning):\n",
                "            c = a.astype(b.dtype, casting='equiv')\n",
                "        assert_equal(a == c, [True, True])\n",
                "\n",
                "        # Check that 'safe' casting can change byte order and up-cast\n",
                "        # fields\n",
                "        t = [('a', '<i8'), ('b', '>f8')]\n",
                "        assert_(np.can_cast(a.dtype, t, casting='safe'))\n",
                "        c = a.astype(t, casting='safe')\n",
                "        assert_equal((c == np.array([(5, 42), (10, 1)], dtype=t)),\n",
                "                     [True, True])\n",
                "\n",
                "        # Check that 'same_kind' casting can change byte order and\n",
                "        # change field widths within a \"kind\"\n",
                "        t = [('a', '<i4'), ('b', '>f4')]\n",
                "        assert_(np.can_cast(a.dtype, t, casting='same_kind'))\n",
                "        c = a.astype(t, casting='same_kind')\n",
                "        assert_equal((c == np.array([(5, 42), (10, 1)], dtype=t)),\n",
                "                     [True, True])\n",
                "\n",
                "        # Check that casting fails if the casting rule should fail on\n",
                "        # any of the fields\n",
                "        t = [('a', '>i8'), ('b', '<f4')]\n",
                "        assert_(not np.can_cast(a.dtype, t, casting='safe'))\n",
                "        assert_raises(TypeError, a.astype, t, casting='safe')\n",
                "        t = [('a', '>i2'), ('b', '<f8')]\n",
                "        assert_(not np.can_cast(a.dtype, t, casting='equiv'))\n",
                "        assert_raises(TypeError, a.astype, t, casting='equiv')\n",
                "        t = [('a', '>i8'), ('b', '<i2')]\n",
                "        assert_(not np.can_cast(a.dtype, t, casting='same_kind'))\n",
                "        assert_raises(TypeError, a.astype, t, casting='same_kind')\n",
                "        assert_(not np.can_cast(a.dtype, b.dtype, casting='no'))\n",
                "        assert_raises(TypeError, a.astype, b.dtype, casting='no')\n",
                "\n",
                "        # Check that non-'unsafe' casting can't change the set of field names\n",
                "        for casting in ['no', 'safe', 'equiv', 'same_kind']:\n",
                "            t = [('a', '>i4')]\n",
                "            assert_(not np.can_cast(a.dtype, t, casting=casting))\n",
                "            t = [('a', '>i4'), ('b', '<f8'), ('c', 'i4')]\n",
                "            assert_(not np.can_cast(a.dtype, t, casting=casting))\n",
                "\n",
                "    def test_objview(self):\n",
                "        # https://github.com/numpy/numpy/issues/3286\n",
                "        a = np.array([], dtype=[('a', 'f'), ('b', 'f'), ('c', 'O')])\n",
                "        a[['a', 'b']]  # TypeError?\n",
                "\n",
                "        # https://github.com/numpy/numpy/issues/3253\n",
                "        dat2 = np.zeros(3, [('A', 'i'), ('B', '|O')])\n",
                "        dat2[['B', 'A']]  # TypeError?\n",
                "\n",
                "    def test_setfield(self):\n",
                "        # https://github.com/numpy/numpy/issues/3126\n",
                "        struct_dt = np.dtype([('elem', 'i4', 5),])\n",
                "        dt = np.dtype([('field', 'i4', 10),('struct', struct_dt)])\n",
                "        x = np.zeros(1, dt)\n",
                "        x[0]['field'] = np.ones(10, dtype='i4')\n",
                "        x[0]['struct'] = np.ones(1, dtype=struct_dt)\n",
                "        assert_equal(x[0]['field'], np.ones(10, dtype='i4'))\n",
                "\n",
                "    def test_setfield_object(self):\n",
                "        # make sure object field assignment with ndarray value\n",
                "        # on void scalar mimics setitem behavior\n",
                "        b = np.zeros(1, dtype=[('x', 'O')])\n",
                "        # next line should work identically to b['x'][0] = np.arange(3)\n",
                "        b[0]['x'] = np.arange(3)\n",
                "        assert_equal(b[0]['x'], np.arange(3))\n",
                "\n",
                "        # check that broadcasting check still works\n",
                "        c = np.zeros(1, dtype=[('x', 'O', 5)])\n",
                "\n",
                "        def testassign():\n",
                "            c[0]['x'] = np.arange(3)\n",
                "\n",
                "        assert_raises(ValueError, testassign)\n",
                "\n",
                "    def test_zero_width_string(self):\n",
                "        # Test for PR #6430 / issues #473, #4955, #2585\n",
                "\n",
                "        dt = np.dtype([('I', int), ('S', 'S0')])\n",
                "\n",
                "        x = np.zeros(4, dtype=dt)\n",
                "\n",
                "        assert_equal(x['S'], [b'', b'', b'', b''])\n",
                "        assert_equal(x['S'].itemsize, 0)\n",
                "\n",
                "        x['S'] = ['a', 'b', 'c', 'd']\n",
                "        assert_equal(x['S'], [b'', b'', b'', b''])\n",
                "        assert_equal(x['I'], [0, 0, 0, 0])\n",
                "\n",
                "        # Variation on test case from #4955\n",
                "        x['S'][x['I'] == 0] = 'hello'\n",
                "        assert_equal(x['S'], [b'', b'', b'', b''])\n",
                "        assert_equal(x['I'], [0, 0, 0, 0])\n",
                "\n",
                "        # Variation on test case from #2585\n",
                "        x['S'] = 'A'\n",
                "        assert_equal(x['S'], [b'', b'', b'', b''])\n",
                "        assert_equal(x['I'], [0, 0, 0, 0])\n",
                "\n",
                "        # Allow zero-width dtypes in ndarray constructor\n",
                "        y = np.ndarray(4, dtype=x['S'].dtype)\n",
                "        assert_equal(y.itemsize, 0)\n",
                "        assert_equal(x['S'], y)\n",
                "\n",
                "        # More tests for indexing an array with zero-width fields\n",
                "        assert_equal(np.zeros(4, dtype=[('a', 'S0,S0'),\n",
                "                                        ('b', 'u1')])['a'].itemsize, 0)\n",
                "        assert_equal(np.empty(3, dtype='S0,S0').itemsize, 0)\n",
                "        assert_equal(np.zeros(4, dtype='S0,u1')['f0'].itemsize, 0)\n",
                "\n",
                "        xx = x['S'].reshape((2, 2))\n",
                "        assert_equal(xx.itemsize, 0)\n",
                "        assert_equal(xx, [[b'', b''], [b'', b'']])\n",
                "        # check for no uninitialized memory due to viewing S0 array\n",
                "        assert_equal(xx[:].dtype, xx.dtype)\n",
                "        assert_array_equal(eval(repr(xx), dict(array=np.array)), xx)\n",
                "\n",
                "        b = io.BytesIO()\n",
                "        np.save(b, xx)\n",
                "\n",
                "        b.seek(0)\n",
                "        yy = np.load(b)\n",
                "        assert_equal(yy.itemsize, 0)\n",
                "        assert_equal(xx, yy)\n",
                "\n",
                "        with temppath(suffix='.npy') as tmp:\n",
                "            np.save(tmp, xx)\n",
                "            yy = np.load(tmp)\n",
                "            assert_equal(yy.itemsize, 0)\n",
                "            assert_equal(xx, yy)\n",
                "\n",
                "    def test_base_attr(self):\n",
                "        a = np.zeros(3, dtype='i4,f4')\n",
                "        b = a[0]\n",
                "        assert_(b.base is a)\n",
                "\n",
                "\n",
                "class TestBool(TestCase):\n",
                "    def test_test_interning(self):\n",
                "        a0 = np.bool_(0)\n",
                "        b0 = np.bool_(False)\n",
                "        self.assertTrue(a0 is b0)\n",
                "        a1 = np.bool_(1)\n",
                "        b1 = np.bool_(True)\n",
                "        self.assertTrue(a1 is b1)\n",
                "        self.assertTrue(np.array([True])[0] is a1)\n",
                "        self.assertTrue(np.array(True)[()] is a1)\n",
                "\n",
                "    def test_sum(self):\n",
                "        d = np.ones(101, dtype=np.bool)\n",
                "        assert_equal(d.sum(), d.size)\n",
                "        assert_equal(d[::2].sum(), d[::2].size)\n",
                "        assert_equal(d[::-2].sum(), d[::-2].size)\n",
                "\n",
                "        d = np.frombuffer(b'\\xff\\xff' * 100, dtype=bool)\n",
                "        assert_equal(d.sum(), d.size)\n",
                "        assert_equal(d[::2].sum(), d[::2].size)\n",
                "        assert_equal(d[::-2].sum(), d[::-2].size)\n",
                "\n",
                "    def check_count_nonzero(self, power, length):\n",
                "        powers = [2 ** i for i in range(length)]\n",
                "        for i in range(2**power):\n",
                "            l = [(i & x) != 0 for x in powers]\n",
                "            a = np.array(l, dtype=np.bool)\n",
                "            c = builtins.sum(l)\n",
                "            self.assertEqual(np.count_nonzero(a), c)\n",
                "            av = a.view(np.uint8)\n",
                "            av *= 3\n",
                "            self.assertEqual(np.count_nonzero(a), c)\n",
                "            av *= 4\n",
                "            self.assertEqual(np.count_nonzero(a), c)\n",
                "            av[av != 0] = 0xFF\n",
                "            self.assertEqual(np.count_nonzero(a), c)\n",
                "\n",
                "    def test_count_nonzero(self):\n",
                "        # check all 12 bit combinations in a length 17 array\n",
                "        # covers most cases of the 16 byte unrolled code\n",
                "        self.check_count_nonzero(12, 17)\n",
                "\n",
                "    @dec.slow\n",
                "    def test_count_nonzero_all(self):\n",
                "        # check all combinations in a length 17 array\n",
                "        # covers all cases of the 16 byte unrolled code\n",
                "        self.check_count_nonzero(17, 17)\n",
                "\n",
                "    def test_count_nonzero_unaligned(self):\n",
                "        # prevent mistakes as e.g. gh-4060\n",
                "        for o in range(7):\n",
                "            a = np.zeros((18,), dtype=np.bool)[o+1:]\n",
                "            a[:o] = True\n",
                "            self.assertEqual(np.count_nonzero(a), builtins.sum(a.tolist()))\n",
                "            a = np.ones((18,), dtype=np.bool)[o+1:]\n",
                "            a[:o] = False\n",
                "            self.assertEqual(np.count_nonzero(a), builtins.sum(a.tolist()))\n",
                "\n",
                "\n",
                "class TestMethods(TestCase):\n",
                "    def test_compress(self):\n",
                "        tgt = [[5, 6, 7, 8, 9]]\n",
                "        arr = np.arange(10).reshape(2, 5)\n",
                "        out = arr.compress([0, 1], axis=0)\n",
                "        assert_equal(out, tgt)\n",
                "\n",
                "        tgt = [[1, 3], [6, 8]]\n",
                "        out = arr.compress([0, 1, 0, 1, 0], axis=1)\n",
                "        assert_equal(out, tgt)\n",
                "\n",
                "        tgt = [[1], [6]]\n",
                "        arr = np.arange(10).reshape(2, 5)\n",
                "        out = arr.compress([0, 1], axis=1)\n",
                "        assert_equal(out, tgt)\n",
                "\n",
                "        arr = np.arange(10).reshape(2, 5)\n",
                "        out = arr.compress([0, 1])\n",
                "        assert_equal(out, 1)\n",
                "\n",
                "    def test_choose(self):\n",
                "        x = 2*np.ones((3,), dtype=int)\n",
                "        y = 3*np.ones((3,), dtype=int)\n",
                "        x2 = 2*np.ones((2, 3), dtype=int)\n",
                "        y2 = 3*np.ones((2, 3), dtype=int)\n",
                "        ind = np.array([0, 0, 1])\n",
                "\n",
                "        A = ind.choose((x, y))\n",
                "        assert_equal(A, [2, 2, 3])\n",
                "\n",
                "        A = ind.choose((x2, y2))\n",
                "        assert_equal(A, [[2, 2, 3], [2, 2, 3]])\n",
                "\n",
                "        A = ind.choose((x, y2))\n",
                "        assert_equal(A, [[2, 2, 3], [2, 2, 3]])\n",
                "\n",
                "    def test_prod(self):\n",
                "        ba = [1, 2, 10, 11, 6, 5, 4]\n",
                "        ba2 = [[1, 2, 3, 4], [5, 6, 7, 9], [10, 3, 4, 5]]\n",
                "\n",
                "        for ctype in [np.int16, np.uint16, np.int32, np.uint32,\n",
                "                      np.float32, np.float64, np.complex64, np.complex128]:\n",
                "            a = np.array(ba, ctype)\n",
                "            a2 = np.array(ba2, ctype)\n",
                "            if ctype in ['1', 'b']:\n",
                "                self.assertRaises(ArithmeticError, a.prod)\n",
                "                self.assertRaises(ArithmeticError, a2.prod, axis=1)\n",
                "            else:\n",
                "                assert_equal(a.prod(axis=0), 26400)\n",
                "                assert_array_equal(a2.prod(axis=0),\n",
                "                                   np.array([50, 36, 84, 180], ctype))\n",
                "                assert_array_equal(a2.prod(axis=-1),\n",
                "                                   np.array([24, 1890, 600], ctype))\n",
                "\n",
                "    def test_repeat(self):\n",
                "        m = np.array([1, 2, 3, 4, 5, 6])\n",
                "        m_rect = m.reshape((2, 3))\n",
                "\n",
                "        A = m.repeat([1, 3, 2, 1, 1, 2])\n",
                "        assert_equal(A, [1, 2, 2, 2, 3,\n",
                "                         3, 4, 5, 6, 6])\n",
                "\n",
                "        A = m.repeat(2)\n",
                "        assert_equal(A, [1, 1, 2, 2, 3, 3,\n",
                "                         4, 4, 5, 5, 6, 6])\n",
                "\n",
                "        A = m_rect.repeat([2, 1], axis=0)\n",
                "        assert_equal(A, [[1, 2, 3],\n",
                "                         [1, 2, 3],\n",
                "                         [4, 5, 6]])\n",
                "\n",
                "        A = m_rect.repeat([1, 3, 2], axis=1)\n",
                "        assert_equal(A, [[1, 2, 2, 2, 3, 3],\n",
                "                         [4, 5, 5, 5, 6, 6]])\n",
                "\n",
                "        A = m_rect.repeat(2, axis=0)\n",
                "        assert_equal(A, [[1, 2, 3],\n",
                "                         [1, 2, 3],\n",
                "                         [4, 5, 6],\n",
                "                         [4, 5, 6]])\n",
                "\n",
                "        A = m_rect.repeat(2, axis=1)\n",
                "        assert_equal(A, [[1, 1, 2, 2, 3, 3],\n",
                "                         [4, 4, 5, 5, 6, 6]])\n",
                "\n",
                "    def test_reshape(self):\n",
                "        arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\n",
                "\n",
                "        tgt = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]]\n",
                "        assert_equal(arr.reshape(2, 6), tgt)\n",
                "\n",
                "        tgt = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n",
                "        assert_equal(arr.reshape(3, 4), tgt)\n",
                "\n",
                "        tgt = [[1, 10, 8, 6], [4, 2, 11, 9], [7, 5, 3, 12]]\n",
                "        assert_equal(arr.reshape((3, 4), order='F'), tgt)\n",
                "\n",
                "        tgt = [[1, 4, 7, 10], [2, 5, 8, 11], [3, 6, 9, 12]]\n",
                "        assert_equal(arr.T.reshape((3, 4), order='C'), tgt)\n",
                "\n",
                "    def test_round(self):\n",
                "        def check_round(arr, expected, *round_args):\n",
                "            assert_equal(arr.round(*round_args), expected)\n",
                "            # With output array\n",
                "            out = np.zeros_like(arr)\n",
                "            res = arr.round(*round_args, out=out)\n",
                "            assert_equal(out, expected)\n",
                "            assert_equal(out, res)\n",
                "\n",
                "        check_round(np.array([1.2, 1.5]), [1, 2])\n",
                "        check_round(np.array(1.5), 2)\n",
                "        check_round(np.array([12.2, 15.5]), [10, 20], -1)\n",
                "        check_round(np.array([12.15, 15.51]), [12.2, 15.5], 1)\n",
                "        # Complex rounding\n",
                "        check_round(np.array([4.5 + 1.5j]), [4 + 2j])\n",
                "        check_round(np.array([12.5 + 15.5j]), [10 + 20j], -1)\n",
                "\n",
                "    def test_squeeze(self):\n",
                "        a = np.array([[[1], [2], [3]]])\n",
                "        assert_equal(a.squeeze(), [1, 2, 3])\n",
                "        assert_equal(a.squeeze(axis=(0,)), [[1], [2], [3]])\n",
                "        assert_raises(ValueError, a.squeeze, axis=(1,))\n",
                "        assert_equal(a.squeeze(axis=(2,)), [[1, 2, 3]])\n",
                "\n",
                "    def test_transpose(self):\n",
                "        a = np.array([[1, 2], [3, 4]])\n",
                "        assert_equal(a.transpose(), [[1, 3], [2, 4]])\n",
                "        self.assertRaises(ValueError, lambda: a.transpose(0))\n",
                "        self.assertRaises(ValueError, lambda: a.transpose(0, 0))\n",
                "        self.assertRaises(ValueError, lambda: a.transpose(0, 1, 2))\n",
                "\n",
                "    def test_sort(self):\n",
                "        # test ordering for floats and complex containing nans. It is only\n",
                "        # necessary to check the less-than comparison, so sorts that\n",
                "        # only follow the insertion sort path are sufficient. We only\n",
                "        # test doubles and complex doubles as the logic is the same.\n",
                "\n",
                "        # check doubles\n",
                "        msg = \"Test real sort order with nans\"\n",
                "        a = np.array([np.nan, 1, 0])\n",
                "        b = np.sort(a)\n",
                "        assert_equal(b, a[::-1], msg)\n",
                "        # check complex\n",
                "        msg = \"Test complex sort order with nans\"\n",
                "        a = np.zeros(9, dtype=np.complex128)\n",
                "        a.real += [np.nan, np.nan, np.nan, 1, 0, 1, 1, 0, 0]\n",
                "        a.imag += [np.nan, 1, 0, np.nan, np.nan, 1, 0, 1, 0]\n",
                "        b = np.sort(a)\n",
                "        assert_equal(b, a[::-1], msg)\n",
                "\n",
                "        # all c scalar sorts use the same code with different types\n",
                "        # so it suffices to run a quick check with one type. The number\n",
                "        # of sorted items must be greater than ~50 to check the actual\n",
                "        # algorithm because quick and merge sort fall over to insertion\n",
                "        # sort for small arrays.\n",
                "        a = np.arange(101)\n",
                "        b = a[::-1].copy()\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"scalar sort, kind=%s\" % kind\n",
                "            c = a.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "            c = b.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "\n",
                "        # test complex sorts. These use the same code as the scalars\n",
                "        # but the compare function differs.\n",
                "        ai = a*1j + 1\n",
                "        bi = b*1j + 1\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"complex sort, real part == 1, kind=%s\" % kind\n",
                "            c = ai.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, ai, msg)\n",
                "            c = bi.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, ai, msg)\n",
                "        ai = a + 1j\n",
                "        bi = b + 1j\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"complex sort, imag part == 1, kind=%s\" % kind\n",
                "            c = ai.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, ai, msg)\n",
                "            c = bi.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, ai, msg)\n",
                "\n",
                "        # test sorting of complex arrays requiring byte-swapping, gh-5441\n",
                "        for endianess in '<>':\n",
                "            for dt in np.typecodes['Complex']:\n",
                "                arr = np.array([1+3.j, 2+2.j, 3+1.j], dtype=endianess + dt)\n",
                "                c = arr.copy()\n",
                "                c.sort()\n",
                "                msg = 'byte-swapped complex sort, dtype={0}'.format(dt)\n",
                "                assert_equal(c, arr, msg)\n",
                "\n",
                "        # test string sorts.\n",
                "        s = 'aaaaaaaa'\n",
                "        a = np.array([s + chr(i) for i in range(101)])\n",
                "        b = a[::-1].copy()\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"string sort, kind=%s\" % kind\n",
                "            c = a.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "            c = b.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "\n",
                "        # test unicode sorts.\n",
                "        s = 'aaaaaaaa'\n",
                "        a = np.array([s + chr(i) for i in range(101)], dtype=np.unicode)\n",
                "        b = a[::-1].copy()\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"unicode sort, kind=%s\" % kind\n",
                "            c = a.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "            c = b.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "\n",
                "        # test object array sorts.\n",
                "        a = np.empty((101,), dtype=np.object)\n",
                "        a[:] = list(range(101))\n",
                "        b = a[::-1]\n",
                "        for kind in ['q', 'h', 'm']:\n",
                "            msg = \"object sort, kind=%s\" % kind\n",
                "            c = a.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "            c = b.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "\n",
                "        # test record array sorts.\n",
                "        dt = np.dtype([('f', float), ('i', int)])\n",
                "        a = np.array([(i, i) for i in range(101)], dtype=dt)\n",
                "        b = a[::-1]\n",
                "        for kind in ['q', 'h', 'm']:\n",
                "            msg = \"object sort, kind=%s\" % kind\n",
                "            c = a.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "            c = b.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "\n",
                "        # test datetime64 sorts.\n",
                "        a = np.arange(0, 101, dtype='datetime64[D]')\n",
                "        b = a[::-1]\n",
                "        for kind in ['q', 'h', 'm']:\n",
                "            msg = \"datetime64 sort, kind=%s\" % kind\n",
                "            c = a.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "            c = b.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "\n",
                "        # test timedelta64 sorts.\n",
                "        a = np.arange(0, 101, dtype='timedelta64[D]')\n",
                "        b = a[::-1]\n",
                "        for kind in ['q', 'h', 'm']:\n",
                "            msg = \"timedelta64 sort, kind=%s\" % kind\n",
                "            c = a.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "            c = b.copy()\n",
                "            c.sort(kind=kind)\n",
                "            assert_equal(c, a, msg)\n",
                "\n",
                "        # check axis handling. This should be the same for all type\n",
                "        # specific sorts, so we only check it for one type and one kind\n",
                "        a = np.array([[3, 2], [1, 0]])\n",
                "        b = np.array([[1, 0], [3, 2]])\n",
                "        c = np.array([[2, 3], [0, 1]])\n",
                "        d = a.copy()\n",
                "        d.sort(axis=0)\n",
                "        assert_equal(d, b, \"test sort with axis=0\")\n",
                "        d = a.copy()\n",
                "        d.sort(axis=1)\n",
                "        assert_equal(d, c, \"test sort with axis=1\")\n",
                "        d = a.copy()\n",
                "        d.sort()\n",
                "        assert_equal(d, c, \"test sort with default axis\")\n",
                "\n",
                "        # check axis handling for multidimensional empty arrays\n",
                "        a = np.array([])\n",
                "        a.shape = (3, 2, 1, 0)\n",
                "        for axis in range(-a.ndim, a.ndim):\n",
                "            msg = 'test empty array sort with axis={0}'.format(axis)\n",
                "            assert_equal(np.sort(a, axis=axis), a, msg)\n",
                "        msg = 'test empty array sort with axis=None'\n",
                "        assert_equal(np.sort(a, axis=None), a.ravel(), msg)\n",
                "\n",
                "        # test generic class with bogus ordering,\n",
                "        # should not segfault.\n",
                "        class Boom(object):\n",
                "            def __lt__(self, other):\n",
                "                return True\n",
                "\n",
                "        a = np.array([Boom()]*100, dtype=object)\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"bogus comparison object sort, kind=%s\" % kind\n",
                "            c.sort(kind=kind)\n",
                "\n",
                "    def test_void_sort(self):\n",
                "        # gh-8210 - previously segfaulted\n",
                "        for i in range(4):\n",
                "            arr = np.empty(1000, 'V4')\n",
                "            arr[::-1].sort()\n",
                "\n",
                "        dt = np.dtype([('val', 'i4', (1,))])\n",
                "        for i in range(4):\n",
                "            arr = np.empty(1000, dt)\n",
                "            arr[::-1].sort()\n",
                "\n",
                "    def test_sort_degraded(self):\n",
                "        # test degraded dataset would take minutes to run with normal qsort\n",
                "        d = np.arange(1000000)\n",
                "        do = d.copy()\n",
                "        x = d\n",
                "        # create a median of 3 killer where each median is the sorted second\n",
                "        # last element of the quicksort partition\n",
                "        while x.size > 3:\n",
                "            mid = x.size // 2\n",
                "            x[mid], x[-2] = x[-2], x[mid]\n",
                "            x = x[:-2]\n",
                "\n",
                "        assert_equal(np.sort(d), do)\n",
                "        assert_equal(d[np.argsort(d)], do)\n",
                "\n",
                "    def test_copy(self):\n",
                "        def assert_fortran(arr):\n",
                "            assert_(arr.flags.fortran)\n",
                "            assert_(arr.flags.f_contiguous)\n",
                "            assert_(not arr.flags.c_contiguous)\n",
                "\n",
                "        def assert_c(arr):\n",
                "            assert_(not arr.flags.fortran)\n",
                "            assert_(not arr.flags.f_contiguous)\n",
                "            assert_(arr.flags.c_contiguous)\n",
                "\n",
                "        a = np.empty((2, 2), order='F')\n",
                "        # Test copying a Fortran array\n",
                "        assert_c(a.copy())\n",
                "        assert_c(a.copy('C'))\n",
                "        assert_fortran(a.copy('F'))\n",
                "        assert_fortran(a.copy('A'))\n",
                "\n",
                "        # Now test starting with a C array.\n",
                "        a = np.empty((2, 2), order='C')\n",
                "        assert_c(a.copy())\n",
                "        assert_c(a.copy('C'))\n",
                "        assert_fortran(a.copy('F'))\n",
                "        assert_c(a.copy('A'))\n",
                "\n",
                "    def test_sort_order(self):\n",
                "        # Test sorting an array with fields\n",
                "        x1 = np.array([21, 32, 14])\n",
                "        x2 = np.array(['my', 'first', 'name'])\n",
                "        x3 = np.array([3.1, 4.5, 6.2])\n",
                "        r = np.rec.fromarrays([x1, x2, x3], names='id,word,number')\n",
                "\n",
                "        r.sort(order=['id'])\n",
                "        assert_equal(r.id, np.array([14, 21, 32]))\n",
                "        assert_equal(r.word, np.array(['name', 'my', 'first']))\n",
                "        assert_equal(r.number, np.array([6.2, 3.1, 4.5]))\n",
                "\n",
                "        r.sort(order=['word'])\n",
                "        assert_equal(r.id, np.array([32, 21, 14]))\n",
                "        assert_equal(r.word, np.array(['first', 'my', 'name']))\n",
                "        assert_equal(r.number, np.array([4.5, 3.1, 6.2]))\n",
                "\n",
                "        r.sort(order=['number'])\n",
                "        assert_equal(r.id, np.array([21, 32, 14]))\n",
                "        assert_equal(r.word, np.array(['my', 'first', 'name']))\n",
                "        assert_equal(r.number, np.array([3.1, 4.5, 6.2]))\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        assert_raises_regex(ValueError, 'duplicate',\n",
                    "            lambda: r.sort(order=['id', 'id']))\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 1540,
                    "end": 1540
                },
                "child_version_range": {
                    "start": 1540,
                    "end": 1543
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "TestMethods",
                        "signature": "class TestMethods(TestCase):",
                        "at_line": 1158
                    },
                    {
                        "type": "function",
                        "name": "test_sort_order",
                        "signature": "def test_sort_order(self):",
                        "at_line": 1518
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: numpy/core/tests/test_multiarray.py\nCode:\n             class TestMethods(TestCase):\n                 ...\n                 def test_sort_order(self):\n                     ...\n1537 1537            assert_equal(r.word, np.array(['my', 'first', 'name']))\n1538 1538            assert_equal(r.number, np.array([3.1, 4.5, 6.2]))\n1539 1539    \n     1540  +         assert_raises_regex(ValueError, 'duplicate',\n     1541  +             lambda: r.sort(order=['id', 'id']))\n     1542  + \n1540 1543            if sys.byteorder == 'little':\n1541 1544                strtype = '>i2'\n1542 1545            else:\n           ...\n",
                "file_path": "numpy/core/tests/test_multiarray.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "ValueError",
                    "assert_raises_regex",
                    "order",
                    "r",
                    "sort"
                ],
                "prefix": [
                    "        assert_equal(r.word, np.array(['my', 'first', 'name']))\n",
                    "        assert_equal(r.number, np.array([3.1, 4.5, 6.2]))\n",
                    "\n"
                ],
                "suffix": [
                    "        if sys.byteorder == 'little':\n",
                    "            strtype = '>i2'\n",
                    "        else:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "assert_raises_regex",
                            "position": {
                                "start": {
                                    "line": 1540,
                                    "column": 8
                                },
                                "end": {
                                    "line": 1540,
                                    "column": 27
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/numpy/numpy/core/tests/test_multiarray.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        if sys.byteorder == 'little':\n",
                "            strtype = '>i2'\n",
                "        else:\n",
                "            strtype = '<i2'\n",
                "        mydtype = [('name', strchar + '5'), ('col2', strtype)]\n",
                "        r = np.array([('a', 1), ('b', 255), ('c', 3), ('d', 258)],\n",
                "                     dtype=mydtype)\n",
                "        r.sort(order='col2')\n",
                "        assert_equal(r['col2'], [1, 3, 255, 258])\n",
                "        assert_equal(r, np.array([('a', 1), ('c', 3), ('b', 255), ('d', 258)],\n",
                "                                 dtype=mydtype))\n",
                "\n",
                "    def test_argsort(self):\n",
                "        # all c scalar argsorts use the same code with different types\n",
                "        # so it suffices to run a quick check with one type. The number\n",
                "        # of sorted items must be greater than ~50 to check the actual\n",
                "        # algorithm because quick and merge sort fall over to insertion\n",
                "        # sort for small arrays.\n",
                "        a = np.arange(101)\n",
                "        b = a[::-1].copy()\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"scalar argsort, kind=%s\" % kind\n",
                "            assert_equal(a.copy().argsort(kind=kind), a, msg)\n",
                "            assert_equal(b.copy().argsort(kind=kind), b, msg)\n",
                "\n",
                "        # test complex argsorts. These use the same code as the scalars\n",
                "        # but the compare function differs.\n",
                "        ai = a*1j + 1\n",
                "        bi = b*1j + 1\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"complex argsort, kind=%s\" % kind\n",
                "            assert_equal(ai.copy().argsort(kind=kind), a, msg)\n",
                "            assert_equal(bi.copy().argsort(kind=kind), b, msg)\n",
                "        ai = a + 1j\n",
                "        bi = b + 1j\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"complex argsort, kind=%s\" % kind\n",
                "            assert_equal(ai.copy().argsort(kind=kind), a, msg)\n",
                "            assert_equal(bi.copy().argsort(kind=kind), b, msg)\n",
                "\n",
                "        # test argsort of complex arrays requiring byte-swapping, gh-5441\n",
                "        for endianess in '<>':\n",
                "            for dt in np.typecodes['Complex']:\n",
                "                arr = np.array([1+3.j, 2+2.j, 3+1.j], dtype=endianess + dt)\n",
                "                msg = 'byte-swapped complex argsort, dtype={0}'.format(dt)\n",
                "                assert_equal(arr.argsort(),\n",
                "                             np.arange(len(arr), dtype=np.intp), msg)\n",
                "\n",
                "        # test string argsorts.\n",
                "        s = 'aaaaaaaa'\n",
                "        a = np.array([s + chr(i) for i in range(101)])\n",
                "        b = a[::-1].copy()\n",
                "        r = np.arange(101)\n",
                "        rr = r[::-1]\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"string argsort, kind=%s\" % kind\n",
                "            assert_equal(a.copy().argsort(kind=kind), r, msg)\n",
                "            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n",
                "\n",
                "        # test unicode argsorts.\n",
                "        s = 'aaaaaaaa'\n",
                "        a = np.array([s + chr(i) for i in range(101)], dtype=np.unicode)\n",
                "        b = a[::-1]\n",
                "        r = np.arange(101)\n",
                "        rr = r[::-1]\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"unicode argsort, kind=%s\" % kind\n",
                "            assert_equal(a.copy().argsort(kind=kind), r, msg)\n",
                "            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n",
                "\n",
                "        # test object array argsorts.\n",
                "        a = np.empty((101,), dtype=np.object)\n",
                "        a[:] = list(range(101))\n",
                "        b = a[::-1]\n",
                "        r = np.arange(101)\n",
                "        rr = r[::-1]\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"object argsort, kind=%s\" % kind\n",
                "            assert_equal(a.copy().argsort(kind=kind), r, msg)\n",
                "            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n",
                "\n",
                "        # test structured array argsorts.\n",
                "        dt = np.dtype([('f', float), ('i', int)])\n",
                "        a = np.array([(i, i) for i in range(101)], dtype=dt)\n",
                "        b = a[::-1]\n",
                "        r = np.arange(101)\n",
                "        rr = r[::-1]\n",
                "        for kind in ['q', 'm', 'h']:\n",
                "            msg = \"structured array argsort, kind=%s\" % kind\n",
                "            assert_equal(a.copy().argsort(kind=kind), r, msg)\n",
                "            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n",
                "\n",
                "        # test datetime64 argsorts.\n",
                "        a = np.arange(0, 101, dtype='datetime64[D]')\n",
                "        b = a[::-1]\n",
                "        r = np.arange(101)\n",
                "        rr = r[::-1]\n",
                "        for kind in ['q', 'h', 'm']:\n",
                "            msg = \"datetime64 argsort, kind=%s\" % kind\n",
                "            assert_equal(a.copy().argsort(kind=kind), r, msg)\n",
                "            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n",
                "\n",
                "        # test timedelta64 argsorts.\n",
                "        a = np.arange(0, 101, dtype='timedelta64[D]')\n",
                "        b = a[::-1]\n",
                "        r = np.arange(101)\n",
                "        rr = r[::-1]\n",
                "        for kind in ['q', 'h', 'm']:\n",
                "            msg = \"timedelta64 argsort, kind=%s\" % kind\n",
                "            assert_equal(a.copy().argsort(kind=kind), r, msg)\n",
                "            assert_equal(b.copy().argsort(kind=kind), rr, msg)\n",
                "\n",
                "        # check axis handling. This should be the same for all type\n",
                "        # specific argsorts, so we only check it for one type and one kind\n",
                "        a = np.array([[3, 2], [1, 0]])\n",
                "        b = np.array([[1, 1], [0, 0]])\n",
                "        c = np.array([[1, 0], [1, 0]])\n",
                "        assert_equal(a.copy().argsort(axis=0), b)\n",
                "        assert_equal(a.copy().argsort(axis=1), c)\n",
                "        assert_equal(a.copy().argsort(), c)\n",
                "\n",
                "        # check axis handling for multidimensional empty arrays\n",
                "        a = np.array([])\n",
                "        a.shape = (3, 2, 1, 0)\n",
                "        for axis in range(-a.ndim, a.ndim):\n",
                "            msg = 'test empty array argsort with axis={0}'.format(axis)\n",
                "            assert_equal(np.argsort(a, axis=axis),\n",
                "                         np.zeros_like(a, dtype=np.intp), msg)\n",
                "        msg = 'test empty array argsort with axis=None'\n",
                "        assert_equal(np.argsort(a, axis=None),\n",
                "                     np.zeros_like(a.ravel(), dtype=np.intp), msg)\n",
                "\n",
                "        # check that stable argsorts are stable\n",
                "        r = np.arange(100)\n",
                "        # scalars\n",
                "        a = np.zeros(100)\n",
                "        assert_equal(a.argsort(kind='m'), r)\n",
                "        # complex\n",
                "        a = np.zeros(100, dtype=np.complex)\n",
                "        assert_equal(a.argsort(kind='m'), r)\n",
                "        # string\n",
                "        a = np.array(['aaaaaaaaa' for i in range(100)])\n",
                "        assert_equal(a.argsort(kind='m'), r)\n",
                "        # unicode\n",
                "        a = np.array(['aaaaaaaaa' for i in range(100)], dtype=np.unicode)\n",
                "        assert_equal(a.argsort(kind='m'), r)\n",
                "\n",
                "    def test_sort_unicode_kind(self):\n",
                "        d = np.arange(10)\n",
                "        k = b'\\xc3\\xa4'.decode(\"UTF8\")\n",
                "        assert_raises(ValueError, d.sort, kind=k)\n",
                "        assert_raises(ValueError, d.argsort, kind=k)\n",
                "\n",
                "    def test_searchsorted(self):\n",
                "        # test for floats and complex containing nans. The logic is the\n",
                "        # same for all float types so only test double types for now.\n",
                "        # The search sorted routines use the compare functions for the\n",
                "        # array type, so this checks if that is consistent with the sort\n",
                "        # order.\n",
                "\n",
                "        # check double\n",
                "        a = np.array([0, 1, np.nan])\n",
                "        msg = \"Test real searchsorted with nans, side='l'\"\n",
                "        b = a.searchsorted(a, side='l')\n",
                "        assert_equal(b, np.arange(3), msg)\n",
                "        msg = \"Test real searchsorted with nans, side='r'\"\n",
                "        b = a.searchsorted(a, side='r')\n",
                "        assert_equal(b, np.arange(1, 4), msg)\n",
                "        # check double complex\n",
                "        a = np.zeros(9, dtype=np.complex128)\n",
                "        a.real += [0, 0, 1, 1, 0, 1, np.nan, np.nan, np.nan]\n",
                "        a.imag += [0, 1, 0, 1, np.nan, np.nan, 0, 1, np.nan]\n",
                "        msg = \"Test complex searchsorted with nans, side='l'\"\n",
                "        b = a.searchsorted(a, side='l')\n",
                "        assert_equal(b, np.arange(9), msg)\n",
                "        msg = \"Test complex searchsorted with nans, side='r'\"\n",
                "        b = a.searchsorted(a, side='r')\n",
                "        assert_equal(b, np.arange(1, 10), msg)\n",
                "        msg = \"Test searchsorted with little endian, side='l'\"\n",
                "        a = np.array([0, 128], dtype='<i4')\n",
                "        b = a.searchsorted(np.array(128, dtype='<i4'))\n",
                "        assert_equal(b, 1, msg)\n",
                "        msg = \"Test searchsorted with big endian, side='l'\"\n",
                "        a = np.array([0, 128], dtype='>i4')\n",
                "        b = a.searchsorted(np.array(128, dtype='>i4'))\n",
                "        assert_equal(b, 1, msg)\n",
                "\n",
                "        # Check 0 elements\n",
                "        a = np.ones(0)\n",
                "        b = a.searchsorted([0, 1, 2], 'l')\n",
                "        assert_equal(b, [0, 0, 0])\n",
                "        b = a.searchsorted([0, 1, 2], 'r')\n",
                "        assert_equal(b, [0, 0, 0])\n",
                "        a = np.ones(1)\n",
                "        # Check 1 element\n",
                "        b = a.searchsorted([0, 1, 2], 'l')\n",
                "        assert_equal(b, [0, 0, 1])\n",
                "        b = a.searchsorted([0, 1, 2], 'r')\n",
                "        assert_equal(b, [0, 1, 1])\n",
                "        # Check all elements equal\n",
                "        a = np.ones(2)\n",
                "        b = a.searchsorted([0, 1, 2], 'l')\n",
                "        assert_equal(b, [0, 0, 2])\n",
                "        b = a.searchsorted([0, 1, 2], 'r')\n",
                "        assert_equal(b, [0, 2, 2])\n",
                "\n",
                "        # Test searching unaligned array\n",
                "        a = np.arange(10)\n",
                "        aligned = np.empty(a.itemsize * a.size + 1, 'uint8')\n",
                "        unaligned = aligned[1:].view(a.dtype)\n",
                "        unaligned[:] = a\n",
                "        # Test searching unaligned array\n",
                "        b = unaligned.searchsorted(a, 'l')\n",
                "        assert_equal(b, a)\n",
                "        b = unaligned.searchsorted(a, 'r')\n",
                "        assert_equal(b, a + 1)\n",
                "        # Test searching for unaligned keys\n",
                "        b = a.searchsorted(unaligned, 'l')\n",
                "        assert_equal(b, a)\n",
                "        b = a.searchsorted(unaligned, 'r')\n",
                "        assert_equal(b, a + 1)\n",
                "\n",
                "        # Test smart resetting of binsearch indices\n",
                "        a = np.arange(5)\n",
                "        b = a.searchsorted([6, 5, 4], 'l')\n",
                "        assert_equal(b, [5, 5, 4])\n",
                "        b = a.searchsorted([6, 5, 4], 'r')\n",
                "        assert_equal(b, [5, 5, 5])\n",
                "\n",
                "        # Test all type specific binary search functions\n",
                "        types = ''.join((np.typecodes['AllInteger'], np.typecodes['AllFloat'],\n",
                "                         np.typecodes['Datetime'], '?O'))\n",
                "        for dt in types:\n",
                "            if dt == 'M':\n",
                "                dt = 'M8[D]'\n",
                "            if dt == '?':\n",
                "                a = np.arange(2, dtype=dt)\n",
                "                out = np.arange(2)\n",
                "            else:\n",
                "                a = np.arange(0, 5, dtype=dt)\n",
                "                out = np.arange(5)\n",
                "            b = a.searchsorted(a, 'l')\n",
                "            assert_equal(b, out)\n",
                "            b = a.searchsorted(a, 'r')\n",
                "            assert_equal(b, out + 1)\n",
                "\n",
                "    def test_searchsorted_unicode(self):\n",
                "        # Test searchsorted on unicode strings.\n",
                "\n",
                "        # 1.6.1 contained a string length miscalculation in\n",
                "        # arraytypes.c.src:UNICODE_compare() which manifested as\n",
                "        # incorrect/inconsistent results from searchsorted.\n",
                "        a = np.array(['P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100185_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100186_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100187_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100189_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100190_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100191_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100192_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100193_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100194_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100195_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100196_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100197_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100198_1',\n",
                "                      'P:\\\\20x_dapi_cy3\\\\20x_dapi_cy3_20100199_1'],\n",
                "                     dtype=np.unicode)\n",
                "        ind = np.arange(len(a))\n",
                "        assert_equal([a.searchsorted(v, 'left') for v in a], ind)\n",
                "        assert_equal([a.searchsorted(v, 'right') for v in a], ind + 1)\n",
                "        assert_equal([a.searchsorted(a[i], 'left') for i in ind], ind)\n",
                "        assert_equal([a.searchsorted(a[i], 'right') for i in ind], ind + 1)\n",
                "\n",
                "    def test_searchsorted_with_sorter(self):\n",
                "        a = np.array([5, 2, 1, 3, 4])\n",
                "        s = np.argsort(a)\n",
                "        assert_raises(TypeError, np.searchsorted, a, 0, sorter=(1, (2, 3)))\n",
                "        assert_raises(TypeError, np.searchsorted, a, 0, sorter=[1.1])\n",
                "        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[1, 2, 3, 4])\n",
                "        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[1, 2, 3, 4, 5, 6])\n",
                "\n",
                "        # bounds check\n",
                "        assert_raises(ValueError, np.searchsorted, a, 4, sorter=[0, 1, 2, 3, 5])\n",
                "        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[-1, 0, 1, 2, 3])\n",
                "        assert_raises(ValueError, np.searchsorted, a, 0, sorter=[4, 0, -1, 2, 3])\n",
                "\n",
                "        a = np.random.rand(300)\n",
                "        s = a.argsort()\n",
                "        b = np.sort(a)\n",
                "        k = np.linspace(0, 1, 20)\n",
                "        assert_equal(b.searchsorted(k), a.searchsorted(k, sorter=s))\n",
                "\n",
                "        a = np.array([0, 1, 2, 3, 5]*20)\n",
                "        s = a.argsort()\n",
                "        k = [0, 1, 2, 3, 5]\n",
                "        expected = [0, 20, 40, 60, 80]\n",
                "        assert_equal(a.searchsorted(k, side='l', sorter=s), expected)\n",
                "        expected = [20, 40, 60, 80, 100]\n",
                "        assert_equal(a.searchsorted(k, side='r', sorter=s), expected)\n",
                "\n",
                "        # Test searching unaligned array\n",
                "        keys = np.arange(10)\n",
                "        a = keys.copy()\n",
                "        np.random.shuffle(s)\n",
                "        s = a.argsort()\n",
                "        aligned = np.empty(a.itemsize * a.size + 1, 'uint8')\n",
                "        unaligned = aligned[1:].view(a.dtype)\n",
                "        # Test searching unaligned array\n",
                "        unaligned[:] = a\n",
                "        b = unaligned.searchsorted(keys, 'l', s)\n",
                "        assert_equal(b, keys)\n",
                "        b = unaligned.searchsorted(keys, 'r', s)\n",
                "        assert_equal(b, keys + 1)\n",
                "        # Test searching for unaligned keys\n",
                "        unaligned[:] = keys\n",
                "        b = a.searchsorted(unaligned, 'l', s)\n",
                "        assert_equal(b, keys)\n",
                "        b = a.searchsorted(unaligned, 'r', s)\n",
                "        assert_equal(b, keys + 1)\n",
                "\n",
                "        # Test all type specific indirect binary search functions\n",
                "        types = ''.join((np.typecodes['AllInteger'], np.typecodes['AllFloat'],\n",
                "                         np.typecodes['Datetime'], '?O'))\n",
                "        for dt in types:\n",
                "            if dt == 'M':\n",
                "                dt = 'M8[D]'\n",
                "            if dt == '?':\n",
                "                a = np.array([1, 0], dtype=dt)\n",
                "                # We want the sorter array to be of a type that is different\n",
                "                # from np.intp in all platforms, to check for #4698\n",
                "                s = np.array([1, 0], dtype=np.int16)\n",
                "                out = np.array([1, 0])\n",
                "            else:\n",
                "                a = np.array([3, 4, 1, 2, 0], dtype=dt)\n",
                "                # We want the sorter array to be of a type that is different\n",
                "                # from np.intp in all platforms, to check for #4698\n",
                "                s = np.array([4, 2, 3, 0, 1], dtype=np.int16)\n",
                "                out = np.array([3, 4, 1, 2, 0], dtype=np.intp)\n",
                "            b = a.searchsorted(a, 'l', s)\n",
                "            assert_equal(b, out)\n",
                "            b = a.searchsorted(a, 'r', s)\n",
                "            assert_equal(b, out + 1)\n",
                "\n",
                "        # Test non-contiguous sorter array\n",
                "        a = np.array([3, 4, 1, 2, 0])\n",
                "        srt = np.empty((10,), dtype=np.intp)\n",
                "        srt[1::2] = -1\n",
                "        srt[::2] = [4, 2, 3, 0, 1]\n",
                "        s = srt[::2]\n",
                "        out = np.array([3, 4, 1, 2, 0], dtype=np.intp)\n",
                "        b = a.searchsorted(a, 'l', s)\n",
                "        assert_equal(b, out)\n",
                "        b = a.searchsorted(a, 'r', s)\n",
                "        assert_equal(b, out + 1)\n",
                "\n",
                "    def test_searchsorted_return_type(self):\n",
                "        # Functions returning indices should always return base ndarrays\n",
                "        class A(np.ndarray):\n",
                "            pass\n",
                "        a = np.arange(5).view(A)\n",
                "        b = np.arange(1, 3).view(A)\n",
                "        s = np.arange(5).view(A)\n",
                "        assert_(not isinstance(a.searchsorted(b, 'l'), A))\n",
                "        assert_(not isinstance(a.searchsorted(b, 'r'), A))\n",
                "        assert_(not isinstance(a.searchsorted(b, 'l', s), A))\n",
                "        assert_(not isinstance(a.searchsorted(b, 'r', s), A))\n",
                "\n",
                "    def test_argpartition_out_of_range(self):\n",
                "        # Test out of range values in kth raise an error, gh-5469\n",
                "        d = np.arange(10)\n",
                "        assert_raises(ValueError, d.argpartition, 10)\n",
                "        assert_raises(ValueError, d.argpartition, -11)\n",
                "        # Test also for generic type argpartition, which uses sorting\n",
                "        # and used to not bound check kth\n",
                "        d_obj = np.arange(10, dtype=object)\n",
                "        assert_raises(ValueError, d_obj.argpartition, 10)\n",
                "        assert_raises(ValueError, d_obj.argpartition, -11)\n",
                "\n",
                "    def test_partition_out_of_range(self):\n",
                "        # Test out of range values in kth raise an error, gh-5469\n",
                "        d = np.arange(10)\n",
                "        assert_raises(ValueError, d.partition, 10)\n",
                "        assert_raises(ValueError, d.partition, -11)\n",
                "        # Test also for generic type partition, which uses sorting\n",
                "        # and used to not bound check kth\n",
                "        d_obj = np.arange(10, dtype=object)\n",
                "        assert_raises(ValueError, d_obj.partition, 10)\n",
                "        assert_raises(ValueError, d_obj.partition, -11)\n",
                "\n",
                "    def test_argpartition_integer(self):\n",
                "        # Test non-integer values in kth raise an error/\n",
                "        d = np.arange(10)\n",
                "        assert_raises(TypeError, d.argpartition, 9.)\n",
                "        # Test also for generic type argpartition, which uses sorting\n",
                "        # and used to not bound check kth\n",
                "        d_obj = np.arange(10, dtype=object)\n",
                "        assert_raises(TypeError, d_obj.argpartition, 9.)\n",
                "\n",
                "    def test_partition_integer(self):\n",
                "        # Test out of range values in kth raise an error, gh-5469\n",
                "        d = np.arange(10)\n",
                "        assert_raises(TypeError, d.partition, 9.)\n",
                "        # Test also for generic type partition, which uses sorting\n",
                "        # and used to not bound check kth\n",
                "        d_obj = np.arange(10, dtype=object)\n",
                "        assert_raises(TypeError, d_obj.partition, 9.)\n",
                "\n",
                "    def test_partition_empty_array(self):\n",
                "        # check axis handling for multidimensional empty arrays\n",
                "        a = np.array([])\n",
                "        a.shape = (3, 2, 1, 0)\n",
                "        for axis in range(-a.ndim, a.ndim):\n",
                "            msg = 'test empty array partition with axis={0}'.format(axis)\n",
                "            assert_equal(np.partition(a, 0, axis=axis), a, msg)\n",
                "        msg = 'test empty array partition with axis=None'\n",
                "        assert_equal(np.partition(a, 0, axis=None), a.ravel(), msg)\n",
                "\n",
                "    def test_argpartition_empty_array(self):\n",
                "        # check axis handling for multidimensional empty arrays\n",
                "        a = np.array([])\n",
                "        a.shape = (3, 2, 1, 0)\n",
                "        for axis in range(-a.ndim, a.ndim):\n",
                "            msg = 'test empty array argpartition with axis={0}'.format(axis)\n",
                "            assert_equal(np.partition(a, 0, axis=axis),\n",
                "                         np.zeros_like(a, dtype=np.intp), msg)\n",
                "        msg = 'test empty array argpartition with axis=None'\n",
                "        assert_equal(np.partition(a, 0, axis=None),\n",
                "                     np.zeros_like(a.ravel(), dtype=np.intp), msg)\n",
                "\n",
                "    def test_partition(self):\n",
                "        d = np.arange(10)\n",
                "        assert_raises(TypeError, np.partition, d, 2, kind=1)\n",
                "        assert_raises(ValueError, np.partition, d, 2, kind=\"nonsense\")\n",
                "        assert_raises(ValueError, np.argpartition, d, 2, kind=\"nonsense\")\n",
                "        assert_raises(ValueError, d.partition, 2, axis=0, kind=\"nonsense\")\n",
                "        assert_raises(ValueError, d.argpartition, 2, axis=0, kind=\"nonsense\")\n",
                "        for k in (\"introselect\",):\n",
                "            d = np.array([])\n",
                "            assert_array_equal(np.partition(d, 0, kind=k), d)\n",
                "            assert_array_equal(np.argpartition(d, 0, kind=k), d)\n",
                "            d = np.ones(1)\n",
                "            assert_array_equal(np.partition(d, 0, kind=k)[0], d)\n",
                "            assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n",
                "                               np.partition(d, 0, kind=k))\n",
                "\n",
                "            # kth not modified\n",
                "            kth = np.array([30, 15, 5])\n",
                "            okth = kth.copy()\n",
                "            np.partition(np.arange(40), kth)\n",
                "            assert_array_equal(kth, okth)\n",
                "\n",
                "            for r in ([2, 1], [1, 2], [1, 1]):\n",
                "                d = np.array(r)\n",
                "                tgt = np.sort(d)\n",
                "                assert_array_equal(np.partition(d, 0, kind=k)[0], tgt[0])\n",
                "                assert_array_equal(np.partition(d, 1, kind=k)[1], tgt[1])\n",
                "                assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n",
                "                                   np.partition(d, 0, kind=k))\n",
                "                assert_array_equal(d[np.argpartition(d, 1, kind=k)],\n",
                "                                   np.partition(d, 1, kind=k))\n",
                "                for i in range(d.size):\n",
                "                    d[i:].partition(0, kind=k)\n",
                "                assert_array_equal(d, tgt)\n",
                "\n",
                "            for r in ([3, 2, 1], [1, 2, 3], [2, 1, 3], [2, 3, 1],\n",
                "                      [1, 1, 1], [1, 2, 2], [2, 2, 1], [1, 2, 1]):\n",
                "                d = np.array(r)\n",
                "                tgt = np.sort(d)\n",
                "                assert_array_equal(np.partition(d, 0, kind=k)[0], tgt[0])\n",
                "                assert_array_equal(np.partition(d, 1, kind=k)[1], tgt[1])\n",
                "                assert_array_equal(np.partition(d, 2, kind=k)[2], tgt[2])\n",
                "                assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n",
                "                                   np.partition(d, 0, kind=k))\n",
                "                assert_array_equal(d[np.argpartition(d, 1, kind=k)],\n",
                "                                   np.partition(d, 1, kind=k))\n",
                "                assert_array_equal(d[np.argpartition(d, 2, kind=k)],\n",
                "                                   np.partition(d, 2, kind=k))\n",
                "                for i in range(d.size):\n",
                "                    d[i:].partition(0, kind=k)\n",
                "                assert_array_equal(d, tgt)\n",
                "\n",
                "            d = np.ones(50)\n",
                "            assert_array_equal(np.partition(d, 0, kind=k), d)\n",
                "            assert_array_equal(d[np.argpartition(d, 0, kind=k)],\n",
                "                               np.partition(d, 0, kind=k))\n",
                "\n",
                "            # sorted\n",
                "            d = np.arange(49)\n",
                "            self.assertEqual(np.partition(d, 5, kind=k)[5], 5)\n",
                "            self.assertEqual(np.partition(d, 15, kind=k)[15], 15)\n",
                "            assert_array_equal(d[np.argpartition(d, 5, kind=k)],\n",
                "                               np.partition(d, 5, kind=k))\n",
                "            assert_array_equal(d[np.argpartition(d, 15, kind=k)],\n",
                "                               np.partition(d, 15, kind=k))\n",
                "\n",
                "            # rsorted\n",
                "            d = np.arange(47)[::-1]\n",
                "            self.assertEqual(np.partition(d, 6, kind=k)[6], 6)\n",
                "            self.assertEqual(np.partition(d, 16, kind=k)[16], 16)\n",
                "            assert_array_equal(d[np.argpartition(d, 6, kind=k)],\n",
                "                               np.partition(d, 6, kind=k))\n",
                "            assert_array_equal(d[np.argpartition(d, 16, kind=k)],\n",
                "                               np.partition(d, 16, kind=k))\n",
                "\n",
                "            assert_array_equal(np.partition(d, -6, kind=k),\n",
                "                               np.partition(d, 41, kind=k))\n",
                "            assert_array_equal(np.partition(d, -16, kind=k),\n",
                "                               np.partition(d, 31, kind=k))\n",
                "            assert_array_equal(d[np.argpartition(d, -6, kind=k)],\n",
                "                               np.partition(d, 41, kind=k))\n",
                "\n",
                "            # median of 3 killer, O(n^2) on pure median 3 pivot quickselect\n",
                "            # exercises the median of median of 5 code used to keep O(n)\n",
                "            d = np.arange(1000000)\n",
                "            x = np.roll(d, d.size // 2)\n",
                "            mid = x.size // 2 + 1\n",
                "            assert_equal(np.partition(x, mid)[mid], mid)\n",
                "            d = np.arange(1000001)\n",
                "            x = np.roll(d, d.size // 2 + 1)\n",
                "            mid = x.size // 2 + 1\n",
                "            assert_equal(np.partition(x, mid)[mid], mid)\n",
                "\n",
                "            # max\n",
                "            d = np.ones(10)\n",
                "            d[1] = 4\n",
                "            assert_equal(np.partition(d, (2, -1))[-1], 4)\n",
                "            assert_equal(np.partition(d, (2, -1))[2], 1)\n",
                "            assert_equal(d[np.argpartition(d, (2, -1))][-1], 4)\n",
                "            assert_equal(d[np.argpartition(d, (2, -1))][2], 1)\n",
                "            d[1] = np.nan\n",
                "            assert_(np.isnan(d[np.argpartition(d, (2, -1))][-1]))\n",
                "            assert_(np.isnan(np.partition(d, (2, -1))[-1]))\n",
                "\n",
                "            # equal elements\n",
                "            d = np.arange(47) % 7\n",
                "            tgt = np.sort(np.arange(47) % 7)\n",
                "            np.random.shuffle(d)\n",
                "            for i in range(d.size):\n",
                "                self.assertEqual(np.partition(d, i, kind=k)[i], tgt[i])\n",
                "            assert_array_equal(d[np.argpartition(d, 6, kind=k)],\n",
                "                               np.partition(d, 6, kind=k))\n",
                "            assert_array_equal(d[np.argpartition(d, 16, kind=k)],\n",
                "                               np.partition(d, 16, kind=k))\n",
                "            for i in range(d.size):\n",
                "                d[i:].partition(0, kind=k)\n",
                "            assert_array_equal(d, tgt)\n",
                "\n",
                "            d = np.array([0, 1, 2, 3, 4, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n",
                "                          7, 7, 7, 7, 7, 9])\n",
                "            kth = [0, 3, 19, 20]\n",
                "            assert_equal(np.partition(d, kth, kind=k)[kth], (0, 3, 7, 7))\n",
                "            assert_equal(d[np.argpartition(d, kth, kind=k)][kth], (0, 3, 7, 7))\n",
                "\n",
                "            d = np.array([2, 1])\n",
                "            d.partition(0, kind=k)\n",
                "            assert_raises(ValueError, d.partition, 2)\n",
                "            assert_raises(np.AxisError, d.partition, 3, axis=1)\n",
                "            assert_raises(ValueError, np.partition, d, 2)\n",
                "            assert_raises(np.AxisError, np.partition, d, 2, axis=1)\n",
                "            assert_raises(ValueError, d.argpartition, 2)\n",
                "            assert_raises(np.AxisError, d.argpartition, 3, axis=1)\n",
                "            assert_raises(ValueError, np.argpartition, d, 2)\n",
                "            assert_raises(np.AxisError, np.argpartition, d, 2, axis=1)\n",
                "            d = np.arange(10).reshape((2, 5))\n",
                "            d.partition(1, axis=0, kind=k)\n",
                "            d.partition(4, axis=1, kind=k)\n",
                "            np.partition(d, 1, axis=0, kind=k)\n",
                "            np.partition(d, 4, axis=1, kind=k)\n",
                "            np.partition(d, 1, axis=None, kind=k)\n",
                "            np.partition(d, 9, axis=None, kind=k)\n",
                "            d.argpartition(1, axis=0, kind=k)\n",
                "            d.argpartition(4, axis=1, kind=k)\n",
                "            np.argpartition(d, 1, axis=0, kind=k)\n",
                "            np.argpartition(d, 4, axis=1, kind=k)\n",
                "            np.argpartition(d, 1, axis=None, kind=k)\n",
                "            np.argpartition(d, 9, axis=None, kind=k)\n",
                "            assert_raises(ValueError, d.partition, 2, axis=0)\n",
                "            assert_raises(ValueError, d.partition, 11, axis=1)\n",
                "            assert_raises(TypeError, d.partition, 2, axis=None)\n",
                "            assert_raises(ValueError, np.partition, d, 9, axis=1)\n",
                "            assert_raises(ValueError, np.partition, d, 11, axis=None)\n",
                "            assert_raises(ValueError, d.argpartition, 2, axis=0)\n",
                "            assert_raises(ValueError, d.argpartition, 11, axis=1)\n",
                "            assert_raises(ValueError, np.argpartition, d, 9, axis=1)\n",
                "            assert_raises(ValueError, np.argpartition, d, 11, axis=None)\n",
                "\n",
                "            td = [(dt, s) for dt in [np.int32, np.float32, np.complex64]\n",
                "                  for s in (9, 16)]\n",
                "            for dt, s in td:\n",
                "                aae = assert_array_equal\n",
                "                at = self.assertTrue\n",
                "\n",
                "                d = np.arange(s, dtype=dt)\n",
                "                np.random.shuffle(d)\n",
                "                d1 = np.tile(np.arange(s, dtype=dt), (4, 1))\n",
                "                map(np.random.shuffle, d1)\n",
                "                d0 = np.transpose(d1)\n",
                "                for i in range(d.size):\n",
                "                    p = np.partition(d, i, kind=k)\n",
                "                    self.assertEqual(p[i], i)\n",
                "                    # all before are smaller\n",
                "                    assert_array_less(p[:i], p[i])\n",
                "                    # all after are larger\n",
                "                    assert_array_less(p[i], p[i + 1:])\n",
                "                    aae(p, d[np.argpartition(d, i, kind=k)])\n",
                "\n",
                "                    p = np.partition(d1, i, axis=1, kind=k)\n",
                "                    aae(p[:, i], np.array([i] * d1.shape[0], dtype=dt))\n",
                "                    # array_less does not seem to work right\n",
                "                    at((p[:, :i].T <= p[:, i]).all(),\n",
                "                       msg=\"%d: %r <= %r\" % (i, p[:, i], p[:, :i].T))\n",
                "                    at((p[:, i + 1:].T > p[:, i]).all(),\n",
                "                       msg=\"%d: %r < %r\" % (i, p[:, i], p[:, i + 1:].T))\n",
                "                    aae(p, d1[np.arange(d1.shape[0])[:, None],\n",
                "                        np.argpartition(d1, i, axis=1, kind=k)])\n",
                "\n",
                "                    p = np.partition(d0, i, axis=0, kind=k)\n",
                "                    aae(p[i, :], np.array([i] * d1.shape[0], dtype=dt))\n",
                "                    # array_less does not seem to work right\n",
                "                    at((p[:i, :] <= p[i, :]).all(),\n",
                "                       msg=\"%d: %r <= %r\" % (i, p[i, :], p[:i, :]))\n",
                "                    at((p[i + 1:, :] > p[i, :]).all(),\n",
                "                       msg=\"%d: %r < %r\" % (i, p[i, :], p[:, i + 1:]))\n",
                "                    aae(p, d0[np.argpartition(d0, i, axis=0, kind=k),\n",
                "                        np.arange(d0.shape[1])[None, :]])\n",
                "\n",
                "                    # check inplace\n",
                "                    dc = d.copy()\n",
                "                    dc.partition(i, kind=k)\n",
                "                    assert_equal(dc, np.partition(d, i, kind=k))\n",
                "                    dc = d0.copy()\n",
                "                    dc.partition(i, axis=0, kind=k)\n",
                "                    assert_equal(dc, np.partition(d0, i, axis=0, kind=k))\n",
                "                    dc = d1.copy()\n",
                "                    dc.partition(i, axis=1, kind=k)\n",
                "                    assert_equal(dc, np.partition(d1, i, axis=1, kind=k))\n",
                "\n",
                "    def assert_partitioned(self, d, kth):\n",
                "        prev = 0\n",
                "        for k in np.sort(kth):\n",
                "            assert_array_less(d[prev:k], d[k], err_msg='kth %d' % k)\n",
                "            assert_((d[k:] >= d[k]).all(),\n",
                "                    msg=\"kth %d, %r not greater equal %d\" % (k, d[k:], d[k]))\n",
                "            prev = k + 1\n",
                "\n",
                "    def test_partition_iterative(self):\n",
                "            d = np.arange(17)\n",
                "            kth = (0, 1, 2, 429, 231)\n",
                "            assert_raises(ValueError, d.partition, kth)\n",
                "            assert_raises(ValueError, d.argpartition, kth)\n",
                "            d = np.arange(10).reshape((2, 5))\n",
                "            assert_raises(ValueError, d.partition, kth, axis=0)\n",
                "            assert_raises(ValueError, d.partition, kth, axis=1)\n",
                "            assert_raises(ValueError, np.partition, d, kth, axis=1)\n",
                "            assert_raises(ValueError, np.partition, d, kth, axis=None)\n",
                "\n",
                "            d = np.array([3, 4, 2, 1])\n",
                "            p = np.partition(d, (0, 3))\n",
                "            self.assert_partitioned(p, (0, 3))\n",
                "            self.assert_partitioned(d[np.argpartition(d, (0, 3))], (0, 3))\n",
                "\n",
                "            assert_array_equal(p, np.partition(d, (-3, -1)))\n",
                "            assert_array_equal(p, d[np.argpartition(d, (-3, -1))])\n",
                "\n",
                "            d = np.arange(17)\n",
                "            np.random.shuffle(d)\n",
                "            d.partition(range(d.size))\n",
                "            assert_array_equal(np.arange(17), d)\n",
                "            np.random.shuffle(d)\n",
                "            assert_array_equal(np.arange(17), d[d.argpartition(range(d.size))])\n",
                "\n",
                "            # test unsorted kth\n",
                "            d = np.arange(17)\n",
                "            np.random.shuffle(d)\n",
                "            keys = np.array([1, 3, 8, -2])\n",
                "            np.random.shuffle(d)\n",
                "            p = np.partition(d, keys)\n",
                "            self.assert_partitioned(p, keys)\n",
                "            p = d[np.argpartition(d, keys)]\n",
                "            self.assert_partitioned(p, keys)\n",
                "            np.random.shuffle(keys)\n",
                "            assert_array_equal(np.partition(d, keys), p)\n",
                "            assert_array_equal(d[np.argpartition(d, keys)], p)\n",
                "\n",
                "            # equal kth\n",
                "            d = np.arange(20)[::-1]\n",
                "            self.assert_partitioned(np.partition(d, [5]*4), [5])\n",
                "            self.assert_partitioned(np.partition(d, [5]*4 + [6, 13]),\n",
                "                                    [5]*4 + [6, 13])\n",
                "            self.assert_partitioned(d[np.argpartition(d, [5]*4)], [5])\n",
                "            self.assert_partitioned(d[np.argpartition(d, [5]*4 + [6, 13])],\n",
                "                                    [5]*4 + [6, 13])\n",
                "\n",
                "            d = np.arange(12)\n",
                "            np.random.shuffle(d)\n",
                "            d1 = np.tile(np.arange(12), (4, 1))\n",
                "            map(np.random.shuffle, d1)\n",
                "            d0 = np.transpose(d1)\n",
                "\n",
                "            kth = (1, 6, 7, -1)\n",
                "            p = np.partition(d1, kth, axis=1)\n",
                "            pa = d1[np.arange(d1.shape[0])[:, None],\n",
                "                    d1.argpartition(kth, axis=1)]\n",
                "            assert_array_equal(p, pa)\n",
                "            for i in range(d1.shape[0]):\n",
                "                self.assert_partitioned(p[i,:], kth)\n",
                "            p = np.partition(d0, kth, axis=0)\n",
                "            pa = d0[np.argpartition(d0, kth, axis=0),\n",
                "                    np.arange(d0.shape[1])[None,:]]\n",
                "            assert_array_equal(p, pa)\n",
                "            for i in range(d0.shape[1]):\n",
                "                self.assert_partitioned(p[:, i], kth)\n",
                "\n",
                "    def test_partition_cdtype(self):\n",
                "        d = np.array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n",
                "                   ('Lancelot', 1.9, 38)],\n",
                "                  dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])\n",
                "\n",
                "        tgt = np.sort(d, order=['age', 'height'])\n",
                "        assert_array_equal(np.partition(d, range(d.size),\n",
                "                                        order=['age', 'height']),\n",
                "                           tgt)\n",
                "        assert_array_equal(d[np.argpartition(d, range(d.size),\n",
                "                                             order=['age', 'height'])],\n",
                "                           tgt)\n",
                "        for k in range(d.size):\n",
                "            assert_equal(np.partition(d, k, order=['age', 'height'])[k],\n",
                "                        tgt[k])\n",
                "            assert_equal(d[np.argpartition(d, k, order=['age', 'height'])][k],\n",
                "                         tgt[k])\n",
                "\n",
                "        d = np.array(['Galahad', 'Arthur', 'zebra', 'Lancelot'])\n",
                "        tgt = np.sort(d)\n",
                "        assert_array_equal(np.partition(d, range(d.size)), tgt)\n",
                "        for k in range(d.size):\n",
                "            assert_equal(np.partition(d, k)[k], tgt[k])\n",
                "            assert_equal(d[np.argpartition(d, k)][k], tgt[k])\n",
                "\n",
                "    def test_partition_unicode_kind(self):\n",
                "        d = np.arange(10)\n",
                "        k = b'\\xc3\\xa4'.decode(\"UTF8\")\n",
                "        assert_raises(ValueError, d.partition, 2, kind=k)\n",
                "        assert_raises(ValueError, d.argpartition, 2, kind=k)\n",
                "\n",
                "    def test_partition_fuzz(self):\n",
                "        # a few rounds of random data testing\n",
                "        for j in range(10, 30):\n",
                "            for i in range(1, j - 2):\n",
                "                d = np.arange(j)\n",
                "                np.random.shuffle(d)\n",
                "                d = d % np.random.randint(2, 30)\n",
                "                idx = np.random.randint(d.size)\n",
                "                kth = [0, idx, i, i + 1]\n",
                "                tgt = np.sort(d)[kth]\n",
                "                assert_array_equal(np.partition(d, kth)[kth], tgt,\n",
                "                                   err_msg=\"data: %r\\n kth: %r\" % (d, kth))\n",
                "\n",
                "    def test_argpartition_gh5524(self):\n",
                "        #  A test for functionality of argpartition on lists.\n",
                "        d = [6,7,3,2,9,0]\n",
                "        p = np.argpartition(d,1)\n",
                "        self.assert_partitioned(np.array(d)[p],[1])\n",
                "\n",
                "    def test_flatten(self):\n",
                "        x0 = np.array([[1, 2, 3], [4, 5, 6]], np.int32)\n",
                "        x1 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]], np.int32)\n",
                "        y0 = np.array([1, 2, 3, 4, 5, 6], np.int32)\n",
                "        y0f = np.array([1, 4, 2, 5, 3, 6], np.int32)\n",
                "        y1 = np.array([1, 2, 3, 4, 5, 6, 7, 8], np.int32)\n",
                "        y1f = np.array([1, 5, 3, 7, 2, 6, 4, 8], np.int32)\n",
                "        assert_equal(x0.flatten(), y0)\n",
                "        assert_equal(x0.flatten('F'), y0f)\n",
                "        assert_equal(x0.flatten('F'), x0.T.flatten())\n",
                "        assert_equal(x1.flatten(), y1)\n",
                "        assert_equal(x1.flatten('F'), y1f)\n",
                "        assert_equal(x1.flatten('F'), x1.T.flatten())\n",
                "\n",
                "    def test_dot(self):\n",
                "        a = np.array([[1, 0], [0, 1]])\n",
                "        b = np.array([[0, 1], [1, 0]])\n",
                "        c = np.array([[9, 1], [1, -9]])\n",
                "        d = np.arange(24).reshape(4, 6)\n",
                "        ddt = np.array(\n",
                "            [[  55,  145,  235,  325],\n",
                "             [ 145,  451,  757, 1063],\n",
                "             [ 235,  757, 1279, 1801],\n",
                "             [ 325, 1063, 1801, 2539]]\n",
                "        )\n",
                "        dtd = np.array(\n",
                "            [[504, 540, 576, 612, 648, 684],\n",
                "             [540, 580, 620, 660, 700, 740],\n",
                "             [576, 620, 664, 708, 752, 796],\n",
                "             [612, 660, 708, 756, 804, 852],\n",
                "             [648, 700, 752, 804, 856, 908],\n",
                "             [684, 740, 796, 852, 908, 964]]\n",
                "        )\n",
                "\n",
                "\n",
                "        # gemm vs syrk optimizations\n",
                "        for et in [np.float32, np.float64, np.complex64, np.complex128]:\n",
                "            eaf = a.astype(et)\n",
                "            assert_equal(np.dot(eaf, eaf), eaf)\n",
                "            assert_equal(np.dot(eaf.T, eaf), eaf)\n",
                "            assert_equal(np.dot(eaf, eaf.T), eaf)\n",
                "            assert_equal(np.dot(eaf.T, eaf.T), eaf)\n",
                "            assert_equal(np.dot(eaf.T.copy(), eaf), eaf)\n",
                "            assert_equal(np.dot(eaf, eaf.T.copy()), eaf)\n",
                "            assert_equal(np.dot(eaf.T.copy(), eaf.T.copy()), eaf)\n",
                "\n",
                "        # syrk validations\n",
                "        for et in [np.float32, np.float64, np.complex64, np.complex128]:\n",
                "            eaf = a.astype(et)\n",
                "            ebf = b.astype(et)\n",
                "            assert_equal(np.dot(ebf, ebf), eaf)\n",
                "            assert_equal(np.dot(ebf.T, ebf), eaf)\n",
                "            assert_equal(np.dot(ebf, ebf.T), eaf)\n",
                "            assert_equal(np.dot(ebf.T, ebf.T), eaf)\n",
                "\n",
                "        # syrk - different shape, stride, and view validations\n",
                "        for et in [np.float32, np.float64, np.complex64, np.complex128]:\n",
                "            edf = d.astype(et)\n",
                "            assert_equal(\n",
                "                np.dot(edf[::-1, :], edf.T),\n",
                "                np.dot(edf[::-1, :].copy(), edf.T.copy())\n",
                "            )\n",
                "            assert_equal(\n",
                "                np.dot(edf[:, ::-1], edf.T),\n",
                "                np.dot(edf[:, ::-1].copy(), edf.T.copy())\n",
                "            )\n",
                "            assert_equal(\n",
                "                np.dot(edf, edf[::-1, :].T),\n",
                "                np.dot(edf, edf[::-1, :].T.copy())\n",
                "            )\n",
                "            assert_equal(\n",
                "                np.dot(edf, edf[:, ::-1].T),\n",
                "                np.dot(edf, edf[:, ::-1].T.copy())\n",
                "            )\n",
                "            assert_equal(\n",
                "                np.dot(edf[:edf.shape[0] // 2, :], edf[::2, :].T),\n",
                "                np.dot(edf[:edf.shape[0] // 2, :].copy(), edf[::2, :].T.copy())\n",
                "            )\n",
                "            assert_equal(\n",
                "                np.dot(edf[::2, :], edf[:edf.shape[0] // 2, :].T),\n",
                "                np.dot(edf[::2, :].copy(), edf[:edf.shape[0] // 2, :].T.copy())\n",
                "            )\n",
                "\n",
                "        # syrk - different shape\n",
                "        for et in [np.float32, np.float64, np.complex64, np.complex128]:\n",
                "            edf = d.astype(et)\n",
                "            eddtf = ddt.astype(et)\n",
                "            edtdf = dtd.astype(et)\n",
                "            assert_equal(np.dot(edf, edf.T), eddtf)\n",
                "            assert_equal(np.dot(edf.T, edf), edtdf)\n",
                "\n",
                "        # function versus methods\n",
                "        assert_equal(np.dot(a, b), a.dot(b))\n",
                "        assert_equal(np.dot(np.dot(a, b), c), a.dot(b).dot(c))\n",
                "\n",
                "        # test passing in an output array\n",
                "        c = np.zeros_like(a)\n",
                "        a.dot(b, c)\n",
                "        assert_equal(c, np.dot(a, b))\n",
                "\n",
                "        # test keyword args\n",
                "        c = np.zeros_like(a)\n",
                "        a.dot(b=b, out=c)\n",
                "        assert_equal(c, np.dot(a, b))\n",
                "\n",
                "    def test_dot_type_mismatch(self):\n",
                "        c = 1.\n",
                "        A = np.array((1,1), dtype='i,i')\n",
                "\n",
                "        assert_raises(TypeError, np.dot, c, A)\n",
                "        assert_raises(TypeError, np.dot, A, c)\n",
                "\n",
                "    def test_dot_out_mem_overlap(self):\n",
                "        np.random.seed(1)\n",
                "\n",
                "        # Test BLAS and non-BLAS code paths, including all dtypes\n",
                "        # that dot() supports\n",
                "        dtypes = [np.dtype(code) for code in np.typecodes['All']\n",
                "                  if code not in 'USVM']\n",
                "        for dtype in dtypes:\n",
                "            a = np.random.rand(3, 3).astype(dtype)\n",
                "\n",
                "            # Valid dot() output arrays must be aligned\n",
                "            b = _aligned_zeros((3, 3), dtype=dtype)\n",
                "            b[...] = np.random.rand(3, 3)\n",
                "\n",
                "            y = np.dot(a, b)\n",
                "            x = np.dot(a, b, out=b)\n",
                "            assert_equal(x, y, err_msg=repr(dtype))\n",
                "\n",
                "            # Check invalid output array\n",
                "            assert_raises(ValueError, np.dot, a, b, out=b[::2])\n",
                "            assert_raises(ValueError, np.dot, a, b, out=b.T)\n",
                "\n",
                "    def test_diagonal(self):\n",
                "        a = np.arange(12).reshape((3, 4))\n",
                "        assert_equal(a.diagonal(), [0, 5, 10])\n",
                "        assert_equal(a.diagonal(0), [0, 5, 10])\n",
                "        assert_equal(a.diagonal(1), [1, 6, 11])\n",
                "        assert_equal(a.diagonal(-1), [4, 9])\n",
                "\n",
                "        b = np.arange(8).reshape((2, 2, 2))\n",
                "        assert_equal(b.diagonal(), [[0, 6], [1, 7]])\n",
                "        assert_equal(b.diagonal(0), [[0, 6], [1, 7]])\n",
                "        assert_equal(b.diagonal(1), [[2], [3]])\n",
                "        assert_equal(b.diagonal(-1), [[4], [5]])\n",
                "        assert_raises(ValueError, b.diagonal, axis1=0, axis2=0)\n",
                "        assert_equal(b.diagonal(0, 1, 2), [[0, 3], [4, 7]])\n",
                "        assert_equal(b.diagonal(0, 0, 1), [[0, 6], [1, 7]])\n",
                "        assert_equal(b.diagonal(offset=1, axis1=0, axis2=2), [[1], [3]])\n",
                "        # Order of axis argument doesn't matter:\n",
                "        assert_equal(b.diagonal(0, 2, 1), [[0, 3], [4, 7]])\n",
                "\n",
                "    def test_diagonal_view_notwriteable(self):\n",
                "        # this test is only for 1.9, the diagonal view will be\n",
                "        # writeable in 1.10.\n",
                "        a = np.eye(3).diagonal()\n",
                "        assert_(not a.flags.writeable)\n",
                "        assert_(not a.flags.owndata)\n",
                "\n",
                "        a = np.diagonal(np.eye(3))\n",
                "        assert_(not a.flags.writeable)\n",
                "        assert_(not a.flags.owndata)\n",
                "\n",
                "        a = np.diag(np.eye(3))\n",
                "        assert_(not a.flags.writeable)\n",
                "        assert_(not a.flags.owndata)\n",
                "\n",
                "    def test_diagonal_memleak(self):\n",
                "        # Regression test for a bug that crept in at one point\n",
                "        a = np.zeros((100, 100))\n",
                "        if HAS_REFCOUNT:\n",
                "            assert_(sys.getrefcount(a) < 50)\n",
                "        for i in range(100):\n",
                "            a.diagonal()\n",
                "        if HAS_REFCOUNT:\n",
                "            assert_(sys.getrefcount(a) < 50)\n",
                "\n",
                "    def test_trace(self):\n",
                "        a = np.arange(12).reshape((3, 4))\n",
                "        assert_equal(a.trace(), 15)\n",
                "        assert_equal(a.trace(0), 15)\n",
                "        assert_equal(a.trace(1), 18)\n",
                "        assert_equal(a.trace(-1), 13)\n",
                "\n",
                "        b = np.arange(8).reshape((2, 2, 2))\n",
                "        assert_equal(b.trace(), [6, 8])\n",
                "        assert_equal(b.trace(0), [6, 8])\n",
                "        assert_equal(b.trace(1), [2, 3])\n",
                "        assert_equal(b.trace(-1), [4, 5])\n",
                "        assert_equal(b.trace(0, 0, 1), [6, 8])\n",
                "        assert_equal(b.trace(0, 0, 2), [5, 9])\n",
                "        assert_equal(b.trace(0, 1, 2), [3, 11])\n",
                "        assert_equal(b.trace(offset=1, axis1=0, axis2=2), [1, 3])\n",
                "\n",
                "    def test_trace_subclass(self):\n",
                "        # The class would need to overwrite trace to ensure single-element\n",
                "        # output also has the right subclass.\n",
                "        class MyArray(np.ndarray):\n",
                "            pass\n",
                "\n",
                "        b = np.arange(8).reshape((2, 2, 2)).view(MyArray)\n",
                "        t = b.trace()\n",
                "        assert isinstance(t, MyArray)\n",
                "\n",
                "    def test_put(self):\n",
                "        icodes = np.typecodes['AllInteger']\n",
                "        fcodes = np.typecodes['AllFloat']\n",
                "        for dt in icodes + fcodes + 'O':\n",
                "            tgt = np.array([0, 1, 0, 3, 0, 5], dtype=dt)\n",
                "\n",
                "            # test 1-d\n",
                "            a = np.zeros(6, dtype=dt)\n",
                "            a.put([1, 3, 5], [1, 3, 5])\n",
                "            assert_equal(a, tgt)\n",
                "\n",
                "            # test 2-d\n",
                "            a = np.zeros((2, 3), dtype=dt)\n",
                "            a.put([1, 3, 5], [1, 3, 5])\n",
                "            assert_equal(a, tgt.reshape(2, 3))\n",
                "\n",
                "        for dt in '?':\n",
                "            tgt = np.array([False, True, False, True, False, True], dtype=dt)\n",
                "\n",
                "            # test 1-d\n",
                "            a = np.zeros(6, dtype=dt)\n",
                "            a.put([1, 3, 5], [True]*3)\n",
                "            assert_equal(a, tgt)\n",
                "\n",
                "            # test 2-d\n",
                "            a = np.zeros((2, 3), dtype=dt)\n",
                "            a.put([1, 3, 5], [True]*3)\n",
                "            assert_equal(a, tgt.reshape(2, 3))\n",
                "\n",
                "        # check must be writeable\n",
                "        a = np.zeros(6)\n",
                "        a.flags.writeable = False\n",
                "        assert_raises(ValueError, a.put, [1, 3, 5], [1, 3, 5])\n",
                "\n",
                "        # when calling np.put, make sure a\n",
                "        # TypeError is raised if the object\n",
                "        # isn't an ndarray\n",
                "        bad_array = [1, 2, 3]\n",
                "        assert_raises(TypeError, np.put, bad_array, [0, 2], 5)\n",
                "\n",
                "    def test_ravel(self):\n",
                "        a = np.array([[0, 1], [2, 3]])\n",
                "        assert_equal(a.ravel(), [0, 1, 2, 3])\n",
                "        assert_(not a.ravel().flags.owndata)\n",
                "        assert_equal(a.ravel('F'), [0, 2, 1, 3])\n",
                "        assert_equal(a.ravel(order='C'), [0, 1, 2, 3])\n",
                "        assert_equal(a.ravel(order='F'), [0, 2, 1, 3])\n",
                "        assert_equal(a.ravel(order='A'), [0, 1, 2, 3])\n",
                "        assert_(not a.ravel(order='A').flags.owndata)\n",
                "        assert_equal(a.ravel(order='K'), [0, 1, 2, 3])\n",
                "        assert_(not a.ravel(order='K').flags.owndata)\n",
                "        assert_equal(a.ravel(), a.reshape(-1))\n",
                "\n",
                "        a = np.array([[0, 1], [2, 3]], order='F')\n",
                "        assert_equal(a.ravel(), [0, 1, 2, 3])\n",
                "        assert_equal(a.ravel(order='A'), [0, 2, 1, 3])\n",
                "        assert_equal(a.ravel(order='K'), [0, 2, 1, 3])\n",
                "        assert_(not a.ravel(order='A').flags.owndata)\n",
                "        assert_(not a.ravel(order='K').flags.owndata)\n",
                "        assert_equal(a.ravel(), a.reshape(-1))\n",
                "        assert_equal(a.ravel(order='A'), a.reshape(-1, order='A'))\n",
                "\n",
                "        a = np.array([[0, 1], [2, 3]])[::-1, :]\n",
                "        assert_equal(a.ravel(), [2, 3, 0, 1])\n",
                "        assert_equal(a.ravel(order='C'), [2, 3, 0, 1])\n",
                "        assert_equal(a.ravel(order='F'), [2, 0, 3, 1])\n",
                "        assert_equal(a.ravel(order='A'), [2, 3, 0, 1])\n",
                "        # 'K' doesn't reverse the axes of negative strides\n",
                "        assert_equal(a.ravel(order='K'), [2, 3, 0, 1])\n",
                "        assert_(a.ravel(order='K').flags.owndata)\n",
                "\n",
                "        # Test simple 1-d copy behaviour:\n",
                "        a = np.arange(10)[::2]\n",
                "        assert_(a.ravel('K').flags.owndata)\n",
                "        assert_(a.ravel('C').flags.owndata)\n",
                "        assert_(a.ravel('F').flags.owndata)\n",
                "\n",
                "        # Not contiguous and 1-sized axis with non matching stride\n",
                "        a = np.arange(2**3 * 2)[::2]\n",
                "        a = a.reshape(2, 1, 2, 2).swapaxes(-1, -2)\n",
                "        strides = list(a.strides)\n",
                "        strides[1] = 123\n",
                "        a.strides = strides\n",
                "        assert_(a.ravel(order='K').flags.owndata)\n",
                "        assert_equal(a.ravel('K'), np.arange(0, 15, 2))\n",
                "\n",
                "        # contiguous and 1-sized axis with non matching stride works:\n",
                "        a = np.arange(2**3)\n",
                "        a = a.reshape(2, 1, 2, 2).swapaxes(-1, -2)\n",
                "        strides = list(a.strides)\n",
                "        strides[1] = 123\n",
                "        a.strides = strides\n",
                "        assert_(np.may_share_memory(a.ravel(order='K'), a))\n",
                "        assert_equal(a.ravel(order='K'), np.arange(2**3))\n",
                "\n",
                "        # Test negative strides (not very interesting since non-contiguous):\n",
                "        a = np.arange(4)[::-1].reshape(2, 2)\n",
                "        assert_(a.ravel(order='C').flags.owndata)\n",
                "        assert_(a.ravel(order='K').flags.owndata)\n",
                "        assert_equal(a.ravel('C'), [3, 2, 1, 0])\n",
                "        assert_equal(a.ravel('K'), [3, 2, 1, 0])\n",
                "\n",
                "        # 1-element tidy strides test (NPY_RELAXED_STRIDES_CHECKING):\n",
                "        a = np.array([[1]])\n",
                "        a.strides = (123, 432)\n",
                "        # If the stride is not 8, NPY_RELAXED_STRIDES_CHECKING is messing\n",
                "        # them up on purpose:\n",
                "        if np.ones(1).strides == (8,):\n",
                "            assert_(np.may_share_memory(a.ravel('K'), a))\n",
                "            assert_equal(a.ravel('K').strides, (a.dtype.itemsize,))\n",
                "\n",
                "        for order in ('C', 'F', 'A', 'K'):\n",
                "            # 0-d corner case:\n",
                "            a = np.array(0)\n",
                "            assert_equal(a.ravel(order), [0])\n",
                "            assert_(np.may_share_memory(a.ravel(order), a))\n",
                "\n",
                "        # Test that certain non-inplace ravels work right (mostly) for 'K':\n",
                "        b = np.arange(2**4 * 2)[::2].reshape(2, 2, 2, 2)\n",
                "        a = b[..., ::2]\n",
                "        assert_equal(a.ravel('K'), [0, 4, 8, 12, 16, 20, 24, 28])\n",
                "        assert_equal(a.ravel('C'), [0, 4, 8, 12, 16, 20, 24, 28])\n",
                "        assert_equal(a.ravel('A'), [0, 4, 8, 12, 16, 20, 24, 28])\n",
                "        assert_equal(a.ravel('F'), [0, 16, 8, 24, 4, 20, 12, 28])\n",
                "\n",
                "        a = b[::2, ...]\n",
                "        assert_equal(a.ravel('K'), [0, 2, 4, 6, 8, 10, 12, 14])\n",
                "        assert_equal(a.ravel('C'), [0, 2, 4, 6, 8, 10, 12, 14])\n",
                "        assert_equal(a.ravel('A'), [0, 2, 4, 6, 8, 10, 12, 14])\n",
                "        assert_equal(a.ravel('F'), [0, 8, 4, 12, 2, 10, 6, 14])\n",
                "\n",
                "    def test_ravel_subclass(self):\n",
                "        class ArraySubclass(np.ndarray):\n",
                "            pass\n",
                "\n",
                "        a = np.arange(10).view(ArraySubclass)\n",
                "        assert_(isinstance(a.ravel('C'), ArraySubclass))\n",
                "        assert_(isinstance(a.ravel('F'), ArraySubclass))\n",
                "        assert_(isinstance(a.ravel('A'), ArraySubclass))\n",
                "        assert_(isinstance(a.ravel('K'), ArraySubclass))\n",
                "\n",
                "        a = np.arange(10)[::2].view(ArraySubclass)\n",
                "        assert_(isinstance(a.ravel('C'), ArraySubclass))\n",
                "        assert_(isinstance(a.ravel('F'), ArraySubclass))\n",
                "        assert_(isinstance(a.ravel('A'), ArraySubclass))\n",
                "        assert_(isinstance(a.ravel('K'), ArraySubclass))\n",
                "\n",
                "    def test_swapaxes(self):\n",
                "        a = np.arange(1*2*3*4).reshape(1, 2, 3, 4).copy()\n",
                "        idx = np.indices(a.shape)\n",
                "        assert_(a.flags['OWNDATA'])\n",
                "        b = a.copy()\n",
                "        # check exceptions\n",
                "        assert_raises(ValueError, a.swapaxes, -5, 0)\n",
                "        assert_raises(ValueError, a.swapaxes, 4, 0)\n",
                "        assert_raises(ValueError, a.swapaxes, 0, -5)\n",
                "        assert_raises(ValueError, a.swapaxes, 0, 4)\n",
                "\n",
                "        for i in range(-4, 4):\n",
                "            for j in range(-4, 4):\n",
                "                for k, src in enumerate((a, b)):\n",
                "                    c = src.swapaxes(i, j)\n",
                "                    # check shape\n",
                "                    shape = list(src.shape)\n",
                "                    shape[i] = src.shape[j]\n",
                "                    shape[j] = src.shape[i]\n",
                "                    assert_equal(c.shape, shape, str((i, j, k)))\n",
                "                    # check array contents\n",
                "                    i0, i1, i2, i3 = [dim-1 for dim in c.shape]\n",
                "                    j0, j1, j2, j3 = [dim-1 for dim in src.shape]\n",
                "                    assert_equal(src[idx[j0], idx[j1], idx[j2], idx[j3]],\n",
                "                                 c[idx[i0], idx[i1], idx[i2], idx[i3]],\n",
                "                                 str((i, j, k)))\n",
                "                    # check a view is always returned, gh-5260\n",
                "                    assert_(not c.flags['OWNDATA'], str((i, j, k)))\n",
                "                    # check on non-contiguous input array\n",
                "                    if k == 1:\n",
                "                        b = c\n",
                "\n",
                "    def test_conjugate(self):\n",
                "        a = np.array([1-1j, 1+1j, 23+23.0j])\n",
                "        ac = a.conj()\n",
                "        assert_equal(a.real, ac.real)\n",
                "        assert_equal(a.imag, -ac.imag)\n",
                "        assert_equal(ac, a.conjugate())\n",
                "        assert_equal(ac, np.conjugate(a))\n",
                "\n",
                "        a = np.array([1-1j, 1+1j, 23+23.0j], 'F')\n",
                "        ac = a.conj()\n",
                "        assert_equal(a.real, ac.real)\n",
                "        assert_equal(a.imag, -ac.imag)\n",
                "        assert_equal(ac, a.conjugate())\n",
                "        assert_equal(ac, np.conjugate(a))\n",
                "\n",
                "        a = np.array([1, 2, 3])\n",
                "        ac = a.conj()\n",
                "        assert_equal(a, ac)\n",
                "        assert_equal(ac, a.conjugate())\n",
                "        assert_equal(ac, np.conjugate(a))\n",
                "\n",
                "        a = np.array([1.0, 2.0, 3.0])\n",
                "        ac = a.conj()\n",
                "        assert_equal(a, ac)\n",
                "        assert_equal(ac, a.conjugate())\n",
                "        assert_equal(ac, np.conjugate(a))\n",
                "\n",
                "        a = np.array([1-1j, 1+1j, 1, 2.0], object)\n",
                "        ac = a.conj()\n",
                "        assert_equal(ac, [k.conjugate() for k in a])\n",
                "        assert_equal(ac, a.conjugate())\n",
                "        assert_equal(ac, np.conjugate(a))\n",
                "\n",
                "        a = np.array([1-1j, 1, 2.0, 'f'], object)\n",
                "        assert_raises(AttributeError, lambda: a.conj())\n",
                "        assert_raises(AttributeError, lambda: a.conjugate())\n",
                "\n",
                "    def test__complex__(self):\n",
                "        dtypes = ['i1', 'i2', 'i4', 'i8',\n",
                "                  'u1', 'u2', 'u4', 'u8',\n",
                "                  'f', 'd', 'g', 'F', 'D', 'G',\n",
                "                  '?', 'O']\n",
                "        for dt in dtypes:\n",
                "            a = np.array(7, dtype=dt)\n",
                "            b = np.array([7], dtype=dt)\n",
                "            c = np.array([[[[[7]]]]], dtype=dt)\n",
                "\n",
                "            msg = 'dtype: {0}'.format(dt)\n",
                "            ap = complex(a)\n",
                "            assert_equal(ap, a, msg)\n",
                "            bp = complex(b)\n",
                "            assert_equal(bp, b, msg)\n",
                "            cp = complex(c)\n",
                "            assert_equal(cp, c, msg)\n",
                "\n",
                "    def test__complex__should_not_work(self):\n",
                "        dtypes = ['i1', 'i2', 'i4', 'i8',\n",
                "                  'u1', 'u2', 'u4', 'u8',\n",
                "                  'f', 'd', 'g', 'F', 'D', 'G',\n",
                "                  '?', 'O']\n",
                "        for dt in dtypes:\n",
                "            a = np.array([1, 2, 3], dtype=dt)\n",
                "            assert_raises(TypeError, complex, a)\n",
                "\n",
                "        dt = np.dtype([('a', 'f8'), ('b', 'i1')])\n",
                "        b = np.array((1.0, 3), dtype=dt)\n",
                "        assert_raises(TypeError, complex, b)\n",
                "\n",
                "        c = np.array([(1.0, 3), (2e-3, 7)], dtype=dt)\n",
                "        assert_raises(TypeError, complex, c)\n",
                "\n",
                "        d = np.array('1+1j')\n",
                "        assert_raises(TypeError, complex, d)\n",
                "\n",
                "        e = np.array(['1+1j'], 'U')\n",
                "        assert_raises(TypeError, complex, e)\n",
                "\n",
                "\n",
                "class TestBinop(object):\n",
                "    def test_inplace(self):\n",
                "        # test refcount 1 inplace conversion\n",
                "        assert_array_almost_equal(np.array([0.5]) * np.array([1.0, 2.0]),\n",
                "                                  [0.5, 1.0])\n",
                "\n",
                "        d = np.array([0.5, 0.5])[::2]\n",
                "        assert_array_almost_equal(d * (d * np.array([1.0, 2.0])),\n",
                "                                  [0.25, 0.5])\n",
                "\n",
                "        a = np.array([0.5])\n",
                "        b = np.array([0.5])\n",
                "        c = a + b\n",
                "        c = a - b\n",
                "        c = a * b\n",
                "        c = a / b\n",
                "        assert_equal(a, b)\n",
                "        assert_almost_equal(c, 1.)\n",
                "\n",
                "        c = a + b * 2. / b * a - a / b\n",
                "        assert_equal(a, b)\n",
                "        assert_equal(c, 0.5)\n",
                "\n",
                "        # true divide\n",
                "        a = np.array([5])\n",
                "        b = np.array([3])\n",
                "        c = (a * a) / b\n",
                "\n",
                "        assert_almost_equal(c, 25 / 3)\n",
                "        assert_equal(a, 5)\n",
                "        assert_equal(b, 3)\n",
                "\n",
                "    def test_extension_incref_elide(self):\n",
                "        # test extension (e.g. cython) calling PyNumber_* slots without\n",
                "        # increasing the reference counts\n",
                "        #\n",
                "        # def incref_elide(a):\n",
                "        #    d = input.copy() # refcount 1\n",
                "        #    return d, d + d # PyNumber_Add without increasing refcount\n",
                "        from numpy.core.multiarray_tests import incref_elide\n",
                "        d = np.ones(100000)\n",
                "        orig, res = incref_elide(d)\n",
                "        d + d\n",
                "        # the return original should not be changed to an inplace operation\n",
                "        assert_array_equal(orig, d)\n",
                "        assert_array_equal(res, d + d)\n",
                "\n",
                "    def test_extension_incref_elide_stack(self):\n",
                "        # scanning if the refcount == 1 object is on the python stack to check\n",
                "        # that we are called directly from python is flawed as object may still\n",
                "        # be above the stack pointer and we have no access to the top of it\n",
                "        #\n",
                "        # def incref_elide_l(d):\n",
                "        #    return l[4] + l[4] # PyNumber_Add without increasing refcount\n",
                "        from numpy.core.multiarray_tests import incref_elide_l\n",
                "        # padding with 1 makes sure the object on the stack is not overwriten\n",
                "        l = [1, 1, 1, 1, np.ones(100000)]\n",
                "        res = incref_elide_l(l)\n",
                "        # the return original should not be changed to an inplace operation\n",
                "        assert_array_equal(l[4], np.ones(100000))\n",
                "        assert_array_equal(res, l[4] + l[4])\n",
                "\n",
                "    def test_temporary_with_cast(self):\n",
                "        # check that we don't elide into a temporary which would need casting\n",
                "        d = np.ones(200000, dtype=np.int64)\n",
                "        assert_equal(((d + d) + 2**222).dtype, np.dtype('O'))\n",
                "\n",
                "        r = ((d + d) / 2)\n",
                "        assert_equal(r.dtype, np.dtype('f8'))\n",
                "\n",
                "        r = np.true_divide((d + d), 2)\n",
                "        assert_equal(r.dtype, np.dtype('f8'))\n",
                "\n",
                "        r = ((d + d) / 2.)\n",
                "        assert_equal(r.dtype, np.dtype('f8'))\n",
                "\n",
                "        r = ((d + d) // 2)\n",
                "        assert_equal(r.dtype, np.dtype(np.int64))\n",
                "\n",
                "        # commutative elision into the astype result\n",
                "        f = np.ones(100000, dtype=np.float32)\n",
                "        assert_equal(((f + f) + f.astype(np.float64)).dtype, np.dtype('f8'))\n",
                "\n",
                "        # no elision into f + f\n",
                "        d = f.astype(np.float64)\n",
                "        assert_equal(((f + f) + d).dtype, np.dtype('f8'))\n",
                "\n",
                "    def test_elide_broadcast(self):\n",
                "        # test no elision on broadcast to higher dimension\n",
                "        # only triggers elision code path in debug mode as triggering it in\n",
                "        # normal mode needs 256kb large matching dimension, so a lot of memory\n",
                "        d = np.ones((2000, 1), dtype=int)\n",
                "        b = np.ones((2000), dtype=np.bool)\n",
                "        r = (1 - d) + b\n",
                "        assert_equal(r, 1)\n",
                "        assert_equal(r.shape, (2000, 2000))\n",
                "\n",
                "    def test_elide_scalar(self):\n",
                "        # check inplace op does not create ndarray from scalars\n",
                "        a = np.bool_()\n",
                "        assert_(type(~(a & a)) is np.bool_)\n",
                "\n",
                "    # ndarray.__rop__ always calls ufunc\n",
                "    # ndarray.__iop__ always calls ufunc\n",
                "    # ndarray.__op__, __rop__:\n",
                "    #   - defer if other has __array_ufunc__ and it is None\n",
                "    #           or other is not a subclass and has higher array priority\n",
                "    #   - else, call ufunc\n",
                "    def test_ufunc_binop_interaction(self):\n",
                "        # Python method name (without underscores)\n",
                "        #   -> (numpy ufunc, has_in_place_version, preferred_dtype)\n",
                "        ops = {\n",
                "            'add':      (np.add, True, float),\n",
                "            'sub':      (np.subtract, True, float),\n",
                "            'mul':      (np.multiply, True, float),\n",
                "            'truediv':  (np.true_divide, True, float),\n",
                "            'floordiv': (np.floor_divide, True, float),\n",
                "            'mod':      (np.remainder, True, float),\n",
                "            'divmod':   (np.divmod, False, float),\n",
                "            'pow':      (np.power, True, int),\n",
                "            'lshift':   (np.left_shift, True, int),\n",
                "            'rshift':   (np.right_shift, True, int),\n",
                "            'and':      (np.bitwise_and, True, int),\n",
                "            'xor':      (np.bitwise_xor, True, int),\n",
                "            'or':       (np.bitwise_or, True, int),\n",
                "            # 'ge':       (np.less_equal, False),\n",
                "            # 'gt':       (np.less, False),\n",
                "            # 'le':       (np.greater_equal, False),\n",
                "            # 'lt':       (np.greater, False),\n",
                "            # 'eq':       (np.equal, False),\n",
                "            # 'ne':       (np.not_equal, False),\n",
                "        }\n",
                "\n",
                "        class Coerced(Exception):\n",
                "            pass\n",
                "\n",
                "        def array_impl(self):\n",
                "            raise Coerced\n",
                "\n",
                "        def op_impl(self, other):\n",
                "            return \"forward\"\n",
                "\n",
                "        def rop_impl(self, other):\n",
                "            return \"reverse\"\n",
                "\n",
                "        def iop_impl(self, other):\n",
                "            return \"in-place\"\n",
                "\n",
                "        def array_ufunc_impl(self, ufunc, method, *args, **kwargs):\n",
                "            return (\"__array_ufunc__\", ufunc, method, args, kwargs)\n",
                "\n",
                "        # Create an object with the given base, in the given module, with a\n",
                "        # bunch of placeholder __op__ methods, and optionally a\n",
                "        # __array_ufunc__ and __array_priority__.\n",
                "        def make_obj(base, array_priority=False, array_ufunc=False,\n",
                "                     alleged_module=\"__main__\"):\n",
                "            class_namespace = {\"__array__\": array_impl}\n",
                "            if array_priority is not False:\n",
                "                class_namespace[\"__array_priority__\"] = array_priority\n",
                "            for op in ops:\n",
                "                class_namespace[\"__{0}__\".format(op)] = op_impl\n",
                "                class_namespace[\"__r{0}__\".format(op)] = rop_impl\n",
                "                class_namespace[\"__i{0}__\".format(op)] = iop_impl\n",
                "            if array_ufunc is not False:\n",
                "                class_namespace[\"__array_ufunc__\"] = array_ufunc\n",
                "            eval_namespace = {\"base\": base,\n",
                "                              \"class_namespace\": class_namespace,\n",
                "                              \"__name__\": alleged_module,\n",
                "                              }\n",
                "            MyType = eval(\"type('MyType', (base,), class_namespace)\",\n",
                "                          eval_namespace)\n",
                "            if issubclass(MyType, np.ndarray):\n",
                "                # Use this range to avoid special case weirdnesses around\n",
                "                # divide-by-0, pow(x, 2), overflow due to pow(big, big), etc.\n",
                "                return np.arange(3, 5).view(MyType)\n",
                "            else:\n",
                "                return MyType()\n",
                "\n",
                "        def check(obj, binop_override_expected, ufunc_override_expected,\n",
                "                  inplace_override_expected, check_scalar=True):\n",
                "            for op, (ufunc, has_inplace, dtype) in ops.items():\n",
                "                err_msg = ('op: %s, ufunc: %s, has_inplace: %s, dtype: %s'\n",
                "                           % (op, ufunc, has_inplace, dtype))\n",
                "                check_objs = [np.arange(3, 5, dtype=dtype)]\n",
                "                if check_scalar:\n",
                "                    check_objs.append(check_objs[0][0])\n",
                "                for arr in check_objs:\n",
                "                    arr_method = getattr(arr, \"__{0}__\".format(op))\n",
                "\n",
                "                    def first_out_arg(result):\n",
                "                        if op == \"divmod\":\n",
                "                            assert_(isinstance(result, tuple))\n",
                "                            return result[0]\n",
                "                        else:\n",
                "                            return result\n",
                "\n",
                "                    # arr __op__ obj\n",
                "                    if binop_override_expected:\n",
                "                        assert_equal(arr_method(obj), NotImplemented, err_msg)\n",
                "                    elif ufunc_override_expected:\n",
                "                        assert_equal(arr_method(obj)[0], \"__array_ufunc__\",\n",
                "                                     err_msg)\n",
                "                    else:\n",
                "                        if (isinstance(obj, np.ndarray) and\n",
                "                            (type(obj).__array_ufunc__ is\n",
                "                             np.ndarray.__array_ufunc__)):\n",
                "                            # __array__ gets ignored\n",
                "                            res = first_out_arg(arr_method(obj))\n",
                "                            assert_(res.__class__ is obj.__class__, err_msg)\n",
                "                        else:\n",
                "                            assert_raises((TypeError, Coerced),\n",
                "                                          arr_method, obj, err_msg=err_msg)\n",
                "                    # obj __op__ arr\n",
                "                    arr_rmethod = getattr(arr, \"__r{0}__\".format(op))\n",
                "                    if ufunc_override_expected:\n",
                "                        res = arr_rmethod(obj)\n",
                "                        assert_equal(res[0], \"__array_ufunc__\",\n",
                "                                     err_msg=err_msg)\n",
                "                        assert_equal(res[1], ufunc, err_msg=err_msg)\n",
                "                    else:\n",
                "                        if (isinstance(obj, np.ndarray) and\n",
                "                                (type(obj).__array_ufunc__ is\n",
                "                                 np.ndarray.__array_ufunc__)):\n",
                "                            # __array__ gets ignored\n",
                "                            res = first_out_arg(arr_rmethod(obj))\n",
                "                            assert_(res.__class__ is obj.__class__, err_msg)\n",
                "                        else:\n",
                "                            # __array_ufunc__ = \"asdf\" creates a TypeError\n",
                "                            assert_raises((TypeError, Coerced),\n",
                "                                          arr_rmethod, obj, err_msg=err_msg)\n",
                "\n",
                "                    # arr __iop__ obj\n",
                "                    # array scalars don't have in-place operators\n",
                "                    if has_inplace and isinstance(arr, np.ndarray):\n",
                "                        arr_imethod = getattr(arr, \"__i{0}__\".format(op))\n",
                "                        if inplace_override_expected:\n",
                "                            assert_equal(arr_method(obj), NotImplemented,\n",
                "                                         err_msg=err_msg)\n",
                "                        elif ufunc_override_expected:\n",
                "                            res = arr_imethod(obj)\n",
                "                            assert_equal(res[0], \"__array_ufunc__\", err_msg)\n",
                "                            assert_equal(res[1], ufunc, err_msg)\n",
                "                            assert_(type(res[-1][\"out\"]) is tuple, err_msg)\n",
                "                            assert_(res[-1][\"out\"][0] is arr, err_msg)\n",
                "                        else:\n",
                "                            if (isinstance(obj, np.ndarray) and\n",
                "                                    (type(obj).__array_ufunc__ is\n",
                "                                    np.ndarray.__array_ufunc__)):\n",
                "                                # __array__ gets ignored\n",
                "                                assert_(arr_imethod(obj) is arr, err_msg)\n",
                "                            else:\n",
                "                                assert_raises((TypeError, Coerced),\n",
                "                                              arr_imethod, obj,\n",
                "                                              err_msg=err_msg)\n",
                "\n",
                "                    op_fn = getattr(operator, op, None)\n",
                "                    if op_fn is None:\n",
                "                        op_fn = getattr(operator, op + \"_\", None)\n",
                "                    if op_fn is None:\n",
                "                        op_fn = getattr(builtins, op)\n",
                "                    assert_equal(op_fn(obj, arr), \"forward\", err_msg)\n",
                "                    if not isinstance(obj, np.ndarray):\n",
                "                        if binop_override_expected:\n",
                "                            assert_equal(op_fn(arr, obj), \"reverse\", err_msg)\n",
                "                        elif ufunc_override_expected:\n",
                "                            assert_equal(op_fn(arr, obj)[0], \"__array_ufunc__\",\n",
                "                                         err_msg)\n",
                "                    if ufunc_override_expected:\n",
                "                        assert_equal(ufunc(obj, arr)[0], \"__array_ufunc__\",\n",
                "                                     err_msg)\n",
                "\n",
                "        # No array priority, no array_ufunc -> nothing called\n",
                "        check(make_obj(object), False, False, False)\n",
                "        # Negative array priority, no array_ufunc -> nothing called\n",
                "        # (has to be very negative, because scalar priority is -1000000.0)\n",
                "        check(make_obj(object, array_priority=-2**30), False, False, False)\n",
                "        # Positive array priority, no array_ufunc -> binops and iops only\n",
                "        check(make_obj(object, array_priority=1), True, False, True)\n",
                "        # ndarray ignores array_priority for ndarray subclasses\n",
                "        check(make_obj(np.ndarray, array_priority=1), False, False, False,\n",
                "              check_scalar=False)\n",
                "        # Positive array_priority and array_ufunc -> array_ufunc only\n",
                "        check(make_obj(object, array_priority=1,\n",
                "                       array_ufunc=array_ufunc_impl), False, True, False)\n",
                "        check(make_obj(np.ndarray, array_priority=1,\n",
                "                       array_ufunc=array_ufunc_impl), False, True, False)\n",
                "        # array_ufunc set to None -> defer binops only\n",
                "        check(make_obj(object, array_ufunc=None), True, False, False)\n",
                "        check(make_obj(np.ndarray, array_ufunc=None), True, False, False,\n",
                "              check_scalar=False)\n",
                "\n",
                "    def test_ufunc_override_normalize_signature(self):\n",
                "        # gh-5674\n",
                "        class SomeClass(object):\n",
                "            def __array_ufunc__(self, ufunc, method, *inputs, **kw):\n",
                "                return kw\n",
                "\n",
                "        a = SomeClass()\n",
                "        kw = np.add(a, [1])\n",
                "        assert_('sig' not in kw and 'signature' not in kw)\n",
                "        kw = np.add(a, [1], sig='ii->i')\n",
                "        assert_('sig' not in kw and 'signature' in kw)\n",
                "        assert_equal(kw['signature'], 'ii->i')\n",
                "        kw = np.add(a, [1], signature='ii->i')\n",
                "        assert_('sig' not in kw and 'signature' in kw)\n",
                "        assert_equal(kw['signature'], 'ii->i')\n",
                "\n",
                "    def test_array_ufunc_index(self):\n",
                "        # Check that index is set appropriately, also if only an output\n",
                "        # is passed on (latter is another regression tests for github bug 4753)\n",
                "        # This also checks implicitly that 'out' is always a tuple.\n",
                "        class CheckIndex(object):\n",
                "            def __array_ufunc__(self, ufunc, method, *inputs, **kw):\n",
                "                for i, a in enumerate(inputs):\n",
                "                    if a is self:\n",
                "                        return i\n",
                "                # calls below mean we must be in an output.\n",
                "                for j, a in enumerate(kw['out']):\n",
                "                    if a is self:\n",
                "                        return (j,)\n",
                "\n",
                "        a = CheckIndex()\n",
                "        dummy = np.arange(2.)\n",
                "        # 1 input, 1 output\n",
                "        assert_equal(np.sin(a), 0)\n",
                "        assert_equal(np.sin(dummy, a), (0,))\n",
                "        assert_equal(np.sin(dummy, out=a), (0,))\n",
                "        assert_equal(np.sin(dummy, out=(a,)), (0,))\n",
                "        assert_equal(np.sin(a, a), 0)\n",
                "        assert_equal(np.sin(a, out=a), 0)\n",
                "        assert_equal(np.sin(a, out=(a,)), 0)\n",
                "        # 1 input, 2 outputs\n",
                "        assert_equal(np.modf(dummy, a), (0,))\n",
                "        assert_equal(np.modf(dummy, None, a), (1,))\n",
                "        assert_equal(np.modf(dummy, dummy, a), (1,))\n",
                "        assert_equal(np.modf(dummy, out=(a, None)), (0,))\n",
                "        assert_equal(np.modf(dummy, out=(a, dummy)), (0,))\n",
                "        assert_equal(np.modf(dummy, out=(None, a)), (1,))\n",
                "        assert_equal(np.modf(dummy, out=(dummy, a)), (1,))\n",
                "        assert_equal(np.modf(a, out=(dummy, a)), 0)\n",
                "        with warnings.catch_warnings(record=True) as w:\n",
                "            warnings.filterwarnings('always', '', DeprecationWarning)\n",
                "            assert_equal(np.modf(dummy, out=a), (0,))\n",
                "            assert_(w[0].category is DeprecationWarning)\n",
                "        assert_raises(TypeError, np.modf, dummy, out=(a,))\n",
                "\n",
                "        # 2 inputs, 1 output\n",
                "        assert_equal(np.add(a, dummy), 0)\n",
                "        assert_equal(np.add(dummy, a), 1)\n",
                "        assert_equal(np.add(dummy, dummy, a), (0,))\n",
                "        assert_equal(np.add(dummy, a, a), 1)\n",
                "        assert_equal(np.add(dummy, dummy, out=a), (0,))\n",
                "        assert_equal(np.add(dummy, dummy, out=(a,)), (0,))\n",
                "        assert_equal(np.add(a, dummy, out=a), 0)\n",
                "\n",
                "    def test_out_override(self):\n",
                "        # regression test for github bug 4753\n",
                "        class OutClass(np.ndarray):\n",
                "            def __array_ufunc__(self, ufunc, method, *inputs, **kw):\n",
                "                if 'out' in kw:\n",
                "                    tmp_kw = kw.copy()\n",
                "                    tmp_kw.pop('out')\n",
                "                    func = getattr(ufunc, method)\n",
                "                    kw['out'][0][...] = func(*inputs, **tmp_kw)\n",
                "\n",
                "        A = np.array([0]).view(OutClass)\n",
                "        B = np.array([5])\n",
                "        C = np.array([6])\n",
                "        np.multiply(C, B, A)\n",
                "        assert_equal(A[0], 30)\n",
                "        assert_(isinstance(A, OutClass))\n",
                "        A[0] = 0\n",
                "        np.multiply(C, B, out=A)\n",
                "        assert_equal(A[0], 30)\n",
                "        assert_(isinstance(A, OutClass))\n",
                "\n",
                "\n",
                "class TestCAPI(TestCase):\n",
                "    def test_IsPythonScalar(self):\n",
                "        from numpy.core.multiarray_tests import IsPythonScalar\n",
                "        assert_(IsPythonScalar(b'foobar'))\n",
                "        assert_(IsPythonScalar(1))\n",
                "        assert_(IsPythonScalar(2**80))\n",
                "        assert_(IsPythonScalar(2.))\n",
                "        assert_(IsPythonScalar(\"a\"))\n",
                "\n",
                "\n",
                "class TestSubscripting(TestCase):\n",
                "    def test_test_zero_rank(self):\n",
                "        x = np.array([1, 2, 3])\n",
                "        self.assertTrue(isinstance(x[0], np.int_))\n",
                "        if sys.version_info[0] < 3:\n",
                "            self.assertTrue(isinstance(x[0], int))\n",
                "        self.assertTrue(type(x[0, ...]) is np.ndarray)\n",
                "\n",
                "\n",
                "class TestPickling(TestCase):\n",
                "    def test_roundtrip(self):\n",
                "        import pickle\n",
                "        carray = np.array([[2, 9], [7, 0], [3, 8]])\n",
                "        DATA = [\n",
                "            carray,\n",
                "            np.transpose(carray),\n",
                "            np.array([('xxx', 1, 2.0)], dtype=[('a', (str, 3)), ('b', int),\n",
                "                                               ('c', float)])\n",
                "        ]\n",
                "\n",
                "        for a in DATA:\n",
                "            assert_equal(a, pickle.loads(a.dumps()), err_msg=\"%r\" % a)\n",
                "\n",
                "    def _loads(self, obj):\n",
                "        if sys.version_info[0] >= 3:\n",
                "            return np.loads(obj, encoding='latin1')\n",
                "        else:\n",
                "            return np.loads(obj)\n",
                "\n",
                "    # version 0 pickles, using protocol=2 to pickle\n",
                "    # version 0 doesn't have a version field\n",
                "    def test_version0_int8(self):\n",
                "        s = b'\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02i1K\\x00K\\x01\\x87Rq\\x05(U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x04\\x01\\x02\\x03\\x04tb.'\n",
                "        a = np.array([1, 2, 3, 4], dtype=np.int8)\n",
                "        p = self._loads(s)\n",
                "        assert_equal(a, p)\n",
                "\n",
                "    def test_version0_float32(self):\n",
                "        s = b'\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02f4K\\x00K\\x01\\x87Rq\\x05(U\\x01<NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x10\\x00\\x00\\x80?\\x00\\x00\\x00@\\x00\\x00@@\\x00\\x00\\x80@tb.'\n",
                "        a = np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float32)\n",
                "        p = self._loads(s)\n",
                "        assert_equal(a, p)\n",
                "\n",
                "    def test_version0_object(self):\n",
                "        s = b'\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x02\\x85cnumpy\\ndtype\\nq\\x04U\\x02O8K\\x00K\\x01\\x87Rq\\x05(U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89]q\\x06(}q\\x07U\\x01aK\\x01s}q\\x08U\\x01bK\\x02setb.'\n",
                "        a = np.array([{'a': 1}, {'b': 2}])\n",
                "        p = self._loads(s)\n",
                "        assert_equal(a, p)\n",
                "\n",
                "    # version 1 pickles, using protocol=2 to pickle\n",
                "    def test_version1_int8(self):\n",
                "        s = b'\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x01K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02i1K\\x00K\\x01\\x87Rq\\x05(K\\x01U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x04\\x01\\x02\\x03\\x04tb.'\n",
                "        a = np.array([1, 2, 3, 4], dtype=np.int8)\n",
                "        p = self._loads(s)\n",
                "        assert_equal(a, p)\n",
                "\n",
                "    def test_version1_float32(self):\n",
                "        s = b'\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x01K\\x04\\x85cnumpy\\ndtype\\nq\\x04U\\x02f4K\\x00K\\x01\\x87Rq\\x05(K\\x01U\\x01<NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89U\\x10\\x00\\x00\\x80?\\x00\\x00\\x00@\\x00\\x00@@\\x00\\x00\\x80@tb.'\n",
                "        a = np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float32)\n",
                "        p = self._loads(s)\n",
                "        assert_equal(a, p)\n",
                "\n",
                "    def test_version1_object(self):\n",
                "        s = b'\\x80\\x02cnumpy.core._internal\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x01K\\x02\\x85cnumpy\\ndtype\\nq\\x04U\\x02O8K\\x00K\\x01\\x87Rq\\x05(K\\x01U\\x01|NNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xfftb\\x89]q\\x06(}q\\x07U\\x01aK\\x01s}q\\x08U\\x01bK\\x02setb.'\n",
                "        a = np.array([{'a': 1}, {'b': 2}])\n",
                "        p = self._loads(s)\n",
                "        assert_equal(a, p)\n",
                "\n",
                "    def test_subarray_int_shape(self):\n",
                "        s = b\"cnumpy.core.multiarray\\n_reconstruct\\np0\\n(cnumpy\\nndarray\\np1\\n(I0\\ntp2\\nS'b'\\np3\\ntp4\\nRp5\\n(I1\\n(I1\\ntp6\\ncnumpy\\ndtype\\np7\\n(S'V6'\\np8\\nI0\\nI1\\ntp9\\nRp10\\n(I3\\nS'|'\\np11\\nN(S'a'\\np12\\ng3\\ntp13\\n(dp14\\ng12\\n(g7\\n(S'V4'\\np15\\nI0\\nI1\\ntp16\\nRp17\\n(I3\\nS'|'\\np18\\n(g7\\n(S'i1'\\np19\\nI0\\nI1\\ntp20\\nRp21\\n(I3\\nS'|'\\np22\\nNNNI-1\\nI-1\\nI0\\ntp23\\nb(I2\\nI2\\ntp24\\ntp25\\nNNI4\\nI1\\nI0\\ntp26\\nbI0\\ntp27\\nsg3\\n(g7\\n(S'V2'\\np28\\nI0\\nI1\\ntp29\\nRp30\\n(I3\\nS'|'\\np31\\n(g21\\nI2\\ntp32\\nNNI2\\nI1\\nI0\\ntp33\\nbI4\\ntp34\\nsI6\\nI1\\nI0\\ntp35\\nbI00\\nS'\\\\x01\\\\x01\\\\x01\\\\x01\\\\x01\\\\x02'\\np36\\ntp37\\nb.\"\n",
                "        a = np.array([(1, (1, 2))], dtype=[('a', 'i1', (2, 2)), ('b', 'i1', 2)])\n",
                "        p = self._loads(s)\n",
                "        assert_equal(a, p)\n",
                "\n",
                "\n",
                "class TestFancyIndexing(TestCase):\n",
                "    def test_list(self):\n",
                "        x = np.ones((1, 1))\n",
                "        x[:, [0]] = 2.0\n",
                "        assert_array_equal(x, np.array([[2.0]]))\n",
                "\n",
                "        x = np.ones((1, 1, 1))\n",
                "        x[:, :, [0]] = 2.0\n",
                "        assert_array_equal(x, np.array([[[2.0]]]))\n",
                "\n",
                "    def test_tuple(self):\n",
                "        x = np.ones((1, 1))\n",
                "        x[:, (0,)] = 2.0\n",
                "        assert_array_equal(x, np.array([[2.0]]))\n",
                "        x = np.ones((1, 1, 1))\n",
                "        x[:, :, (0,)] = 2.0\n",
                "        assert_array_equal(x, np.array([[[2.0]]]))\n",
                "\n",
                "    def test_mask(self):\n",
                "        x = np.array([1, 2, 3, 4])\n",
                "        m = np.array([0, 1, 0, 0], bool)\n",
                "        assert_array_equal(x[m], np.array([2]))\n",
                "\n",
                "    def test_mask2(self):\n",
                "        x = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\n",
                "        m = np.array([0, 1], bool)\n",
                "        m2 = np.array([[0, 1, 0, 0], [1, 0, 0, 0]], bool)\n",
                "        m3 = np.array([[0, 1, 0, 0], [0, 0, 0, 0]], bool)\n",
                "        assert_array_equal(x[m], np.array([[5, 6, 7, 8]]))\n",
                "        assert_array_equal(x[m2], np.array([2, 5]))\n",
                "        assert_array_equal(x[m3], np.array([2]))\n",
                "\n",
                "    def test_assign_mask(self):\n",
                "        x = np.array([1, 2, 3, 4])\n",
                "        m = np.array([0, 1, 0, 0], bool)\n",
                "        x[m] = 5\n",
                "        assert_array_equal(x, np.array([1, 5, 3, 4]))\n",
                "\n",
                "    def test_assign_mask2(self):\n",
                "        xorig = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\n",
                "        m = np.array([0, 1], bool)\n",
                "        m2 = np.array([[0, 1, 0, 0], [1, 0, 0, 0]], bool)\n",
                "        m3 = np.array([[0, 1, 0, 0], [0, 0, 0, 0]], bool)\n",
                "        x = xorig.copy()\n",
                "        x[m] = 10\n",
                "        assert_array_equal(x, np.array([[1, 2, 3, 4], [10, 10, 10, 10]]))\n",
                "        x = xorig.copy()\n",
                "        x[m2] = 10\n",
                "        assert_array_equal(x, np.array([[1, 10, 3, 4], [10, 6, 7, 8]]))\n",
                "        x = xorig.copy()\n",
                "        x[m3] = 10\n",
                "        assert_array_equal(x, np.array([[1, 10, 3, 4], [5, 6, 7, 8]]))\n",
                "\n",
                "\n",
                "class TestStringCompare(TestCase):\n",
                "    def test_string(self):\n",
                "        g1 = np.array([\"This\", \"is\", \"example\"])\n",
                "        g2 = np.array([\"This\", \"was\", \"example\"])\n",
                "        assert_array_equal(g1 == g2, [g1[i] == g2[i] for i in [0, 1, 2]])\n",
                "        assert_array_equal(g1 != g2, [g1[i] != g2[i] for i in [0, 1, 2]])\n",
                "        assert_array_equal(g1 <= g2, [g1[i] <= g2[i] for i in [0, 1, 2]])\n",
                "        assert_array_equal(g1 >= g2, [g1[i] >= g2[i] for i in [0, 1, 2]])\n",
                "        assert_array_equal(g1 < g2, [g1[i] < g2[i] for i in [0, 1, 2]])\n",
                "        assert_array_equal(g1 > g2, [g1[i] > g2[i] for i in [0, 1, 2]])\n",
                "\n",
                "    def test_mixed(self):\n",
                "        g1 = np.array([\"spam\", \"spa\", \"spammer\", \"and eggs\"])\n",
                "        g2 = \"spam\"\n",
                "        assert_array_equal(g1 == g2, [x == g2 for x in g1])\n",
                "        assert_array_equal(g1 != g2, [x != g2 for x in g1])\n",
                "        assert_array_equal(g1 < g2, [x < g2 for x in g1])\n",
                "        assert_array_equal(g1 > g2, [x > g2 for x in g1])\n",
                "        assert_array_equal(g1 <= g2, [x <= g2 for x in g1])\n",
                "        assert_array_equal(g1 >= g2, [x >= g2 for x in g1])\n",
                "\n",
                "    def test_unicode(self):\n",
                "        g1 = np.array([u\"This\", u\"is\", u\"example\"])\n",
                "        g2 = np.array([u\"This\", u\"was\", u\"example\"])\n",
                "        assert_array_equal(g1 == g2, [g1[i] == g2[i] for i in [0, 1, 2]])\n",
                "        assert_array_equal(g1 != g2, [g1[i] != g2[i] for i in [0, 1, 2]])\n",
                "        assert_array_equal(g1 <= g2, [g1[i] <= g2[i] for i in [0, 1, 2]])\n",
                "        assert_array_equal(g1 >= g2, [g1[i] >= g2[i] for i in [0, 1, 2]])\n",
                "        assert_array_equal(g1 < g2,  [g1[i] < g2[i] for i in [0, 1, 2]])\n",
                "        assert_array_equal(g1 > g2,  [g1[i] > g2[i] for i in [0, 1, 2]])\n",
                "\n",
                "\n",
                "class TestArgmax(TestCase):\n",
                "\n",
                "    nan_arr = [\n",
                "        ([0, 1, 2, 3, np.nan], 4),\n",
                "        ([0, 1, 2, np.nan, 3], 3),\n",
                "        ([np.nan, 0, 1, 2, 3], 0),\n",
                "        ([np.nan, 0, np.nan, 2, 3], 0),\n",
                "        ([0, 1, 2, 3, complex(0, np.nan)], 4),\n",
                "        ([0, 1, 2, 3, complex(np.nan, 0)], 4),\n",
                "        ([0, 1, 2, complex(np.nan, 0), 3], 3),\n",
                "        ([0, 1, 2, complex(0, np.nan), 3], 3),\n",
                "        ([complex(0, np.nan), 0, 1, 2, 3], 0),\n",
                "        ([complex(np.nan, np.nan), 0, 1, 2, 3], 0),\n",
                "        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, 1)], 0),\n",
                "        ([complex(np.nan, np.nan), complex(np.nan, 2), complex(np.nan, 1)], 0),\n",
                "        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, np.nan)], 0),\n",
                "\n",
                "        ([complex(0, 0), complex(0, 2), complex(0, 1)], 1),\n",
                "        ([complex(1, 0), complex(0, 2), complex(0, 1)], 0),\n",
                "        ([complex(1, 0), complex(0, 2), complex(1, 1)], 2),\n",
                "\n",
                "        ([np.datetime64('1923-04-14T12:43:12'),\n",
                "          np.datetime64('1994-06-21T14:43:15'),\n",
                "          np.datetime64('2001-10-15T04:10:32'),\n",
                "          np.datetime64('1995-11-25T16:02:16'),\n",
                "          np.datetime64('2005-01-04T03:14:12'),\n",
                "          np.datetime64('2041-12-03T14:05:03')], 5),\n",
                "        ([np.datetime64('1935-09-14T04:40:11'),\n",
                "          np.datetime64('1949-10-12T12:32:11'),\n",
                "          np.datetime64('2010-01-03T05:14:12'),\n",
                "          np.datetime64('2015-11-20T12:20:59'),\n",
                "          np.datetime64('1932-09-23T10:10:13'),\n",
                "          np.datetime64('2014-10-10T03:50:30')], 3),\n",
                "        # Assorted tests with NaTs\n",
                "        ([np.datetime64('NaT'),\n",
                "          np.datetime64('NaT'),\n",
                "          np.datetime64('2010-01-03T05:14:12'),\n",
                "          np.datetime64('NaT'),\n",
                "          np.datetime64('2015-09-23T10:10:13'),\n",
                "          np.datetime64('1932-10-10T03:50:30')], 4),\n",
                "        ([np.datetime64('2059-03-14T12:43:12'),\n",
                "          np.datetime64('1996-09-21T14:43:15'),\n",
                "          np.datetime64('NaT'),\n",
                "          np.datetime64('2022-12-25T16:02:16'),\n",
                "          np.datetime64('1963-10-04T03:14:12'),\n",
                "          np.datetime64('2013-05-08T18:15:23')], 0),\n",
                "        ([np.timedelta64(2, 's'),\n",
                "          np.timedelta64(1, 's'),\n",
                "          np.timedelta64('NaT', 's'),\n",
                "          np.timedelta64(3, 's')], 3),\n",
                "        ([np.timedelta64('NaT', 's')] * 3, 0),\n",
                "\n",
                "        ([timedelta(days=5, seconds=14), timedelta(days=2, seconds=35),\n",
                "          timedelta(days=-1, seconds=23)], 0),\n",
                "        ([timedelta(days=1, seconds=43), timedelta(days=10, seconds=5),\n",
                "          timedelta(days=5, seconds=14)], 1),\n",
                "        ([timedelta(days=10, seconds=24), timedelta(days=10, seconds=5),\n",
                "          timedelta(days=10, seconds=43)], 2),\n",
                "\n",
                "        ([False, False, False, False, True], 4),\n",
                "        ([False, False, False, True, False], 3),\n",
                "        ([True, False, False, False, False], 0),\n",
                "        ([True, False, True, False, False], 0),\n",
                "    ]\n",
                "\n",
                "    def test_all(self):\n",
                "        a = np.random.normal(0, 1, (4, 5, 6, 7, 8))\n",
                "        for i in range(a.ndim):\n",
                "            amax = a.max(i)\n",
                "            aargmax = a.argmax(i)\n",
                "            axes = list(range(a.ndim))\n",
                "            axes.remove(i)\n",
                "            assert_(np.all(amax == aargmax.choose(*a.transpose(i,*axes))))\n",
                "\n",
                "    def test_combinations(self):\n",
                "        for arr, pos in self.nan_arr:\n",
                "            assert_equal(np.argmax(arr), pos, err_msg=\"%r\" % arr)\n",
                "            assert_equal(arr[np.argmax(arr)], np.max(arr), err_msg=\"%r\" % arr)\n",
                "\n",
                "    def test_output_shape(self):\n",
                "        # see also gh-616\n",
                "        a = np.ones((10, 5))\n",
                "        # Check some simple shape mismatches\n",
                "        out = np.ones(11, dtype=np.int_)\n",
                "        assert_raises(ValueError, a.argmax, -1, out)\n",
                "\n",
                "        out = np.ones((2, 5), dtype=np.int_)\n",
                "        assert_raises(ValueError, a.argmax, -1, out)\n",
                "\n",
                "        # these could be relaxed possibly (used to allow even the previous)\n",
                "        out = np.ones((1, 10), dtype=np.int_)\n",
                "        assert_raises(ValueError, a.argmax, -1, out)\n",
                "\n",
                "        out = np.ones(10, dtype=np.int_)\n",
                "        a.argmax(-1, out=out)\n",
                "        assert_equal(out, a.argmax(-1))\n",
                "\n",
                "    def test_argmax_unicode(self):\n",
                "        d = np.zeros(6031, dtype='<U9')\n",
                "        d[5942] = \"as\"\n",
                "        assert_equal(d.argmax(), 5942)\n",
                "\n",
                "    def test_np_vs_ndarray(self):\n",
                "        # make sure both ndarray.argmax and numpy.argmax support out/axis args\n",
                "        a = np.random.normal(size=(2,3))\n",
                "\n",
                "        # check positional args\n",
                "        out1 = np.zeros(2, dtype=int)\n",
                "        out2 = np.zeros(2, dtype=int)\n",
                "        assert_equal(a.argmax(1, out1), np.argmax(a, 1, out2))\n",
                "        assert_equal(out1, out2)\n",
                "\n",
                "        # check keyword args\n",
                "        out1 = np.zeros(3, dtype=int)\n",
                "        out2 = np.zeros(3, dtype=int)\n",
                "        assert_equal(a.argmax(out=out1, axis=0), np.argmax(a, out=out2, axis=0))\n",
                "        assert_equal(out1, out2)\n",
                "\n",
                "    def test_object_argmax_with_NULLs(self):\n",
                "        # See gh-6032\n",
                "        a = np.empty(4, dtype='O')\n",
                "        ctypes.memset(a.ctypes.data, 0, a.nbytes)\n",
                "        assert_equal(a.argmax(), 0)\n",
                "        a[3] = 10\n",
                "        assert_equal(a.argmax(), 3)\n",
                "        a[1] = 30\n",
                "        assert_equal(a.argmax(), 1)\n",
                "\n",
                "\n",
                "class TestArgmin(TestCase):\n",
                "\n",
                "    nan_arr = [\n",
                "        ([0, 1, 2, 3, np.nan], 4),\n",
                "        ([0, 1, 2, np.nan, 3], 3),\n",
                "        ([np.nan, 0, 1, 2, 3], 0),\n",
                "        ([np.nan, 0, np.nan, 2, 3], 0),\n",
                "        ([0, 1, 2, 3, complex(0, np.nan)], 4),\n",
                "        ([0, 1, 2, 3, complex(np.nan, 0)], 4),\n",
                "        ([0, 1, 2, complex(np.nan, 0), 3], 3),\n",
                "        ([0, 1, 2, complex(0, np.nan), 3], 3),\n",
                "        ([complex(0, np.nan), 0, 1, 2, 3], 0),\n",
                "        ([complex(np.nan, np.nan), 0, 1, 2, 3], 0),\n",
                "        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, 1)], 0),\n",
                "        ([complex(np.nan, np.nan), complex(np.nan, 2), complex(np.nan, 1)], 0),\n",
                "        ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, np.nan)], 0),\n",
                "\n",
                "        ([complex(0, 0), complex(0, 2), complex(0, 1)], 0),\n",
                "        ([complex(1, 0), complex(0, 2), complex(0, 1)], 2),\n",
                "        ([complex(1, 0), complex(0, 2), complex(1, 1)], 1),\n",
                "\n",
                "        ([np.datetime64('1923-04-14T12:43:12'),\n",
                "          np.datetime64('1994-06-21T14:43:15'),\n",
                "          np.datetime64('2001-10-15T04:10:32'),\n",
                "          np.datetime64('1995-11-25T16:02:16'),\n",
                "          np.datetime64('2005-01-04T03:14:12'),\n",
                "          np.datetime64('2041-12-03T14:05:03')], 0),\n",
                "        ([np.datetime64('1935-09-14T04:40:11'),\n",
                "          np.datetime64('1949-10-12T12:32:11'),\n",
                "          np.datetime64('2010-01-03T05:14:12'),\n",
                "          np.datetime64('2014-11-20T12:20:59'),\n",
                "          np.datetime64('2015-09-23T10:10:13'),\n",
                "          np.datetime64('1932-10-10T03:50:30')], 5),\n",
                "        # Assorted tests with NaTs\n",
                "        ([np.datetime64('NaT'),\n",
                "          np.datetime64('NaT'),\n",
                "          np.datetime64('2010-01-03T05:14:12'),\n",
                "          np.datetime64('NaT'),\n",
                "          np.datetime64('2015-09-23T10:10:13'),\n",
                "          np.datetime64('1932-10-10T03:50:30')], 5),\n",
                "        ([np.datetime64('2059-03-14T12:43:12'),\n",
                "          np.datetime64('1996-09-21T14:43:15'),\n",
                "          np.datetime64('NaT'),\n",
                "          np.datetime64('2022-12-25T16:02:16'),\n",
                "          np.datetime64('1963-10-04T03:14:12'),\n",
                "          np.datetime64('2013-05-08T18:15:23')], 4),\n",
                "        ([np.timedelta64(2, 's'),\n",
                "          np.timedelta64(1, 's'),\n",
                "          np.timedelta64('NaT', 's'),\n",
                "          np.timedelta64(3, 's')], 1),\n",
                "        ([np.timedelta64('NaT', 's')] * 3, 0),\n",
                "\n",
                "        ([timedelta(days=5, seconds=14), timedelta(days=2, seconds=35),\n",
                "          timedelta(days=-1, seconds=23)], 2),\n",
                "        ([timedelta(days=1, seconds=43), timedelta(days=10, seconds=5),\n",
                "          timedelta(days=5, seconds=14)], 0),\n",
                "        ([timedelta(days=10, seconds=24), timedelta(days=10, seconds=5),\n",
                "          timedelta(days=10, seconds=43)], 1),\n",
                "\n",
                "        ([True, True, True, True, False], 4),\n",
                "        ([True, True, True, False, True], 3),\n",
                "        ([False, True, True, True, True], 0),\n",
                "        ([False, True, False, True, True], 0),\n",
                "    ]\n",
                "\n",
                "    def test_all(self):\n",
                "        a = np.random.normal(0, 1, (4, 5, 6, 7, 8))\n",
                "        for i in range(a.ndim):\n",
                "            amin = a.min(i)\n",
                "            aargmin = a.argmin(i)\n",
                "            axes = list(range(a.ndim))\n",
                "            axes.remove(i)\n",
                "            assert_(np.all(amin == aargmin.choose(*a.transpose(i,*axes))))\n",
                "\n",
                "    def test_combinations(self):\n",
                "        for arr, pos in self.nan_arr:\n",
                "            assert_equal(np.argmin(arr), pos, err_msg=\"%r\" % arr)\n",
                "            assert_equal(arr[np.argmin(arr)], np.min(arr), err_msg=\"%r\" % arr)\n",
                "\n",
                "    def test_minimum_signed_integers(self):\n",
                "\n",
                "        a = np.array([1, -2**7, -2**7 + 1], dtype=np.int8)\n",
                "        assert_equal(np.argmin(a), 1)\n",
                "\n",
                "        a = np.array([1, -2**15, -2**15 + 1], dtype=np.int16)\n",
                "        assert_equal(np.argmin(a), 1)\n",
                "\n",
                "        a = np.array([1, -2**31, -2**31 + 1], dtype=np.int32)\n",
                "        assert_equal(np.argmin(a), 1)\n",
                "\n",
                "        a = np.array([1, -2**63, -2**63 + 1], dtype=np.int64)\n",
                "        assert_equal(np.argmin(a), 1)\n",
                "\n",
                "    def test_output_shape(self):\n",
                "        # see also gh-616\n",
                "        a = np.ones((10, 5))\n",
                "        # Check some simple shape mismatches\n",
                "        out = np.ones(11, dtype=np.int_)\n",
                "        assert_raises(ValueError, a.argmin, -1, out)\n",
                "\n",
                "        out = np.ones((2, 5), dtype=np.int_)\n",
                "        assert_raises(ValueError, a.argmin, -1, out)\n",
                "\n",
                "        # these could be relaxed possibly (used to allow even the previous)\n",
                "        out = np.ones((1, 10), dtype=np.int_)\n",
                "        assert_raises(ValueError, a.argmin, -1, out)\n",
                "\n",
                "        out = np.ones(10, dtype=np.int_)\n",
                "        a.argmin(-1, out=out)\n",
                "        assert_equal(out, a.argmin(-1))\n",
                "\n",
                "    def test_argmin_unicode(self):\n",
                "        d = np.ones(6031, dtype='<U9')\n",
                "        d[6001] = \"0\"\n",
                "        assert_equal(d.argmin(), 6001)\n",
                "\n",
                "    def test_np_vs_ndarray(self):\n",
                "        # make sure both ndarray.argmin and numpy.argmin support out/axis args\n",
                "        a = np.random.normal(size=(2, 3))\n",
                "\n",
                "        # check positional args\n",
                "        out1 = np.zeros(2, dtype=int)\n",
                "        out2 = np.ones(2, dtype=int)\n",
                "        assert_equal(a.argmin(1, out1), np.argmin(a, 1, out2))\n",
                "        assert_equal(out1, out2)\n",
                "\n",
                "        # check keyword args\n",
                "        out1 = np.zeros(3, dtype=int)\n",
                "        out2 = np.ones(3, dtype=int)\n",
                "        assert_equal(a.argmin(out=out1, axis=0), np.argmin(a, out=out2, axis=0))\n",
                "        assert_equal(out1, out2)\n",
                "\n",
                "    def test_object_argmin_with_NULLs(self):\n",
                "        # See gh-6032\n",
                "        a = np.empty(4, dtype='O')\n",
                "        ctypes.memset(a.ctypes.data, 0, a.nbytes)\n",
                "        assert_equal(a.argmin(), 0)\n",
                "        a[3] = 30\n",
                "        assert_equal(a.argmin(), 3)\n",
                "        a[1] = 10\n",
                "        assert_equal(a.argmin(), 1)\n",
                "\n",
                "\n",
                "class TestMinMax(TestCase):\n",
                "\n",
                "    def test_scalar(self):\n",
                "        assert_raises(np.AxisError, np.amax, 1, 1)\n",
                "        assert_raises(np.AxisError, np.amin, 1, 1)\n",
                "\n",
                "        assert_equal(np.amax(1, axis=0), 1)\n",
                "        assert_equal(np.amin(1, axis=0), 1)\n",
                "        assert_equal(np.amax(1, axis=None), 1)\n",
                "        assert_equal(np.amin(1, axis=None), 1)\n",
                "\n",
                "    def test_axis(self):\n",
                "        assert_raises(np.AxisError, np.amax, [1, 2, 3], 1000)\n",
                "        assert_equal(np.amax([[1, 2, 3]], axis=1), 3)\n",
                "\n",
                "    def test_datetime(self):\n",
                "        # NaTs are ignored\n",
                "        for dtype in ('m8[s]', 'm8[Y]'):\n",
                "            a = np.arange(10).astype(dtype)\n",
                "            a[3] = 'NaT'\n",
                "            assert_equal(np.amin(a), a[0])\n",
                "            assert_equal(np.amax(a), a[9])\n",
                "            a[0] = 'NaT'\n",
                "            assert_equal(np.amin(a), a[1])\n",
                "            assert_equal(np.amax(a), a[9])\n",
                "            a.fill('NaT')\n",
                "            assert_equal(np.amin(a), a[0])\n",
                "            assert_equal(np.amax(a), a[0])\n",
                "\n",
                "\n",
                "class TestNewaxis(TestCase):\n",
                "    def test_basic(self):\n",
                "        sk = np.array([0, -0.1, 0.1])\n",
                "        res = 250*sk[:, np.newaxis]\n",
                "        assert_almost_equal(res.ravel(), 250*sk)\n",
                "\n",
                "\n",
                "class TestClip(TestCase):\n",
                "    def _check_range(self, x, cmin, cmax):\n",
                "        assert_(np.all(x >= cmin))\n",
                "        assert_(np.all(x <= cmax))\n",
                "\n",
                "    def _clip_type(self, type_group, array_max,\n",
                "                   clip_min, clip_max, inplace=False,\n",
                "                   expected_min=None, expected_max=None):\n",
                "        if expected_min is None:\n",
                "            expected_min = clip_min\n",
                "        if expected_max is None:\n",
                "            expected_max = clip_max\n",
                "\n",
                "        for T in np.sctypes[type_group]:\n",
                "            if sys.byteorder == 'little':\n",
                "                byte_orders = ['=', '>']\n",
                "            else:\n",
                "                byte_orders = ['<', '=']\n",
                "\n",
                "            for byteorder in byte_orders:\n",
                "                dtype = np.dtype(T).newbyteorder(byteorder)\n",
                "\n",
                "                x = (np.random.random(1000) * array_max).astype(dtype)\n",
                "                if inplace:\n",
                "                    x.clip(clip_min, clip_max, x)\n",
                "                else:\n",
                "                    x = x.clip(clip_min, clip_max)\n",
                "                    byteorder = '='\n",
                "\n",
                "                if x.dtype.byteorder == '|':\n",
                "                    byteorder = '|'\n",
                "                assert_equal(x.dtype.byteorder, byteorder)\n",
                "                self._check_range(x, expected_min, expected_max)\n",
                "        return x\n",
                "\n",
                "    def test_basic(self):\n",
                "        for inplace in [False, True]:\n",
                "            self._clip_type(\n",
                "                'float', 1024, -12.8, 100.2, inplace=inplace)\n",
                "            self._clip_type(\n",
                "                'float', 1024, 0, 0, inplace=inplace)\n",
                "\n",
                "            self._clip_type(\n",
                "                'int', 1024, -120, 100.5, inplace=inplace)\n",
                "            self._clip_type(\n",
                "                'int', 1024, 0, 0, inplace=inplace)\n",
                "\n",
                "            self._clip_type(\n",
                "                'uint', 1024, 0, 0, inplace=inplace)\n",
                "            self._clip_type(\n",
                "                'uint', 1024, -120, 100, inplace=inplace, expected_min=0)\n",
                "\n",
                "    def test_record_array(self):\n",
                "        rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],\n",
                "                       dtype=[('x', '<f8'), ('y', '<f8'), ('z', '<f8')])\n",
                "        y = rec['x'].clip(-0.3, 0.5)\n",
                "        self._check_range(y, -0.3, 0.5)\n",
                "\n",
                "    def test_max_or_min(self):\n",
                "        val = np.array([0, 1, 2, 3, 4, 5, 6, 7])\n",
                "        x = val.clip(3)\n",
                "        assert_(np.all(x >= 3))\n",
                "        x = val.clip(min=3)\n",
                "        assert_(np.all(x >= 3))\n",
                "        x = val.clip(max=4)\n",
                "        assert_(np.all(x <= 4))\n",
                "\n",
                "    def test_nan(self):\n",
                "        input_arr = np.array([-2., np.nan, 0.5, 3., 0.25, np.nan])\n",
                "        result = input_arr.clip(-1, 1)\n",
                "        expected = np.array([-1., np.nan, 0.5, 1., 0.25, np.nan])\n",
                "        assert_array_equal(result, expected)\n",
                "\n",
                "\n",
                "class TestCompress(TestCase):\n",
                "    def test_axis(self):\n",
                "        tgt = [[5, 6, 7, 8, 9]]\n",
                "        arr = np.arange(10).reshape(2, 5)\n",
                "        out = np.compress([0, 1], arr, axis=0)\n",
                "        assert_equal(out, tgt)\n",
                "\n",
                "        tgt = [[1, 3], [6, 8]]\n",
                "        out = np.compress([0, 1, 0, 1, 0], arr, axis=1)\n",
                "        assert_equal(out, tgt)\n",
                "\n",
                "    def test_truncate(self):\n",
                "        tgt = [[1], [6]]\n",
                "        arr = np.arange(10).reshape(2, 5)\n",
                "        out = np.compress([0, 1], arr, axis=1)\n",
                "        assert_equal(out, tgt)\n",
                "\n",
                "    def test_flatten(self):\n",
                "        arr = np.arange(10).reshape(2, 5)\n",
                "        out = np.compress([0, 1], arr)\n",
                "        assert_equal(out, 1)\n",
                "\n",
                "\n",
                "class TestPutmask(object):\n",
                "    def tst_basic(self, x, T, mask, val):\n",
                "        np.putmask(x, mask, val)\n",
                "        assert_equal(x[mask], T(val))\n",
                "        assert_equal(x.dtype, T)\n",
                "\n",
                "    def test_ip_types(self):\n",
                "        unchecked_types = [bytes, unicode, np.void, object]\n",
                "\n",
                "        x = np.random.random(1000)*100\n",
                "        mask = x < 40\n",
                "\n",
                "        for val in [-100, 0, 15]:\n",
                "            for types in np.sctypes.values():\n",
                "                for T in types:\n",
                "                    if T not in unchecked_types:\n",
                "                        yield self.tst_basic, x.copy().astype(T), T, mask, val\n",
                "\n",
                "    def test_mask_size(self):\n",
                "        assert_raises(ValueError, np.putmask, np.array([1, 2, 3]), [True], 5)\n",
                "\n",
                "    def tst_byteorder(self, dtype):\n",
                "        x = np.array([1, 2, 3], dtype)\n",
                "        np.putmask(x, [True, False, True], -1)\n",
                "        assert_array_equal(x, [-1, 2, -1])\n",
                "\n",
                "    def test_ip_byteorder(self):\n",
                "        for dtype in ('>i4', '<i4'):\n",
                "            yield self.tst_byteorder, dtype\n",
                "\n",
                "    def test_record_array(self):\n",
                "        # Note mixed byteorder.\n",
                "        rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],\n",
                "                      dtype=[('x', '<f8'), ('y', '>f8'), ('z', '<f8')])\n",
                "        np.putmask(rec['x'], [True, False], 10)\n",
                "        assert_array_equal(rec['x'], [10, 5])\n",
                "        assert_array_equal(rec['y'], [2, 4])\n",
                "        assert_array_equal(rec['z'], [3, 3])\n",
                "        np.putmask(rec['y'], [True, False], 11)\n",
                "        assert_array_equal(rec['x'], [10, 5])\n",
                "        assert_array_equal(rec['y'], [11, 4])\n",
                "        assert_array_equal(rec['z'], [3, 3])\n",
                "\n",
                "\n",
                "class TestTake(object):\n",
                "    def tst_basic(self, x):\n",
                "        ind = list(range(x.shape[0]))\n",
                "        assert_array_equal(x.take(ind, axis=0), x)\n",
                "\n",
                "    def test_ip_types(self):\n",
                "        unchecked_types = [bytes, unicode, np.void, object]\n",
                "\n",
                "        x = np.random.random(24)*100\n",
                "        x.shape = 2, 3, 4\n",
                "        for types in np.sctypes.values():\n",
                "            for T in types:\n",
                "                if T not in unchecked_types:\n",
                "                    yield self.tst_basic, x.copy().astype(T)\n",
                "\n",
                "    def test_raise(self):\n",
                "        x = np.random.random(24)*100\n",
                "        x.shape = 2, 3, 4\n",
                "        assert_raises(IndexError, x.take, [0, 1, 2], axis=0)\n",
                "        assert_raises(IndexError, x.take, [-3], axis=0)\n",
                "        assert_array_equal(x.take([-1], axis=0)[0], x[1])\n",
                "\n",
                "    def test_clip(self):\n",
                "        x = np.random.random(24)*100\n",
                "        x.shape = 2, 3, 4\n",
                "        assert_array_equal(x.take([-1], axis=0, mode='clip')[0], x[0])\n",
                "        assert_array_equal(x.take([2], axis=0, mode='clip')[0], x[1])\n",
                "\n",
                "    def test_wrap(self):\n",
                "        x = np.random.random(24)*100\n",
                "        x.shape = 2, 3, 4\n",
                "        assert_array_equal(x.take([-1], axis=0, mode='wrap')[0], x[1])\n",
                "        assert_array_equal(x.take([2], axis=0, mode='wrap')[0], x[0])\n",
                "        assert_array_equal(x.take([3], axis=0, mode='wrap')[0], x[1])\n",
                "\n",
                "    def tst_byteorder(self, dtype):\n",
                "        x = np.array([1, 2, 3], dtype)\n",
                "        assert_array_equal(x.take([0, 2, 1]), [1, 3, 2])\n",
                "\n",
                "    def test_ip_byteorder(self):\n",
                "        for dtype in ('>i4', '<i4'):\n",
                "            yield self.tst_byteorder, dtype\n",
                "\n",
                "    def test_record_array(self):\n",
                "        # Note mixed byteorder.\n",
                "        rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],\n",
                "                      dtype=[('x', '<f8'), ('y', '>f8'), ('z', '<f8')])\n",
                "        rec1 = rec.take([1])\n",
                "        assert_(rec1['x'] == 5.0 and rec1['y'] == 4.0)\n",
                "\n",
                "\n",
                "class TestLexsort(TestCase):\n",
                "    def test_basic(self):\n",
                "        a = [1, 2, 1, 3, 1, 5]\n",
                "        b = [0, 4, 5, 6, 2, 3]\n",
                "        idx = np.lexsort((b, a))\n",
                "        expected_idx = np.array([0, 4, 2, 1, 3, 5])\n",
                "        assert_array_equal(idx, expected_idx)\n",
                "\n",
                "        x = np.vstack((b, a))\n",
                "        idx = np.lexsort(x)\n",
                "        assert_array_equal(idx, expected_idx)\n",
                "\n",
                "        assert_array_equal(x[1][idx], np.sort(x[1]))\n",
                "\n",
                "    def test_datetime(self):\n",
                "        a = np.array([0,0,0], dtype='datetime64[D]')\n",
                "        b = np.array([2,1,0], dtype='datetime64[D]')\n",
                "        idx = np.lexsort((b, a))\n",
                "        expected_idx = np.array([2, 1, 0])\n",
                "        assert_array_equal(idx, expected_idx)\n",
                "\n",
                "        a = np.array([0,0,0], dtype='timedelta64[D]')\n",
                "        b = np.array([2,1,0], dtype='timedelta64[D]')\n",
                "        idx = np.lexsort((b, a))\n",
                "        expected_idx = np.array([2, 1, 0])\n",
                "        assert_array_equal(idx, expected_idx)\n",
                "\n",
                "    def test_object(self):  # gh-6312\n",
                "        a = np.random.choice(10, 1000)\n",
                "        b = np.random.choice(['abc', 'xy', 'wz', 'efghi', 'qwst', 'x'], 1000)\n",
                "\n",
                "        for u in a, b:\n",
                "            left = np.lexsort((u.astype('O'),))\n",
                "            right = np.argsort(u, kind='mergesort')\n",
                "            assert_array_equal(left, right)\n",
                "\n",
                "        for u, v in (a, b), (b, a):\n",
                "            idx = np.lexsort((u, v))\n",
                "            assert_array_equal(idx, np.lexsort((u.astype('O'), v)))\n",
                "            assert_array_equal(idx, np.lexsort((u, v.astype('O'))))\n",
                "            u, v = np.array(u, dtype='object'), np.array(v, dtype='object')\n",
                "            assert_array_equal(idx, np.lexsort((u, v)))\n",
                "\n",
                "    def test_invalid_axis(self): # gh-7528\n",
                "        x = np.linspace(0., 1., 42*3).reshape(42, 3)\n",
                "        assert_raises(np.AxisError, np.lexsort, x, axis=2)\n",
                "\n",
                "class TestIO(TestCase):\n",
                "    \"\"\"Test tofile, fromfile, tobytes, and fromstring\"\"\"\n",
                "\n",
                "    def setUp(self):\n",
                "        shape = (2, 4, 3)\n",
                "        rand = np.random.random\n",
                "        self.x = rand(shape) + rand(shape).astype(np.complex)*1j\n",
                "        self.x[0,:, 1] = [np.nan, np.inf, -np.inf, np.nan]\n",
                "        self.dtype = self.x.dtype\n",
                "        self.tempdir = tempfile.mkdtemp()\n",
                "        self.filename = tempfile.mktemp(dir=self.tempdir)\n",
                "\n",
                "    def tearDown(self):\n",
                "        shutil.rmtree(self.tempdir)\n",
                "\n",
                "    def test_nofile(self):\n",
                "        # this should probably be supported as a file\n",
                "        # but for now test for proper errors\n",
                "        b = io.BytesIO()\n",
                "        assert_raises(IOError, np.fromfile, b, np.uint8, 80)\n",
                "        d = np.ones(7)\n",
                "        assert_raises(IOError, lambda x: x.tofile(b), d)\n",
                "\n",
                "    def test_bool_fromstring(self):\n",
                "        v = np.array([True, False, True, False], dtype=np.bool_)\n",
                "        y = np.fromstring('1 0 -2.3 0.0', sep=' ', dtype=np.bool_)\n",
                "        assert_array_equal(v, y)\n",
                "\n",
                "    def test_uint64_fromstring(self):\n",
                "        d = np.fromstring(\"9923372036854775807 104783749223640\",\n",
                "                          dtype=np.uint64, sep=' ')\n",
                "        e = np.array([9923372036854775807, 104783749223640], dtype=np.uint64)\n",
                "        assert_array_equal(d, e)\n",
                "\n",
                "    def test_int64_fromstring(self):\n",
                "        d = np.fromstring(\"-25041670086757 104783749223640\",\n",
                "                          dtype=np.int64, sep=' ')\n",
                "        e = np.array([-25041670086757, 104783749223640], dtype=np.int64)\n",
                "        assert_array_equal(d, e)\n",
                "\n",
                "    def test_empty_files_binary(self):\n",
                "        f = open(self.filename, 'w')\n",
                "        f.close()\n",
                "        y = np.fromfile(self.filename)\n",
                "        assert_(y.size == 0, \"Array not empty\")\n",
                "\n",
                "    def test_empty_files_text(self):\n",
                "        f = open(self.filename, 'w')\n",
                "        f.close()\n",
                "        y = np.fromfile(self.filename, sep=\" \")\n",
                "        assert_(y.size == 0, \"Array not empty\")\n",
                "\n",
                "    def test_roundtrip_file(self):\n",
                "        f = open(self.filename, 'wb')\n",
                "        self.x.tofile(f)\n",
                "        f.close()\n",
                "        # NB. doesn't work with flush+seek, due to use of C stdio\n",
                "        f = open(self.filename, 'rb')\n",
                "        y = np.fromfile(f, dtype=self.dtype)\n",
                "        f.close()\n",
                "        assert_array_equal(y, self.x.flat)\n",
                "\n",
                "    def test_roundtrip_filename(self):\n",
                "        self.x.tofile(self.filename)\n",
                "        y = np.fromfile(self.filename, dtype=self.dtype)\n",
                "        assert_array_equal(y, self.x.flat)\n",
                "\n",
                "    def test_roundtrip_binary_str(self):\n",
                "        s = self.x.tobytes()\n",
                "        y = np.fromstring(s, dtype=self.dtype)\n",
                "        assert_array_equal(y, self.x.flat)\n",
                "\n",
                "        s = self.x.tobytes('F')\n",
                "        y = np.fromstring(s, dtype=self.dtype)\n",
                "        assert_array_equal(y, self.x.flatten('F'))\n",
                "\n",
                "    def test_roundtrip_str(self):\n",
                "        x = self.x.real.ravel()\n",
                "        s = \"@\".join(map(str, x))\n",
                "        y = np.fromstring(s, sep=\"@\")\n",
                "        # NB. str imbues less precision\n",
                "        nan_mask = ~np.isfinite(x)\n",
                "        assert_array_equal(x[nan_mask], y[nan_mask])\n",
                "        assert_array_almost_equal(x[~nan_mask], y[~nan_mask], decimal=5)\n",
                "\n",
                "    def test_roundtrip_repr(self):\n",
                "        x = self.x.real.ravel()\n",
                "        s = \"@\".join(map(repr, x))\n",
                "        y = np.fromstring(s, sep=\"@\")\n",
                "        assert_array_equal(x, y)\n",
                "\n",
                "    def test_unseekable_fromfile(self):\n",
                "        # gh-6246\n",
                "        self.x.tofile(self.filename)\n",
                "\n",
                "        def fail(*args, **kwargs):\n",
                "            raise IOError('Can not tell or seek')\n",
                "\n",
                "        with io.open(self.filename, 'rb', buffering=0) as f:\n",
                "            f.seek = fail\n",
                "            f.tell = fail\n",
                "            self.assertRaises(IOError, np.fromfile, f, dtype=self.dtype)\n",
                "\n",
                "    def test_io_open_unbuffered_fromfile(self):\n",
                "        # gh-6632\n",
                "        self.x.tofile(self.filename)\n",
                "        with io.open(self.filename, 'rb', buffering=0) as f:\n",
                "            y = np.fromfile(f, dtype=self.dtype)\n",
                "            assert_array_equal(y, self.x.flat)\n",
                "\n",
                "    def test_largish_file(self):\n",
                "        # check the fallocate path on files > 16MB\n",
                "        d = np.zeros(4 * 1024 ** 2)\n",
                "        d.tofile(self.filename)\n",
                "        assert_equal(os.path.getsize(self.filename), d.nbytes)\n",
                "        assert_array_equal(d, np.fromfile(self.filename))\n",
                "        # check offset\n",
                "        with open(self.filename, \"r+b\") as f:\n",
                "            f.seek(d.nbytes)\n",
                "            d.tofile(f)\n",
                "            assert_equal(os.path.getsize(self.filename), d.nbytes * 2)\n",
                "        # check append mode (gh-8329)\n",
                "        open(self.filename, \"w\").close() # delete file contents\n",
                "        with open(self.filename, \"ab\") as f:\n",
                "            d.tofile(f)\n",
                "        assert_array_equal(d, np.fromfile(self.filename))\n",
                "        with open(self.filename, \"ab\") as f:\n",
                "            d.tofile(f)\n",
                "        assert_equal(os.path.getsize(self.filename), d.nbytes * 2)\n",
                "\n",
                "\n",
                "    def test_io_open_buffered_fromfile(self):\n",
                "        # gh-6632\n",
                "        self.x.tofile(self.filename)\n",
                "        with io.open(self.filename, 'rb', buffering=-1) as f:\n",
                "            y = np.fromfile(f, dtype=self.dtype)\n",
                "        assert_array_equal(y, self.x.flat)\n",
                "\n",
                "    def test_file_position_after_fromfile(self):\n",
                "        # gh-4118\n",
                "        sizes = [io.DEFAULT_BUFFER_SIZE//8,\n",
                "                 io.DEFAULT_BUFFER_SIZE,\n",
                "                 io.DEFAULT_BUFFER_SIZE*8]\n",
                "\n",
                "        for size in sizes:\n",
                "            f = open(self.filename, 'wb')\n",
                "            f.seek(size-1)\n",
                "            f.write(b'\\0')\n",
                "            f.close()\n",
                "\n",
                "            for mode in ['rb', 'r+b']:\n",
                "                err_msg = \"%d %s\" % (size, mode)\n",
                "\n",
                "                f = open(self.filename, mode)\n",
                "                f.read(2)\n",
                "                np.fromfile(f, dtype=np.float64, count=1)\n",
                "                pos = f.tell()\n",
                "                f.close()\n",
                "                assert_equal(pos, 10, err_msg=err_msg)\n",
                "\n",
                "    def test_file_position_after_tofile(self):\n",
                "        # gh-4118\n",
                "        sizes = [io.DEFAULT_BUFFER_SIZE//8,\n",
                "                 io.DEFAULT_BUFFER_SIZE,\n",
                "                 io.DEFAULT_BUFFER_SIZE*8]\n",
                "\n",
                "        for size in sizes:\n",
                "            err_msg = \"%d\" % (size,)\n",
                "\n",
                "            f = open(self.filename, 'wb')\n",
                "            f.seek(size-1)\n",
                "            f.write(b'\\0')\n",
                "            f.seek(10)\n",
                "            f.write(b'12')\n",
                "            np.array([0], dtype=np.float64).tofile(f)\n",
                "            pos = f.tell()\n",
                "            f.close()\n",
                "            assert_equal(pos, 10 + 2 + 8, err_msg=err_msg)\n",
                "\n",
                "            f = open(self.filename, 'r+b')\n",
                "            f.read(2)\n",
                "            f.seek(0, 1)  # seek between read&write required by ANSI C\n",
                "            np.array([0], dtype=np.float64).tofile(f)\n",
                "            pos = f.tell()\n",
                "            f.close()\n",
                "            assert_equal(pos, 10, err_msg=err_msg)\n",
                "\n",
                "    def _check_from(self, s, value, **kw):\n",
                "        y = np.fromstring(s, **kw)\n",
                "        assert_array_equal(y, value)\n",
                "\n",
                "        f = open(self.filename, 'wb')\n",
                "        f.write(s)\n",
                "        f.close()\n",
                "        y = np.fromfile(self.filename, **kw)\n",
                "        assert_array_equal(y, value)\n",
                "\n",
                "    def test_nan(self):\n",
                "        self._check_from(\n",
                "            b\"nan +nan -nan NaN nan(foo) +NaN(BAR) -NAN(q_u_u_x_)\",\n",
                "            [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n",
                "            sep=' ')\n",
                "\n",
                "    def test_inf(self):\n",
                "        self._check_from(\n",
                "            b\"inf +inf -inf infinity -Infinity iNfInItY -inF\",\n",
                "            [np.inf, np.inf, -np.inf, np.inf, -np.inf, np.inf, -np.inf],\n",
                "            sep=' ')\n",
                "\n",
                "    def test_numbers(self):\n",
                "        self._check_from(b\"1.234 -1.234 .3 .3e55 -123133.1231e+133\",\n",
                "                         [1.234, -1.234, .3, .3e55, -123133.1231e+133], sep=' ')\n",
                "\n",
                "    def test_binary(self):\n",
                "        self._check_from(b'\\x00\\x00\\x80?\\x00\\x00\\x00@\\x00\\x00@@\\x00\\x00\\x80@',\n",
                "                         np.array([1, 2, 3, 4]),\n",
                "                         dtype='<f4')\n",
                "\n",
                "    @dec.slow  # takes > 1 minute on mechanical hard drive\n",
                "    def test_big_binary(self):\n",
                "        \"\"\"Test workarounds for 32-bit limited fwrite, fseek, and ftell\n",
                "        calls in windows. These normally would hang doing something like this.\n",
                "        See http://projects.scipy.org/numpy/ticket/1660\"\"\"\n",
                "        if sys.platform != 'win32':\n",
                "            return\n",
                "        try:\n",
                "            # before workarounds, only up to 2**32-1 worked\n",
                "            fourgbplus = 2**32 + 2**16\n",
                "            testbytes = np.arange(8, dtype=np.int8)\n",
                "            n = len(testbytes)\n",
                "            flike = tempfile.NamedTemporaryFile()\n",
                "            f = flike.file\n",
                "            np.tile(testbytes, fourgbplus // testbytes.nbytes).tofile(f)\n",
                "            flike.seek(0)\n",
                "            a = np.fromfile(f, dtype=np.int8)\n",
                "            flike.close()\n",
                "            assert_(len(a) == fourgbplus)\n",
                "            # check only start and end for speed:\n",
                "            assert_((a[:n] == testbytes).all())\n",
                "            assert_((a[-n:] == testbytes).all())\n",
                "        except (MemoryError, ValueError):\n",
                "            pass\n",
                "\n",
                "    def test_string(self):\n",
                "        self._check_from(b'1,2,3,4', [1., 2., 3., 4.], sep=',')\n",
                "\n",
                "    def test_counted_string(self):\n",
                "        self._check_from(b'1,2,3,4', [1., 2., 3., 4.], count=4, sep=',')\n",
                "        self._check_from(b'1,2,3,4', [1., 2., 3.], count=3, sep=',')\n",
                "        self._check_from(b'1,2,3,4', [1., 2., 3., 4.], count=-1, sep=',')\n",
                "\n",
                "    def test_string_with_ws(self):\n",
                "        self._check_from(b'1 2  3     4   ', [1, 2, 3, 4], dtype=int, sep=' ')\n",
                "\n",
                "    def test_counted_string_with_ws(self):\n",
                "        self._check_from(b'1 2  3     4   ', [1, 2, 3], count=3, dtype=int,\n",
                "                         sep=' ')\n",
                "\n",
                "    def test_ascii(self):\n",
                "        self._check_from(b'1 , 2 , 3 , 4', [1., 2., 3., 4.], sep=',')\n",
                "        self._check_from(b'1,2,3,4', [1., 2., 3., 4.], dtype=float, sep=',')\n",
                "\n",
                "    def test_malformed(self):\n",
                "        self._check_from(b'1.234 1,234', [1.234, 1.], sep=' ')\n",
                "\n",
                "    def test_long_sep(self):\n",
                "        self._check_from(b'1_x_3_x_4_x_5', [1, 3, 4, 5], sep='_x_')\n",
                "\n",
                "    def test_dtype(self):\n",
                "        v = np.array([1, 2, 3, 4], dtype=np.int_)\n",
                "        self._check_from(b'1,2,3,4', v, sep=',', dtype=np.int_)\n",
                "\n",
                "    def test_dtype_bool(self):\n",
                "        # can't use _check_from because fromstring can't handle True/False\n",
                "        v = np.array([True, False, True, False], dtype=np.bool_)\n",
                "        s = b'1,0,-2.3,0'\n",
                "        f = open(self.filename, 'wb')\n",
                "        f.write(s)\n",
                "        f.close()\n",
                "        y = np.fromfile(self.filename, sep=',', dtype=np.bool_)\n",
                "        assert_(y.dtype == '?')\n",
                "        assert_array_equal(y, v)\n",
                "\n",
                "    def test_tofile_sep(self):\n",
                "        x = np.array([1.51, 2, 3.51, 4], dtype=float)\n",
                "        f = open(self.filename, 'w')\n",
                "        x.tofile(f, sep=',')\n",
                "        f.close()\n",
                "        f = open(self.filename, 'r')\n",
                "        s = f.read()\n",
                "        f.close()\n",
                "        #assert_equal(s, '1.51,2.0,3.51,4.0')\n",
                "        y = np.array([float(p) for p in s.split(',')])\n",
                "        assert_array_equal(x,y)\n",
                "\n",
                "    def test_tofile_format(self):\n",
                "        x = np.array([1.51, 2, 3.51, 4], dtype=float)\n",
                "        f = open(self.filename, 'w')\n",
                "        x.tofile(f, sep=',', format='%.2f')\n",
                "        f.close()\n",
                "        f = open(self.filename, 'r')\n",
                "        s = f.read()\n",
                "        f.close()\n",
                "        assert_equal(s, '1.51,2.00,3.51,4.00')\n",
                "\n",
                "    def test_locale(self):\n",
                "        in_foreign_locale(self.test_numbers)()\n",
                "        in_foreign_locale(self.test_nan)()\n",
                "        in_foreign_locale(self.test_inf)()\n",
                "        in_foreign_locale(self.test_counted_string)()\n",
                "        in_foreign_locale(self.test_ascii)()\n",
                "        in_foreign_locale(self.test_malformed)()\n",
                "        in_foreign_locale(self.test_tofile_sep)()\n",
                "        in_foreign_locale(self.test_tofile_format)()\n",
                "\n",
                "\n",
                "class TestFromBuffer(object):\n",
                "    def tst_basic(self, buffer, expected, kwargs):\n",
                "        assert_array_equal(np.frombuffer(buffer,**kwargs), expected)\n",
                "\n",
                "    def test_ip_basic(self):\n",
                "        for byteorder in ['<', '>']:\n",
                "            for dtype in [float, int, np.complex]:\n",
                "                dt = np.dtype(dtype).newbyteorder(byteorder)\n",
                "                x = (np.random.random((4, 7))*5).astype(dt)\n",
                "                buf = x.tobytes()\n",
                "                yield self.tst_basic, buf, x.flat, {'dtype':dt}\n",
                "\n",
                "    def test_empty(self):\n",
                "        yield self.tst_basic, b'', np.array([]), {}\n",
                "\n",
                "\n",
                "class TestFlat(TestCase):\n",
                "    def setUp(self):\n",
                "        a0 = np.arange(20.0)\n",
                "        a = a0.reshape(4, 5)\n",
                "        a0.shape = (4, 5)\n",
                "        a.flags.writeable = False\n",
                "        self.a = a\n",
                "        self.b = a[::2, ::2]\n",
                "        self.a0 = a0\n",
                "        self.b0 = a0[::2, ::2]\n",
                "\n",
                "    def test_contiguous(self):\n",
                "        testpassed = False\n",
                "        try:\n",
                "            self.a.flat[12] = 100.0\n",
                "        except ValueError:\n",
                "            testpassed = True\n",
                "        assert_(testpassed)\n",
                "        assert_(self.a.flat[12] == 12.0)\n",
                "\n",
                "    def test_discontiguous(self):\n",
                "        testpassed = False\n",
                "        try:\n",
                "            self.b.flat[4] = 100.0\n",
                "        except ValueError:\n",
                "            testpassed = True\n",
                "        assert_(testpassed)\n",
                "        assert_(self.b.flat[4] == 12.0)\n",
                "\n",
                "    def test___array__(self):\n",
                "        c = self.a.flat.__array__()\n",
                "        d = self.b.flat.__array__()\n",
                "        e = self.a0.flat.__array__()\n",
                "        f = self.b0.flat.__array__()\n",
                "\n",
                "        assert_(c.flags.writeable is False)\n",
                "        assert_(d.flags.writeable is False)\n",
                "        assert_(e.flags.writeable is True)\n",
                "        assert_(f.flags.writeable is True)\n",
                "\n",
                "        assert_(c.flags.updateifcopy is False)\n",
                "        assert_(d.flags.updateifcopy is False)\n",
                "        assert_(e.flags.updateifcopy is False)\n",
                "        assert_(f.flags.updateifcopy is True)\n",
                "        assert_(f.base is self.b0)\n",
                "\n",
                "\n",
                "class TestResize(TestCase):\n",
                "    def test_basic(self):\n",
                "        x = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n",
                "        if IS_PYPY:\n",
                "            x.resize((5, 5), refcheck=False)\n",
                "        else:\n",
                "            x.resize((5, 5))\n",
                "        assert_array_equal(x.flat[:9],\n",
                "                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]).flat)\n",
                "        assert_array_equal(x[9:].flat, 0)\n",
                "\n",
                "    def test_check_reference(self):\n",
                "        x = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n",
                "        y = x\n",
                "        self.assertRaises(ValueError, x.resize, (5, 1))\n",
                "        del y  # avoid pyflakes unused variable warning.\n",
                "\n",
                "    def test_int_shape(self):\n",
                "        x = np.eye(3)\n",
                "        if IS_PYPY:\n",
                "            x.resize(3, refcheck=False)\n",
                "        else:\n",
                "            x.resize(3)\n",
                "        assert_array_equal(x, np.eye(3)[0,:])\n",
                "\n",
                "    def test_none_shape(self):\n",
                "        x = np.eye(3)\n",
                "        x.resize(None)\n",
                "        assert_array_equal(x, np.eye(3))\n",
                "        x.resize()\n",
                "        assert_array_equal(x, np.eye(3))\n",
                "\n",
                "    def test_invalid_arguments(self):\n",
                "        self.assertRaises(TypeError, np.eye(3).resize, 'hi')\n",
                "        self.assertRaises(ValueError, np.eye(3).resize, -1)\n",
                "        self.assertRaises(TypeError, np.eye(3).resize, order=1)\n",
                "        self.assertRaises(TypeError, np.eye(3).resize, refcheck='hi')\n",
                "\n",
                "    def test_freeform_shape(self):\n",
                "        x = np.eye(3)\n",
                "        if IS_PYPY:\n",
                "            x.resize(3, 2, 1, refcheck=False)\n",
                "        else:\n",
                "            x.resize(3, 2, 1)\n",
                "        assert_(x.shape == (3, 2, 1))\n",
                "\n",
                "    def test_zeros_appended(self):\n",
                "        x = np.eye(3)\n",
                "        if IS_PYPY:\n",
                "            x.resize(2, 3, 3, refcheck=False)\n",
                "        else:\n",
                "            x.resize(2, 3, 3)\n",
                "        assert_array_equal(x[0], np.eye(3))\n",
                "        assert_array_equal(x[1], np.zeros((3, 3)))\n",
                "\n",
                "    def test_obj_obj(self):\n",
                "        # check memory is initialized on resize, gh-4857\n",
                "        a = np.ones(10, dtype=[('k', object, 2)])\n",
                "        if IS_PYPY:\n",
                "            a.resize(15, refcheck=False)\n",
                "        else:\n",
                "            a.resize(15,)\n",
                "        assert_equal(a.shape, (15,))\n",
                "        assert_array_equal(a['k'][-5:], 0)\n",
                "        assert_array_equal(a['k'][:-5], 1)\n",
                "\n",
                "\n",
                "class TestRecord(TestCase):\n",
                "    def test_field_rename(self):\n",
                "        dt = np.dtype([('f', float), ('i', int)])\n",
                "        dt.names = ['p', 'q']\n",
                "        assert_equal(dt.names, ['p', 'q'])\n",
                "\n",
                "    def test_multiple_field_name_occurrence(self):\n",
                "        def test_assign():\n",
                "            dtype = np.dtype([(\"A\", \"f8\"), (\"B\", \"f8\"), (\"A\", \"f8\")])\n",
                "\n",
                "        # Error raised when multiple fields have the same name\n",
                "        assert_raises(ValueError, test_assign)\n",
                "\n",
                "    if sys.version_info[0] >= 3:\n",
                "        def test_bytes_fields(self):\n",
                "            # Bytes are not allowed in field names and not recognized in titles\n",
                "            # on Py3\n",
                "            assert_raises(TypeError, np.dtype, [(b'a', int)])\n",
                "            assert_raises(TypeError, np.dtype, [(('b', b'a'), int)])\n",
                "\n",
                "            dt = np.dtype([((b'a', 'b'), int)])\n",
                "            assert_raises(ValueError, dt.__getitem__, b'a')\n",
                "\n",
                "            x = np.array([(1,), (2,), (3,)], dtype=dt)\n",
                "            assert_raises(IndexError, x.__getitem__, b'a')\n",
                "\n",
                "            y = x[0]\n",
                "            assert_raises(IndexError, y.__getitem__, b'a')\n",
                "\n",
                "        def test_multiple_field_name_unicode(self):\n",
                "            def test_assign_unicode():\n",
                "                dt = np.dtype([(\"\\u20B9\", \"f8\"),\n",
                "                               (\"B\", \"f8\"),\n",
                "                               (\"\\u20B9\", \"f8\")])\n",
                "\n",
                "            # Error raised when multiple fields have the same name(unicode included)\n",
                "            assert_raises(ValueError, test_assign_unicode)\n",
                "\n",
                "    else:\n",
                "        def test_unicode_field_titles(self):\n",
                "            # Unicode field titles are added to field dict on Py2\n",
                "            title = u'b'\n",
                "            dt = np.dtype([((title, 'a'), int)])\n",
                "            dt[title]\n",
                "            dt['a']\n",
                "            x = np.array([(1,), (2,), (3,)], dtype=dt)\n",
                "            x[title]\n",
                "            x['a']\n",
                "            y = x[0]\n",
                "            y[title]\n",
                "            y['a']\n",
                "\n",
                "        def test_unicode_field_names(self):\n",
                "            # Unicode field names are not allowed on Py2\n",
                "            title = u'b'\n",
                "            assert_raises(TypeError, np.dtype, [(title, int)])\n",
                "            assert_raises(TypeError, np.dtype, [(('a', title), int)])\n",
                "\n",
                "    def test_field_names(self):\n",
                "        # Test unicode and 8-bit / byte strings can be used\n",
                "        a = np.zeros((1,), dtype=[('f1', 'i4'),\n",
                "                                  ('f2', 'i4'),\n",
                "                                  ('f3', [('sf1', 'i4')])])\n",
                "        is_py3 = sys.version_info[0] >= 3\n",
                "        if is_py3:\n",
                "            funcs = (str,)\n",
                "            # byte string indexing fails gracefully\n",
                "            assert_raises(IndexError, a.__setitem__, b'f1', 1)\n",
                "            assert_raises(IndexError, a.__getitem__, b'f1')\n",
                "            assert_raises(IndexError, a['f1'].__setitem__, b'sf1', 1)\n",
                "            assert_raises(IndexError, a['f1'].__getitem__, b'sf1')\n",
                "        else:\n",
                "            funcs = (str, unicode)\n",
                "        for func in funcs:\n",
                "            b = a.copy()\n",
                "            fn1 = func('f1')\n",
                "            b[fn1] = 1\n",
                "            assert_equal(b[fn1], 1)\n",
                "            fnn = func('not at all')\n",
                "            assert_raises(ValueError, b.__setitem__, fnn, 1)\n",
                "            assert_raises(ValueError, b.__getitem__, fnn)\n",
                "            b[0][fn1] = 2\n",
                "            assert_equal(b[fn1], 2)\n",
                "            # Subfield\n",
                "            assert_raises(ValueError, b[0].__setitem__, fnn, 1)\n",
                "            assert_raises(ValueError, b[0].__getitem__, fnn)\n",
                "            # Subfield\n",
                "            fn3 = func('f3')\n",
                "            sfn1 = func('sf1')\n",
                "            b[fn3][sfn1] = 1\n",
                "            assert_equal(b[fn3][sfn1], 1)\n",
                "            assert_raises(ValueError, b[fn3].__setitem__, fnn, 1)\n",
                "            assert_raises(ValueError, b[fn3].__getitem__, fnn)\n",
                "            # multiple subfields\n",
                "            fn2 = func('f2')\n",
                "            b[fn2] = 3\n",
                "            with suppress_warnings() as sup:\n",
                "                sup.filter(FutureWarning,\n",
                "                           \"Assignment between structured arrays.*\")\n",
                "                sup.filter(FutureWarning,\n",
                "                           \"Numpy has detected that you .*\")\n",
                "\n",
                "                assert_equal(b[['f1', 'f2']][0].tolist(), (2, 3))\n",
                "                assert_equal(b[['f2', 'f1']][0].tolist(), (3, 2))\n",
                "                assert_equal(b[['f1', 'f3']][0].tolist(), (2, (1,)))\n",
                "                # view of subfield view/copy\n",
                "                assert_equal(b[['f1', 'f2']][0].view(('i4', 2)).tolist(),\n",
                "                             (2, 3))\n",
                "                assert_equal(b[['f2', 'f1']][0].view(('i4', 2)).tolist(),\n",
                "                             (3, 2))\n",
                "                view_dtype = [('f1', 'i4'), ('f3', [('', 'i4')])]\n",
                "                assert_equal(b[['f1', 'f3']][0].view(view_dtype).tolist(),\n",
                "                             (2, (1,)))\n",
                "        # non-ascii unicode field indexing is well behaved\n",
                "        if not is_py3:\n",
                "            raise SkipTest('non ascii unicode field indexing skipped; '\n",
                "                           'raises segfault on python 2.x')\n",
                "        else:\n",
                "            assert_raises(ValueError, a.__setitem__, u'\\u03e0', 1)\n",
                "            assert_raises(ValueError, a.__getitem__, u'\\u03e0')\n",
                "\n",
                "    def test_field_names_deprecation(self):\n",
                "\n",
                "        def collect_warnings(f, *args, **kwargs):\n",
                "            with warnings.catch_warnings(record=True) as log:\n",
                "                warnings.simplefilter(\"always\")\n",
                "                f(*args, **kwargs)\n",
                "            return [w.category for w in log]\n",
                "\n",
                "        a = np.zeros((1,), dtype=[('f1', 'i4'),\n",
                "                                  ('f2', 'i4'),\n",
                "                                  ('f3', [('sf1', 'i4')])])\n",
                "        a['f1'][0] = 1\n",
                "        a['f2'][0] = 2\n",
                "        a['f3'][0] = (3,)\n",
                "        b = np.zeros((1,), dtype=[('f1', 'i4'),\n",
                "                                  ('f2', 'i4'),\n",
                "                                  ('f3', [('sf1', 'i4')])])\n",
                "        b['f1'][0] = 1\n",
                "        b['f2'][0] = 2\n",
                "        b['f3'][0] = (3,)\n",
                "\n",
                "        # All the different functions raise a warning, but not an error\n",
                "        assert_equal(collect_warnings(a[['f1', 'f2']].__setitem__, 0, (10, 20)),\n",
                "                     [FutureWarning])\n",
                "        # For <=1.12 a is not modified, but it will be in 1.13\n",
                "        assert_equal(a, b)\n",
                "\n",
                "        # Views also warn\n",
                "        subset = a[['f1', 'f2']]\n",
                "        subset_view = subset.view()\n",
                "        assert_equal(collect_warnings(subset_view['f1'].__setitem__, 0, 10),\n",
                "                     [FutureWarning])\n",
                "        # But the write goes through:\n",
                "        assert_equal(subset['f1'][0], 10)\n",
                "        # Only one warning per multiple field indexing, though (even if there\n",
                "        # are multiple views involved):\n",
                "        assert_equal(collect_warnings(subset['f1'].__setitem__, 0, 10), [])\n",
                "\n",
                "        # make sure views of a multi-field index warn too\n",
                "        c = np.zeros(3, dtype='i8,i8,i8')\n",
                "        assert_equal(collect_warnings(c[['f0', 'f2']].view, 'i8,i8'),\n",
                "                     [FutureWarning])\n",
                "\n",
                "        # make sure assignment using a different dtype warns\n",
                "        a = np.zeros(2, dtype=[('a', 'i4'), ('b', 'i4')])\n",
                "        b = np.zeros(2, dtype=[('b', 'i4'), ('a', 'i4')])\n",
                "        assert_equal(collect_warnings(a.__setitem__, (), b), [FutureWarning])\n",
                "\n",
                "    def test_record_hash(self):\n",
                "        a = np.array([(1, 2), (1, 2)], dtype='i1,i2')\n",
                "        a.flags.writeable = False\n",
                "        b = np.array([(1, 2), (3, 4)], dtype=[('num1', 'i1'), ('num2', 'i2')])\n",
                "        b.flags.writeable = False\n",
                "        c = np.array([(1, 2), (3, 4)], dtype='i1,i2')\n",
                "        c.flags.writeable = False\n",
                "        self.assertTrue(hash(a[0]) == hash(a[1]))\n",
                "        self.assertTrue(hash(a[0]) == hash(b[0]))\n",
                "        self.assertTrue(hash(a[0]) != hash(b[1]))\n",
                "        self.assertTrue(hash(c[0]) == hash(a[0]) and c[0] == a[0])\n",
                "\n",
                "    def test_record_no_hash(self):\n",
                "        a = np.array([(1, 2), (1, 2)], dtype='i1,i2')\n",
                "        self.assertRaises(TypeError, hash, a[0])\n",
                "\n",
                "    def test_empty_structure_creation(self):\n",
                "        # make sure these do not raise errors (gh-5631)\n",
                "        np.array([()], dtype={'names': [], 'formats': [],\n",
                "                           'offsets': [], 'itemsize': 12})\n",
                "        np.array([(), (), (), (), ()], dtype={'names': [], 'formats': [],\n",
                "                                           'offsets': [], 'itemsize': 12})\n",
                "\n",
                "class TestView(TestCase):\n",
                "    def test_basic(self):\n",
                "        x = np.array([(1, 2, 3, 4), (5, 6, 7, 8)],\n",
                "                     dtype=[('r', np.int8), ('g', np.int8),\n",
                "                            ('b', np.int8), ('a', np.int8)])\n",
                "        # We must be specific about the endianness here:\n",
                "        y = x.view(dtype='<i4')\n",
                "        # ... and again without the keyword.\n",
                "        z = x.view('<i4')\n",
                "        assert_array_equal(y, z)\n",
                "        assert_array_equal(y, [67305985, 134678021])\n",
                "\n",
                "\n",
                "def _mean(a, **args):\n",
                "    return a.mean(**args)\n",
                "\n",
                "\n",
                "def _var(a, **args):\n",
                "    return a.var(**args)\n",
                "\n",
                "\n",
                "def _std(a, **args):\n",
                "    return a.std(**args)\n",
                "\n",
                "\n",
                "class TestStats(TestCase):\n",
                "\n",
                "    funcs = [_mean, _var, _std]\n",
                "\n",
                "    def setUp(self):\n",
                "        np.random.seed(range(3))\n",
                "        self.rmat = np.random.random((4, 5))\n",
                "        self.cmat = self.rmat + 1j * self.rmat\n",
                "        self.omat = np.array([Decimal(repr(r)) for r in self.rmat.flat])\n",
                "        self.omat = self.omat.reshape(4, 5)\n",
                "\n",
                "    def test_python_type(self):\n",
                "        for x in (np.float16(1.), 1, 1., 1+0j):\n",
                "            assert_equal(np.mean([x]), 1.)\n",
                "            assert_equal(np.std([x]), 0.)\n",
                "            assert_equal(np.var([x]), 0.)\n",
                "\n",
                "    def test_keepdims(self):\n",
                "        mat = np.eye(3)\n",
                "        for f in self.funcs:\n",
                "            for axis in [0, 1]:\n",
                "                res = f(mat, axis=axis, keepdims=True)\n",
                "                assert_(res.ndim == mat.ndim)\n",
                "                assert_(res.shape[axis] == 1)\n",
                "            for axis in [None]:\n",
                "                res = f(mat, axis=axis, keepdims=True)\n",
                "                assert_(res.shape == (1, 1))\n",
                "\n",
                "    def test_out(self):\n",
                "        mat = np.eye(3)\n",
                "        for f in self.funcs:\n",
                "            out = np.zeros(3)\n",
                "            tgt = f(mat, axis=1)\n",
                "            res = f(mat, axis=1, out=out)\n",
                "            assert_almost_equal(res, out)\n",
                "            assert_almost_equal(res, tgt)\n",
                "        out = np.empty(2)\n",
                "        assert_raises(ValueError, f, mat, axis=1, out=out)\n",
                "        out = np.empty((2, 2))\n",
                "        assert_raises(ValueError, f, mat, axis=1, out=out)\n",
                "\n",
                "    def test_dtype_from_input(self):\n",
                "\n",
                "        icodes = np.typecodes['AllInteger']\n",
                "        fcodes = np.typecodes['AllFloat']\n",
                "\n",
                "        # object type\n",
                "        for f in self.funcs:\n",
                "            mat = np.array([[Decimal(1)]*3]*3)\n",
                "            tgt = mat.dtype.type\n",
                "            res = f(mat, axis=1).dtype.type\n",
                "            assert_(res is tgt)\n",
                "            # scalar case\n",
                "            res = type(f(mat, axis=None))\n",
                "            assert_(res is Decimal)\n",
                "\n",
                "        # integer types\n",
                "        for f in self.funcs:\n",
                "            for c in icodes:\n",
                "                mat = np.eye(3, dtype=c)\n",
                "                tgt = np.float64\n",
                "                res = f(mat, axis=1).dtype.type\n",
                "                assert_(res is tgt)\n",
                "                # scalar case\n",
                "                res = f(mat, axis=None).dtype.type\n",
                "                assert_(res is tgt)\n",
                "\n",
                "        # mean for float types\n",
                "        for f in [_mean]:\n",
                "            for c in fcodes:\n",
                "                mat = np.eye(3, dtype=c)\n",
                "                tgt = mat.dtype.type\n",
                "                res = f(mat, axis=1).dtype.type\n",
                "                assert_(res is tgt)\n",
                "                # scalar case\n",
                "                res = f(mat, axis=None).dtype.type\n",
                "                assert_(res is tgt)\n",
                "\n",
                "        # var, std for float types\n",
                "        for f in [_var, _std]:\n",
                "            for c in fcodes:\n",
                "                mat = np.eye(3, dtype=c)\n",
                "                # deal with complex types\n",
                "                tgt = mat.real.dtype.type\n",
                "                res = f(mat, axis=1).dtype.type\n",
                "                assert_(res is tgt)\n",
                "                # scalar case\n",
                "                res = f(mat, axis=None).dtype.type\n",
                "                assert_(res is tgt)\n",
                "\n",
                "    def test_dtype_from_dtype(self):\n",
                "        mat = np.eye(3)\n",
                "\n",
                "        # stats for integer types\n",
                "        # FIXME:\n",
                "        # this needs definition as there are lots places along the line\n",
                "        # where type casting may take place.\n",
                "\n",
                "        # for f in self.funcs:\n",
                "        #    for c in np.typecodes['AllInteger']:\n",
                "        #        tgt = np.dtype(c).type\n",
                "        #        res = f(mat, axis=1, dtype=c).dtype.type\n",
                "        #        assert_(res is tgt)\n",
                "        #        # scalar case\n",
                "        #        res = f(mat, axis=None, dtype=c).dtype.type\n",
                "        #        assert_(res is tgt)\n",
                "\n",
                "        # stats for float types\n",
                "        for f in self.funcs:\n",
                "            for c in np.typecodes['AllFloat']:\n",
                "                tgt = np.dtype(c).type\n",
                "                res = f(mat, axis=1, dtype=c).dtype.type\n",
                "                assert_(res is tgt)\n",
                "                # scalar case\n",
                "                res = f(mat, axis=None, dtype=c).dtype.type\n",
                "                assert_(res is tgt)\n",
                "\n",
                "    def test_ddof(self):\n",
                "        for f in [_var]:\n",
                "            for ddof in range(3):\n",
                "                dim = self.rmat.shape[1]\n",
                "                tgt = f(self.rmat, axis=1) * dim\n",
                "                res = f(self.rmat, axis=1, ddof=ddof) * (dim - ddof)\n",
                "        for f in [_std]:\n",
                "            for ddof in range(3):\n",
                "                dim = self.rmat.shape[1]\n",
                "                tgt = f(self.rmat, axis=1) * np.sqrt(dim)\n",
                "                res = f(self.rmat, axis=1, ddof=ddof) * np.sqrt(dim - ddof)\n",
                "                assert_almost_equal(res, tgt)\n",
                "                assert_almost_equal(res, tgt)\n",
                "\n",
                "    def test_ddof_too_big(self):\n",
                "        dim = self.rmat.shape[1]\n",
                "        for f in [_var, _std]:\n",
                "            for ddof in range(dim, dim + 2):\n",
                "                with warnings.catch_warnings(record=True) as w:\n",
                "                    warnings.simplefilter('always')\n",
                "                    res = f(self.rmat, axis=1, ddof=ddof)\n",
                "                    assert_(not (res < 0).any())\n",
                "                    assert_(len(w) > 0)\n",
                "                    assert_(issubclass(w[0].category, RuntimeWarning))\n",
                "\n",
                "    def test_empty(self):\n",
                "        A = np.zeros((0, 3))\n",
                "        for f in self.funcs:\n",
                "            for axis in [0, None]:\n",
                "                with warnings.catch_warnings(record=True) as w:\n",
                "                    warnings.simplefilter('always')\n",
                "                    assert_(np.isnan(f(A, axis=axis)).all())\n",
                "                    assert_(len(w) > 0)\n",
                "                    assert_(issubclass(w[0].category, RuntimeWarning))\n",
                "            for axis in [1]:\n",
                "                with warnings.catch_warnings(record=True) as w:\n",
                "                    warnings.simplefilter('always')\n",
                "                    assert_equal(f(A, axis=axis), np.zeros([]))\n",
                "\n",
                "    def test_mean_values(self):\n",
                "        for mat in [self.rmat, self.cmat, self.omat]:\n",
                "            for axis in [0, 1]:\n",
                "                tgt = mat.sum(axis=axis)\n",
                "                res = _mean(mat, axis=axis) * mat.shape[axis]\n",
                "                assert_almost_equal(res, tgt)\n",
                "            for axis in [None]:\n",
                "                tgt = mat.sum(axis=axis)\n",
                "                res = _mean(mat, axis=axis) * np.prod(mat.shape)\n",
                "                assert_almost_equal(res, tgt)\n",
                "\n",
                "    def test_mean_float16(self):\n",
                "        # This fail if the sum inside mean is done in float16 instead\n",
                "        # of float32.\n",
                "        assert _mean(np.ones(100000, dtype='float16')) == 1\n",
                "\n",
                "    def test_var_values(self):\n",
                "        for mat in [self.rmat, self.cmat, self.omat]:\n",
                "            for axis in [0, 1, None]:\n",
                "                msqr = _mean(mat * mat.conj(), axis=axis)\n",
                "                mean = _mean(mat, axis=axis)\n",
                "                tgt = msqr - mean * mean.conjugate()\n",
                "                res = _var(mat, axis=axis)\n",
                "                assert_almost_equal(res, tgt)\n",
                "\n",
                "    def test_std_values(self):\n",
                "        for mat in [self.rmat, self.cmat, self.omat]:\n",
                "            for axis in [0, 1, None]:\n",
                "                tgt = np.sqrt(_var(mat, axis=axis))\n",
                "                res = _std(mat, axis=axis)\n",
                "                assert_almost_equal(res, tgt)\n",
                "\n",
                "    def test_subclass(self):\n",
                "        class TestArray(np.ndarray):\n",
                "            def __new__(cls, data, info):\n",
                "                result = np.array(data)\n",
                "                result = result.view(cls)\n",
                "                result.info = info\n",
                "                return result\n",
                "\n",
                "            def __array_finalize__(self, obj):\n",
                "                self.info = getattr(obj, \"info\", '')\n",
                "\n",
                "        dat = TestArray([[1, 2, 3, 4], [5, 6, 7, 8]], 'jubba')\n",
                "        res = dat.mean(1)\n",
                "        assert_(res.info == dat.info)\n",
                "        res = dat.std(1)\n",
                "        assert_(res.info == dat.info)\n",
                "        res = dat.var(1)\n",
                "        assert_(res.info == dat.info)\n",
                "\n",
                "class TestVdot(TestCase):\n",
                "    def test_basic(self):\n",
                "        dt_numeric = np.typecodes['AllFloat'] + np.typecodes['AllInteger']\n",
                "        dt_complex = np.typecodes['Complex']\n",
                "\n",
                "        # test real\n",
                "        a = np.eye(3)\n",
                "        for dt in dt_numeric + 'O':\n",
                "            b = a.astype(dt)\n",
                "            res = np.vdot(b, b)\n",
                "            assert_(np.isscalar(res))\n",
                "            assert_equal(np.vdot(b, b), 3)\n",
                "\n",
                "        # test complex\n",
                "        a = np.eye(3) * 1j\n",
                "        for dt in dt_complex + 'O':\n",
                "            b = a.astype(dt)\n",
                "            res = np.vdot(b, b)\n",
                "            assert_(np.isscalar(res))\n",
                "            assert_equal(np.vdot(b, b), 3)\n",
                "\n",
                "        # test boolean\n",
                "        b = np.eye(3, dtype=np.bool)\n",
                "        res = np.vdot(b, b)\n",
                "        assert_(np.isscalar(res))\n",
                "        assert_equal(np.vdot(b, b), True)\n",
                "\n",
                "    def test_vdot_array_order(self):\n",
                "        a = np.array([[1, 2], [3, 4]], order='C')\n",
                "        b = np.array([[1, 2], [3, 4]], order='F')\n",
                "        res = np.vdot(a, a)\n",
                "\n",
                "        # integer arrays are exact\n",
                "        assert_equal(np.vdot(a, b), res)\n",
                "        assert_equal(np.vdot(b, a), res)\n",
                "        assert_equal(np.vdot(b, b), res)\n",
                "\n",
                "    def test_vdot_uncontiguous(self):\n",
                "        for size in [2, 1000]:\n",
                "            # Different sizes match different branches in vdot.\n",
                "            a = np.zeros((size, 2, 2))\n",
                "            b = np.zeros((size, 2, 2))\n",
                "            a[:, 0, 0] = np.arange(size)\n",
                "            b[:, 0, 0] = np.arange(size) + 1\n",
                "            # Make a and b uncontiguous:\n",
                "            a = a[..., 0]\n",
                "            b = b[..., 0]\n",
                "\n",
                "            assert_equal(np.vdot(a, b),\n",
                "                         np.vdot(a.flatten(), b.flatten()))\n",
                "            assert_equal(np.vdot(a, b.copy()),\n",
                "                         np.vdot(a.flatten(), b.flatten()))\n",
                "            assert_equal(np.vdot(a.copy(), b),\n",
                "                         np.vdot(a.flatten(), b.flatten()))\n",
                "            assert_equal(np.vdot(a.copy('F'), b),\n",
                "                         np.vdot(a.flatten(), b.flatten()))\n",
                "            assert_equal(np.vdot(a, b.copy('F')),\n",
                "                         np.vdot(a.flatten(), b.flatten()))\n",
                "\n",
                "\n",
                "class TestDot(TestCase):\n",
                "    def setUp(self):\n",
                "        np.random.seed(128)\n",
                "        self.A = np.random.rand(4, 2)\n",
                "        self.b1 = np.random.rand(2, 1)\n",
                "        self.b2 = np.random.rand(2)\n",
                "        self.b3 = np.random.rand(1, 2)\n",
                "        self.b4 = np.random.rand(4)\n",
                "        self.N = 7\n",
                "\n",
                "    def test_dotmatmat(self):\n",
                "        A = self.A\n",
                "        res = np.dot(A.transpose(), A)\n",
                "        tgt = np.array([[1.45046013, 0.86323640],\n",
                "                        [0.86323640, 0.84934569]])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotmatvec(self):\n",
                "        A, b1 = self.A, self.b1\n",
                "        res = np.dot(A, b1)\n",
                "        tgt = np.array([[0.32114320], [0.04889721],\n",
                "                        [0.15696029], [0.33612621]])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotmatvec2(self):\n",
                "        A, b2 = self.A, self.b2\n",
                "        res = np.dot(A, b2)\n",
                "        tgt = np.array([0.29677940, 0.04518649, 0.14468333, 0.31039293])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotvecmat(self):\n",
                "        A, b4 = self.A, self.b4\n",
                "        res = np.dot(b4, A)\n",
                "        tgt = np.array([1.23495091, 1.12222648])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotvecmat2(self):\n",
                "        b3, A = self.b3, self.A\n",
                "        res = np.dot(b3, A.transpose())\n",
                "        tgt = np.array([[0.58793804, 0.08957460, 0.30605758, 0.62716383]])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotvecmat3(self):\n",
                "        A, b4 = self.A, self.b4\n",
                "        res = np.dot(A.transpose(), b4)\n",
                "        tgt = np.array([1.23495091, 1.12222648])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotvecvecouter(self):\n",
                "        b1, b3 = self.b1, self.b3\n",
                "        res = np.dot(b1, b3)\n",
                "        tgt = np.array([[0.20128610, 0.08400440], [0.07190947, 0.03001058]])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotvecvecinner(self):\n",
                "        b1, b3 = self.b1, self.b3\n",
                "        res = np.dot(b3, b1)\n",
                "        tgt = np.array([[ 0.23129668]])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotcolumnvect1(self):\n",
                "        b1 = np.ones((3, 1))\n",
                "        b2 = [5.3]\n",
                "        res = np.dot(b1, b2)\n",
                "        tgt = np.array([5.3, 5.3, 5.3])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotcolumnvect2(self):\n",
                "        b1 = np.ones((3, 1)).transpose()\n",
                "        b2 = [6.2]\n",
                "        res = np.dot(b2, b1)\n",
                "        tgt = np.array([6.2, 6.2, 6.2])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotvecscalar(self):\n",
                "        np.random.seed(100)\n",
                "        b1 = np.random.rand(1, 1)\n",
                "        b2 = np.random.rand(1, 4)\n",
                "        res = np.dot(b1, b2)\n",
                "        tgt = np.array([[0.15126730, 0.23068496, 0.45905553, 0.00256425]])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_dotvecscalar2(self):\n",
                "        np.random.seed(100)\n",
                "        b1 = np.random.rand(4, 1)\n",
                "        b2 = np.random.rand(1, 1)\n",
                "        res = np.dot(b1, b2)\n",
                "        tgt = np.array([[0.00256425],[0.00131359],[0.00200324],[ 0.00398638]])\n",
                "        assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_all(self):\n",
                "        dims = [(), (1,), (1, 1)]\n",
                "        dout = [(), (1,), (1, 1), (1,), (), (1,), (1, 1), (1,), (1, 1)]\n",
                "        for dim, (dim1, dim2) in zip(dout, itertools.product(dims, dims)):\n",
                "            b1 = np.zeros(dim1)\n",
                "            b2 = np.zeros(dim2)\n",
                "            res = np.dot(b1, b2)\n",
                "            tgt = np.zeros(dim)\n",
                "            assert_(res.shape == tgt.shape)\n",
                "            assert_almost_equal(res, tgt, decimal=self.N)\n",
                "\n",
                "    def test_vecobject(self):\n",
                "        class Vec(object):\n",
                "            def __init__(self, sequence=None):\n",
                "                if sequence is None:\n",
                "                    sequence = []\n",
                "                self.array = np.array(sequence)\n",
                "\n",
                "            def __add__(self, other):\n",
                "                out = Vec()\n",
                "                out.array = self.array + other.array\n",
                "                return out\n",
                "\n",
                "            def __sub__(self, other):\n",
                "                out = Vec()\n",
                "                out.array = self.array - other.array\n",
                "                return out\n",
                "\n",
                "            def __mul__(self, other):  # with scalar\n",
                "                out = Vec(self.array.copy())\n",
                "                out.array *= other\n",
                "                return out\n",
                "\n",
                "            def __rmul__(self, other):\n",
                "                return self*other\n",
                "\n",
                "        U_non_cont = np.transpose([[1., 1.], [1., 2.]])\n",
                "        U_cont = np.ascontiguousarray(U_non_cont)\n",
                "        x = np.array([Vec([1., 0.]), Vec([0., 1.])])\n",
                "        zeros = np.array([Vec([0., 0.]), Vec([0., 0.])])\n",
                "        zeros_test = np.dot(U_cont, x) - np.dot(U_non_cont, x)\n",
                "        assert_equal(zeros[0].array, zeros_test[0].array)\n",
                "        assert_equal(zeros[1].array, zeros_test[1].array)\n",
                "\n",
                "    def test_dot_2args(self):\n",
                "        from numpy.core.multiarray import dot\n",
                "\n",
                "        a = np.array([[1, 2], [3, 4]], dtype=float)\n",
                "        b = np.array([[1, 0], [1, 1]], dtype=float)\n",
                "        c = np.array([[3, 2], [7, 4]], dtype=float)\n",
                "\n",
                "        d = dot(a, b)\n",
                "        assert_allclose(c, d)\n",
                "\n",
                "    def test_dot_3args(self):\n",
                "        from numpy.core.multiarray import dot\n",
                "\n",
                "        np.random.seed(22)\n",
                "        f = np.random.random_sample((1024, 16))\n",
                "        v = np.random.random_sample((16, 32))\n",
                "\n",
                "        r = np.empty((1024, 32))\n",
                "        for i in range(12):\n",
                "            dot(f, v, r)\n",
                "        if HAS_REFCOUNT:\n",
                "            assert_equal(sys.getrefcount(r), 2)\n",
                "        r2 = dot(f, v, out=None)\n",
                "        assert_array_equal(r2, r)\n",
                "        assert_(r is dot(f, v, out=r))\n",
                "\n",
                "        v = v[:, 0].copy()  # v.shape == (16,)\n",
                "        r = r[:, 0].copy()  # r.shape == (1024,)\n",
                "        r2 = dot(f, v)\n",
                "        assert_(r is dot(f, v, r))\n",
                "        assert_array_equal(r2, r)\n",
                "\n",
                "    def test_dot_3args_errors(self):\n",
                "        from numpy.core.multiarray import dot\n",
                "\n",
                "        np.random.seed(22)\n",
                "        f = np.random.random_sample((1024, 16))\n",
                "        v = np.random.random_sample((16, 32))\n",
                "\n",
                "        r = np.empty((1024, 31))\n",
                "        assert_raises(ValueError, dot, f, v, r)\n",
                "\n",
                "        r = np.empty((1024,))\n",
                "        assert_raises(ValueError, dot, f, v, r)\n",
                "\n",
                "        r = np.empty((32,))\n",
                "        assert_raises(ValueError, dot, f, v, r)\n",
                "\n",
                "        r = np.empty((32, 1024))\n",
                "        assert_raises(ValueError, dot, f, v, r)\n",
                "        assert_raises(ValueError, dot, f, v, r.T)\n",
                "\n",
                "        r = np.empty((1024, 64))\n",
                "        assert_raises(ValueError, dot, f, v, r[:, ::2])\n",
                "        assert_raises(ValueError, dot, f, v, r[:, :32])\n",
                "\n",
                "        r = np.empty((1024, 32), dtype=np.float32)\n",
                "        assert_raises(ValueError, dot, f, v, r)\n",
                "\n",
                "        r = np.empty((1024, 32), dtype=int)\n",
                "        assert_raises(ValueError, dot, f, v, r)\n",
                "\n",
                "    def test_dot_array_order(self):\n",
                "        a = np.array([[1, 2], [3, 4]], order='C')\n",
                "        b = np.array([[1, 2], [3, 4]], order='F')\n",
                "        res = np.dot(a, a)\n",
                "\n",
                "        # integer arrays are exact\n",
                "        assert_equal(np.dot(a, b), res)\n",
                "        assert_equal(np.dot(b, a), res)\n",
                "        assert_equal(np.dot(b, b), res)\n",
                "\n",
                "    def test_dot_scalar_and_matrix_of_objects(self):\n",
                "        # Ticket #2469\n",
                "        arr = np.matrix([1, 2], dtype=object)\n",
                "        desired = np.matrix([[3, 6]], dtype=object)\n",
                "        assert_equal(np.dot(arr, 3), desired)\n",
                "        assert_equal(np.dot(3, arr), desired)\n",
                "\n",
                "    def test_accelerate_framework_sgemv_fix(self):\n",
                "\n",
                "        def aligned_array(shape, align, dtype, order='C'):\n",
                "            d = dtype(0)\n",
                "            N = np.prod(shape)\n",
                "            tmp = np.zeros(N * d.nbytes + align, dtype=np.uint8)\n",
                "            address = tmp.__array_interface__[\"data\"][0]\n",
                "            for offset in range(align):\n",
                "                if (address + offset) % align == 0:\n",
                "                    break\n",
                "            tmp = tmp[offset:offset+N*d.nbytes].view(dtype=dtype)\n",
                "            return tmp.reshape(shape, order=order)\n",
                "\n",
                "        def as_aligned(arr, align, dtype, order='C'):\n",
                "            aligned = aligned_array(arr.shape, align, dtype, order)\n",
                "            aligned[:] = arr[:]\n",
                "            return aligned\n",
                "\n",
                "        def assert_dot_close(A, X, desired):\n",
                "            assert_allclose(np.dot(A, X), desired, rtol=1e-5, atol=1e-7)\n",
                "\n",
                "        m = aligned_array(100, 15, np.float32)\n",
                "        s = aligned_array((100, 100), 15, np.float32)\n",
                "        np.dot(s, m)  # this will always segfault if the bug is present\n",
                "\n",
                "        testdata = itertools.product((15,32), (10000,), (200,89), ('C','F'))\n",
                "        for align, m, n, a_order in testdata:\n",
                "            # Calculation in double precision\n",
                "            A_d = np.random.rand(m, n)\n",
                "            X_d = np.random.rand(n)\n",
                "            desired = np.dot(A_d, X_d)\n",
                "            # Calculation with aligned single precision\n",
                "            A_f = as_aligned(A_d, align, np.float32, order=a_order)\n",
                "            X_f = as_aligned(X_d, align, np.float32)\n",
                "            assert_dot_close(A_f, X_f, desired)\n",
                "            # Strided A rows\n",
                "            A_d_2 = A_d[::2]\n",
                "            desired = np.dot(A_d_2, X_d)\n",
                "            A_f_2 = A_f[::2]\n",
                "            assert_dot_close(A_f_2, X_f, desired)\n",
                "            # Strided A columns, strided X vector\n",
                "            A_d_22 = A_d_2[:, ::2]\n",
                "            X_d_2 = X_d[::2]\n",
                "            desired = np.dot(A_d_22, X_d_2)\n",
                "            A_f_22 = A_f_2[:, ::2]\n",
                "            X_f_2 = X_f[::2]\n",
                "            assert_dot_close(A_f_22, X_f_2, desired)\n",
                "            # Check the strides are as expected\n",
                "            if a_order == 'F':\n",
                "                assert_equal(A_f_22.strides, (8, 8 * m))\n",
                "            else:\n",
                "                assert_equal(A_f_22.strides, (8 * n, 8))\n",
                "            assert_equal(X_f_2.strides, (8,))\n",
                "            # Strides in A rows + cols only\n",
                "            X_f_2c = as_aligned(X_f_2, align, np.float32)\n",
                "            assert_dot_close(A_f_22, X_f_2c, desired)\n",
                "            # Strides just in A cols\n",
                "            A_d_12 = A_d[:, ::2]\n",
                "            desired = np.dot(A_d_12, X_d_2)\n",
                "            A_f_12 = A_f[:, ::2]\n",
                "            assert_dot_close(A_f_12, X_f_2c, desired)\n",
                "            # Strides in A cols and X\n",
                "            assert_dot_close(A_f_12, X_f_2, desired)\n",
                "\n",
                "\n",
                "class MatmulCommon():\n",
                "    \"\"\"Common tests for '@' operator and numpy.matmul.\n",
                "\n",
                "    Do not derive from TestCase to avoid nose running it.\n",
                "\n",
                "    \"\"\"\n",
                "    # Should work with these types. Will want to add\n",
                "    # \"O\" at some point\n",
                "    types = \"?bhilqBHILQefdgFDG\"\n",
                "\n",
                "    def test_exceptions(self):\n",
                "        dims = [\n",
                "            ((1,), (2,)),            # mismatched vector vector\n",
                "            ((2, 1,), (2,)),         # mismatched matrix vector\n",
                "            ((2,), (1, 2)),          # mismatched vector matrix\n",
                "            ((1, 2), (3, 1)),        # mismatched matrix matrix\n",
                "            ((1,), ()),              # vector scalar\n",
                "            ((), (1)),               # scalar vector\n",
                "            ((1, 1), ()),            # matrix scalar\n",
                "            ((), (1, 1)),            # scalar matrix\n",
                "            ((2, 2, 1), (3, 1, 2)),  # cannot broadcast\n",
                "            ]\n",
                "\n",
                "        for dt, (dm1, dm2) in itertools.product(self.types, dims):\n",
                "            a = np.ones(dm1, dtype=dt)\n",
                "            b = np.ones(dm2, dtype=dt)\n",
                "            assert_raises(ValueError, self.matmul, a, b)\n",
                "\n",
                "    def test_shapes(self):\n",
                "        dims = [\n",
                "            ((1, 1), (2, 1, 1)),     # broadcast first argument\n",
                "            ((2, 1, 1), (1, 1)),     # broadcast second argument\n",
                "            ((2, 1, 1), (2, 1, 1)),  # matrix stack sizes match\n",
                "            ]\n",
                "\n",
                "        for dt, (dm1, dm2) in itertools.product(self.types, dims):\n",
                "            a = np.ones(dm1, dtype=dt)\n",
                "            b = np.ones(dm2, dtype=dt)\n",
                "            res = self.matmul(a, b)\n",
                "            assert_(res.shape == (2, 1, 1))\n",
                "\n",
                "        # vector vector returns scalars.\n",
                "        for dt in self.types:\n",
                "            a = np.ones((2,), dtype=dt)\n",
                "            b = np.ones((2,), dtype=dt)\n",
                "            c = self.matmul(a, b)\n",
                "            assert_(np.array(c).shape == ())\n",
                "\n",
                "    def test_result_types(self):\n",
                "        mat = np.ones((1,1))\n",
                "        vec = np.ones((1,))\n",
                "        for dt in self.types:\n",
                "            m = mat.astype(dt)\n",
                "            v = vec.astype(dt)\n",
                "            for arg in [(m, v), (v, m), (m, m)]:\n",
                "                res = self.matmul(*arg)\n",
                "                assert_(res.dtype == dt)\n",
                "\n",
                "            # vector vector returns scalars\n",
                "            res = self.matmul(v, v)\n",
                "            assert_(type(res) is np.dtype(dt).type)\n",
                "\n",
                "    def test_vector_vector_values(self):\n",
                "        vec = np.array([1, 2])\n",
                "        tgt = 5\n",
                "        for dt in self.types[1:]:\n",
                "            v1 = vec.astype(dt)\n",
                "            res = self.matmul(v1, v1)\n",
                "            assert_equal(res, tgt)\n",
                "\n",
                "        # boolean type\n",
                "        vec = np.array([True, True], dtype='?')\n",
                "        res = self.matmul(vec, vec)\n",
                "        assert_equal(res, True)\n",
                "\n",
                "    def test_vector_matrix_values(self):\n",
                "        vec = np.array([1, 2])\n",
                "        mat1 = np.array([[1, 2], [3, 4]])\n",
                "        mat2 = np.stack([mat1]*2, axis=0)\n",
                "        tgt1 = np.array([7, 10])\n",
                "        tgt2 = np.stack([tgt1]*2, axis=0)\n",
                "        for dt in self.types[1:]:\n",
                "            v = vec.astype(dt)\n",
                "            m1 = mat1.astype(dt)\n",
                "            m2 = mat2.astype(dt)\n",
                "            res = self.matmul(v, m1)\n",
                "            assert_equal(res, tgt1)\n",
                "            res = self.matmul(v, m2)\n",
                "            assert_equal(res, tgt2)\n",
                "\n",
                "        # boolean type\n",
                "        vec = np.array([True, False])\n",
                "        mat1 = np.array([[True, False], [False, True]])\n",
                "        mat2 = np.stack([mat1]*2, axis=0)\n",
                "        tgt1 = np.array([True, False])\n",
                "        tgt2 = np.stack([tgt1]*2, axis=0)\n",
                "\n",
                "        res = self.matmul(vec, mat1)\n",
                "        assert_equal(res, tgt1)\n",
                "        res = self.matmul(vec, mat2)\n",
                "        assert_equal(res, tgt2)\n",
                "\n",
                "    def test_matrix_vector_values(self):\n",
                "        vec = np.array([1, 2])\n",
                "        mat1 = np.array([[1, 2], [3, 4]])\n",
                "        mat2 = np.stack([mat1]*2, axis=0)\n",
                "        tgt1 = np.array([5, 11])\n",
                "        tgt2 = np.stack([tgt1]*2, axis=0)\n",
                "        for dt in self.types[1:]:\n",
                "            v = vec.astype(dt)\n",
                "            m1 = mat1.astype(dt)\n",
                "            m2 = mat2.astype(dt)\n",
                "            res = self.matmul(m1, v)\n",
                "            assert_equal(res, tgt1)\n",
                "            res = self.matmul(m2, v)\n",
                "            assert_equal(res, tgt2)\n",
                "\n",
                "        # boolean type\n",
                "        vec = np.array([True, False])\n",
                "        mat1 = np.array([[True, False], [False, True]])\n",
                "        mat2 = np.stack([mat1]*2, axis=0)\n",
                "        tgt1 = np.array([True, False])\n",
                "        tgt2 = np.stack([tgt1]*2, axis=0)\n",
                "\n",
                "        res = self.matmul(vec, mat1)\n",
                "        assert_equal(res, tgt1)\n",
                "        res = self.matmul(vec, mat2)\n",
                "        assert_equal(res, tgt2)\n",
                "\n",
                "    def test_matrix_matrix_values(self):\n",
                "        mat1 = np.array([[1, 2], [3, 4]])\n",
                "        mat2 = np.array([[1, 0], [1, 1]])\n",
                "        mat12 = np.stack([mat1, mat2], axis=0)\n",
                "        mat21 = np.stack([mat2, mat1], axis=0)\n",
                "        tgt11 = np.array([[7, 10], [15, 22]])\n",
                "        tgt12 = np.array([[3, 2], [7, 4]])\n",
                "        tgt21 = np.array([[1, 2], [4, 6]])\n",
                "        tgt12_21 = np.stack([tgt12, tgt21], axis=0)\n",
                "        tgt11_12 = np.stack((tgt11, tgt12), axis=0)\n",
                "        tgt11_21 = np.stack((tgt11, tgt21), axis=0)\n",
                "        for dt in self.types[1:]:\n",
                "            m1 = mat1.astype(dt)\n",
                "            m2 = mat2.astype(dt)\n",
                "            m12 = mat12.astype(dt)\n",
                "            m21 = mat21.astype(dt)\n",
                "\n",
                "            # matrix @ matrix\n",
                "            res = self.matmul(m1, m2)\n",
                "            assert_equal(res, tgt12)\n",
                "            res = self.matmul(m2, m1)\n",
                "            assert_equal(res, tgt21)\n",
                "\n",
                "            # stacked @ matrix\n",
                "            res = self.matmul(m12, m1)\n",
                "            assert_equal(res, tgt11_21)\n",
                "\n",
                "            # matrix @ stacked\n",
                "            res = self.matmul(m1, m12)\n",
                "            assert_equal(res, tgt11_12)\n",
                "\n",
                "            # stacked @ stacked\n",
                "            res = self.matmul(m12, m21)\n",
                "            assert_equal(res, tgt12_21)\n",
                "\n",
                "        # boolean type\n",
                "        m1 = np.array([[1, 1], [0, 0]], dtype=np.bool_)\n",
                "        m2 = np.array([[1, 0], [1, 1]], dtype=np.bool_)\n",
                "        m12 = np.stack([m1, m2], axis=0)\n",
                "        m21 = np.stack([m2, m1], axis=0)\n",
                "        tgt11 = m1\n",
                "        tgt12 = m1\n",
                "        tgt21 = np.array([[1, 1], [1, 1]], dtype=np.bool_)\n",
                "        tgt12_21 = np.stack([tgt12, tgt21], axis=0)\n",
                "        tgt11_12 = np.stack((tgt11, tgt12), axis=0)\n",
                "        tgt11_21 = np.stack((tgt11, tgt21), axis=0)\n",
                "\n",
                "        # matrix @ matrix\n",
                "        res = self.matmul(m1, m2)\n",
                "        assert_equal(res, tgt12)\n",
                "        res = self.matmul(m2, m1)\n",
                "        assert_equal(res, tgt21)\n",
                "\n",
                "        # stacked @ matrix\n",
                "        res = self.matmul(m12, m1)\n",
                "        assert_equal(res, tgt11_21)\n",
                "\n",
                "        # matrix @ stacked\n",
                "        res = self.matmul(m1, m12)\n",
                "        assert_equal(res, tgt11_12)\n",
                "\n",
                "        # stacked @ stacked\n",
                "        res = self.matmul(m12, m21)\n",
                "        assert_equal(res, tgt12_21)\n",
                "\n",
                "\n",
                "class TestMatmul(MatmulCommon, TestCase):\n",
                "    matmul = np.matmul\n",
                "\n",
                "    def test_out_arg(self):\n",
                "        a = np.ones((2, 2), dtype=np.float)\n",
                "        b = np.ones((2, 2), dtype=np.float)\n",
                "        tgt = np.full((2,2), 2, dtype=np.float)\n",
                "\n",
                "        # test as positional argument\n",
                "        msg = \"out positional argument\"\n",
                "        out = np.zeros((2, 2), dtype=np.float)\n",
                "        self.matmul(a, b, out)\n",
                "        assert_array_equal(out, tgt, err_msg=msg)\n",
                "\n",
                "        # test as keyword argument\n",
                "        msg = \"out keyword argument\"\n",
                "        out = np.zeros((2, 2), dtype=np.float)\n",
                "        self.matmul(a, b, out=out)\n",
                "        assert_array_equal(out, tgt, err_msg=msg)\n",
                "\n",
                "        # test out with not allowed type cast (safe casting)\n",
                "        # einsum and cblas raise different error types, so\n",
                "        # use Exception.\n",
                "        msg = \"out argument with illegal cast\"\n",
                "        out = np.zeros((2, 2), dtype=np.int32)\n",
                "        assert_raises(Exception, self.matmul, a, b, out=out)\n",
                "\n",
                "        # skip following tests for now, cblas does not allow non-contiguous\n",
                "        # outputs and consistency with dot would require same type,\n",
                "        # dimensions, subtype, and c_contiguous.\n",
                "\n",
                "        # test out with allowed type cast\n",
                "        # msg = \"out argument with allowed cast\"\n",
                "        # out = np.zeros((2, 2), dtype=np.complex128)\n",
                "        # self.matmul(a, b, out=out)\n",
                "        # assert_array_equal(out, tgt, err_msg=msg)\n",
                "\n",
                "        # test out non-contiguous\n",
                "        # msg = \"out argument with non-contiguous layout\"\n",
                "        # c = np.zeros((2, 2, 2), dtype=np.float)\n",
                "        # self.matmul(a, b, out=c[..., 0])\n",
                "        # assert_array_equal(c, tgt, err_msg=msg)\n",
                "\n",
                "\n",
                "if sys.version_info[:2] >= (3, 5):\n",
                "    class TestMatmulOperator(MatmulCommon, TestCase):\n",
                "        import operator\n",
                "        matmul = operator.matmul\n",
                "\n",
                "        def test_array_priority_override(self):\n",
                "\n",
                "            class A(object):\n",
                "                __array_priority__ = 1000\n",
                "\n",
                "                def __matmul__(self, other):\n",
                "                    return \"A\"\n",
                "\n",
                "                def __rmatmul__(self, other):\n",
                "                    return \"A\"\n",
                "\n",
                "            a = A()\n",
                "            b = np.ones(2)\n",
                "            assert_equal(self.matmul(a, b), \"A\")\n",
                "            assert_equal(self.matmul(b, a), \"A\")\n",
                "\n",
                "    def test_matmul_inplace():\n",
                "        # It would be nice to support in-place matmul eventually, but for now\n",
                "        # we don't have a working implementation, so better just to error out\n",
                "        # and nudge people to writing \"a = a @ b\".\n",
                "        a = np.eye(3)\n",
                "        b = np.eye(3)\n",
                "        assert_raises(TypeError, a.__imatmul__, b)\n",
                "        import operator\n",
                "        assert_raises(TypeError, operator.imatmul, a, b)\n",
                "        # we avoid writing the token `exec` so as not to crash python 2's\n",
                "        # parser\n",
                "        exec_ = getattr(builtins, \"exec\")\n",
                "        assert_raises(TypeError, exec_, \"a @= b\", globals(), locals())\n",
                "\n",
                "\n",
                "class TestInner(TestCase):\n",
                "\n",
                "    def test_inner_type_mismatch(self):\n",
                "        c = 1.\n",
                "        A = np.array((1,1), dtype='i,i')\n",
                "\n",
                "        assert_raises(TypeError, np.inner, c, A)\n",
                "        assert_raises(TypeError, np.inner, A, c)\n",
                "\n",
                "    def test_inner_scalar_and_vector(self):\n",
                "        for dt in np.typecodes['AllInteger'] + np.typecodes['AllFloat'] + '?':\n",
                "            sca = np.array(3, dtype=dt)[()]\n",
                "            vec = np.array([1, 2], dtype=dt)\n",
                "            desired = np.array([3, 6], dtype=dt)\n",
                "            assert_equal(np.inner(vec, sca), desired)\n",
                "            assert_equal(np.inner(sca, vec), desired)\n",
                "\n",
                "    def test_inner_scalar_and_matrix(self):\n",
                "        for dt in np.typecodes['AllInteger'] + np.typecodes['AllFloat'] + '?':\n",
                "            sca = np.array(3, dtype=dt)[()]\n",
                "            arr = np.matrix([[1, 2], [3, 4]], dtype=dt)\n",
                "            desired = np.matrix([[3, 6], [9, 12]], dtype=dt)\n",
                "            assert_equal(np.inner(arr, sca), desired)\n",
                "            assert_equal(np.inner(sca, arr), desired)\n",
                "\n",
                "    def test_inner_scalar_and_matrix_of_objects(self):\n",
                "        # Ticket #4482\n",
                "        arr = np.matrix([1, 2], dtype=object)\n",
                "        desired = np.matrix([[3, 6]], dtype=object)\n",
                "        assert_equal(np.inner(arr, 3), desired)\n",
                "        assert_equal(np.inner(3, arr), desired)\n",
                "\n",
                "    def test_vecself(self):\n",
                "        # Ticket 844.\n",
                "        # Inner product of a vector with itself segfaults or give\n",
                "        # meaningless result\n",
                "        a = np.zeros(shape=(1, 80), dtype=np.float64)\n",
                "        p = np.inner(a, a)\n",
                "        assert_almost_equal(p, 0, decimal=14)\n",
                "\n",
                "    def test_inner_product_with_various_contiguities(self):\n",
                "        # github issue 6532\n",
                "        for dt in np.typecodes['AllInteger'] + np.typecodes['AllFloat'] + '?':\n",
                "            # check an inner product involving a matrix transpose\n",
                "            A = np.array([[1, 2], [3, 4]], dtype=dt)\n",
                "            B = np.array([[1, 3], [2, 4]], dtype=dt)\n",
                "            C = np.array([1, 1], dtype=dt)\n",
                "            desired = np.array([4, 6], dtype=dt)\n",
                "            assert_equal(np.inner(A.T, C), desired)\n",
                "            assert_equal(np.inner(C, A.T), desired)\n",
                "            assert_equal(np.inner(B, C), desired)\n",
                "            assert_equal(np.inner(C, B), desired)\n",
                "            # check a matrix product\n",
                "            desired = np.array([[7, 10], [15, 22]], dtype=dt)\n",
                "            assert_equal(np.inner(A, B), desired)\n",
                "            # check the syrk vs. gemm paths\n",
                "            desired = np.array([[5, 11], [11, 25]], dtype=dt)\n",
                "            assert_equal(np.inner(A, A), desired)\n",
                "            assert_equal(np.inner(A, A.copy()), desired)\n",
                "            # check an inner product involving an aliased and reversed view\n",
                "            a = np.arange(5).astype(dt)\n",
                "            b = a[::-1]\n",
                "            desired = np.array(10, dtype=dt).item()\n",
                "            assert_equal(np.inner(b, a), desired)\n",
                "\n",
                "    def test_3d_tensor(self):\n",
                "        for dt in np.typecodes['AllInteger'] + np.typecodes['AllFloat'] + '?':\n",
                "            a = np.arange(24).reshape(2,3,4).astype(dt)\n",
                "            b = np.arange(24, 48).reshape(2,3,4).astype(dt)\n",
                "            desired = np.array(\n",
                "                [[[[ 158,  182,  206],\n",
                "                   [ 230,  254,  278]],\n",
                "\n",
                "                  [[ 566,  654,  742],\n",
                "                   [ 830,  918, 1006]],\n",
                "\n",
                "                  [[ 974, 1126, 1278],\n",
                "                   [1430, 1582, 1734]]],\n",
                "\n",
                "                 [[[1382, 1598, 1814],\n",
                "                   [2030, 2246, 2462]],\n",
                "\n",
                "                  [[1790, 2070, 2350],\n",
                "                   [2630, 2910, 3190]],\n",
                "\n",
                "                  [[2198, 2542, 2886],\n",
                "                   [3230, 3574, 3918]]]],\n",
                "                dtype=dt\n",
                "            )\n",
                "            assert_equal(np.inner(a, b), desired)\n",
                "            assert_equal(np.inner(b, a).transpose(2,3,0,1), desired)\n",
                "\n",
                "\n",
                "class TestSummarization(TestCase):\n",
                "    def test_1d(self):\n",
                "        A = np.arange(1001)\n",
                "        strA = '[   0    1    2 ...,  998  999 1000]'\n",
                "        assert_(str(A) == strA)\n",
                "\n",
                "        reprA = 'array([   0,    1,    2, ...,  998,  999, 1000])'\n",
                "        assert_(repr(A) == reprA)\n",
                "\n",
                "    def test_2d(self):\n",
                "        A = np.arange(1002).reshape(2, 501)\n",
                "        strA = '[[   0    1    2 ...,  498  499  500]\\n' \\\n",
                "               ' [ 501  502  503 ...,  999 1000 1001]]'\n",
                "        assert_(str(A) == strA)\n",
                "\n",
                "        reprA = 'array([[   0,    1,    2, ...,  498,  499,  500],\\n' \\\n",
                "                '       [ 501,  502,  503, ...,  999, 1000, 1001]])'\n",
                "        assert_(repr(A) == reprA)\n",
                "\n",
                "\n",
                "class TestAlen(TestCase):\n",
                "    def test_basic(self):\n",
                "        m = np.array([1, 2, 3])\n",
                "        self.assertEqual(np.alen(m), 3)\n",
                "\n",
                "        m = np.array([[1, 2, 3], [4, 5, 7]])\n",
                "        self.assertEqual(np.alen(m), 2)\n",
                "\n",
                "        m = [1, 2, 3]\n",
                "        self.assertEqual(np.alen(m), 3)\n",
                "\n",
                "        m = [[1, 2, 3], [4, 5, 7]]\n",
                "        self.assertEqual(np.alen(m), 2)\n",
                "\n",
                "    def test_singleton(self):\n",
                "        self.assertEqual(np.alen(5), 1)\n",
                "\n",
                "\n",
                "class TestChoose(TestCase):\n",
                "    def setUp(self):\n",
                "        self.x = 2*np.ones((3,), dtype=int)\n",
                "        self.y = 3*np.ones((3,), dtype=int)\n",
                "        self.x2 = 2*np.ones((2, 3), dtype=int)\n",
                "        self.y2 = 3*np.ones((2, 3), dtype=int)\n",
                "        self.ind = [0, 0, 1]\n",
                "\n",
                "    def test_basic(self):\n",
                "        A = np.choose(self.ind, (self.x, self.y))\n",
                "        assert_equal(A, [2, 2, 3])\n",
                "\n",
                "    def test_broadcast1(self):\n",
                "        A = np.choose(self.ind, (self.x2, self.y2))\n",
                "        assert_equal(A, [[2, 2, 3], [2, 2, 3]])\n",
                "\n",
                "    def test_broadcast2(self):\n",
                "        A = np.choose(self.ind, (self.x, self.y2))\n",
                "        assert_equal(A, [[2, 2, 3], [2, 2, 3]])\n",
                "\n",
                "\n",
                "class TestRepeat(TestCase):\n",
                "    def setUp(self):\n",
                "        self.m = np.array([1, 2, 3, 4, 5, 6])\n",
                "        self.m_rect = self.m.reshape((2, 3))\n",
                "\n",
                "    def test_basic(self):\n",
                "        A = np.repeat(self.m, [1, 3, 2, 1, 1, 2])\n",
                "        assert_equal(A, [1, 2, 2, 2, 3,\n",
                "                         3, 4, 5, 6, 6])\n",
                "\n",
                "    def test_broadcast1(self):\n",
                "        A = np.repeat(self.m, 2)\n",
                "        assert_equal(A, [1, 1, 2, 2, 3, 3,\n",
                "                         4, 4, 5, 5, 6, 6])\n",
                "\n",
                "    def test_axis_spec(self):\n",
                "        A = np.repeat(self.m_rect, [2, 1], axis=0)\n",
                "        assert_equal(A, [[1, 2, 3],\n",
                "                         [1, 2, 3],\n",
                "                         [4, 5, 6]])\n",
                "\n",
                "        A = np.repeat(self.m_rect, [1, 3, 2], axis=1)\n",
                "        assert_equal(A, [[1, 2, 2, 2, 3, 3],\n",
                "                         [4, 5, 5, 5, 6, 6]])\n",
                "\n",
                "    def test_broadcast2(self):\n",
                "        A = np.repeat(self.m_rect, 2, axis=0)\n",
                "        assert_equal(A, [[1, 2, 3],\n",
                "                         [1, 2, 3],\n",
                "                         [4, 5, 6],\n",
                "                         [4, 5, 6]])\n",
                "\n",
                "        A = np.repeat(self.m_rect, 2, axis=1)\n",
                "        assert_equal(A, [[1, 1, 2, 2, 3, 3],\n",
                "                         [4, 4, 5, 5, 6, 6]])\n",
                "\n",
                "\n",
                "# TODO: test for multidimensional\n",
                "NEIGH_MODE = {'zero': 0, 'one': 1, 'constant': 2, 'circular': 3, 'mirror': 4}\n",
                "\n",
                "\n",
                "class TestNeighborhoodIter(TestCase):\n",
                "    # Simple, 2d tests\n",
                "    def _test_simple2d(self, dt):\n",
                "        # Test zero and one padding for simple data type\n",
                "        x = np.array([[0, 1], [2, 3]], dtype=dt)\n",
                "        r = [np.array([[0, 0, 0], [0, 0, 1]], dtype=dt),\n",
                "             np.array([[0, 0, 0], [0, 1, 0]], dtype=dt),\n",
                "             np.array([[0, 0, 1], [0, 2, 3]], dtype=dt),\n",
                "             np.array([[0, 1, 0], [2, 3, 0]], dtype=dt)]\n",
                "        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], x[0],\n",
                "                NEIGH_MODE['zero'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        r = [np.array([[1, 1, 1], [1, 0, 1]], dtype=dt),\n",
                "             np.array([[1, 1, 1], [0, 1, 1]], dtype=dt),\n",
                "             np.array([[1, 0, 1], [1, 2, 3]], dtype=dt),\n",
                "             np.array([[0, 1, 1], [2, 3, 1]], dtype=dt)]\n",
                "        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], x[0],\n",
                "                NEIGH_MODE['one'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        r = [np.array([[4, 4, 4], [4, 0, 1]], dtype=dt),\n",
                "             np.array([[4, 4, 4], [0, 1, 4]], dtype=dt),\n",
                "             np.array([[4, 0, 1], [4, 2, 3]], dtype=dt),\n",
                "             np.array([[0, 1, 4], [2, 3, 4]], dtype=dt)]\n",
                "        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], 4,\n",
                "                NEIGH_MODE['constant'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "    def test_simple2d(self):\n",
                "        self._test_simple2d(np.float)\n",
                "\n",
                "    def test_simple2d_object(self):\n",
                "        self._test_simple2d(Decimal)\n",
                "\n",
                "    def _test_mirror2d(self, dt):\n",
                "        x = np.array([[0, 1], [2, 3]], dtype=dt)\n",
                "        r = [np.array([[0, 0, 1], [0, 0, 1]], dtype=dt),\n",
                "             np.array([[0, 1, 1], [0, 1, 1]], dtype=dt),\n",
                "             np.array([[0, 0, 1], [2, 2, 3]], dtype=dt),\n",
                "             np.array([[0, 1, 1], [2, 3, 3]], dtype=dt)]\n",
                "        l = test_neighborhood_iterator(x, [-1, 0, -1, 1], x[0],\n",
                "                NEIGH_MODE['mirror'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "    def test_mirror2d(self):\n",
                "        self._test_mirror2d(np.float)\n",
                "\n",
                "    def test_mirror2d_object(self):\n",
                "        self._test_mirror2d(Decimal)\n",
                "\n",
                "    # Simple, 1d tests\n",
                "    def _test_simple(self, dt):\n",
                "        # Test padding with constant values\n",
                "        x = np.linspace(1, 5, 5).astype(dt)\n",
                "        r = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 0]]\n",
                "        l = test_neighborhood_iterator(x, [-1, 1], x[0], NEIGH_MODE['zero'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        r = [[1, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 1]]\n",
                "        l = test_neighborhood_iterator(x, [-1, 1], x[0], NEIGH_MODE['one'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        r = [[x[4], 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, x[4]]]\n",
                "        l = test_neighborhood_iterator(x, [-1, 1], x[4], NEIGH_MODE['constant'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "    def test_simple_float(self):\n",
                "        self._test_simple(np.float)\n",
                "\n",
                "    def test_simple_object(self):\n",
                "        self._test_simple(Decimal)\n",
                "\n",
                "    # Test mirror modes\n",
                "    def _test_mirror(self, dt):\n",
                "        x = np.linspace(1, 5, 5).astype(dt)\n",
                "        r = np.array([[2, 1, 1, 2, 3], [1, 1, 2, 3, 4], [1, 2, 3, 4, 5],\n",
                "                [2, 3, 4, 5, 5], [3, 4, 5, 5, 4]], dtype=dt)\n",
                "        l = test_neighborhood_iterator(x, [-2, 2], x[1], NEIGH_MODE['mirror'])\n",
                "        self.assertTrue([i.dtype == dt for i in l])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "    def test_mirror(self):\n",
                "        self._test_mirror(np.float)\n",
                "\n",
                "    def test_mirror_object(self):\n",
                "        self._test_mirror(Decimal)\n",
                "\n",
                "    # Circular mode\n",
                "    def _test_circular(self, dt):\n",
                "        x = np.linspace(1, 5, 5).astype(dt)\n",
                "        r = np.array([[4, 5, 1, 2, 3], [5, 1, 2, 3, 4], [1, 2, 3, 4, 5],\n",
                "                [2, 3, 4, 5, 1], [3, 4, 5, 1, 2]], dtype=dt)\n",
                "        l = test_neighborhood_iterator(x, [-2, 2], x[0], NEIGH_MODE['circular'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "    def test_circular(self):\n",
                "        self._test_circular(np.float)\n",
                "\n",
                "    def test_circular_object(self):\n",
                "        self._test_circular(Decimal)\n",
                "\n",
                "# Test stacking neighborhood iterators\n",
                "class TestStackedNeighborhoodIter(TestCase):\n",
                "    # Simple, 1d test: stacking 2 constant-padded neigh iterators\n",
                "    def test_simple_const(self):\n",
                "        dt = np.float64\n",
                "        # Test zero and one padding for simple data type\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([0], dtype=dt),\n",
                "             np.array([0], dtype=dt),\n",
                "             np.array([1], dtype=dt),\n",
                "             np.array([2], dtype=dt),\n",
                "             np.array([3], dtype=dt),\n",
                "             np.array([0], dtype=dt),\n",
                "             np.array([0], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [-2, 4], NEIGH_MODE['zero'],\n",
                "                [0, 0], NEIGH_MODE['zero'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        r = [np.array([1, 0, 1], dtype=dt),\n",
                "             np.array([0, 1, 2], dtype=dt),\n",
                "             np.array([1, 2, 3], dtype=dt),\n",
                "             np.array([2, 3, 0], dtype=dt),\n",
                "             np.array([3, 0, 1], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n",
                "                [-1, 1], NEIGH_MODE['one'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "    # 2nd simple, 1d test: stacking 2 neigh iterators, mixing const padding and\n",
                "    # mirror padding\n",
                "    def test_simple_mirror(self):\n",
                "        dt = np.float64\n",
                "        # Stacking zero on top of mirror\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([0, 1, 1], dtype=dt),\n",
                "             np.array([1, 1, 2], dtype=dt),\n",
                "             np.array([1, 2, 3], dtype=dt),\n",
                "             np.array([2, 3, 3], dtype=dt),\n",
                "             np.array([3, 3, 0], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['mirror'],\n",
                "                [-1, 1], NEIGH_MODE['zero'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        # Stacking mirror on top of zero\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([1, 0, 0], dtype=dt),\n",
                "             np.array([0, 0, 1], dtype=dt),\n",
                "             np.array([0, 1, 2], dtype=dt),\n",
                "             np.array([1, 2, 3], dtype=dt),\n",
                "             np.array([2, 3, 0], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n",
                "                [-2, 0], NEIGH_MODE['mirror'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        # Stacking mirror on top of zero: 2nd\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([0, 1, 2], dtype=dt),\n",
                "             np.array([1, 2, 3], dtype=dt),\n",
                "             np.array([2, 3, 0], dtype=dt),\n",
                "             np.array([3, 0, 0], dtype=dt),\n",
                "             np.array([0, 0, 3], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n",
                "                [0, 2], NEIGH_MODE['mirror'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        # Stacking mirror on top of zero: 3rd\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([1, 0, 0, 1, 2], dtype=dt),\n",
                "             np.array([0, 0, 1, 2, 3], dtype=dt),\n",
                "             np.array([0, 1, 2, 3, 0], dtype=dt),\n",
                "             np.array([1, 2, 3, 0, 0], dtype=dt),\n",
                "             np.array([2, 3, 0, 0, 3], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n",
                "                [-2, 2], NEIGH_MODE['mirror'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "    # 3rd simple, 1d test: stacking 2 neigh iterators, mixing const padding and\n",
                "    # circular padding\n",
                "    def test_simple_circular(self):\n",
                "        dt = np.float64\n",
                "        # Stacking zero on top of mirror\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([0, 3, 1], dtype=dt),\n",
                "             np.array([3, 1, 2], dtype=dt),\n",
                "             np.array([1, 2, 3], dtype=dt),\n",
                "             np.array([2, 3, 1], dtype=dt),\n",
                "             np.array([3, 1, 0], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['circular'],\n",
                "                [-1, 1], NEIGH_MODE['zero'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        # Stacking mirror on top of zero\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([3, 0, 0], dtype=dt),\n",
                "             np.array([0, 0, 1], dtype=dt),\n",
                "             np.array([0, 1, 2], dtype=dt),\n",
                "             np.array([1, 2, 3], dtype=dt),\n",
                "             np.array([2, 3, 0], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n",
                "                [-2, 0], NEIGH_MODE['circular'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        # Stacking mirror on top of zero: 2nd\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([0, 1, 2], dtype=dt),\n",
                "             np.array([1, 2, 3], dtype=dt),\n",
                "             np.array([2, 3, 0], dtype=dt),\n",
                "             np.array([3, 0, 0], dtype=dt),\n",
                "             np.array([0, 0, 1], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n",
                "                [0, 2], NEIGH_MODE['circular'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        # Stacking mirror on top of zero: 3rd\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([3, 0, 0, 1, 2], dtype=dt),\n",
                "             np.array([0, 0, 1, 2, 3], dtype=dt),\n",
                "             np.array([0, 1, 2, 3, 0], dtype=dt),\n",
                "             np.array([1, 2, 3, 0, 0], dtype=dt),\n",
                "             np.array([2, 3, 0, 0, 1], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [-1, 3], NEIGH_MODE['zero'],\n",
                "                [-2, 2], NEIGH_MODE['circular'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "    # 4th simple, 1d test: stacking 2 neigh iterators, but with lower iterator\n",
                "    # being strictly within the array\n",
                "    def test_simple_strict_within(self):\n",
                "        dt = np.float64\n",
                "        # Stacking zero on top of zero, first neighborhood strictly inside the\n",
                "        # array\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([1, 2, 3, 0], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [1, 1], NEIGH_MODE['zero'],\n",
                "                [-1, 2], NEIGH_MODE['zero'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        # Stacking mirror on top of zero, first neighborhood strictly inside the\n",
                "        # array\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([1, 2, 3, 3], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [1, 1], NEIGH_MODE['zero'],\n",
                "                [-1, 2], NEIGH_MODE['mirror'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "        # Stacking mirror on top of zero, first neighborhood strictly inside the\n",
                "        # array\n",
                "        x = np.array([1, 2, 3], dtype=dt)\n",
                "        r = [np.array([1, 2, 3, 1], dtype=dt)]\n",
                "        l = test_neighborhood_iterator_oob(x, [1, 1], NEIGH_MODE['zero'],\n",
                "                [-1, 2], NEIGH_MODE['circular'])\n",
                "        assert_array_equal(l, r)\n",
                "\n",
                "class TestWarnings(object):\n",
                "\n",
                "    def test_complex_warning(self):\n",
                "        x = np.array([1, 2])\n",
                "        y = np.array([1-2j, 1+2j])\n",
                "\n",
                "        with warnings.catch_warnings():\n",
                "            warnings.simplefilter(\"error\", np.ComplexWarning)\n",
                "            assert_raises(np.ComplexWarning, x.__setitem__, slice(None), y)\n",
                "            assert_equal(x, [1, 2])\n",
                "\n",
                "\n",
                "class TestMinScalarType(object):\n",
                "\n",
                "    def test_usigned_shortshort(self):\n",
                "        dt = np.min_scalar_type(2**8-1)\n",
                "        wanted = np.dtype('uint8')\n",
                "        assert_equal(wanted, dt)\n",
                "\n",
                "    def test_usigned_short(self):\n",
                "        dt = np.min_scalar_type(2**16-1)\n",
                "        wanted = np.dtype('uint16')\n",
                "        assert_equal(wanted, dt)\n",
                "\n",
                "    def test_usigned_int(self):\n",
                "        dt = np.min_scalar_type(2**32-1)\n",
                "        wanted = np.dtype('uint32')\n",
                "        assert_equal(wanted, dt)\n",
                "\n",
                "    def test_usigned_longlong(self):\n",
                "        dt = np.min_scalar_type(2**63-1)\n",
                "        wanted = np.dtype('uint64')\n",
                "        assert_equal(wanted, dt)\n",
                "\n",
                "    def test_object(self):\n",
                "        dt = np.min_scalar_type(2**64)\n",
                "        wanted = np.dtype('O')\n",
                "        assert_equal(wanted, dt)\n",
                "\n",
                "\n",
                "from numpy.core._internal import _dtype_from_pep3118\n",
                "\n",
                "\n",
                "class TestPEP3118Dtype(object):\n",
                "    def _check(self, spec, wanted):\n",
                "        dt = np.dtype(wanted)\n",
                "        actual = _dtype_from_pep3118(spec)\n",
                "        assert_equal(actual, dt,\n",
                "                     err_msg=\"spec %r != dtype %r\" % (spec, wanted))\n",
                "\n",
                "    def test_native_padding(self):\n",
                "        align = np.dtype('i').alignment\n",
                "        for j in range(8):\n",
                "            if j == 0:\n",
                "                s = 'bi'\n",
                "            else:\n",
                "                s = 'b%dxi' % j\n",
                "            self._check('@'+s, {'f0': ('i1', 0),\n",
                "                                'f1': ('i', align*(1 + j//align))})\n",
                "            self._check('='+s, {'f0': ('i1', 0),\n",
                "                                'f1': ('i', 1+j)})\n",
                "\n",
                "    def test_native_padding_2(self):\n",
                "        # Native padding should work also for structs and sub-arrays\n",
                "        self._check('x3T{xi}', {'f0': (({'f0': ('i', 4)}, (3,)), 4)})\n",
                "        self._check('^x3T{xi}', {'f0': (({'f0': ('i', 1)}, (3,)), 1)})\n",
                "\n",
                "    def test_trailing_padding(self):\n",
                "        # Trailing padding should be included, *and*, the item size\n",
                "        # should match the alignment if in aligned mode\n",
                "        align = np.dtype('i').alignment\n",
                "        size = np.dtype('i').itemsize\n",
                "\n",
                "        def aligned(n):\n",
                "            return align*(1 + (n-1)//align)\n",
                "\n",
                "        base = dict(formats=['i'], names=['f0'])\n",
                "\n",
                "        self._check('ix',    dict(itemsize=aligned(size + 1), **base))\n",
                "        self._check('ixx',   dict(itemsize=aligned(size + 2), **base))\n",
                "        self._check('ixxx',  dict(itemsize=aligned(size + 3), **base))\n",
                "        self._check('ixxxx', dict(itemsize=aligned(size + 4), **base))\n",
                "        self._check('i7x',   dict(itemsize=aligned(size + 7), **base))\n",
                "\n",
                "        self._check('^ix',    dict(itemsize=size + 1, **base))\n",
                "        self._check('^ixx',   dict(itemsize=size + 2, **base))\n",
                "        self._check('^ixxx',  dict(itemsize=size + 3, **base))\n",
                "        self._check('^ixxxx', dict(itemsize=size + 4, **base))\n",
                "        self._check('^i7x',   dict(itemsize=size + 7, **base))\n",
                "\n",
                "    def test_native_padding_3(self):\n",
                "        dt = np.dtype(\n",
                "                [('a', 'b'), ('b', 'i'),\n",
                "                    ('sub', np.dtype('b,i')), ('c', 'i')],\n",
                "                align=True)\n",
                "        self._check(\"T{b:a:xxxi:b:T{b:f0:=i:f1:}:sub:xxxi:c:}\", dt)\n",
                "\n",
                "        dt = np.dtype(\n",
                "                [('a', 'b'), ('b', 'i'), ('c', 'b'), ('d', 'b'),\n",
                "                    ('e', 'b'), ('sub', np.dtype('b,i', align=True))])\n",
                "        self._check(\"T{b:a:=i:b:b:c:b:d:b:e:T{b:f0:xxxi:f1:}:sub:}\", dt)\n",
                "\n",
                "    def test_padding_with_array_inside_struct(self):\n",
                "        dt = np.dtype(\n",
                "                [('a', 'b'), ('b', 'i'), ('c', 'b', (3,)),\n",
                "                    ('d', 'i')],\n",
                "                align=True)\n",
                "        self._check(\"T{b:a:xxxi:b:3b:c:xi:d:}\", dt)\n",
                "\n",
                "    def test_byteorder_inside_struct(self):\n",
                "        # The byte order after @T{=i} should be '=', not '@'.\n",
                "        # Check this by noting the absence of native alignment.\n",
                "        self._check('@T{^i}xi', {'f0': ({'f0': ('i', 0)}, 0),\n",
                "                                 'f1': ('i', 5)})\n",
                "\n",
                "    def test_intra_padding(self):\n",
                "        # Natively aligned sub-arrays may require some internal padding\n",
                "        align = np.dtype('i').alignment\n",
                "        size = np.dtype('i').itemsize\n",
                "\n",
                "        def aligned(n):\n",
                "            return (align*(1 + (n-1)//align))\n",
                "\n",
                "        self._check('(3)T{ix}', (dict(\n",
                "            names=['f0'],\n",
                "            formats=['i'],\n",
                "            offsets=[0],\n",
                "            itemsize=aligned(size + 1)\n",
                "        ), (3,)))\n",
                "\n",
                "    def test_char_vs_string(self):\n",
                "        dt = np.dtype('c')\n",
                "        self._check('c', dt)\n",
                "\n",
                "        dt = np.dtype([('f0', 'S1', (4,)), ('f1', 'S4')])\n",
                "        self._check('4c4s', dt)\n",
                "\n",
                "    def test_field_order(self):\n",
                "        # gh-9053 - previously, we relied on dictionary key order\n",
                "        self._check(\"(0)I:a:f:b:\", [('a', 'I', (0,)), ('b', 'f')])\n",
                "        self._check(\"(0)I:b:f:a:\", [('b', 'I', (0,)), ('a', 'f')])\n",
                "\n",
                "    def test_unnamed_fields(self):\n",
                "        self._check('ii',     [('f0', 'i'), ('f1', 'i')])\n",
                "        self._check('ii:f0:', [('f1', 'i'), ('f0', 'i')])\n",
                "\n",
                "        self._check('i', 'i')\n",
                "        self._check('i:f0:', [('f0', 'i')])\n",
                "\n",
                "class TestNewBufferProtocol(object):\n",
                "    def _check_roundtrip(self, obj):\n",
                "        obj = np.asarray(obj)\n",
                "        x = memoryview(obj)\n",
                "        y = np.asarray(x)\n",
                "        y2 = np.array(x)\n",
                "        assert_(not y.flags.owndata)\n",
                "        assert_(y2.flags.owndata)\n",
                "\n",
                "        assert_equal(y.dtype, obj.dtype)\n",
                "        assert_equal(y.shape, obj.shape)\n",
                "        assert_array_equal(obj, y)\n",
                "\n",
                "        assert_equal(y2.dtype, obj.dtype)\n",
                "        assert_equal(y2.shape, obj.shape)\n",
                "        assert_array_equal(obj, y2)\n",
                "\n",
                "    def test_roundtrip(self):\n",
                "        x = np.array([1, 2, 3, 4, 5], dtype='i4')\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "        x = np.array([[1, 2], [3, 4]], dtype=np.float64)\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "        x = np.zeros((3, 3, 3), dtype=np.float32)[:, 0,:]\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "        dt = [('a', 'b'),\n",
                "              ('b', 'h'),\n",
                "              ('c', 'i'),\n",
                "              ('d', 'l'),\n",
                "              ('dx', 'q'),\n",
                "              ('e', 'B'),\n",
                "              ('f', 'H'),\n",
                "              ('g', 'I'),\n",
                "              ('h', 'L'),\n",
                "              ('hx', 'Q'),\n",
                "              ('i', np.single),\n",
                "              ('j', np.double),\n",
                "              ('k', np.longdouble),\n",
                "              ('ix', np.csingle),\n",
                "              ('jx', np.cdouble),\n",
                "              ('kx', np.clongdouble),\n",
                "              ('l', 'S4'),\n",
                "              ('m', 'U4'),\n",
                "              ('n', 'V3'),\n",
                "              ('o', '?'),\n",
                "              ('p', np.half),\n",
                "              ]\n",
                "        x = np.array(\n",
                "                [(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n",
                "                    b'aaaa', 'bbbb', b'xxx', True, 1.0)],\n",
                "                dtype=dt)\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "        x = np.array(([[1, 2], [3, 4]],), dtype=[('a', (int, (2, 2)))])\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "        x = np.array([1, 2, 3], dtype='>i2')\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "        x = np.array([1, 2, 3], dtype='<i2')\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "        x = np.array([1, 2, 3], dtype='>i4')\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "        x = np.array([1, 2, 3], dtype='<i4')\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "        # check long long can be represented as non-native\n",
                "        x = np.array([1, 2, 3], dtype='>q')\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "        # Native-only data types can be passed through the buffer interface\n",
                "        # only in native byte order\n",
                "        if sys.byteorder == 'little':\n",
                "            x = np.array([1, 2, 3], dtype='>g')\n",
                "            assert_raises(ValueError, self._check_roundtrip, x)\n",
                "            x = np.array([1, 2, 3], dtype='<g')\n",
                "            self._check_roundtrip(x)\n",
                "        else:\n",
                "            x = np.array([1, 2, 3], dtype='>g')\n",
                "            self._check_roundtrip(x)\n",
                "            x = np.array([1, 2, 3], dtype='<g')\n",
                "            assert_raises(ValueError, self._check_roundtrip, x)\n",
                "\n",
                "    def test_roundtrip_half(self):\n",
                "        half_list = [\n",
                "            1.0,\n",
                "            -2.0,\n",
                "            6.5504 * 10**4,  # (max half precision)\n",
                "            2**-14,  # ~= 6.10352 * 10**-5 (minimum positive normal)\n",
                "            2**-24,  # ~= 5.96046 * 10**-8 (minimum strictly positive subnormal)\n",
                "            0.0,\n",
                "            -0.0,\n",
                "            float('+inf'),\n",
                "            float('-inf'),\n",
                "            0.333251953125,  # ~= 1/3\n",
                "        ]\n",
                "\n",
                "        x = np.array(half_list, dtype='>e')\n",
                "        self._check_roundtrip(x)\n",
                "        x = np.array(half_list, dtype='<e')\n",
                "        self._check_roundtrip(x)\n",
                "\n",
                "    def test_roundtrip_single_types(self):\n",
                "        for typ in np.typeDict.values():\n",
                "            dtype = np.dtype(typ)\n",
                "\n",
                "            if dtype.char in 'Mm':\n",
                "                # datetimes cannot be used in buffers\n",
                "                continue\n",
                "            if dtype.char == 'V':\n",
                "                # skip void\n",
                "                continue\n",
                "\n",
                "            x = np.zeros(4, dtype=dtype)\n",
                "            self._check_roundtrip(x)\n",
                "\n",
                "            if dtype.char not in 'qQgG':\n",
                "                dt = dtype.newbyteorder('<')\n",
                "                x = np.zeros(4, dtype=dt)\n",
                "                self._check_roundtrip(x)\n",
                "\n",
                "                dt = dtype.newbyteorder('>')\n",
                "                x = np.zeros(4, dtype=dt)\n",
                "                self._check_roundtrip(x)\n",
                "\n",
                "    def test_roundtrip_scalar(self):\n",
                "        # Issue #4015.\n",
                "        self._check_roundtrip(0)\n",
                "\n",
                "    def test_export_simple_1d(self):\n",
                "        x = np.array([1, 2, 3, 4, 5], dtype='i')\n",
                "        y = memoryview(x)\n",
                "        assert_equal(y.format, 'i')\n",
                "        assert_equal(y.shape, (5,))\n",
                "        assert_equal(y.ndim, 1)\n",
                "        assert_equal(y.strides, (4,))\n",
                "        assert_equal(y.suboffsets, EMPTY)\n",
                "        assert_equal(y.itemsize, 4)\n",
                "\n",
                "    def test_export_simple_nd(self):\n",
                "        x = np.array([[1, 2], [3, 4]], dtype=np.float64)\n",
                "        y = memoryview(x)\n",
                "        assert_equal(y.format, 'd')\n",
                "        assert_equal(y.shape, (2, 2))\n",
                "        assert_equal(y.ndim, 2)\n",
                "        assert_equal(y.strides, (16, 8))\n",
                "        assert_equal(y.suboffsets, EMPTY)\n",
                "        assert_equal(y.itemsize, 8)\n",
                "\n",
                "    def test_export_discontiguous(self):\n",
                "        x = np.zeros((3, 3, 3), dtype=np.float32)[:, 0,:]\n",
                "        y = memoryview(x)\n",
                "        assert_equal(y.format, 'f')\n",
                "        assert_equal(y.shape, (3, 3))\n",
                "        assert_equal(y.ndim, 2)\n",
                "        assert_equal(y.strides, (36, 4))\n",
                "        assert_equal(y.suboffsets, EMPTY)\n",
                "        assert_equal(y.itemsize, 4)\n",
                "\n",
                "    def test_export_record(self):\n",
                "        dt = [('a', 'b'),\n",
                "              ('b', 'h'),\n",
                "              ('c', 'i'),\n",
                "              ('d', 'l'),\n",
                "              ('dx', 'q'),\n",
                "              ('e', 'B'),\n",
                "              ('f', 'H'),\n",
                "              ('g', 'I'),\n",
                "              ('h', 'L'),\n",
                "              ('hx', 'Q'),\n",
                "              ('i', np.single),\n",
                "              ('j', np.double),\n",
                "              ('k', np.longdouble),\n",
                "              ('ix', np.csingle),\n",
                "              ('jx', np.cdouble),\n",
                "              ('kx', np.clongdouble),\n",
                "              ('l', 'S4'),\n",
                "              ('m', 'U4'),\n",
                "              ('n', 'V3'),\n",
                "              ('o', '?'),\n",
                "              ('p', np.half),\n",
                "              ]\n",
                "        x = np.array(\n",
                "                [(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n",
                "                    b'aaaa', 'bbbb', b'   ', True, 1.0)],\n",
                "                dtype=dt)\n",
                "        y = memoryview(x)\n",
                "        assert_equal(y.shape, (1,))\n",
                "        assert_equal(y.ndim, 1)\n",
                "        assert_equal(y.suboffsets, EMPTY)\n",
                "\n",
                "        sz = sum([np.dtype(b).itemsize for a, b in dt])\n",
                "        if np.dtype('l').itemsize == 4:\n",
                "            assert_equal(y.format, 'T{b:a:=h:b:i:c:l:d:q:dx:B:e:@H:f:=I:g:L:h:Q:hx:f:i:d:j:^g:k:=Zf:ix:Zd:jx:^Zg:kx:4s:l:=4w:m:3x:n:?:o:@e:p:}')\n",
                "        else:\n",
                "            assert_equal(y.format, 'T{b:a:=h:b:i:c:q:d:q:dx:B:e:@H:f:=I:g:Q:h:Q:hx:f:i:d:j:^g:k:=Zf:ix:Zd:jx:^Zg:kx:4s:l:=4w:m:3x:n:?:o:@e:p:}')\n",
                "        # Cannot test if NPY_RELAXED_STRIDES_CHECKING changes the strides\n",
                "        if not (np.ones(1).strides[0] == np.iinfo(np.intp).max):\n",
                "            assert_equal(y.strides, (sz,))\n",
                "        assert_equal(y.itemsize, sz)\n",
                "\n",
                "    def test_export_subarray(self):\n",
                "        x = np.array(([[1, 2], [3, 4]],), dtype=[('a', ('i', (2, 2)))])\n",
                "        y = memoryview(x)\n",
                "        assert_equal(y.format, 'T{(2,2)i:a:}')\n",
                "        assert_equal(y.shape, EMPTY)\n",
                "        assert_equal(y.ndim, 0)\n",
                "        assert_equal(y.strides, EMPTY)\n",
                "        assert_equal(y.suboffsets, EMPTY)\n",
                "        assert_equal(y.itemsize, 16)\n",
                "\n",
                "    def test_export_endian(self):\n",
                "        x = np.array([1, 2, 3], dtype='>i')\n",
                "        y = memoryview(x)\n",
                "        if sys.byteorder == 'little':\n",
                "            assert_equal(y.format, '>i')\n",
                "        else:\n",
                "            assert_equal(y.format, 'i')\n",
                "\n",
                "        x = np.array([1, 2, 3], dtype='<i')\n",
                "        y = memoryview(x)\n",
                "        if sys.byteorder == 'little':\n",
                "            assert_equal(y.format, 'i')\n",
                "        else:\n",
                "            assert_equal(y.format, '<i')\n",
                "\n",
                "    def test_export_flags(self):\n",
                "        # Check SIMPLE flag, see also gh-3613 (exception should be BufferError)\n",
                "        assert_raises(ValueError, get_buffer_info, np.arange(5)[::2], ('SIMPLE',))\n",
                "\n",
                "    def test_padding(self):\n",
                "        for j in range(8):\n",
                "            x = np.array([(1,), (2,)], dtype={'f0': (int, j)})\n",
                "            self._check_roundtrip(x)\n",
                "\n",
                "    def test_reference_leak(self):\n",
                "        if HAS_REFCOUNT:\n",
                "            count_1 = sys.getrefcount(np.core._internal)\n",
                "        a = np.zeros(4)\n",
                "        b = memoryview(a)\n",
                "        c = np.asarray(b)\n",
                "        if HAS_REFCOUNT:\n",
                "            count_2 = sys.getrefcount(np.core._internal)\n",
                "            assert_equal(count_1, count_2)\n",
                "        del c  # avoid pyflakes unused variable warning.\n",
                "\n",
                "    def test_padded_struct_array(self):\n",
                "        dt1 = np.dtype(\n",
                "                [('a', 'b'), ('b', 'i'), ('sub', np.dtype('b,i')), ('c', 'i')],\n",
                "                align=True)\n",
                "        x1 = np.arange(dt1.itemsize, dtype=np.int8).view(dt1)\n",
                "        self._check_roundtrip(x1)\n",
                "\n",
                "        dt2 = np.dtype(\n",
                "                [('a', 'b'), ('b', 'i'), ('c', 'b', (3,)), ('d', 'i')],\n",
                "                align=True)\n",
                "        x2 = np.arange(dt2.itemsize, dtype=np.int8).view(dt2)\n",
                "        self._check_roundtrip(x2)\n",
                "\n",
                "        dt3 = np.dtype(\n",
                "                [('a', 'b'), ('b', 'i'), ('c', 'b'), ('d', 'b'),\n",
                "                    ('e', 'b'), ('sub', np.dtype('b,i', align=True))])\n",
                "        x3 = np.arange(dt3.itemsize, dtype=np.int8).view(dt3)\n",
                "        self._check_roundtrip(x3)\n",
                "\n",
                "    def test_relaxed_strides(self):\n",
                "        # Test that relaxed strides are converted to non-relaxed\n",
                "        c = np.ones((1, 10, 10), dtype='i8')\n",
                "\n",
                "        # Check for NPY_RELAXED_STRIDES_CHECKING:\n",
                "        if np.ones((10, 1), order=\"C\").flags.f_contiguous:\n",
                "            c.strides = (-1, 80, 8)\n",
                "\n",
                "        assert_(memoryview(c).strides == (800, 80, 8))\n",
                "\n",
                "        # Writing C-contiguous data to a BytesIO buffer should work\n",
                "        fd = io.BytesIO()\n",
                "        fd.write(c.data)\n",
                "\n",
                "        fortran = c.T\n",
                "        assert_(memoryview(fortran).strides == (8, 80, 800))\n",
                "\n",
                "        arr = np.ones((1, 10))\n",
                "        if arr.flags.f_contiguous:\n",
                "            shape, strides = get_buffer_info(arr, ['F_CONTIGUOUS'])\n",
                "            assert_(strides[0] == 8)\n",
                "            arr = np.ones((10, 1), order='F')\n",
                "            shape, strides = get_buffer_info(arr, ['C_CONTIGUOUS'])\n",
                "            assert_(strides[-1] == 8)\n",
                "\n",
                "\n",
                "class TestArrayAttributeDeletion(object):\n",
                "\n",
                "    def test_multiarray_writable_attributes_deletion(self):\n",
                "        # ticket #2046, should not seqfault, raise AttributeError\n",
                "        a = np.ones(2)\n",
                "        attr = ['shape', 'strides', 'data', 'dtype', 'real', 'imag', 'flat']\n",
                "        with suppress_warnings() as sup:\n",
                "            sup.filter(DeprecationWarning, \"Assigning the 'data' attribute\")\n",
                "            for s in attr:\n",
                "                assert_raises(AttributeError, delattr, a, s)\n",
                "\n",
                "    def test_multiarray_not_writable_attributes_deletion(self):\n",
                "        a = np.ones(2)\n",
                "        attr = [\"ndim\", \"flags\", \"itemsize\", \"size\", \"nbytes\", \"base\",\n",
                "                \"ctypes\", \"T\", \"__array_interface__\", \"__array_struct__\",\n",
                "                \"__array_priority__\", \"__array_finalize__\"]\n",
                "        for s in attr:\n",
                "            assert_raises(AttributeError, delattr, a, s)\n",
                "\n",
                "    def test_multiarray_flags_writable_attribute_deletion(self):\n",
                "        a = np.ones(2).flags\n",
                "        attr = ['updateifcopy', 'aligned', 'writeable']\n",
                "        for s in attr:\n",
                "            assert_raises(AttributeError, delattr, a, s)\n",
                "\n",
                "    def test_multiarray_flags_not_writable_attribute_deletion(self):\n",
                "        a = np.ones(2).flags\n",
                "        attr = [\"contiguous\", \"c_contiguous\", \"f_contiguous\", \"fortran\",\n",
                "                \"owndata\", \"fnc\", \"forc\", \"behaved\", \"carray\", \"farray\",\n",
                "                \"num\"]\n",
                "        for s in attr:\n",
                "            assert_raises(AttributeError, delattr, a, s)\n",
                "\n",
                "\n",
                "def test_array_interface():\n",
                "    # Test scalar coercion within the array interface\n",
                "    class Foo(object):\n",
                "        def __init__(self, value):\n",
                "            self.value = value\n",
                "            self.iface = {'typestr': '=f8'}\n",
                "\n",
                "        def __float__(self):\n",
                "            return float(self.value)\n",
                "\n",
                "        @property\n",
                "        def __array_interface__(self):\n",
                "            return self.iface\n",
                "\n",
                "    f = Foo(0.5)\n",
                "    assert_equal(np.array(f), 0.5)\n",
                "    assert_equal(np.array([f]), [0.5])\n",
                "    assert_equal(np.array([f, f]), [0.5, 0.5])\n",
                "    assert_equal(np.array(f).dtype, np.dtype('=f8'))\n",
                "    # Test various shape definitions\n",
                "    f.iface['shape'] = ()\n",
                "    assert_equal(np.array(f), 0.5)\n",
                "    f.iface['shape'] = None\n",
                "    assert_raises(TypeError, np.array, f)\n",
                "    f.iface['shape'] = (1, 1)\n",
                "    assert_equal(np.array(f), [[0.5]])\n",
                "    f.iface['shape'] = (2,)\n",
                "    assert_raises(ValueError, np.array, f)\n",
                "\n",
                "    # test scalar with no shape\n",
                "    class ArrayLike(object):\n",
                "        array = np.array(1)\n",
                "        __array_interface__ = array.__array_interface__\n",
                "    assert_equal(np.array(ArrayLike()), 1)\n",
                "\n",
                "\n",
                "def test_array_interface_itemsize():\n",
                "    # See gh-6361\n",
                "    my_dtype = np.dtype({'names': ['A', 'B'], 'formats': ['f4', 'f4'],\n",
                "                         'offsets': [0, 8], 'itemsize': 16})\n",
                "    a = np.ones(10, dtype=my_dtype)\n",
                "    descr_t = np.dtype(a.__array_interface__['descr'])\n",
                "    typestr_t = np.dtype(a.__array_interface__['typestr'])\n",
                "    assert_equal(descr_t.itemsize, typestr_t.itemsize)\n",
                "\n",
                "\n",
                "def test_flat_element_deletion():\n",
                "    it = np.ones(3).flat\n",
                "    try:\n",
                "        del it[1]\n",
                "        del it[1:2]\n",
                "    except TypeError:\n",
                "        pass\n",
                "    except:\n",
                "        raise AssertionError\n",
                "\n",
                "\n",
                "def test_scalar_element_deletion():\n",
                "    a = np.zeros(2, dtype=[('x', 'int'), ('y', 'int')])\n",
                "    assert_raises(ValueError, a[0].__delitem__, 'x')\n",
                "\n",
                "\n",
                "class TestMemEventHook(TestCase):\n",
                "    def test_mem_seteventhook(self):\n",
                "        # The actual tests are within the C code in\n",
                "        # multiarray/multiarray_tests.c.src\n",
                "        test_pydatamem_seteventhook_start()\n",
                "        # force an allocation and free of a numpy array\n",
                "        # needs to be larger then limit of small memory cacher in ctors.c\n",
                "        a = np.zeros(1000)\n",
                "        del a\n",
                "        gc.collect()\n",
                "        test_pydatamem_seteventhook_end()\n",
                "\n",
                "class TestMapIter(TestCase):\n",
                "    def test_mapiter(self):\n",
                "        # The actual tests are within the C code in\n",
                "        # multiarray/multiarray_tests.c.src\n",
                "\n",
                "        a = np.arange(12).reshape((3, 4)).astype(float)\n",
                "        index = ([1, 1, 2, 0],\n",
                "                 [0, 0, 2, 3])\n",
                "        vals = [50, 50, 30, 16]\n",
                "\n",
                "        test_inplace_increment(a, index, vals)\n",
                "        assert_equal(a, [[0.00, 1., 2.0, 19.],\n",
                "                         [104., 5., 6.0, 7.0],\n",
                "                         [8.00, 9., 40., 11.]])\n",
                "\n",
                "        b = np.arange(6).astype(float)\n",
                "        index = (np.array([1, 2, 0]),)\n",
                "        vals = [50, 4, 100.1]\n",
                "        test_inplace_increment(b, index, vals)\n",
                "        assert_equal(b, [100.1,  51.,   6.,   3.,   4.,   5.])\n",
                "\n",
                "\n",
                "class TestAsCArray(TestCase):\n",
                "    def test_1darray(self):\n",
                "        array = np.arange(24, dtype=np.double)\n",
                "        from_c = test_as_c_array(array, 3)\n",
                "        assert_equal(array[3], from_c)\n",
                "\n",
                "    def test_2darray(self):\n",
                "        array = np.arange(24, dtype=np.double).reshape(3, 8)\n",
                "        from_c = test_as_c_array(array, 2, 4)\n",
                "        assert_equal(array[2, 4], from_c)\n",
                "\n",
                "    def test_3darray(self):\n",
                "        array = np.arange(24, dtype=np.double).reshape(2, 3, 4)\n",
                "        from_c = test_as_c_array(array, 1, 2, 3)\n",
                "        assert_equal(array[1, 2, 3], from_c)\n",
                "\n",
                "\n",
                "class TestConversion(TestCase):\n",
                "    def test_array_scalar_relational_operation(self):\n",
                "        # All integer\n",
                "        for dt1 in np.typecodes['AllInteger']:\n",
                "            assert_(1 > np.array(0, dtype=dt1), \"type %s failed\" % (dt1,))\n",
                "            assert_(not 1 < np.array(0, dtype=dt1), \"type %s failed\" % (dt1,))\n",
                "\n",
                "            for dt2 in np.typecodes['AllInteger']:\n",
                "                assert_(np.array(1, dtype=dt1) > np.array(0, dtype=dt2),\n",
                "                        \"type %s and %s failed\" % (dt1, dt2))\n",
                "                assert_(not np.array(1, dtype=dt1) < np.array(0, dtype=dt2),\n",
                "                        \"type %s and %s failed\" % (dt1, dt2))\n",
                "\n",
                "        # Unsigned integers\n",
                "        for dt1 in 'BHILQP':\n",
                "            assert_(-1 < np.array(1, dtype=dt1), \"type %s failed\" % (dt1,))\n",
                "            assert_(not -1 > np.array(1, dtype=dt1), \"type %s failed\" % (dt1,))\n",
                "            assert_(-1 != np.array(1, dtype=dt1), \"type %s failed\" % (dt1,))\n",
                "\n",
                "            # Unsigned vs signed\n",
                "            for dt2 in 'bhilqp':\n",
                "                assert_(np.array(1, dtype=dt1) > np.array(-1, dtype=dt2),\n",
                "                        \"type %s and %s failed\" % (dt1, dt2))\n",
                "                assert_(not np.array(1, dtype=dt1) < np.array(-1, dtype=dt2),\n",
                "                        \"type %s and %s failed\" % (dt1, dt2))\n",
                "                assert_(np.array(1, dtype=dt1) != np.array(-1, dtype=dt2),\n",
                "                        \"type %s and %s failed\" % (dt1, dt2))\n",
                "\n",
                "        # Signed integers and floats\n",
                "        for dt1 in 'bhlqp' + np.typecodes['Float']:\n",
                "            assert_(1 > np.array(-1, dtype=dt1), \"type %s failed\" % (dt1,))\n",
                "            assert_(not 1 < np.array(-1, dtype=dt1), \"type %s failed\" % (dt1,))\n",
                "            assert_(-1 == np.array(-1, dtype=dt1), \"type %s failed\" % (dt1,))\n",
                "\n",
                "            for dt2 in 'bhlqp' + np.typecodes['Float']:\n",
                "                assert_(np.array(1, dtype=dt1) > np.array(-1, dtype=dt2),\n",
                "                        \"type %s and %s failed\" % (dt1, dt2))\n",
                "                assert_(not np.array(1, dtype=dt1) < np.array(-1, dtype=dt2),\n",
                "                        \"type %s and %s failed\" % (dt1, dt2))\n",
                "                assert_(np.array(-1, dtype=dt1) == np.array(-1, dtype=dt2),\n",
                "                        \"type %s and %s failed\" % (dt1, dt2))\n",
                "\n",
                "    def test_to_bool_scalar(self):\n",
                "        assert_equal(bool(np.array([False])), False)\n",
                "        assert_equal(bool(np.array([True])), True)\n",
                "        assert_equal(bool(np.array([[42]])), True)\n",
                "        assert_raises(ValueError, bool, np.array([1, 2]))\n",
                "\n",
                "        class NotConvertible(object):\n",
                "            def __bool__(self):\n",
                "                raise NotImplementedError\n",
                "            __nonzero__ = __bool__  # python 2\n",
                "\n",
                "        assert_raises(NotImplementedError, bool, np.array(NotConvertible()))\n",
                "        assert_raises(NotImplementedError, bool, np.array([NotConvertible()]))\n",
                "\n",
                "        self_containing = np.array([None])\n",
                "        self_containing[0] = self_containing\n",
                "        try:\n",
                "            Error = RecursionError\n",
                "        except NameError:\n",
                "            Error = RuntimeError  # python < 3.5\n",
                "        assert_raises(Error, bool, self_containing)  # previously stack overflow\n",
                "\n",
                "\n",
                "class TestWhere(TestCase):\n",
                "    def test_basic(self):\n",
                "        dts = [np.bool, np.int16, np.int32, np.int64, np.double, np.complex128,\n",
                "               np.longdouble, np.clongdouble]\n",
                "        for dt in dts:\n",
                "            c = np.ones(53, dtype=np.bool)\n",
                "            assert_equal(np.where( c, dt(0), dt(1)), dt(0))\n",
                "            assert_equal(np.where(~c, dt(0), dt(1)), dt(1))\n",
                "            assert_equal(np.where(True, dt(0), dt(1)), dt(0))\n",
                "            assert_equal(np.where(False, dt(0), dt(1)), dt(1))\n",
                "            d = np.ones_like(c).astype(dt)\n",
                "            e = np.zeros_like(d)\n",
                "            r = d.astype(dt)\n",
                "            c[7] = False\n",
                "            r[7] = e[7]\n",
                "            assert_equal(np.where(c, e, e), e)\n",
                "            assert_equal(np.where(c, d, e), r)\n",
                "            assert_equal(np.where(c, d, e[0]), r)\n",
                "            assert_equal(np.where(c, d[0], e), r)\n",
                "            assert_equal(np.where(c[::2], d[::2], e[::2]), r[::2])\n",
                "            assert_equal(np.where(c[1::2], d[1::2], e[1::2]), r[1::2])\n",
                "            assert_equal(np.where(c[::3], d[::3], e[::3]), r[::3])\n",
                "            assert_equal(np.where(c[1::3], d[1::3], e[1::3]), r[1::3])\n",
                "            assert_equal(np.where(c[::-2], d[::-2], e[::-2]), r[::-2])\n",
                "            assert_equal(np.where(c[::-3], d[::-3], e[::-3]), r[::-3])\n",
                "            assert_equal(np.where(c[1::-3], d[1::-3], e[1::-3]), r[1::-3])\n",
                "\n",
                "    def test_exotic(self):\n",
                "        # object\n",
                "        assert_array_equal(np.where(True, None, None), np.array(None))\n",
                "        # zero sized\n",
                "        m = np.array([], dtype=bool).reshape(0, 3)\n",
                "        b = np.array([], dtype=np.float64).reshape(0, 3)\n",
                "        assert_array_equal(np.where(m, 0, b), np.array([]).reshape(0, 3))\n",
                "\n",
                "        # object cast\n",
                "        d = np.array([-1.34, -0.16, -0.54, -0.31, -0.08, -0.95, 0.000, 0.313,\n",
                "                      0.547, -0.18, 0.876, 0.236, 1.969, 0.310, 0.699, 1.013,\n",
                "                      1.267, 0.229, -1.39, 0.487])\n",
                "        nan = float('NaN')\n",
                "        e = np.array(['5z', '0l', nan, 'Wz', nan, nan, 'Xq', 'cs', nan, nan,\n",
                "                     'QN', nan, nan, 'Fd', nan, nan, 'kp', nan, '36', 'i1'],\n",
                "                     dtype=object)\n",
                "        m = np.array([0, 0, 1, 0, 1, 1, 0, 0, 1, 1,\n",
                "                      0, 1, 1, 0, 1, 1, 0, 1, 0, 0], dtype=bool)\n",
                "\n",
                "        r = e[:]\n",
                "        r[np.where(m)] = d[np.where(m)]\n",
                "        assert_array_equal(np.where(m, d, e), r)\n",
                "\n",
                "        r = e[:]\n",
                "        r[np.where(~m)] = d[np.where(~m)]\n",
                "        assert_array_equal(np.where(m, e, d), r)\n",
                "\n",
                "        assert_array_equal(np.where(m, e, e), e)\n",
                "\n",
                "        # minimal dtype result with NaN scalar (e.g required by pandas)\n",
                "        d = np.array([1., 2.], dtype=np.float32)\n",
                "        e = float('NaN')\n",
                "        assert_equal(np.where(True, d, e).dtype, np.float32)\n",
                "        e = float('Infinity')\n",
                "        assert_equal(np.where(True, d, e).dtype, np.float32)\n",
                "        e = float('-Infinity')\n",
                "        assert_equal(np.where(True, d, e).dtype, np.float32)\n",
                "        # also check upcast\n",
                "        e = float(1e150)\n",
                "        assert_equal(np.where(True, d, e).dtype, np.float64)\n",
                "\n",
                "    def test_ndim(self):\n",
                "        c = [True, False]\n",
                "        a = np.zeros((2, 25))\n",
                "        b = np.ones((2, 25))\n",
                "        r = np.where(np.array(c)[:,np.newaxis], a, b)\n",
                "        assert_array_equal(r[0], a[0])\n",
                "        assert_array_equal(r[1], b[0])\n",
                "\n",
                "        a = a.T\n",
                "        b = b.T\n",
                "        r = np.where(c, a, b)\n",
                "        assert_array_equal(r[:,0], a[:,0])\n",
                "        assert_array_equal(r[:,1], b[:,0])\n",
                "\n",
                "    def test_dtype_mix(self):\n",
                "        c = np.array([False, True, False, False, False, False, True, False,\n",
                "                     False, False, True, False])\n",
                "        a = np.uint32(1)\n",
                "        b = np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.],\n",
                "                      dtype=np.float64)\n",
                "        r = np.array([5., 1., 3., 2., -1., -4., 1., -10., 10., 1., 1., 3.],\n",
                "                     dtype=np.float64)\n",
                "        assert_equal(np.where(c, a, b), r)\n",
                "\n",
                "        a = a.astype(np.float32)\n",
                "        b = b.astype(np.int64)\n",
                "        assert_equal(np.where(c, a, b), r)\n",
                "\n",
                "        # non bool mask\n",
                "        c = c.astype(np.int)\n",
                "        c[c != 0] = 34242324\n",
                "        assert_equal(np.where(c, a, b), r)\n",
                "        # invert\n",
                "        tmpmask = c != 0\n",
                "        c[c == 0] = 41247212\n",
                "        c[tmpmask] = 0\n",
                "        assert_equal(np.where(c, b, a), r)\n",
                "\n",
                "    def test_foreign(self):\n",
                "        c = np.array([False, True, False, False, False, False, True, False,\n",
                "                     False, False, True, False])\n",
                "        r = np.array([5., 1., 3., 2., -1., -4., 1., -10., 10., 1., 1., 3.],\n",
                "                     dtype=np.float64)\n",
                "        a = np.ones(1, dtype='>i4')\n",
                "        b = np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.],\n",
                "                     dtype=np.float64)\n",
                "        assert_equal(np.where(c, a, b), r)\n",
                "\n",
                "        b = b.astype('>f8')\n",
                "        assert_equal(np.where(c, a, b), r)\n",
                "\n",
                "        a = a.astype('<i4')\n",
                "        assert_equal(np.where(c, a, b), r)\n",
                "\n",
                "        c = c.astype('>i4')\n",
                "        assert_equal(np.where(c, a, b), r)\n",
                "\n",
                "    def test_error(self):\n",
                "        c = [True, True]\n",
                "        a = np.ones((4, 5))\n",
                "        b = np.ones((5, 5))\n",
                "        assert_raises(ValueError, np.where, c, a, a)\n",
                "        assert_raises(ValueError, np.where, c[0], a, b)\n",
                "\n",
                "    def test_string(self):\n",
                "        # gh-4778 check strings are properly filled with nulls\n",
                "        a = np.array(\"abc\")\n",
                "        b = np.array(\"x\" * 753)\n",
                "        assert_equal(np.where(True, a, b), \"abc\")\n",
                "        assert_equal(np.where(False, b, a), \"abc\")\n",
                "\n",
                "        # check native datatype sized strings\n",
                "        a = np.array(\"abcd\")\n",
                "        b = np.array(\"x\" * 8)\n",
                "        assert_equal(np.where(True, a, b), \"abcd\")\n",
                "        assert_equal(np.where(False, b, a), \"abcd\")\n",
                "\n",
                "    def test_empty_result(self):\n",
                "        # pass empty where result through an assignment which reads the data of\n",
                "        # empty arrays, error detectable with valgrind, see gh-8922\n",
                "        x = np.zeros((1, 1))\n",
                "        ibad = np.vstack(np.where(x == 99.))\n",
                "        assert_array_equal(ibad,\n",
                "                           np.atleast_2d(np.array([[],[]], dtype=np.intp)))\n",
                "\n",
                "\n",
                "if not IS_PYPY:\n",
                "    # sys.getsizeof() is not valid on PyPy\n",
                "    class TestSizeOf(TestCase):\n",
                "\n",
                "        def test_empty_array(self):\n",
                "            x = np.array([])\n",
                "            assert_(sys.getsizeof(x) > 0)\n",
                "\n",
                "        def check_array(self, dtype):\n",
                "            elem_size = dtype(0).itemsize\n",
                "\n",
                "            for length in [10, 50, 100, 500]:\n",
                "                x = np.arange(length, dtype=dtype)\n",
                "                assert_(sys.getsizeof(x) > length * elem_size)\n",
                "\n",
                "        def test_array_int32(self):\n",
                "            self.check_array(np.int32)\n",
                "\n",
                "        def test_array_int64(self):\n",
                "            self.check_array(np.int64)\n",
                "\n",
                "        def test_array_float32(self):\n",
                "            self.check_array(np.float32)\n",
                "\n",
                "        def test_array_float64(self):\n",
                "            self.check_array(np.float64)\n",
                "\n",
                "        def test_view(self):\n",
                "            d = np.ones(100)\n",
                "            assert_(sys.getsizeof(d[...]) < sys.getsizeof(d))\n",
                "\n",
                "        def test_reshape(self):\n",
                "            d = np.ones(100)\n",
                "            assert_(sys.getsizeof(d) < sys.getsizeof(d.reshape(100, 1, 1).copy()))\n",
                "\n",
                "        def test_resize(self):\n",
                "            d = np.ones(100)\n",
                "            old = sys.getsizeof(d)\n",
                "            d.resize(50)\n",
                "            assert_(old > sys.getsizeof(d))\n",
                "            d.resize(150)\n",
                "            assert_(old < sys.getsizeof(d))\n",
                "\n",
                "        def test_error(self):\n",
                "            d = np.ones(100)\n",
                "            assert_raises(TypeError, d.__sizeof__, \"a\")\n",
                "\n",
                "\n",
                "class TestHashing(TestCase):\n",
                "\n",
                "    def test_arrays_not_hashable(self):\n",
                "        x = np.ones(3)\n",
                "        assert_raises(TypeError, hash, x)\n",
                "\n",
                "    def test_collections_hashable(self):\n",
                "        x = np.array([])\n",
                "        self.assertFalse(isinstance(x, collections.Hashable))\n",
                "\n",
                "\n",
                "class TestArrayPriority(TestCase):\n",
                "    # This will go away when __array_priority__ is settled, meanwhile\n",
                "    # it serves to check unintended changes.\n",
                "    op = operator\n",
                "    binary_ops = [\n",
                "        op.pow, op.add, op.sub, op.mul, op.floordiv, op.truediv, op.mod,\n",
                "        op.and_, op.or_, op.xor, op.lshift, op.rshift, op.mod, op.gt,\n",
                "        op.ge, op.lt, op.le, op.ne, op.eq\n",
                "        ]\n",
                "\n",
                "    # See #7949. Dont use \"/\" operator With -3 switch, since python reports it\n",
                "    # as a DeprecationWarning\n",
                "    if sys.version_info[0] < 3 and not sys.py3kwarning:\n",
                "        binary_ops.append(op.div)\n",
                "\n",
                "    class Foo(np.ndarray):\n",
                "        __array_priority__ = 100.\n",
                "\n",
                "        def __new__(cls, *args, **kwargs):\n",
                "            return np.array(*args, **kwargs).view(cls)\n",
                "\n",
                "    class Bar(np.ndarray):\n",
                "        __array_priority__ = 101.\n",
                "\n",
                "        def __new__(cls, *args, **kwargs):\n",
                "            return np.array(*args, **kwargs).view(cls)\n",
                "\n",
                "    class Other(object):\n",
                "        __array_priority__ = 1000.\n",
                "\n",
                "        def _all(self, other):\n",
                "            return self.__class__()\n",
                "\n",
                "        __add__ = __radd__ = _all\n",
                "        __sub__ = __rsub__ = _all\n",
                "        __mul__ = __rmul__ = _all\n",
                "        __pow__ = __rpow__ = _all\n",
                "        __div__ = __rdiv__ = _all\n",
                "        __mod__ = __rmod__ = _all\n",
                "        __truediv__ = __rtruediv__ = _all\n",
                "        __floordiv__ = __rfloordiv__ = _all\n",
                "        __and__ = __rand__ = _all\n",
                "        __xor__ = __rxor__ = _all\n",
                "        __or__ = __ror__ = _all\n",
                "        __lshift__ = __rlshift__ = _all\n",
                "        __rshift__ = __rrshift__ = _all\n",
                "        __eq__ = _all\n",
                "        __ne__ = _all\n",
                "        __gt__ = _all\n",
                "        __ge__ = _all\n",
                "        __lt__ = _all\n",
                "        __le__ = _all\n",
                "\n",
                "    def test_ndarray_subclass(self):\n",
                "        a = np.array([1, 2])\n",
                "        b = self.Bar([1, 2])\n",
                "        for f in self.binary_ops:\n",
                "            msg = repr(f)\n",
                "            assert_(isinstance(f(a, b), self.Bar), msg)\n",
                "            assert_(isinstance(f(b, a), self.Bar), msg)\n",
                "\n",
                "    def test_ndarray_other(self):\n",
                "        a = np.array([1, 2])\n",
                "        b = self.Other()\n",
                "        for f in self.binary_ops:\n",
                "            msg = repr(f)\n",
                "            assert_(isinstance(f(a, b), self.Other), msg)\n",
                "            assert_(isinstance(f(b, a), self.Other), msg)\n",
                "\n",
                "    def test_subclass_subclass(self):\n",
                "        a = self.Foo([1, 2])\n",
                "        b = self.Bar([1, 2])\n",
                "        for f in self.binary_ops:\n",
                "            msg = repr(f)\n",
                "            assert_(isinstance(f(a, b), self.Bar), msg)\n",
                "            assert_(isinstance(f(b, a), self.Bar), msg)\n",
                "\n",
                "    def test_subclass_other(self):\n",
                "        a = self.Foo([1, 2])\n",
                "        b = self.Other()\n",
                "        for f in self.binary_ops:\n",
                "            msg = repr(f)\n",
                "            assert_(isinstance(f(a, b), self.Other), msg)\n",
                "            assert_(isinstance(f(b, a), self.Other), msg)\n",
                "\n",
                "\n",
                "class TestBytestringArrayNonzero(TestCase):\n",
                "\n",
                "    def test_empty_bstring_array_is_falsey(self):\n",
                "        self.assertFalse(np.array([''], dtype=np.str))\n",
                "\n",
                "    def test_whitespace_bstring_array_is_falsey(self):\n",
                "        a = np.array(['spam'], dtype=np.str)\n",
                "        a[0] = '  \\0\\0'\n",
                "        self.assertFalse(a)\n",
                "\n",
                "    def test_all_null_bstring_array_is_falsey(self):\n",
                "        a = np.array(['spam'], dtype=np.str)\n",
                "        a[0] = '\\0\\0\\0\\0'\n",
                "        self.assertFalse(a)\n",
                "\n",
                "    def test_null_inside_bstring_array_is_truthy(self):\n",
                "        a = np.array(['spam'], dtype=np.str)\n",
                "        a[0] = ' \\0 \\0'\n",
                "        self.assertTrue(a)\n",
                "\n",
                "\n",
                "class TestUnicodeArrayNonzero(TestCase):\n",
                "\n",
                "    def test_empty_ustring_array_is_falsey(self):\n",
                "        self.assertFalse(np.array([''], dtype=np.unicode))\n",
                "\n",
                "    def test_whitespace_ustring_array_is_falsey(self):\n",
                "        a = np.array(['eggs'], dtype=np.unicode)\n",
                "        a[0] = '  \\0\\0'\n",
                "        self.assertFalse(a)\n",
                "\n",
                "    def test_all_null_ustring_array_is_falsey(self):\n",
                "        a = np.array(['eggs'], dtype=np.unicode)\n",
                "        a[0] = '\\0\\0\\0\\0'\n",
                "        self.assertFalse(a)\n",
                "\n",
                "    def test_null_inside_ustring_array_is_truthy(self):\n",
                "        a = np.array(['eggs'], dtype=np.unicode)\n",
                "        a[0] = ' \\0 \\0'\n",
                "        self.assertTrue(a)\n",
                "\n",
                "\n",
                "class TestCTypes(TestCase):\n",
                "\n",
                "    def test_ctypes_is_available(self):\n",
                "        test_arr = np.array([[1, 2, 3], [4, 5, 6]])\n",
                "\n",
                "        self.assertEqual(ctypes, test_arr.ctypes._ctypes)\n",
                "        assert_equal(tuple(test_arr.ctypes.shape), (2, 3))\n",
                "\n",
                "    def test_ctypes_is_not_available(self):\n",
                "        from numpy.core import _internal\n",
                "        _internal.ctypes = None\n",
                "        try:\n",
                "            test_arr = np.array([[1, 2, 3], [4, 5, 6]])\n",
                "\n",
                "            self.assertIsInstance(\n",
                "                test_arr.ctypes._ctypes, _internal._missing_ctypes)\n",
                "            assert_equal(tuple(test_arr.ctypes.shape), (2, 3))\n",
                "        finally:\n",
                "            _internal.ctypes = ctypes\n",
                "\n",
                "\n",
                "def test_orderconverter_with_nonASCII_unicode_ordering():\n",
                "    # gh-7475\n",
                "    a = np.arange(5)\n",
                "    assert_raises(ValueError, a.flatten, order=u'\\xe2')\n",
                "\n",
                "if __name__ == \"__main__\":\n",
                "    run_module_suite()"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "0 before 1",
            "reason": "move"
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                3,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "implement and test"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        }
    ]
}