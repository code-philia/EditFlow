{
    "language": "python",
    "commit_url": "https://github.com/mitmproxy/mitmproxy/commit/09e995ab5c78b8bd098e1330df7aa40972e0b1bb",
    "commit_message": "Improvements to pathoc repeat requests\n\n- Pathoc will now keep trying if connections failed\n- Add a -w option to specify a wait time between requests",
    "commit_snapshots": {
        "libpathod/cmdline.py": [
            [
                "#!/usr/bin/env python\n",
                "import argparse\n",
                "import os\n",
                "import os.path\n",
                "import sys\n",
                "import re\n",
                "from . import pathoc, pathod, version, utils, language\n",
                "from netlib import http_uastrings\n",
                "\n",
                "\n",
                "def go_pathoc():\n",
                "    preparser = argparse.ArgumentParser(add_help=False)\n",
                "    preparser.add_argument(\n",
                "        \"--show-uas\", dest=\"showua\", action=\"store_true\", default=False,\n",
                "        help=\"Print user agent shortcuts and exit.\"\n",
                "    )\n",
                "    pa = preparser.parse_known_args()[0]\n",
                "    if pa.showua:\n",
                "        print \"User agent strings:\"\n",
                "        for i in http_uastrings.UASTRINGS:\n",
                "            print \"  \", i[1], i[0]\n",
                "        sys.exit(0)\n",
                "\n",
                "    parser = argparse.ArgumentParser(\n",
                "        description='A perverse HTTP client.', parents=[preparser]\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        '--version',\n",
                "        action='version',\n",
                "        version=\"pathoc \" + version.VERSION\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-c\", dest=\"connect_to\", type=str, default=False,\n",
                "        metavar = \"HOST:PORT\",\n",
                "        help=\"Issue an HTTP CONNECT to connect to the specified host.\"\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--memo-limit\", dest='memolimit', default=5000, type=int, metavar=\"N\",\n",
                "        help='Stop if we do not find a valid request after N attempts.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-m\", dest='memo', action=\"store_true\", default=False,\n",
                "        help=\"\"\"\n",
                "            Remember specs, and never play the same one twice. Note that this\n",
                "            means requests have to be rendered in memory, which means that large\n",
                "            generated data can cause issues.\n",
                "        \"\"\"\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-n\", dest='repeat', default=1, type=int, metavar=\"N\",\n",
                "        help='Repeat N times. If 0 repeat for ever.'\n",
                "    )\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    parser.add_argument(\n",
                    "        \"-w\", dest='wait', default=0, type=float, metavar=\"N\",\n",
                    "        help='Wait N seconds between each request.'\n",
                    "    )\n"
                ],
                "parent_version_range": {
                    "start": 52,
                    "end": 52
                },
                "child_version_range": {
                    "start": 52,
                    "end": 56
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "go_pathoc",
                        "signature": "def go_pathoc():",
                        "at_line": 10
                    },
                    {
                        "type": "call",
                        "name": "parser.add_argument",
                        "signature": "parser.add_argument(\n        \"-n\", dest='repeat', default=1, type=int, metavar=\"N\",\n        help='Repeat N times. If 0 repeat for ever.'\n    )",
                        "at_line": 48
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: libpathod/cmdline.py\nCode:\n         def go_pathoc():\n             ...\n             parser.add_argument(\n        \"-n\", dest='repeat', default=1, type=int, metavar=\"N\",\n        help='Repeat N times. If 0 repeat for ever.'\n    )\n                 ...\n49 49            \"-n\", dest='repeat', default=1, type=int, metavar=\"N\",\n50 50            help='Repeat N times. If 0 repeat for ever.'\n51 51        )\n   52  +     parser.add_argument(\n   53  +         \"-w\", dest='wait', default=0, type=float, metavar=\"N\",\n   54  +         help='Wait N seconds between each request.'\n   55  +     )\n52 56        parser.add_argument(\n53 57            \"-r\", dest=\"random\", action=\"store_true\", default=False,\n54 58            help=\"\"\"\n       ...\n",
                "file_path": "libpathod/cmdline.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "add_argument",
                    "default",
                    "dest",
                    "float",
                    "help",
                    "metavar",
                    "parser",
                    "type"
                ],
                "prefix": [
                    "        \"-n\", dest='repeat', default=1, type=int, metavar=\"N\",\n",
                    "        help='Repeat N times. If 0 repeat for ever.'\n",
                    "    )\n"
                ],
                "suffix": [
                    "    parser.add_argument(\n",
                    "        \"-r\", dest=\"random\", action=\"store_true\", default=False,\n",
                    "        help=\"\"\"\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    parser.add_argument(\n",
                "        \"-r\", dest=\"random\", action=\"store_true\", default=False,\n",
                "        help=\"\"\"\n",
                "        Select a random request from those specified. If this is not specified,\n",
                "        requests are all played in sequence.\n",
                "        \"\"\"\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-t\", dest=\"timeout\", type=int, default=None,\n",
                "        help=\"Connection timeout\"\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        'host', type=str,\n",
                "        metavar = \"host[:port]\",\n",
                "        help='Host and port to connect to'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        'requests', type=str, nargs=\"+\",\n",
                "        help=\"\"\"\n",
                "        Request specification, or path to a file containing request\n",
                "        specifcations\n",
                "        \"\"\"\n",
                "    )\n",
                "    group = parser.add_argument_group(\n",
                "        'SSL',\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-s\", dest=\"ssl\", action=\"store_true\", default=False,\n",
                "        help=\"Connect with SSL\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-C\", dest=\"clientcert\", type=str, default=False,\n",
                "        help=\"Path to a file containing client certificate and private key\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-i\", dest=\"sni\", type=str, default=False,\n",
                "        help=\"SSL Server Name Indication\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"--ciphers\", dest=\"ciphers\", type=str, default=False,\n",
                "        help=\"SSL cipher specification\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"--sslversion\", dest=\"sslversion\", type=int, default=4,\n",
                "        choices=[1, 2, 3, 4],\n",
                "        help=\"\"\"\n",
                "            Use a specified protocol - TLSv1, SSLv2, SSLv3, SSLv23. Default\n",
                "            to SSLv23.\n",
                "        \"\"\"\n",
                "    )\n",
                "\n",
                "    group = parser.add_argument_group(\n",
                "        'Controlling Output',\n",
                "        \"\"\"\n",
                "            Some of these options expand generated values for logging - if\n",
                "            you're generating large data, use them with caution.\n",
                "        \"\"\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-I\", dest=\"ignorecodes\", type=str, default=\"\",\n",
                "        help=\"Comma-separated list of response codes to ignore\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-S\", dest=\"showssl\", action=\"store_true\", default=False,\n",
                "        help=\"Show info on SSL connection\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-e\", dest=\"explain\", action=\"store_true\", default=False,\n",
                "        help=\"Explain requests\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-o\", dest=\"oneshot\", action=\"store_true\", default=False,\n",
                "        help=\"Oneshot - exit after first non-ignored response\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-q\", dest=\"showreq\", action=\"store_true\", default=False,\n",
                "        help=\"Print full request\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-p\", dest=\"showresp\", action=\"store_true\", default=False,\n",
                "        help=\"Print full response\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-T\", dest=\"ignoretimeout\", action=\"store_true\", default=False,\n",
                "        help=\"Ignore timeouts\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-x\", dest=\"hexdump\", action=\"store_true\", default=False,\n",
                "        help=\"Output in hexdump format\"\n",
                "    )\n",
                "\n",
                "    args = parser.parse_args()\n",
                "\n",
                "    args.port = None\n",
                "    if \":\" in args.host:\n",
                "        h, p = args.host.rsplit(\":\", 1)\n",
                "        try:\n",
                "            p = int(p)\n",
                "        except ValueError:\n",
                "            parser.error(\"Invalid port in host spec: %s\" % args.host)\n",
                "        args.host = h\n",
                "        args.port = p\n",
                "\n",
                "    if args.port is None:\n",
                "        args.port = 443 if args.ssl else 80\n",
                "\n",
                "    try:\n",
                "        args.ignorecodes = [int(i) for i in args.ignorecodes.split(\",\") if i]\n",
                "    except ValueError:\n",
                "        parser.error(\"Invalid return code specification: %s\"%args.ignorecodes)\n",
                "\n",
                "    if args.connect_to:\n",
                "        parts = args.connect_to.split(\":\")\n",
                "        if len(parts) != 2:\n",
                "            parser.error(\"Invalid CONNECT specification: %s\"%args.connect_to)\n",
                "        try:\n",
                "            parts[1] = int(parts[1])\n",
                "        except ValueError:\n",
                "            parser.error(\"Invalid CONNECT specification: %s\"%args.connect_to)\n",
                "        args.connect_to = parts\n",
                "    else:\n",
                "        args.connect_to = None\n",
                "\n",
                "    reqs = []\n",
                "    for r in args.requests:\n",
                "        if os.path.exists(r):\n",
                "            data = open(r).read()\n",
                "            r = data\n",
                "        try:\n",
                "            reqs.extend(language.parse_requests(r))\n",
                "        except language.ParseException, v:\n",
                "            print >> sys.stderr, \"Error parsing request spec: %s\"%v.msg\n",
                "            print >> sys.stderr, v.marked()\n",
                "            sys.exit(1)\n",
                "    args.requests = reqs\n",
                "    pathoc.main(args)\n",
                "\n",
                "\n",
                "def go_pathod():\n",
                "    parser = argparse.ArgumentParser(\n",
                "        description='A pathological HTTP/S daemon.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        '--version',\n",
                "        action='version',\n",
                "        version=\"pathod \" + version.VERSION\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-p\",\n",
                "        dest='port',\n",
                "        default=9999,\n",
                "        type=int,\n",
                "        help='Port. Specify 0 to pick an arbitrary empty port.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-l\",\n",
                "        dest='address',\n",
                "        default=\"127.0.0.1\",\n",
                "        type=str,\n",
                "        help='Listening address.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-a\",\n",
                "        dest='anchors',\n",
                "        default=[],\n",
                "        type=str,\n",
                "        action=\"append\",\n",
                "        metavar=\"ANCHOR\",\n",
                "        help=\"\"\"\n",
                "        Add an anchor. Specified as a string with the form pattern=pagespec, or\n",
                "        pattern=filepath\n",
                "        \"\"\"\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-c\", dest='craftanchor', default=\"/p/\", type=str,\n",
                "        help='Anchorpoint for URL crafting commands.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--confdir\",\n",
                "        action=\"store\", type = str, dest=\"confdir\", default='~/.mitmproxy',\n",
                "        help = \"Configuration directory. (~/.mitmproxy)\"\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-d\", dest='staticdir', default=None, type=str,\n",
                "        help='Directory for static files.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-D\", dest='daemonize', default=False, action=\"store_true\",\n",
                "        help='Daemonize.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"-t\", dest=\"timeout\", type=int, default=None,\n",
                "        help=\"Connection timeout\"\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--limit-size\", dest='sizelimit', default=None, type=str,\n",
                "        help='Size limit of served responses. Understands size suffixes, i.e. 100k.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--noapi\", dest='noapi', default=False, action=\"store_true\",\n",
                "        help='Disable API.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--nohang\", dest='nohang', default=False, action=\"store_true\",\n",
                "        help='Disable pauses during crafted response generation.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--noweb\", dest='noweb', default=False, action=\"store_true\",\n",
                "        help='Disable both web interface and API.'\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--nocraft\", dest='nocraft', default=False, action=\"store_true\",\n",
                "        help='Disable response crafting. If anchors are specified, they still work.'\n",
                "    )\n",
                "\n",
                "    group = parser.add_argument_group(\n",
                "        'SSL',\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-s\", dest='ssl', default=False, action=\"store_true\",\n",
                "        help='Run in HTTPS mode.'\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"--cn\", dest=\"cn\", type=str, default=None,\n",
                "        help=\"CN for generated SSL certs. Default: %s\"%pathod.DEFAULT_CERT_DOMAIN\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-C\", dest='ssl_not_after_connect', default=False, action=\"store_true\",\n",
                "        help=\"Don't expect SSL after a CONNECT request.\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"--cert\", dest='ssl_certs', default=[], type=str,\n",
                "        metavar = \"SPEC\", action=\"append\",\n",
                "        help = \"\"\"\n",
                "        Add an SSL certificate. SPEC is of the form \"[domain=]path\". The domain\n",
                "        may include a wildcard, and is equal to \"*\" if not specified. The file\n",
                "        at path is a certificate in PEM format. If a private key is included in\n",
                "        the PEM, it is used, else the default key in the conf dir is used. Can\n",
                "        be passed multiple times.'\n",
                "        \"\"\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"--ciphers\", dest=\"ciphers\", type=str, default=False,\n",
                "        help=\"SSL cipher specification\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"--sslversion\", dest=\"sslversion\", type=int, default=4,\n",
                "        choices=[1, 2, 3, 4],\n",
                "        help=\"\"\"\"Use a specified protocol - TLSv1, SSLv2, SSLv3, SSLv23. Default\n",
                "        to SSLv23.\"\"\"\n",
                "    )\n",
                "\n",
                "    group = parser.add_argument_group(\n",
                "        'Controlling Logging',\n",
                "        \"\"\"\n",
                "            Some of these options expand generated values for logging - if\n",
                "            you're generating large data, use them with caution.\n",
                "        \"\"\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-e\", dest=\"explain\", action=\"store_true\", default=False,\n",
                "        help=\"Explain responses\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-f\", dest='logfile', default=None, type=str,\n",
                "        help='Log to file.'\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-q\", dest=\"logreq\", action=\"store_true\", default=False,\n",
                "        help=\"Log full request\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-r\", dest=\"logresp\", action=\"store_true\", default=False,\n",
                "        help=\"Log full response\"\n",
                "    )\n",
                "    group.add_argument(\n",
                "        \"-x\", dest=\"hexdump\", action=\"store_true\", default=False,\n",
                "        help=\"Log request/response in hexdump format\"\n",
                "    )\n",
                "    args = parser.parse_args()\n",
                "\n",
                "    certs = []\n",
                "    for i in args.ssl_certs:\n",
                "        parts = i.split(\"=\", 1)\n",
                "        if len(parts) == 1:\n",
                "            parts = [\"*\", parts[0]]\n",
                "        parts[1] = os.path.expanduser(parts[1])\n",
                "        if not os.path.exists(parts[1]):\n",
                "            parser.error(\"Certificate file does not exist: %s\"%parts[1])\n",
                "        certs.append(parts)\n",
                "    args.ssl_certs = certs\n",
                "\n",
                "    alst = []\n",
                "    for i in args.anchors:\n",
                "        parts = utils.parse_anchor_spec(i)\n",
                "        if not parts:\n",
                "            parser.error(\"Invalid anchor specification: %s\"%i)\n",
                "        alst.append(parts)\n",
                "    args.anchors = alst\n",
                "\n",
                "    sizelimit = None\n",
                "    if args.sizelimit:\n",
                "        try:\n",
                "            sizelimit = utils.parse_size(args.sizelimit)\n",
                "        except ValueError, v:\n",
                "            parser.error(v)\n",
                "    args.sizelimit = sizelimit\n",
                "\n",
                "    anchors = []\n",
                "    for patt, spec in args.anchors:\n",
                "        if os.path.exists(spec):\n",
                "            data = open(spec).read()\n",
                "            spec = data\n",
                "\n",
                "        try:\n",
                "            req = language.parse_response(spec)\n",
                "        except language.ParseException, v:\n",
                "            print >> sys.stderr, \"Error parsing anchor spec: %s\"%v.msg\n",
                "            print >> sys.stderr, v.marked()\n",
                "            sys.exit(1)\n",
                "        try:\n",
                "            arex = re.compile(patt)\n",
                "        except re.error:\n",
                "            print >> sys.stderr, \"Invalid regex in anchor: %s\" % patt\n",
                "            sys.exit(1)\n",
                "        anchors.append((arex, req))\n",
                "    args.anchors = anchors\n",
                "\n",
                "    pathod.main(args)"
            ]
        ],
        "libpathod/pathoc.py": [
            [
                "import sys\n",
                "import os\n",
                "import hashlib\n",
                "import random\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "import time\n",
                    "\n",
                    "import OpenSSL.crypto\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 4,
                    "end": 4
                },
                "child_version_range": {
                    "start": 4,
                    "end": 8
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 1,
                "hunk_diff": "File: libpathod/pathoc.py\nCode:\n  ...\n 1  1    import os\n 2  2    import hashlib\n 3  3    import random\n    4  + import time\n    5  + \n    6  + import OpenSSL.crypto\n    7  + \n 4  8    from netlib import tcp, http, certutils\n 5  9    import netlib.utils\n 6 10    \n       ...\n",
                "file_path": "libpathod/pathoc.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "OpenSSL",
                    "crypto",
                    "time"
                ],
                "prefix": [
                    "import os\n",
                    "import hashlib\n",
                    "import random\n"
                ],
                "suffix": [
                    "from netlib import tcp, http, certutils\n",
                    "import netlib.utils\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "time",
                            "position": {
                                "start": {
                                    "line": 4,
                                    "column": 7
                                },
                                "end": {
                                    "line": 4,
                                    "column": 11
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/libpathod/pathoc.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "from netlib import tcp, http, certutils\n",
                "import netlib.utils\n",
                "\n",
                "import language\n",
                "import utils\n"
            ],
            {
                "type": "delete",
                "before": [
                    "import OpenSSL.crypto\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 9,
                    "end": 10
                },
                "child_version_range": {
                    "start": 13,
                    "end": 13
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 2,
                "hunk_diff": "File: libpathod/pathoc.py\nCode:\n  ...\n 6 10    \n 7 11    import language\n 8 12    import utils\n 9     - import OpenSSL.crypto\n10 13    \n11 14    \n12 15    class PathocError(Exception):\n       ...\n",
                "file_path": "libpathod/pathoc.py",
                "identifiers_before": [
                    "OpenSSL",
                    "crypto"
                ],
                "identifiers_after": [],
                "prefix": [
                    "\n",
                    "import language\n",
                    "import utils\n"
                ],
                "suffix": [
                    "\n",
                    "\n",
                    "class PathocError(Exception):\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "\n",
                "class PathocError(Exception):\n",
                "    pass\n",
                "\n",
                "\n",
                "class SSLInfo:\n",
                "    def __init__(self, certchain, cipher):\n",
                "        self.certchain, self.cipher = certchain, cipher\n",
                "\n",
                "\n",
                "class Response:\n",
                "    def __init__(\n",
                "        self,\n",
                "        httpversion,\n",
                "        status_code,\n",
                "        msg,\n",
                "        headers,\n",
                "        content,\n",
                "        sslinfo\n",
                "    ):\n",
                "        self.httpversion, self.status_code = httpversion, status_code\n",
                "        self.msg = msg\n",
                "        self.headers, self.content = headers, content\n",
                "        self.sslinfo = sslinfo\n",
                "\n",
                "    def __repr__(self):\n",
                "        return \"Response(%s - %s)\"%(self.status_code, self.msg)\n",
                "\n",
                "\n",
                "class Pathoc(tcp.TCPClient):\n",
                "    def __init__(\n",
                "            self,\n",
                "            address,\n",
                "            ssl=None,\n",
                "            sni=None,\n",
                "            sslversion=4,\n",
                "            clientcert=None,\n",
                "            ciphers=None):\n",
                "        tcp.TCPClient.__init__(self, address)\n",
                "        self.settings = dict(\n",
                "            staticdir = os.getcwd(),\n",
                "            unconstrained_file_access = True,\n",
                "        )\n",
                "        self.ssl, self.sni = ssl, sni\n",
                "        self.clientcert = clientcert\n",
                "        self.sslversion = utils.SSLVERSIONS[sslversion]\n",
                "        self.ciphers = ciphers\n",
                "\n",
                "    def http_connect(self, connect_to):\n",
                "        self.wfile.write(\n",
                "            'CONNECT %s:%s HTTP/1.1\\r\\n'%tuple(connect_to) +\n",
                "            '\\r\\n'\n",
                "        )\n",
                "        self.wfile.flush()\n",
                "        l = self.rfile.readline()\n",
                "        if not l:\n",
                "            raise PathocError(\"Proxy CONNECT failed\")\n",
                "        parsed = http.parse_response_line(l)\n",
                "        if not parsed[1] == 200:\n",
                "            raise PathocError(\"Proxy CONNECT failed: %s - %s\"%(parsed[1], parsed[2]))\n",
                "        http.read_headers(self.rfile)\n",
                "\n",
                "    def connect(self, connect_to=None):\n",
                "        \"\"\"\n",
                "            connect_to: A (host, port) tuple, which will be connected to with an\n",
                "            HTTP CONNECT request.\n",
                "        \"\"\"\n",
                "        tcp.TCPClient.connect(self)\n",
                "        if connect_to:\n",
                "            self.http_connect(connect_to)\n",
                "        self.sslinfo = None\n",
                "        if self.ssl:\n",
                "            try:\n",
                "                self.convert_to_ssl(\n",
                "                    sni=self.sni,\n",
                "                    cert=self.clientcert,\n",
                "                    method=self.sslversion,\n",
                "                    cipher_list = self.ciphers\n",
                "                )\n",
                "            except tcp.NetLibError, v:\n",
                "                raise PathocError(str(v))\n",
                "            self.sslinfo = SSLInfo(\n",
                "                self.connection.get_peer_cert_chain(),\n",
                "                self.get_current_cipher()\n",
                "            )\n",
                "\n",
                "    def request(self, spec):\n",
                "        \"\"\"\n",
                "            Return an (httpversion, code, msg, headers, content) tuple.\n",
                "\n",
                "            May raise language.ParseException, netlib.http.HttpError or\n",
                "            language.FileAccessDenied.\n",
                "        \"\"\"\n",
                "        r = language.parse_requests(spec)[0]\n",
                "        language.serve(r, self.wfile, self.settings, self.address.host)\n",
                "        self.wfile.flush()\n",
                "        ret = list(http.read_response(self.rfile, r.method.string(), None))\n",
                "        ret.append(self.sslinfo)\n",
                "        return Response(*ret)\n",
                "\n",
                "    def _show_summary(self, fp, httpversion, code, msg, headers, content):\n",
                "        print >> fp, \"<< %s %s: %s bytes\"%(\n",
                "            code, utils.xrepr(msg), len(content)\n",
                "        )\n",
                "\n",
                "    def _show(self, fp, header, data, hexdump):\n",
                "        if hexdump:\n",
                "            print >> fp, \"%s (hex dump):\"%header\n",
                "            for line in netlib.utils.hexdump(data):\n",
                "                print >> fp, \"\\t%s %s %s\"%line\n",
                "        else:\n",
                "            print >> fp, \"%s (unprintables escaped):\"%header\n",
                "            print >> fp, netlib.utils.cleanBin(data)\n",
                "\n",
                "    def print_request(\n",
                "        self,\n",
                "        r,\n",
                "        showreq,\n",
                "        showresp,\n",
                "        explain,\n",
                "        showssl,\n",
                "        hexdump,\n",
                "        ignorecodes,\n",
                "        ignoretimeout,\n",
                "        fp=sys.stdout\n",
                "    ):\n",
                "        \"\"\"\n",
                "            Performs a series of requests, and prints results to the specified\n",
                "            file descriptor.\n",
                "\n",
                "            spec: A request specification\n",
                "            showreq: Print requests\n",
                "            showresp: Print responses\n",
                "            explain: Print request explanation\n",
                "            showssl: Print info on SSL connection\n",
                "            hexdump: When printing requests or responses, use hex dump output\n",
                "            ignorecodes: Sequence of return codes to ignore\n",
                "\n",
                "            Returns True if we have a non-ignored response.\n",
                "        \"\"\"\n",
                "        resp, req = None, None\n",
                "        if showreq:\n",
                "            self.wfile.start_log()\n",
                "        if showresp:\n",
                "            self.rfile.start_log()\n",
                "        try:\n",
                "            req = language.serve(\n",
                "                r,\n",
                "                self.wfile,\n",
                "                self.settings,\n",
                "                self.address.host\n",
                "            )\n",
                "            self.wfile.flush()\n",
                "            resp = http.read_response(self.rfile, r.method.string(), None)\n",
                "        except http.HttpError, v:\n",
                "            print >> fp, \"<< HTTP Error:\", v.message\n",
                "        except tcp.NetLibTimeout:\n",
                "            if ignoretimeout:\n",
                "                return\n",
                "            print >> fp, \"<<\", \"Timeout\"\n",
                "        except tcp.NetLibDisconnect: # pragma: nocover\n",
                "            print >> fp, \"<<\", \"Disconnect\"\n",
                "\n",
                "        if req:\n",
                "            if ignorecodes and resp and resp[1] in ignorecodes:\n",
                "                return\n",
                "\n",
                "            if explain:\n",
                "                print >> fp, \">> Spec:\", r.spec()\n",
                "\n",
                "            if showreq:\n",
                "                self._show(fp, \">> Request\", self.wfile.get_log(), hexdump)\n",
                "\n",
                "            if showresp:\n",
                "                self._show(fp, \"<< Response\", self.rfile.get_log(), hexdump)\n",
                "            else:\n",
                "                if resp:\n",
                "                    self._show_summary(fp, *resp)\n",
                "\n",
                "            if showssl and self.sslinfo:\n",
                "                print >> fp, \"Cipher: %s, %s bit, %s\"%self.sslinfo.cipher\n",
                "                print >> fp, \"SSL certificate chain:\\n\"\n",
                "                for i in self.sslinfo.certchain:\n",
                "                    print >> fp, \"\\tSubject: \",\n",
                "                    for cn in i.get_subject().get_components():\n",
                "                        print >> fp, \"%s=%s\"%cn,\n",
                "                    print >> fp\n",
                "                    print >> fp, \"\\tIssuer: \",\n",
                "                    for cn in i.get_issuer().get_components():\n",
                "                        print >> fp, \"%s=%s\"%cn,\n",
                "                    print >> fp\n",
                "                    print >> fp, \"\\tVersion: %s\"%i.get_version()\n",
                "                    print >> fp, \"\\tValidity: %s - %s\"%(\n",
                "                        i.get_notBefore(), i.get_notAfter()\n",
                "                    )\n",
                "                    print >> fp, \"\\tSerial: %s\"%i.get_serial_number()\n",
                "                    print >> fp, \"\\tAlgorithm: %s\"%i.get_signature_algorithm()\n",
                "                    pk = i.get_pubkey()\n",
                "                    types = {\n",
                "                        OpenSSL.crypto.TYPE_RSA: \"RSA\",\n",
                "                        OpenSSL.crypto.TYPE_DSA: \"DSA\"\n",
                "                    }\n",
                "                    t = types.get(pk.type(), \"Uknown\")\n",
                "                    print >> fp, \"\\tPubkey: %s bit %s\"%(pk.bits(), t)\n",
                "                    s = certutils.SSLCert(i)\n",
                "                    if s.altnames:\n",
                "                        print >> fp, \"\\tSANs:\", \" \".join(s.altnames)\n",
                "                    print >> fp\n",
                "            return True\n",
                "\n",
                "\n",
                "def main(args):\n",
                "    memo = set([])\n",
                "    trycount = 0\n",
                "    try:\n",
                "        cnt = 0\n",
                "        while 1:\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "            if cnt == args.repeat and args.repeat != 0:\n",
                    "                break\n"
                ],
                "parent_version_range": {
                    "start": 228,
                    "end": 228
                },
                "child_version_range": {
                    "start": 231,
                    "end": 233
                },
                "control_flow": [
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 225,
                        "end_line": 286
                    },
                    {
                        "type": "while_statement",
                        "statement": "while 1:",
                        "start_line": 227,
                        "end_line": 284
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "main",
                        "signature": "def main(args):",
                        "at_line": 222
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: libpathod/pathoc.py\nCode:\n           def main(args):\n               ...\n225 228        try:\n226 229            cnt = 0\n227 230            while 1:\n    231  +             if cnt == args.repeat and args.repeat != 0:\n    232  +                 break\n228 233                if trycount > args.memolimit:\n229 234                    print >> sys.stderr, \"Memo limit exceeded...\"\n230 235                    return\n         ...\n",
                "file_path": "libpathod/pathoc.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "args",
                    "cnt",
                    "repeat"
                ],
                "prefix": [
                    "    try:\n",
                    "        cnt = 0\n",
                    "        while 1:\n"
                ],
                "suffix": [
                    "            if trycount > args.memolimit:\n",
                    "                print >> sys.stderr, \"Memo limit exceeded...\"\n",
                    "                return\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "            if trycount > args.memolimit:\n",
                "                print >> sys.stderr, \"Memo limit exceeded...\"\n",
                "                return\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "            if args.wait and cnt != 0:\n",
                    "                time.sleep(args.wait)\n"
                ],
                "parent_version_range": {
                    "start": 231,
                    "end": 231
                },
                "child_version_range": {
                    "start": 236,
                    "end": 238
                },
                "control_flow": [
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 225,
                        "end_line": 286
                    },
                    {
                        "type": "while_statement",
                        "statement": "while 1:",
                        "start_line": 227,
                        "end_line": 284
                    },
                    {
                        "type": "if_statement",
                        "statement": "if trycount > args.memolimit:",
                        "start_line": 228,
                        "end_line": 230
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "main",
                        "signature": "def main(args):",
                        "at_line": 222
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: libpathod/pathoc.py\nCode:\n           def main(args):\n               ...\n228 233                if trycount > args.memolimit:\n229 234                    print >> sys.stderr, \"Memo limit exceeded...\"\n230 235                    return\n    236  +             if args.wait and cnt != 0:\n    237  +                 time.sleep(args.wait)\n231 238    \n232 239                cnt += 1\n233 240                if args.random:\n         ...\n",
                "file_path": "libpathod/pathoc.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "args",
                    "cnt",
                    "sleep",
                    "time",
                    "wait"
                ],
                "prefix": [
                    "            if trycount > args.memolimit:\n",
                    "                print >> sys.stderr, \"Memo limit exceeded...\"\n",
                    "                return\n"
                ],
                "suffix": [
                    "\n",
                    "            cnt += 1\n",
                    "            if args.random:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "time",
                            "position": {
                                "start": {
                                    "line": 237,
                                    "column": 16
                                },
                                "end": {
                                    "line": 237,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/libpathod/pathoc.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "            cnt += 1\n",
                "            if args.random:\n",
                "                playlist = [random.choice(args.requests)]\n",
                "            else:\n",
                "                playlist = args.requests\n",
                "            p = Pathoc(\n",
                "                (args.host, args.port),\n",
                "                ssl=args.ssl,\n",
                "                sni=args.sni,\n",
                "                sslversion=args.sslversion,\n",
                "                clientcert=args.clientcert,\n",
                "                ciphers=args.ciphers\n",
                "            )\n",
                "            if args.explain or args.memo:\n",
                "                playlist = [\n",
                "                    i.freeze(p.settings, p.address.host) for i in playlist\n",
                "                ]\n",
                "            if args.memo:\n",
                "                newlist = []\n",
                "                for spec in playlist:\n",
                "                    h = hashlib.sha256(spec.spec()).digest()\n",
                "                    if h not in memo:\n",
                "                        memo.add(h)\n",
                "                        newlist.append(spec)\n",
                "                playlist = newlist\n",
                "            if not playlist:\n",
                "                trycount += 1\n",
                "                continue\n",
                "\n",
                "            trycount = 0\n",
                "            try:\n",
                "                p.connect(args.connect_to)\n"
            ],
            {
                "type": "replace",
                "before": [
                    "            except (tcp.NetLibError, PathocError), v:\n"
                ],
                "after": [
                    "            except tcp.NetLibError, v:\n",
                    "                print >> sys.stderr, str(v)\n",
                    "                continue\n",
                    "            except PathocError, v:\n"
                ],
                "parent_version_range": {
                    "start": 264,
                    "end": 265
                },
                "child_version_range": {
                    "start": 271,
                    "end": 275
                },
                "control_flow": [
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 225,
                        "end_line": 286
                    },
                    {
                        "type": "while_statement",
                        "statement": "while 1:",
                        "start_line": 227,
                        "end_line": 284
                    },
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 262,
                        "end_line": 266
                    },
                    {
                        "type": "except_clause",
                        "statement": "except (tcp.NetLibError, PathocError), v:",
                        "start_line": 264,
                        "end_line": 266
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "main",
                        "signature": "def main(args):",
                        "at_line": 222
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: libpathod/pathoc.py\nCode:\n           def main(args):\n               ...\n261 268                trycount = 0\n262 269                try:\n263 270                    p.connect(args.connect_to)\n264      -             except (tcp.NetLibError, PathocError), v:\n    271  +             except tcp.NetLibError, v:\n    272  +                 print >> sys.stderr, str(v)\n    273  +                 continue\n    274  +             except PathocError, v:\n265 275                    print >> sys.stderr, str(v)\n266 276                    sys.exit(1)\n267 277                if args.timeout:\n         ...\n",
                "file_path": "libpathod/pathoc.py",
                "identifiers_before": [
                    "NetLibError",
                    "PathocError",
                    "except",
                    "tcp",
                    "v"
                ],
                "identifiers_after": [
                    "NetLibError",
                    "PathocError",
                    "except",
                    "print",
                    "stderr",
                    "str",
                    "sys",
                    "tcp",
                    "v"
                ],
                "prefix": [
                    "            trycount = 0\n",
                    "            try:\n",
                    "                p.connect(args.connect_to)\n"
                ],
                "suffix": [
                    "                print >> sys.stderr, str(v)\n",
                    "                sys.exit(1)\n",
                    "            if args.timeout:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                print >> sys.stderr, str(v)\n",
                "                sys.exit(1)\n",
                "            if args.timeout:\n",
                "                p.settimeout(args.timeout)\n",
                "            for spec in playlist:\n",
                "                ret = p.print_request(\n",
                "                    spec,\n",
                "                    showreq=args.showreq,\n",
                "                    showresp=args.showresp,\n",
                "                    explain=args.explain,\n",
                "                    showssl=args.showssl,\n",
                "                    hexdump=args.hexdump,\n",
                "                    ignorecodes=args.ignorecodes,\n",
                "                    ignoretimeout=args.ignoretimeout\n",
                "                )\n",
                "                sys.stdout.flush()\n",
                "                if ret and args.oneshot:\n",
                "                    sys.exit(0)\n"
            ],
            {
                "type": "delete",
                "before": [
                    "            if cnt == args.repeat:\n",
                    "                break\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 283,
                    "end": 285
                },
                "child_version_range": {
                    "start": 293,
                    "end": 293
                },
                "control_flow": [
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 225,
                        "end_line": 286
                    },
                    {
                        "type": "while_statement",
                        "statement": "while 1:",
                        "start_line": 227,
                        "end_line": 284
                    },
                    {
                        "type": "if_statement",
                        "statement": "if cnt == args.repeat:",
                        "start_line": 283,
                        "end_line": 284
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "main",
                        "signature": "def main(args):",
                        "at_line": 222
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: libpathod/pathoc.py\nCode:\n           def main(args):\n               ...\n280 290                    sys.stdout.flush()\n281 291                    if ret and args.oneshot:\n282 292                        sys.exit(0)\n283      -             if cnt == args.repeat:\n284      -                 break\n285 293        except KeyboardInterrupt:\n286 294            pass\n         ...\n",
                "file_path": "libpathod/pathoc.py",
                "identifiers_before": [
                    "args",
                    "cnt",
                    "repeat"
                ],
                "identifiers_after": [],
                "prefix": [
                    "                sys.stdout.flush()\n",
                    "                if ret and args.oneshot:\n",
                    "                    sys.exit(0)\n"
                ],
                "suffix": [
                    "    except KeyboardInterrupt:\n",
                    "        pass"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    except KeyboardInterrupt:\n",
                "        pass"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "1 before 0",
            "reason": "move"
        },
        {
            "edit_hunk_pair": [
                1,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                3,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "maybe move, maybe not, set to bi-directional for safety"
        }
    ]
}