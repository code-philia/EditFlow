{
    "language": "python",
    "commit_url": "https://github.com/kovidgoyal/kitty/commit/b1c0398bba156d86f88a75466054b7b750202420",
    "commit_message": "Avoid unnecessary CPU churn when reading from stdin for @ send-text",
    "commit_snapshots": {
        "kitty/rc/send_text.py": [
            [
                "#!/usr/bin/env python\n",
                "# License: GPLv3 Copyright: 2020, Kovid Goyal <kovid at kovidgoyal.net>\n",
                "\n",
                "import base64\n",
                "import os\n",
                "import sys\n",
                "from typing import TYPE_CHECKING, List, Optional, Union\n",
                "\n",
                "from kitty.fast_data_types import KeyEvent as WindowSystemKeyEvent\n",
                "from kitty.key_encoding import decode_key_event_as_window_system_key\n",
                "from kitty.options.utils import parse_send_text_bytes\n",
                "\n",
                "from .base import (\n",
                "    MATCH_TAB_OPTION, MATCH_WINDOW_OPTION, ArgsType, Boss, CmdGenerator,\n",
                "    MatchError, PayloadGetType, PayloadType, RCOptions, RemoteCommand,\n",
                "    ResponseType, Window\n",
                ")\n",
                "\n",
                "if TYPE_CHECKING:\n",
                "    from kitty.cli_stub import SendTextRCOptions as CLIOptions\n",
                "\n",
                "\n",
                "class SendText(RemoteCommand):\n",
                "    '''\n",
                "    data+: The data being sent. Can be either: text: followed by text or base64: followed by standard base64 encoded bytes\n",
                "    match: A string indicating the window to send text to\n",
                "    match_tab: A string indicating the tab to send text to\n",
                "    all: A boolean indicating all windows should be matched.\n",
                "    exclude_active: A boolean that prevents sending text to the active window\n",
                "    '''\n",
                "    short_desc = 'Send arbitrary text to specified windows'\n",
                "    desc = (\n",
                "        'Send arbitrary text to specified windows. The text follows Python'\n",
                "        ' escaping rules. So you can use escapes like :italic:`\\\\x1b` to send control codes'\n",
                "        ' and :italic:`\\\\u21fa` to send unicode characters. If you use the :option:`kitty @ send-text --match` option'\n",
                "        ' the text will be sent to all matched windows. By default, text is sent to'\n",
                "        ' only the currently active window.'\n",
                "    )\n",
                "    options_spec = MATCH_WINDOW_OPTION + '\\n\\n' + MATCH_TAB_OPTION.replace('--match -m', '--match-tab -t') + '''\\n\n",
                "--all\n",
                "type=bool-set\n",
                "Match all windows.\n",
                "\n",
                "\n",
                "--stdin\n",
                "type=bool-set\n",
                "Read the text to be sent from :italic:`stdin`. Note that in this case the text is sent as is,\n",
                "not interpreted for escapes. If stdin is a terminal, you can press Ctrl-D to end reading.\n",
                "\n",
                "\n",
                "--from-file\n",
                "Path to a file whose contents you wish to send. Note that in this case the file contents\n",
                "are sent as is, not interpreted for escapes.\n",
                "\n",
                "\n",
                "--exclude-active\n",
                "type=bool-set\n",
                "Do not send text to the active window, even if it is one of the matched windows.\n",
                "'''\n",
                "    no_response = True\n",
                "    argspec = '[TEXT TO SEND]'\n",
                "\n",
                "    def message_to_kitty(self, global_opts: RCOptions, opts: 'CLIOptions', args: ArgsType) -> PayloadType:\n",
                "        limit = 1024\n",
                "        ret = {'match': opts.match, 'data': '', 'match_tab': opts.match_tab, 'all': opts.all, 'exclude_active': opts.exclude_active}\n",
                "\n",
                "        def pipe() -> CmdGenerator:\n",
                "            if sys.stdin.isatty():\n",
                "                ret['exclude_active'] = True\n",
                "                keep_going = True\n",
                "                from kitty.utils import TTYIO\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                with TTYIO() as tty:\n"
                ],
                "after": [
                    "                with TTYIO(read_with_timeout=False) as tty:\n"
                ],
                "parent_version_range": {
                    "start": 71,
                    "end": 72
                },
                "child_version_range": {
                    "start": 71,
                    "end": 72
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if sys.stdin.isatty():",
                        "start_line": 67,
                        "end_line": 86
                    },
                    {
                        "type": "with_statement",
                        "statement": "with TTYIO() as tty:",
                        "start_line": 71,
                        "end_line": 79
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "SendText",
                        "signature": "class SendText(RemoteCommand):",
                        "at_line": 22
                    },
                    {
                        "type": "function",
                        "name": "message_to_kitty",
                        "signature": "def message_to_kitty(self, global_opts: RCOptions, opts: 'CLIOptions', args: ArgsType)->PayloadType:",
                        "at_line": 62
                    },
                    {
                        "type": "function",
                        "name": "pipe",
                        "signature": "def pipe()->CmdGenerator:",
                        "at_line": 66
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: kitty/rc/send_text.py\nCode:\n         class SendText(RemoteCommand):\n             ...\n             def message_to_kitty(self, global_opts: RCOptions, opts: 'CLIOptions', args: ArgsType)->PayloadType:\n                 ...\n                 def pipe()->CmdGenerator:\n                     ...\n68 68                    ret['exclude_active'] = True\n69 69                    keep_going = True\n70 70                    from kitty.utils import TTYIO\n71     -                 with TTYIO() as tty:\n   71  +                 with TTYIO(read_with_timeout=False) as tty:\n72 72                        while keep_going:\n       ...\n",
                "file_path": "kitty/rc/send_text.py",
                "identifiers_before": [
                    "TTYIO",
                    "tty"
                ],
                "identifiers_after": [
                    "TTYIO",
                    "read_with_timeout",
                    "tty"
                ],
                "prefix": [
                    "                ret['exclude_active'] = True\n",
                    "                keep_going = True\n",
                    "                from kitty.utils import TTYIO\n"
                ],
                "suffix": [
                    "                    while keep_going:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "read_with_timeout",
                            "position": {
                                "start": {
                                    "line": 71,
                                    "column": 27
                                },
                                "end": {
                                    "line": 71,
                                    "column": 44
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/rc/send_text.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "tty",
                            "position": {
                                "start": {
                                    "line": 71,
                                    "column": 55
                                },
                                "end": {
                                    "line": 71,
                                    "column": 58
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/rc/send_text.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "                    while keep_going:\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "                        if not tty.wait_till_read_available():\n",
                    "                            break\n"
                ],
                "parent_version_range": {
                    "start": 73,
                    "end": 73
                },
                "child_version_range": {
                    "start": 73,
                    "end": 75
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if sys.stdin.isatty():",
                        "start_line": 67,
                        "end_line": 86
                    },
                    {
                        "type": "with_statement",
                        "statement": "with TTYIO() as tty:",
                        "start_line": 71,
                        "end_line": 79
                    },
                    {
                        "type": "while_statement",
                        "statement": "while keep_going:",
                        "start_line": 72,
                        "end_line": 79
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "SendText",
                        "signature": "class SendText(RemoteCommand):",
                        "at_line": 22
                    },
                    {
                        "type": "function",
                        "name": "message_to_kitty",
                        "signature": "def message_to_kitty(self, global_opts: RCOptions, opts: 'CLIOptions', args: ArgsType)->PayloadType:",
                        "at_line": 62
                    },
                    {
                        "type": "function",
                        "name": "pipe",
                        "signature": "def pipe()->CmdGenerator:",
                        "at_line": 66
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: kitty/rc/send_text.py\nCode:\n         class SendText(RemoteCommand):\n             ...\n             def message_to_kitty(self, global_opts: RCOptions, opts: 'CLIOptions', args: ArgsType)->PayloadType:\n                 ...\n                 def pipe()->CmdGenerator:\n                     ...\n72 72                        while keep_going:\n   73  +                         if not tty.wait_till_read_available():\n   74  +                             break\n73 75                            data = os.read(tty.tty_fd, limit)\n       ...\n",
                "file_path": "kitty/rc/send_text.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "tty",
                    "wait_till_read_available"
                ],
                "prefix": [
                    "                    while keep_going:\n"
                ],
                "suffix": [
                    "                        data = os.read(tty.tty_fd, limit)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "tty",
                            "position": {
                                "start": {
                                    "line": 73,
                                    "column": 31
                                },
                                "end": {
                                    "line": 73,
                                    "column": 34
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/rc/send_text.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "wait_till_read_available",
                            "position": {
                                "start": {
                                    "line": 73,
                                    "column": 35
                                },
                                "end": {
                                    "line": 73,
                                    "column": 59
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/rc/send_text.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                        data = os.read(tty.tty_fd, limit)\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "                        if not data:\n",
                    "                            break\n"
                ],
                "parent_version_range": {
                    "start": 74,
                    "end": 74
                },
                "child_version_range": {
                    "start": 76,
                    "end": 78
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if sys.stdin.isatty():",
                        "start_line": 67,
                        "end_line": 86
                    },
                    {
                        "type": "with_statement",
                        "statement": "with TTYIO() as tty:",
                        "start_line": 71,
                        "end_line": 79
                    },
                    {
                        "type": "while_statement",
                        "statement": "while keep_going:",
                        "start_line": 72,
                        "end_line": 79
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "SendText",
                        "signature": "class SendText(RemoteCommand):",
                        "at_line": 22
                    },
                    {
                        "type": "function",
                        "name": "message_to_kitty",
                        "signature": "def message_to_kitty(self, global_opts: RCOptions, opts: 'CLIOptions', args: ArgsType)->PayloadType:",
                        "at_line": 62
                    },
                    {
                        "type": "function",
                        "name": "pipe",
                        "signature": "def pipe()->CmdGenerator:",
                        "at_line": 66
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: kitty/rc/send_text.py\nCode:\n         class SendText(RemoteCommand):\n             ...\n             def message_to_kitty(self, global_opts: RCOptions, opts: 'CLIOptions', args: ArgsType)->PayloadType:\n                 ...\n                 def pipe()->CmdGenerator:\n                     ...\n73 75                            data = os.read(tty.tty_fd, limit)\n   76  +                         if not data:\n   77  +                             break\n74 78                            decoded_data = data.decode('utf-8')\n75 79                            if '\\x04' in decoded_data:\n76 80                                decoded_data = decoded_data[:decoded_data.index('\\x04')]\n       ...\n",
                "file_path": "kitty/rc/send_text.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "data"
                ],
                "prefix": [
                    "                        data = os.read(tty.tty_fd, limit)\n"
                ],
                "suffix": [
                    "                        decoded_data = data.decode('utf-8')\n",
                    "                        if '\\x04' in decoded_data:\n",
                    "                            decoded_data = decoded_data[:decoded_data.index('\\x04')]\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                        decoded_data = data.decode('utf-8')\n",
                "                        if '\\x04' in decoded_data:\n",
                "                            decoded_data = decoded_data[:decoded_data.index('\\x04')]\n",
                "                            keep_going = False\n",
                "                        ret['data'] = 'text:' + decoded_data\n",
                "                        yield ret\n",
                "            else:\n",
                "                while True:\n",
                "                    data = sys.stdin.buffer.read(limit)\n",
                "                    if not data:\n",
                "                        break\n",
                "                    ret['data'] = 'base64:' + base64.standard_b64encode(data).decode('ascii')\n",
                "                    yield ret\n",
                "\n",
                "        def chunks(text: str) -> CmdGenerator:\n",
                "            data = parse_send_text_bytes(text).decode('utf-8')\n",
                "            while data:\n",
                "                ret['data'] = 'text:' + data[:limit]\n",
                "                yield ret\n",
                "                data = data[limit:]\n",
                "\n",
                "        def file_pipe(path: str) -> CmdGenerator:\n",
                "            with open(path, 'rb') as f:\n",
                "                while True:\n",
                "                    data = f.read(limit)\n",
                "                    if not data:\n",
                "                        break\n",
                "                    ret['data'] = 'base64:' + base64.standard_b64encode(data).decode('ascii')\n",
                "                    yield ret\n",
                "\n",
                "        sources = []\n",
                "        if opts.stdin:\n",
                "            sources.append(pipe())\n",
                "\n",
                "        if opts.from_file:\n",
                "            sources.append(file_pipe(opts.from_file))\n",
                "\n",
                "        text = ' '.join(args)\n",
                "        sources.append(chunks(text))\n",
                "\n",
                "        def chain() -> CmdGenerator:\n",
                "            for src in sources:\n",
                "                yield from src\n",
                "        return chain()\n",
                "\n",
                "    def response_from_kitty(self, boss: Boss, window: Optional[Window], payload_get: PayloadGetType) -> ResponseType:\n",
                "        if payload_get('all'):\n",
                "            windows: List[Optional[Window]] = list(boss.all_windows)\n",
                "        else:\n",
                "            windows = [boss.active_window]\n",
                "            match = payload_get('match')\n",
                "            if match:\n",
                "                windows = list(boss.match_windows(match))\n",
                "            mt = payload_get('match_tab')\n",
                "            if mt:\n",
                "                windows = []\n",
                "                tabs = tuple(boss.match_tabs(mt))\n",
                "                if not tabs:\n",
                "                    raise MatchError(payload_get('match_tab'), 'tabs')\n",
                "                for tab in tabs:\n",
                "                    windows += tuple(tab)\n",
                "        pdata: str = payload_get('data')\n",
                "        encoding, _, q = pdata.partition(':')\n",
                "        if encoding == 'text':\n",
                "            data: Union[bytes, WindowSystemKeyEvent] = q.encode('utf-8')\n",
                "        elif encoding == 'base64':\n",
                "            data = base64.standard_b64decode(q)\n",
                "        elif encoding == 'kitty-key':\n",
                "            bdata = base64.standard_b64decode(q)\n",
                "            candidate = decode_key_event_as_window_system_key(bdata.decode('ascii'))\n",
                "            if candidate is None:\n",
                "                raise ValueError(f'Could not decode window system key: {q}')\n",
                "            data = candidate\n",
                "        else:\n",
                "            raise TypeError(f'Invalid encoding for send-text data: {encoding}')\n",
                "        exclude_active = payload_get('exclude_active')\n",
                "        for window in windows:\n",
                "            if window is not None:\n",
                "                if not exclude_active or window is not boss.active_window:\n",
                "                    if isinstance(data, WindowSystemKeyEvent):\n",
                "                        kdata = window.encoded_key(data)\n",
                "                        if kdata:\n",
                "                            window.write_to_child(kdata)\n",
                "                    else:\n",
                "                        window.write_to_child(data)\n",
                "        return None\n",
                "\n",
                "\n",
                "send_text = SendText()"
            ]
        ],
        "kitty/utils.py": [
            [
                "#!/usr/bin/env python3\n",
                "# License: GPL v3 Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n",
                "\n",
                "import atexit\n",
                "import errno\n",
                "import fcntl\n",
                "import math\n",
                "import os\n",
                "import re\n",
                "import string\n",
                "import sys\n",
                "from contextlib import suppress\n",
                "from functools import lru_cache\n",
                "from time import monotonic\n",
                "from typing import (\n",
                "    TYPE_CHECKING, Any, Callable, Dict, Generator, Iterable, List, Mapping,\n",
                "    Match, NamedTuple, Optional, Pattern, Tuple, Union, cast\n",
                ")\n",
                "\n",
                "from .constants import (\n",
                "    appname, is_macos, is_wayland, read_kitty_resource, shell_path,\n",
                "    supports_primary_selection\n",
                ")\n",
                "from .rgb import to_color\n",
                "from .types import run_once\n",
                "from .typing import AddressFamily, PopenType, Socket, StartupCtx\n",
                "from .fast_data_types import Color\n",
                "\n",
                "if TYPE_CHECKING:\n",
                "    from .fast_data_types import OSWindowSize\n",
                "    from .options.types import Options\n",
                "else:\n",
                "    Options = object\n",
                "\n",
                "\n",
                "def expandvars(val: str, env: Mapping[str, str] = {}, fallback_to_os_env: bool = True) -> str:\n",
                "    '''\n",
                "    Expand $VAR and ${VAR} Use $$ for a literal $\n",
                "    '''\n",
                "\n",
                "    def sub(m: 'Match[str]') -> str:\n",
                "        key = m.group(1) or m.group(2)\n",
                "        result = env.get(key)\n",
                "        if result is None and fallback_to_os_env:\n",
                "            result = os.environ.get(key)\n",
                "        if result is None:\n",
                "            result = m.group()\n",
                "        return result\n",
                "\n",
                "    if '$' not in val:\n",
                "        return val\n",
                "\n",
                "    return re.sub(r'\\$(?:(\\w+)|\\{([^}]+)\\})', sub, val.replace('$$', '\\0')).replace('\\0', '$')\n",
                "\n",
                "\n",
                "def platform_window_id(os_window_id: int) -> Optional[int]:\n",
                "    if is_macos:\n",
                "        from .fast_data_types import cocoa_window_id\n",
                "        with suppress(Exception):\n",
                "            return cocoa_window_id(os_window_id)\n",
                "    if not is_wayland():\n",
                "        from .fast_data_types import x11_window_id\n",
                "        with suppress(Exception):\n",
                "            return x11_window_id(os_window_id)\n",
                "    return None\n",
                "\n",
                "\n",
                "def load_shaders(name: str, vertex_name: str = '', fragment_name: str = '') -> Tuple[str, str]:\n",
                "    from .fast_data_types import GLSL_VERSION\n",
                "\n",
                "    def load(which: str, lname: str = '') -> str:\n",
                "        lname = lname or name\n",
                "        return read_kitty_resource(f'{lname}_{which}.glsl').decode('utf-8').replace('GLSL_VERSION', str(GLSL_VERSION), 1)\n",
                "\n",
                "    return load('vertex', vertex_name), load('fragment', fragment_name)\n",
                "\n",
                "\n",
                "def safe_print(*a: Any, **k: Any) -> None:\n",
                "    with suppress(Exception):\n",
                "        print(*a, **k)\n",
                "\n",
                "\n",
                "def log_error(*a: Any, **k: str) -> None:\n",
                "    from .fast_data_types import log_error_string\n",
                "    output = getattr(log_error, 'redirect', log_error_string)\n",
                "    with suppress(Exception):\n",
                "        msg = k.get('sep', ' ').join(map(str, a)) + k.get('end', '').replace('\\0', '')\n",
                "        output(msg)\n",
                "\n",
                "\n",
                "def ceil_int(x: float) -> int:\n",
                "    return int(math.ceil(x))\n",
                "\n",
                "\n",
                "def sanitize_title(x: str) -> str:\n",
                "    return re.sub(r'\\s+', ' ', re.sub(r'[\\0-\\x19\\x80-\\x9f]', '', x))\n",
                "\n",
                "\n",
                "def color_as_int(val: Color) -> int:\n",
                "    return int(val) & 0xffffff\n",
                "\n",
                "\n",
                "def color_from_int(val: int) -> Color:\n",
                "    return Color((val >> 16) & 0xFF, (val >> 8) & 0xFF, val & 0xFF)\n",
                "\n",
                "\n",
                "def parse_color_set(raw: str) -> Generator[Tuple[int, Optional[int]], None, None]:\n",
                "    parts = raw.split(';')\n",
                "    lp = len(parts)\n",
                "    if lp % 2 != 0:\n",
                "        return\n",
                "    for c_, spec in [parts[i:i + 2] for i in range(0, len(parts), 2)]:\n",
                "        try:\n",
                "            c = int(c_)\n",
                "            if c < 0 or c > 255:\n",
                "                continue\n",
                "            if spec == '?':\n",
                "                yield c, None\n",
                "            else:\n",
                "                q = to_color(spec)\n",
                "                if q is not None:\n",
                "                    yield c, int(q) & 0xffffff\n",
                "        except Exception:\n",
                "            continue\n",
                "\n",
                "\n",
                "class ScreenSize(NamedTuple):\n",
                "    rows: int\n",
                "    cols: int\n",
                "    width: int\n",
                "    height: int\n",
                "    cell_width: int\n",
                "    cell_height: int\n",
                "\n",
                "\n",
                "class ScreenSizeGetter:\n",
                "    changed = True\n",
                "    Size = ScreenSize\n",
                "    ans: Optional[ScreenSize] = None\n",
                "\n",
                "    def __init__(self, fd: Optional[int]):\n",
                "        if fd is None:\n",
                "            fd = sys.stdout.fileno()\n",
                "        self.fd = fd\n",
                "\n",
                "    def __call__(self) -> ScreenSize:\n",
                "        if self.changed:\n",
                "            import array\n",
                "            import fcntl\n",
                "            import termios\n",
                "            buf = array.array('H', [0, 0, 0, 0])\n",
                "            fcntl.ioctl(self.fd, termios.TIOCGWINSZ, cast(bytearray, buf))\n",
                "            rows, cols, width, height = tuple(buf)\n",
                "            cell_width, cell_height = width // (cols or 1), height // (rows or 1)\n",
                "            self.ans = ScreenSize(rows, cols, width, height, cell_width, cell_height)\n",
                "            self.changed = False\n",
                "        return cast(ScreenSize, self.ans)\n",
                "\n",
                "\n",
                "@lru_cache(maxsize=64)\n",
                "def screen_size_function(fd: Optional[int] = None) -> ScreenSizeGetter:\n",
                "    return ScreenSizeGetter(fd)\n",
                "\n",
                "\n",
                "def fit_image(width: int, height: int, pwidth: int, pheight: int) -> Tuple[int, int]:\n",
                "    from math import floor\n",
                "    if height > pheight:\n",
                "        corrf = pheight / float(height)\n",
                "        width, height = floor(corrf * width), pheight\n",
                "    if width > pwidth:\n",
                "        corrf = pwidth / float(width)\n",
                "        width, height = pwidth, floor(corrf * height)\n",
                "    if height > pheight:\n",
                "        corrf = pheight / float(height)\n",
                "        width, height = floor(corrf * width), pheight\n",
                "\n",
                "    return int(width), int(height)\n",
                "\n",
                "\n",
                "def set_primary_selection(text: Union[str, bytes]) -> None:\n",
                "    if not supports_primary_selection:\n",
                "        return  # There is no primary selection\n",
                "    from kitty.fast_data_types import set_primary_selection as s\n",
                "    s(text)\n",
                "\n",
                "\n",
                "def get_primary_selection() -> str:\n",
                "    if not supports_primary_selection:\n",
                "        return ''  # There is no primary selection\n",
                "    from kitty.fast_data_types import get_primary_selection as g\n",
                "    return (g() or b'').decode('utf-8', 'replace')\n",
                "\n",
                "\n",
                "def base64_encode(\n",
                "    integer: int,\n",
                "    chars: str = string.ascii_uppercase + string.ascii_lowercase + string.digits +\n",
                "    '+/'\n",
                ") -> str:\n",
                "    ans = ''\n",
                "    while True:\n",
                "        integer, remainder = divmod(integer, 64)\n",
                "        ans = chars[remainder] + ans\n",
                "        if integer == 0:\n",
                "            break\n",
                "    return ans\n",
                "\n",
                "\n",
                "def command_for_open(program: Union[str, List[str]] = 'default') -> List[str]:\n",
                "    if isinstance(program, str):\n",
                "        from .conf.utils import to_cmdline\n",
                "        program = to_cmdline(program)\n",
                "    if program == ['default']:\n",
                "        cmd = ['open'] if is_macos else ['xdg-open']\n",
                "    else:\n",
                "        cmd = program\n",
                "    return cmd\n",
                "\n",
                "\n",
                "def open_cmd(cmd: Union[Iterable[str], List[str]], arg: Union[None, Iterable[str], str] = None, cwd: Optional[str] = None) -> 'PopenType[bytes]':\n",
                "    import subprocess\n",
                "    if arg is not None:\n",
                "        cmd = list(cmd)\n",
                "        if isinstance(arg, str):\n",
                "            cmd.append(arg)\n",
                "        else:\n",
                "            cmd.extend(arg)\n",
                "    return subprocess.Popen(tuple(cmd), stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, cwd=cwd or None)\n",
                "\n",
                "\n",
                "def open_url(url: str, program: Union[str, List[str]] = 'default', cwd: Optional[str] = None) -> 'PopenType[bytes]':\n",
                "    return open_cmd(command_for_open(program), url, cwd=cwd)\n",
                "\n",
                "\n",
                "def detach(fork: bool = True, setsid: bool = True, redirect: bool = True) -> None:\n",
                "    if fork:\n",
                "        # Detach from the controlling process.\n",
                "        if os.fork() != 0:\n",
                "            raise SystemExit(0)\n",
                "    if setsid:\n",
                "        os.setsid()\n",
                "    if redirect:\n",
                "        from .fast_data_types import redirect_std_streams\n",
                "        redirect_std_streams(os.devnull)\n",
                "\n",
                "\n",
                "def adjust_line_height(cell_height: int, val: Union[int, float]) -> int:\n",
                "    if isinstance(val, int):\n",
                "        return cell_height + val\n",
                "    return int(cell_height * val)\n",
                "\n",
                "\n",
                "def init_startup_notification_x11(window_handle: int, startup_id: Optional[str] = None) -> Optional['StartupCtx']:\n",
                "    # https://specifications.freedesktop.org/startup-notification-spec/startup-notification-latest.txt\n",
                "    from kitty.fast_data_types import init_x11_startup_notification\n",
                "    sid = startup_id or os.environ.pop('DESKTOP_STARTUP_ID', None)  # ensure child processes don't get this env var\n",
                "    if not sid:\n",
                "        return None\n",
                "    from .fast_data_types import x11_display\n",
                "    display = x11_display()\n",
                "    if not display:\n",
                "        return None\n",
                "    return init_x11_startup_notification(display, window_handle, sid)\n",
                "\n",
                "\n",
                "def end_startup_notification_x11(ctx: 'StartupCtx') -> None:\n",
                "    from kitty.fast_data_types import end_x11_startup_notification\n",
                "    end_x11_startup_notification(ctx)\n",
                "\n",
                "\n",
                "def init_startup_notification(window_handle: Optional[int], startup_id: Optional[str] = None) -> Optional['StartupCtx']:\n",
                "    if is_macos or is_wayland():\n",
                "        return None\n",
                "    if window_handle is None:\n",
                "        log_error('Could not perform startup notification as window handle not present')\n",
                "        return None\n",
                "    try:\n",
                "        try:\n",
                "            return init_startup_notification_x11(window_handle, startup_id)\n",
                "        except OSError as e:\n",
                "            if not str(e).startswith(\"Failed to load libstartup-notification\"):\n",
                "                raise e\n",
                "            log_error(\n",
                "                f'{e}. This has two main effects:',\n",
                "                'There will be no startup feedback and when using --single-instance, kitty windows may start on an incorrect desktop/workspace.')\n",
                "    except Exception:\n",
                "        import traceback\n",
                "        traceback.print_exc()\n",
                "    return None\n",
                "\n",
                "\n",
                "def end_startup_notification(ctx: Optional['StartupCtx']) -> None:\n",
                "    if not ctx:\n",
                "        return\n",
                "    if is_macos or is_wayland():\n",
                "        return\n",
                "    try:\n",
                "        end_startup_notification_x11(ctx)\n",
                "    except Exception:\n",
                "        import traceback\n",
                "        traceback.print_exc()\n",
                "\n",
                "\n",
                "class startup_notification_handler:\n",
                "\n",
                "    def __init__(self, do_notify: bool = True, startup_id: Optional[str] = None, extra_callback: Optional[Callable[[int], None]] = None):\n",
                "        self.do_notify = do_notify\n",
                "        self.startup_id = startup_id\n",
                "        self.extra_callback = extra_callback\n",
                "        self.ctx: Optional['StartupCtx'] = None\n",
                "\n",
                "    def __enter__(self) -> Callable[[int], None]:\n",
                "\n",
                "        def pre_show_callback(window_handle: int) -> None:\n",
                "            if self.extra_callback is not None:\n",
                "                self.extra_callback(window_handle)\n",
                "            if self.do_notify:\n",
                "                self.ctx = init_startup_notification(window_handle, self.startup_id)\n",
                "\n",
                "        return pre_show_callback\n",
                "\n",
                "    def __exit__(self, *a: Any) -> None:\n",
                "        if self.ctx is not None:\n",
                "            end_startup_notification(self.ctx)\n",
                "\n",
                "\n",
                "def remove_socket_file(s: 'Socket', path: Optional[str] = None) -> None:\n",
                "    with suppress(OSError):\n",
                "        s.close()\n",
                "    if path:\n",
                "        with suppress(OSError):\n",
                "            os.unlink(path)\n",
                "\n",
                "\n",
                "def unix_socket_paths(name: str, ext: str = '.lock') -> Generator[str, None, None]:\n",
                "    import tempfile\n",
                "    home = os.path.expanduser('~')\n",
                "    candidates = [tempfile.gettempdir(), home]\n",
                "    if is_macos:\n",
                "        from .fast_data_types import user_cache_dir\n",
                "        candidates = [user_cache_dir(), '/Library/Caches']\n",
                "    for loc in candidates:\n",
                "        if os.access(loc, os.W_OK | os.R_OK | os.X_OK):\n",
                "            filename = ('.' if loc == home else '') + name + ext\n",
                "            yield os.path.join(loc, filename)\n",
                "\n",
                "\n",
                "def single_instance_unix(name: str) -> bool:\n",
                "    import socket\n",
                "    for path in unix_socket_paths(name):\n",
                "        socket_path = path.rpartition('.')[0] + '.sock'\n",
                "        fd = os.open(path, os.O_CREAT | os.O_WRONLY | os.O_TRUNC | os.O_CLOEXEC)\n",
                "        try:\n",
                "            fcntl.lockf(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n",
                "        except OSError as err:\n",
                "            if err.errno in (errno.EAGAIN, errno.EACCES):\n",
                "                # Client\n",
                "                s = socket.socket(family=socket.AF_UNIX)\n",
                "                s.connect(socket_path)\n",
                "                single_instance.socket = s\n",
                "                return False\n",
                "            raise\n",
                "        s = socket.socket(family=socket.AF_UNIX)\n",
                "        try:\n",
                "            s.bind(socket_path)\n",
                "        except OSError as err:\n",
                "            if err.errno in (errno.EADDRINUSE, errno.EEXIST):\n",
                "                os.unlink(socket_path)\n",
                "                s.bind(socket_path)\n",
                "            else:\n",
                "                raise\n",
                "        single_instance.socket = s  # prevent garbage collection from closing the socket\n",
                "        atexit.register(remove_socket_file, s, socket_path)\n",
                "        s.listen()\n",
                "        s.set_inheritable(False)\n",
                "        return True\n",
                "    return False\n",
                "\n",
                "\n",
                "class SingleInstance:\n",
                "\n",
                "    socket: Optional['Socket'] = None\n",
                "\n",
                "    def __call__(self, group_id: Optional[str] = None) -> bool:\n",
                "        import socket\n",
                "        name = f'{appname}-ipc-{os.geteuid()}'\n",
                "        if group_id:\n",
                "            name += f'-{group_id}'\n",
                "\n",
                "        s = socket.socket(family=socket.AF_UNIX)\n",
                "        # First try with abstract UDS\n",
                "        addr = '\\0' + name\n",
                "        try:\n",
                "            s.bind(addr)\n",
                "        except OSError as err:\n",
                "            if err.errno == errno.ENOENT:\n",
                "                return single_instance_unix(name)\n",
                "            if err.errno == errno.EADDRINUSE:\n",
                "                s.connect(addr)\n",
                "                self.socket = s\n",
                "                return False\n",
                "            raise\n",
                "        s.listen()\n",
                "        self.socket = s  # prevent garbage collection from closing the socket\n",
                "        s.set_inheritable(False)\n",
                "        atexit.register(remove_socket_file, s)\n",
                "        return True\n",
                "\n",
                "\n",
                "single_instance = SingleInstance()\n",
                "\n",
                "\n",
                "def parse_address_spec(spec: str) -> Tuple[AddressFamily, Union[Tuple[str, int], str], Optional[str]]:\n",
                "    import socket\n",
                "    protocol, rest = spec.split(':', 1)\n",
                "    socket_path = None\n",
                "    address: Union[str, Tuple[str, int]] = ''\n",
                "    if protocol == 'unix':\n",
                "        family = socket.AF_UNIX\n",
                "        address = rest\n",
                "        if address.startswith('@') and len(address) > 1:\n",
                "            address = '\\0' + address[1:]\n",
                "        else:\n",
                "            socket_path = address\n",
                "    elif protocol in ('tcp', 'tcp6'):\n",
                "        family = socket.AF_INET if protocol == 'tcp' else socket.AF_INET6\n",
                "        host, port = rest.rsplit(':', 1)\n",
                "        address = host, int(port)\n",
                "    else:\n",
                "        raise ValueError(f'Unknown protocol in --listen-on value: {spec}')\n",
                "    return family, address, socket_path\n",
                "\n",
                "\n",
                "def write_all(fd: int, data: Union[str, bytes]) -> None:\n",
                "    if isinstance(data, str):\n",
                "        data = data.encode('utf-8')\n",
                "    while data:\n",
                "        n = os.write(fd, data)\n",
                "        if not n:\n",
                "            break\n",
                "        data = data[n:]\n",
                "\n",
                "\n",
                "class TTYIO:\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    def __init__(self, read_with_timeout: bool = True):\n",
                    "        self.read_with_timeout = read_with_timeout\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 444,
                    "end": 444
                },
                "child_version_range": {
                    "start": 444,
                    "end": 447
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "TTYIO",
                        "signature": "class TTYIO:",
                        "at_line": 442
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: kitty/utils.py\nCode:\n441 441    \n442 442    class TTYIO:\n443 443    \n    444  +     def __init__(self, read_with_timeout: bool = True):\n    445  +         self.read_with_timeout = read_with_timeout\n    446  + \n444 447        def __enter__(self) -> 'TTYIO':\n445 448            from .fast_data_types import open_tty\n         ...\n",
                "file_path": "kitty/utils.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "__init__",
                    "bool",
                    "read_with_timeout",
                    "self"
                ],
                "prefix": [
                    "\n",
                    "class TTYIO:\n",
                    "\n"
                ],
                "suffix": [
                    "    def __enter__(self) -> 'TTYIO':\n",
                    "        from .fast_data_types import open_tty\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "read_with_timeout",
                            "position": {
                                "start": {
                                    "line": 444,
                                    "column": 23
                                },
                                "end": {
                                    "line": 444,
                                    "column": 40
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/utils.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "read_with_timeout",
                            "position": {
                                "start": {
                                    "line": 445,
                                    "column": 13
                                },
                                "end": {
                                    "line": 445,
                                    "column": 30
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/utils.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "    def __enter__(self) -> 'TTYIO':\n",
                "        from .fast_data_types import open_tty\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        self.tty_fd, self.original_termios = open_tty(True)\n"
                ],
                "after": [
                    "        self.tty_fd, self.original_termios = open_tty(self.read_with_timeout)\n"
                ],
                "parent_version_range": {
                    "start": 446,
                    "end": 447
                },
                "child_version_range": {
                    "start": 449,
                    "end": 450
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "TTYIO",
                        "signature": "class TTYIO:",
                        "at_line": 442
                    },
                    {
                        "type": "function",
                        "name": "__enter__",
                        "signature": "def __enter__(self)->'TTYIO':",
                        "at_line": 444
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: kitty/utils.py\nCode:\n           class TTYIO:\n               ...\n444 447        def __enter__(self) -> 'TTYIO':\n445 448            from .fast_data_types import open_tty\n446      -         self.tty_fd, self.original_termios = open_tty(True)\n    449  +         self.tty_fd, self.original_termios = open_tty(self.read_with_timeout)\n447 450            return self\n448 451    \n449 452        def __exit__(self, *a: Any) -> None:\n         ...\n",
                "file_path": "kitty/utils.py",
                "identifiers_before": [
                    "open_tty",
                    "original_termios",
                    "self",
                    "tty_fd"
                ],
                "identifiers_after": [
                    "open_tty",
                    "original_termios",
                    "read_with_timeout",
                    "self",
                    "tty_fd"
                ],
                "prefix": [
                    "    def __enter__(self) -> 'TTYIO':\n",
                    "        from .fast_data_types import open_tty\n"
                ],
                "suffix": [
                    "        return self\n",
                    "\n",
                    "    def __exit__(self, *a: Any) -> None:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "read_with_timeout",
                            "position": {
                                "start": {
                                    "line": 449,
                                    "column": 59
                                },
                                "end": {
                                    "line": 449,
                                    "column": 76
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/utils.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "tty_fd",
                            "position": {
                                "start": {
                                    "line": 449,
                                    "column": 13
                                },
                                "end": {
                                    "line": 449,
                                    "column": 19
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/utils.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "        return self\n",
                "\n",
                "    def __exit__(self, *a: Any) -> None:\n",
                "        from .fast_data_types import close_tty\n",
                "        close_tty(self.tty_fd, self.original_termios)\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    def wait_till_read_available(self) -> bool:\n",
                    "        import select\n",
                    "        rd = select.select([self.tty_fd], [], [])[0]\n",
                    "        return bool(rd)\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 453,
                    "end": 453
                },
                "child_version_range": {
                    "start": 456,
                    "end": 461
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "TTYIO",
                        "signature": "class TTYIO:",
                        "at_line": 442
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: kitty/utils.py\nCode:\n           class TTYIO:\n               ...\n450 453            from .fast_data_types import close_tty\n451 454            close_tty(self.tty_fd, self.original_termios)\n452 455    \n    456  +     def wait_till_read_available(self) -> bool:\n    457  +         import select\n    458  +         rd = select.select([self.tty_fd], [], [])[0]\n    459  +         return bool(rd)\n    460  + \n453 461        def send(self, data: Union[str, bytes, Iterable[Union[str, bytes]]]) -> None:\n454 462            if isinstance(data, (str, bytes)):\n455 463                write_all(self.tty_fd, data)\n         ...\n",
                "file_path": "kitty/utils.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "bool",
                    "rd",
                    "select",
                    "self",
                    "tty_fd",
                    "wait_till_read_available"
                ],
                "prefix": [
                    "        from .fast_data_types import close_tty\n",
                    "        close_tty(self.tty_fd, self.original_termios)\n",
                    "\n"
                ],
                "suffix": [
                    "    def send(self, data: Union[str, bytes, Iterable[Union[str, bytes]]]) -> None:\n",
                    "        if isinstance(data, (str, bytes)):\n",
                    "            write_all(self.tty_fd, data)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "tty_fd",
                            "position": {
                                "start": {
                                    "line": 458,
                                    "column": 33
                                },
                                "end": {
                                    "line": 458,
                                    "column": 39
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/utils.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "wait_till_read_available",
                            "position": {
                                "start": {
                                    "line": 456,
                                    "column": 8
                                },
                                "end": {
                                    "line": 456,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/utils.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "    def send(self, data: Union[str, bytes, Iterable[Union[str, bytes]]]) -> None:\n",
                "        if isinstance(data, (str, bytes)):\n",
                "            write_all(self.tty_fd, data)\n",
                "        else:\n",
                "            for chunk in data:\n",
                "                write_all(self.tty_fd, chunk)\n",
                "\n",
                "    def recv(self, more_needed: Callable[[bytes], bool], timeout: float, sz: int = 1) -> None:\n",
                "        fd = self.tty_fd\n",
                "        start_time = monotonic()\n",
                "        while timeout > monotonic() - start_time:\n",
                "            # will block for 0.1 secs waiting for data because we have set\n",
                "            # VMIN=0 VTIME=1 in termios\n",
                "            data = os.read(fd, sz)\n",
                "            if data and not more_needed(data):\n",
                "                break\n",
                "\n",
                "\n",
                "def natsort_ints(iterable: Iterable[str]) -> List[str]:\n",
                "\n",
                "    def convert(text: str) -> Union[int, str]:\n",
                "        return int(text) if text.isdigit() else text\n",
                "\n",
                "    def alphanum_key(key: str) -> Tuple[Union[int, str], ...]:\n",
                "        return tuple(map(convert, re.split(r'(\\d+)', key)))\n",
                "\n",
                "    return sorted(iterable, key=alphanum_key)\n",
                "\n",
                "\n",
                "def resolve_editor_cmd(editor: str, shell_env: Mapping[str, str]) -> Optional[str]:\n",
                "    import shlex\n",
                "    editor_cmd = shlex.split(editor)\n",
                "    editor_exe = (editor_cmd or ('',))[0]\n",
                "    if editor_exe and os.path.isabs(editor_exe):\n",
                "        return editor\n",
                "    if not editor_exe:\n",
                "        return None\n",
                "\n",
                "    def patched(exe: str) -> str:\n",
                "        editor_cmd[0] = exe\n",
                "        return ' '.join(map(shlex.quote, editor_cmd))\n",
                "\n",
                "    if shell_env is os.environ:\n",
                "        q = find_exe(editor_exe)\n",
                "        if q:\n",
                "            return patched(q)\n",
                "    elif 'PATH' in shell_env:\n",
                "        import shutil\n",
                "        q = shutil.which(editor_exe, path=shell_env['PATH'])\n",
                "        if q:\n",
                "            return patched(q)\n",
                "    return None\n",
                "\n",
                "\n",
                "def get_editor_from_env(env: Mapping[str, str]) -> Optional[str]:\n",
                "    for var in ('VISUAL', 'EDITOR'):\n",
                "        editor = env.get(var)\n",
                "        if editor:\n",
                "            editor = resolve_editor_cmd(editor, env)\n",
                "            if editor:\n",
                "                return editor\n",
                "    return None\n",
                "\n",
                "\n",
                "def get_editor_from_env_vars(opts: Optional[Options] = None) -> List[str]:\n",
                "    import shlex\n",
                "    import shutil\n",
                "\n",
                "    editor = get_editor_from_env(os.environ)\n",
                "    if not editor:\n",
                "        shell_env = read_shell_environment(opts)\n",
                "        editor = get_editor_from_env(shell_env)\n",
                "\n",
                "    for ans in (editor, 'vim', 'nvim', 'vi', 'emacs', 'kak', 'micro', 'nano', 'vis'):\n",
                "        if ans and shutil.which(shlex.split(ans)[0]):\n",
                "            break\n",
                "    else:\n",
                "        ans = 'vim'\n",
                "    return shlex.split(ans)\n",
                "\n",
                "\n",
                "def get_editor(opts: Optional[Options] = None) -> List[str]:\n",
                "    if opts is None:\n",
                "        from .fast_data_types import get_options\n",
                "        try:\n",
                "            opts = get_options()\n",
                "        except RuntimeError:\n",
                "            # we are in a kitten\n",
                "            from .cli import create_default_opts\n",
                "            opts = create_default_opts()\n",
                "    if opts.editor == '.':\n",
                "        return get_editor_from_env_vars()\n",
                "    import shlex\n",
                "    return shlex.split(opts.editor)\n",
                "\n",
                "\n",
                "def is_path_in_temp_dir(path: str) -> bool:\n",
                "    if not path:\n",
                "        return False\n",
                "\n",
                "    def abspath(x: Optional[str]) -> str:\n",
                "        if x:\n",
                "            x = os.path.abspath(os.path.realpath(x))\n",
                "        return x or ''\n",
                "\n",
                "    import tempfile\n",
                "    path = abspath(path)\n",
                "    candidates = frozenset(map(abspath, ('/tmp', '/dev/shm', os.environ.get('TMPDIR', None), tempfile.gettempdir())))\n",
                "    for q in candidates:\n",
                "        if q and path.startswith(q):\n",
                "            return True\n",
                "    return False\n",
                "\n",
                "\n",
                "def func_name(f: Any) -> str:\n",
                "    if hasattr(f, '__name__'):\n",
                "        return str(f.__name__)\n",
                "    if hasattr(f, 'func') and hasattr(f.func, '__name__'):\n",
                "        return str(f.func.__name__)\n",
                "    return str(f)\n",
                "\n",
                "\n",
                "def resolved_shell(opts: Optional[Options] = None) -> List[str]:\n",
                "    q: str = getattr(opts, 'shell', '.')\n",
                "    if q == '.':\n",
                "        ans = [shell_path]\n",
                "    else:\n",
                "        import shlex\n",
                "        ans = shlex.split(q)\n",
                "    return ans\n",
                "\n",
                "\n",
                "@run_once\n",
                "def system_paths_on_macos() -> List[str]:\n",
                "    entries, seen = [], set()\n",
                "\n",
                "    def add_from_file(x: str) -> None:\n",
                "        try:\n",
                "            f = open(x)\n",
                "        except FileNotFoundError:\n",
                "            return\n",
                "        with f:\n",
                "            for line in f:\n",
                "                line = line.strip()\n",
                "                if line and not line.startswith('#') and line not in seen:\n",
                "                    if os.path.isdir(line):\n",
                "                        seen.add(line)\n",
                "                        entries.append(line)\n",
                "    try:\n",
                "        files = os.listdir('/etc/paths.d')\n",
                "    except FileNotFoundError:\n",
                "        files = []\n",
                "    for name in sorted(files):\n",
                "        add_from_file(os.path.join('/etc/paths.d', name))\n",
                "    add_from_file('/etc/paths')\n",
                "    return entries\n",
                "\n",
                "\n",
                "@lru_cache(maxsize=32)\n",
                "def find_exe(name: str) -> Optional[str]:\n",
                "    import shutil\n",
                "    ans = shutil.which(name)\n",
                "    if ans is None:\n",
                "        # In case PATH is messed up\n",
                "        if is_macos:\n",
                "            paths = system_paths_on_macos()\n",
                "        else:\n",
                "            paths = ['/usr/local/bin', '/opt/bin', '/usr/bin', '/bin', '/usr/sbin', '/sbin']\n",
                "        paths.insert(0, os.path.expanduser('~/.local/bin'))\n",
                "        path = os.pathsep.join(paths) + os.pathsep + os.defpath\n",
                "        ans = shutil.which(name, path=path)\n",
                "    return ans\n",
                "\n",
                "\n",
                "def read_shell_environment(opts: Optional[Options] = None) -> Dict[str, str]:\n",
                "    ans: Optional[Dict[str, str]] = getattr(read_shell_environment, 'ans', None)\n",
                "    if ans is None:\n",
                "        from .child import openpty, remove_blocking\n",
                "        ans = {}\n",
                "        setattr(read_shell_environment, 'ans', ans)\n",
                "        import subprocess\n",
                "        shell = resolved_shell(opts)\n",
                "        master, slave = openpty()\n",
                "        remove_blocking(master)\n",
                "        if '-l' not in shell and '--login' not in shell:\n",
                "            shell += ['-l']\n",
                "        if '-i' not in shell and '--interactive' not in shell:\n",
                "            shell += ['-i']\n",
                "        try:\n",
                "            p = subprocess.Popen(shell + ['-c', 'env'], stdout=slave, stdin=slave, stderr=slave, start_new_session=True, close_fds=True)\n",
                "        except FileNotFoundError:\n",
                "            log_error('Could not find shell to read environment')\n",
                "            return ans\n",
                "        with os.fdopen(master, 'rb') as stdout, os.fdopen(slave, 'wb'):\n",
                "            raw = b''\n",
                "            from subprocess import TimeoutExpired\n",
                "            from time import monotonic\n",
                "            start_time = monotonic()\n",
                "            while monotonic() - start_time < 1.5:\n",
                "                try:\n",
                "                    ret: Optional[int] = p.wait(0.01)\n",
                "                except TimeoutExpired:\n",
                "                    ret = None\n",
                "                with suppress(Exception):\n",
                "                    raw += stdout.read()\n",
                "                if ret is not None:\n",
                "                    break\n",
                "            if cast(Optional[int], p.returncode) is None:\n",
                "                log_error('Timed out waiting for shell to quit while reading shell environment')\n",
                "                p.kill()\n",
                "            elif p.returncode == 0:\n",
                "                while True:\n",
                "                    try:\n",
                "                        x = stdout.read()\n",
                "                    except Exception:\n",
                "                        break\n",
                "                    if not x:\n",
                "                        break\n",
                "                    raw += x\n",
                "                draw = raw.decode('utf-8', 'replace')\n",
                "                for line in draw.splitlines():\n",
                "                    k, v = line.partition('=')[::2]\n",
                "                    if k and v:\n",
                "                        ans[k] = v\n",
                "            else:\n",
                "                log_error('Failed to run shell to read its environment')\n",
                "    return ans\n",
                "\n",
                "\n",
                "def parse_uri_list(text: str) -> Generator[str, None, None]:\n",
                "    ' Get paths from file:// URLs '\n",
                "    from urllib.parse import unquote, urlparse\n",
                "    for line in text.splitlines():\n",
                "        if not line or line.startswith('#'):\n",
                "            continue\n",
                "        if not line.startswith('file://'):\n",
                "            yield line\n",
                "            continue\n",
                "        try:\n",
                "            purl = urlparse(line, allow_fragments=False)\n",
                "        except Exception:\n",
                "            yield line\n",
                "            continue\n",
                "        if purl.path:\n",
                "            yield unquote(purl.path)\n",
                "\n",
                "\n",
                "def edit_config_file() -> None:\n",
                "    from kitty.config import prepare_config_file_for_editing\n",
                "    p = prepare_config_file_for_editing()\n",
                "    editor = get_editor()\n",
                "    os.execvp(editor[0], editor + [p])\n",
                "\n",
                "\n",
                "class SSHConnectionData(NamedTuple):\n",
                "    binary: str\n",
                "    hostname: str\n",
                "    port: Optional[int] = None\n",
                "    identity_file: str = ''\n",
                "\n",
                "\n",
                "def get_new_os_window_size(\n",
                "    metrics: 'OSWindowSize', width: int, height: int, unit: str, incremental: bool = False, has_window_scaling: bool = True\n",
                ") -> Tuple[int, int]:\n",
                "    if unit == 'cells':\n",
                "        cw = metrics['cell_width']\n",
                "        ch = metrics['cell_height']\n",
                "        width *= cw\n",
                "        height *= ch\n",
                "        if has_window_scaling:\n",
                "            width = round(width / metrics['xscale'])\n",
                "            height = round(height / metrics['yscale'])\n",
                "    if incremental:\n",
                "        w = metrics['width'] + width\n",
                "        h = metrics['height'] + height\n",
                "    else:\n",
                "        w = width or metrics['width']\n",
                "        h = height or metrics['height']\n",
                "    return w, h\n",
                "\n",
                "\n",
                "def get_all_processes() -> Iterable[int]:\n",
                "    if is_macos:\n",
                "        from kitty.fast_data_types import get_all_processes as f\n",
                "        yield from f()\n",
                "    else:\n",
                "        for c in os.listdir('/proc'):\n",
                "            if c.isdigit():\n",
                "                yield int(c)\n",
                "\n",
                "\n",
                "def is_kitty_gui_cmdline(*cmd: str) -> bool:\n",
                "    if not cmd:\n",
                "        return False\n",
                "    if os.path.basename(cmd[0]) != 'kitty':\n",
                "        return False\n",
                "    if len(cmd) == 1:\n",
                "        return True\n",
                "    if '+' in cmd or '@' in cmd or cmd[1].startswith('+') or cmd[1].startswith('@'):\n",
                "        return False\n",
                "    return True\n",
                "\n",
                "\n",
                "def reload_conf_in_all_kitties() -> None:\n",
                "    import signal\n",
                "\n",
                "    from kitty.child import cmdline_of_process  # type: ignore\n",
                "    for pid in get_all_processes():\n",
                "        try:\n",
                "            cmd = cmdline_of_process(pid)\n",
                "        except Exception:\n",
                "            continue\n",
                "        if cmd and is_kitty_gui_cmdline(*cmd):\n",
                "            os.kill(pid, signal.SIGUSR1)\n",
                "\n",
                "\n",
                "@run_once\n",
                "def control_codes_pat() -> 'Pattern[str]':\n",
                "    return re.compile('[\\x00-\\x09\\x0b-\\x1f\\x7f\\x80-\\x9f]')\n",
                "\n",
                "\n",
                "def sanitize_control_codes(text: str, replace_with: str = '') -> str:\n",
                "    return control_codes_pat().sub(replace_with, text)"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                0,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                0,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and implement"
        },
        {
            "edit_hunk_pair": [
                1,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        }
    ]
}