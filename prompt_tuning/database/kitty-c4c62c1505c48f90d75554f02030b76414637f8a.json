{
    "language": "python",
    "commit_url": "https://github.com/kovidgoyal/kitty/commit/c4c62c1505c48f90d75554f02030b76414637f8a",
    "commit_message": "When using --keep-focus ensure active history list is not affected\n\nFixes #4987",
    "commit_snapshots": {
        "kitty/boss.py": [
            [
                "#!/usr/bin/env python3\n",
                "# License: GPL v3 Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n",
                "\n",
                "import atexit\n",
                "import json\n",
                "import os\n",
                "import re\n",
                "import sys\n",
                "from contextlib import suppress\n",
                "from functools import partial\n",
                "from gettext import gettext as _\n",
                "from time import monotonic\n",
                "from typing import (\n",
                "    Any, Callable, Container, Dict, Iterable, Iterator, List, Optional, Set,\n",
                "    Tuple, Union\n",
                ")\n",
                "from weakref import WeakValueDictionary\n",
                "\n",
                "from .child import cached_process_data, default_env, set_default_env\n",
                "from .cli import create_opts, parse_args\n",
                "from .cli_stub import CLIOptions\n",
                "from .conf.utils import BadLine, KeyAction, to_cmdline\n",
                "from .config import common_opts_as_dict, prepare_config_file_for_editing\n",
                "from .constants import (\n",
                "    appname, cache_dir, config_dir, is_macos, is_wayland, kitty_exe,\n",
                "    logo_png_file, supports_primary_selection, website_url\n",
                ")\n",
                "from .fast_data_types import (\n",
                "    CLOSE_BEING_CONFIRMED, GLFW_MOD_ALT, GLFW_MOD_CONTROL, GLFW_MOD_SHIFT,\n",
                "    GLFW_MOD_SUPER, GLFW_MOUSE_BUTTON_LEFT, GLFW_PRESS,\n",
                "    IMPERATIVE_CLOSE_REQUESTED, NO_CLOSE_REQUESTED, ChildMonitor, Color,\n",
                "    KeyEvent, add_timer, apply_options_update, background_opacity_of,\n",
                "    change_background_opacity, change_os_window_state, cocoa_set_menubar_title,\n",
                "    create_os_window, current_application_quit_request, current_os_window,\n",
                "    destroy_global_data, focus_os_window, get_boss, get_clipboard_string,\n",
                "    get_options, get_os_window_size, global_font_size,\n",
                "    mark_os_window_for_close, os_window_font_size, patch_global_colors,\n",
                "    redirect_mouse_handling, ring_bell, safe_pipe,\n",
                "    set_application_quit_request, set_background_image, set_boss,\n",
                "    set_clipboard_string, set_in_sequence_mode, set_options,\n",
                "    set_os_window_size, set_os_window_title, thread_write, toggle_fullscreen,\n",
                "    toggle_maximized, toggle_secure_input\n",
                ")\n",
                "from .key_encoding import get_name_to_functional_number_map\n",
                "from .keys import get_shortcut, shortcut_matches\n",
                "from .layout.base import set_layout_options\n",
                "from .notify import notification_activated\n",
                "from .options.types import Options\n",
                "from .options.utils import MINIMUM_FONT_SIZE, KeyMap, SubSequenceMap\n",
                "from .os_window_size import initial_window_size_func\n",
                "from .rgb import color_from_int\n",
                "from .session import Session, create_sessions, get_os_window_sizing_data\n",
                "from .tabs import (\n",
                "    SpecialWindow, SpecialWindowInstance, Tab, TabDict, TabManager\n",
                ")\n",
                "from .types import _T, AsyncResponse, SingleKey, WindowSystemMouseEvent, ac\n",
                "from .typing import PopenType, TypedDict\n",
                "from .utils import (\n",
                "    cleanup_ssh_control_masters, func_name, get_editor, get_new_os_window_size,\n",
                "    get_primary_selection, is_path_in_temp_dir, less_version, log_error,\n",
                "    macos_version, open_url, parse_address_spec, parse_uri_list,\n",
                "    platform_window_id, remove_socket_file, safe_print, set_primary_selection,\n",
                "    single_instance, startup_notification_handler, which\n",
                ")\n",
                "from .window import CommandOutput, CwdRequest, Window\n",
                "\n",
                "\n",
                "class OSWindowDict(TypedDict):\n",
                "    id: int\n",
                "    platform_window_id: Optional[int]\n",
                "    is_focused: bool\n",
                "    tabs: List[TabDict]\n",
                "    wm_class: str\n",
                "    wm_name: str\n",
                "\n",
                "\n",
                "def listen_on(spec: str) -> int:\n",
                "    import socket\n",
                "    family, address, socket_path = parse_address_spec(spec)\n",
                "    s = socket.socket(family)\n",
                "    atexit.register(remove_socket_file, s, socket_path)\n",
                "    s.bind(address)\n",
                "    s.listen()\n",
                "    return s.fileno()\n",
                "\n",
                "\n",
                "def data_for_at(w: Optional[Window], arg: str, add_wrap_markers: bool = False) -> Optional[str]:\n",
                "    if not w:\n",
                "        return None\n",
                "\n",
                "    def as_text(**kw: bool) -> str:\n",
                "        kw['add_wrap_markers'] = add_wrap_markers\n",
                "        return w.as_text(**kw) if w else ''\n",
                "\n",
                "    if arg == '@selection':\n",
                "        return w.text_for_selection()\n",
                "    if arg in ('@ansi', '@ansi_screen_scrollback'):\n",
                "        return as_text(as_ansi=True, add_history=True)\n",
                "    if arg in ('@text', '@screen_scrollback'):\n",
                "        return as_text(add_history=True)\n",
                "    if arg == '@screen':\n",
                "        return as_text()\n",
                "    if arg == '@ansi_screen':\n",
                "        return as_text(as_ansi=True)\n",
                "    if arg == '@alternate':\n",
                "        return as_text(alternate_screen=True)\n",
                "    if arg == '@alternate_scrollback':\n",
                "        return as_text(alternate_screen=True, add_history=True)\n",
                "    if arg == '@ansi_alternate':\n",
                "        return as_text(as_ansi=True, alternate_screen=True)\n",
                "    if arg == '@ansi_alternate_scrollback':\n",
                "        return as_text(as_ansi=True, alternate_screen=True, add_history=True)\n",
                "    if arg == '@first_cmd_output_on_screen':\n",
                "        return w.cmd_output(CommandOutput.first_on_screen, add_wrap_markers=add_wrap_markers)\n",
                "    if arg == '@ansi_first_cmd_output_on_screen':\n",
                "        return w.cmd_output(CommandOutput.first_on_screen, as_ansi=True, add_wrap_markers=add_wrap_markers)\n",
                "    if arg == '@last_cmd_output':\n",
                "        return w.cmd_output(CommandOutput.last_run, add_wrap_markers=add_wrap_markers)\n",
                "    if arg == '@ansi_last_cmd_output':\n",
                "        return w.cmd_output(CommandOutput.last_run, as_ansi=True, add_wrap_markers=add_wrap_markers)\n",
                "    if arg == '@last_visited_cmd_output':\n",
                "        return w.cmd_output(CommandOutput.last_visited, add_wrap_markers=add_wrap_markers)\n",
                "    if arg == '@ansi_last_visited_cmd_output':\n",
                "        return w.cmd_output(CommandOutput.last_visited, as_ansi=True, add_wrap_markers=add_wrap_markers)\n",
                "    return None\n",
                "\n",
                "\n",
                "class DumpCommands:  # {{{\n",
                "\n",
                "    def __init__(self, args: CLIOptions):\n",
                "        self.draw_dump_buf: List[str] = []\n",
                "        if args.dump_bytes:\n",
                "            self.dump_bytes_to = open(args.dump_bytes, 'wb')\n",
                "\n",
                "    def __call__(self, *a: Any) -> None:\n",
                "        if a:\n",
                "            if a[0] == 'draw':\n",
                "                if a[1] is None:\n",
                "                    if self.draw_dump_buf:\n",
                "                        safe_print('draw', ''.join(self.draw_dump_buf))\n",
                "                        self.draw_dump_buf = []\n",
                "                else:\n",
                "                    self.draw_dump_buf.append(a[1])\n",
                "            elif a[0] == 'bytes':\n",
                "                self.dump_bytes_to.write(a[1])\n",
                "                self.dump_bytes_to.flush()\n",
                "            else:\n",
                "                if self.draw_dump_buf:\n",
                "                    safe_print('draw', ''.join(self.draw_dump_buf))\n",
                "                    self.draw_dump_buf = []\n",
                "                safe_print(*a)\n",
                "# }}}\n",
                "\n",
                "\n",
                "class VisualSelect:\n",
                "\n",
                "    def __init__(\n",
                "        self,\n",
                "        tab_id: int,\n",
                "        os_window_id: int,\n",
                "        prev_tab_id: Optional[int],\n",
                "        prev_os_window_id: Optional[int],\n",
                "        title: str,\n",
                "        callback: Callable[[Optional[Tab], Optional[Window]], None],\n",
                "        reactivate_prev_tab: bool\n",
                "    ) -> None:\n",
                "        self.tab_id = tab_id\n",
                "        self.os_window_id = os_window_id\n",
                "        self.prev_tab_id = prev_tab_id\n",
                "        self.prev_os_window_id = prev_os_window_id\n",
                "        self.callback = callback\n",
                "        self.window_ids: List[int] = []\n",
                "        self.window_used_for_selection_id = 0\n",
                "        self.reactivate_prev_tab = reactivate_prev_tab\n",
                "        set_os_window_title(self.os_window_id, title)\n",
                "\n",
                "    def cancel(self) -> None:\n",
                "        self.clear_global_state()\n",
                "        self.activate_prev_tab()\n",
                "        self.callback(None, None)\n",
                "\n",
                "    def trigger(self, window_id: int) -> None:\n",
                "        boss = self.clear_global_state()\n",
                "        self.activate_prev_tab()\n",
                "        w = boss.window_id_map.get(window_id)\n",
                "        if w is None:\n",
                "            self.callback(None, None)\n",
                "        else:\n",
                "            tab = w.tabref()\n",
                "            if tab is None:\n",
                "                self.callback(None, None)\n",
                "            else:\n",
                "                self.callback(tab, w)\n",
                "\n",
                "    def clear_global_state(self) -> 'Boss':\n",
                "        set_os_window_title(self.os_window_id, '')\n",
                "        boss = get_boss()\n",
                "        redirect_mouse_handling(False)\n",
                "        boss.clear_pending_sequences()\n",
                "        for wid in self.window_ids:\n",
                "            w = boss.window_id_map.get(wid)\n",
                "            if w is not None:\n",
                "                w.screen.set_window_char()\n",
                "        if self.window_used_for_selection_id:\n",
                "            w = boss.window_id_map.get(self.window_used_for_selection_id)\n",
                "            if w is not None:\n",
                "                boss.mark_window_for_close(w)\n",
                "        return boss\n",
                "\n",
                "    def activate_prev_tab(self) -> None:\n",
                "        if not self.reactivate_prev_tab or self.prev_tab_id is None:\n",
                "            return None\n",
                "        boss = get_boss()\n",
                "        tm = boss.os_window_map.get(self.os_window_id)\n",
                "        if tm is not None:\n",
                "            t = tm.tab_for_id(self.prev_tab_id)\n",
                "            if t is not tm.active_tab and t is not None:\n",
                "                tm.set_active_tab(t)\n",
                "        if current_os_window() != self.prev_os_window_id and self.prev_os_window_id is not None:\n",
                "            focus_os_window(self.prev_os_window_id, True)\n",
                "\n",
                "\n",
                "class Boss:\n",
                "\n",
                "    def __init__(\n",
                "        self,\n",
                "        opts: Options,\n",
                "        args: CLIOptions,\n",
                "        cached_values: Dict[str, Any],\n",
                "        global_shortcuts: Dict[str, SingleKey]\n",
                "    ):\n",
                "        set_layout_options(opts)\n",
                "        self.update_check_started = False\n",
                "        self.clipboard_buffers: Dict[str, str] = {}\n",
                "        self.update_check_process: Optional['PopenType[bytes]'] = None\n",
                "        self.window_id_map: WeakValueDictionary[int, Window] = WeakValueDictionary()\n",
                "        self.startup_colors = {k: opts[k] for k in opts if isinstance(opts[k], Color)}\n",
                "        self.current_visual_select: Optional[VisualSelect] = None\n",
                "        self.startup_cursor_text_color = opts.cursor_text_color\n",
                "        self.pending_sequences: Optional[SubSequenceMap] = None\n",
                "        self.default_pending_action: str = ''\n",
                "        self.cached_values = cached_values\n",
                "        self.os_window_map: Dict[int, TabManager] = {}\n",
                "        self.os_window_death_actions: Dict[int, Callable[[], None]] = {}\n",
                "        self.cursor_blinking = True\n",
                "        self.shutting_down = False\n",
                "        talk_fd = getattr(single_instance, 'socket', None)\n",
                "        talk_fd = -1 if talk_fd is None else talk_fd.fileno()\n",
                "        listen_fd = -1\n",
                "        # we dont allow reloading the config file to change\n",
                "        # allow_remote_control\n",
                "        self.allow_remote_control = opts.allow_remote_control\n",
                "        if args.listen_on and (self.allow_remote_control in ('y', 'socket-only')):\n",
                "            listen_fd = listen_on(args.listen_on)\n",
                "        self.child_monitor = ChildMonitor(\n",
                "            self.on_child_death,\n",
                "            DumpCommands(args) if args.dump_commands or args.dump_bytes else None,\n",
                "            talk_fd, listen_fd\n",
                "        )\n",
                "        set_boss(self)\n",
                "        self.args = args\n",
                "        self.global_shortcuts_map: KeyMap = {v: k for k, v in global_shortcuts.items()}\n",
                "        self.global_shortcuts = global_shortcuts\n",
                "        self.mouse_handler: Optional[Callable[[WindowSystemMouseEvent], None]] = None\n",
                "        self.update_keymap()\n",
                "        if is_macos:\n",
                "            from .fast_data_types import (\n",
                "                cocoa_set_notification_activated_callback\n",
                "            )\n",
                "            cocoa_set_notification_activated_callback(notification_activated)\n",
                "\n",
                "    def update_keymap(self) -> None:\n",
                "        self.keymap = get_options().keymap.copy()\n",
                "        for sc in self.global_shortcuts.values():\n",
                "            self.keymap.pop(sc, None)\n",
                "\n",
                "    def startup_first_child(self, os_window_id: Optional[int], startup_sessions: Iterable[Session] = ()) -> None:\n",
                "        si = startup_sessions or create_sessions(get_options(), self.args, default_session=get_options().startup_session)\n",
                "        for startup_session in si:\n",
                "            self.add_os_window(startup_session, os_window_id=os_window_id)\n",
                "            os_window_id = None\n",
                "            if self.args.start_as != 'normal':\n",
                "                if self.args.start_as == 'fullscreen':\n",
                "                    self.toggle_fullscreen()\n",
                "                else:\n",
                "                    change_os_window_state(self.args.start_as)\n",
                "\n",
                "    def add_os_window(\n",
                "        self,\n",
                "        startup_session: Optional[Session] = None,\n",
                "        os_window_id: Optional[int] = None,\n",
                "        wclass: Optional[str] = None,\n",
                "        wname: Optional[str] = None,\n",
                "        opts_for_size: Optional[Options] = None,\n",
                "        startup_id: Optional[str] = None,\n",
                "        override_title: Optional[str] = None,\n",
                "    ) -> int:\n",
                "        if os_window_id is None:\n",
                "            size_data = get_os_window_sizing_data(opts_for_size or get_options(), startup_session)\n",
                "            wclass = wclass or getattr(startup_session, 'os_window_class', None) or self.args.cls or appname\n",
                "            wname = wname or self.args.name or wclass\n",
                "            wtitle = override_title or self.args.title\n",
                "            with startup_notification_handler(do_notify=startup_id is not None, startup_id=startup_id) as pre_show_callback:\n",
                "                os_window_id = create_os_window(\n",
                "                        initial_window_size_func(size_data, self.cached_values),\n",
                "                        pre_show_callback,\n",
                "                        wtitle or appname, wname, wclass, disallow_override_title=bool(wtitle))\n",
                "        else:\n",
                "            wname = self.args.name or self.args.cls or appname\n",
                "            wclass = self.args.cls or appname\n",
                "        tm = TabManager(os_window_id, self.args, wclass, wname, startup_session)\n",
                "        self.os_window_map[os_window_id] = tm\n",
                "        return os_window_id\n",
                "\n",
                "    def list_os_windows(self, self_window: Optional[Window] = None) -> Iterator[OSWindowDict]:\n",
                "        with cached_process_data():\n",
                "            active_tab, active_window = self.active_tab, self.active_window\n",
                "            active_tab_manager = self.active_tab_manager\n",
                "            for os_window_id, tm in self.os_window_map.items():\n",
                "                yield {\n",
                "                    'id': os_window_id,\n",
                "                    'platform_window_id': platform_window_id(os_window_id),\n",
                "                    'is_focused': tm is active_tab_manager,\n",
                "                    'tabs': list(tm.list_tabs(active_tab, active_window, self_window)),\n",
                "                    'wm_class': tm.wm_class,\n",
                "                    'wm_name': tm.wm_name\n",
                "                }\n",
                "\n",
                "    @property\n",
                "    def all_tab_managers(self) -> Iterator[TabManager]:\n",
                "        yield from self.os_window_map.values()\n",
                "\n",
                "    @property\n",
                "    def all_tabs(self) -> Iterator[Tab]:\n",
                "        for tm in self.all_tab_managers:\n",
                "            yield from tm\n",
                "\n",
                "    @property\n",
                "    def all_windows(self) -> Iterator[Window]:\n",
                "        for tab in self.all_tabs:\n",
                "            yield from tab\n",
                "\n",
                "    def match_windows(self, match: str) -> Iterator[Window]:\n",
                "        from .search_query_parser import search\n",
                "        tab = self.active_tab\n",
                "\n",
                "        def get_matches(location: str, query: str, candidates: Set[int]) -> Set[int]:\n",
                "            return {wid for wid in candidates if self.window_id_map[wid].matches_query(location, query, tab)}\n",
                "\n",
                "        for wid in search(match, (\n",
                "                'id', 'title', 'pid', 'cwd', 'cmdline', 'num', 'env', 'recent', 'state'\n",
                "        ), set(self.window_id_map), get_matches):\n",
                "            yield self.window_id_map[wid]\n",
                "\n",
                "    def tab_for_window(self, window: Window) -> Optional[Tab]:\n",
                "        for tab in self.all_tabs:\n",
                "            for w in tab:\n",
                "                if w.id == window.id:\n",
                "                    return tab\n",
                "        return None\n",
                "\n",
                "    def match_tabs(self, match: str) -> Iterator[Tab]:\n",
                "        from .search_query_parser import search\n",
                "        tm = self.active_tab_manager\n",
                "        tim = {t.id: t for t in self.all_tabs}\n",
                "\n",
                "        def get_matches(location: str, query: str, candidates: Set[int]) -> Set[int]:\n",
                "            return {wid for wid in candidates if tim[wid].matches_query(location, query, tm)}\n",
                "\n",
                "        found = False\n",
                "        for tid in search(match, (\n",
                "                'id', 'index', 'title', 'window_id', 'window_title', 'pid', 'cwd', 'env', 'cmdline', 'recent', 'state'\n",
                "        ), set(tim), get_matches):\n",
                "            found = True\n",
                "            yield tim[tid]\n",
                "\n",
                "        if not found:\n",
                "            tabs = {self.tab_for_window(w) for w in self.match_windows(match)}\n",
                "            for q in tabs:\n",
                "                if q:\n",
                "                    yield q\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    def set_active_window(self, window: Window, switch_os_window_if_needed: bool = False) -> Optional[int]:\n"
                ],
                "after": [
                    "    def set_active_window(self, window: Window, switch_os_window_if_needed: bool = False, for_keep_focus: bool = False) -> Optional[int]:\n"
                ],
                "parent_version_range": {
                    "start": 382,
                    "end": 383
                },
                "child_version_range": {
                    "start": 382,
                    "end": 383
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Boss",
                        "signature": "class Boss:",
                        "at_line": 222
                    },
                    {
                        "type": "function",
                        "name": "set_active_window",
                        "signature": "def set_active_window(self, window: Window, switch_os_window_if_needed: bool = False)->Optional[int]:",
                        "at_line": 382
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: kitty/boss.py\nCode:\n           class Boss:\n               ...\n379 379                    if q:\n380 380                        yield q\n381 381    \n382      -     def set_active_window(self, window: Window, switch_os_window_if_needed: bool = False) -> Optional[int]:\n    382  +     def set_active_window(self, window: Window, switch_os_window_if_needed: bool = False, for_keep_focus: bool = False) -> Optional[int]:\n383 383            for os_window_id, tm in self.os_window_map.items():\n384 384                for tab in tm:\n385 385                    for w in tab:\n         ...\n",
                "file_path": "kitty/boss.py",
                "identifiers_before": [
                    "Optional",
                    "Window",
                    "bool",
                    "int",
                    "self",
                    "set_active_window",
                    "switch_os_window_if_needed",
                    "window"
                ],
                "identifiers_after": [
                    "Optional",
                    "Window",
                    "bool",
                    "for_keep_focus",
                    "int",
                    "self",
                    "set_active_window",
                    "switch_os_window_if_needed",
                    "window"
                ],
                "prefix": [
                    "                if q:\n",
                    "                    yield q\n",
                    "\n"
                ],
                "suffix": [
                    "        for os_window_id, tm in self.os_window_map.items():\n",
                    "            for tab in tm:\n",
                    "                for w in tab:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "set_active_window",
                            "position": {
                                "start": {
                                    "line": 382,
                                    "column": 8
                                },
                                "end": {
                                    "line": 382,
                                    "column": 25
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "switch_os_window_if_needed",
                            "position": {
                                "start": {
                                    "line": 382,
                                    "column": 48
                                },
                                "end": {
                                    "line": 382,
                                    "column": 74
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "set_active_window",
                            "position": {
                                "start": {
                                    "line": 382,
                                    "column": 8
                                },
                                "end": {
                                    "line": 382,
                                    "column": 25
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "window",
                            "position": {
                                "start": {
                                    "line": 382,
                                    "column": 32
                                },
                                "end": {
                                    "line": 382,
                                    "column": 38
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "window",
                            "position": {
                                "start": {
                                    "line": 382,
                                    "column": 32
                                },
                                "end": {
                                    "line": 382,
                                    "column": 38
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "switch_os_window_if_needed",
                            "position": {
                                "start": {
                                    "line": 382,
                                    "column": 48
                                },
                                "end": {
                                    "line": 382,
                                    "column": 74
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 382,
                                    "column": 90
                                },
                                "end": {
                                    "line": 382,
                                    "column": 104
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 382,
                                    "column": 90
                                },
                                "end": {
                                    "line": 382,
                                    "column": 104
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 382,
                                    "column": 90
                                },
                                "end": {
                                    "line": 382,
                                    "column": 104
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "        for os_window_id, tm in self.os_window_map.items():\n",
                "            for tab in tm:\n",
                "                for w in tab:\n",
                "                    if w.id == window.id:\n",
                "                        if tab is not self.active_tab:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                            tm.set_active_tab(tab)\n",
                    "                        tab.set_active_window(w)\n"
                ],
                "after": [
                    "                            tm.set_active_tab(tab, for_keep_focus=window.tabref() if for_keep_focus else None)\n",
                    "                        tab.set_active_window(w, for_keep_focus=window if for_keep_focus else None)\n"
                ],
                "parent_version_range": {
                    "start": 388,
                    "end": 390
                },
                "child_version_range": {
                    "start": 388,
                    "end": 390
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for os_window_id, tm in self.os_window_map.items():",
                        "start_line": 383,
                        "end_line": 392
                    },
                    {
                        "type": "for_statement",
                        "statement": "for tab in tm:",
                        "start_line": 384,
                        "end_line": 392
                    },
                    {
                        "type": "for_statement",
                        "statement": "for w in tab:",
                        "start_line": 385,
                        "end_line": 392
                    },
                    {
                        "type": "if_statement",
                        "statement": "if w.id == window.id:",
                        "start_line": 386,
                        "end_line": 392
                    },
                    {
                        "type": "if_statement",
                        "statement": "if tab is not self.active_tab:",
                        "start_line": 387,
                        "end_line": 388
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Boss",
                        "signature": "class Boss:",
                        "at_line": 222
                    },
                    {
                        "type": "function",
                        "name": "set_active_window",
                        "signature": "def set_active_window(self, window: Window, switch_os_window_if_needed: bool = False)->Optional[int]:",
                        "at_line": 382
                    },
                    {
                        "type": "call",
                        "name": "tm.set_active_tab",
                        "signature": "tm.set_active_tab(tab)",
                        "at_line": 388,
                        "argument": "tab"
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: kitty/boss.py\nCode:\n           class Boss:\n               ...\n               def set_active_window(self, window: Window, switch_os_window_if_needed: bool = False)->Optional[int]:\n                   ...\n385 385                    for w in tab:\n386 386                        if w.id == window.id:\n387 387                            if tab is not self.active_tab:\n388      -                             tm.set_active_tab(tab)\n389      -                         tab.set_active_window(w)\n    388  +                             tm.set_active_tab(tab, for_keep_focus=window.tabref() if for_keep_focus else None)\n    389  +                         tab.set_active_window(w, for_keep_focus=window if for_keep_focus else None)\n390 390                            if switch_os_window_if_needed and current_os_window() != os_window_id:\n391 391                                focus_os_window(os_window_id, True)\n392 392                            return os_window_id\n         ...\n",
                "file_path": "kitty/boss.py",
                "identifiers_before": [
                    "set_active_tab",
                    "set_active_window",
                    "tab",
                    "tm",
                    "w"
                ],
                "identifiers_after": [
                    "for_keep_focus",
                    "set_active_tab",
                    "set_active_window",
                    "tab",
                    "tabref",
                    "tm",
                    "w",
                    "window"
                ],
                "prefix": [
                    "                for w in tab:\n",
                    "                    if w.id == window.id:\n",
                    "                        if tab is not self.active_tab:\n"
                ],
                "suffix": [
                    "                        if switch_os_window_if_needed and current_os_window() != os_window_id:\n",
                    "                            focus_os_window(os_window_id, True)\n",
                    "                        return os_window_id\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "set_active_tab",
                            "position": {
                                "start": {
                                    "line": 388,
                                    "column": 31
                                },
                                "end": {
                                    "line": 388,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "set_active_window",
                            "position": {
                                "start": {
                                    "line": 389,
                                    "column": 28
                                },
                                "end": {
                                    "line": 389,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "window",
                            "position": {
                                "start": {
                                    "line": 388,
                                    "column": 66
                                },
                                "end": {
                                    "line": 388,
                                    "column": 72
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "window",
                            "position": {
                                "start": {
                                    "line": 389,
                                    "column": 64
                                },
                                "end": {
                                    "line": 389,
                                    "column": 70
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 388,
                                    "column": 85
                                },
                                "end": {
                                    "line": 388,
                                    "column": 99
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 389,
                                    "column": 74
                                },
                                "end": {
                                    "line": 389,
                                    "column": 88
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "set_active_tab",
                            "position": {
                                "start": {
                                    "line": 388,
                                    "column": 31
                                },
                                "end": {
                                    "line": 388,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 388,
                                    "column": 51
                                },
                                "end": {
                                    "line": 388,
                                    "column": 65
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "set_active_window",
                            "position": {
                                "start": {
                                    "line": 389,
                                    "column": 28
                                },
                                "end": {
                                    "line": 389,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 389,
                                    "column": 49
                                },
                                "end": {
                                    "line": 389,
                                    "column": 63
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                        if switch_os_window_if_needed and current_os_window() != os_window_id:\n",
                "                            focus_os_window(os_window_id, True)\n",
                "                        return os_window_id\n",
                "        return None\n",
                "\n",
                "    def _new_os_window(self, args: Union[SpecialWindowInstance, Iterable[str]], cwd_from: Optional[CwdRequest] = None) -> int:\n",
                "        if isinstance(args, SpecialWindowInstance):\n",
                "            sw: Optional[SpecialWindowInstance] = args\n",
                "        else:\n",
                "            sw = self.args_to_special_window(args, cwd_from) if args else None\n",
                "        startup_session = next(create_sessions(get_options(), special_window=sw, cwd_from=cwd_from))\n",
                "        return self.add_os_window(startup_session)\n",
                "\n",
                "    @ac('win', 'New OS Window')\n",
                "    def new_os_window(self, *args: str) -> None:\n",
                "        self._new_os_window(args)\n",
                "\n",
                "    @property\n",
                "    def active_window_for_cwd(self) -> Optional[Window]:\n",
                "        t = self.active_tab\n",
                "        if t is not None:\n",
                "            return t.active_window_for_cwd\n",
                "        return None\n",
                "\n",
                "    @ac('win', 'New OS Window with the same working directory as the currently active window')\n",
                "    def new_os_window_with_cwd(self, *args: str) -> None:\n",
                "        w = self.active_window_for_cwd\n",
                "        self._new_os_window(args, CwdRequest(w))\n",
                "\n",
                "    def new_os_window_with_wd(self, wd: Union[str, List[str]], str_is_multiple_paths: bool = False) -> None:\n",
                "        if isinstance(wd, str):\n",
                "            wd = wd.split(os.pathsep) if str_is_multiple_paths else [wd]\n",
                "        for path in wd:\n",
                "            special_window = SpecialWindow(None, cwd=path)\n",
                "            self._new_os_window(special_window)\n",
                "\n",
                "    def add_child(self, window: Window) -> None:\n",
                "        assert window.child.pid is not None and window.child.child_fd is not None\n",
                "        self.child_monitor.add_child(window.id, window.child.pid, window.child.child_fd, window.screen)\n",
                "        self.window_id_map[window.id] = window\n",
                "\n",
                "    def _handle_remote_command(self, cmd: str, window: Optional[Window] = None, peer_id: int = 0) -> Union[Dict[str, Any], None, AsyncResponse]:\n",
                "        from .remote_control import handle_cmd\n",
                "        response = None\n",
                "        window = window or None\n",
                "        if self.allow_remote_control == 'y' or peer_id > 0 or getattr(window, 'allow_remote_control', False):\n",
                "            try:\n",
                "                response = handle_cmd(self, window, cmd, peer_id)\n",
                "            except Exception as err:\n",
                "                import traceback\n",
                "                response = {'ok': False, 'error': str(err)}\n",
                "                if not getattr(err, 'hide_traceback', False):\n",
                "                    response['tb'] = traceback.format_exc()\n",
                "        else:\n",
                "            no_response = False\n",
                "            try:\n",
                "                no_response = json.loads(cmd).get('no_response')\n",
                "            except Exception:\n",
                "                pass\n",
                "            if not no_response:\n",
                "                response = {'ok': False, 'error': 'Remote control is disabled. Add allow_remote_control to your kitty.conf'}\n",
                "        return response\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Run a remote control command\n",
                "\n",
                "        For example::\n",
                "\n",
                "            map F1 remote_control set-spacing margin=30\n",
                "\n",
                "        See :ref:`rc_mapping` for details.\n",
                "        ''')\n",
                "    def remote_control(self, *args: str) -> None:\n",
                "        from .rc.base import (\n",
                "            PayloadGetter, command_for_name, parse_subcommand_cli\n",
                "        )\n",
                "        from .remote_control import parse_rc_args\n",
                "        try:\n",
                "            global_opts, items = parse_rc_args(['@'] + list(args))\n",
                "            if not items:\n",
                "                return\n",
                "            cmd = items[0]\n",
                "            c = command_for_name(cmd)\n",
                "            opts, items = parse_subcommand_cli(c, items)\n",
                "            payload = c.message_to_kitty(global_opts, opts, items)\n",
                "            import types\n",
                "            if isinstance(payload, types.GeneratorType):\n",
                "                for x in payload:\n",
                "                    c.response_from_kitty(self, self.active_window, PayloadGetter(c, x if isinstance(x, dict) else {}))\n",
                "            else:\n",
                "                c.response_from_kitty(self, self.active_window, PayloadGetter(c, payload if isinstance(payload, dict) else {}))\n",
                "        except (Exception, SystemExit):\n",
                "            import traceback\n",
                "            tb = traceback.format_exc()\n",
                "            self.show_error(_('remote_control mapping failed'), tb)\n",
                "\n",
                "    def peer_message_received(self, msg_bytes: bytes, peer_id: int) -> Union[bytes, bool, None]:\n",
                "        cmd_prefix = b'\\x1bP@kitty-cmd'\n",
                "        terminator = b'\\x1b\\\\'\n",
                "        if msg_bytes.startswith(cmd_prefix) and msg_bytes.endswith(terminator):\n",
                "            cmd = msg_bytes[len(cmd_prefix):-len(terminator)].decode('utf-8')\n",
                "            response = self._handle_remote_command(cmd, peer_id=peer_id)\n",
                "            if response is None:\n",
                "                return None\n",
                "            if isinstance(response, AsyncResponse):\n",
                "                return True\n",
                "            from kitty.remote_control import encode_response_for_peer\n",
                "            return encode_response_for_peer(response)\n",
                "\n",
                "        data = json.loads(msg_bytes.decode('utf-8'))\n",
                "        if isinstance(data, dict) and data.get('cmd') == 'new_instance':\n",
                "            from .cli_stub import CLIOptions\n",
                "            startup_id = data.get('startup_id')\n",
                "            args, rest = parse_args(data['args'][1:], result_class=CLIOptions)\n",
                "            cmdline_args_for_open = data.get('cmdline_args_for_open')\n",
                "            if cmdline_args_for_open:\n",
                "                self.launch_urls(*cmdline_args_for_open, no_replace_window=True)\n",
                "                return None\n",
                "            args.args = rest\n",
                "            opts = create_opts(args)\n",
                "            if args.session == '-':\n",
                "                from .session import PreReadSession\n",
                "                args.session = PreReadSession(data['stdin'])\n",
                "            if not os.path.isabs(args.directory):\n",
                "                args.directory = os.path.join(data['cwd'], args.directory)\n",
                "            for session in create_sessions(opts, args, respect_cwd=True):\n",
                "                os_window_id = self.add_os_window(\n",
                "                    session, wclass=args.cls, wname=args.name, opts_for_size=opts, startup_id=startup_id,\n",
                "                    override_title=args.title or None)\n",
                "                if opts.background_opacity != get_options().background_opacity:\n",
                "                    self._set_os_window_background_opacity(os_window_id, opts.background_opacity)\n",
                "                if data.get('notify_on_os_window_death'):\n",
                "                    self.os_window_death_actions[os_window_id] = partial(self.notify_on_os_window_death, data['notify_on_os_window_death'])\n",
                "        else:\n",
                "            log_error('Unknown message received from peer, ignoring')\n",
                "        return None\n",
                "\n",
                "    def handle_remote_cmd(self, cmd: str, window: Optional[Window] = None) -> None:\n",
                "        response = self._handle_remote_command(cmd, window)\n",
                "        if response is not None and not isinstance(response, AsyncResponse) and window is not None:\n",
                "            window.send_cmd_response(response)\n",
                "\n",
                "    def mark_os_window_for_close(self, os_window_id: int, request_type: int = IMPERATIVE_CLOSE_REQUESTED) -> None:\n",
                "        if self.current_visual_select is not None and self.current_visual_select.os_window_id == os_window_id and request_type == IMPERATIVE_CLOSE_REQUESTED:\n",
                "            self.cancel_current_visual_select()\n",
                "        mark_os_window_for_close(os_window_id, request_type)\n",
                "\n",
                "    def _cleanup_tab_after_window_removal(self, src_tab: Tab) -> None:\n",
                "        if len(src_tab) < 1:\n",
                "            tm = src_tab.tab_manager_ref()\n",
                "            if tm is not None:\n",
                "                tm.remove(src_tab)\n",
                "                src_tab.destroy()\n",
                "                if len(tm) == 0:\n",
                "                    if not self.shutting_down:\n",
                "                        self.mark_os_window_for_close(src_tab.os_window_id)\n",
                "\n",
                "    def on_child_death(self, window_id: int) -> None:\n",
                "        prev_active_window = self.active_window\n",
                "        window = self.window_id_map.pop(window_id, None)\n",
                "        if window is None:\n",
                "            return\n",
                "        for close_action in window.actions_on_close:\n",
                "            try:\n",
                "                close_action(window)\n",
                "            except Exception:\n",
                "                import traceback\n",
                "                traceback.print_exc()\n",
                "        os_window_id = window.os_window_id\n",
                "        window.destroy()\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        tab = None\n",
                "        if tm is not None:\n",
                "            for q in tm:\n",
                "                if window in q:\n",
                "                    tab = q\n",
                "                    break\n",
                "        if tab is not None:\n",
                "            tab.remove_window(window)\n",
                "            self._cleanup_tab_after_window_removal(tab)\n",
                "        for removal_action in window.actions_on_removal:\n",
                "            try:\n",
                "                removal_action(window)\n",
                "            except Exception:\n",
                "                import traceback\n",
                "                traceback.print_exc()\n",
                "        del window.actions_on_close[:], window.actions_on_removal[:]\n",
                "        window = self.active_window\n",
                "        if window is not prev_active_window:\n",
                "            if prev_active_window is not None:\n",
                "                prev_active_window.focus_changed(False)\n",
                "            if window is not None:\n",
                "                window.focus_changed(True)\n",
                "\n",
                "    def mark_window_for_close(self, q: Union[Window, None, int] = None) -> None:\n",
                "        if isinstance(q, int):\n",
                "            window = self.window_id_map.get(q)\n",
                "            if window is None:\n",
                "                return\n",
                "        else:\n",
                "            window = q or self.active_window\n",
                "        if window:\n",
                "            self.child_monitor.mark_for_close(window.id)\n",
                "\n",
                "    @ac('win', 'Close the currently active window')\n",
                "    def close_window(self) -> None:\n",
                "        self.mark_window_for_close()\n",
                "\n",
                "    @ac('win', '''\n",
                "    Close window with confirmation\n",
                "\n",
                "    Asks for confirmation before closing the window. If you don't want the\n",
                "    confirmation when the window is sitting at a shell prompt\n",
                "    (requires :ref:`shell_integration`), use::\n",
                "\n",
                "        map f1 close_window_with_confirmation ignore-shell\n",
                "    ''')\n",
                "    def close_window_with_confirmation(self, ignore_shell: bool = False) -> None:\n",
                "        window = self.active_window\n",
                "        if window is None:\n",
                "            return\n",
                "        if not ignore_shell or window.has_running_program:\n",
                "            msg = _('Are you sure you want to close this window?')\n",
                "            if window.has_running_program:\n",
                "                msg += ' ' + _('It is running a program.')\n",
                "            self.confirm(msg, self.handle_close_window_confirmation, window.id, window=window)\n",
                "        else:\n",
                "            self.mark_window_for_close(window)\n",
                "\n",
                "    def handle_close_window_confirmation(self, allowed: bool, window_id: int) -> None:\n",
                "        if allowed:\n",
                "            self.mark_window_for_close(window_id)\n",
                "\n",
                "    @ac('tab', 'Close the current tab')\n",
                "    def close_tab(self, tab: Optional[Tab] = None) -> None:\n",
                "        tab = tab or self.active_tab\n",
                "        if tab:\n",
                "            self.confirm_tab_close(tab)\n",
                "\n",
                "    @ac('tab', 'Close all the tabs in the current OS window other than the currently active tab')\n",
                "    def close_other_tabs_in_os_window(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None and len(tm.tabs) > 1:\n",
                "            active_tab = self.active_tab\n",
                "            for tab in tm:\n",
                "                if tab is not active_tab:\n",
                "                    self.close_tab(tab)\n",
                "\n",
                "    def confirm(\n",
                "        self, msg: str,  # can contain newlines and ANSI formatting\n",
                "        callback: Callable[..., None],  # called with True or False and *args\n",
                "        *args: Any,  # passed to the callback function\n",
                "        window: Optional[Window] = None,  # the window associated with the confirmation\n",
                "        confirm_on_cancel: bool = False,  # on closing window\n",
                "        confirm_on_accept: bool = True,  # on pressing enter\n",
                "    ) -> None:\n",
                "        def callback_(res: Dict[str, Any], x: int, boss: Boss) -> None:\n",
                "            callback(res.get('response') == 'y', *args)\n",
                "        self._run_kitten('ask', ['--type=yesno', '--message', msg, '--default', 'y' if confirm_on_accept else 'n'],\n",
                "                         window=window, custom_callback=callback_, default_data={'response': 'y' if confirm_on_cancel else 'n'})\n",
                "\n",
                "    def choose(\n",
                "        self, msg: str,  # can contain newlines and ANSI formatting\n",
                "        callback: Callable[..., None],  # called with the choice or empty string when aborted\n",
                "        *choices: str,   # The choices, see the help for the ask kitten for format of a choice\n",
                "        window: Optional[Window] = None,  # the window associated with the confirmation\n",
                "        default: str = '',  # the default choice when the user presses Enter\n",
                "    ) -> None:\n",
                "        def callback_(res: Dict[str, Any], x: int, boss: Boss) -> None:\n",
                "            callback(res.get('response') or '')\n",
                "        cmd = ['--type=choices', '--message', msg]\n",
                "        if default:\n",
                "            cmd += ['-d', default]\n",
                "        for c in choices:\n",
                "            cmd += ['-c', c]\n",
                "        self._run_kitten('ask', cmd, window=window, custom_callback=callback_, default_data={'response': ''})\n",
                "\n",
                "    def get_line(\n",
                "        self, msg: str,  # can contain newlines and ANSI formatting\n",
                "        callback: Callable[..., None],  # called with the answer or empty string when aborted\n",
                "        window: Optional[Window] = None,  # the window associated with the confirmation\n",
                "        prompt: str = '> ',\n",
                "        is_password: bool = False\n",
                "    ) -> None:\n",
                "        def callback_(res: Dict[str, Any], x: int, boss: Boss) -> None:\n",
                "            callback(res.get('response') or '')\n",
                "        cmd = ['--type', 'password' if is_password else 'line', '--message', msg, '--prompt', prompt]\n",
                "        self._run_kitten('ask', cmd, window=window, custom_callback=callback_, default_data={'response': ''})\n",
                "\n",
                "    def confirm_tab_close(self, tab: Tab) -> None:\n",
                "        x = get_options().confirm_os_window_close\n",
                "        num = tab.number_of_windows_with_running_programs if x < 0 else len(tab)\n",
                "        needs_confirmation = x != 0 and num >= abs(x)\n",
                "        if not needs_confirmation:\n",
                "            self.close_tab_no_confirm(tab)\n",
                "            return\n",
                "        if tab is not self.active_tab:\n",
                "            tm = tab.tab_manager_ref()\n",
                "            if tm is not None:\n",
                "                tm.set_active_tab(tab)\n",
                "        self.confirm(_(\n",
                "            'Are you sure you want to close this tab, it has {}'\n",
                "            ' windows running?').format(num),\n",
                "            self.handle_close_tab_confirmation, tab.id,\n",
                "            window=tab.active_window,\n",
                "        )\n",
                "\n",
                "    def handle_close_tab_confirmation(self, confirmed: bool, tab_id: int) -> None:\n",
                "        if not confirmed:\n",
                "            return\n",
                "        for tab in self.all_tabs:\n",
                "            if tab.id == tab_id:\n",
                "                break\n",
                "        else:\n",
                "            return\n",
                "        self.close_tab_no_confirm(tab)\n",
                "\n",
                "    def close_tab_no_confirm(self, tab: Tab) -> None:\n",
                "        if self.current_visual_select is not None and self.current_visual_select.tab_id == tab.id:\n",
                "            self.cancel_current_visual_select()\n",
                "        for window in tab:\n",
                "            self.mark_window_for_close(window)\n",
                "\n",
                "    @ac('win', 'Toggle the fullscreen status of the active OS Window')\n",
                "    def toggle_fullscreen(self, os_window_id: int = 0) -> None:\n",
                "        toggle_fullscreen(os_window_id)\n",
                "\n",
                "    @ac('win', 'Toggle the maximized status of the active OS Window')\n",
                "    def toggle_maximized(self, os_window_id: int = 0) -> None:\n",
                "        toggle_maximized(os_window_id)\n",
                "\n",
                "    @ac('misc', 'Toggle macOS secure keyboard entry')\n",
                "    def toggle_macos_secure_keyboard_entry(self) -> None:\n",
                "        toggle_secure_input()\n",
                "\n",
                "    def start(self, first_os_window_id: int, startup_sessions: Iterable[Session]) -> None:\n",
                "        if not getattr(self, 'io_thread_started', False):\n",
                "            self.child_monitor.start()\n",
                "            self.io_thread_started = True\n",
                "            urls: List[str] = getattr(sys, 'cmdline_args_for_open', [])\n",
                "            if urls:\n",
                "                delattr(sys, 'cmdline_args_for_open')\n",
                "                sess = create_sessions(get_options(), self.args, special_window=SpecialWindow([kitty_exe(), '+runpy', 'input()']))\n",
                "                self.startup_first_child(first_os_window_id, startup_sessions=tuple(sess))\n",
                "                self.launch_urls(*urls)\n",
                "            else:\n",
                "                self.startup_first_child(first_os_window_id, startup_sessions=startup_sessions)\n",
                "\n",
                "        if get_options().update_check_interval > 0 and not self.update_check_started and getattr(sys, 'frozen', False):\n",
                "            from .update_check import run_update_check\n",
                "            run_update_check(get_options().update_check_interval * 60 * 60)\n",
                "            self.update_check_started = True\n",
                "\n",
                "    def handle_click_on_tab(self, os_window_id: int, x: int, button: int, modifiers: int, action: int) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            tm.handle_click_on_tab(x, button, modifiers, action)\n",
                "\n",
                "    def on_window_resize(self, os_window_id: int, w: int, h: int, dpi_changed: bool) -> None:\n",
                "        if dpi_changed:\n",
                "            self.on_dpi_change(os_window_id)\n",
                "        else:\n",
                "            tm = self.os_window_map.get(os_window_id)\n",
                "            if tm is not None:\n",
                "                tm.resize()\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Clear the terminal\n",
                "\n",
                "        See :sc:`reset_terminal <reset_terminal>` for details. For example::\n",
                "\n",
                "            # Reset the terminal\n",
                "            map f1 clear_terminal reset active\n",
                "            # Clear the terminal screen by erasing all contents\n",
                "            map f1 clear_terminal clear active\n",
                "            # Clear the terminal scrollback by erasing it\n",
                "            map f1 clear_terminal scrollback active\n",
                "            # Scroll the contents of the screen into the scrollback\n",
                "            map f1 clear_terminal scroll active\n",
                "            # Clear everything up to the line with the cursor\n",
                "            map f1 clear_terminal to_cursor active\n",
                "        ''')\n",
                "    def clear_terminal(self, action: str, only_active: bool) -> None:\n",
                "        if only_active:\n",
                "            windows = []\n",
                "            w = self.active_window\n",
                "            if w is not None:\n",
                "                windows.append(w)\n",
                "        else:\n",
                "            windows = list(self.all_windows)\n",
                "        if action == 'reset':\n",
                "            for w in windows:\n",
                "                w.clear_screen(reset=True, scrollback=True)\n",
                "        elif action == 'scrollback':\n",
                "            for w in windows:\n",
                "                w.clear_screen(scrollback=True)\n",
                "        elif action == 'clear':\n",
                "            for w in windows:\n",
                "                w.clear_screen()\n",
                "        elif action == 'scroll':\n",
                "            for w in windows:\n",
                "                w.scroll_prompt_to_top()\n",
                "        elif action == 'to_cursor':\n",
                "            for w in windows:\n",
                "                w.scroll_prompt_to_top(clear_scrollback=True)\n",
                "\n",
                "    def increase_font_size(self) -> None:  # legacy\n",
                "        cfs = global_font_size()\n",
                "        self.set_font_size(min(get_options().font_size * 5, cfs + 2.0))\n",
                "\n",
                "    def decrease_font_size(self) -> None:  # legacy\n",
                "        cfs = global_font_size()\n",
                "        self.set_font_size(max(MINIMUM_FONT_SIZE, cfs - 2.0))\n",
                "\n",
                "    def restore_font_size(self) -> None:  # legacy\n",
                "        self.set_font_size(get_options().font_size)\n",
                "\n",
                "    def set_font_size(self, new_size: float) -> None:  # legacy\n",
                "        self.change_font_size(True, None, new_size)\n",
                "\n",
                "    @ac('win', '''\n",
                "        Change the font size for the current or all OS Windows\n",
                "\n",
                "        See :ref:`conf-kitty-shortcuts.fonts` for details.\n",
                "        ''')\n",
                "    def change_font_size(self, all_windows: bool, increment_operation: Optional[str], amt: float) -> None:\n",
                "        def calc_new_size(old_size: float) -> float:\n",
                "            new_size = old_size\n",
                "            if amt == 0:\n",
                "                new_size = get_options().font_size\n",
                "            else:\n",
                "                if increment_operation:\n",
                "                    new_size += (1 if increment_operation == '+' else -1) * amt\n",
                "                else:\n",
                "                    new_size = amt\n",
                "                new_size = max(MINIMUM_FONT_SIZE, min(new_size, get_options().font_size * 5))\n",
                "            return new_size\n",
                "\n",
                "        if all_windows:\n",
                "            current_global_size = global_font_size()\n",
                "            new_size = calc_new_size(current_global_size)\n",
                "            if new_size != current_global_size:\n",
                "                global_font_size(new_size)\n",
                "            os_windows = list(self.os_window_map.keys())\n",
                "        else:\n",
                "            os_windows = []\n",
                "            w = self.active_window\n",
                "            if w is not None:\n",
                "                os_windows.append(w.os_window_id)\n",
                "        if os_windows:\n",
                "            final_windows = {}\n",
                "            for wid in os_windows:\n",
                "                current_size = os_window_font_size(wid)\n",
                "                if current_size:\n",
                "                    new_size = calc_new_size(current_size)\n",
                "                    if new_size != current_size:\n",
                "                        final_windows[wid] = new_size\n",
                "            if final_windows:\n",
                "                self._change_font_size(final_windows)\n",
                "\n",
                "    def _change_font_size(self, sz_map: Dict[int, float]) -> None:\n",
                "        for os_window_id, sz in sz_map.items():\n",
                "            tm = self.os_window_map.get(os_window_id)\n",
                "            if tm is not None:\n",
                "                os_window_font_size(os_window_id, sz)\n",
                "                tm.resize()\n",
                "\n",
                "    def on_dpi_change(self, os_window_id: int) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            sz = os_window_font_size(os_window_id)\n",
                "            if sz:\n",
                "                os_window_font_size(os_window_id, sz, True)\n",
                "                for tab in tm:\n",
                "                    for window in tab:\n",
                "                        window.on_dpi_change(sz)\n",
                "                tm.resize()\n",
                "\n",
                "    def _set_os_window_background_opacity(self, os_window_id: int, opacity: float) -> None:\n",
                "        change_background_opacity(os_window_id, max(0.1, min(opacity, 1.0)))\n",
                "\n",
                "    @ac('win', '''\n",
                "        Set the background opacity for the active OS Window\n",
                "\n",
                "        For example::\n",
                "\n",
                "            map f1 set_background_opacity +0.1\n",
                "            map f2 set_background_opacity -0.1\n",
                "            map f3 set_background_opacity 0.5\n",
                "        ''')\n",
                "    def set_background_opacity(self, opacity: str) -> None:\n",
                "        window = self.active_window\n",
                "        if window is None or not opacity:\n",
                "            return\n",
                "        if not get_options().dynamic_background_opacity:\n",
                "            self.show_error(\n",
                "                    _('Cannot change background opacity'),\n",
                "                    _('You must set the dynamic_background_opacity option in kitty.conf to be able to change background opacity'))\n",
                "            return\n",
                "        os_window_id = window.os_window_id\n",
                "        if opacity[0] in '+-':\n",
                "            old_opacity = background_opacity_of(os_window_id)\n",
                "            if old_opacity is None:\n",
                "                return\n",
                "            fin_opacity = old_opacity + float(opacity)\n",
                "        elif opacity == 'default':\n",
                "            fin_opacity = get_options().background_opacity\n",
                "        else:\n",
                "            fin_opacity = float(opacity)\n",
                "        self._set_os_window_background_opacity(os_window_id, fin_opacity)\n",
                "\n",
                "    @property\n",
                "    def active_tab_manager(self) -> Optional[TabManager]:\n",
                "        os_window_id = current_os_window()\n",
                "        return None if os_window_id is None else self.os_window_map.get(os_window_id)\n",
                "\n",
                "    @property\n",
                "    def active_tab(self) -> Optional[Tab]:\n",
                "        tm = self.active_tab_manager\n",
                "        return None if tm is None else tm.active_tab\n",
                "\n",
                "    @property\n",
                "    def active_window(self) -> Optional[Window]:\n",
                "        t = self.active_tab\n",
                "        return None if t is None else t.active_window\n",
                "\n",
                "    def set_pending_sequences(self, sequences: SubSequenceMap, default_pending_action: str = '') -> None:\n",
                "        self.pending_sequences = sequences\n",
                "        self.default_pending_action = default_pending_action\n",
                "        set_in_sequence_mode(True)\n",
                "\n",
                "    def dispatch_possible_special_key(self, ev: KeyEvent) -> bool:\n",
                "        # Handles shortcuts, return True if the key was consumed\n",
                "        key_action = get_shortcut(self.keymap, ev)\n",
                "        if key_action is None:\n",
                "            sequences = get_shortcut(get_options().sequence_map, ev)\n",
                "            if sequences and not isinstance(sequences, str):\n",
                "                self.set_pending_sequences(sequences)\n",
                "                return True\n",
                "            if self.global_shortcuts_map and get_shortcut(self.global_shortcuts_map, ev):\n",
                "                return True\n",
                "        elif isinstance(key_action, str):\n",
                "            return self.combine(key_action)\n",
                "        return False\n",
                "\n",
                "    def clear_pending_sequences(self) -> None:\n",
                "        self.pending_sequences = None\n",
                "        self.default_pending_action = ''\n",
                "        set_in_sequence_mode(False)\n",
                "\n",
                "    def process_sequence(self, ev: KeyEvent) -> None:\n",
                "        if not self.pending_sequences:\n",
                "            set_in_sequence_mode(False)\n",
                "            return\n",
                "\n",
                "        remaining = {}\n",
                "        matched_action = None\n",
                "        for seq, key_action in self.pending_sequences.items():\n",
                "            if shortcut_matches(seq[0], ev):\n",
                "                seq = seq[1:]\n",
                "                if seq:\n",
                "                    remaining[seq] = key_action\n",
                "                else:\n",
                "                    matched_action = key_action\n",
                "\n",
                "        if remaining:\n",
                "            self.pending_sequences = remaining\n",
                "        else:\n",
                "            matched_action = matched_action or self.default_pending_action\n",
                "            self.clear_pending_sequences()\n",
                "            if matched_action is not None:\n",
                "                self.combine(matched_action)\n",
                "\n",
                "    def cancel_current_visual_select(self) -> None:\n",
                "        if self.current_visual_select:\n",
                "            self.current_visual_select.cancel()\n",
                "            self.current_visual_select = None\n",
                "\n",
                "    def visual_window_select_action(\n",
                "        self, tab: Tab,\n",
                "        callback: Callable[[Optional[Tab], Optional[Window]], None],\n",
                "        choose_msg: str,\n",
                "        only_window_ids: Container[int] = (),\n",
                "        reactivate_prev_tab: bool = False\n",
                "    ) -> None:\n",
                "        import string\n",
                "        self.cancel_current_visual_select()\n",
                "        initial_tab_id: Optional[int] = None\n",
                "        initial_os_window_id = current_os_window()\n",
                "        tm = tab.tab_manager_ref()\n",
                "        if tm is not None:\n",
                "            if tm.active_tab is not None:\n",
                "                initial_tab_id = tm.active_tab.id\n",
                "            tm.set_active_tab(tab)\n",
                "        if initial_os_window_id != tab.os_window_id:\n",
                "            focus_os_window(tab.os_window_id, True)\n",
                "        self.current_visual_select = VisualSelect(tab.id, tab.os_window_id, initial_tab_id, initial_os_window_id, choose_msg, callback, reactivate_prev_tab)\n",
                "        if tab.current_layout.only_active_window_visible:\n",
                "            w = self.select_window_in_tab_using_overlay(tab, choose_msg, only_window_ids)\n",
                "            self.current_visual_select.window_used_for_selection_id = 0 if w is None else w.id\n",
                "            return\n",
                "        pending_sequences: SubSequenceMap = {}\n",
                "        fmap = get_name_to_functional_number_map()\n",
                "        alphanumerics = get_options().visual_window_select_characters\n",
                "        for idx, window in tab.windows.iter_windows_with_number(only_visible=True):\n",
                "            if only_window_ids and window.id not in only_window_ids:\n",
                "                continue\n",
                "            ac = f'visual_window_select_action_trigger {window.id}'\n",
                "            if idx >= len(alphanumerics):\n",
                "                break\n",
                "            ch = alphanumerics[idx]\n",
                "            window.screen.set_window_char(ch)\n",
                "            self.current_visual_select.window_ids.append(window.id)\n",
                "            for mods in (0, GLFW_MOD_CONTROL, GLFW_MOD_CONTROL | GLFW_MOD_SHIFT, GLFW_MOD_SUPER, GLFW_MOD_ALT, GLFW_MOD_SHIFT):\n",
                "                pending_sequences[(SingleKey(mods=mods, key=ord(ch.lower())),)] = ac\n",
                "                if ch in string.digits:\n",
                "                    pending_sequences[(SingleKey(mods=mods, key=fmap[f'KP_{ch}']),)] = ac\n",
                "        if len(self.current_visual_select.window_ids) > 1:\n",
                "            self.set_pending_sequences(pending_sequences, default_pending_action='visual_window_select_action_trigger 0')\n",
                "            redirect_mouse_handling(True)\n",
                "            self.mouse_handler = self.visual_window_select_mouse_handler\n",
                "        else:\n",
                "            self.visual_window_select_action_trigger(self.current_visual_select.window_ids[0] if self.current_visual_select.window_ids else 0)\n",
                "            if get_options().enable_audio_bell:\n",
                "                ring_bell()\n",
                "\n",
                "    def visual_window_select_action_trigger(self, window_id: int = 0) -> None:\n",
                "        if self.current_visual_select:\n",
                "            self.current_visual_select.trigger(int(window_id))\n",
                "        self.current_visual_select = None\n",
                "\n",
                "    def visual_window_select_mouse_handler(self, ev: WindowSystemMouseEvent) -> None:\n",
                "        tab = self.active_tab\n",
                "        if ev.button == GLFW_MOUSE_BUTTON_LEFT and ev.action == GLFW_PRESS and ev.window_id:\n",
                "            w = self.window_id_map.get(ev.window_id)\n",
                "            if w is not None and tab is not None and w in tab:\n",
                "                if self.current_visual_select and self.current_visual_select.tab_id == tab.id:\n",
                "                    self.visual_window_select_action_trigger(w.id)\n",
                "                else:\n",
                "                    self.visual_window_select_action_trigger()\n",
                "                return\n",
                "        if ev.button > -1 and tab is not None:\n",
                "            self.visual_window_select_action_trigger()\n",
                "\n",
                "    def mouse_event(\n",
                "        self, in_tab_bar: bool, window_id: int, action: int, modifiers: int, button: int,\n",
                "        currently_pressed_button: int, x: float, y: float\n",
                "    ) -> None:\n",
                "        if self.mouse_handler is not None:\n",
                "            ev = WindowSystemMouseEvent(in_tab_bar, window_id, action, modifiers, button, currently_pressed_button, x, y)\n",
                "            self.mouse_handler(ev)\n",
                "\n",
                "    def select_window_in_tab_using_overlay(self, tab: Tab, msg: str, only_window_ids: Container[int] = ()) -> Optional[Window]:\n",
                "        windows = tuple((None, f'Current window: {w.title}' if w is self.active_window else w.title)\n",
                "                        if only_window_ids and w.id not in only_window_ids else (w.id, w.title)\n",
                "                        for i, w in tab.windows.iter_windows_with_number(only_visible=False))\n",
                "        if len(windows) < 1:\n",
                "            self.visual_window_select_action_trigger(windows[0][0] if windows and windows[0][0] is not None else 0)\n",
                "            if get_options().enable_audio_bell:\n",
                "                ring_bell()\n",
                "            return None\n",
                "        cvs = self.current_visual_select\n",
                "\n",
                "        def chosen(ans: Union[None, int, str]) -> None:\n",
                "            q = self.current_visual_select\n",
                "            self.current_visual_select = None\n",
                "            if cvs and q is cvs:\n",
                "                q.trigger(ans if isinstance(ans, int) else 0)\n",
                "\n",
                "        return self.choose_entry(msg, windows, chosen, hints_args=('--hints-offset=0', '--alphabet', get_options().visual_window_select_characters.lower()))\n",
                "\n",
                "    @ac('win', '''\n",
                "        Resize the active window interactively\n",
                "\n",
                "        See :ref:`window_resizing` for details.\n",
                "        ''')\n",
                "    def start_resizing_window(self) -> None:\n",
                "        w = self.active_window\n",
                "        if w is None:\n",
                "            return\n",
                "        overlay_window = self._run_kitten('resize_window', args=[\n",
                "            f'--horizontal-increment={get_options().window_resize_step_cells}',\n",
                "            f'--vertical-increment={get_options().window_resize_step_lines}'\n",
                "        ])\n",
                "        if overlay_window is not None:\n",
                "            overlay_window.allow_remote_control = True\n",
                "\n",
                "    def resize_layout_window(self, window: Window, increment: float, is_horizontal: bool, reset: bool = False) -> Union[bool, None, str]:\n",
                "        tab = window.tabref()\n",
                "        if tab is None or not increment:\n",
                "            return False\n",
                "        if reset:\n",
                "            tab.reset_window_sizes()\n",
                "            return None\n",
                "        return tab.resize_window_by(window.id, increment, is_horizontal)\n",
                "\n",
                "    def resize_os_window(self, os_window_id: int, width: int, height: int, unit: str, incremental: bool = False) -> None:\n",
                "        if not incremental and (width < 0 or height < 0):\n",
                "            return\n",
                "        metrics = get_os_window_size(os_window_id)\n",
                "        if metrics is None:\n",
                "            return\n",
                "        has_window_scaling = is_macos or is_wayland()\n",
                "        w, h = get_new_os_window_size(metrics, width, height, unit, incremental, has_window_scaling)\n",
                "        set_os_window_size(os_window_id, w, h)\n",
                "\n",
                "    def default_bg_changed_for(self, window_id: int) -> None:\n",
                "        w = self.window_id_map.get(window_id)\n",
                "        if w is not None:\n",
                "            tm = self.os_window_map.get(w.os_window_id)\n",
                "            if tm is not None:\n",
                "                tm.update_tab_bar_data()\n",
                "                tm.mark_tab_bar_dirty()\n",
                "                t = tm.tab_for_id(w.tab_id)\n",
                "                if t is not None:\n",
                "                    t.relayout_borders()\n",
                "\n",
                "    def dispatch_action(\n",
                "        self,\n",
                "        key_action: KeyAction,\n",
                "        window_for_dispatch: Optional[Window] = None,\n",
                "        dispatch_type: str = 'KeyPress'\n",
                "    ) -> bool:\n",
                "\n",
                "        def report_match(f: Callable[..., Any]) -> None:\n",
                "            if self.args.debug_keyboard:\n",
                "                prefix = '\\n' if dispatch_type == 'KeyPress' else ''\n",
                "                print(f'{prefix}\\x1b[35m{dispatch_type}\\x1b[m matched action:', func_name(f), flush=True)\n",
                "\n",
                "        if key_action is not None:\n",
                "            f = getattr(self, key_action.func, None)\n",
                "            if f is not None:\n",
                "                report_match(f)\n",
                "                passthrough = f(*key_action.args)\n",
                "                if passthrough is not True:\n",
                "                    return True\n",
                "        if window_for_dispatch is None:\n",
                "            tab = self.active_tab\n",
                "            window = self.active_window\n",
                "        else:\n",
                "            window = window_for_dispatch\n",
                "            tab = window.tabref()\n",
                "        if tab is None or window is None:\n",
                "            return False\n",
                "        if key_action is not None:\n",
                "            f = getattr(tab, key_action.func, getattr(window, key_action.func, None))\n",
                "            if f is not None:\n",
                "                passthrough = f(*key_action.args)\n",
                "                report_match(f)\n",
                "                if passthrough is not True:\n",
                "                    return True\n",
                "        return False\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Combine multiple actions and map to a single keypress\n",
                "\n",
                "        The syntax is::\n",
                "\n",
                "            map key combine <separator> action1 <separator> action2 <separator> action3 ...\n",
                "\n",
                "        For example::\n",
                "\n",
                "            map kitty_mod+e combine : new_window : next_layout\n",
                "        ''')\n",
                "    def combine(self, action_definition: str, window_for_dispatch: Optional[Window] = None, dispatch_type: str = 'KeyPress') -> bool:\n",
                "        consumed = False\n",
                "        if action_definition:\n",
                "            try:\n",
                "                actions = get_options().alias_map.resolve_aliases(action_definition, 'map' if dispatch_type == 'KeyPress' else 'mouse_map')\n",
                "            except Exception as e:\n",
                "                import traceback\n",
                "                traceback.print_exc()\n",
                "                self.show_error('Failed to parse action', f'{action_definition}\\n{e}')\n",
                "                return True\n",
                "            if actions:\n",
                "                try:\n",
                "                    if self.dispatch_action(actions[0], window_for_dispatch, dispatch_type):\n",
                "                        consumed = True\n",
                "                        if len(actions) > 1:\n",
                "                            self.drain_actions(list(actions[1:]), window_for_dispatch, dispatch_type)\n",
                "                except Exception as e:\n",
                "                    self.show_error('Key action failed', f'{actions[0].pretty()}\\n{e}')\n",
                "                    consumed = True\n",
                "        return consumed\n",
                "\n",
                "    def on_focus(self, os_window_id: int, focused: bool) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            w = tm.active_window\n",
                "            if w is not None:\n",
                "                w.focus_changed(focused)\n",
                "                if is_macos and focused:\n",
                "                    cocoa_set_menubar_title(w.title or '')\n",
                "            tm.mark_tab_bar_dirty()\n",
                "\n",
                "    def on_activity_since_last_focus(self, window: Window) -> None:\n",
                "        os_window_id = window.os_window_id\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            tm.mark_tab_bar_dirty()\n",
                "\n",
                "    def update_tab_bar_data(self, os_window_id: int) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            tm.update_tab_bar_data()\n",
                "\n",
                "    def on_drop(self, os_window_id: int, mime: str, data: bytes) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            w = tm.active_window\n",
                "            if w is not None:\n",
                "                text = data.decode('utf-8', 'replace')\n",
                "                if mime == 'text/uri-list':\n",
                "                    urls = parse_uri_list(text)\n",
                "                    if w.at_prompt:\n",
                "                        import shlex\n",
                "                        text = ' '.join(map(shlex.quote, urls))\n",
                "                    else:\n",
                "                        text = '\\n'.join(urls)\n",
                "                w.paste_text(text)\n",
                "\n",
                "    @ac('win', 'Focus the nth OS window')\n",
                "    def nth_os_window(self, num: int = 1) -> None:\n",
                "        if self.os_window_map and num > 0:\n",
                "            ids = list(self.os_window_map.keys())\n",
                "            os_window_id = ids[min(num, len(ids)) - 1]\n",
                "            focus_os_window(os_window_id, True)\n",
                "\n",
                "    @ac('win', 'Close the currently active OS Window')\n",
                "    def close_os_window(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            self.confirm_os_window_close(tm.os_window_id)\n",
                "\n",
                "    def confirm_os_window_close(self, os_window_id: int) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        q = get_options().confirm_os_window_close\n",
                "        num = 0 if tm is None else (tm.number_of_windows_with_running_programs if q < 0 else tm.number_of_windows)\n",
                "        needs_confirmation = tm is not None and q != 0 and num >= abs(q)\n",
                "        if not needs_confirmation:\n",
                "            self.mark_os_window_for_close(os_window_id)\n",
                "            return\n",
                "        if tm is not None:\n",
                "            w = tm.active_window\n",
                "            self.confirm(\n",
                "                _('Are you sure you want to close this OS window, it has {}'\n",
                "                  ' windows running?').format(num),\n",
                "                self.handle_close_os_window_confirmation, os_window_id,\n",
                "                window=w,\n",
                "            )\n",
                "\n",
                "    def handle_close_os_window_confirmation(self, confirmed: bool, os_window_id: int) -> None:\n",
                "        if confirmed:\n",
                "            self.mark_os_window_for_close(os_window_id)\n",
                "        else:\n",
                "            self.mark_os_window_for_close(os_window_id, NO_CLOSE_REQUESTED)\n",
                "\n",
                "    def on_os_window_closed(self, os_window_id: int, viewport_width: int, viewport_height: int) -> None:\n",
                "        self.cached_values['window-size'] = viewport_width, viewport_height\n",
                "        tm = self.os_window_map.pop(os_window_id, None)\n",
                "        if tm is not None:\n",
                "            tm.destroy()\n",
                "        for window_id in tuple(w.id for w in self.window_id_map.values() if getattr(w, 'os_window_id', None) == os_window_id):\n",
                "            self.window_id_map.pop(window_id, None)\n",
                "        if not self.os_window_map and is_macos:\n",
                "            cocoa_set_menubar_title('')\n",
                "        action = self.os_window_death_actions.pop(os_window_id, None)\n",
                "        if action is not None:\n",
                "            action()\n",
                "\n",
                "    @ac('win', 'Quit, closing all windows')\n",
                "    def quit(self, *args: Any) -> None:\n",
                "        tm = self.active_tab\n",
                "        num = 0\n",
                "        x = get_options().confirm_os_window_close\n",
                "        for q in self.os_window_map.values():\n",
                "            num += q.number_of_windows_with_running_programs if x < 0 else q.number_of_windows\n",
                "        needs_confirmation = tm is not None and x != 0 and num >= abs(x)\n",
                "        if not needs_confirmation:\n",
                "            set_application_quit_request(IMPERATIVE_CLOSE_REQUESTED)\n",
                "            return\n",
                "        if current_application_quit_request() == CLOSE_BEING_CONFIRMED:\n",
                "            return\n",
                "        assert tm is not None\n",
                "        self.confirm(\n",
                "            _('Are you sure you want to quit kitty, it has {} windows running?').format(num),\n",
                "            self.handle_quit_confirmation,\n",
                "            window=tm.active_window,\n",
                "        )\n",
                "        set_application_quit_request(CLOSE_BEING_CONFIRMED)\n",
                "\n",
                "    def handle_quit_confirmation(self, confirmed: bool) -> None:\n",
                "        set_application_quit_request(IMPERATIVE_CLOSE_REQUESTED if confirmed else NO_CLOSE_REQUESTED)\n",
                "\n",
                "    def notify_on_os_window_death(self, address: str) -> None:\n",
                "        import socket\n",
                "        s = socket.socket(family=socket.AF_UNIX)\n",
                "        with suppress(Exception):\n",
                "            s.connect(address)\n",
                "            s.sendall(b'c')\n",
                "            with suppress(OSError):\n",
                "                s.shutdown(socket.SHUT_RDWR)\n",
                "            s.close()\n",
                "\n",
                "    def display_scrollback(self, window: Window, data: Union[bytes, str], input_line_number: int = 0, title: str = '', report_cursor: bool = True) -> None:\n",
                "\n",
                "        def prepare_arg(x: str) -> str:\n",
                "            x = x.replace('INPUT_LINE_NUMBER', str(input_line_number))\n",
                "            x = x.replace('CURSOR_LINE', str(window.screen.cursor.y + 1) if report_cursor else '0')\n",
                "            x = x.replace('CURSOR_COLUMN', str(window.screen.cursor.x + 1) if report_cursor else '0')\n",
                "            return x\n",
                "\n",
                "        cmd = list(map(prepare_arg, get_options().scrollback_pager))\n",
                "        if not os.path.isabs(cmd[0]):\n",
                "            cmd[0] = which(cmd[0]) or cmd[0]\n",
                "\n",
                "        if os.path.basename(cmd[0]) == 'less':\n",
                "            cmd.append('-+F')  # reset --quit-if-one-screen\n",
                "        tab = self.active_tab\n",
                "        if tab is not None:\n",
                "            bdata = data.encode('utf-8') if isinstance(data, str) else data\n",
                "            if is_macos and cmd[0] == '/usr/bin/less' and macos_version()[:2] < (12, 3):\n",
                "                # the system less before macOS 12.3 barfs up OSC codes, so sanitize them ourselves\n",
                "                sentinel = os.path.join(cache_dir(), 'less-is-new-enough')\n",
                "                if not os.path.exists(sentinel):\n",
                "                    if less_version(cmd[0]) >= 581:\n",
                "                        open(sentinel, 'w').close()\n",
                "                    else:\n",
                "                        bdata = re.sub(br'\\x1b\\].*?\\x1b\\\\', b'', bdata)\n",
                "\n",
                "            tab.new_special_window(\n",
                "                SpecialWindow(cmd, bdata, title or _('History'), overlay_for=window.id, cwd=window.cwd_of_child),\n",
                "                copy_colors_from=self.active_window\n",
                "                )\n",
                "\n",
                "    @ac('misc', 'Edit the kitty.conf config file in your favorite text editor')\n",
                "    def edit_config_file(self, *a: Any) -> None:\n",
                "        confpath = prepare_config_file_for_editing()\n",
                "        # On macOS vim fails to handle SIGWINCH if it occurs early, so add a\n",
                "        # small delay.\n",
                "        cmd = [kitty_exe(), '+runpy', 'import os, sys, time; time.sleep(0.05); os.execvp(sys.argv[1], sys.argv[1:])'] + get_editor(get_options()) + [confpath]\n",
                "        self.new_os_window(*cmd)\n",
                "\n",
                "    def _run_kitten(\n",
                "        self,\n",
                "        kitten: str,\n",
                "        args: Iterable[str] = (),\n",
                "        input_data: Optional[Union[bytes, str]] = None,\n",
                "        window: Optional[Window] = None,\n",
                "        custom_callback: Optional[Callable[[Dict[str, Any], int, 'Boss'], None]] = None,\n",
                "        action_on_removal: Optional[Callable[[int, 'Boss'], None]] = None,\n",
                "        default_data: Optional[Dict[str, Any]] = None\n",
                "    ) -> Any:\n",
                "        orig_args, args = list(args), list(args)\n",
                "        from kittens.runner import create_kitten_handler\n",
                "        end_kitten = create_kitten_handler(kitten, orig_args)\n",
                "        if window is None:\n",
                "            w = self.active_window\n",
                "            tab = self.active_tab\n",
                "        else:\n",
                "            w = window\n",
                "            tab = w.tabref() if w else None\n",
                "        if end_kitten.no_ui:\n",
                "            return end_kitten(None, getattr(w, 'id', None), self)\n",
                "\n",
                "        if w is not None and tab is not None:\n",
                "            args[0:0] = [config_dir, kitten]\n",
                "            if input_data is None:\n",
                "                type_of_input = end_kitten.type_of_input\n",
                "                q = type_of_input.split('-') if type_of_input else []\n",
                "                if not q:\n",
                "                    data: Optional[bytes] = None\n",
                "                elif q[0] in ('text', 'history', 'ansi', 'screen'):\n",
                "                    data = w.as_text(as_ansi='ansi' in q, add_history='history' in q, add_wrap_markers='screen' in q).encode('utf-8')\n",
                "                elif type_of_input == 'selection':\n",
                "                    sel = self.data_for_at(which='@selection', window=w)\n",
                "                    data = sel.encode('utf-8') if sel else None\n",
                "                elif q[0] in ('output', 'first_output', 'last_visited_output'):\n",
                "                    which = {\n",
                "                        'output': CommandOutput.last_run, 'first_output': CommandOutput.first_on_screen,\n",
                "                        'last_visited_output': CommandOutput.last_visited}[q[0]]\n",
                "                    data = w.cmd_output(which, as_ansi='ansi' in q, add_wrap_markers='screen' in q).encode('utf-8')\n",
                "                else:\n",
                "                    raise ValueError(f'Unknown type_of_input: {type_of_input}')\n",
                "            else:\n",
                "                data = input_data if isinstance(input_data, bytes) else input_data.encode('utf-8')\n",
                "            copts = common_opts_as_dict(get_options())\n",
                "            final_args: List[str] = []\n",
                "            for x in args:\n",
                "                if x == '@selection':\n",
                "                    sel = self.data_for_at(which='@selection', window=w)\n",
                "                    if sel:\n",
                "                        x = sel\n",
                "                final_args.append(x)\n",
                "            overlay_window = tab.new_special_window(\n",
                "                SpecialWindow(\n",
                "                    [kitty_exe(), '+runpy', 'from kittens.runner import main; main()'] + final_args,\n",
                "                    stdin=data,\n",
                "                    env={\n",
                "                        'KITTY_COMMON_OPTS': json.dumps(copts),\n",
                "                        'KITTY_CHILD_PID': str(w.child.pid),\n",
                "                        'PYTHONWARNINGS': 'ignore',\n",
                "                        'OVERLAID_WINDOW_LINES': str(w.screen.lines),\n",
                "                        'OVERLAID_WINDOW_COLS': str(w.screen.columns),\n",
                "                    },\n",
                "                    cwd=w.cwd_of_child,\n",
                "                    overlay_for=w.id,\n",
                "                    overlay_behind=end_kitten.has_ready_notification,\n",
                "                ),\n",
                "                copy_colors_from=w\n",
                "            )\n",
                "            wid = w.id\n",
                "            overlay_window.actions_on_close.append(partial(self.on_kitten_finish, wid, custom_callback or end_kitten, default_data=default_data))\n",
                "            if action_on_removal is not None:\n",
                "\n",
                "                def callback_wrapper(*a: Any) -> None:\n",
                "                    if action_on_removal is not None:\n",
                "                        action_on_removal(wid, self)\n",
                "                overlay_window.actions_on_removal.append(callback_wrapper)\n",
                "            return overlay_window\n",
                "\n",
                "    @ac('misc', 'Run the specified kitten. See :doc:`/kittens/custom` for details')\n",
                "    def kitten(self, kitten: str, *kargs: str) -> None:\n",
                "        self._run_kitten(kitten, kargs)\n",
                "\n",
                "    def run_kitten(self, kitten: str, *args: str) -> None:\n",
                "        self._run_kitten(kitten, args)\n",
                "\n",
                "    def on_kitten_finish(\n",
                "        self, target_window_id: int, end_kitten: Callable[[Dict[str, Any], int, 'Boss'], None],\n",
                "        source_window: Window,\n",
                "        default_data: Optional[Dict[str, Any]] = None\n",
                "    ) -> None:\n",
                "        data, source_window.kitten_result = source_window.kitten_result, None\n",
                "        if data is None:\n",
                "            data = default_data\n",
                "        if data is not None:\n",
                "            end_kitten(data, target_window_id, self)\n",
                "\n",
                "    @ac('misc', 'Input an arbitrary unicode character. See :doc:`/kittens/unicode_input` for details.')\n",
                "    def input_unicode_character(self) -> None:\n",
                "        self._run_kitten('unicode_input')\n",
                "\n",
                "    @ac('tab', 'Change the title of the active tab')\n",
                "    def set_tab_title(self) -> None:\n",
                "        tab = self.active_tab\n",
                "        if tab:\n",
                "            args = [\n",
                "                '--name=tab-title', '--message', _('Enter the new title for this tab below.'),\n",
                "                '--default', tab.name or tab.title, 'do_set_tab_title', str(tab.id)]\n",
                "            self._run_kitten('ask', args)\n",
                "\n",
                "    def do_set_tab_title(self, title: str, tab_id: int) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tab_id = int(tab_id)\n",
                "            for tab in tm.tabs:\n",
                "                if tab.id == tab_id:\n",
                "                    tab.set_title(title)\n",
                "                    break\n",
                "\n",
                "    def show_error(self, title: str, msg: str) -> None:\n",
                "        self._run_kitten('show_error', args=['--title', title], input_data=msg)\n",
                "\n",
                "    @ac('mk', 'Create a new marker')\n",
                "    def create_marker(self) -> None:\n",
                "        w = self.active_window\n",
                "        if w:\n",
                "            spec = None\n",
                "\n",
                "            def done(data: Dict[str, Any], target_window_id: int, self: Boss) -> None:\n",
                "                nonlocal spec\n",
                "                spec = data['response']\n",
                "\n",
                "            def done2(target_window_id: int, self: Boss) -> None:\n",
                "                w = self.window_id_map.get(target_window_id)\n",
                "                if w is not None and spec:\n",
                "                    try:\n",
                "                        w.set_marker(spec)\n",
                "                    except Exception as err:\n",
                "                        self.show_error(_('Invalid marker specification'), str(err))\n",
                "\n",
                "            self._run_kitten('ask', [\n",
                "                '--name=create-marker', '--message',\n",
                "                _('Create marker, for example:\\ntext 1 ERROR\\nSee {}\\n').format(website_url('marks'))\n",
                "                ],\n",
                "                custom_callback=done, action_on_removal=done2)\n",
                "\n",
                "    @ac('misc', 'Run the kitty shell to control kitty with commands')\n",
                "    def kitty_shell(self, window_type: str = 'window') -> None:\n",
                "        kw: Dict[str, Any] = {}\n",
                "        cmd = [kitty_exe(), '@']\n",
                "        aw = self.active_window\n",
                "        if aw is not None:\n",
                "            kw['env'] = {'KITTY_SHELL_ACTIVE_WINDOW_ID': str(aw.id)}\n",
                "        if window_type == 'tab':\n",
                "            tab = self._new_tab(SpecialWindow(cmd, **kw))\n",
                "            if tab is not None:\n",
                "                for w in tab:\n",
                "                    w.allow_remote_control = True\n",
                "                    window = w\n",
                "        elif window_type == 'os_window':\n",
                "            os_window_id = self._new_os_window(SpecialWindow(cmd, **kw))\n",
                "            for tab in self.os_window_map[os_window_id]:\n",
                "                for w in tab:\n",
                "                    w.allow_remote_control = True\n",
                "                    window = w\n",
                "        elif window_type == 'overlay':\n",
                "            tab = self.active_tab\n",
                "            if aw is not None and tab is not None:\n",
                "                kw['overlay_for'] = aw.id\n",
                "                window = tab.new_special_window(SpecialWindow(cmd, **kw), allow_remote_control=True)\n",
                "        else:\n",
                "            tab = self.active_tab\n",
                "            if tab is not None:\n",
                "                window = tab.new_special_window(SpecialWindow(cmd, **kw), allow_remote_control=True)\n",
                "\n",
                "        path, ext = os.path.splitext(logo_png_file)\n",
                "        window.set_logo(f'{path}-128{ext}', position='bottom-right', alpha=0.25)\n",
                "\n",
                "    def switch_focus_to(self, window_id: int) -> None:\n",
                "        tab = self.active_tab\n",
                "        if tab:\n",
                "            tab.set_active_window(window_id)\n",
                "\n",
                "    def open_url(self, url: str, program: Optional[Union[str, List[str]]] = None, cwd: Optional[str] = None) -> None:\n",
                "        if not url:\n",
                "            return\n",
                "        if isinstance(program, str):\n",
                "            program = to_cmdline(program)\n",
                "        found_action = False\n",
                "        if program is None:\n",
                "            from .open_actions import actions_for_url\n",
                "            actions = list(actions_for_url(url))\n",
                "            if actions:\n",
                "                found_action = True\n",
                "                self.dispatch_action(actions.pop(0))\n",
                "                if actions:\n",
                "                    self.drain_actions(actions)\n",
                "        if not found_action:\n",
                "            open_url(url, program or get_options().open_url_with, cwd=cwd)\n",
                "\n",
                "    @ac('misc', 'Click a URL using the keyboard')\n",
                "    def open_url_with_hints(self) -> None:\n",
                "        self._run_kitten('hints')\n",
                "\n",
                "    def drain_actions(self, actions: List[KeyAction], window_for_dispatch: Optional[Window] = None, dispatch_type: str = 'KeyPress') -> None:\n",
                "\n",
                "        def callback(timer_id: Optional[int]) -> None:\n",
                "            self.dispatch_action(actions.pop(0), window_for_dispatch, dispatch_type)\n",
                "            if actions:\n",
                "                self.drain_actions(actions)\n",
                "        add_timer(callback, 0, False)\n",
                "\n",
                "    def destroy(self) -> None:\n",
                "        self.shutting_down = True\n",
                "        self.child_monitor.shutdown_monitor()\n",
                "        self.set_update_check_process()\n",
                "        self.update_check_process = None\n",
                "        del self.child_monitor\n",
                "        for tm in self.os_window_map.values():\n",
                "            tm.destroy()\n",
                "        self.os_window_map = {}\n",
                "        destroy_global_data()\n",
                "\n",
                "    def paste_to_active_window(self, text: str) -> None:\n",
                "        if text:\n",
                "            w = self.active_window\n",
                "            if w is not None:\n",
                "                w.paste_with_actions(text)\n",
                "\n",
                "    @ac('cp', 'Paste from the clipboard to the active window')\n",
                "    def paste_from_clipboard(self) -> None:\n",
                "        text = get_clipboard_string()\n",
                "        self.paste_to_active_window(text)\n",
                "\n",
                "    def current_primary_selection(self) -> str:\n",
                "        return get_primary_selection() if supports_primary_selection else ''\n",
                "\n",
                "    def current_primary_selection_or_clipboard(self) -> str:\n",
                "        return get_primary_selection() if supports_primary_selection else get_clipboard_string()\n",
                "\n",
                "    @ac('cp', 'Paste from the clipboard to the active window')\n",
                "    def paste_from_selection(self) -> None:\n",
                "        text = self.current_primary_selection_or_clipboard()\n",
                "        self.paste_to_active_window(text)\n",
                "\n",
                "    def set_primary_selection(self) -> None:\n",
                "        w = self.active_window\n",
                "        if w is not None and not w.destroyed:\n",
                "            text = w.text_for_selection()\n",
                "            if text:\n",
                "                set_primary_selection(text)\n",
                "                if get_options().copy_on_select:\n",
                "                    self.copy_to_buffer(get_options().copy_on_select)\n",
                "\n",
                "    @ac('cp', '''\n",
                "        Copy the selection from the active window to the specified buffer\n",
                "\n",
                "        See :ref:`cpbuf` for details.\n",
                "        ''')\n",
                "    def copy_to_buffer(self, buffer_name: str) -> None:\n",
                "        w = self.active_window\n",
                "        if w is not None and not w.destroyed:\n",
                "            text = w.text_for_selection()\n",
                "            if text:\n",
                "                if buffer_name == 'clipboard':\n",
                "                    set_clipboard_string(text)\n",
                "                elif buffer_name == 'primary':\n",
                "                    set_primary_selection(text)\n",
                "                else:\n",
                "                    self.clipboard_buffers[buffer_name] = text\n",
                "\n",
                "    @ac('cp', '''\n",
                "        Paste from the specified buffer to the active window\n",
                "\n",
                "        See :ref:`cpbuf` for details.\n",
                "        ''')\n",
                "    def paste_from_buffer(self, buffer_name: str) -> None:\n",
                "        if buffer_name == 'clipboard':\n",
                "            text: Optional[str] = get_clipboard_string()\n",
                "        elif buffer_name == 'primary':\n",
                "            text = get_primary_selection()\n",
                "        else:\n",
                "            text = self.clipboard_buffers.get(buffer_name)\n",
                "        if text:\n",
                "            self.paste_to_active_window(text)\n",
                "\n",
                "    @ac('tab', '''\n",
                "        Go to the specified tab, by number, starting with 1\n",
                "\n",
                "        Zero and negative numbers go to previously active tabs\n",
                "        ''')\n",
                "    def goto_tab(self, tab_num: int) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tm.goto_tab(tab_num - 1)\n",
                "\n",
                "    def set_active_tab(self, tab: Tab) -> bool:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            return tm.set_active_tab(tab)\n",
                "        return False\n",
                "\n",
                "    @ac('tab', 'Make the next tab active')\n",
                "    def next_tab(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tm.next_tab()\n",
                "\n",
                "    @ac('tab', 'Make the previous tab active')\n",
                "    def previous_tab(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tm.next_tab(-1)\n",
                "\n",
                "    prev_tab = previous_tab\n",
                "\n",
                "    def process_stdin_source(\n",
                "        self, window: Optional[Window] = None,\n",
                "        stdin: Optional[str] = None, copy_pipe_data: Optional[Dict[str, Any]] = None\n",
                "    ) -> Tuple[Optional[Dict[str, str]], Optional[bytes]]:\n",
                "        w = window or self.active_window\n",
                "        if not w:\n",
                "            return None, None\n",
                "        env = None\n",
                "        input_data = None\n",
                "        if stdin:\n",
                "            add_wrap_markers = stdin.endswith('_wrap')\n",
                "            if add_wrap_markers:\n",
                "                stdin = stdin[:-len('_wrap')]\n",
                "            stdin = data_for_at(w, stdin, add_wrap_markers=add_wrap_markers)\n",
                "            if stdin is not None:\n",
                "                pipe_data = w.pipe_data(stdin, has_wrap_markers=add_wrap_markers) if w else None\n",
                "                if pipe_data:\n",
                "                    if copy_pipe_data is not None:\n",
                "                        copy_pipe_data.update(pipe_data)\n",
                "                    env = {\n",
                "                        'KITTY_PIPE_DATA':\n",
                "                        '{scrolled_by}:{cursor_x},{cursor_y}:{lines},{columns}'.format(**pipe_data)\n",
                "                    }\n",
                "                input_data = stdin.encode('utf-8')\n",
                "        return env, input_data\n",
                "\n",
                "    def data_for_at(self, which: str, window: Optional[Window] = None, add_wrap_markers: bool = False) -> Optional[str]:\n",
                "        window = window or self.active_window\n",
                "        if not window:\n",
                "            return None\n",
                "        return data_for_at(window, which, add_wrap_markers=add_wrap_markers)\n",
                "\n",
                "    def special_window_for_cmd(\n",
                "        self, cmd: List[str],\n",
                "        window: Optional[Window] = None,\n",
                "        stdin: Optional[str] = None,\n",
                "        cwd_from: Optional[CwdRequest] = None,\n",
                "        as_overlay: bool = False\n",
                "    ) -> SpecialWindowInstance:\n",
                "        w = window or self.active_window\n",
                "        env, input_data = self.process_stdin_source(w, stdin)\n",
                "        cmdline = []\n",
                "        for arg in cmd:\n",
                "            if arg == '@selection' and w:\n",
                "                q = data_for_at(w, arg)\n",
                "                if not q:\n",
                "                    continue\n",
                "                arg = q\n",
                "            cmdline.append(arg)\n",
                "        overlay_for = w.id if w and as_overlay else None\n",
                "        return SpecialWindow(cmd, input_data, cwd_from=cwd_from, overlay_for=overlay_for, env=env)\n",
                "\n",
                "    def run_background_process(\n",
                "        self,\n",
                "        cmd: List[str],\n",
                "        cwd: Optional[str] = None,\n",
                "        env: Optional[Dict[str, str]] = None,\n",
                "        stdin: Optional[bytes] = None,\n",
                "        cwd_from: Optional[CwdRequest] = None\n",
                "    ) -> None:\n",
                "        import subprocess\n",
                "        env = env or None\n",
                "        if env:\n",
                "            env_ = default_env().copy()\n",
                "            env_.update(env)\n",
                "            env = env_\n",
                "        if cwd_from:\n",
                "            with suppress(Exception):\n",
                "                cwd = cwd_from.cwd_of_child\n",
                "\n",
                "        if stdin:\n",
                "            r, w = safe_pipe(False)\n",
                "            try:\n",
                "                subprocess.Popen(cmd, env=env, stdin=r, cwd=cwd)\n",
                "            except Exception:\n",
                "                os.close(w)\n",
                "            else:\n",
                "                thread_write(w, stdin)\n",
                "            finally:\n",
                "                os.close(r)\n",
                "        else:\n",
                "            subprocess.Popen(cmd, env=env, cwd=cwd)\n",
                "\n",
                "    def pipe(self, source: str, dest: str, exe: str, *args: str) -> Optional[Window]:\n",
                "        cmd = [exe] + list(args)\n",
                "        window = self.active_window\n",
                "        cwd_from = CwdRequest(window) if window else None\n",
                "\n",
                "        def create_window() -> SpecialWindowInstance:\n",
                "            return self.special_window_for_cmd(\n",
                "                cmd, stdin=source, as_overlay=dest == 'overlay', cwd_from=cwd_from)\n",
                "\n",
                "        if dest == 'overlay' or dest == 'window':\n",
                "            tab = self.active_tab\n",
                "            if tab is not None:\n",
                "                return tab.new_special_window(create_window())\n",
                "        elif dest == 'tab':\n",
                "            tm = self.active_tab_manager\n",
                "            if tm is not None:\n",
                "                tm.new_tab(special_window=create_window(), cwd_from=cwd_from)\n",
                "        elif dest == 'os_window':\n",
                "            self._new_os_window(create_window(), cwd_from=cwd_from)\n",
                "        elif dest in ('clipboard', 'primary'):\n",
                "            env, stdin = self.process_stdin_source(stdin=source, window=window)\n",
                "            if stdin:\n",
                "                if dest == 'clipboard':\n",
                "                    set_clipboard_string(stdin)\n",
                "                else:\n",
                "                    set_primary_selection(stdin)\n",
                "        else:\n",
                "            env, stdin = self.process_stdin_source(stdin=source, window=window)\n",
                "            self.run_background_process(cmd, cwd_from=cwd_from, stdin=stdin, env=env)\n",
                "        return None\n",
                "\n",
                "    def args_to_special_window(self, args: Iterable[str], cwd_from: Optional[CwdRequest] = None) -> SpecialWindowInstance:\n",
                "        args = list(args)\n",
                "        stdin = None\n",
                "        w = self.active_window\n",
                "\n",
                "        if args[0].startswith('@') and args[0] != '@':\n",
                "            q = data_for_at(w, args[0]) or None\n",
                "            if q is not None:\n",
                "                stdin = q.encode('utf-8')\n",
                "            del args[0]\n",
                "\n",
                "        cmd = []\n",
                "        for arg in args:\n",
                "            if arg == '@selection':\n",
                "                q = data_for_at(w, arg)\n",
                "                if not q:\n",
                "                    continue\n",
                "                arg = q\n",
                "            cmd.append(arg)\n",
                "        return SpecialWindow(cmd, stdin, cwd_from=cwd_from)\n",
                "\n",
                "    def _new_tab(self, args: Union[SpecialWindowInstance, Iterable[str]], cwd_from: Optional[CwdRequest] = None, as_neighbor: bool = False) -> Optional[Tab]:\n",
                "        special_window = None\n",
                "        if args:\n",
                "            if isinstance(args, SpecialWindowInstance):\n",
                "                special_window = args\n",
                "            else:\n",
                "                special_window = self.args_to_special_window(args, cwd_from=cwd_from)\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            return tm.new_tab(special_window=special_window, cwd_from=cwd_from, as_neighbor=as_neighbor)\n",
                "        return None\n",
                "\n",
                "    def _create_tab(self, args: List[str], cwd_from: Optional[CwdRequest] = None) -> None:\n",
                "        as_neighbor = False\n",
                "        if args and args[0].startswith('!'):\n",
                "            as_neighbor = 'neighbor' in args[0][1:].split(',')\n",
                "            args = args[1:]\n",
                "        self._new_tab(args, as_neighbor=as_neighbor, cwd_from=cwd_from)\n",
                "\n",
                "    @ac('tab', 'Create a new tab')\n",
                "    def new_tab(self, *args: str) -> None:\n",
                "        self._create_tab(list(args))\n",
                "\n",
                "    @ac('tab', 'Create a new tab with working directory for the window in it set to the same as the active window')\n",
                "    def new_tab_with_cwd(self, *args: str) -> None:\n",
                "        self._create_tab(list(args), cwd_from=CwdRequest(self.active_window_for_cwd))\n",
                "\n",
                "    def new_tab_with_wd(self, wd: Union[str, List[str]], str_is_multiple_paths: bool = False) -> None:\n",
                "        if not self.os_window_map:\n",
                "            self.add_os_window()\n",
                "        if isinstance(wd, str):\n",
                "            wd = wd.split(os.pathsep) if str_is_multiple_paths else [wd]\n",
                "        for path in wd:\n",
                "            special_window = SpecialWindow(None, cwd=path)\n",
                "            self._new_tab(special_window)\n",
                "\n",
                "    def _new_window(self, args: List[str], cwd_from: Optional[CwdRequest] = None) -> Optional[Window]:\n",
                "        tab = self.active_tab\n",
                "        if tab is None:\n",
                "            return None\n",
                "        allow_remote_control = False\n",
                "        location = None\n",
                "        if args and args[0].startswith('!'):\n",
                "            location = args[0][1:].lower()\n",
                "            args = args[1:]\n",
                "        if args and args[0] == '@':\n",
                "            args = args[1:]\n",
                "            allow_remote_control = True\n",
                "        if args:\n",
                "            return tab.new_special_window(\n",
                "                self.args_to_special_window(args, cwd_from=cwd_from),\n",
                "                location=location, allow_remote_control=allow_remote_control)\n",
                "        else:\n",
                "            return tab.new_window(cwd_from=cwd_from, location=location, allow_remote_control=allow_remote_control)\n",
                "\n",
                "    @ac('win', 'Create a new window')\n",
                "    def new_window(self, *args: str) -> None:\n",
                "        self._new_window(list(args))\n",
                "\n",
                "    @ac('win', 'Create a new window with working directory same as that of the active window')\n",
                "    def new_window_with_cwd(self, *args: str) -> None:\n",
                "        w = self.active_window_for_cwd\n",
                "        if w is None:\n",
                "            return self.new_window(*args)\n",
                "        self._new_window(list(args), cwd_from=CwdRequest(w))\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Launch the specified program in a new window/tab/etc.\n",
                "\n",
                "        See :doc:`launch` for details\n",
                "        ''')\n",
                "    def launch(self, *args: str) -> None:\n",
                "        from kitty.launch import launch, parse_launch_args\n",
                "        opts, args_ = parse_launch_args(args)\n",
                "        launch(self, opts, args_)\n",
                "\n",
                "    @ac('tab', 'Move the active tab forward')\n",
                "    def move_tab_forward(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tm.move_tab(1)\n",
                "\n",
                "    @ac('tab', 'Move the active tab backward')\n",
                "    def move_tab_backward(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tm.move_tab(-1)\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Turn on/off ligatures in the specified window\n",
                "\n",
                "        See :opt:`disable_ligatures` for details\n",
                "        ''')\n",
                "    def disable_ligatures_in(self, where: Union[str, Iterable[Window]], strategy: int) -> None:\n",
                "        if isinstance(where, str):\n",
                "            windows: List[Window] = []\n",
                "            if where == 'active':\n",
                "                if self.active_window is not None:\n",
                "                    windows = [self.active_window]\n",
                "            elif where == 'all':\n",
                "                windows = list(self.all_windows)\n",
                "            elif where == 'tab':\n",
                "                if self.active_tab is not None:\n",
                "                    windows = list(self.active_tab)\n",
                "        else:\n",
                "            windows = list(where)\n",
                "        for window in windows:\n",
                "            window.screen.disable_ligatures = strategy\n",
                "            window.refresh()\n",
                "\n",
                "    def patch_colors(self, spec: Dict[str, Optional[int]], configured: bool = False) -> None:\n",
                "        from kitty.rc.set_colors import nullable_colors\n",
                "        opts = get_options()\n",
                "        if configured:\n",
                "            for k, v in spec.items():\n",
                "                if hasattr(opts, k):\n",
                "                    if v is None:\n",
                "                        if k in nullable_colors:\n",
                "                            setattr(opts, k, None)\n",
                "                    else:\n",
                "                        setattr(opts, k, color_from_int(v))\n",
                "        for tm in self.all_tab_managers:\n",
                "            tm.tab_bar.patch_colors(spec)\n",
                "            tm.tab_bar.layout()\n",
                "            tm.mark_tab_bar_dirty()\n",
                "            t = tm.active_tab\n",
                "            if t is not None:\n",
                "                t.relayout_borders()\n",
                "        patch_global_colors(spec, configured)\n",
                "\n",
                "    def apply_new_options(self, opts: Options) -> None:\n",
                "        from .fonts.box_drawing import set_scale\n",
                "\n",
                "        # Update options storage\n",
                "        set_options(opts, is_wayland(), self.args.debug_rendering, self.args.debug_font_fallback)\n",
                "        apply_options_update()\n",
                "        set_layout_options(opts)\n",
                "        set_default_env(opts.env.copy())\n",
                "        # Update font data\n",
                "        set_scale(opts.box_drawing_scale)\n",
                "        from .fonts.render import set_font_family\n",
                "        set_font_family(opts, debug_font_matching=self.args.debug_font_fallback)\n",
                "        for os_window_id, tm in self.os_window_map.items():\n",
                "            if tm is not None:\n",
                "                os_window_font_size(os_window_id, opts.font_size, True)\n",
                "                tm.resize()\n",
                "        # Update key bindings\n",
                "        self.update_keymap()\n",
                "        # Update misc options\n",
                "        for tm in self.all_tab_managers:\n",
                "            tm.apply_options()\n",
                "        # Update colors\n",
                "        for w in self.all_windows:\n",
                "            self.default_bg_changed_for(w.id)\n",
                "            w.refresh()\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Reload the config file\n",
                "\n",
                "        If mapped without arguments reloads the default config file, otherwise loads\n",
                "        the specified config files, in order. Loading a config file *replaces* all\n",
                "        config options. For example::\n",
                "\n",
                "            map f5 load_config_file /path/to/some/kitty.conf\n",
                "        ''')\n",
                "    def load_config_file(self, *paths: str, apply_overrides: bool = True) -> None:\n",
                "        from .config import load_config\n",
                "        old_opts = get_options()\n",
                "        paths = paths or old_opts.config_paths\n",
                "        bad_lines: List[BadLine] = []\n",
                "        opts = load_config(*paths, overrides=old_opts.config_overrides if apply_overrides else None, accumulate_bad_lines=bad_lines)\n",
                "        if bad_lines:\n",
                "            self.show_bad_config_lines(bad_lines)\n",
                "        self.apply_new_options(opts)\n",
                "        from .open_actions import load_open_actions\n",
                "        load_open_actions.clear_cached()\n",
                "\n",
                "    def safe_delete_temp_file(self, path: str) -> None:\n",
                "        if is_path_in_temp_dir(path):\n",
                "            with suppress(FileNotFoundError):\n",
                "                os.remove(path)\n",
                "\n",
                "    def set_update_check_process(self, process: Optional['PopenType[bytes]'] = None) -> None:\n",
                "        if self.update_check_process is not None:\n",
                "            with suppress(Exception):\n",
                "                if self.update_check_process.poll() is None:\n",
                "                    self.update_check_process.kill()\n",
                "        self.update_check_process = process\n",
                "\n",
                "    def on_monitored_pid_death(self, pid: int, exit_status: int) -> None:\n",
                "        update_check_process = self.update_check_process\n",
                "        if update_check_process is not None and pid == update_check_process.pid:\n",
                "            self.update_check_process = None\n",
                "            from .update_check import process_current_release\n",
                "            try:\n",
                "                assert update_check_process.stdout is not None\n",
                "                raw = update_check_process.stdout.read().decode('utf-8')\n",
                "            except Exception as e:\n",
                "                log_error(f'Failed to read data from update check process, with error: {e}')\n",
                "            else:\n",
                "                try:\n",
                "                    process_current_release(raw)\n",
                "                except Exception as e:\n",
                "                    log_error(f'Failed to process update check data {raw!r}, with error: {e}')\n",
                "\n",
                "    def dbus_notification_callback(self, activated: bool, a: int, b: Union[int, str]) -> None:\n",
                "        from .notify import (\n",
                "            dbus_notification_activated, dbus_notification_created\n",
                "        )\n",
                "        if activated:\n",
                "            assert isinstance(b, str)\n",
                "            dbus_notification_activated(a, b)\n",
                "        else:\n",
                "            assert isinstance(b, int)\n",
                "            dbus_notification_created(a, b)\n",
                "\n",
                "    def show_bad_config_lines(self, bad_lines: Iterable[BadLine]) -> None:\n",
                "\n",
                "        def format_bad_line(bad_line: BadLine) -> str:\n",
                "            return f'{bad_line.number}:{bad_line.exception} in line: {bad_line.line}\\n'\n",
                "\n",
                "        groups: Dict[str, List[BadLine]] = {}\n",
                "        for bl in bad_lines:\n",
                "            groups.setdefault(bl.file, []).append(bl)\n",
                "        ans: List[str] = []\n",
                "        a = ans.append\n",
                "        for file in sorted(groups):\n",
                "            if file:\n",
                "                a(f'In file {file}:')\n",
                "            [a(format_bad_line(x)) for x in groups[file]]\n",
                "\n",
                "        msg = '\\n'.join(ans).rstrip()\n",
                "        self.show_error(_('Errors parsing configuration'), msg)\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Change colors in the specified windows\n",
                "\n",
                "        For details, see :ref:`at_set-colors`. For example::\n",
                "\n",
                "            map f5 set_colors --configured /path/to/some/config/file/colors.conf\n",
                "        ''')\n",
                "    def set_colors(self, *args: str) -> None:\n",
                "        from kitty.rc.base import (\n",
                "            PayloadGetter, command_for_name, parse_subcommand_cli\n",
                "        )\n",
                "        from kitty.remote_control import parse_rc_args\n",
                "        c = command_for_name('set_colors')\n",
                "        try:\n",
                "            opts, items = parse_subcommand_cli(c, ['set-colors'] + list(args))\n",
                "        except (Exception, SystemExit) as err:\n",
                "            self.show_error('Invalid set_colors mapping', str(err))\n",
                "            return\n",
                "        try:\n",
                "            payload = c.message_to_kitty(parse_rc_args([])[0], opts, items)\n",
                "        except (Exception, SystemExit) as err:\n",
                "            self.show_error('Failed to set colors', str(err))\n",
                "            return\n",
                "        c.response_from_kitty(self, self.active_window, PayloadGetter(c, payload if isinstance(payload, dict) else {}))\n",
                "\n",
                "    def _move_window_to(\n",
                "        self,\n",
                "        window: Optional[Window] = None,\n",
                "        target_tab_id: Optional[Union[str, int]] = None,\n",
                "        target_os_window_id: Optional[Union[str, int]] = None\n",
                "    ) -> None:\n",
                "        window = window or self.active_window\n",
                "        if not window:\n",
                "            return\n",
                "        src_tab = self.tab_for_window(window)\n",
                "        if src_tab is None:\n",
                "            return\n",
                "        if target_os_window_id == 'new':\n",
                "            target_os_window_id = self.add_os_window()\n",
                "            tm = self.os_window_map[target_os_window_id]\n",
                "            target_tab = tm.new_tab(empty_tab=True)\n",
                "        else:\n",
                "            target_os_window_id = target_os_window_id or current_os_window()\n",
                "            if isinstance(target_tab_id, str):\n",
                "                if not isinstance(target_os_window_id, int):\n",
                "                    q = self.active_tab_manager\n",
                "                    assert q is not None\n",
                "                    tm = q\n",
                "                else:\n",
                "                    tm = self.os_window_map[target_os_window_id]\n",
                "                if target_tab_id == 'new':\n",
                "                    target_tab = tm.new_tab(empty_tab=True)\n",
                "                else:\n",
                "                    target_tab = tm.tab_at_location(target_tab_id) or tm.new_tab(empty_tab=True)\n",
                "            else:\n",
                "                for tab in self.all_tabs:\n",
                "                    if tab.id == target_tab_id:\n",
                "                        target_tab = tab\n",
                "                        target_os_window_id = tab.os_window_id\n",
                "                        break\n",
                "                else:\n",
                "                    return\n",
                "\n",
                "        for detached_window in src_tab.detach_window(window):\n",
                "            target_tab.attach_window(detached_window)\n",
                "        self._cleanup_tab_after_window_removal(src_tab)\n",
                "        target_tab.make_active()\n",
                "\n",
                "    def _move_tab_to(self, tab: Optional[Tab] = None, target_os_window_id: Optional[int] = None) -> None:\n",
                "        tab = tab or self.active_tab\n",
                "        if tab is None:\n",
                "            return\n",
                "        if target_os_window_id is None:\n",
                "            target_os_window_id = self.add_os_window()\n",
                "        tm = self.os_window_map[target_os_window_id]\n",
                "        target_tab = tm.new_tab(empty_tab=True)\n",
                "        target_tab.take_over_from(tab)\n",
                "        self._cleanup_tab_after_window_removal(tab)\n",
                "        target_tab.make_active()\n",
                "\n",
                "    def choose_entry(\n",
                "        self, title: str, entries: Iterable[Tuple[Union[_T, str, None], str]],\n",
                "        callback: Callable[[Union[_T, str, None]], None],\n",
                "        subtitle: str = '',\n",
                "        hints_args: Optional[Tuple[str, ...]] = None,\n",
                "    ) -> Optional[Window]:\n",
                "        lines = [title, subtitle, ' '] if subtitle else [title, ' ']\n",
                "        idx_map: List[Union[_T, str, None]] = []\n",
                "        ans: Union[str, _T, None] = None\n",
                "        fmt = ': {1}'\n",
                "\n",
                "        for obj, text in entries:\n",
                "            idx_map.append(obj)\n",
                "            if obj is None:\n",
                "                lines.append(text)\n",
                "            else:\n",
                "                lines.append(fmt.format(len(idx_map), text))\n",
                "\n",
                "        def done(data: Dict[str, Any], target_window_id: int, self: Boss) -> None:\n",
                "            nonlocal ans\n",
                "            ans = idx_map[int(data['groupdicts'][0]['index'])]\n",
                "\n",
                "        def done2(target_window_id: int, self: Boss) -> None:\n",
                "            callback(ans)\n",
                "\n",
                "        q = self._run_kitten(\n",
                "            'hints', args=(\n",
                "                '--ascending', '--customize-processing=::import::kitty.choose_entry',\n",
                "                '--window-title', title,\n",
                "                *(hints_args or ())\n",
                "            ), input_data='\\r\\n'.join(lines).encode('utf-8'), custom_callback=done, action_on_removal=done2\n",
                "        )\n",
                "        return q if isinstance(q, Window) else None\n",
                "\n",
                "    @ac('tab', 'Interactively select a tab to switch to')\n",
                "    def select_tab(self) -> None:\n",
                "\n",
                "        def chosen(ans: Union[None, str, int]) -> None:\n",
                "            if isinstance(ans, int):\n",
                "                for tab in self.all_tabs:\n",
                "                    if tab.id == ans:\n",
                "                        self.set_active_tab(tab)\n",
                "\n",
                "        def format_tab_title(tab: Tab) -> str:\n",
                "            w = 'windows' if tab.num_window_groups > 1 else 'window'\n",
                "            return f'{tab.name or tab.title} [{tab.num_window_groups} {w}]'\n",
                "\n",
                "        ct = self.active_tab\n",
                "        self.choose_entry(\n",
                "            'Choose a tab to switch to',\n",
                "            ((None, f'Current tab: {format_tab_title(t)}') if t is ct else (t.id, format_tab_title(t)) for t in self.all_tabs),\n",
                "            chosen\n",
                "        )\n",
                "\n",
                "    @ac('win', '''\n",
                "        Detach a window, moving it to another tab or OS Window\n",
                "\n",
                "        See :ref:`detaching windows <detach_window>` for details.\n",
                "        ''')\n",
                "    def detach_window(self, *args: str) -> None:\n",
                "        if not args or args[0] == 'new':\n",
                "            return self._move_window_to(target_os_window_id='new')\n",
                "        if args[0] in ('new-tab', 'tab-prev', 'tab-left', 'tab-right'):\n",
                "            where = 'new' if args[0] == 'new-tab' else args[0][4:]\n",
                "            return self._move_window_to(target_tab_id=where)\n",
                "        ct = self.active_tab\n",
                "        items: List[Tuple[Union[str, int], str]] = [(t.id, t.title) for t in self.all_tabs if t is not ct]\n",
                "        items.append(('new_tab', 'New tab'))\n",
                "        items.append(('new_os_window', 'New OS Window'))\n",
                "        target_window = self.active_window\n",
                "\n",
                "        def chosen(ans: Union[None, str, int]) -> None:\n",
                "            if ans is not None:\n",
                "                if isinstance(ans, str):\n",
                "                    if ans == 'new_os_window':\n",
                "                        self._move_window_to(target_os_window_id='new')\n",
                "                    elif ans == 'new_tab':\n",
                "                        self._move_window_to(target_tab_id=ans)\n",
                "                else:\n",
                "                    self._move_window_to(target_window, target_tab_id=ans)\n",
                "\n",
                "        self.choose_entry('Choose a tab to move the window to', items, chosen)\n",
                "\n",
                "    @ac('tab', '''\n",
                "        Detach a tab, moving it to another OS Window\n",
                "\n",
                "        See :ref:`detaching windows <detach_window>` for details.\n",
                "        ''')\n",
                "    def detach_tab(self, *args: str) -> None:\n",
                "        if not args or args[0] == 'new':\n",
                "            return self._move_tab_to()\n",
                "\n",
                "        items: List[Tuple[Union[str, int], str]] = []\n",
                "        ct = self.active_tab_manager\n",
                "        for osw_id, tm in self.os_window_map.items():\n",
                "            if tm is not ct and tm.active_tab:\n",
                "                items.append((osw_id, tm.active_tab.title))\n",
                "        items.append(('new', 'New OS Window'))\n",
                "        target_tab = self.active_tab\n",
                "\n",
                "        def chosen(ans: Union[None, int, str]) -> None:\n",
                "            if ans is not None:\n",
                "                os_window_id = None if isinstance(ans, str) else ans\n",
                "                self._move_tab_to(tab=target_tab, target_os_window_id=os_window_id)\n",
                "\n",
                "        self.choose_entry('Choose an OS window to move the tab to', items, chosen)\n",
                "\n",
                "    def set_background_image(self, path: Optional[str], os_windows: Tuple[int, ...], configured: bool, layout: Optional[str]) -> None:\n",
                "        set_background_image(path, os_windows, configured, layout)\n",
                "        for os_window_id in os_windows:\n",
                "            self.default_bg_changed_for(os_window_id)\n",
                "\n",
                "    # Can be called with kitty -o \"map f1 send_test_notification\"\n",
                "    def send_test_notification(self) -> None:\n",
                "        from .notify import notify\n",
                "        now = monotonic()\n",
                "        ident = f'test-notify-{now}'\n",
                "        notify(f'Test {now}', f'At: {now}', identifier=ident, subtitle=f'Test subtitle {now}')\n",
                "\n",
                "    def notification_activated(self, identifier: str, window_id: int, focus: bool, report: bool) -> None:\n",
                "        w = self.window_id_map.get(window_id)\n",
                "        if w is None:\n",
                "            return\n",
                "        if focus:\n",
                "            self.set_active_window(w, switch_os_window_if_needed=True)\n",
                "        if report:\n",
                "            w.report_notification_activated(identifier)\n",
                "\n",
                "    @ac('debug', 'Show the environment variables that the kitty process sees')\n",
                "    def show_kitty_env_vars(self) -> None:\n",
                "        w = self.active_window\n",
                "        if w:\n",
                "            output = '\\n'.join(f'{k}={v}' for k, v in os.environ.items())\n",
                "            self.display_scrollback(w, output, title=_('Current kitty env vars'), report_cursor=False)\n",
                "\n",
                "    @ac('debug', 'Close all shared SSH connections')\n",
                "    def close_shared_ssh_connections(self) -> None:\n",
                "        cleanup_ssh_control_masters()\n",
                "\n",
                "    def launch_urls(self, *urls: str, no_replace_window: bool = False) -> None:\n",
                "        from .launch import force_window_launch\n",
                "        from .open_actions import actions_for_launch\n",
                "        actions: List[KeyAction] = []\n",
                "        failures = []\n",
                "        for url in urls:\n",
                "            uactions = tuple(actions_for_launch(url))\n",
                "            if uactions:\n",
                "                actions.extend(uactions)\n",
                "            else:\n",
                "                failures.append(url)\n",
                "        tab = self.active_tab\n",
                "        if tab is not None:\n",
                "            w = tab.active_window\n",
                "        else:\n",
                "            w = None\n",
                "        needs_window_replaced = False\n",
                "        if not no_replace_window and not get_options().startup_session:\n",
                "            if w is not None and w.id == 1 and monotonic() - w.started_at < 2 and len(tuple(self.all_windows)) == 1:\n",
                "                # first window, soon after startup replace it\n",
                "                needs_window_replaced = True\n",
                "\n",
                "        def clear_initial_window() -> None:\n",
                "            if needs_window_replaced and tab is not None and w is not None:\n",
                "                tab.remove_window(w)\n",
                "\n",
                "        if failures:\n",
                "            from kittens.tui.operations import styled\n",
                "            spec = '\\n  '.join(styled(u, fg='red') for u in failures)\n",
                "            bdata = f\"Unknown URL type, cannot open:\\n\\n  {spec}\".encode('utf-8')\n",
                "            special_window = SpecialWindow([kitty_exe(), '+kitten', 'show_error', '--title', 'Open URL Error'], bdata, 'Open URL Error')\n",
                "            if needs_window_replaced and tab is not None:\n",
                "                tab.new_special_window(special_window)\n",
                "            else:\n",
                "                self._new_os_window(special_window)\n",
                "            clear_initial_window()\n",
                "            needs_window_replaced = False\n",
                "        if actions:\n",
                "            with force_window_launch(needs_window_replaced):\n",
                "                self.dispatch_action(actions.pop(0))\n",
                "            clear_initial_window()\n",
                "            if actions:\n",
                "                self.drain_actions(actions)\n",
                "\n",
                "    @ac('debug', 'Show the effective configuration kitty is running with')\n",
                "    def debug_config(self) -> None:\n",
                "        from .debug_config import debug_config\n",
                "        w = self.active_window\n",
                "        if w is not None:\n",
                "            output = debug_config(get_options())\n",
                "            set_clipboard_string(re.sub(r'\\x1b.+?m', '', output))\n",
                "            output += '\\n\\x1b[35mThis debug output has been copied to the clipboard\\x1b[m'\n",
                "            self.display_scrollback(w, output, title=_('Current kitty options'), report_cursor=False)\n",
                "\n",
                "    @ac('misc', 'Discard this event completely ignoring it')\n",
                "    def discard_event(self) -> None:\n",
                "        pass\n",
                "    mouse_discard_event = discard_event"
            ]
        ],
        "kitty/launch.py": [
            [
                "#!/usr/bin/env python\n",
                "# License: GPLv3 Copyright: 2019, Kovid Goyal <kovid at kovidgoyal.net>\n",
                "\n",
                "\n",
                "import os\n",
                "from typing import Any, Dict, Iterable, List, NamedTuple, Optional, Sequence\n",
                "\n",
                "from .boss import Boss\n",
                "from .child import Child\n",
                "from .cli import parse_args\n",
                "from .cli_stub import LaunchCLIOptions\n",
                "from .constants import kitty_exe, shell_path\n",
                "from .fast_data_types import (\n",
                "    get_boss, get_options, get_os_window_title, patch_color_profiles,\n",
                "    set_clipboard_string\n",
                ")\n",
                "from .options.utils import env as parse_env\n",
                "from .tabs import Tab, TabManager\n",
                "from .types import run_once\n",
                "from .utils import log_error, resolve_custom_file, set_primary_selection, which\n",
                "from .window import CwdRequest, CwdRequestType, Watchers, Window\n",
                "\n",
                "try:\n",
                "    from typing import TypedDict\n",
                "except ImportError:\n",
                "    TypedDict = dict\n",
                "\n",
                "\n",
                "class LaunchSpec(NamedTuple):\n",
                "    opts: LaunchCLIOptions\n",
                "    args: List[str]\n",
                "\n",
                "\n",
                "@run_once\n",
                "def options_spec() -> str:\n",
                "    return '''\n",
                "--window-title --title\n",
                "The title to set for the new window. By default, title is controlled by the\n",
                "child process. The special value :code:`current` will copy the title from the currently\n",
                "active window.\n",
                "\n",
                "\n",
                "--tab-title\n",
                "The title for the new tab if launching in a new tab. By default, the title\n",
                "of the active window in the tab is used as the tab title. The special value\n",
                ":code:`current` will copy the title form the title of the currently active tab.\n",
                "\n",
                "\n",
                "--type\n",
                "type=choices\n",
                "default=window\n",
                "choices=window,tab,os-window,overlay,background,clipboard,primary\n",
                "Where to launch the child process, in a new kitty window in the current tab,\n",
                "a new tab, or a new OS window or an overlay over the current window.\n",
                "Note that if the current window already has an overlay, then it will\n",
                "open a new window. The value of background means the process will be\n",
                "run in the background. The values clipboard and primary are meant\n",
                "to work with :option:`launch --stdin-source` to copy data to the system\n",
                "clipboard or primary selection.\n",
                "\n",
                "\n",
                "--keep-focus --dont-take-focus\n",
                "type=bool-set\n",
                "Keep the focus on the currently active window instead of switching\n",
                "to the newly opened window.\n",
                "\n",
                "\n",
                "--cwd\n",
                "The working directory for the newly launched child. Use the special value\n",
                ":code:`current` to use the working directory of the currently active window.\n",
                "The special value :code:`last_reported` uses the last working directory\n",
                "reported by the shell (needs :ref:`shell_integration` to work). The special\n",
                "value :code:`oldest` works like :code:`current` but uses the working directory\n",
                "of the oldest foreground process associated with the currently active window\n",
                "rather than the newest foreground process.\n",
                "\n",
                "\n",
                "--env\n",
                "type=list\n",
                "Environment variables to set in the child process. Can be specified multiple\n",
                "times to set different environment variables.  Syntax: :code:`name=value`.\n",
                "Using :code:`name=` will set to empty string and just :code:`name` will\n",
                "remove the environment variable.\n",
                "\n",
                "\n",
                "--hold\n",
                "type=bool-set\n",
                "Keep the window open even after the command being executed exits.\n",
                "\n",
                "\n",
                "--copy-colors\n",
                "type=bool-set\n",
                "Set the colors of the newly created window to be the same as the colors in the\n",
                "currently active window.\n",
                "\n",
                "\n",
                "--copy-cmdline\n",
                "type=bool-set\n",
                "Ignore any specified command line and instead use the command line from the\n",
                "currently active window.\n",
                "\n",
                "\n",
                "--copy-env\n",
                "type=bool-set\n",
                "Copy the environment variables from the currently active window into the\n",
                "newly launched child process. Note that most shells only set environment\n",
                "variables for child processes, so this will only copy the environment\n",
                "variables that the shell process itself has not the environment variables\n",
                "child processes inside the shell see. To copy that enviroment, use the\n",
                "kitty remote control feature with :code:`kitty @launch --copy-env`.\n",
                "\n",
                "\n",
                "--location\n",
                "type=choices\n",
                "default=default\n",
                "choices=first,after,before,neighbor,last,vsplit,hsplit,split,default\n",
                "Where to place the newly created window when it is added to a tab which\n",
                "already has existing windows in it. :code:`after` and :code:`before` place the new\n",
                "window before or after the active window. :code:`neighbor` is a synonym for :code:`after`.\n",
                "Also applies to creating a new tab, where the value of :code:`after`\n",
                "will cause the new tab to be placed next to the current tab instead of at the end.\n",
                "The values of :code:`vsplit`, :code:`hsplit` and :code:`split` are only used by the\n",
                ":code:`splits` layout and control if the new window is placed in a vertical,\n",
                "horizontal or automatic split with the currently active window. The default is\n",
                "to place the window in a layout dependent manner, typically, after the\n",
                "currently active window.\n",
                "\n",
                "\n",
                "--allow-remote-control\n",
                "type=bool-set\n",
                "Programs running in this window can control kitty (if remote control is\n",
                "enabled). Note that any program with the right level of permissions can still\n",
                "write to the pipes of any other program on the same computer and therefore can\n",
                "control kitty. It can, however, be useful to block programs running on other\n",
                "computers (for example, over ssh) or as other users.\n",
                "\n",
                "\n",
                "--stdin-source\n",
                "type=choices\n",
                "default=none\n",
                "choices=none,@selection,@screen,@screen_scrollback,@alternate,@alternate_scrollback,@first_cmd_output_on_screen,@last_cmd_output,@last_visited_cmd_output\n",
                "Pass the screen contents as :code:`STDIN` to the child process. :code:`@selection` is\n",
                "the currently selected text. :code:`@screen` is the contents of the currently active\n",
                "window. :code:`@screen_scrollback` is the same as :code:`@screen`, but includes the\n",
                "scrollback buffer as well. :code:`@alternate` is the secondary screen of the current\n",
                "active window. For example if you run a full screen terminal application, the\n",
                "secondary screen will be the screen you return to when quitting the application.\n",
                ":code:`@first_cmd_output_on_screen` is the output from the first command run in the shell on screen,\n",
                ":code:`@last_cmd_output` is the output from the last command run in the shell,\n",
                ":code:`@last_visited_cmd_output` is the first output below the last scrolled position via\n",
                "scroll_to_prompt, this three needs :ref:`shell_integration` to work.\n",
                "\n",
                "\n",
                "--stdin-add-formatting\n",
                "type=bool-set\n",
                "When using :option:`launch --stdin-source` add formatting escape codes, without this\n",
                "only plain text will be sent.\n",
                "\n",
                "\n",
                "--stdin-add-line-wrap-markers\n",
                "type=bool-set\n",
                "When using :option:`launch --stdin-source` add a carriage return at every line wrap\n",
                "location (where long lines are wrapped at screen edges). This is useful if you\n",
                "want to pipe to program that wants to duplicate the screen layout of the\n",
                "screen.\n",
                "\n",
                "\n",
                "--marker\n",
                "Create a marker that highlights text in the newly created window. The syntax is\n",
                "the same as for the :code:`toggle_marker` map action (see :doc:`/marks`).\n",
                "\n",
                "\n",
                "--os-window-class\n",
                "Set the WM_CLASS property on X11 and the application id property on Wayland for\n",
                "the newly created OS Window when using :option:`launch --type`=os-window.\n",
                "Defaults to whatever is used by the parent kitty process, which in turn\n",
                "defaults to :code:`kitty`.\n",
                "\n",
                "\n",
                "--os-window-name\n",
                "Set the WM_NAME property on X11 for the newly created OS Window when using\n",
                ":option:`launch --type`=os-window. Defaults to :option:`launch --os-window-class`.\n",
                "\n",
                "\n",
                "--os-window-title\n",
                "Set the title for the newly created OS window. This title will override any\n",
                "titles set by programs running in kitty. The special value :code:`current`\n",
                "will use the title of the current OS Window, if any.\n",
                "\n",
                "\n",
                "--logo\n",
                "Path to a PNG image to use as the logo for the newly created window. See :opt:`window_logo_path`.\n",
                "\n",
                "\n",
                "--logo-position\n",
                "The position for the window logo. Only takes effect if :option:`--logo` is specified. See :opt:`window_logo_position`.\n",
                "\n",
                "\n",
                "--logo-alpha\n",
                "type=float\n",
                "default=-1\n",
                "The amount the window logo should be faded into the background.\n",
                "Only takes effect if :option:`--logo` is specified. See :opt:`window_logo_position`.\n",
                "\n",
                "\n",
                "--color\n",
                "type=list\n",
                "Change colors in the newly launched window. You can either specify a path to a .conf\n",
                "file with the same syntax as kitty.conf to read the colors from, or specify them\n",
                "individually, for example: ``--color background=white`` ``--color foreground=red``\n",
                "\n",
                "\n",
                "--watcher -w\n",
                "type=list\n",
                "Path to a python file. Appropriately named functions in this file will be called\n",
                "for various events, such as when the window is resized, focused or closed. See the section\n",
                "on watchers in the launch command documentation: :ref:`watchers`. Relative paths are\n",
                "resolved relative to the kitty config directory. Global watchers for all windows can be\n",
                "specified with :opt:`watcher`.\n",
                "'''\n",
                "\n",
                "\n",
                "def parse_launch_args(args: Optional[Sequence[str]] = None) -> LaunchSpec:\n",
                "    args = list(args or ())\n",
                "    try:\n",
                "        opts, args = parse_args(result_class=LaunchCLIOptions, args=args, ospec=options_spec)\n",
                "    except SystemExit as e:\n",
                "        raise ValueError from e\n",
                "    return LaunchSpec(opts, args)\n",
                "\n",
                "\n",
                "def get_env(opts: LaunchCLIOptions, active_child: Optional[Child] = None) -> Dict[str, str]:\n",
                "    env: Dict[str, str] = {}\n",
                "    if opts.copy_env and active_child:\n",
                "        env.update(active_child.foreground_environ)\n",
                "    for x in opts.env:\n",
                "        for k, v in parse_env(x, env):\n",
                "            env[k] = v\n",
                "    return env\n",
                "\n",
                "\n",
                "def tab_for_window(boss: Boss, opts: LaunchCLIOptions, target_tab: Optional[Tab] = None) -> Optional[Tab]:\n",
                "\n",
                "    def create_tab(tm: Optional[TabManager] = None) -> Tab:\n",
                "        if tm is None:\n",
                "            oswid = boss.add_os_window(wclass=opts.os_window_class, wname=opts.os_window_name, override_title=opts.os_window_title or None)\n",
                "            tm = boss.os_window_map[oswid]\n",
                "        tab = tm.new_tab(empty_tab=True, location=opts.location)\n",
                "        if opts.tab_title:\n",
                "            tab.set_title(opts.tab_title)\n",
                "        return tab\n",
                "\n",
                "    if opts.type == 'tab':\n",
                "        if target_tab is not None:\n",
                "            tm = target_tab.tab_manager_ref() or boss.active_tab_manager\n",
                "        else:\n",
                "            tm = boss.active_tab_manager\n",
                "        tab = create_tab(tm)\n",
                "    elif opts.type == 'os-window':\n",
                "        tab = create_tab()\n",
                "    else:\n",
                "        tab = target_tab or boss.active_tab or create_tab()\n",
                "\n",
                "    return tab\n",
                "\n",
                "\n",
                "watcher_modules: Dict[str, Any] = {}\n",
                "\n",
                "\n",
                "def load_watch_modules(watchers: Iterable[str]) -> Optional[Watchers]:\n",
                "    if not watchers:\n",
                "        return None\n",
                "    import runpy\n",
                "    ans = Watchers()\n",
                "    for path in watchers:\n",
                "        path = resolve_custom_file(path)\n",
                "        m = watcher_modules.get(path, None)\n",
                "        if m is None:\n",
                "            try:\n",
                "                m = runpy.run_path(path, run_name='__kitty_watcher__')\n",
                "            except Exception as err:\n",
                "                import traceback\n",
                "                log_error(traceback.format_exc())\n",
                "                log_error(f'Failed to load watcher from {path} with error: {err}')\n",
                "                watcher_modules[path] = False\n",
                "                continue\n",
                "            watcher_modules[path] = m\n",
                "        if m is False:\n",
                "            continue\n",
                "        w = m.get('on_close')\n",
                "        if callable(w):\n",
                "            ans.on_close.append(w)\n",
                "        w = m.get('on_resize')\n",
                "        if callable(w):\n",
                "            ans.on_resize.append(w)\n",
                "        w = m.get('on_focus_change')\n",
                "        if callable(w):\n",
                "            ans.on_focus_change.append(w)\n",
                "    return ans\n",
                "\n",
                "\n",
                "class LaunchKwds(TypedDict):\n",
                "\n",
                "    allow_remote_control: bool\n",
                "    cwd_from: Optional[CwdRequest]\n",
                "    cwd: Optional[str]\n",
                "    location: Optional[str]\n",
                "    override_title: Optional[str]\n",
                "    copy_colors_from: Optional[Window]\n",
                "    marker: Optional[str]\n",
                "    cmd: Optional[List[str]]\n",
                "    overlay_for: Optional[int]\n",
                "    stdin: Optional[bytes]\n",
                "\n",
                "\n",
                "def apply_colors(window: Window, spec: Sequence[str]) -> None:\n",
                "    from kitty.rc.set_colors import parse_colors\n",
                "    colors = parse_colors(spec)\n",
                "    profiles = window.screen.color_profile,\n",
                "    patch_color_profiles(colors, profiles, True)\n",
                "\n",
                "\n",
                "class ForceWindowLaunch:\n",
                "\n",
                "    def __init__(self) -> None:\n",
                "        self.force = False\n",
                "\n",
                "    def __bool__(self) -> bool:\n",
                "        return self.force\n",
                "\n",
                "    def __call__(self, force: bool) -> 'ForceWindowLaunch':\n",
                "        self.force = force\n",
                "        return self\n",
                "\n",
                "    def __enter__(self) -> None:\n",
                "        pass\n",
                "\n",
                "    def __exit__(self, *a: object) -> None:\n",
                "        self.force = False\n",
                "\n",
                "\n",
                "force_window_launch = ForceWindowLaunch()\n",
                "non_window_launch_types = 'background', 'clipboard', 'primary'\n",
                "\n",
                "\n",
                "def launch(\n",
                "    boss: Boss,\n",
                "    opts: LaunchCLIOptions,\n",
                "    args: List[str],\n",
                "    target_tab: Optional[Tab] = None,\n",
                "    force_target_tab: bool = False,\n",
                "    active: Optional[Window] = None,\n",
                "    is_clone_launch: str = '',\n",
                ") -> Optional[Window]:\n",
                "    active = active or boss.active_window_for_cwd\n",
                "    if active:\n",
                "        active_child = active.child\n",
                "    else:\n",
                "        active_child = None\n",
                "    if opts.window_title == 'current':\n",
                "        opts.window_title = active.title if active else None\n",
                "    if opts.tab_title == 'current':\n",
                "        atab = boss.active_tab\n",
                "        opts.tab_title = atab.effective_title if atab else None\n",
                "    if opts.os_window_title == 'current':\n",
                "        tm = boss.active_tab_manager\n",
                "        opts.os_window_title = get_os_window_title(tm.os_window_id) if tm else None\n",
                "    env = get_env(opts, active_child)\n",
                "    kw: LaunchKwds = {\n",
                "        'allow_remote_control': opts.allow_remote_control,\n",
                "        'cwd_from': None,\n",
                "        'cwd': None,\n",
                "        'location': None,\n",
                "        'override_title': opts.window_title or None,\n",
                "        'copy_colors_from': None,\n",
                "        'marker': opts.marker or None,\n",
                "        'cmd': None,\n",
                "        'overlay_for': None,\n",
                "        'stdin': None\n",
                "    }\n",
                "    if opts.cwd:\n",
                "        if opts.cwd == 'current':\n",
                "            if active:\n",
                "                kw['cwd_from'] = CwdRequest(active)\n",
                "        elif opts.cwd == 'last_reported':\n",
                "            if active:\n",
                "                kw['cwd_from'] = CwdRequest(active, CwdRequestType.last_reported)\n",
                "        elif opts.cwd == 'oldest':\n",
                "            if active:\n",
                "                kw['cwd_from'] = CwdRequest(active, CwdRequestType.last_reported)\n",
                "        else:\n",
                "            kw['cwd'] = opts.cwd\n",
                "    if opts.location != 'default':\n",
                "        kw['location'] = opts.location\n",
                "    if opts.copy_colors and active:\n",
                "        kw['copy_colors_from'] = active\n",
                "    pipe_data: Dict[str, Any] = {}\n",
                "    if opts.stdin_source != 'none':\n",
                "        q = str(opts.stdin_source)\n",
                "        if opts.stdin_add_formatting:\n",
                "            if q in ('@screen', '@screen_scrollback', '@alternate', '@alternate_scrollback',\n",
                "                     '@first_cmd_output_on_screen', '@last_cmd_output', '@last_visited_cmd_output'):\n",
                "                q = f'@ansi_{q[1:]}'\n",
                "        if opts.stdin_add_line_wrap_markers:\n",
                "            q += '_wrap'\n",
                "        penv, stdin = boss.process_stdin_source(window=active, stdin=q, copy_pipe_data=pipe_data)\n",
                "        if stdin:\n",
                "            kw['stdin'] = stdin\n",
                "            if penv:\n",
                "                env.update(penv)\n",
                "\n",
                "    cmd = args or None\n",
                "    if opts.copy_cmdline and active_child:\n",
                "        cmd = active_child.foreground_cmdline\n",
                "    if cmd:\n",
                "        final_cmd: List[str] = []\n",
                "        for x in cmd:\n",
                "            if active and not opts.copy_cmdline:\n",
                "                if x == '@selection':\n",
                "                    s = boss.data_for_at(which=x, window=active)\n",
                "                    if s:\n",
                "                        x = s\n",
                "                elif x == '@active-kitty-window-id':\n",
                "                    x = str(active.id)\n",
                "                elif x == '@input-line-number':\n",
                "                    if 'input_line_number' in pipe_data:\n",
                "                        x = str(pipe_data['input_line_number'])\n",
                "                elif x == '@line-count':\n",
                "                    if 'lines' in pipe_data:\n",
                "                        x = str(pipe_data['lines'])\n",
                "                elif x in ('@cursor-x', '@cursor-y', '@scrolled-by', '@first-line-on-screen', '@last-line-on-screen'):\n",
                "                    if active is not None:\n",
                "                        screen = active.screen\n",
                "                        if x == '@scrolled-by':\n",
                "                            x = str(screen.scrolled_by)\n",
                "                        elif x == '@cursor-x':\n",
                "                            x = str(screen.cursor.x + 1)\n",
                "                        elif x == '@cursor-y':\n",
                "                            x = str(screen.cursor.y + 1)\n",
                "                        elif x == '@first-line-on-screen':\n",
                "                            x = str(screen.visual_line(0) or '')\n",
                "                        elif x == '@last-line-on-screen':\n",
                "                            x = str(screen.visual_line(screen.lines - 1) or '')\n",
                "            final_cmd.append(x)\n",
                "        exe = which(final_cmd[0])\n",
                "        if exe:\n",
                "            final_cmd[0] = exe\n",
                "        kw['cmd'] = final_cmd\n",
                "    if force_window_launch and opts.type not in non_window_launch_types:\n",
                "        opts.type = 'window'\n",
                "    if opts.type == 'overlay' and active:\n",
                "        kw['overlay_for'] = active.id\n",
                "    if opts.type == 'background':\n",
                "        cmd = kw['cmd']\n",
                "        if not cmd:\n",
                "            raise ValueError('The cmd to run must be specified when running a background process')\n",
                "        boss.run_background_process(cmd, cwd=kw['cwd'], cwd_from=kw['cwd_from'], env=env or None, stdin=kw['stdin'])\n",
                "    elif opts.type in ('clipboard', 'primary'):\n",
                "        stdin = kw.get('stdin')\n",
                "        if stdin is not None:\n",
                "            if opts.type == 'clipboard':\n",
                "                set_clipboard_string(stdin)\n",
                "            else:\n",
                "                set_primary_selection(stdin)\n",
                "    else:\n",
                "        if opts.hold:\n",
                "            cmd = kw['cmd'] or [shell_path]\n",
                "            kw['cmd'] = [kitty_exe(), '+hold'] + cmd\n",
                "        if force_target_tab:\n",
                "            tab = target_tab\n",
                "        else:\n",
                "            tab = tab_for_window(boss, opts, target_tab)\n",
                "        if tab is not None:\n",
                "            watchers = load_watch_modules(opts.watcher)\n",
                "            new_window: Window = tab.new_window(env=env or None, watchers=watchers or None, is_clone_launch=is_clone_launch, **kw)\n",
                "            if opts.color:\n",
                "                apply_colors(new_window, opts.color)\n",
                "            if opts.keep_focus and active:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                boss.set_active_window(active, switch_os_window_if_needed=True)\n"
                ],
                "after": [
                    "                boss.set_active_window(active, switch_os_window_if_needed=True, for_keep_focus=True)\n"
                ],
                "parent_version_range": {
                    "start": 478,
                    "end": 479
                },
                "child_version_range": {
                    "start": 478,
                    "end": 479
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if opts.type == 'background':",
                        "start_line": 452,
                        "end_line": 481
                    },
                    {
                        "type": "else_clause",
                        "statement": "else:",
                        "start_line": 464,
                        "end_line": 481
                    },
                    {
                        "type": "if_statement",
                        "statement": "if tab is not None:",
                        "start_line": 472,
                        "end_line": 481
                    },
                    {
                        "type": "if_statement",
                        "statement": "if opts.keep_focus and active:",
                        "start_line": 477,
                        "end_line": 478
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "launch",
                        "signature": "def launch(\n    boss: Boss,\n    opts: LaunchCLIOptions,\n    args: List[str],\n    target_tab: Optional[Tab] = None,\n    force_target_tab: bool = False,\n    active: Optional[Window] = None,\n    is_clone_launch: str = '',\n)->Optional[Window]:",
                        "at_line": 345
                    },
                    {
                        "type": "call",
                        "name": "boss.set_active_window",
                        "signature": "boss.set_active_window(active, switch_os_window_if_needed=True)",
                        "at_line": 478,
                        "argument": "active"
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: kitty/launch.py\nCode:\n           def launch(\n    boss: Boss,\n    opts: LaunchCLIOptions,\n    args: List[str],\n    target_tab: Optional[Tab] = None,\n    force_target_tab: bool = False,\n    active: Optional[Window] = None,\n    is_clone_launch: str = '',\n)->Optional[Window]:\n               ...\n475 475                if opts.color:\n476 476                    apply_colors(new_window, opts.color)\n477 477                if opts.keep_focus and active:\n478      -                 boss.set_active_window(active, switch_os_window_if_needed=True)\n    478  +                 boss.set_active_window(active, switch_os_window_if_needed=True, for_keep_focus=True)\n479 479                if opts.logo:\n480 480                    new_window.set_logo(opts.logo, opts.logo_position or '', opts.logo_alpha)\n481 481                return new_window\n         ...\n",
                "file_path": "kitty/launch.py",
                "identifiers_before": [
                    "active",
                    "boss",
                    "set_active_window",
                    "switch_os_window_if_needed"
                ],
                "identifiers_after": [
                    "active",
                    "boss",
                    "for_keep_focus",
                    "set_active_window",
                    "switch_os_window_if_needed"
                ],
                "prefix": [
                    "            if opts.color:\n",
                    "                apply_colors(new_window, opts.color)\n",
                    "            if opts.keep_focus and active:\n"
                ],
                "suffix": [
                    "            if opts.logo:\n",
                    "                new_window.set_logo(opts.logo, opts.logo_position or '', opts.logo_alpha)\n",
                    "            return new_window\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "set_active_window",
                            "position": {
                                "start": {
                                    "line": 478,
                                    "column": 21
                                },
                                "end": {
                                    "line": 478,
                                    "column": 38
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/launch.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "switch_os_window_if_needed",
                            "position": {
                                "start": {
                                    "line": 478,
                                    "column": 47
                                },
                                "end": {
                                    "line": 478,
                                    "column": 73
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/launch.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "set_active_window",
                            "position": {
                                "start": {
                                    "line": 478,
                                    "column": 21
                                },
                                "end": {
                                    "line": 478,
                                    "column": 38
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/launch.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "switch_os_window_if_needed",
                            "position": {
                                "start": {
                                    "line": 478,
                                    "column": 47
                                },
                                "end": {
                                    "line": 478,
                                    "column": 73
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/launch.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 478,
                                    "column": 80
                                },
                                "end": {
                                    "line": 478,
                                    "column": 94
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/launch.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "            if opts.logo:\n",
                "                new_window.set_logo(opts.logo, opts.logo_position or '', opts.logo_alpha)\n",
                "            return new_window\n",
                "    return None\n",
                "\n",
                "\n",
                "def parse_opts_for_clone(args: List[str]) -> LaunchCLIOptions:\n",
                "    unsafe, unsafe_args = parse_launch_args(args)\n",
                "    default_opts, default_args = parse_launch_args()\n",
                "    # only copy safe options, those that dont lead to local code exec\n",
                "    for x in (\n",
                "        'window_title', 'tab_title', 'type', 'keep_focus', 'cwd', 'env', 'hold',\n",
                "        'location', 'os_window_class', 'os_window_name', 'os_window_title',\n",
                "        'logo', 'logo_position', 'logo_alpha', 'color'\n",
                "    ):\n",
                "        setattr(default_opts, x, getattr(unsafe, x))\n",
                "    return default_opts\n",
                "\n",
                "\n",
                "def parse_bash_env(text: str) -> Dict[str, str]:\n",
                "    # See https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n",
                "    ans = {}\n",
                "    pos = 0\n",
                "    escapes = r'\"\\$`'\n",
                "    while pos < len(text):\n",
                "        idx = text.find('=\"', pos)\n",
                "        if idx < 0:\n",
                "            break\n",
                "        i = text.rfind(' ', 0, idx)\n",
                "        if i < 0:\n",
                "            break\n",
                "        key = text[i+1:idx]\n",
                "        pos = idx + 2\n",
                "        buf: List[str] = []\n",
                "        a = buf.append\n",
                "        while pos < len(text):\n",
                "            ch = text[pos]\n",
                "            pos += 1\n",
                "            if ch == '\\\\':\n",
                "                if text[pos] in escapes:\n",
                "                    a(text[pos])\n",
                "                    pos += 1\n",
                "                    continue\n",
                "                a(ch)\n",
                "            elif ch == '\"':\n",
                "                break\n",
                "            else:\n",
                "                a(ch)\n",
                "        ans[key] = ''.join(buf)\n",
                "    return ans\n",
                "\n",
                "\n",
                "def parse_null_env(text: str) -> Dict[str, str]:\n",
                "    ans = {}\n",
                "    for line in text.split('\\0'):\n",
                "        if line:\n",
                "            try:\n",
                "                k, v = line.split('=', 1)\n",
                "            except ValueError:\n",
                "                continue\n",
                "            ans[k] = v\n",
                "    return ans\n",
                "\n",
                "\n",
                "class CloneCmd:\n",
                "\n",
                "    def __init__(self, msg: str) -> None:\n",
                "        self.args: List[str] = []\n",
                "        self.env: Optional[Dict[str, str]] = None\n",
                "        self.cwd = ''\n",
                "        self.shell = ''\n",
                "        self.envfmt = 'default'\n",
                "        self.pid = -1\n",
                "        self.parse_message(msg)\n",
                "        self.opts = parse_opts_for_clone(self.args)\n",
                "\n",
                "    def parse_message(self, msg: str) -> None:\n",
                "        import base64\n",
                "        simple = 'pid', 'envfmt', 'shell'\n",
                "        for x in msg.split(','):\n",
                "            k, v = x.split('=', 1)\n",
                "            if k in simple:\n",
                "                setattr(self, k, int(v) if k == 'pid' else v)\n",
                "                continue\n",
                "            v = base64.standard_b64decode(v).decode('utf-8', 'replace')\n",
                "            if k == 'a':\n",
                "                self.args.append(v)\n",
                "            elif k == 'env':\n",
                "                env = parse_bash_env(v) if self.envfmt == 'bash' else parse_null_env(v)\n",
                "                self.env = {k: v for k, v in env.items() if k not in {\n",
                "                    'HOME', 'LOGNAME', 'USER', 'PWD',\n",
                "                    # some people export these. We want the shell rc files to recreate them\n",
                "                    'PS0', 'PS1', 'PS2', 'PS3', 'PS4', 'RPS1', 'PROMPT_COMMAND', 'SHLVL',\n",
                "                    # conda state env vars\n",
                "                    'CONDA_SHLVL', 'CONDA_PREFIX', 'CONDA_PROMPT_MODIFIER', 'CONDA_EXE', 'CONDA_PYTHON_EXE', '_CE_CONDA', '_CE_M',\n",
                "                    # skip SSH environment variables\n",
                "                    'SSH_CLIENT', 'SSH_CONNECTION', 'SSH_ORIGINAL_COMMAND', 'SSH_TTY', 'SSH2_TTY',\n",
                "                } and not k.startswith((\n",
                "                    # conda state env vars for multi-level virtual environments\n",
                "                    'CONDA_PREFIX_',\n",
                "                ))}\n",
                "            elif k == 'cwd':\n",
                "                self.cwd = v\n",
                "\n",
                "\n",
                "def clone_and_launch(msg: str, window: Window) -> None:\n",
                "    from .child import cmdline_of_process\n",
                "    from .shell_integration import serialize_env\n",
                "    c = CloneCmd(msg)\n",
                "    if c.cwd and not c.opts.cwd:\n",
                "        c.opts.cwd = c.cwd\n",
                "    c.opts.copy_colors = True\n",
                "    c.opts.copy_env = False\n",
                "    if c.opts.type in non_window_launch_types:\n",
                "        c.opts.type = 'window'\n",
                "    if c.env and c.env.get('PATH') and c.env.get('VIRTUAL_ENV'):\n",
                "        # only pass VIRTUAL_ENV if it is currently active\n",
                "        if f\"{c.env['VIRTUAL_ENV']}/bin\" not in c.env['PATH'].split(os.pathsep):\n",
                "            del c.env['VIRTUAL_ENV']\n",
                "    is_clone_launch = serialize_env(c.shell, c.env or {})\n",
                "    ssh_kitten_cmdline = window.ssh_kitten_cmdline()\n",
                "    if ssh_kitten_cmdline:\n",
                "        from kittens.ssh.main import (\n",
                "            patch_cmdline, set_cwd_in_cmdline, set_env_in_cmdline\n",
                "        )\n",
                "        cmdline = ssh_kitten_cmdline\n",
                "        if c.opts.cwd:\n",
                "            set_cwd_in_cmdline(c.opts.cwd, cmdline)\n",
                "            c.opts.cwd = None\n",
                "        if c.env:\n",
                "            set_env_in_cmdline({\n",
                "                'KITTY_IS_CLONE_LAUNCH': is_clone_launch,\n",
                "                'KITTY_CLONE_SOURCE_STRATEGIES': ',' + ','.join(get_options().clone_source_strategies) + ','\n",
                "            }, cmdline)\n",
                "            c.env = None\n",
                "        if c.opts.env:\n",
                "            for entry in reversed(c.opts.env):\n",
                "                patch_cmdline('env', entry, cmdline)\n",
                "            c.opts.env = []\n",
                "    else:\n",
                "        try:\n",
                "            cmdline = cmdline_of_process(c.pid)\n",
                "        except Exception:\n",
                "            cmdline = []\n",
                "        if not cmdline:\n",
                "            cmdline = list(window.child.argv)\n",
                "        if cmdline and cmdline[0] == window.child.final_argv0:\n",
                "            cmdline[0] = window.child.final_exe\n",
                "        if cmdline and cmdline == [window.child.final_exe] + window.child.argv[1:]:\n",
                "            cmdline = window.child.unmodified_argv\n",
                "    launch(get_boss(), c.opts, cmdline, active=window, is_clone_launch=is_clone_launch)"
            ]
        ],
        "kitty/tabs.py": [
            [
                "#!/usr/bin/env python3\n",
                "# License: GPL v3 Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n",
                "\n",
                "import os\n",
                "import re\n",
                "import stat\n",
                "import weakref\n",
                "from collections import deque\n",
                "from contextlib import suppress\n",
                "from operator import attrgetter\n",
                "from time import monotonic\n",
                "from typing import (\n",
                "    Any, Deque, Dict, Generator, Iterable, Iterator, List, NamedTuple,\n",
                "    Optional, Sequence, Set, Tuple, Union\n",
                ")\n",
                "\n",
                "from .borders import Border, Borders\n",
                "from .child import Child\n",
                "from .cli_stub import CLIOptions\n",
                "from .constants import appname, kitty_exe\n",
                "from .fast_data_types import (\n",
                "    GLFW_MOUSE_BUTTON_LEFT, GLFW_MOUSE_BUTTON_MIDDLE, GLFW_PRESS, GLFW_RELEASE,\n",
                "    add_tab, attach_window, current_os_window, detach_window, get_boss,\n",
                "    get_click_interval, get_options, mark_tab_bar_dirty, next_window_id,\n",
                "    remove_tab, remove_window, ring_bell, set_active_tab, set_active_window,\n",
                "    swap_tabs, sync_os_window_title\n",
                ")\n",
                "from .layout.base import Layout\n",
                "from .layout.interface import create_layout_object_for, evict_cached_layouts\n",
                "from .tab_bar import TabBar, TabBarData\n",
                "from .types import ac\n",
                "from .typing import EdgeLiteral, SessionTab, SessionType, TypedDict\n",
                "from .utils import log_error, platform_window_id, resolved_shell\n",
                "from .window import CwdRequest, Watchers, Window, WindowDict\n",
                "from .window_list import WindowList\n",
                "\n",
                "\n",
                "class TabMouseEvent(NamedTuple):\n",
                "    button: int\n",
                "    modifiers: int\n",
                "    action: int\n",
                "    at: float\n",
                "    tab_idx: Optional[int]\n",
                "\n",
                "\n",
                "class TabDict(TypedDict):\n",
                "    id: int\n",
                "    is_focused: bool\n",
                "    title: str\n",
                "    layout: str\n",
                "    layout_state: Dict[str, Any]\n",
                "    layout_opts: Dict[str, Any]\n",
                "    enabled_layouts: List[str]\n",
                "    windows: List[WindowDict]\n",
                "    active_window_history: List[int]\n",
                "\n",
                "\n",
                "class SpecialWindowInstance(NamedTuple):\n",
                "    cmd: Optional[List[str]]\n",
                "    stdin: Optional[bytes]\n",
                "    override_title: Optional[str]\n",
                "    cwd_from: Optional[CwdRequest]\n",
                "    cwd: Optional[str]\n",
                "    overlay_for: Optional[int]\n",
                "    env: Optional[Dict[str, str]]\n",
                "    watchers: Optional[Watchers]\n",
                "    overlay_behind: bool\n",
                "\n",
                "\n",
                "def SpecialWindow(\n",
                "    cmd: Optional[List[str]],\n",
                "    stdin: Optional[bytes] = None,\n",
                "    override_title: Optional[str] = None,\n",
                "    cwd_from: Optional[CwdRequest] = None,\n",
                "    cwd: Optional[str] = None,\n",
                "    overlay_for: Optional[int] = None,\n",
                "    env: Optional[Dict[str, str]] = None,\n",
                "    watchers: Optional[Watchers] = None,\n",
                "    overlay_behind: bool = False\n",
                ") -> SpecialWindowInstance:\n",
                "    return SpecialWindowInstance(cmd, stdin, override_title, cwd_from, cwd, overlay_for, env, watchers, overlay_behind)\n",
                "\n",
                "\n",
                "def add_active_id_to_history(items: Deque[int], item_id: int, maxlen: int = 64) -> None:\n",
                "    with suppress(ValueError):\n",
                "        items.remove(item_id)\n",
                "    items.append(item_id)\n",
                "    if len(items) > maxlen:\n",
                "        items.popleft()\n",
                "\n",
                "\n",
                "class Tab:  # {{{\n",
                "\n",
                "    active_fg: Optional[int] = None\n",
                "    active_bg: Optional[int] = None\n",
                "    inactive_fg: Optional[int] = None\n",
                "    inactive_bg: Optional[int] = None\n",
                "\n",
                "    def __init__(\n",
                "        self,\n",
                "        tab_manager: 'TabManager',\n",
                "        session_tab: Optional['SessionTab'] = None,\n",
                "        special_window: Optional[SpecialWindowInstance] = None,\n",
                "        cwd_from: Optional[CwdRequest] = None,\n",
                "        no_initial_window: bool = False\n",
                "    ):\n",
                "        self.tab_manager_ref = weakref.ref(tab_manager)\n",
                "        self.os_window_id: int = tab_manager.os_window_id\n",
                "        self.id: int = add_tab(self.os_window_id)\n",
                "        if not self.id:\n",
                "            raise Exception(f'No OS window with id {self.os_window_id} found, or tab counter has wrapped')\n",
                "        self.args = tab_manager.args\n",
                "        self.name = getattr(session_tab, 'name', '')\n",
                "        self.enabled_layouts = [x.lower() for x in getattr(session_tab, 'enabled_layouts', None) or get_options().enabled_layouts]\n",
                "        self.borders = Borders(self.os_window_id, self.id)\n",
                "        self.windows = WindowList(self)\n",
                "        self._last_used_layout: Optional[str] = None\n",
                "        self._current_layout_name: Optional[str] = None\n",
                "        self.cwd = self.args.directory\n",
                "        if no_initial_window:\n",
                "            self._set_current_layout(self.enabled_layouts[0])\n",
                "        elif session_tab is None:\n",
                "            sl = self.enabled_layouts[0]\n",
                "            self._set_current_layout(sl)\n",
                "            if special_window is None:\n",
                "                self.new_window(cwd_from=cwd_from)\n",
                "            else:\n",
                "                self.new_special_window(special_window)\n",
                "        else:\n",
                "            if session_tab.cwd:\n",
                "                self.cwd = session_tab.cwd\n",
                "            l0 = session_tab.layout\n",
                "            self._set_current_layout(l0)\n",
                "            self.startup(session_tab)\n",
                "\n",
                "    def set_enabled_layouts(self, val: Iterable[str]) -> None:\n",
                "        self.enabled_layouts = [x.lower() for x in val] or ['tall']\n",
                "        if self.current_layout.name not in self.enabled_layouts:\n",
                "            self._set_current_layout(self.enabled_layouts[0])\n",
                "        self.relayout()\n",
                "\n",
                "    def apply_options(self) -> None:\n",
                "        for window in self:\n",
                "            window.apply_options()\n",
                "        self.set_enabled_layouts(get_options().enabled_layouts)\n",
                "\n",
                "    def take_over_from(self, other_tab: 'Tab') -> None:\n",
                "        self.name, self.cwd = other_tab.name, other_tab.cwd\n",
                "        self.enabled_layouts = list(other_tab.enabled_layouts)\n",
                "        if other_tab._current_layout_name:\n",
                "            self._set_current_layout(other_tab._current_layout_name)\n",
                "        self._last_used_layout = other_tab._last_used_layout\n",
                "        for window in other_tab.windows:\n",
                "            detach_window(other_tab.os_window_id, other_tab.id, window.id)\n",
                "        self.windows = other_tab.windows\n",
                "        self.windows.change_tab(self)\n",
                "        other_tab.windows = WindowList(other_tab)\n",
                "        for window in self.windows:\n",
                "            window.change_tab(self)\n",
                "            attach_window(self.os_window_id, self.id, window.id)\n",
                "        self.active_window_changed()\n",
                "        self.relayout()\n",
                "\n",
                "    def _set_current_layout(self, layout_name: str) -> None:\n",
                "        self._last_used_layout = self._current_layout_name\n",
                "        self.current_layout = self.create_layout_object(layout_name)\n",
                "        self._current_layout_name = layout_name\n",
                "        self.mark_tab_bar_dirty()\n",
                "\n",
                "    def startup(self, session_tab: 'SessionTab') -> None:\n",
                "        for cmd in session_tab.windows:\n",
                "            if isinstance(cmd, SpecialWindowInstance):\n",
                "                self.new_special_window(cmd)\n",
                "            else:\n",
                "                from .launch import launch\n",
                "                launch(get_boss(), cmd.opts, cmd.args, target_tab=self, force_target_tab=True)\n",
                "        self.windows.set_active_window_group_for(self.windows.all_windows[session_tab.active_window_idx])\n",
                "\n",
                "    def serialize_state(self) -> Dict[str, Any]:\n",
                "        return {\n",
                "            'version': 1,\n",
                "            'id': self.id,\n",
                "            'window_list': self.windows.serialize_state(),\n",
                "            'current_layout': self._current_layout_name,\n",
                "            'last_used_layout': self._last_used_layout,\n",
                "            'layout_opts': self.current_layout.layout_opts,\n",
                "            'layout_state': self.current_layout.layout_state,\n",
                "            'enabled_layouts': self.enabled_layouts,\n",
                "            'name': self.name,\n",
                "        }\n",
                "\n",
                "    def active_window_changed(self) -> None:\n",
                "        w = self.active_window\n",
                "        set_active_window(self.os_window_id, self.id, 0 if w is None else w.id)\n",
                "        self.mark_tab_bar_dirty()\n",
                "        self.relayout_borders()\n",
                "        self.current_layout.update_visibility(self.windows)\n",
                "\n",
                "    def mark_tab_bar_dirty(self) -> None:\n",
                "        tm = self.tab_manager_ref()\n",
                "        if tm is not None:\n",
                "            tm.mark_tab_bar_dirty()\n",
                "\n",
                "    @property\n",
                "    def active_window(self) -> Optional[Window]:\n",
                "        return self.windows.active_window\n",
                "\n",
                "    @property\n",
                "    def active_window_for_cwd(self) -> Optional[Window]:\n",
                "        return self.windows.active_group_base\n",
                "\n",
                "    @property\n",
                "    def title(self) -> str:\n",
                "        w = self.active_window\n",
                "        return w.title if w else appname\n",
                "\n",
                "    @property\n",
                "    def effective_title(self) -> str:\n",
                "        return self.name or self.title\n",
                "\n",
                "    @property\n",
                "    def number_of_windows_with_running_programs(self) -> int:\n",
                "        ans = 0\n",
                "        for window in self:\n",
                "            if window.has_running_program:\n",
                "                ans += 1\n",
                "        return ans\n",
                "\n",
                "    def set_title(self, title: str) -> None:\n",
                "        self.name = title or ''\n",
                "        self.mark_tab_bar_dirty()\n",
                "\n",
                "    def title_changed(self, window: Window) -> None:\n",
                "        if window is self.active_window:\n",
                "            tm = self.tab_manager_ref()\n",
                "            if tm is not None:\n",
                "                tm.title_changed(self)\n",
                "\n",
                "    def on_bell(self, window: Window) -> None:\n",
                "        self.mark_tab_bar_dirty()\n",
                "\n",
                "    def relayout(self) -> None:\n",
                "        if self.windows:\n",
                "            self.current_layout(self.windows)\n",
                "        self.relayout_borders()\n",
                "\n",
                "    def relayout_borders(self) -> None:\n",
                "        tm = self.tab_manager_ref()\n",
                "        if tm is not None:\n",
                "            w = self.active_window\n",
                "            ly = self.current_layout\n",
                "            self.borders(\n",
                "                all_windows=self.windows,\n",
                "                current_layout=ly, tab_bar_rects=tm.tab_bar_rects,\n",
                "                draw_window_borders=(ly.needs_window_borders and self.windows.num_visble_groups > 1) or ly.must_draw_borders\n",
                "            )\n",
                "            if w is not None:\n",
                "                w.change_titlebar_color()\n",
                "\n",
                "    def create_layout_object(self, name: str) -> Layout:\n",
                "        return create_layout_object_for(name, self.os_window_id, self.id)\n",
                "\n",
                "    @ac('lay', 'Go to the next enabled layout')\n",
                "    def next_layout(self) -> None:\n",
                "        if len(self.enabled_layouts) > 1:\n",
                "            for i, layout_name in enumerate(self.enabled_layouts):\n",
                "                if layout_name == self.current_layout.full_name:\n",
                "                    idx = i\n",
                "                    break\n",
                "            else:\n",
                "                idx = -1\n",
                "            nl = self.enabled_layouts[(idx + 1) % len(self.enabled_layouts)]\n",
                "            self._set_current_layout(nl)\n",
                "            self.relayout()\n",
                "\n",
                "    @ac('lay', 'Go to the previously used layout')\n",
                "    def last_used_layout(self) -> None:\n",
                "        if len(self.enabled_layouts) > 1 and self._last_used_layout and self._last_used_layout != self._current_layout_name:\n",
                "            self._set_current_layout(self._last_used_layout)\n",
                "            self.relayout()\n",
                "\n",
                "    @ac('lay', '''\n",
                "        Switch to the named layout\n",
                "\n",
                "        For example::\n",
                "\n",
                "            map f1 goto_layout tall\n",
                "        ''')\n",
                "    def goto_layout(self, layout_name: str, raise_exception: bool = False) -> None:\n",
                "        layout_name = layout_name.lower()\n",
                "        if layout_name not in self.enabled_layouts:\n",
                "            if raise_exception:\n",
                "                raise ValueError(layout_name)\n",
                "            log_error(f'Unknown or disabled layout: {layout_name}')\n",
                "            return\n",
                "        self._set_current_layout(layout_name)\n",
                "        self.relayout()\n",
                "\n",
                "    @ac('lay', '''\n",
                "        Toggle the named layout\n",
                "\n",
                "        Switches to the named layout if another layout is current, otherwise\n",
                "        switches to the last used layout. Useful to \"zoom\" a window temporarily\n",
                "        by switching to the stack layout. For example::\n",
                "\n",
                "            map f1 toggle_layout stack\n",
                "        ''')\n",
                "    def toggle_layout(self, layout_name: str) -> None:\n",
                "        if self._current_layout_name == layout_name:\n",
                "            self.last_used_layout()\n",
                "        else:\n",
                "            self.goto_layout(layout_name)\n",
                "\n",
                "    def resize_window_by(self, window_id: int, increment: float, is_horizontal: bool) -> Optional[str]:\n",
                "        increment_as_percent = self.current_layout.bias_increment_for_cell(self.windows, window_id, is_horizontal) * increment\n",
                "        if self.current_layout.modify_size_of_window(self.windows, window_id, increment_as_percent, is_horizontal):\n",
                "            self.relayout()\n",
                "            return None\n",
                "        return 'Could not resize'\n",
                "\n",
                "    @ac('win', '''\n",
                "        Resize the active window by the specified amount\n",
                "\n",
                "        See :ref:`window_resizing` for details.\n",
                "        ''')\n",
                "    def resize_window(self, quality: str, increment: int) -> None:\n",
                "        if quality == 'reset':\n",
                "            self.reset_window_sizes()\n",
                "            return\n",
                "        if increment < 1:\n",
                "            raise ValueError(increment)\n",
                "        is_horizontal = quality in ('wider', 'narrower')\n",
                "        increment *= 1 if quality in ('wider', 'taller') else -1\n",
                "        w = self.active_window\n",
                "        if w is not None and self.resize_window_by(\n",
                "                w.id, increment, is_horizontal) is not None:\n",
                "            if get_options().enable_audio_bell:\n",
                "                ring_bell()\n",
                "\n",
                "    @ac('win', 'Reset window sizes undoing any dynamic resizing of windows')\n",
                "    def reset_window_sizes(self) -> None:\n",
                "        if self.current_layout.remove_all_biases():\n",
                "            self.relayout()\n",
                "\n",
                "    @ac('lay', 'Perform a layout specific action. See :doc:`layouts` for details')\n",
                "    def layout_action(self, action_name: str, args: Sequence[str]) -> None:\n",
                "        ret = self.current_layout.layout_action(action_name, args, self.windows)\n",
                "        if ret is None:\n",
                "            ring_bell()\n",
                "            return\n",
                "        self.relayout()\n",
                "\n",
                "    def launch_child(\n",
                "        self,\n",
                "        use_shell: bool = False,\n",
                "        cmd: Optional[List[str]] = None,\n",
                "        stdin: Optional[bytes] = None,\n",
                "        cwd_from: Optional[CwdRequest] = None,\n",
                "        cwd: Optional[str] = None,\n",
                "        env: Optional[Dict[str, str]] = None,\n",
                "        allow_remote_control: bool = False,\n",
                "        is_clone_launch: str = '',\n",
                "    ) -> Child:\n",
                "        check_for_suitability = True\n",
                "        if cmd is None:\n",
                "            if use_shell:\n",
                "                cmd = resolved_shell(get_options())\n",
                "                check_for_suitability = False\n",
                "            else:\n",
                "                if self.args.args:\n",
                "                    cmd = list(self.args.args)\n",
                "                else:\n",
                "                    cmd = resolved_shell(get_options())\n",
                "                    check_for_suitability = False\n",
                "        if check_for_suitability:\n",
                "            old_exe = cmd[0]\n",
                "            if not os.path.isabs(old_exe):\n",
                "                from .utils import which\n",
                "                actual_exe = which(old_exe)\n",
                "                old_exe = actual_exe if actual_exe else os.path.abspath(old_exe)\n",
                "            try:\n",
                "                is_executable = os.access(old_exe, os.X_OK)\n",
                "            except OSError:\n",
                "                pass\n",
                "            else:\n",
                "                try:\n",
                "                    st = os.stat(old_exe)\n",
                "                except OSError:\n",
                "                    pass\n",
                "                else:\n",
                "                    if stat.S_ISDIR(st.st_mode):\n",
                "                        cwd = old_exe\n",
                "                        cmd = resolved_shell(get_options())\n",
                "                    elif not is_executable:\n",
                "                        import shlex\n",
                "                        with suppress(OSError):\n",
                "                            with open(old_exe) as f:\n",
                "                                if f.read(2) == '#!':\n",
                "                                    line = f.read(4096).splitlines()[0]\n",
                "                                    cmd[:0] = shlex.split(line)\n",
                "                                else:\n",
                "                                    cmd[:0] = [resolved_shell(get_options())[0]]\n",
                "                                cmd[:0] = [kitty_exe(), '+hold']\n",
                "        fenv: Dict[str, str] = {}\n",
                "        if env:\n",
                "            fenv.update(env)\n",
                "        fenv['KITTY_WINDOW_ID'] = str(next_window_id())\n",
                "        pwid = platform_window_id(self.os_window_id)\n",
                "        if pwid is not None:\n",
                "            fenv['WINDOWID'] = str(pwid)\n",
                "        ans = Child(cmd, cwd or self.cwd, stdin, fenv, cwd_from, allow_remote_control=allow_remote_control, is_clone_launch=is_clone_launch)\n",
                "        ans.fork()\n",
                "        return ans\n",
                "\n",
                "    def _add_window(self, window: Window, location: Optional[str] = None, overlay_for: Optional[int] = None, overlay_behind: bool = False) -> None:\n",
                "        self.current_layout.add_window(self.windows, window, location, overlay_for, put_overlay_behind=overlay_behind)\n",
                "        self.mark_tab_bar_dirty()\n",
                "        self.relayout()\n",
                "\n",
                "    def new_window(\n",
                "        self,\n",
                "        use_shell: bool = True,\n",
                "        cmd: Optional[List[str]] = None,\n",
                "        stdin: Optional[bytes] = None,\n",
                "        override_title: Optional[str] = None,\n",
                "        cwd_from: Optional[CwdRequest] = None,\n",
                "        cwd: Optional[str] = None,\n",
                "        overlay_for: Optional[int] = None,\n",
                "        env: Optional[Dict[str, str]] = None,\n",
                "        location: Optional[str] = None,\n",
                "        copy_colors_from: Optional[Window] = None,\n",
                "        allow_remote_control: bool = False,\n",
                "        marker: Optional[str] = None,\n",
                "        watchers: Optional[Watchers] = None,\n",
                "        overlay_behind: bool = False,\n",
                "        is_clone_launch: str = '',\n",
                "    ) -> Window:\n",
                "        child = self.launch_child(\n",
                "            use_shell=use_shell, cmd=cmd, stdin=stdin, cwd_from=cwd_from, cwd=cwd, env=env, allow_remote_control=allow_remote_control,\n",
                "            is_clone_launch=is_clone_launch\n",
                "        )\n",
                "        window = Window(\n",
                "            self, child, self.args, override_title=override_title,\n",
                "            copy_colors_from=copy_colors_from, watchers=watchers\n",
                "        )\n",
                "        # Must add child before laying out so that resize_pty succeeds\n",
                "        get_boss().add_child(window)\n",
                "        self._add_window(window, location=location, overlay_for=overlay_for, overlay_behind=overlay_behind)\n",
                "        if marker:\n",
                "            try:\n",
                "                window.set_marker(marker)\n",
                "            except Exception:\n",
                "                import traceback\n",
                "                traceback.print_exc()\n",
                "        return window\n",
                "\n",
                "    def new_special_window(\n",
                "            self,\n",
                "            special_window: SpecialWindowInstance,\n",
                "            location: Optional[str] = None,\n",
                "            copy_colors_from: Optional[Window] = None,\n",
                "            allow_remote_control: bool = False,\n",
                "    ) -> Window:\n",
                "        return self.new_window(\n",
                "            use_shell=False, cmd=special_window.cmd, stdin=special_window.stdin,\n",
                "            override_title=special_window.override_title,\n",
                "            cwd_from=special_window.cwd_from, cwd=special_window.cwd, overlay_for=special_window.overlay_for,\n",
                "            env=special_window.env, location=location, copy_colors_from=copy_colors_from,\n",
                "            allow_remote_control=allow_remote_control, watchers=special_window.watchers, overlay_behind=special_window.overlay_behind\n",
                "        )\n",
                "\n",
                "    @ac('win', 'Close all windows in the tab other than the currently active window')\n",
                "    def close_other_windows_in_tab(self) -> None:\n",
                "        if len(self.windows) > 1:\n",
                "            active_window = self.active_window\n",
                "            for window in tuple(self.windows):\n",
                "                if window is not active_window:\n",
                "                    self.remove_window(window)\n",
                "\n",
                "    def move_window_to_top_of_group(self, window: Window) -> bool:\n",
                "        return self.windows.move_window_to_top_of_group(window)\n",
                "\n",
                "    def remove_window(self, window: Window, destroy: bool = True) -> None:\n",
                "        self.windows.remove_window(window)\n",
                "        if destroy:\n",
                "            remove_window(self.os_window_id, self.id, window.id)\n",
                "        else:\n",
                "            detach_window(self.os_window_id, self.id, window.id)\n",
                "        self.mark_tab_bar_dirty()\n",
                "        self.relayout()\n",
                "        active_window = self.active_window\n",
                "        if active_window:\n",
                "            self.title_changed(active_window)\n",
                "\n",
                "    def detach_window(self, window: Window) -> Tuple[Window, ...]:\n",
                "        windows = list(self.windows.windows_in_group_of(window))\n",
                "        windows.sort(key=attrgetter('id'))  # since ids increase in order of creation\n",
                "        for w in reversed(windows):\n",
                "            self.remove_window(w, destroy=False)\n",
                "        return tuple(windows)\n",
                "\n",
                "    def attach_window(self, window: Window) -> None:\n",
                "        window.change_tab(self)\n",
                "        attach_window(self.os_window_id, self.id, window.id)\n",
                "        self._add_window(window)\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    def set_active_window(self, x: Union[Window, int]) -> None:\n",
                    "        self.windows.set_active_window_group_for(x)\n"
                ],
                "after": [
                    "    def set_active_window(self, x: Union[Window, int], for_keep_focus: Optional[Window] = None) -> None:\n",
                    "        self.windows.set_active_window_group_for(x, for_keep_focus=for_keep_focus)\n"
                ],
                "parent_version_range": {
                    "start": 506,
                    "end": 508
                },
                "child_version_range": {
                    "start": 506,
                    "end": 508
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Tab",
                        "signature": "class Tab:",
                        "at_line": 91
                    },
                    {
                        "type": "function",
                        "name": "set_active_window",
                        "signature": "def set_active_window(self, x: Union[Window, int])->None:",
                        "at_line": 506
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: kitty/tabs.py\nCode:\n           class Tab:\n               ...\n503 503            attach_window(self.os_window_id, self.id, window.id)\n504 504            self._add_window(window)\n505 505    \n506      -     def set_active_window(self, x: Union[Window, int]) -> None:\n507      -         self.windows.set_active_window_group_for(x)\n    506  +     def set_active_window(self, x: Union[Window, int], for_keep_focus: Optional[Window] = None) -> None:\n    507  +         self.windows.set_active_window_group_for(x, for_keep_focus=for_keep_focus)\n508 508    \n509 509        def get_nth_window(self, n: int) -> Optional[Window]:\n510 510            if self.windows:\n         ...\n",
                "file_path": "kitty/tabs.py",
                "identifiers_before": [
                    "Union",
                    "Window",
                    "int",
                    "self",
                    "set_active_window",
                    "set_active_window_group_for",
                    "windows",
                    "x"
                ],
                "identifiers_after": [
                    "Optional",
                    "Union",
                    "Window",
                    "for_keep_focus",
                    "int",
                    "self",
                    "set_active_window",
                    "set_active_window_group_for",
                    "windows",
                    "x"
                ],
                "prefix": [
                    "        attach_window(self.os_window_id, self.id, window.id)\n",
                    "        self._add_window(window)\n",
                    "\n"
                ],
                "suffix": [
                    "\n",
                    "    def get_nth_window(self, n: int) -> Optional[Window]:\n",
                    "        if self.windows:\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "set_active_window_group_for",
                            "position": {
                                "start": {
                                    "line": 507,
                                    "column": 21
                                },
                                "end": {
                                    "line": 507,
                                    "column": 48
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "set_active_window",
                            "position": {
                                "start": {
                                    "line": 506,
                                    "column": 8
                                },
                                "end": {
                                    "line": 506,
                                    "column": 25
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "set_active_window_group_for",
                            "position": {
                                "start": {
                                    "line": 507,
                                    "column": 21
                                },
                                "end": {
                                    "line": 507,
                                    "column": 48
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 507,
                                    "column": 52
                                },
                                "end": {
                                    "line": 507,
                                    "column": 66
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "set_active_window",
                            "position": {
                                "start": {
                                    "line": 506,
                                    "column": 8
                                },
                                "end": {
                                    "line": 506,
                                    "column": 25
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 506,
                                    "column": 55
                                },
                                "end": {
                                    "line": 506,
                                    "column": 69
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "\n",
                "    def get_nth_window(self, n: int) -> Optional[Window]:\n",
                "        if self.windows:\n",
                "            return self.current_layout.nth_window(self.windows, n)\n",
                "        return None\n",
                "\n",
                "    @ac('win', '''\n",
                "        Focus the nth window if positive or the previously active windows if negative. When the number is larger\n",
                "        than the number of windows focus the last window. For example::\n",
                "\n",
                "            # focus the previously active window\n",
                "            map ctrl+p nth_window -1\n",
                "            # focus the first window\n",
                "            map ctrl+1 nth_window 0\n",
                "        ''')\n",
                "    def nth_window(self, num: int = 0) -> None:\n",
                "        if self.windows:\n",
                "            if num < 0:\n",
                "                self.windows.make_previous_group_active(-num)\n",
                "            elif self.windows.num_groups:\n",
                "                self.current_layout.activate_nth_window(self.windows, min(num, self.windows.num_groups - 1))\n",
                "            self.relayout_borders()\n",
                "\n",
                "    @ac('win', 'Focus the first window')\n",
                "    def first_window(self) -> None:\n",
                "        self.nth_window(0)\n",
                "\n",
                "    @ac('win', 'Focus the second window')\n",
                "    def second_window(self) -> None:\n",
                "        self.nth_window(1)\n",
                "\n",
                "    @ac('win', 'Focus the third window')\n",
                "    def third_window(self) -> None:\n",
                "        self.nth_window(2)\n",
                "\n",
                "    @ac('win', 'Focus the fourth window')\n",
                "    def fourth_window(self) -> None:\n",
                "        self.nth_window(3)\n",
                "\n",
                "    @ac('win', 'Focus the fifth window')\n",
                "    def fifth_window(self) -> None:\n",
                "        self.nth_window(4)\n",
                "\n",
                "    @ac('win', 'Focus the sixth window')\n",
                "    def sixth_window(self) -> None:\n",
                "        self.nth_window(5)\n",
                "\n",
                "    @ac('win', 'Focus the seventh window')\n",
                "    def seventh_window(self) -> None:\n",
                "        self.nth_window(6)\n",
                "\n",
                "    @ac('win', 'Focus the eighth window')\n",
                "    def eighth_window(self) -> None:\n",
                "        self.nth_window(7)\n",
                "\n",
                "    @ac('win', 'Focus the ninth window')\n",
                "    def ninth_window(self) -> None:\n",
                "        self.nth_window(8)\n",
                "\n",
                "    @ac('win', 'Focus the tenth window')\n",
                "    def tenth_window(self) -> None:\n",
                "        self.nth_window(9)\n",
                "\n",
                "    def _next_window(self, delta: int = 1) -> None:\n",
                "        if len(self.windows) > 1:\n",
                "            self.current_layout.next_window(self.windows, delta)\n",
                "            self.relayout_borders()\n",
                "\n",
                "    @ac('win', 'Focus the next window in the current tab')\n",
                "    def next_window(self) -> None:\n",
                "        self._next_window()\n",
                "\n",
                "    @ac('win', 'Focus the previous window in the current tab')\n",
                "    def previous_window(self) -> None:\n",
                "        self._next_window(-1)\n",
                "\n",
                "    prev_window = previous_window\n",
                "\n",
                "    def most_recent_group(self, groups: Sequence[int]) -> Optional[int]:\n",
                "        groups_set = frozenset(groups)\n",
                "\n",
                "        for window_id in reversed(self.windows.active_window_history):\n",
                "            group = self.windows.group_for_window(window_id)\n",
                "            if group and group.id in groups_set:\n",
                "                return group.id\n",
                "\n",
                "        if groups:\n",
                "            return groups[0]\n",
                "        return None\n",
                "\n",
                "    def nth_active_window_id(self, n: int = 0) -> int:\n",
                "        if n <= 0:\n",
                "            return self.active_window.id if self.active_window else 0\n",
                "        ids = tuple(reversed(self.windows.active_window_history))\n",
                "        return ids[min(n - 1, len(ids) - 1)] if ids else 0\n",
                "\n",
                "    def neighboring_group_id(self, which: EdgeLiteral) -> Optional[int]:\n",
                "        neighbors = self.current_layout.neighbors(self.windows)\n",
                "        candidates = neighbors.get(which)\n",
                "        if candidates:\n",
                "            return self.most_recent_group(candidates)\n",
                "        return None\n",
                "\n",
                "    @ac('win', '''\n",
                "        Focus the neighboring window in the current tab\n",
                "\n",
                "        For example::\n",
                "\n",
                "            map ctrl+left neighboring_window left\n",
                "            map ctrl+down neighboring_window bottom\n",
                "        ''')\n",
                "    def neighboring_window(self, which: EdgeLiteral) -> None:\n",
                "        neighbor = self.neighboring_group_id(which)\n",
                "        if neighbor:\n",
                "            self.windows.set_active_group(neighbor)\n",
                "\n",
                "    @ac('win', '''\n",
                "        Move the window in the specified direction\n",
                "\n",
                "        For example::\n",
                "\n",
                "            map ctrl+left move_window left\n",
                "            map ctrl+down move_window bottom\n",
                "        ''')\n",
                "    def move_window(self, delta: Union[EdgeLiteral, int] = 1) -> None:\n",
                "        if isinstance(delta, int):\n",
                "            if self.current_layout.move_window(self.windows, delta):\n",
                "                self.relayout()\n",
                "        elif isinstance(delta, str):\n",
                "            neighbor = self.neighboring_group_id(delta)\n",
                "            if neighbor:\n",
                "                if self.current_layout.move_window_to_group(self.windows, neighbor):\n",
                "                    self.relayout()\n",
                "\n",
                "    def swap_active_window_with(self, window_id: int) -> None:\n",
                "        group = self.windows.group_for_window(window_id)\n",
                "        if group is not None:\n",
                "            w = self.active_window\n",
                "            if w is not None and w.id != window_id:\n",
                "                if self.current_layout.move_window_to_group(self.windows, group.id):\n",
                "                    self.relayout()\n",
                "\n",
                "    @property\n",
                "    def all_window_ids_except_active_window(self) -> Set[int]:\n",
                "        all_window_ids = {w.id for w in self}\n",
                "        aw = self.active_window\n",
                "        if aw is not None:\n",
                "            all_window_ids.discard(aw.id)\n",
                "        return all_window_ids\n",
                "\n",
                "    @ac('win', '''\n",
                "        Focus a visible window by pressing the number of the window. Window numbers are displayed\n",
                "        over the windows for easy selection in this mode. See :opt:`visual_window_select_characters`.\n",
                "        ''')\n",
                "    def focus_visible_window(self) -> None:\n",
                "        def callback(tab: Optional[Tab], window: Optional[Window]) -> None:\n",
                "            if tab and window:\n",
                "                tab.set_active_window(window)\n",
                "\n",
                "        get_boss().visual_window_select_action(self, callback, 'Choose window to switch to', only_window_ids=self.all_window_ids_except_active_window)\n",
                "\n",
                "    @ac('win', 'Swap the current window with another window in the current tab, selected visually. See :opt:`visual_window_select_characters`')\n",
                "    def swap_with_window(self) -> None:\n",
                "        def callback(tab: Optional[Tab], window: Optional[Window]) -> None:\n",
                "            if tab and window:\n",
                "                tab.swap_active_window_with(window.id)\n",
                "        get_boss().visual_window_select_action(self, callback, 'Choose window to swap with', only_window_ids=self.all_window_ids_except_active_window)\n",
                "\n",
                "    @ac('win', 'Move active window to the top (make it the first window)')\n",
                "    def move_window_to_top(self) -> None:\n",
                "        n = self.windows.active_group_idx\n",
                "        if n > 0:\n",
                "            self.move_window(-n)\n",
                "\n",
                "    @ac('win', 'Move active window forward (swap it with the next window)')\n",
                "    def move_window_forward(self) -> None:\n",
                "        self.move_window()\n",
                "\n",
                "    @ac('win', 'Move active window backward (swap it with the previous window)')\n",
                "    def move_window_backward(self) -> None:\n",
                "        self.move_window(-1)\n",
                "\n",
                "    def list_windows(self, active_window: Optional[Window], self_window: Optional[Window] = None) -> Generator[WindowDict, None, None]:\n",
                "        for w in self:\n",
                "            yield w.as_dict(is_focused=w is active_window, is_self=w is self_window)\n",
                "\n",
                "    def matches_query(self, field: str, query: str, active_tab_manager: Optional['TabManager'] = None) -> bool:\n",
                "        if field == 'title':\n",
                "            return re.search(query, self.effective_title) is not None\n",
                "        if field == 'id':\n",
                "            return query == str(self.id)\n",
                "        if field in ('window_id', 'window_title'):\n",
                "            field = field.partition('_')[-1]\n",
                "            for w in self:\n",
                "                if w.matches_query(field, query):\n",
                "                    return True\n",
                "            return False\n",
                "        if field == 'index':\n",
                "            if active_tab_manager and len(active_tab_manager.tabs):\n",
                "                idx = (int(query) + len(active_tab_manager.tabs)) % len(active_tab_manager.tabs)\n",
                "                return active_tab_manager.tabs[idx] is self\n",
                "            return False\n",
                "        if field == 'recent':\n",
                "            if active_tab_manager and len(active_tab_manager.tabs):\n",
                "                return self is active_tab_manager.nth_active_tab(int(query))\n",
                "            return False\n",
                "        if field == 'state':\n",
                "            if query == 'active':\n",
                "                return active_tab_manager is not None and self is active_tab_manager.active_tab\n",
                "            if query == 'focused':\n",
                "                return active_tab_manager is not None and self is active_tab_manager.active_tab and self.os_window_id == current_os_window()\n",
                "            if query == 'needs_attention':\n",
                "                for w in self:\n",
                "                    if w.needs_attention:\n",
                "                        return True\n",
                "            if query == 'parent_active':\n",
                "                return active_tab_manager is not None and self.tab_manager_ref() is active_tab_manager\n",
                "            if query == 'parent_focused':\n",
                "                return active_tab_manager is not None and self.tab_manager_ref() is active_tab_manager and self.os_window_id == current_os_window()\n",
                "            return False\n",
                "        return False\n",
                "\n",
                "    def __iter__(self) -> Iterator[Window]:\n",
                "        return iter(self.windows)\n",
                "\n",
                "    def __len__(self) -> int:\n",
                "        return len(self.windows)\n",
                "\n",
                "    @property\n",
                "    def num_window_groups(self) -> int:\n",
                "        return self.windows.num_groups\n",
                "\n",
                "    def __contains__(self, window: Window) -> bool:\n",
                "        return window in self.windows\n",
                "\n",
                "    def destroy(self) -> None:\n",
                "        evict_cached_layouts(self.id)\n",
                "        for w in self.windows:\n",
                "            w.destroy()\n",
                "        self.windows = WindowList(self)\n",
                "\n",
                "    def __repr__(self) -> str:\n",
                "        return f'Tab(title={self.effective_title}, id={hex(id(self))})'\n",
                "\n",
                "    def make_active(self) -> None:\n",
                "        tm = self.tab_manager_ref()\n",
                "        if tm is not None:\n",
                "            tm.set_active_tab(self)\n",
                "# }}}\n",
                "\n",
                "\n",
                "class TabManager:  # {{{\n",
                "\n",
                "    def __init__(self, os_window_id: int, args: CLIOptions, wm_class: str, wm_name: str, startup_session: Optional[SessionType] = None):\n",
                "        self.os_window_id = os_window_id\n",
                "        self.wm_class = wm_class\n",
                "        self.recent_mouse_events: Deque[TabMouseEvent] = deque()\n",
                "        self.wm_name = wm_name\n",
                "        self.last_active_tab_id = None\n",
                "        self.args = args\n",
                "        self.tab_bar_hidden = get_options().tab_bar_style == 'hidden'\n",
                "        self.tabs: List[Tab] = []\n",
                "        self.active_tab_history: Deque[int] = deque()\n",
                "        self.tab_bar = TabBar(self.os_window_id)\n",
                "        self._active_tab_idx = 0\n",
                "\n",
                "        if startup_session is not None:\n",
                "            for t in startup_session.tabs:\n",
                "                self._add_tab(Tab(self, session_tab=t))\n",
                "            self._set_active_tab(max(0, min(startup_session.active_tab_idx, len(self.tabs) - 1)))\n",
                "\n",
                "    @property\n",
                "    def active_tab_idx(self) -> int:\n",
                "        return self._active_tab_idx\n",
                "\n",
                "    @active_tab_idx.setter\n",
                "    def active_tab_idx(self, val: int) -> None:\n",
                "        new_active_tab_idx = max(0, min(val, len(self.tabs) - 1))\n",
                "        if new_active_tab_idx == self._active_tab_idx:\n",
                "            return\n",
                "        try:\n",
                "            old_active_tab: Optional[Tab] = self.tabs[self._active_tab_idx]\n",
                "        except Exception:\n",
                "            old_active_tab = None\n",
                "        else:\n",
                "            assert old_active_tab is not None\n",
                "            add_active_id_to_history(self.active_tab_history, old_active_tab.id)\n",
                "        self._active_tab_idx = new_active_tab_idx\n",
                "        try:\n",
                "            new_active_tab: Optional[Tab] = self.tabs[self._active_tab_idx]\n",
                "        except Exception:\n",
                "            new_active_tab = None\n",
                "        if old_active_tab is not new_active_tab:\n",
                "            if old_active_tab is not None:\n",
                "                w = old_active_tab.active_window\n",
                "                if w is not None:\n",
                "                    w.focus_changed(False)\n",
                "            if new_active_tab is not None:\n",
                "                w = new_active_tab.active_window\n",
                "                if w is not None:\n",
                "                    w.focus_changed(True)\n",
                "\n",
                "    def refresh_sprite_positions(self) -> None:\n",
                "        if not self.tab_bar_hidden:\n",
                "            self.tab_bar.screen.refresh_sprite_positions()\n",
                "\n",
                "    @property\n",
                "    def tab_bar_should_be_visible(self) -> bool:\n",
                "        return len(self.tabs) >= get_options().tab_bar_min_tabs\n",
                "\n",
                "    def _add_tab(self, tab: Tab) -> None:\n",
                "        visible_before = self.tab_bar_should_be_visible\n",
                "        self.tabs.append(tab)\n",
                "        if not visible_before and self.tab_bar_should_be_visible:\n",
                "            self.tabbar_visibility_changed()\n",
                "\n",
                "    def _remove_tab(self, tab: Tab) -> None:\n",
                "        visible_before = self.tab_bar_should_be_visible\n",
                "        remove_tab(self.os_window_id, tab.id)\n",
                "        self.tabs.remove(tab)\n",
                "        if visible_before and not self.tab_bar_should_be_visible:\n",
                "            self.tabbar_visibility_changed()\n",
                "\n",
                "    def _set_active_tab(self, idx: int) -> None:\n",
                "        self.active_tab_idx = idx\n",
                "        set_active_tab(self.os_window_id, idx)\n",
                "\n",
                "    def tabbar_visibility_changed(self) -> None:\n",
                "        if not self.tab_bar_hidden:\n",
                "            self.tab_bar.layout()\n",
                "            self.resize(only_tabs=True)\n",
                "\n",
                "    def mark_tab_bar_dirty(self) -> None:\n",
                "        if self.tab_bar_should_be_visible and not self.tab_bar_hidden:\n",
                "            mark_tab_bar_dirty(self.os_window_id)\n",
                "\n",
                "    def update_tab_bar_data(self) -> None:\n",
                "        self.tab_bar.update(self.tab_bar_data)\n",
                "\n",
                "    def title_changed(self, tab: Tab) -> None:\n",
                "        self.mark_tab_bar_dirty()\n",
                "        if tab is self.active_tab:\n",
                "            sync_os_window_title(self.os_window_id)\n",
                "\n",
                "    def resize(self, only_tabs: bool = False) -> None:\n",
                "        if not only_tabs:\n",
                "            if not self.tab_bar_hidden:\n",
                "                self.tab_bar.layout()\n",
                "                self.mark_tab_bar_dirty()\n",
                "        for tab in self.tabs:\n",
                "            tab.relayout()\n",
                "\n",
                "    def set_active_tab_idx(self, idx: int) -> None:\n",
                "        self._set_active_tab(idx)\n",
                "        tab = self.active_tab\n",
                "        if tab is not None:\n",
                "            tab.relayout_borders()\n",
                "        self.mark_tab_bar_dirty()\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    def set_active_tab(self, tab: Tab) -> bool:\n"
                ],
                "after": [
                    "    def set_active_tab(self, tab: Tab, for_keep_focus: Optional[Tab] = None) -> bool:\n"
                ],
                "parent_version_range": {
                    "start": 867,
                    "end": 868
                },
                "child_version_range": {
                    "start": 867,
                    "end": 868
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "TabManager",
                        "signature": "class TabManager:",
                        "at_line": 759
                    },
                    {
                        "type": "function",
                        "name": "set_active_tab",
                        "signature": "def set_active_tab(self, tab: Tab)->bool:",
                        "at_line": 867
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: kitty/tabs.py\nCode:\n           class TabManager:\n               ...\n864 864                tab.relayout_borders()\n865 865            self.mark_tab_bar_dirty()\n866 866    \n867      -     def set_active_tab(self, tab: Tab) -> bool:\n    867  +     def set_active_tab(self, tab: Tab, for_keep_focus: Optional[Tab] = None) -> bool:\n868 868            try:\n869 869                idx = self.tabs.index(tab)\n870 870            except Exception:\n         ...\n",
                "file_path": "kitty/tabs.py",
                "identifiers_before": [
                    "Tab",
                    "bool",
                    "self",
                    "set_active_tab",
                    "tab"
                ],
                "identifiers_after": [
                    "Optional",
                    "Tab",
                    "bool",
                    "for_keep_focus",
                    "self",
                    "set_active_tab",
                    "tab"
                ],
                "prefix": [
                    "            tab.relayout_borders()\n",
                    "        self.mark_tab_bar_dirty()\n",
                    "\n"
                ],
                "suffix": [
                    "        try:\n",
                    "            idx = self.tabs.index(tab)\n",
                    "        except Exception:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "set_active_tab",
                            "position": {
                                "start": {
                                    "line": 867,
                                    "column": 8
                                },
                                "end": {
                                    "line": 867,
                                    "column": 22
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "set_active_tab",
                            "position": {
                                "start": {
                                    "line": 867,
                                    "column": 8
                                },
                                "end": {
                                    "line": 867,
                                    "column": 22
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 867,
                                    "column": 39
                                },
                                "end": {
                                    "line": 867,
                                    "column": 53
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 867,
                                    "column": 39
                                },
                                "end": {
                                    "line": 867,
                                    "column": 53
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 867,
                                    "column": 39
                                },
                                "end": {
                                    "line": 867,
                                    "column": 53
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 867,
                                    "column": 39
                                },
                                "end": {
                                    "line": 867,
                                    "column": 53
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 867,
                                    "column": 23
                                },
                                "end": {
                                    "line": 867,
                                    "column": 27
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "        try:\n",
                "            idx = self.tabs.index(tab)\n",
                "        except Exception:\n",
                "            return False\n",
                "        self.set_active_tab_idx(idx)\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        h = self.active_tab_history\n",
                    "        if for_keep_focus and len(h) > 2 and h[-2] == for_keep_focus.id and h[-1] != for_keep_focus.id:\n",
                    "            h.pop()\n",
                    "            h.pop()\n"
                ],
                "parent_version_range": {
                    "start": 873,
                    "end": 873
                },
                "child_version_range": {
                    "start": 873,
                    "end": 877
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "TabManager",
                        "signature": "class TabManager:",
                        "at_line": 759
                    },
                    {
                        "type": "function",
                        "name": "set_active_tab",
                        "signature": "def set_active_tab(self, tab: Tab)->bool:",
                        "at_line": 867
                    },
                    {
                        "type": "call",
                        "name": "self.set_active_tab_idx",
                        "signature": "self.set_active_tab_idx(idx)",
                        "at_line": 872,
                        "argument": "idx"
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: kitty/tabs.py\nCode:\n           class TabManager:\n               ...\n               def set_active_tab(self, tab: Tab)->bool:\n                   ...\n870 870            except Exception:\n871 871                return False\n872 872            self.set_active_tab_idx(idx)\n    873  +         h = self.active_tab_history\n    874  +         if for_keep_focus and len(h) > 2 and h[-2] == for_keep_focus.id and h[-1] != for_keep_focus.id:\n    875  +             h.pop()\n    876  +             h.pop()\n873 877            return True\n874 878    \n875 879        def next_tab(self, delta: int = 1) -> None:\n         ...\n",
                "file_path": "kitty/tabs.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "active_tab_history",
                    "for_keep_focus",
                    "h",
                    "id",
                    "len",
                    "pop",
                    "self"
                ],
                "prefix": [
                    "        except Exception:\n",
                    "            return False\n",
                    "        self.set_active_tab_idx(idx)\n"
                ],
                "suffix": [
                    "        return True\n",
                    "\n",
                    "    def next_tab(self, delta: int = 1) -> None:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 874,
                                    "column": 11
                                },
                                "end": {
                                    "line": 874,
                                    "column": 25
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 874,
                                    "column": 54
                                },
                                "end": {
                                    "line": 874,
                                    "column": 68
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 874,
                                    "column": 85
                                },
                                "end": {
                                    "line": 874,
                                    "column": 99
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 873,
                                    "column": 12
                                },
                                "end": {
                                    "line": 873,
                                    "column": 16
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/tabs.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    7
                ]
            },
            [
                "        return True\n",
                "\n",
                "    def next_tab(self, delta: int = 1) -> None:\n",
                "        if len(self.tabs) > 1:\n",
                "            self.set_active_tab_idx((self.active_tab_idx + len(self.tabs) + delta) % len(self.tabs))\n",
                "\n",
                "    def tab_at_location(self, loc: str) -> Optional[Tab]:\n",
                "        if loc == 'prev':\n",
                "            if self.active_tab_history:\n",
                "                old_active_tab_id = self.active_tab_history[-1]\n",
                "                for idx, tab in enumerate(self.tabs):\n",
                "                    if tab.id == old_active_tab_id:\n",
                "                        return tab\n",
                "        elif loc in ('left', 'right'):\n",
                "            delta = -1 if loc == 'left' else 1\n",
                "            idx = (len(self.tabs) + self.active_tab_idx + delta) % len(self.tabs)\n",
                "            return self.tabs[idx]\n",
                "        return None\n",
                "\n",
                "    def goto_tab(self, tab_num: int) -> None:\n",
                "        if tab_num >= len(self.tabs):\n",
                "            tab_num = max(0, len(self.tabs) - 1)\n",
                "        if tab_num >= 0:\n",
                "            self.set_active_tab_idx(tab_num)\n",
                "        else:\n",
                "            try:\n",
                "                old_active_tab_id = self.active_tab_history[tab_num]\n",
                "            except IndexError:\n",
                "                return\n",
                "            for idx, tab in enumerate(self.tabs):\n",
                "                if tab.id == old_active_tab_id:\n",
                "                    self.set_active_tab_idx(idx)\n",
                "                    break\n",
                "\n",
                "    def nth_active_tab(self, n: int = 0) -> Optional[Tab]:\n",
                "        if n <= 0:\n",
                "            return self.active_tab\n",
                "        tab_ids = tuple(reversed(self.active_tab_history))\n",
                "        return self.tab_for_id(tab_ids[min(n - 1, len(tab_ids) - 1)]) if tab_ids else None\n",
                "\n",
                "    def __iter__(self) -> Iterator[Tab]:\n",
                "        return iter(self.tabs)\n",
                "\n",
                "    def __len__(self) -> int:\n",
                "        return len(self.tabs)\n",
                "\n",
                "    def list_tabs(self, active_tab: Optional[Tab], active_window: Optional[Window], self_window: Optional[Window] = None) -> Generator[TabDict, None, None]:\n",
                "        for tab in self:\n",
                "            yield {\n",
                "                'id': tab.id,\n",
                "                'is_focused': tab is active_tab,\n",
                "                'title': tab.name or tab.title,\n",
                "                'layout': str(tab.current_layout.name),\n",
                "                'layout_state': tab.current_layout.layout_state(),\n",
                "                'layout_opts': tab.current_layout.layout_opts.serialized(),\n",
                "                'enabled_layouts': tab.enabled_layouts,\n",
                "                'windows': list(tab.list_windows(active_window, self_window)),\n",
                "                'active_window_history': list(tab.windows.active_window_history),\n",
                "            }\n",
                "\n",
                "    def serialize_state(self) -> Dict[str, Any]:\n",
                "        return {\n",
                "            'version': 1,\n",
                "            'id': self.os_window_id,\n",
                "            'tabs': [tab.serialize_state() for tab in self],\n",
                "            'active_tab_idx': self.active_tab_idx,\n",
                "        }\n",
                "\n",
                "    @property\n",
                "    def active_tab(self) -> Optional[Tab]:\n",
                "        try:\n",
                "            return self.tabs[self.active_tab_idx] if self.tabs else None\n",
                "        except Exception:\n",
                "            return None\n",
                "\n",
                "    @property\n",
                "    def active_window(self) -> Optional[Window]:\n",
                "        t = self.active_tab\n",
                "        if t is not None:\n",
                "            return t.active_window\n",
                "        return None\n",
                "\n",
                "    @property\n",
                "    def number_of_windows_with_running_programs(self) -> int:\n",
                "        count = 0\n",
                "        for tab in self:\n",
                "            count += tab.number_of_windows_with_running_programs\n",
                "        return count\n",
                "\n",
                "    @property\n",
                "    def number_of_windows(self) -> int:\n",
                "        count = 0\n",
                "        for tab in self:\n",
                "            count += len(tab)\n",
                "        return count\n",
                "\n",
                "    def tab_for_id(self, tab_id: int) -> Optional[Tab]:\n",
                "        for t in self.tabs:\n",
                "            if t.id == tab_id:\n",
                "                return t\n",
                "        return None\n",
                "\n",
                "    def move_tab(self, delta: int = 1) -> None:\n",
                "        if len(self.tabs) > 1:\n",
                "            idx = self.active_tab_idx\n",
                "            nidx = (idx + len(self.tabs) + delta) % len(self.tabs)\n",
                "            step = 1 if idx < nidx else -1\n",
                "            for i in range(idx, nidx, step):\n",
                "                self.tabs[i], self.tabs[i + step] = self.tabs[i + step], self.tabs[i]\n",
                "                swap_tabs(self.os_window_id, i, i + step)\n",
                "            self._set_active_tab(nidx)\n",
                "            self.mark_tab_bar_dirty()\n",
                "\n",
                "    def new_tab(\n",
                "        self,\n",
                "        special_window: Optional[SpecialWindowInstance] = None,\n",
                "        cwd_from: Optional[CwdRequest] = None,\n",
                "        as_neighbor: bool = False,\n",
                "        empty_tab: bool = False,\n",
                "        location: str = 'last'\n",
                "    ) -> Tab:\n",
                "        idx = len(self.tabs)\n",
                "        orig_active_tab_idx = self.active_tab_idx\n",
                "        self._add_tab(Tab(self, no_initial_window=True) if empty_tab else Tab(self, special_window=special_window, cwd_from=cwd_from))\n",
                "        self._set_active_tab(idx)\n",
                "        if as_neighbor:\n",
                "            location = 'after'\n",
                "        if location == 'neighbor':\n",
                "            location = 'after'\n",
                "        if location == 'default':\n",
                "            location = 'last'\n",
                "        if len(self.tabs) > 1 and location != 'last':\n",
                "            if location == 'first':\n",
                "                desired_idx = 0\n",
                "            else:\n",
                "                desired_idx = orig_active_tab_idx + (0 if location == 'before' else 1)\n",
                "            if idx != desired_idx:\n",
                "                for i in range(idx, desired_idx, -1):\n",
                "                    self.tabs[i], self.tabs[i-1] = self.tabs[i-1], self.tabs[i]\n",
                "                    swap_tabs(self.os_window_id, i, i-1)\n",
                "                self._set_active_tab(desired_idx)\n",
                "                idx = desired_idx\n",
                "        self.mark_tab_bar_dirty()\n",
                "        return self.tabs[idx]\n",
                "\n",
                "    def remove(self, tab: Tab) -> None:\n",
                "        active_tab_before_removal = self.active_tab\n",
                "        active_tab_needs_to_change = active_tab_before_removal is tab\n",
                "        self._remove_tab(tab)\n",
                "        while True:\n",
                "            try:\n",
                "                self.active_tab_history.remove(tab.id)\n",
                "            except ValueError:\n",
                "                break\n",
                "\n",
                "        if active_tab_needs_to_change:\n",
                "            next_active_tab = -1\n",
                "            if get_options().tab_switch_strategy == 'previous':\n",
                "                while self.active_tab_history and next_active_tab < 0:\n",
                "                    tab_id = self.active_tab_history.pop()\n",
                "                    for idx, qtab in enumerate(self.tabs):\n",
                "                        if qtab.id == tab_id:\n",
                "                            next_active_tab = idx\n",
                "                            break\n",
                "            elif get_options().tab_switch_strategy == 'left':\n",
                "                next_active_tab = max(0, self.active_tab_idx - 1)\n",
                "            elif get_options().tab_switch_strategy == 'right':\n",
                "                next_active_tab = min(self.active_tab_idx, len(self.tabs) - 1)\n",
                "\n",
                "            if next_active_tab < 0:\n",
                "                next_active_tab = max(0, min(self.active_tab_idx, len(self.tabs) - 1))\n",
                "\n",
                "            self._set_active_tab(next_active_tab)\n",
                "        elif active_tab_before_removal is not None:\n",
                "            try:\n",
                "                idx = self.tabs.index(active_tab_before_removal)\n",
                "            except Exception:\n",
                "                pass\n",
                "            else:\n",
                "                self._active_tab_idx = idx\n",
                "        self.mark_tab_bar_dirty()\n",
                "        tab.destroy()\n",
                "\n",
                "    @property\n",
                "    def tab_bar_data(self) -> List[TabBarData]:\n",
                "        at = self.active_tab\n",
                "        ans = []\n",
                "        for t in self.tabs:\n",
                "            title = (t.name or t.title or appname).strip()\n",
                "            needs_attention = False\n",
                "            has_activity_since_last_focus = False\n",
                "            for w in t:\n",
                "                if w.needs_attention:\n",
                "                    needs_attention = True\n",
                "                if w.has_activity_since_last_focus:\n",
                "                    has_activity_since_last_focus = True\n",
                "            ans.append(TabBarData(\n",
                "                title, t is at, needs_attention,\n",
                "                len(t), t.num_window_groups, t.current_layout.name or '',\n",
                "                has_activity_since_last_focus, t.active_fg, t.active_bg,\n",
                "                t.inactive_fg, t.inactive_bg\n",
                "            ))\n",
                "        return ans\n",
                "\n",
                "    def handle_click_on_tab(self, x: int, button: int, modifiers: int, action: int) -> None:\n",
                "        i = self.tab_bar.tab_at(x)\n",
                "        now = monotonic()\n",
                "        if i is None:\n",
                "            if button == GLFW_MOUSE_BUTTON_LEFT and action == GLFW_RELEASE and len(self.recent_mouse_events) > 2:\n",
                "                ci = get_click_interval()\n",
                "                prev, prev2 = self.recent_mouse_events[-1], self.recent_mouse_events[-2]\n",
                "                if (\n",
                "                    prev.button == button and prev2.button == button and\n",
                "                    prev.action == GLFW_PRESS and prev2.action == GLFW_RELEASE and\n",
                "                    prev.tab_idx is None and prev2.tab_idx is None and\n",
                "                    now - prev.at <= ci and now - prev2.at <= 2 * ci\n",
                "                ):  # double click\n",
                "                    self.new_tab()\n",
                "                    self.recent_mouse_events.clear()\n",
                "                    return\n",
                "        else:\n",
                "            if action == GLFW_PRESS and button == GLFW_MOUSE_BUTTON_LEFT:\n",
                "                self.set_active_tab_idx(i)\n",
                "            elif button == GLFW_MOUSE_BUTTON_MIDDLE and action == GLFW_RELEASE and self.recent_mouse_events:\n",
                "                p = self.recent_mouse_events[-1]\n",
                "                if p.button == button and p.action == GLFW_PRESS and p.tab_idx == i:\n",
                "                    tab = self.tabs[i]\n",
                "                    get_boss().close_tab(tab)\n",
                "        self.recent_mouse_events.append(TabMouseEvent(button, modifiers, action, now, i))\n",
                "        if len(self.recent_mouse_events) > 5:\n",
                "            self.recent_mouse_events.popleft()\n",
                "\n",
                "    @property\n",
                "    def tab_bar_rects(self) -> Tuple[Border, ...]:\n",
                "        return self.tab_bar.blank_rects if self.tab_bar_should_be_visible else ()\n",
                "\n",
                "    def destroy(self) -> None:\n",
                "        for t in self:\n",
                "            t.destroy()\n",
                "        self.tab_bar.destroy()\n",
                "        del self.tab_bar\n",
                "        del self.tabs\n",
                "\n",
                "    def apply_options(self) -> None:\n",
                "        for tab in self:\n",
                "            tab.apply_options()\n",
                "        self.tab_bar_hidden = get_options().tab_bar_style == 'hidden'\n",
                "        self.tab_bar.apply_options()\n",
                "        self.update_tab_bar_data()\n",
                "        self.mark_tab_bar_dirty()\n",
                "        self.tab_bar.layout()\n",
                "# }}}"
            ]
        ],
        "kitty/window_list.py": [
            [
                "#!/usr/bin/env python\n",
                "# License: GPLv3 Copyright: 2020, Kovid Goyal <kovid at kovidgoyal.net>\n",
                "\n",
                "import weakref\n",
                "from collections import deque\n",
                "from contextlib import suppress\n",
                "from itertools import count\n",
                "from typing import Any, Deque, Dict, Iterator, List, Optional, Tuple, Union\n",
                "\n",
                "from .types import WindowGeometry\n",
                "from .typing import EdgeLiteral, TabType, WindowType\n",
                "\n",
                "WindowOrId = Union[WindowType, int]\n",
                "group_id_counter = count(start=1)\n",
                "\n",
                "\n",
                "def reset_group_id_counter() -> None:\n",
                "    global group_id_counter\n",
                "    group_id_counter = count(start=1)\n",
                "\n",
                "\n",
                "def wrap_increment(val: int, num: int, delta: int) -> int:\n",
                "    mult = -1 if delta < 0 else 1\n",
                "    delta = mult * (abs(delta) % num)\n",
                "    return (val + num + delta) % num\n",
                "\n",
                "\n",
                "class WindowGroup:\n",
                "\n",
                "    def __init__(self) -> None:\n",
                "        self.windows: List[WindowType] = []\n",
                "        self.id = next(group_id_counter)\n",
                "\n",
                "    def __len__(self) -> int:\n",
                "        return len(self.windows)\n",
                "\n",
                "    def __bool__(self) -> bool:\n",
                "        return bool(self.windows)\n",
                "\n",
                "    def __iter__(self) -> Iterator[WindowType]:\n",
                "        return iter(self.windows)\n",
                "\n",
                "    def __contains__(self, window: WindowType) -> bool:\n",
                "        for w in self.windows:\n",
                "            if w is window:\n",
                "                return True\n",
                "        return False\n",
                "\n",
                "    @property\n",
                "    def needs_attention(self) -> bool:\n",
                "        for w in self.windows:\n",
                "            if w.needs_attention:\n",
                "                return True\n",
                "        return False\n",
                "\n",
                "    @property\n",
                "    def base_window_id(self) -> int:\n",
                "        return self.windows[0].id if self.windows else 0\n",
                "\n",
                "    @property\n",
                "    def active_window_id(self) -> int:\n",
                "        return self.windows[-1].id if self.windows else 0\n",
                "\n",
                "    def add_window(self, window: WindowType, head_of_group: bool = False) -> None:\n",
                "        if head_of_group:\n",
                "            self.windows.insert(0, window)\n",
                "        else:\n",
                "            self.windows.append(window)\n",
                "\n",
                "    def move_window_to_top_of_group(self, window: WindowType) -> bool:\n",
                "        try:\n",
                "            idx = self.windows.index(window)\n",
                "        except ValueError:\n",
                "            return False\n",
                "        if idx == len(self.windows) - 1:\n",
                "            return False\n",
                "        del self.windows[idx]\n",
                "        self.windows.append(window)\n",
                "        return True\n",
                "\n",
                "    def remove_window(self, window: WindowType) -> None:\n",
                "        with suppress(ValueError):\n",
                "            self.windows.remove(window)\n",
                "\n",
                "    def serialize_state(self) -> Dict[str, Any]:\n",
                "        return {\n",
                "            'id': self.id,\n",
                "            'windows': [w.serialize_state() for w in self.windows]\n",
                "        }\n",
                "\n",
                "    def decoration(self, which: EdgeLiteral, border_mult: int = 1, is_single_window: bool = False) -> int:\n",
                "        if not self.windows:\n",
                "            return 0\n",
                "        w = self.windows[0]\n",
                "        return w.effective_margin(which, is_single_window=is_single_window) + w.effective_border() * border_mult + w.effective_padding(which)\n",
                "\n",
                "    def effective_padding(self, which: EdgeLiteral) -> int:\n",
                "        if not self.windows:\n",
                "            return 0\n",
                "        w = self.windows[0]\n",
                "        return w.effective_padding(which)\n",
                "\n",
                "    def effective_border(self) -> int:\n",
                "        if not self.windows:\n",
                "            return 0\n",
                "        w = self.windows[0]\n",
                "        return w.effective_border()\n",
                "\n",
                "    def set_geometry(self, geom: WindowGeometry) -> None:\n",
                "        for w in self.windows:\n",
                "            w.set_geometry(geom)\n",
                "\n",
                "    @property\n",
                "    def default_bg(self) -> int:\n",
                "        if self.windows:\n",
                "            w: WindowType = self.windows[-1]\n",
                "            return w.screen.color_profile.default_bg\n",
                "        return 0\n",
                "\n",
                "    @property\n",
                "    def geometry(self) -> Optional[WindowGeometry]:\n",
                "        if self.windows:\n",
                "            w: WindowType = self.windows[-1]\n",
                "            return w.geometry\n",
                "        return None\n",
                "\n",
                "    @property\n",
                "    def is_visible_in_layout(self) -> bool:\n",
                "        if self.windows:\n",
                "            w: WindowType = self.windows[-1]\n",
                "            return w.is_visible_in_layout\n",
                "        return False\n",
                "\n",
                "\n",
                "class WindowList:\n",
                "\n",
                "    def __init__(self, tab: TabType) -> None:\n",
                "        self.all_windows: List[WindowType] = []\n",
                "        self.id_map: Dict[int, WindowType] = {}\n",
                "        self.groups: List[WindowGroup] = []\n",
                "        self._active_group_idx: int = -1\n",
                "        self.active_group_history: Deque[int] = deque((), 64)\n",
                "        self.tabref = weakref.ref(tab)\n",
                "\n",
                "    def __len__(self) -> int:\n",
                "        return len(self.all_windows)\n",
                "\n",
                "    def __bool__(self) -> bool:\n",
                "        return bool(self.all_windows)\n",
                "\n",
                "    def __iter__(self) -> Iterator[WindowType]:\n",
                "        return iter(self.all_windows)\n",
                "\n",
                "    def __contains__(self, window: WindowOrId) -> bool:\n",
                "        q = window if isinstance(window, int) else window.id\n",
                "        return q in self.id_map\n",
                "\n",
                "    def serialize_state(self) -> Dict[str, Any]:\n",
                "        return {\n",
                "            'active_group_idx': self.active_group_idx,\n",
                "            'active_group_history': list(self.active_group_history),\n",
                "            'window_groups': [g.serialize_state() for g in self.groups]\n",
                "        }\n",
                "\n",
                "    @property\n",
                "    def active_group_idx(self) -> int:\n",
                "        return self._active_group_idx\n",
                "\n",
                "    @property\n",
                "    def active_window_history(self) -> List[int]:\n",
                "        ans = []\n",
                "        seen = set()\n",
                "        gid_map = {g.id: g for g in self.groups}\n",
                "        for gid in self.active_group_history:\n",
                "            g = gid_map.get(gid)\n",
                "            if g is not None:\n",
                "                w = g.active_window_id\n",
                "                if w > 0 and w not in seen:\n",
                "                    seen.add(w)\n",
                "                    ans.append(w)\n",
                "        return ans\n",
                "\n",
                "    def notify_on_active_window_change(self, old_active_window: Optional[WindowType], new_active_window: Optional[WindowType]) -> None:\n",
                "        if old_active_window is not None:\n",
                "            old_active_window.focus_changed(False)\n",
                "        if new_active_window is not None:\n",
                "            new_active_window.focus_changed(True)\n",
                "        tab = self.tabref()\n",
                "        if tab is not None:\n",
                "            tab.active_window_changed()\n",
                "\n",
                "    def set_active_group_idx(self, i: int, notify: bool = True) -> bool:\n",
                "        changed = False\n",
                "        if i != self._active_group_idx and 0 <= i < len(self.groups):\n",
                "            old_active_window = self.active_window\n",
                "            g = self.active_group\n",
                "            if g is not None:\n",
                "                with suppress(ValueError):\n",
                "                    self.active_group_history.remove(g.id)\n",
                "                self.active_group_history.append(g.id)\n",
                "            self._active_group_idx = i\n",
                "            new_active_window = self.active_window\n",
                "            if old_active_window is not new_active_window:\n",
                "                if notify:\n",
                "                    self.notify_on_active_window_change(old_active_window, new_active_window)\n",
                "                changed = True\n",
                "        return changed\n",
                "\n",
                "    def set_active_group(self, group_id: int) -> bool:\n",
                "        for i, gr in enumerate(self.groups):\n",
                "            if gr.id == group_id:\n",
                "                return self.set_active_group_idx(i)\n",
                "        return False\n",
                "\n",
                "    def change_tab(self, tab: TabType) -> None:\n",
                "        self.tabref = weakref.ref(tab)\n",
                "\n",
                "    def iter_windows_with_visibility(self) -> Iterator[Tuple[WindowType, bool]]:\n",
                "        for g in self.groups:\n",
                "            aw = g.active_window_id\n",
                "            for window in g:\n",
                "                yield window, window.id == aw\n",
                "\n",
                "    def iter_all_layoutable_groups(self, only_visible: bool = False) -> Iterator[WindowGroup]:\n",
                "        return iter(g for g in self.groups if g.is_visible_in_layout) if only_visible else iter(self.groups)\n",
                "\n",
                "    def iter_windows_with_number(self, only_visible: bool = True) -> Iterator[Tuple[int, WindowType]]:\n",
                "        for i, g in enumerate(self.groups):\n",
                "            if not only_visible or g.is_visible_in_layout:\n",
                "                aw = g.active_window_id\n",
                "                for window in g:\n",
                "                    if window.id == aw:\n",
                "                        yield i, window\n",
                "                        break\n",
                "\n",
                "    def make_previous_group_active(self, which: int = 1, notify: bool = True) -> None:\n",
                "        which = max(1, which)\n",
                "        gid_map = {g.id: i for i, g in enumerate(self.groups)}\n",
                "        num = len(self.active_group_history)\n",
                "        for i in range(num):\n",
                "            idx = num - i - 1\n",
                "            gid = self.active_group_history[idx]\n",
                "            x = gid_map.get(gid)\n",
                "            if x is not None:\n",
                "                which -= 1\n",
                "                if which < 1:\n",
                "                    self.set_active_group_idx(x, notify=notify)\n",
                "                    return\n",
                "        self.set_active_group_idx(len(self.groups) - 1, notify=notify)\n",
                "\n",
                "    @property\n",
                "    def num_groups(self) -> int:\n",
                "        return len(self.groups)\n",
                "\n",
                "    def group_for_window(self, x: WindowOrId) -> Optional[WindowGroup]:\n",
                "        q = self.id_map[x] if isinstance(x, int) else x\n",
                "        for g in self.groups:\n",
                "            if q in g:\n",
                "                return g\n",
                "        return None\n",
                "\n",
                "    def group_idx_for_window(self, x: WindowOrId) -> Optional[int]:\n",
                "        q = self.id_map[x] if isinstance(x, int) else x\n",
                "        for i, g in enumerate(self.groups):\n",
                "            if q in g:\n",
                "                return i\n",
                "        return None\n",
                "\n",
                "    def move_window_to_top_of_group(self, window: WindowType) -> bool:\n",
                "        g = self.group_for_window(window)\n",
                "        if g is None:\n",
                "            return False\n",
                "        before = self.active_window\n",
                "        if not g.move_window_to_top_of_group(window):\n",
                "            return False\n",
                "        after = self.active_window\n",
                "        changed = before is not after\n",
                "        if changed:\n",
                "            self.notify_on_active_window_change(before, after)\n",
                "        return changed\n",
                "\n",
                "    def windows_in_group_of(self, x: WindowOrId) -> Iterator[WindowType]:\n",
                "        g = self.group_for_window(x)\n",
                "        if g is not None:\n",
                "            return iter(g)\n",
                "        return iter(())\n",
                "\n",
                "    @property\n",
                "    def active_group(self) -> Optional[WindowGroup]:\n",
                "        with suppress(Exception):\n",
                "            return self.groups[self.active_group_idx]\n",
                "        return None\n",
                "\n",
                "    @property\n",
                "    def active_window(self) -> Optional[WindowType]:\n",
                "        with suppress(Exception):\n",
                "            return self.id_map[self.groups[self.active_group_idx].active_window_id]\n",
                "        return None\n",
                "\n",
                "    @property\n",
                "    def active_group_base(self) -> Optional[WindowType]:\n",
                "        with suppress(Exception):\n",
                "            return self.id_map[self.groups[self.active_group_idx].base_window_id]\n",
                "        return None\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    def set_active_window_group_for(self, x: WindowOrId) -> None:\n"
                ],
                "after": [
                    "    def set_active_window_group_for(self, x: WindowOrId, for_keep_focus: Optional[WindowType] = None) -> None:\n"
                ],
                "parent_version_range": {
                    "start": 305,
                    "end": 306
                },
                "child_version_range": {
                    "start": 305,
                    "end": 306
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "WindowList",
                        "signature": "class WindowList:",
                        "at_line": 134
                    },
                    {
                        "type": "function",
                        "name": "set_active_window_group_for",
                        "signature": "def set_active_window_group_for(self, x: WindowOrId)->None:",
                        "at_line": 305
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: kitty/window_list.py\nCode:\n           class WindowList:\n               ...\n302 302                return self.id_map[self.groups[self.active_group_idx].base_window_id]\n303 303            return None\n304 304    \n305      -     def set_active_window_group_for(self, x: WindowOrId) -> None:\n    305  +     def set_active_window_group_for(self, x: WindowOrId, for_keep_focus: Optional[WindowType] = None) -> None:\n306 306            try:\n307 307                q = self.id_map[x] if isinstance(x, int) else x\n308 308            except KeyError:\n         ...\n",
                "file_path": "kitty/window_list.py",
                "identifiers_before": [
                    "WindowOrId",
                    "self",
                    "set_active_window_group_for",
                    "x"
                ],
                "identifiers_after": [
                    "Optional",
                    "WindowOrId",
                    "WindowType",
                    "for_keep_focus",
                    "self",
                    "set_active_window_group_for",
                    "x"
                ],
                "prefix": [
                    "            return self.id_map[self.groups[self.active_group_idx].base_window_id]\n",
                    "        return None\n",
                    "\n"
                ],
                "suffix": [
                    "        try:\n",
                    "            q = self.id_map[x] if isinstance(x, int) else x\n",
                    "        except KeyError:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "set_active_window_group_for",
                            "position": {
                                "start": {
                                    "line": 305,
                                    "column": 8
                                },
                                "end": {
                                    "line": 305,
                                    "column": 35
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "set_active_window_group_for",
                            "position": {
                                "start": {
                                    "line": 305,
                                    "column": 8
                                },
                                "end": {
                                    "line": 305,
                                    "column": 35
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 305,
                                    "column": 57
                                },
                                "end": {
                                    "line": 305,
                                    "column": 71
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 305,
                                    "column": 57
                                },
                                "end": {
                                    "line": 305,
                                    "column": 71
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 305,
                                    "column": 57
                                },
                                "end": {
                                    "line": 305,
                                    "column": 71
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 305,
                                    "column": 57
                                },
                                "end": {
                                    "line": 305,
                                    "column": 71
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 305,
                                    "column": 36
                                },
                                "end": {
                                    "line": 305,
                                    "column": 40
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "        try:\n",
                "            q = self.id_map[x] if isinstance(x, int) else x\n",
                "        except KeyError:\n",
                "            return\n",
                "        for i, group in enumerate(self.groups):\n",
                "            if q in group:\n",
                "                self.set_active_group_idx(i)\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "                h = self.active_group_history\n",
                    "                if for_keep_focus and len(h) > 2 and h[-2] == for_keep_focus.id and h[-1] != for_keep_focus.id:\n",
                    "                    h.pop()\n",
                    "                    h.pop()\n"
                ],
                "parent_version_range": {
                    "start": 313,
                    "end": 313
                },
                "child_version_range": {
                    "start": 313,
                    "end": 317
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for i, group in enumerate(self.groups):",
                        "start_line": 310,
                        "end_line": 313
                    },
                    {
                        "type": "if_statement",
                        "statement": "if q in group:",
                        "start_line": 311,
                        "end_line": 313
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "WindowList",
                        "signature": "class WindowList:",
                        "at_line": 134
                    },
                    {
                        "type": "function",
                        "name": "set_active_window_group_for",
                        "signature": "def set_active_window_group_for(self, x: WindowOrId)->None:",
                        "at_line": 305
                    },
                    {
                        "type": "call",
                        "name": "self.set_active_group_idx",
                        "signature": "self.set_active_group_idx(i)",
                        "at_line": 312,
                        "argument": "i"
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: kitty/window_list.py\nCode:\n           class WindowList:\n               ...\n               def set_active_window_group_for(self, x: WindowOrId)->None:\n                   ...\n310 310            for i, group in enumerate(self.groups):\n311 311                if q in group:\n312 312                    self.set_active_group_idx(i)\n    313  +                 h = self.active_group_history\n    314  +                 if for_keep_focus and len(h) > 2 and h[-2] == for_keep_focus.id and h[-1] != for_keep_focus.id:\n    315  +                     h.pop()\n    316  +                     h.pop()\n313 317                    break\n314 318    \n315 319        def add_window(\n         ...\n",
                "file_path": "kitty/window_list.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "active_group_history",
                    "for_keep_focus",
                    "h",
                    "id",
                    "len",
                    "pop",
                    "self"
                ],
                "prefix": [
                    "        for i, group in enumerate(self.groups):\n",
                    "            if q in group:\n",
                    "                self.set_active_group_idx(i)\n"
                ],
                "suffix": [
                    "                break\n",
                    "\n",
                    "    def add_window(\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 314,
                                    "column": 19
                                },
                                "end": {
                                    "line": 314,
                                    "column": 33
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 314,
                                    "column": 62
                                },
                                "end": {
                                    "line": 314,
                                    "column": 76
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "for_keep_focus",
                            "position": {
                                "start": {
                                    "line": 314,
                                    "column": 93
                                },
                                "end": {
                                    "line": 314,
                                    "column": 107
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 313,
                                    "column": 20
                                },
                                "end": {
                                    "line": 313,
                                    "column": 24
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/window_list.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    5
                ]
            },
            [
                "                break\n",
                "\n",
                "    def add_window(\n",
                "        self,\n",
                "        window: WindowType,\n",
                "        group_of: Optional[WindowOrId] = None,\n",
                "        next_to: Optional[WindowOrId] = None,\n",
                "        before: bool = False,\n",
                "        make_active: bool = True,\n",
                "        head_of_group: bool = False,\n",
                "    ) -> WindowGroup:\n",
                "        self.all_windows.append(window)\n",
                "        self.id_map[window.id] = window\n",
                "        target_group: Optional[WindowGroup] = None\n",
                "\n",
                "        if group_of is not None:\n",
                "            target_group = self.group_for_window(group_of)\n",
                "        if target_group is None and next_to is not None:\n",
                "            q = self.id_map[next_to] if isinstance(next_to, int) else next_to\n",
                "            pos = -1\n",
                "            for i, g in enumerate(self.groups):\n",
                "                if q in g:\n",
                "                    pos = i\n",
                "                    break\n",
                "            if pos > -1:\n",
                "                target_group = WindowGroup()\n",
                "                self.groups.insert(pos + (0 if before else 1), target_group)\n",
                "        if target_group is None:\n",
                "            target_group = WindowGroup()\n",
                "            if before:\n",
                "                self.groups.insert(0, target_group)\n",
                "            else:\n",
                "                self.groups.append(target_group)\n",
                "\n",
                "        old_active_window = self.active_window\n",
                "        target_group.add_window(window, head_of_group=head_of_group)\n",
                "        if make_active:\n",
                "            for i, g in enumerate(self.groups):\n",
                "                if g is target_group:\n",
                "                    self.set_active_group_idx(i, notify=False)\n",
                "                    break\n",
                "        new_active_window = self.active_window\n",
                "        if new_active_window is not old_active_window:\n",
                "            self.notify_on_active_window_change(old_active_window, new_active_window)\n",
                "        return target_group\n",
                "\n",
                "    def remove_window(self, x: WindowOrId) -> None:\n",
                "        old_active_window = self.active_window\n",
                "        q = self.id_map[x] if isinstance(x, int) else x\n",
                "        try:\n",
                "            self.all_windows.remove(q)\n",
                "        except ValueError:\n",
                "            pass\n",
                "        self.id_map.pop(q.id, None)\n",
                "        for i, g in enumerate(tuple(self.groups)):\n",
                "            g.remove_window(q)\n",
                "            if not g:\n",
                "                del self.groups[i]\n",
                "                if self.groups:\n",
                "                    if self.active_group_idx == i:\n",
                "                        self.make_previous_group_active(notify=False)\n",
                "                    elif self.active_group_idx >= len(self.groups):\n",
                "                        self._active_group_idx -= 1\n",
                "                else:\n",
                "                    self._active_group_idx = -1\n",
                "                break\n",
                "        new_active_window = self.active_window\n",
                "        if old_active_window is not new_active_window:\n",
                "            self.notify_on_active_window_change(old_active_window, new_active_window)\n",
                "\n",
                "    def active_window_in_nth_group(self, n: int, clamp: bool = False) -> Optional[WindowType]:\n",
                "        if clamp:\n",
                "            n = max(0, min(n, self.num_groups - 1))\n",
                "        if 0 <= n < self.num_groups:\n",
                "            return self.id_map.get(self.groups[n].active_window_id)\n",
                "        return None\n",
                "\n",
                "    def activate_next_window_group(self, delta: int) -> None:\n",
                "        self.set_active_group_idx(wrap_increment(self.active_group_idx, self.num_groups, delta))\n",
                "\n",
                "    def move_window_group(self, by: Optional[int] = None, to_group: Optional[int] = None) -> bool:\n",
                "        if self.active_group_idx < 0 or not self.groups:\n",
                "            return False\n",
                "        target = -1\n",
                "        if by is not None:\n",
                "            target = wrap_increment(self.active_group_idx, self.num_groups, by)\n",
                "        if to_group is not None:\n",
                "            for i, group in enumerate(self.groups):\n",
                "                if group.id == to_group:\n",
                "                    target = i\n",
                "                    break\n",
                "        if target > -1:\n",
                "            if target == self.active_group_idx:\n",
                "                return False\n",
                "            self.groups[self.active_group_idx], self.groups[target] = self.groups[target], self.groups[self.active_group_idx]\n",
                "            self.set_active_group_idx(target)\n",
                "            return True\n",
                "        return False\n",
                "\n",
                "    def compute_needs_borders_map(self, draw_active_borders: bool) -> Dict[int, bool]:\n",
                "        ag = self.active_group\n",
                "        return {gr.id: ((gr is ag and draw_active_borders) or gr.needs_attention) for gr in self.groups}\n",
                "\n",
                "    @property\n",
                "    def num_visble_groups(self) -> int:\n",
                "        ans = 0\n",
                "        for gr in self.groups:\n",
                "            if gr.is_visible_in_layout:\n",
                "                ans += 1\n",
                "        return ans"
            ]
        ]
    },
    "edit_order": [
        [
            0,
            1,
            3,
            2,
            4,
            5,
            6,
            7
        ],
        [
            2,
            3,
            4,
            5,
            0,
            1,
            6,
            7
        ]
    ],
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "The function `set_active_tabs` has been modified to accept an additional argument.",
            "scenario of 0 -> 1": "edit 0 adds a new argument, which was then used in edit 1.",
            "scenario of 1 -> 0": "edit 1 uses the new argument first, then edit 0 introduces the new argument."
        },
        {
            "edit_hunk_pair": [
                0,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "The function `set_active_tabs` has been modified to accept an additional argument.",
            "scenario of 0 -> 1": "edit 0 adds a new argument, which was then used in edit 1.",
            "scenario of 1 -> 0": "edit 1 uses the new argument first, then edit 0 introduces the new argument."
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "The function `set_active_tabs` in the class `Tabs` in the file `kitty/tabs.py` has been modified to accept an additional argument `for_keep_focus` of type `Optional[Tab]`.",
            "scenario of 0 -> 1": "edit 0 adds a new argument, which was then used in edit 1.",
            "scenario of 1 -> 0": "edit 1 uses the new argument first, then edit 0 introduces the new argument."
        },
        {
            "edit_hunk_pair": [
                6,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "The function `set_active_window_group_for` in the class `WindowList` in the file `kitty/window_list.py` has been modified to accept an additional argument `for_keep_focus` of type `Optional[WindowType]`.",
            "scenario of 0 -> 1": "edit 0 adds a new argument, which was then used in edit 1.",
            "scenario of 1 -> 0": "edit 1 uses the new argument first, then edit 0 introduces the new argument."
        },
        {
            "edit_hunk_pair": [
                5,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "code clones",
            "scenario of 0 -> 1": "edit 0 updates the logic first, then copied pasted it to edit 1.",
            "scenario of 1 -> 0": "edit 1 updates the logic first, then copied pasted it to edit 0."
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "propagation of set_active_window",
            "scenario of 0 -> 1": "implement before use",
            "scenario of 1 -> 0": "use before implement"
        },
        {
            "edit_hunk_pair": [
                1,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "dependency of set_active_window",
            "scenario of 0 -> 1": "define before use",
            "scenario of 1 -> 0": "use before define"
        },
        {
            "edit_hunk_pair": [
                7,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "dependency of set_active_window",
            "scenario of 0 -> 1": "use before define",
            "scenario of 1 -> 0": "define before use"
        },
        {
            "edit_hunk_pair": [
                1,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "dependency of set_active_tab",
            "scenario of 0 -> 1": "use before define",
            "scenario of 1 -> 0": "define before use"
        },
        {
            "edit_hunk_pair": [
                1,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "dependency of set_active_tab",
            "scenario of 0 -> 1": "use before define",
            "scenario of 1 -> 0": "define before use"
        },
        {
            "edit_hunk_pair": [
                3,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "dependency of set_active_window_group_for",
            "scenario of 0 -> 1": "use before define",
            "scenario of 1 -> 0": "define before use"
        }
    ]
}