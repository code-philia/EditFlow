{
    "language": "python",
    "commit_url": "https://github.com/sqlmapproject/sqlmap/commit/7c06dbffc3f037785bc9530e74771997f8d555fd",
    "commit_message": "bug fix (AttributeError: 'unicode' object has no attribute 'sort')",
    "commit_snapshots": {
        "lib/core/common.py": [
            [
                "#!/usr/bin/env python\n",
                "\n",
                "\"\"\"\n",
                "$Id$\n",
                "\n",
                "Copyright (c) 2006-2010 sqlmap developers (http://sqlmap.sourceforge.net/)\n",
                "See the file 'doc/COPYING' for copying permission\n",
                "\"\"\"\n",
                "\n",
                "import codecs\n",
                "import ctypes\n",
                "import inspect\n",
                "import os\n",
                "import random\n",
                "import re\n",
                "import socket\n",
                "import string\n",
                "import sys\n",
                "import time\n",
                "import urlparse\n",
                "import ntpath\n",
                "import posixpath\n",
                "import subprocess\n",
                "import threading\n",
                "\n",
                "from ConfigParser import DEFAULTSECT\n",
                "from ConfigParser import RawConfigParser\n",
                "from StringIO import StringIO\n",
                "from difflib import SequenceMatcher\n",
                "from inspect import getmembers\n",
                "from math import sqrt\n",
                "from subprocess import PIPE\n",
                "from subprocess import Popen as execute\n",
                "from tempfile import NamedTemporaryFile\n",
                "from tempfile import mkstemp\n",
                "from xml.etree import ElementTree as ET\n",
                "from xml.dom import minidom\n",
                "from xml.sax import parse\n",
                "\n",
                "from extra.cloak.cloak import decloak\n",
                "from lib.contrib import magic\n",
                "from lib.core.data import conf\n",
                "from lib.core.data import dbmsDict\n",
                "from lib.core.data import kb\n",
                "from lib.core.data import logger\n",
                "from lib.core.data import paths\n",
                "from lib.core.data import queries\n",
                "from lib.core.convert import htmlunescape\n",
                "from lib.core.convert import urlencode\n",
                "from lib.core.enums import DBMS\n",
                "from lib.core.enums import PLACE\n",
                "from lib.core.enums import PAYLOAD\n",
                "from lib.core.exception import sqlmapFilePathException\n",
                "from lib.core.exception import sqlmapGenericException\n",
                "from lib.core.exception import sqlmapNoneDataException\n",
                "from lib.core.exception import sqlmapMissingDependence\n",
                "from lib.core.exception import sqlmapSyntaxException\n",
                "from lib.core.optiondict import optDict\n",
                "from lib.core.settings import DESCRIPTION\n",
                "from lib.core.settings import IS_WIN\n",
                "from lib.core.settings import PLATFORM\n",
                "from lib.core.settings import SITE\n",
                "from lib.core.settings import SQL_STATEMENTS\n",
                "from lib.core.settings import SUPPORTED_DBMS\n",
                "from lib.core.settings import UNKNOWN_DBMS_VERSION\n",
                "from lib.core.settings import VERSION_STRING\n",
                "from lib.core.settings import DUMP_NEWLINE_MARKER\n",
                "from lib.core.settings import DUMP_CR_MARKER\n",
                "from lib.core.settings import DUMP_DEL_MARKER\n",
                "from lib.core.settings import DUMP_TAB_MARKER\n",
                "from lib.core.settings import DUMP_START_MARKER\n",
                "from lib.core.settings import DUMP_STOP_MARKER\n",
                "from lib.core.settings import MIN_TIME_RESPONSES\n",
                "from lib.core.settings import TIME_STDEV_COEFF\n",
                "\n",
                "class UnicodeRawConfigParser(RawConfigParser):\n",
                "    \"\"\"\n",
                "    RawConfigParser with unicode writing support\n",
                "    \"\"\"\n",
                "    def write(self, fp):\n",
                "        \"\"\"\n",
                "        Write an .ini-format representation of the configuration state.\n",
                "        \"\"\"\n",
                "\n",
                "        if self._defaults:\n",
                "            fp.write(\"[%s]\\n\" % DEFAULTSECT)\n",
                "\n",
                "            for (key, value) in self._defaults.items():\n",
                "                fp.write(\"%s = %s\\n\" % (key, getUnicode(value).replace('\\n', '\\n\\t')))\n",
                "\n",
                "            fp.write(\"\\n\")\n",
                "\n",
                "        for section in self._sections:\n",
                "            fp.write(\"[%s]\\n\" % section)\n",
                "\n",
                "            for (key, value) in self._sections[section].items():\n",
                "                if key != \"__name__\":\n",
                "                    if value is None:\n",
                "                        fp.write(\"%s\\n\" % (key))\n",
                "                    else:\n",
                "                        fp.write(\"%s = %s\\n\" % (key, getUnicode(value).replace('\\n', '\\n\\t')))\n",
                "\n",
                "            fp.write(\"\\n\")\n",
                "\n",
                "\n",
                "class DynamicContentItem:\n",
                "    \"\"\"\n",
                "    Represents line in content page with dynamic properties (candidate for removal prior detection phase)\n",
                "    \"\"\"\n",
                "\n",
                "    def __init__(self, lineNumber, pageTotal, lineContentBefore, lineContentAfter):\n",
                "        self.lineNumber = lineNumber\n",
                "        self.pageTotal = pageTotal\n",
                "        self.lineContentBefore = lineContentBefore\n",
                "        self.lineContentAfter = lineContentAfter\n",
                "\n",
                "\n",
                "class ThreadData():\n",
                "    \"\"\"\n",
                "    Represents thread independent data\n",
                "    \"\"\"\n",
                "\n",
                "    def __init__(self):\n",
                "        self.lastErrorPage = None\n",
                "        self.lastQueryDuration = 0\n",
                "        self.lastRequestUID = 0\n",
                "        self.valueStack = []\n",
                "\n",
                "def paramToDict(place, parameters=None):\n",
                "    \"\"\"\n",
                "    Split the parameters into names and values, check if these parameters\n",
                "    are within the testable parameters and return in a dictionary.\n",
                "\n",
                "    @param place: where sqlmap has to work, can be GET, POST or Cookie.\n",
                "    @type place: C{str}\n",
                "\n",
                "    @param parameters: parameters string in the format for instance\n",
                "    'p1=v1&p2=v2' (GET and POST) or 'p1=v1;p2=v2' (Cookie).\n",
                "    @type parameters: C{str}\n",
                "\n",
                "    @return: the parameters in a dictionary.\n",
                "    @rtype: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    testableParameters = {}\n",
                "\n",
                "    if conf.parameters.has_key(place) and not parameters:\n",
                "        parameters = conf.parameters[place]\n",
                "\n",
                "    if place is not \"POSTxml\":\n",
                "        parameters = parameters.replace(\", \", \",\")\n",
                "\n",
                "        if place == PLACE.COOKIE:\n",
                "            splitParams = parameters.split(\";\")\n",
                "        else:\n",
                "            splitParams = parameters.split(\"&\")\n",
                "\n",
                "        for element in splitParams:\n",
                "            elem = element.split(\"=\")\n",
                "\n",
                "            if len(elem) == 2:\n",
                "                parameter = elem[0].replace(\" \", \"\")\n",
                "\n",
                "                condition  = not conf.testParameter\n",
                "                condition |= parameter in conf.testParameter\n",
                "\n",
                "                if condition:\n",
                "                    testableParameters[parameter] = elem[1]\n",
                "    else:\n",
                "        root = ET.XML(parameters)\n",
                "        iterator = root.getiterator()\n",
                "\n",
                "        for child in iterator:\n",
                "            parameter = child.tag\n",
                "\n",
                "            if \"}\" in parameter:\n",
                "                testParam = parameter.split(\"}\")[1]\n",
                "            else:\n",
                "                testParam = parameter\n",
                "\n",
                "            condition = not conf.testParameter\n",
                "            condition |= testParam in conf.testParameter\n",
                "\n",
                "            if condition:\n",
                "                testableParameters[parameter] = child.text\n",
                "\n",
                "    if conf.testParameter and not testableParameters:\n",
                "        paramStr = \", \".join(test for test in conf.testParameter)\n",
                "\n",
                "        if len(conf.testParameter) > 1:\n",
                "            warnMsg  = \"the testable parameters '%s' \" % paramStr\n",
                "            warnMsg += \"you provided are not into the %s\" % place\n",
                "        else:\n",
                "            parameter = conf.testParameter[0]\n",
                "\n",
                "            warnMsg  = \"the testable parameter '%s' \" % paramStr\n",
                "            warnMsg += \"you provided is not into the %s\" % place\n",
                "\n",
                "        logger.warn(warnMsg)\n",
                "\n",
                "    elif len(conf.testParameter) != len(testableParameters.keys()):\n",
                "        for parameter in conf.testParameter:\n",
                "            if not testableParameters.has_key(parameter):\n",
                "                warnMsg  =  \"the testable parameter '%s' \" % parameter\n",
                "                warnMsg += \"you provided is not into the %s\" % place\n",
                "                logger.warn(warnMsg)\n",
                "\n",
                "    return testableParameters\n",
                "\n",
                "def formatDBMSfp(versions=None):\n",
                "    \"\"\"\n",
                "    This function format the back-end DBMS fingerprint value and return its\n",
                "    values formatted as a human readable string.\n",
                "\n",
                "    @return: detected back-end DBMS based upon fingerprint techniques.\n",
                "    @rtype: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    while versions and None in versions:\n",
                "        versions.remove(None)\n",
                "\n",
                "    if not versions and kb.dbmsVersion and kb.dbmsVersion[0] != UNKNOWN_DBMS_VERSION and kb.dbmsVersion[0] != None:\n",
                "        versions = kb.dbmsVersion\n",
                "\n",
                "    if isinstance(versions, basestring):\n",
                "        return \"%s %s\" % (kb.dbms, versions)\n",
                "    elif isinstance(versions, (list, set, tuple)):\n",
                "        return \"%s %s\" % (kb.dbms, \" and \".join([version for version in versions]))\n",
                "    elif not versions:\n",
                "        warnMsg  = \"unable to extensively fingerprint the back-end \"\n",
                "        warnMsg += \"DBMS version\"\n",
                "        logger.warn(warnMsg)\n",
                "\n",
                "        return kb.dbms\n",
                "\n",
                "def formatFingerprintString(values, chain=\" or \"):\n",
                "    strJoin = \"|\".join([v for v in values])\n",
                "\n",
                "    return strJoin.replace(\"|\", chain)\n",
                "\n",
                "def formatFingerprint(target, info):\n",
                "    \"\"\"\n",
                "    This function format the back-end operating system fingerprint value\n",
                "    and return its values formatted as a human readable string.\n",
                "\n",
                "    Example of info (kb.headersFp) dictionary:\n",
                "\n",
                "    {\n",
                "      'distrib': set(['Ubuntu']),\n",
                "      'type': set(['Linux']),\n",
                "      'technology': set(['PHP 5.2.6', 'Apache 2.2.9']),\n",
                "      'release': set(['8.10'])\n",
                "    }\n",
                "\n",
                "    Example of info (kb.bannerFp) dictionary:\n",
                "\n",
                "    {\n",
                "      'sp': set(['Service Pack 4']),\n",
                "      'dbmsVersion': '8.00.194',\n",
                "      'dbmsServicePack': '0',\n",
                "      'distrib': set(['2000']),\n",
                "      'dbmsRelease': '2000',\n",
                "      'type': set(['Windows'])\n",
                "    }\n",
                "\n",
                "    @return: detected back-end operating system based upon fingerprint\n",
                "    techniques.\n",
                "    @rtype: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    infoStr = \"\"\n",
                "\n",
                "    if info and \"type\" in info:\n",
                "        infoStr += \"%s operating system: %s\" % (target, formatFingerprintString(info[\"type\"]))\n",
                "\n",
                "        if \"distrib\" in info:\n",
                "            infoStr += \" %s\" % formatFingerprintString(info[\"distrib\"])\n",
                "\n",
                "        if \"release\" in info:\n",
                "            infoStr += \" %s\" % formatFingerprintString(info[\"release\"])\n",
                "\n",
                "        if \"sp\" in info:\n",
                "            infoStr += \" %s\" % formatFingerprintString(info[\"sp\"])\n",
                "\n",
                "        if \"codename\" in info:\n",
                "            infoStr += \" (%s)\" % formatFingerprintString(info[\"codename\"])\n",
                "\n",
                "    if \"technology\" in info:\n",
                "        infoStr += \"\\nweb application technology: %s\" % formatFingerprintString(info[\"technology\"], \", \")\n",
                "\n",
                "    return infoStr\n",
                "\n",
                "def getHtmlErrorFp():\n",
                "    \"\"\"\n",
                "    This function parses the knowledge base htmlFp list and return its\n",
                "    values formatted as a human readable string.\n",
                "\n",
                "    @return: list of possible back-end DBMS based upon error messages\n",
                "    parsing.\n",
                "    @rtype: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    htmlParsed = \"\"\n",
                "\n",
                "    if not kb.htmlFp:\n",
                "        return None\n",
                "\n",
                "    if len(kb.htmlFp) == 1:\n",
                "        htmlVer = kb.htmlFp[0]\n",
                "        htmlParsed = htmlVer\n",
                "    elif len(kb.htmlFp) > 1:\n",
                "        htmlParsed = \" or \".join([htmlFp for htmlFp in kb.htmlFp])\n",
                "\n",
                "    return htmlParsed\n",
                "\n",
                "def getDocRoot(webApi=None):\n",
                "    docRoot = None\n",
                "    pagePath = directoryPath(conf.path)\n",
                "\n",
                "    if kb.os == \"Windows\":\n",
                "        if webApi in (\"php\", \"jsp\"):\n",
                "            defaultDocRoot = \"C:/xampp/htdocs/\"\n",
                "        else:\n",
                "            defaultDocRoot = \"C:/Inetpub/wwwroot/\"\n",
                "    else:\n",
                "        defaultDocRoot = \"/var/www/\"\n",
                "\n",
                "    if kb.absFilePaths:\n",
                "        for absFilePath in kb.absFilePaths:\n",
                "            if directoryPath(absFilePath) == '/':\n",
                "                continue\n",
                "\n",
                "            absFilePath = normalizePath(absFilePath)\n",
                "            absFilePathWin = None\n",
                "\n",
                "            if isWindowsPath(absFilePath):\n",
                "                absFilePathWin = posixToNtSlashes(absFilePath)\n",
                "                absFilePath    = ntToPosixSlashes(absFilePath[2:])\n",
                "            elif isWindowsDriveLetterPath(absFilePath): # E.g. C:/xampp/htdocs\n",
                "                absFilePath    = absFilePath[2:]\n",
                "\n",
                "            if pagePath in absFilePath:\n",
                "                index   = absFilePath.index(pagePath)\n",
                "                docRoot = absFilePath[:index]\n",
                "\n",
                "                if len(docRoot) == 0:\n",
                "                    docRoot = None\n",
                "                    continue\n",
                "\n",
                "                if absFilePathWin:\n",
                "                    docRoot = \"C:/%s\" % ntToPosixSlashes(docRoot)\n",
                "\n",
                "                docRoot = normalizePath(docRoot)\n",
                "                break\n",
                "\n",
                "    if docRoot:\n",
                "        infoMsg = \"retrieved the web server document root: '%s'\" % docRoot\n",
                "        logger.info(infoMsg)\n",
                "    else:\n",
                "        warnMsg = \"unable to retrieve the web server document root\"\n",
                "        logger.warn(warnMsg)\n",
                "\n",
                "        message  = \"please provide the web server document root \"\n",
                "        message += \"[%s]: \" % defaultDocRoot\n",
                "        inputDocRoot = readInput(message, default=defaultDocRoot)\n",
                "\n",
                "        if inputDocRoot:\n",
                "            docRoot = inputDocRoot\n",
                "        else:\n",
                "            docRoot = defaultDocRoot\n",
                "\n",
                "    return docRoot\n",
                "\n",
                "def getDirs(webApi=None):\n",
                "    directories = set()\n",
                "\n",
                "    if kb.os == \"Windows\":\n",
                "        if webApi in (\"php\", \"jsp\"):\n",
                "            defaultDirs = [\"C:/xampp/htdocs/\"]\n",
                "        else:\n",
                "            defaultDirs = [\"C:/Inetpub/wwwroot/\"]\n",
                "    else:\n",
                "        defaultDirs = [\"/var/www/\"]\n",
                "\n",
                "    if kb.docRoot and kb.docRoot not in defaultDirs:\n",
                "        defaultDirs.append(kb.docRoot)\n",
                "\n",
                "    if kb.absFilePaths:\n",
                "        infoMsg  = \"retrieved web server full paths: \"\n",
                "        infoMsg += \"'%s'\" % \", \".join(path for path in kb.absFilePaths)\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        for absFilePath in kb.absFilePaths:\n",
                "            if absFilePath:\n",
                "                directory = directoryPath(absFilePath)\n",
                "\n",
                "                if isWindowsPath(directory):\n",
                "                    directory = ntToPosixSlashes(directory)\n",
                "\n",
                "                if directory == '/':\n",
                "                    continue\n",
                "\n",
                "                directories.add(directory)\n",
                "    else:\n",
                "        warnMsg = \"unable to retrieve any web server path\"\n",
                "        logger.warn(warnMsg)\n",
                "\n",
                "    message   = \"please provide any additional web server full path to try \"\n",
                "    message  += \"to upload the agent [%s]: \" % \",\".join(directory for directory in defaultDirs)\n",
                "    inputDirs = readInput(message, default=\",\".join(directory for directory in defaultDirs))\n",
                "\n",
                "    if inputDirs:\n",
                "        inputDirs = inputDirs.replace(\", \", \",\")\n",
                "        inputDirs = inputDirs.split(\",\")\n",
                "\n",
                "        for inputDir in inputDirs:\n",
                "            if inputDir:\n",
                "                directories.add(inputDir)\n",
                "    else:\n",
                "        [directories.add(directory) for directory in defaultDirs]\n",
                "\n",
                "    return directories\n",
                "\n",
                "def filePathToString(filePath):\n",
                "    strRepl = filePath.replace(\"/\", \"_\").replace(\"\\\\\", \"_\")\n",
                "    strRepl = strRepl.replace(\" \", \"_\").replace(\":\", \"_\")\n",
                "\n",
                "    return strRepl\n",
                "\n",
                "def dataToStdout(data, forceOutput=False):\n",
                "    if (forceOutput or conf.verbose > 0)\\\n",
                "        and not ('threadException' in kb and kb.threadException)\\\n",
                "        and not ('disableStdOut' in kb and kb.disableStdOut):\n",
                "        try:\n",
                "            sys.stdout.write(data)\n",
                "            sys.stdout.flush()\n",
                "        except UnicodeEncodeError:\n",
                "            print data.encode(conf.dataEncoding)\n",
                "\n",
                "def dataToSessionFile(data):\n",
                "    if not conf.sessionFile:\n",
                "        return\n",
                "\n",
                "    conf.sessionFP.write(data)\n",
                "    conf.sessionFP.flush()\n",
                "\n",
                "def dataToTrafficFile(data):\n",
                "    if not conf.trafficFile:\n",
                "        return\n",
                "\n",
                "    conf.trafficFP.write(data)\n",
                "    conf.trafficFP.flush()\n",
                "\n",
                "def dataToDumpFile(dumpFile, data):\n",
                "    dumpFile.write(data)\n",
                "    dumpFile.flush()\n",
                "\n",
                "def dataToOutFile(data):\n",
                "    if not data:\n",
                "        return \"No data retrieved\"\n",
                "\n",
                "    rFile = filePathToString(conf.rFile)\n",
                "    rFilePath = \"%s%s%s\" % (conf.filePath, os.sep, rFile)\n",
                "    rFileFP = codecs.open(rFilePath, \"wb\")\n",
                "\n",
                "    rFileFP.write(data)\n",
                "    rFileFP.flush()\n",
                "    rFileFP.close()\n",
                "\n",
                "    return rFilePath\n",
                "\n",
                "def strToHex(inpStr):\n",
                "    \"\"\"\n",
                "    @param inpStr: inpStr to be converted into its hexadecimal value.\n",
                "    @type inpStr: C{str}\n",
                "\n",
                "    @return: the hexadecimal converted inpStr.\n",
                "    @rtype: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    hexStr = \"\"\n",
                "\n",
                "    for character in inpStr:\n",
                "        if character == \"\\n\":\n",
                "            character = \" \"\n",
                "\n",
                "        hexChar = \"%2x\" % ord(character)\n",
                "        hexChar = hexChar.replace(\" \", \"0\")\n",
                "        hexChar = hexChar.upper()\n",
                "\n",
                "        hexStr += hexChar\n",
                "\n",
                "    return hexStr\n",
                "\n",
                "def readInput(message, default=None):\n",
                "    \"\"\"\n",
                "    @param message: message to display on terminal.\n",
                "    @type message: C{str}\n",
                "\n",
                "    @return: a string read from keyboard as input.\n",
                "    @rtype: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    if \"\\n\" in message:\n",
                "        message += \"\\n> \"\n",
                "    elif message[-1] == ']':\n",
                "        message += \" \"\n",
                "\n",
                "    if conf.batch and default:\n",
                "        infoMsg = \"%s%s\" % (message, getUnicode(default))\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        debugMsg = \"used the default behaviour, running in batch mode\"\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "        data = default\n",
                "    else:\n",
                "        data = raw_input(message.encode(sys.stdout.encoding))\n",
                "\n",
                "        if not data:\n",
                "            data = default\n",
                "\n",
                "    return data\n",
                "\n",
                "def randomRange(start=0, stop=1000):\n",
                "    \"\"\"\n",
                "    @param start: starting number.\n",
                "    @type start: C{int}\n",
                "\n",
                "    @param stop: last number.\n",
                "    @type stop: C{int}\n",
                "\n",
                "    @return: a random number within the range.\n",
                "    @rtype: C{int}\n",
                "    \"\"\"\n",
                "\n",
                "    return int(random.randint(start, stop))\n",
                "\n",
                "def randomInt(length=4):\n",
                "    \"\"\"\n",
                "    @param length: length of the random string.\n",
                "    @type length: C{int}\n",
                "\n",
                "    @return: a random string of digits.\n",
                "    @rtype: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    return int(\"\".join([random.choice(string.digits) for _ in xrange(0, length)]))\n",
                "\n",
                "def randomStr(length=4, lowercase=False, alphabet=None):\n",
                "    \"\"\"\n",
                "    @param length: length of the random string.\n",
                "    @type length: C{int}\n",
                "\n",
                "    @return: a random string of characters.\n",
                "    @rtype: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    if alphabet:\n",
                "        rndStr = \"\".join([random.choice(alphabet) for _ in xrange(0, length)])    \n",
                "    elif lowercase:\n",
                "        rndStr = \"\".join([random.choice(string.lowercase) for _ in xrange(0, length)])\n",
                "    else:\n",
                "        rndStr = \"\".join([random.choice(string.letters) for _ in xrange(0, length)])\n",
                "\n",
                "    return rndStr\n",
                "\n",
                "def sanitizeStr(inpStr):\n",
                "    \"\"\"\n",
                "    @param inpStr: inpStr to sanitize: cast to str datatype and replace\n",
                "    newlines with one space and strip carriage returns.\n",
                "    @type inpStr: C{str}\n",
                "\n",
                "    @return: sanitized inpStr\n",
                "    @rtype: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    cleanString = getUnicode(inpStr)\n",
                "    cleanString = cleanString.replace(\"\\n\", \" \").replace(\"\\r\", \"\")\n",
                "\n",
                "    return cleanString\n",
                "\n",
                "def checkFile(filename):\n",
                "    \"\"\"\n",
                "    @param filename: filename to check if it exists.\n",
                "    @type filename: C{str}\n",
                "    \"\"\"\n",
                "\n",
                "    if not os.path.exists(filename):\n",
                "        raise sqlmapFilePathException, \"unable to read file '%s'\" % filename\n",
                "\n",
                "def replaceNewlineTabs(inpStr, stdout=False):\n",
                "    if inpStr is None:\n",
                "        return\n",
                "\n",
                "    if stdout:\n",
                "        replacedString = inpStr.replace(\"\\n\", \" \").replace(\"\\r\", \" \").replace(\"\\t\", \" \")\n",
                "    else:\n",
                "        replacedString = inpStr.replace(\"\\n\", DUMP_NEWLINE_MARKER).replace(\"\\r\", DUMP_CR_MARKER).replace(\"\\t\", DUMP_TAB_MARKER)\n",
                "\n",
                "    replacedString = replacedString.replace(kb.misc.delimiter, DUMP_DEL_MARKER)\n",
                "\n",
                "    return replacedString\n",
                "\n",
                "def restoreDumpMarkedChars(inpStr, onlyNewlineTab=False):\n",
                "    replacedString = inpStr\n",
                "\n",
                "    if isinstance(replacedString, basestring):\n",
                "        replacedString = replacedString.replace(DUMP_NEWLINE_MARKER, \"\\n\").replace(DUMP_CR_MARKER, \"\\r\").replace(DUMP_TAB_MARKER, \"\\t\")\n",
                "\n",
                "        if not onlyNewlineTab:\n",
                "            replacedString = replacedString.replace(DUMP_START_MARKER, \"\").replace(DUMP_STOP_MARKER, \"\")\n",
                "            replacedString = replacedString.replace(DUMP_DEL_MARKER, \", \")\n",
                "\n",
                "    return replacedString\n",
                "\n",
                "def banner():\n",
                "    \"\"\"\n",
                "    This function prints sqlmap banner with its version\n",
                "    \"\"\"\n",
                "\n",
                "    ban = \"\"\"\n",
                "    %s - %s\n",
                "    %s\\n\n",
                "\"\"\" % (VERSION_STRING, DESCRIPTION, SITE)\n",
                "\n",
                "    dataToStdout(ban, forceOutput=True)\n",
                "\n",
                "def parsePasswordHash(password):\n",
                "    blank = \" \" * 8\n",
                "\n",
                "    if not password or password == \" \":\n",
                "        password = \"NULL\"\n",
                "\n",
                "    if kb.dbms == DBMS.MSSQL and password != \"NULL\" and isHexEncodedString(password):\n",
                "        hexPassword = password\n",
                "        password  = \"%s\\n\" % hexPassword\n",
                "        password += \"%sheader: %s\\n\" % (blank, hexPassword[:6])\n",
                "        password += \"%ssalt: %s\\n\" % (blank, hexPassword[6:14])\n",
                "        password += \"%smixedcase: %s\\n\" % (blank, hexPassword[14:54])\n",
                "\n",
                "        if kb.dbmsVersion[0] not in ( \"2005\", \"2008\" ):\n",
                "            password += \"%suppercase: %s\" % (blank, hexPassword[54:])\n",
                "\n",
                "    return password\n",
                "\n",
                "def cleanQuery(query):\n",
                "    upperQuery = query\n",
                "\n",
                "    for sqlStatements in SQL_STATEMENTS.values():\n",
                "        for sqlStatement in sqlStatements:\n",
                "            sqlStatementEsc = sqlStatement.replace(\"(\", \"\\\\(\")\n",
                "            queryMatch = re.search(\"(%s)\" % sqlStatementEsc, query, re.I)\n",
                "\n",
                "            if queryMatch:\n",
                "                upperQuery = upperQuery.replace(queryMatch.group(1), sqlStatement.upper())\n",
                "\n",
                "    return upperQuery\n",
                "\n",
                "def setPaths():\n",
                "    # sqlmap paths\n",
                "    paths.SQLMAP_CONTRIB_PATH    = os.path.join(paths.SQLMAP_ROOT_PATH, \"lib\", \"contrib\")\n",
                "    paths.SQLMAP_EXTRAS_PATH     = os.path.join(paths.SQLMAP_ROOT_PATH, \"extra\")\n",
                "    paths.SQLMAP_SHELL_PATH      = os.path.join(paths.SQLMAP_ROOT_PATH, \"shell\")\n",
                "    paths.SQLMAP_TXT_PATH        = os.path.join(paths.SQLMAP_ROOT_PATH, \"txt\")\n",
                "    paths.SQLMAP_UDF_PATH        = os.path.join(paths.SQLMAP_ROOT_PATH, \"udf\")\n",
                "    paths.SQLMAP_XML_PATH        = os.path.join(paths.SQLMAP_ROOT_PATH, \"xml\")\n",
                "    paths.SQLMAP_XML_BANNER_PATH = os.path.join(paths.SQLMAP_XML_PATH, \"banner\")\n",
                "    paths.SQLMAP_OUTPUT_PATH     = os.path.join(paths.SQLMAP_ROOT_PATH, \"output\")\n",
                "    paths.SQLMAP_DUMP_PATH       = os.path.join(paths.SQLMAP_OUTPUT_PATH, \"%s\", \"dump\")\n",
                "    paths.SQLMAP_FILES_PATH      = os.path.join(paths.SQLMAP_OUTPUT_PATH, \"%s\", \"files\")\n",
                "\n",
                "    # sqlmap files\n",
                "    paths.SQLMAP_HISTORY         = os.path.join(paths.SQLMAP_ROOT_PATH, \".sqlmap_history\")\n",
                "    paths.SQLMAP_CONFIG          = os.path.join(paths.SQLMAP_ROOT_PATH, \"sqlmap-%s.conf\" % randomStr())\n",
                "    paths.COMMON_COLUMNS         = os.path.join(paths.SQLMAP_TXT_PATH, \"common-columns.txt\")\n",
                "    paths.COMMON_TABLES          = os.path.join(paths.SQLMAP_TXT_PATH, \"common-tables.txt\")\n",
                "    paths.COMMON_OUTPUTS         = os.path.join(paths.SQLMAP_TXT_PATH, 'common-outputs.txt')\n",
                "    paths.DORKS                  = os.path.join(paths.SQLMAP_TXT_PATH, \"dorks.txt\")\n",
                "    paths.SQL_KEYWORDS           = os.path.join(paths.SQLMAP_TXT_PATH, \"keywords.txt\")\n",
                "    paths.ORACLE_DEFAULT_PASSWD  = os.path.join(paths.SQLMAP_TXT_PATH, \"oracle-default-passwords.txt\")\n",
                "    paths.WORDLIST               = os.path.join(paths.SQLMAP_TXT_PATH, \"wordlist.txt\")\n",
                "    paths.PHPIDS_RULES_XML       = os.path.join(paths.SQLMAP_XML_PATH, \"phpids_rules.xml\")\n",
                "    paths.ERRORS_XML             = os.path.join(paths.SQLMAP_XML_PATH, \"errors.xml\")\n",
                "    paths.PAYLOADS_XML           = os.path.join(paths.SQLMAP_XML_PATH, \"payloads.xml\")\n",
                "    paths.INJECTIONS_XML         = os.path.join(paths.SQLMAP_XML_PATH, \"injections.xml\")\n",
                "    paths.LIVE_TESTS_XML         = os.path.join(paths.SQLMAP_XML_PATH, \"livetests.xml\")\n",
                "    paths.QUERIES_XML            = os.path.join(paths.SQLMAP_XML_PATH, \"queries.xml\")\n",
                "    paths.GENERIC_XML            = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"generic.xml\")\n",
                "    paths.MSSQL_XML              = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"mssql.xml\")\n",
                "    paths.MYSQL_XML              = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"mysql.xml\")\n",
                "    paths.ORACLE_XML             = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"oracle.xml\")\n",
                "    paths.PGSQL_XML              = os.path.join(paths.SQLMAP_XML_BANNER_PATH, \"postgresql.xml\")\n",
                "\n",
                "def weAreFrozen():\n",
                "    \"\"\"\n",
                "    Returns whether we are frozen via py2exe.\n",
                "    This will affect how we find out where we are located.\n",
                "    Reference: http://www.py2exe.org/index.cgi/WhereAmI\n",
                "    \"\"\"\n",
                "\n",
                "    return hasattr(sys, \"frozen\")\n",
                "\n",
                "def parseTargetDirect():\n",
                "    \"\"\"\n",
                "    Parse target dbms and set some attributes into the configuration singleton.\n",
                "    \"\"\"\n",
                "\n",
                "    if not conf.direct:\n",
                "        return\n",
                "\n",
                "    details = None\n",
                "    remote = False\n",
                "\n",
                "    for dbms in SUPPORTED_DBMS:\n",
                "        details = re.search(\"^(?P<dbms>%s)://(?P<credentials>(?P<user>.+?)\\:(?P<pass>.*?)\\@)?(?P<remote>(?P<hostname>.+?)\\:(?P<port>[\\d]+)\\/)?(?P<db>[\\w\\d\\ \\:\\.\\_\\-\\/\\\\\\\\]+?)$\" % dbms, conf.direct, re.I)\n",
                "\n",
                "        if details:\n",
                "            conf.dbms = details.group('dbms')\n",
                "\n",
                "            if details.group('credentials'):\n",
                "                conf.dbmsUser = details.group('user')\n",
                "                conf.dbmsPass = details.group('pass')\n",
                "            else:\n",
                "                conf.dbmsUser = unicode()\n",
                "                conf.dbmsPass = unicode()\n",
                "\n",
                "            if not conf.dbmsPass:\n",
                "                conf.dbmsPass = None\n",
                "\n",
                "            if details.group('remote'):\n",
                "                remote = True\n",
                "                conf.hostname = details.group('hostname')\n",
                "                conf.port     = int(details.group('port'))\n",
                "            else:\n",
                "                conf.hostname = \"localhost\"\n",
                "                conf.port     = 0\n",
                "\n",
                "            conf.dbmsDb = details.group('db')\n",
                "\n",
                "            conf.parameters[None] = \"direct connection\"\n",
                "\n",
                "            break\n",
                "\n",
                "    if not details:\n",
                "        errMsg = \"invalid target details, valid syntax is for instance \"\n",
                "        errMsg += \"'mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME' \"\n",
                "        errMsg += \"or 'access://DATABASE_FILEPATH'\"\n",
                "        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "    for dbmsName, data in dbmsDict.items():\n",
                "        if conf.dbms in data[0]:\n",
                "            try:\n",
                "                if dbmsName in (DBMS.ACCESS, DBMS.SQLITE, DBMS.FIREBIRD):\n",
                "                    if remote:\n",
                "                        warnMsg = \"direct connection over the network for \"\n",
                "                        warnMsg += \"%s DBMS is not supported\" % dbmsName\n",
                "                        logger.warn(warnMsg)\n",
                "\n",
                "                        conf.hostname = \"localhost\"\n",
                "                        conf.port     = 0\n",
                "                elif not remote:\n",
                "                        errMsg = \"missing remote connection details\"\n",
                "                        raise sqlmapSyntaxException, errMsg\n",
                "\n",
                "                if dbmsName == DBMS.MSSQL:\n",
                "                    import _mssql\n",
                "                    import pymssql\n",
                "\n",
                "                    if not hasattr(pymssql, \"__version__\") or pymssql.__version__ < \"1.0.2\":\n",
                "                        errMsg = \"pymssql library on your system must be \"\n",
                "                        errMsg += \"version 1.0.2 to work, get it from \"\n",
                "                        errMsg += \"http://sourceforge.net/projects/pymssql/files/pymssql/1.0.2/\"\n",
                "                        raise sqlmapMissingDependence, errMsg\n",
                "\n",
                "                elif dbmsName == DBMS.MYSQL:\n",
                "                    import MySQLdb\n",
                "                elif dbmsName == DBMS.PGSQL:\n",
                "                    import psycopg2\n",
                "                elif dbmsName == DBMS.ORACLE:\n",
                "                    import cx_Oracle\n",
                "                elif dbmsName == DBMS.SQLITE:\n",
                "                    import sqlite3\n",
                "                elif dbmsName == DBMS.ACCESS:\n",
                "                    import pyodbc\n",
                "                elif dbmsName == DBMS.FIREBIRD:\n",
                "                    import kinterbasdb\n",
                "            except ImportError, _:\n",
                "                errMsg  = \"sqlmap requires '%s' third-party library \" % data[1]\n",
                "                errMsg += \"in order to directly connect to the database \"\n",
                "                errMsg += \"'%s'. Download from '%s'\" % (dbmsName, data[2])\n",
                "                raise sqlmapMissingDependence, errMsg\n",
                "\n",
                "def parseTargetUrl():\n",
                "    \"\"\"\n",
                "    Parse target url and set some attributes into the configuration singleton.\n",
                "    \"\"\"\n",
                "\n",
                "    if not conf.url:\n",
                "        return\n",
                "\n",
                "    if not re.search(\"^http[s]*://\", conf.url):\n",
                "        if \":443/\" in conf.url:\n",
                "            conf.url = \"https://\" + conf.url\n",
                "        else:\n",
                "            conf.url = \"http://\" + conf.url\n",
                "\n",
                "    __urlSplit     = urlparse.urlsplit(conf.url)\n",
                "    __hostnamePort = __urlSplit[1].split(\":\")\n",
                "\n",
                "    conf.scheme    = __urlSplit[0]\n",
                "    conf.path      = __urlSplit[2]\n",
                "    conf.hostname  = __hostnamePort[0]\n",
                "\n",
                "    if len(__hostnamePort) == 2:\n",
                "        try:\n",
                "            conf.port = int(__hostnamePort[1])\n",
                "        except:\n",
                "            errMsg = \"invalid target url\"\n",
                "            raise sqlmapSyntaxException, errMsg\n",
                "    elif conf.scheme == \"https\":\n",
                "        conf.port = 443\n",
                "    else:\n",
                "        conf.port = 80\n",
                "\n",
                "    if __urlSplit[3]:\n",
                "        conf.parameters[PLACE.GET] = __urlSplit[3]\n",
                "\n",
                "    conf.url = \"%s://%s:%d%s\" % (conf.scheme, conf.hostname, conf.port, conf.path)\n",
                "\n",
                "def expandAsteriskForColumns(expression):\n",
                "    # If the user provided an asterisk rather than the column(s)\n",
                "    # name, sqlmap will retrieve the columns itself and reprocess\n",
                "    # the SQL query string (expression)\n",
                "    asterisk = re.search(\"^SELECT\\s+\\*\\s+FROM\\s+([\\w\\.\\_]+)\\s*\", expression, re.I)\n",
                "\n",
                "    if asterisk:\n",
                "        infoMsg  = \"you did not provide the fields in your query. \"\n",
                "        infoMsg += \"sqlmap will retrieve the column names itself\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        dbTbl = asterisk.group(1)\n",
                "\n",
                "        if dbTbl and \".\" in dbTbl:\n",
                "            conf.db, conf.tbl = dbTbl.split(\".\", 1)\n",
                "        else:\n",
                "            conf.tbl = dbTbl\n",
                "\n",
                "        columnsDict = conf.dbmsHandler.getColumns(onlyColNames=True)\n",
                "\n",
                "        if columnsDict and conf.db in columnsDict and conf.tbl in columnsDict[conf.db]:\n",
                "            columns = columnsDict[conf.db][conf.tbl].keys()\n",
                "            columns.sort()\n",
                "            columnsStr = \", \".join([column for column in columns])\n",
                "            expression = expression.replace(\"*\", columnsStr, 1)\n",
                "\n",
                "            infoMsg  = \"the query with column names is: \"\n",
                "            infoMsg += \"%s\" % expression\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "    return expression\n",
                "\n",
                "def getRange(count, dump=False, plusOne=False):\n",
                "    count      = int(count)\n",
                "    indexRange = None\n",
                "    limitStart = 1\n",
                "    limitStop  = count\n",
                "\n",
                "    if dump:\n",
                "        if isinstance(conf.limitStop, int) and conf.limitStop > 0 and conf.limitStop < limitStop:\n",
                "            limitStop = conf.limitStop\n",
                "\n",
                "        if isinstance(conf.limitStart, int) and conf.limitStart > 0 and conf.limitStart <= limitStop:\n",
                "            limitStart = conf.limitStart\n",
                "\n",
                "    if plusOne:\n",
                "        indexRange = range(limitStart, limitStop + 1)\n",
                "    else:\n",
                "        indexRange = range(limitStart - 1, limitStop)\n",
                "\n",
                "    return indexRange\n",
                "\n",
                "def parseUnionPage(output, expression, partial=False, condition=None, sort=True):\n",
                "    data = []\n",
                "\n",
                "    outCond1 = ( output.startswith(kb.misc.start) and output.endswith(kb.misc.stop) )\n",
                "    outCond2 = ( output.startswith(DUMP_START_MARKER) and output.endswith(DUMP_STOP_MARKER) )\n",
                "\n",
                "    if outCond1 or outCond2:\n",
                "        if outCond1:\n",
                "            regExpr = '%s(.*?)%s' % (kb.misc.start, kb.misc.stop)\n",
                "        elif outCond2:\n",
                "            regExpr = '%s(.*?)%s' % (DUMP_START_MARKER, DUMP_STOP_MARKER)\n",
                "\n",
                "        output = re.findall(regExpr, output, re.S)\n",
                "\n",
                "        if condition is None:\n",
                "            condition = (\n",
                "                          kb.resumedQueries and conf.url in kb.resumedQueries.keys()\n",
                "                          and expression in kb.resumedQueries[conf.url].keys()\n",
                "                        )\n",
                "\n",
                "        if partial or not condition:\n",
                "            logOutput = \"\".join([\"%s%s%s\" % (DUMP_START_MARKER, replaceNewlineTabs(value), DUMP_STOP_MARKER) for value in output])\n",
                "            dataToSessionFile(\"[%s][%s][%s][%s][%s]\\n\" % (conf.url, kb.injection.place, conf.parameters[kb.injection.place], expression, logOutput))\n",
                "\n",
                "        if sort:\n",
                "            output = set(output)\n",
                "\n",
                "        for entry in output:\n",
                "            info = []\n",
                "\n",
                "            if DUMP_DEL_MARKER in entry:\n",
                "                entry = entry.split(DUMP_DEL_MARKER)\n",
                "            else:\n",
                "                entry = entry.split(kb.misc.delimiter)\n",
                "\n",
                "            if len(entry) == 1:\n",
                "                data.append(entry[0])\n",
                "            else:\n",
                "                for value in entry:\n",
                "                    info.append(value)\n",
                "\n",
                "                data.append(info)\n",
                "    else:\n",
                "        data = output\n",
                "\n",
                "    if len(data) == 1 and isinstance(data[0], basestring):\n",
                "        data = data[0]\n",
                "\n",
                "    return data\n",
                "\n",
                "def getDelayQuery(andCond=False):\n",
                "    query = None\n",
                "\n",
                "    if kb.dbms in (DBMS.MYSQL, DBMS.PGSQL):\n",
                "        if not kb.data.banner:\n",
                "            conf.dbmsHandler.getVersionFromBanner()\n",
                "\n",
                "        banVer = kb.bannerFp[\"dbmsVersion\"] if 'dbmsVersion' in kb.bannerFp else None\n",
                "\n",
                "        if banVer is None or (kb.dbms == DBMS.MYSQL and banVer >= \"5.0.12\") or (kb.dbms == DBMS.PGSQL and banVer >= \"8.2\"):\n",
                "            query = queries[kb.dbms].timedelay.query % conf.timeSec\n",
                "        else:\n",
                "            query = queries[kb.dbms].timedelay.query2 % conf.timeSec\n",
                "    elif kb.dbms == DBMS.FIREBIRD:\n",
                "        query = queries[kb.dbms].timedelay.query\n",
                "    else:\n",
                "        query = queries[kb.dbms].timedelay.query % conf.timeSec\n",
                "\n",
                "    if andCond:\n",
                "        if kb.dbms in ( DBMS.MYSQL, DBMS.SQLITE ):\n",
                "            query = query.replace(\"SELECT \", \"\")\n",
                "        elif kb.dbms == DBMS.FIREBIRD:\n",
                "            query = \"(%s)>0\" % query\n",
                "\n",
                "    return query\n",
                "\n",
                "def getLocalIP():\n",
                "    retVal = None\n",
                "    try:\n",
                "        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n",
                "        s.connect((conf.hostname, conf.port))\n",
                "        retVal, _ = s.getsockname()\n",
                "        s.close()\n",
                "    except:\n",
                "        debugMsg = \"there was an error in opening socket \"\n",
                "        debugMsg += \"connection toward '%s'\" % conf.hostname\n",
                "        logger.debug(debugMsg)\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def getRemoteIP():\n",
                "    return socket.gethostbyname(conf.hostname)\n",
                "\n",
                "def getFileType(filePath):\n",
                "    try:\n",
                "        magicFileType = magic.from_file(filePath)\n",
                "    except:\n",
                "        return \"unknown\"\n",
                "\n",
                "    if \"ASCII\" in magicFileType or \"text\" in magicFileType:\n",
                "        return \"text\"\n",
                "    else:\n",
                "        return \"binary\"\n",
                "\n",
                "def getCharset(charsetType=None):\n",
                "    asciiTbl = []\n",
                "\n",
                "    if charsetType is None:\n",
                "        asciiTbl = range(0, 128)\n",
                "\n",
                "    # 0 or 1\n",
                "    elif charsetType == 1:\n",
                "        asciiTbl.extend([ 0, 1 ])\n",
                "        asciiTbl.extend(range(47, 50))\n",
                "\n",
                "    # Digits\n",
                "    elif charsetType == 2:\n",
                "        asciiTbl.extend([ 0, 1 ])\n",
                "        asciiTbl.extend(range(47, 58))\n",
                "\n",
                "    # Hexadecimal\n",
                "    elif charsetType == 3:\n",
                "        asciiTbl.extend([ 0, 1 ])\n",
                "        asciiTbl.extend(range(47, 58))\n",
                "        asciiTbl.extend(range(64, 71))\n",
                "        asciiTbl.extend(range(96, 103))\n",
                "\n",
                "    # Characters\n",
                "    elif charsetType == 4:\n",
                "        asciiTbl.extend([ 0, 1 ])\n",
                "        asciiTbl.extend(range(64, 91))\n",
                "        asciiTbl.extend(range(96, 123))\n",
                "\n",
                "    # Characters and digits\n",
                "    elif charsetType == 5:\n",
                "        asciiTbl.extend([ 0, 1 ])\n",
                "        asciiTbl.extend(range(47, 58))\n",
                "        asciiTbl.extend(range(64, 91))\n",
                "        asciiTbl.extend(range(96, 123))\n",
                "\n",
                "    return asciiTbl\n",
                "\n",
                "def searchEnvPath(fileName):\n",
                "    envPaths = os.environ[\"PATH\"]\n",
                "    result = None\n",
                "\n",
                "    if IS_WIN:\n",
                "        envPaths = envPaths.split(\";\")\n",
                "    else:\n",
                "        envPaths = envPaths.split(\":\")\n",
                "\n",
                "    for envPath in envPaths:\n",
                "        envPath = envPath.replace(\";\", \"\")\n",
                "        result = os.path.exists(os.path.normpath(os.path.join(envPath, fileName)))\n",
                "\n",
                "        if result:\n",
                "            break\n",
                "\n",
                "    return result\n",
                "\n",
                "def urlEncodeCookieValues(cookieStr):\n",
                "    if cookieStr:\n",
                "        result = \"\"\n",
                "\n",
                "        for part in cookieStr.split(';'):\n",
                "            index = part.find('=') + 1\n",
                "\n",
                "            if index > 0:\n",
                "                name = part[:index - 1].strip()\n",
                "                value = urlencode(part[index:], convall=True)\n",
                "                result += \"; %s=%s\" % (name, value)\n",
                "            elif part.strip().lower() != \"secure\":\n",
                "                result += \"%s%s\" % (\"%3B\", urlencode(part, convall=True))\n",
                "            else:\n",
                "                result += \"; secure\"\n",
                "\n",
                "        if result.startswith('; '):\n",
                "            result = result[2:]\n",
                "        elif result.startswith('%3B'):\n",
                "            result = result[3:]\n",
                "\n",
                "        return result\n",
                "    else:\n",
                "        return None\n",
                "\n",
                "def directoryPath(path):\n",
                "    retVal = None\n",
                "\n",
                "    if isWindowsDriveLetterPath(path):\n",
                "        retVal = ntpath.dirname(path)\n",
                "    else:\n",
                "        retVal = posixpath.dirname(path)\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def normalizePath(path):\n",
                "    retVal = None\n",
                "\n",
                "    if isWindowsDriveLetterPath(path):\n",
                "        retVal = ntpath.normpath(path)\n",
                "    else:\n",
                "        retVal = posixpath.normpath(path)\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def safeStringFormat(formatStr, params):\n",
                "    retVal = formatStr.replace(\"%d\", \"%s\")\n",
                "\n",
                "    if isinstance(params, basestring):\n",
                "        retVal = retVal.replace(\"%s\", params)\n",
                "    else:\n",
                "        count = 0\n",
                "        index = 0\n",
                "\n",
                "        while index != -1:\n",
                "            index = retVal.find(\"%s\")\n",
                "\n",
                "            if index != -1:\n",
                "                if count < len(params):\n",
                "                    retVal = retVal[:index] + getUnicode(params[count]) + retVal[index+2:]\n",
                "                else:\n",
                "                    raise sqlmapNoneDataException, \"wrong number of parameters during string formatting\"\n",
                "                count += 1\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def sanitizeAsciiString(subject):\n",
                "    if subject:\n",
                "        index = None\n",
                "        for i in xrange(len(subject)):\n",
                "            if ord(subject[i]) >= 128:\n",
                "                index = i\n",
                "                break\n",
                "        if index is None:\n",
                "            return subject\n",
                "        else:\n",
                "            return subject[:index] + \"\".join(subject[i] if ord(subject[i]) < 128 else '?' for i in xrange(index, len(subject)))\n",
                "    else:\n",
                "        return None\n",
                "\n",
                "def getFilteredPageContent(page):\n",
                "    retVal = page\n",
                "\n",
                "    if isinstance(page, basestring):\n",
                "        retVal = re.sub(r\"(?s)<script.+?</script>|<style.+?</style>|<[^>]+>|\\t|\\n|\\r\", \" \", page)\n",
                "\n",
                "        while retVal.find(\"  \") != -1:\n",
                "            retVal = retVal.replace(\"  \", \" \")\n",
                "\n",
                "        retVal = htmlunescape(retVal)\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def getPageTextWordsSet(page):\n",
                "    retVal = None\n",
                "\n",
                "    if isinstance(page, basestring):\n",
                "        page = getFilteredPageContent(page)\n",
                "        retVal = set(re.findall(r\"\\w+\", page))\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def showStaticWords(firstPage, secondPage):\n",
                "    infoMsg = \"finding static words in longest matching part of dynamic page content\"\n",
                "    logger.info(infoMsg)\n",
                "\n",
                "    firstPage = getFilteredPageContent(firstPage)\n",
                "    secondPage = getFilteredPageContent(secondPage)\n",
                "    match = SequenceMatcher(None, firstPage, secondPage).find_longest_match(0, len(firstPage), 0, len(secondPage))\n",
                "    commonText = firstPage[match[0]:match[0]+match[2]]\n",
                "    commonWords = getPageTextWordsSet(commonText)\n",
                "\n",
                "    infoMsg = \"static words: \"\n",
                "\n",
                "    if commonWords:\n",
                "        commonWords = list(commonWords)\n",
                "        commonWords.sort(lambda a, b: cmp(a.lower(), b.lower()))\n",
                "\n",
                "    for word in commonWords:\n",
                "        if len(word) > 2:\n",
                "            infoMsg += \"'%s', \" % word\n",
                "\n",
                "    infoMsg = infoMsg.rstrip(\", \")\n",
                "    logger.info(infoMsg)\n",
                "\n",
                "def decloakToNamedTemporaryFile(filepath, name=None):\n",
                "    retVal = NamedTemporaryFile()\n",
                "\n",
                "    def __del__():\n",
                "        try:\n",
                "            if hasattr(retVal, 'old_name'):\n",
                "                retVal.name = old_name\n",
                "            retVal.close()\n",
                "        except OSError:\n",
                "            pass\n",
                "\n",
                "    retVal.__del__ = __del__\n",
                "    retVal.write(decloak(filepath))\n",
                "    retVal.seek(0)\n",
                "\n",
                "    if name:\n",
                "        retVal.old_name = retVal.name\n",
                "        retVal.name = name\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def decloakToMkstemp(filepath, **kwargs):\n",
                "    name = mkstemp(**kwargs)[1]\n",
                "    retVal = open(name, 'w+b')\n",
                "\n",
                "    retVal.write(decloak(filepath))\n",
                "    retVal.seek(0)\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def isWindowsPath(filepath):\n",
                "    return re.search(\"\\A[\\w]\\:\\\\\\\\\", filepath) is not None\n",
                "\n",
                "def isWindowsDriveLetterPath(filepath):\n",
                "    return re.search(\"\\A[\\w]\\:\", filepath) is not None\n",
                "\n",
                "def posixToNtSlashes(filepath):\n",
                "    \"\"\"\n",
                "    Replaces all occurances of Posix slashes (/) in provided\n",
                "    filepath with NT ones (/)\n",
                "    >>> posixToNtSlashes('C:/Windows')\n",
                "    'C:\\\\\\\\Windows'\n",
                "    \"\"\"\n",
                "\n",
                "    return filepath.replace('/', '\\\\')\n",
                "\n",
                "def ntToPosixSlashes(filepath):\n",
                "    \"\"\"\n",
                "    Replaces all occurances of NT slashes (\\) in provided\n",
                "    filepath with Posix ones (/)\n",
                "    >>> ntToPosixSlashes('C:\\\\Windows')\n",
                "    'C:/Windows'\n",
                "    \"\"\"\n",
                "\n",
                "    return filepath.replace('\\\\', '/')\n",
                "\n",
                "def isBase64EncodedString(subject):\n",
                "    \"\"\"\n",
                "    Checks if the provided string is Base64 encoded\n",
                "    >>> isBase64EncodedString('dGVzdA==')\n",
                "    True\n",
                "    >>> isBase64EncodedString('123456')\n",
                "    False\n",
                "    \"\"\"\n",
                "\n",
                "    return re.match(r\"\\A(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?\\Z\", subject) is not None\n",
                "\n",
                "def isHexEncodedString(subject):\n",
                "    \"\"\"\n",
                "    Checks if the provided string is hex encoded\n",
                "    >>> isHexEncodedString('DEADBEEF')\n",
                "    True\n",
                "    >>> isHexEncodedString('test')\n",
                "    False\n",
                "    \"\"\"\n",
                "\n",
                "    return re.match(r\"\\A[0-9a-fA-Fx]+\\Z\", subject) is not None\n",
                "\n",
                "def getConsoleWidth(default=80):\n",
                "    width = None\n",
                "\n",
                "    if 'COLUMNS' in os.environ and os.environ['COLUMNS'].isdigit():\n",
                "        width = int(os.environ['COLUMNS'])\n",
                "    else:\n",
                "        output=subprocess.Popen('stty size', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).stdout.read()\n",
                "        items = output.split()\n",
                "\n",
                "        if len(items) == 2 and items[1].isdigit():\n",
                "            width = int(items[1])\n",
                "\n",
                "    if width is None:\n",
                "        try:\n",
                "            import curses\n",
                "\n",
                "            stdscr = curses.initscr()\n",
                "            _, width = stdscr.getmaxyx()\n",
                "            curses.endwin()\n",
                "        except:\n",
                "            pass\n",
                "\n",
                "    return width if width else default\n",
                "\n",
                "def clearConsoleLine(forceOutput=False):\n",
                "    dataToStdout(\"\\r%s\\r\" % (\" \" * (getConsoleWidth() - 1)), forceOutput)\n",
                "\n",
                "def parseXmlFile(xmlFile, handler):\n",
                "    stream = StringIO(readCachedFileContent(xmlFile))\n",
                "    parse(stream, handler)\n",
                "    stream.close()\n",
                "\n",
                "def readCachedFileContent(filename, mode='rb'):\n",
                "    if filename not in kb.cache.content:\n",
                "        kb.locks.cacheLock.acquire()\n",
                "\n",
                "        if filename not in kb.cache.content:\n",
                "            checkFile(filename)\n",
                "            xfile = codecs.open(filename, mode, conf.dataEncoding)\n",
                "            content = xfile.read()\n",
                "            kb.cache.content[filename] = content\n",
                "            xfile.close()\n",
                "\n",
                "        kb.locks.cacheLock.release()\n",
                "\n",
                "    return kb.cache.content[filename]\n",
                "\n",
                "def readXmlFile(xmlFile):\n",
                "    checkFile(xmlFile)  \n",
                "\n",
                "    xfile = codecs.open(xmlFile, 'r', conf.dataEncoding)\n",
                "    retVal = minidom.parse(xfile).documentElement\n",
                "\n",
                "    xfile.close()\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def stdev(values):\n",
                "    \"\"\"\n",
                "    Computes standard deviation of a list of numbers.\n",
                "    Reference: http://www.goldb.org/corestats.html\n",
                "    \"\"\"\n",
                "\n",
                "    if not values or len(values) < 2:\n",
                "        return None\n",
                "\n",
                "    key = (values[0], values[-1], len(values))\n",
                "\n",
                "    if key in kb.cache.stdev:\n",
                "        return kb.cache.stdev[key]\n",
                "    else:\n",
                "        summa = 0.0\n",
                "        avg = average(values)\n",
                "\n",
                "        for value in values:\n",
                "            summa += pow(value - avg, 2)\n",
                "\n",
                "        retVal = sqrt(summa/(len(values) - 1))\n",
                "        kb.cache.stdev[key] = retVal\n",
                "        return retVal\n",
                "\n",
                "def average(values):\n",
                "    \"\"\"\n",
                "    Computes the arithmetic mean of a list of numbers.\n",
                "    \"\"\"\n",
                "    retVal = None\n",
                "\n",
                "    if values:\n",
                "        retVal = sum(values) / len(values)\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def calculateDeltaSeconds(start):\n",
                "    \"\"\"\n",
                "    Returns elapsed time from start till now\n",
                "    \"\"\"\n",
                "    return time.time() - start\n",
                "\n",
                "def initCommonOutputs():\n",
                "    kb.commonOutputs = {}\n",
                "    key = None\n",
                "\n",
                "    cfile = codecs.open(paths.COMMON_OUTPUTS, 'r', conf.dataEncoding)\n",
                "\n",
                "    for line in cfile.readlines(): # xreadlines doesn't return unicode strings when codec.open() is used\n",
                "        if line.find('#') != -1:\n",
                "            line = line[:line.find('#')]\n",
                "\n",
                "        line = line.strip()\n",
                "\n",
                "        if len(line) > 1:\n",
                "            if line.startswith('[') and line.endswith(']'):\n",
                "                key = line[1:-1]\n",
                "            elif key:\n",
                "                if key not in kb.commonOutputs:\n",
                "                    kb.commonOutputs[key] = set()\n",
                "\n",
                "                if line not in kb.commonOutputs[key]:\n",
                "                    kb.commonOutputs[key].add(line)\n",
                "\n",
                "    cfile.close()\n",
                "\n",
                "def getFileItems(filename, commentPrefix='#', unicode_=True):\n",
                "    retVal = []\n",
                "\n",
                "    checkFile(filename)\n",
                "\n",
                "    if unicode_:\n",
                "        ifile = codecs.open(filename, 'r', conf.dataEncoding)\n",
                "    else:\n",
                "        ifile = open(filename, 'r')\n",
                "\n",
                "    for line in ifile.readlines(): # xreadlines doesn't return unicode strings when codec.open() is used\n",
                "        if commentPrefix:\n",
                "            if line.find(commentPrefix) != -1:\n",
                "                line = line[:line.find(commentPrefix)]\n",
                "        line = line.strip()\n",
                "        if not unicode_:\n",
                "            try:\n",
                "                line = str.encode(line)\n",
                "            except UnicodeDecodeError:\n",
                "                continue\n",
                "        if line:\n",
                "            retVal.append(line)\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def goGoodSamaritan(prevValue, originalCharset):\n",
                "    \"\"\"\n",
                "    Function for retrieving parameters needed for common prediction (good\n",
                "    samaritan) feature.\n",
                "\n",
                "    prevValue: retrieved query output so far (e.g. 'i').\n",
                "\n",
                "    Returns commonValue if there is a complete single match (in kb.partRun\n",
                "    of txt/common-outputs.txt under kb.partRun) regarding parameter\n",
                "    prevValue. If there is no single value match, but multiple, commonCharset is\n",
                "    returned containing more probable characters (retrieved from matched\n",
                "    values in txt/common-outputs.txt) together with the rest of charset as\n",
                "    otherCharset.\n",
                "    \"\"\"\n",
                "\n",
                "    if kb.commonOutputs is None:\n",
                "        initCommonOutputs()\n",
                "\n",
                "    predictionSet = set()\n",
                "    commonValue = None\n",
                "    commonPattern = None\n",
                "    countCommonValue = 0\n",
                "\n",
                "    # If the header (e.g. Databases) we are looking for has common\n",
                "    # outputs defined\n",
                "    if kb.partRun in kb.commonOutputs:\n",
                "        commonPartOutputs = kb.commonOutputs[kb.partRun]\n",
                "        commonPattern = commonFinderOnly(prevValue, commonPartOutputs)\n",
                "\n",
                "        # If the longest common prefix is the same as previous value then\n",
                "        # do not consider it\n",
                "        if commonPattern and commonPattern == prevValue:\n",
                "            commonPattern = None\n",
                "\n",
                "        # For each common output\n",
                "        for item in commonPartOutputs:\n",
                "            # Check if the common output (item) starts with prevValue\n",
                "            # where prevValue is the enumerated character(s) so far\n",
                "            if item.startswith(prevValue):\n",
                "                commonValue = item\n",
                "                countCommonValue += 1\n",
                "\n",
                "                if len(item) > len(prevValue):\n",
                "                    char = item[len(prevValue)]\n",
                "                    predictionSet.add(char)\n",
                "\n",
                "        # Reset single value if there is more than one possible common\n",
                "        # output\n",
                "        if countCommonValue > 1:\n",
                "            commonValue = None\n",
                "\n",
                "        commonCharset = []\n",
                "        otherCharset = []\n",
                "\n",
                "        # Split the original charset into common chars (commonCharset)\n",
                "        # and other chars (otherCharset)\n",
                "        for ordChar in originalCharset:\n",
                "            if chr(ordChar) not in predictionSet:\n",
                "                otherCharset.append(ordChar)\n",
                "            else:\n",
                "                commonCharset.append(ordChar)\n",
                "\n",
                "        commonCharset.sort()\n",
                "\n",
                "        return commonValue, commonPattern, commonCharset, originalCharset\n",
                "    else:\n",
                "        return None, None, None, originalCharset\n",
                "\n",
                "def getCompiledRegex(regex, flags=0):\n",
                "    \"\"\"\n",
                "    Returns compiled regular expression and stores it in cache for further\n",
                "    usage\n",
                "    >>> getCompiledRegex('test') # doctest: +ELLIPSIS\n",
                "    <_sre.SRE_Pattern object at...\n",
                "    \"\"\"\n",
                "\n",
                "    if (regex, flags) in kb.cache.regex:\n",
                "        return kb.cache.regex[(regex, flags)]\n",
                "    else:\n",
                "        retVal = re.compile(regex, flags)\n",
                "        kb.cache.regex[(regex, flags)] = retVal\n",
                "        return retVal\n",
                "\n",
                "def getPartRun():\n",
                "    \"\"\"\n",
                "    Goes through call stack and finds constructs matching conf.dbmsHandler.*.\n",
                "    Returns it or its alias used in txt/common-outputs.txt\n",
                "    \"\"\"\n",
                "\n",
                "    retVal = None\n",
                "    commonPartsDict = optDict[\"Enumeration\"]\n",
                "    stack = [item[4][0] if isinstance(item[4], list) else '' for item in inspect.stack()]\n",
                "    reobj1 = getCompiledRegex('conf\\.dbmsHandler\\.([^(]+)\\(\\)')\n",
                "    reobj2 = getCompiledRegex('self\\.(get[^(]+)\\(\\)')\n",
                "\n",
                "    # Goes backwards through the stack to find the conf.dbmsHandler method\n",
                "    # calling this function\n",
                "    for i in xrange(0, len(stack)-1):\n",
                "        for reobj in (reobj2, reobj1):\n",
                "            match = reobj.search(stack[i])\n",
                "\n",
                "            if match:\n",
                "                # This is the calling conf.dbmsHandler or self method\n",
                "                # (e.g. 'getDbms')\n",
                "                retVal = match.groups()[0]\n",
                "                break\n",
                "\n",
                "        if retVal is not None:\n",
                "            break\n",
                "\n",
                "    # Return the INI tag to consider for common outputs (e.g. 'Databases')\n",
                "    return commonPartsDict[retVal][1] if retVal in commonPartsDict else retVal\n",
                "\n",
                "def getUnicode(value, encoding=None):\n",
                "    \"\"\"\n",
                "    Return the unicode representation of the supplied value:\n",
                "\n",
                "    >>> getUnicode(u'test')\n",
                "    u'test'\n",
                "    >>> getUnicode('test')\n",
                "    u'test'\n",
                "    >>> getUnicode(1)\n",
                "    u'1'\n",
                "    \"\"\"\n",
                "\n",
                "    if encoding is None:\n",
                "        encoding = conf.dataEncoding if 'dataEncoding' in conf else \"utf-8\"\n",
                "    if isinstance(value, basestring):\n",
                "        return value if isinstance(value, unicode) else unicode(value, encoding, errors='replace')\n",
                "    else:\n",
                "        return unicode(value) # encoding ignored for non-basestring instances\n",
                "\n",
                "# http://boredzo.org/blog/archives/2007-01-06/longest-common-prefix-in-python-2\n",
                "def longestCommonPrefix(*sequences):\n",
                "    if len(sequences) == 1:\n",
                "        return sequences[0]\n",
                "\n",
                "    sequences = [pair[1] for pair in sorted((len(fi), fi) for fi in sequences)]\n",
                "\n",
                "    if not sequences:\n",
                "        return None\n",
                "\n",
                "    for i, comparison_ch in enumerate(sequences[0]):\n",
                "        for fi in sequences[1:]:\n",
                "            ch = fi[i]\n",
                "\n",
                "            if ch != comparison_ch:\n",
                "                return fi[:i]\n",
                "\n",
                "    return sequences[0]\n",
                "\n",
                "def commonFinderOnly(initial, sequence):\n",
                "    return longestCommonPrefix(*filter(lambda x: x.startswith(initial), sequence))\n",
                "\n",
                "def getCurrentThreadUID():\n",
                "    return hash(threading.currentThread())\n",
                "\n",
                "def getCurrentThreadData():\n",
                "    \"\"\"\n",
                "    Returns current thread's dependent data\n",
                "    \"\"\"\n",
                "\n",
                "    threadUID = getCurrentThreadUID()\n",
                "    if threadUID not in kb.threadData:\n",
                "        kb.threadData[threadUID] = ThreadData()\n",
                "    return kb.threadData[threadUID]\n",
                "\n",
                "def pushValue(value):\n",
                "    \"\"\"\n",
                "    Push value to the stack (thread dependent)\n",
                "    \"\"\"\n",
                "\n",
                "    getCurrentThreadData().valueStack.append(value)\n",
                "\n",
                "def popValue():\n",
                "    \"\"\"\n",
                "    Pop value from the stack (thread dependent)\n",
                "    \"\"\"\n",
                "\n",
                "    return getCurrentThreadData().valueStack.pop()\n",
                "\n",
                "def wasLastRequestDBMSError():\n",
                "    \"\"\"\n",
                "    Returns True if the last web request resulted in a (recognized) DBMS error page\n",
                "    \"\"\"\n",
                "\n",
                "    threadData = getCurrentThreadData()\n",
                "    return threadData.lastErrorPage and threadData.lastErrorPage[0] == threadData.lastRequestUID\n",
                "\n",
                "def wasLastRequestDelayed():\n",
                "    \"\"\"\n",
                "    Returns True if the last web request resulted in a time-delay\n",
                "    \"\"\"\n",
                "\n",
                "    # 99.9999999997440% of all non time-based sql injection\n",
                "    # affected response times should be inside +-7*stdev([normal response times])\n",
                "    # (Math reference: http://www.answers.com/topic/standard-deviation)\n",
                "    deviation = stdev(kb.responseTimes)\n",
                "    threadData = getCurrentThreadData()\n",
                "\n",
                "    if deviation:\n",
                "        if len(kb.responseTimes) < MIN_TIME_RESPONSES:\n",
                "            warnMsg = \"time-based standard deviation method used on a model \"\n",
                "            warnMsg += \"with less than %d response times\" % MIN_TIME_RESPONSES\n",
                "            logger.warn(warnMsg)\n",
                "\n",
                "        return (threadData.lastQueryDuration >= average(kb.responseTimes) + TIME_STDEV_COEFF * deviation)\n",
                "    else:\n",
                "        return threadData.lastQueryDuration - conf.timeSec\n",
                "\n",
                "def extractErrorMessage(page):\n",
                "    \"\"\"\n",
                "    Returns reported error message from page if it founds one\n",
                "    \"\"\"\n",
                "\n",
                "    retVal = None\n",
                "\n",
                "    if isinstance(page, basestring):\n",
                "        for regex in (r\"<b>[^<]*(fatal|error|warning|exception)[^<]*</b>:?\\s+(?P<result>.+?)<br\\s*/?\\s*>\", r\"<li>Error Type:<br>(?P<result>.+?)</li>\"):\n",
                "            match = re.search(regex, page, re.DOTALL | re.IGNORECASE)\n",
                "\n",
                "            if match:\n",
                "                retVal = htmlunescape(match.group(\"result\")).replace(\"<br>\", \"\\n\").strip()\n",
                "                break\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def beep():\n",
                "    \"\"\"\n",
                "    Does an audible beep sound\n",
                "    Reference: http://de3.aminet.net/dev/src/clr.py.txt\n",
                "    \"\"\"\n",
                "\n",
                "    if sys.platform == 'linux2':\n",
                "        for dev in ('/dev/audio', '/dev/oss', '/dev/dsp', '/dev/sound'):\n",
                "            if os.path.exists(dev):\n",
                "                try:\n",
                "                    audio = file(dev, 'wb')\n",
                "\n",
                "                    for i in xrange(250):\n",
                "                        audio.write(chr(32) * 4)\n",
                "                        audio.write(chr(0) * 4)\n",
                "\n",
                "                    audio.close()\n",
                "                    return\n",
                "                except:\n",
                "                    pass\n",
                "\n",
                "        try:\n",
                "            import curses\n",
                "            curses.initscr()\n",
                "            curses.beep()\n",
                "            curses.flash()\n",
                "            curses.endwin()\n",
                "            return\n",
                "        except:\n",
                "            dataToStdout('\\a', True)\n",
                "\n",
                "    else:\n",
                "        dataToStdout('\\a', True)\n",
                "\n",
                "def runningAsAdmin():\n",
                "    isAdmin = False\n",
                "\n",
                "    if PLATFORM in ( \"posix\", \"mac\" ):\n",
                "        isAdmin = os.geteuid()\n",
                "\n",
                "        if isinstance(isAdmin, (int, float, long)) and isAdmin == 0:\n",
                "            isAdmin = True\n",
                "    elif IS_WIN:\n",
                "        isAdmin = ctypes.windll.shell32.IsUserAnAdmin()\n",
                "\n",
                "        if isinstance(isAdmin, (int, float, long)) and isAdmin == 1:\n",
                "            isAdmin = True\n",
                "    else:\n",
                "        errMsg  = \"sqlmap is not able to check if you are running it \"\n",
                "        errMsg += \"as an administrator account on this platform. \"\n",
                "        errMsg += \"sqlmap will assume that you are an administrator \"\n",
                "        errMsg += \"which is mandatory for the requested takeover attack \"\n",
                "        errMsg += \"to work properly\"\n",
                "        logger.error(errMsg)\n",
                "\n",
                "        isAdmin = True\n",
                "\n",
                "    return isAdmin\n",
                "\n",
                "def logHTTPTraffic(requestLogMsg, responseLogMsg):\n",
                "    kb.locks.logLock.acquire()\n",
                "\n",
                "    dataToTrafficFile(\"%s\\n\" % requestLogMsg)\n",
                "    dataToTrafficFile(\"%s\\n\" % responseLogMsg)\n",
                "    dataToTrafficFile(\"\\n%s\\n\\n\" % (76 * '#'))\n",
                "\n",
                "    kb.locks.logLock.release()\n",
                "\n",
                "def getPageTemplate(payload, place):\n",
                "    pass\n",
                "\n",
                "def getPublicTypeMembers(type_, onlyValues=False):\n",
                "    \"\"\"\n",
                "    Useful for getting members from types (e.g. in enums)\n",
                "    \"\"\"\n",
                "    retVal = []\n",
                "\n",
                "    for name, value in getmembers(type_):\n",
                "        if not name.startswith('__'):\n",
                "            if not onlyValues:\n",
                "                retVal.append((name, value))\n",
                "            else:\n",
                "                retVal.append(value)\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def enumValueToNameLookup(type_, value_):\n",
                "    retVal = None\n",
                "\n",
                "    for name, value in getPublicTypeMembers(type_):\n",
                "        if value == value_:\n",
                "            retVal = name\n",
                "            break\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def extractRegexResult(regex, content, flags=0):\n",
                "    retVal = None\n",
                "\n",
                "    if regex and content and '?P<result>' in regex:\n",
                "        match = re.search(regex, content, flags)\n",
                "\n",
                "        if match:\n",
                "            retVal = match.group(\"result\")\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def trimAlphaNum(value):\n",
                "    \"\"\"\n",
                "    Trims alpha numeric characters from start and ending of a given value\n",
                "    \"\"\"\n",
                "    while value and value[-1].isalnum():\n",
                "        value = value[:-1]\n",
                "\n",
                "    while value and value[0].isalnum():\n",
                "        value = value[1:]\n",
                "\n",
                "    return value\n",
                "\n",
                "def isNumPosStrValue(value):\n",
                "    return value and isinstance(value, basestring) and value.isdigit() and value != \"0\"\n",
                "\n",
                "def aliasToDbmsEnum(value):\n",
                "    retVal = None\n",
                "\n",
                "    for key, item in dbmsDict.items():\n",
                "        if value in item[0]:\n",
                "            retVal = key\n",
                "            break\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def removeDynamicContent(page):\n",
                "    if page:\n",
                "        for item in kb.dynamicMarkings:\n",
                "            prefix, suffix = item\n",
                "            if prefix is None:\n",
                "                page = getCompiledRegex('(?s)^.+%s' % suffix).sub(suffix, page)\n",
                "            elif suffix is None:\n",
                "                page = getCompiledRegex('(?s)%s.+$' % prefix).sub(prefix, page)\n",
                "            else:\n",
                "                page = getCompiledRegex('(?s)%s.+%s' % (prefix, suffix)).sub('%s%s' % (prefix, suffix), page)\n",
                "\n",
                "    return page\n",
                "\n",
                "def filterStringValue(value, regex):\n",
                "    retVal = \"\"\n",
                "\n",
                "    if value:\n",
                "        for char in value:\n",
                "            if re.search(regex, char):\n",
                "                retVal += char\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def isDBMSVersionAtLeast(version):\n",
                "    retVal = None\n",
                "\n",
                "    if kb.dbmsVersion and kb.dbmsVersion[0] != UNKNOWN_DBMS_VERSION and kb.dbmsVersion[0] != None:\n",
                "        value = kb.dbmsVersion[0].replace(\" \", \"\").rstrip('.')\n",
                "\n",
                "        while True:\n",
                "            index = value.find('.', value.find('.') + 1)\n",
                "            if index > -1:\n",
                "                value = value[0:index] + value[index + 1:]\n",
                "            else:\n",
                "                break\n",
                "\n",
                "        value = filterStringValue(value, '[0-9.><=]')\n",
                "\n",
                "        if isinstance(value, basestring):\n",
                "            if value.startswith(\">=\"):\n",
                "                value = float(value.replace(\">=\", \"\"))\n",
                "            elif value.startswith(\">\"):\n",
                "                value = float(value.replace(\">\", \"\")) + 0.01\n",
                "            elif value.startswith(\"<=\"):\n",
                "                value = float(value.replace(\"<=\", \"\"))\n",
                "            elif value.startswith(\">\"):\n",
                "                value = float(value.replace(\"<\", \"\")) - 0.01\n",
                "\n",
                "        retVal = getUnicode(value) >= getUnicode(version)\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def parseSqliteTableSchema(value):\n",
                "    if value:\n",
                "        table = {}\n",
                "        columns = {}\n",
                "\n",
                "        for match in re.finditer(getCompiledRegex(r\"(\\w+) ([A-Z]+)[,\\r\\n]\"), value):\n",
                "            columns[match.group(1)] = match.group(2)\n",
                "\n",
                "        table[conf.tbl] = columns\n",
                "        kb.data.cachedColumns[conf.db] = table\n",
                "\n",
                "def getTechniqueData(technique=None):\n",
                "    retVal = None\n",
                "\n",
                "    if technique and technique in kb.injection.data:\n",
                "        retVal = kb.injection.data[technique]\n",
                "\n",
                "    return retVal\n",
                "\n",
                "def isTechniqueAvailable(technique=None):\n",
                "    return getTechniqueData(technique) is not None\n",
                "\n",
                "def initTechnique(technique=None):\n",
                "    data = getTechniqueData(technique)\n",
                "\n",
                "    if data:\n",
                "        kb.pageTemplate = getPageTemplate(data.templatePayload, kb.injection.place)\n",
                "        kb.matchRatio = data.matchRatio\n",
                "    else:\n",
                "        warnMsg = \"there is no injection data available for technique \"\n",
                "        warnMsg += \"'%s'\" % enumValueToNameLookup(PAYLOAD.TECHNIQUE, technique)\n",
                "        logger.warn(warnMsg)\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "\n",
                    "def arrayizeValue(value):\n",
                    "    if not isinstance(value, list):\n",
                    "        value = [value]\n",
                    "    return value"
                ],
                "parent_version_range": {
                    "start": 1835,
                    "end": 1835
                },
                "child_version_range": {
                    "start": 1835,
                    "end": 1840
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if data:",
                        "start_line": 1828,
                        "end_line": 1834
                    },
                    {
                        "type": "else_clause",
                        "statement": "else:",
                        "start_line": 1831,
                        "end_line": 1834
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "initTechnique",
                        "signature": "def initTechnique(technique=None):",
                        "at_line": 1825
                    },
                    {
                        "type": "call",
                        "name": "logger.warn",
                        "signature": "logger.warn(warnMsg)",
                        "at_line": 1834,
                        "argument": "warnMsg"
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: lib/core/common.py\nCode:\n             def initTechnique(technique=None):\n                 ...\n1832 1832            warnMsg = \"there is no injection data available for technique \"\n1833 1833            warnMsg += \"'%s'\" % enumValueToNameLookup(PAYLOAD.TECHNIQUE, technique)\n1834 1834            logger.warn(warnMsg)\n     1835  + \n     1836  + def arrayizeValue(value):\n     1837  +     if not isinstance(value, list):\n     1838  +         value = [value]\n     1839  +     return value\n           ...\n",
                "file_path": "lib/core/common.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "arrayizeValue",
                    "isinstance",
                    "list",
                    "value"
                ],
                "prefix": [
                    "        warnMsg = \"there is no injection data available for technique \"\n",
                    "        warnMsg += \"'%s'\" % enumValueToNameLookup(PAYLOAD.TECHNIQUE, technique)\n",
                    "        logger.warn(warnMsg)\n"
                ],
                "suffix": [],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 1836,
                                    "column": 4
                                },
                                "end": {
                                    "line": 1836,
                                    "column": 17
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/lib/core/common.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 1836,
                                    "column": 4
                                },
                                "end": {
                                    "line": 1836,
                                    "column": 17
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/lib/core/common.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 1836,
                                    "column": 4
                                },
                                "end": {
                                    "line": 1836,
                                    "column": 17
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/lib/core/common.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 1836,
                                    "column": 4
                                },
                                "end": {
                                    "line": 1836,
                                    "column": 17
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/lib/core/common.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 1836,
                                    "column": 4
                                },
                                "end": {
                                    "line": 1836,
                                    "column": 17
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/lib/core/common.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            }
        ],
        "plugins/dbms/mssqlserver/enumeration.py": [
            [
                "#!/usr/bin/env python\n",
                "\n",
                "\"\"\"\n",
                "$Id$\n",
                "\n",
                "Copyright (c) 2006-2010 sqlmap developers (http://sqlmap.sourceforge.net/)\n",
                "See the file 'doc/COPYING' for copying permission\n",
                "\"\"\"\n",
                "\n",
                "from lib.core.agent import agent\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "from lib.core.common import arrayizeValue\n"
                ],
                "parent_version_range": {
                    "start": 10,
                    "end": 10
                },
                "child_version_range": {
                    "start": 10,
                    "end": 11
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 1,
                "hunk_diff": "File: plugins/dbms/mssqlserver/enumeration.py\nCode:\n  ...\n 7  7    \"\"\"\n 8  8    \n 9  9    from lib.core.agent import agent\n   10  + from lib.core.common import arrayizeValue\n10 11    from lib.core.common import getRange\n11 12    from lib.core.common import isNumPosStrValue\n12 13    from lib.core.data import conf\n       ...\n",
                "file_path": "plugins/dbms/mssqlserver/enumeration.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "arrayizeValue",
                    "common",
                    "core",
                    "lib"
                ],
                "prefix": [
                    "\"\"\"\n",
                    "\n",
                    "from lib.core.agent import agent\n"
                ],
                "suffix": [
                    "from lib.core.common import getRange\n",
                    "from lib.core.common import isNumPosStrValue\n",
                    "from lib.core.data import conf\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 10,
                                    "column": 28
                                },
                                "end": {
                                    "line": 10,
                                    "column": 41
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/dbms/mssqlserver/enumeration.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 10,
                                    "column": 28
                                },
                                "end": {
                                    "line": 10,
                                    "column": 41
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/dbms/mssqlserver/enumeration.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    3
                ]
            },
            [
                "from lib.core.common import getRange\n",
                "from lib.core.common import isNumPosStrValue\n",
                "from lib.core.data import conf\n",
                "from lib.core.data import kb\n",
                "from lib.core.data import logger\n",
                "from lib.core.data import queries\n",
                "from lib.core.enums import DBMS\n",
                "from lib.core.enums import EXPECTED\n",
                "from lib.core.exception import sqlmapNoneDataException\n",
                "from lib.request import inject\n",
                "\n",
                "from plugins.generic.enumeration import Enumeration as GenericEnumeration\n",
                "\n",
                "class Enumeration(GenericEnumeration):\n",
                "    def __init__(self):\n",
                "        GenericEnumeration.__init__(self, DBMS.MSSQL)\n",
                "\n",
                "    def getPrivileges(self, *args):\n",
                "        warnMsg  = \"on Microsoft SQL Server it is not possible to fetch \"\n",
                "        warnMsg += \"database users privileges\"\n",
                "        logger.warn(warnMsg)\n",
                "\n",
                "        return {}\n",
                "\n",
                "    def getTables(self):\n",
                "        infoMsg = \"fetching tables\"\n",
                "        if conf.db:\n",
                "            infoMsg += \" for database '%s'\" % conf.db\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        rootQuery = queries[kb.dbms].tables\n",
                "\n",
                "        if not conf.db:\n",
                "            if not len(kb.data.cachedDbs):\n",
                "                dbs = self.getDbs()\n",
                "            else:\n",
                "                dbs = kb.data.cachedDbs\n",
                "        else:\n",
                "            if \",\" in conf.db:\n",
                "                dbs = conf.db.split(\",\")\n",
                "            else:\n",
                "                dbs = [conf.db]\n",
                "\n",
                "        if kb.unionPosition is not None or conf.direct:\n",
                "            for db in dbs:\n",
                "                if conf.excludeSysDbs and db in self.excludeDbsList:\n",
                "                    infoMsg = \"skipping system database '%s'\" % db\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "                    continue\n",
                "\n",
                "                query = rootQuery.inband.query % db\n",
                "                value = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "                if value:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                    kb.data.cachedTables[db] = value\n"
                ],
                "after": [
                    "                    kb.data.cachedTables[db] = arrayizeValue(value)\n"
                ],
                "parent_version_range": {
                    "start": 65,
                    "end": 66
                },
                "child_version_range": {
                    "start": 66,
                    "end": 67
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if kb.unionPosition is not None or conf.direct:",
                        "start_line": 53,
                        "end_line": 65
                    },
                    {
                        "type": "for_statement",
                        "statement": "for db in dbs:",
                        "start_line": 54,
                        "end_line": 65
                    },
                    {
                        "type": "if_statement",
                        "statement": "if value:",
                        "start_line": 64,
                        "end_line": 65
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Enumeration",
                        "signature": "class Enumeration(GenericEnumeration):",
                        "at_line": 23
                    },
                    {
                        "type": "function",
                        "name": "getTables",
                        "signature": "def getTables(self):",
                        "at_line": 34
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: plugins/dbms/mssqlserver/enumeration.py\nCode:\n         class Enumeration(GenericEnumeration):\n             ...\n             def getTables(self):\n                 ...\n62 63                    value = inject.getValue(query, blind=False, error=False)\n63 64    \n64 65                    if value:\n65     -                     kb.data.cachedTables[db] = value\n   66  +                     kb.data.cachedTables[db] = arrayizeValue(value)\n66 67    \n67 68            if not kb.data.cachedTables and not conf.direct:\n68 69                for db in dbs:\n       ...\n",
                "file_path": "plugins/dbms/mssqlserver/enumeration.py",
                "identifiers_before": [
                    "cachedTables",
                    "data",
                    "db",
                    "kb",
                    "value"
                ],
                "identifiers_after": [
                    "arrayizeValue",
                    "cachedTables",
                    "data",
                    "db",
                    "kb",
                    "value"
                ],
                "prefix": [
                    "                value = inject.getValue(query, blind=False, error=False)\n",
                    "\n",
                    "                if value:\n"
                ],
                "suffix": [
                    "\n",
                    "        if not kb.data.cachedTables and not conf.direct:\n",
                    "            for db in dbs:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 66,
                                    "column": 47
                                },
                                "end": {
                                    "line": 66,
                                    "column": 60
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/dbms/mssqlserver/enumeration.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 66,
                                    "column": 47
                                },
                                "end": {
                                    "line": 66,
                                    "column": 60
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/dbms/mssqlserver/enumeration.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    4
                ]
            },
            [
                "\n",
                "        if not kb.data.cachedTables and not conf.direct:\n",
                "            for db in dbs:\n",
                "                if conf.excludeSysDbs and db in self.excludeDbsList:\n",
                "                    infoMsg = \"skipping system database '%s'\" % db\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "                    continue\n",
                "\n",
                "                infoMsg  = \"fetching number of tables for \"\n",
                "                infoMsg += \"database '%s'\" % db\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                query = rootQuery.blind.count % db\n",
                "                count = inject.getValue(query, inband=False, charsetType=2)\n",
                "\n",
                "                if not isNumPosStrValue(count):\n",
                "                    warnMsg  = \"unable to retrieve the number of \"\n",
                "                    warnMsg += \"tables for database '%s'\" % db\n",
                "                    logger.warn(warnMsg)\n",
                "                    continue\n",
                "\n",
                "                tables = []\n",
                "\n",
                "                for index in range(int(count)):\n",
                "                    query = rootQuery.blind.query % (db, index, db)\n",
                "                    table = inject.getValue(query, inband=False)\n",
                "                    tables.append(table)\n",
                "                    kb.hintValue = table\n",
                "\n",
                "                if tables:\n",
                "                    kb.data.cachedTables[db] = tables\n",
                "                else:\n",
                "                    warnMsg  = \"unable to retrieve the tables \"\n",
                "                    warnMsg += \"for database '%s'\" % db\n",
                "                    logger.warn(warnMsg)\n",
                "\n",
                "        if not kb.data.cachedTables:\n",
                "            errMsg = \"unable to retrieve the tables for any database\"\n",
                "            raise sqlmapNoneDataException(errMsg)\n",
                "\n",
                "        return kb.data.cachedTables\n",
                "\n",
                "    def searchTable(self):\n",
                "        rootQuery = queries[kb.dbms].search_table\n",
                "        foundTbls = {}\n",
                "        tblList = conf.tbl.split(\",\")\n",
                "        tblCond = rootQuery.inband.condition\n",
                "        dbCond = rootQuery.inband.condition2\n",
                "\n",
                "        tblConsider, tblCondParam = self.likeOrExact(\"table\")\n",
                "\n",
                "        if not len(kb.data.cachedDbs):\n",
                "            enumDbs = self.getDbs()\n",
                "        else:\n",
                "            enumDbs = kb.data.cachedDbs\n",
                "\n",
                "        for db in enumDbs:\n",
                "            foundTbls[db] = []\n",
                "\n",
                "        for tbl in tblList:\n",
                "            infoMsg = \"searching table\"\n",
                "            if tblConsider == \"1\":\n",
                "                infoMsg += \"s like\"\n",
                "            infoMsg += \" '%s'\" % tbl\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            tblQuery = \"%s%s\" % (tblCond, tblCondParam)\n",
                "            tblQuery = tblQuery % tbl\n",
                "\n",
                "            for db in foundTbls.keys():\n",
                "                if conf.excludeSysDbs and db in self.excludeDbsList:\n",
                "                    infoMsg = \"skipping system database '%s'\" % db\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "                    continue\n",
                "\n",
                "                if kb.unionPosition is not None or conf.direct:\n",
                "                    query = rootQuery.inband.query % db\n",
                "                    query += tblQuery\n",
                "                    values = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "                    if values:\n",
                "                        if isinstance(values, basestring):\n",
                "                            values = [ values ]\n",
                "\n",
                "                        for foundTbl in values:\n",
                "                            foundTbls[db].append(foundTbl)\n",
                "                else:\n",
                "                    infoMsg = \"fetching number of table\"\n",
                "                    if tblConsider == \"1\":\n",
                "                        infoMsg += \"s like\"\n",
                "                    infoMsg += \" '%s' in database '%s'\" % (tbl, db)\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "                    query = rootQuery.blind.count2\n",
                "                    query = query % db\n",
                "                    query += \" AND %s\" % tblQuery\n",
                "                    count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "                    if not isNumPosStrValue(count):\n",
                "                        warnMsg = \"no table\"\n",
                "                        if tblConsider == \"1\":\n",
                "                            warnMsg += \"s like\"\n",
                "                        warnMsg += \" '%s' \" % tbl\n",
                "                        warnMsg += \"in database '%s'\" % db\n",
                "                        logger.warn(warnMsg)\n",
                "\n",
                "                        continue\n",
                "\n",
                "                    indexRange = getRange(count)\n",
                "\n",
                "                    for index in indexRange:\n",
                "                        query = rootQuery.blind.query2\n",
                "                        query = query % db\n",
                "                        query += \" AND %s\" % tblQuery\n",
                "                        query = agent.limitQuery(index, query, tblCond)\n",
                "                        tbl = inject.getValue(query, inband=False)\n",
                "                        kb.hintValue = tbl\n",
                "                        foundTbls[db].append(tbl)\n",
                "\n",
                "        for db, tbls in foundTbls.items():\n",
                "            if len(tbls) == 0:\n",
                "                foundTbls.pop(db)\n",
                "\n",
                "        return foundTbls\n",
                "\n",
                "    def searchColumn(self):\n",
                "        rootQuery = queries[kb.dbms].search_column\n",
                "        foundCols = {}\n",
                "        dbs = {}\n",
                "        colList = conf.col.split(\",\")\n",
                "        colCond = rootQuery.inband.condition\n",
                "        colConsider, colCondParam = self.likeOrExact(\"column\")\n",
                "\n",
                "        if not len(kb.data.cachedDbs):\n",
                "            enumDbs = self.getDbs()\n",
                "        else:\n",
                "            enumDbs = kb.data.cachedDbs\n",
                "\n",
                "        for db in enumDbs:\n",
                "            dbs[db] = {}\n",
                "\n",
                "        for column in colList:\n",
                "            infoMsg = \"searching column\"\n",
                "            if colConsider == \"1\":\n",
                "                infoMsg += \"s like\"\n",
                "            infoMsg += \" '%s'\" % column\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            foundCols[column] = {}\n",
                "\n",
                "            colQuery = \"%s%s\" % (colCond, colCondParam)\n",
                "            colQuery = colQuery % column\n",
                "\n",
                "            for db in dbs.keys():\n",
                "                if conf.excludeSysDbs and db in self.excludeDbsList:\n",
                "                    infoMsg = \"skipping system database '%s'\" % db\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "                    continue\n",
                "\n",
                "                if kb.unionPosition is not None or conf.direct:\n",
                "                    query = rootQuery.inband.query % (db, db, db, db, db)\n",
                "                    query += \" AND %s\" % colQuery.replace(\"[DB]\", db)\n",
                "                    values = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "                    if values:\n",
                "                        if isinstance(values, basestring):\n",
                "                            values = [ values ]\n",
                "\n",
                "                        for foundTbl in values:\n",
                "                            if foundTbl not in dbs[db]:\n",
                "                                dbs[db][foundTbl] = {}\n",
                "\n",
                "                            if colConsider == \"1\":\n",
                "                                conf.db = db\n",
                "                                conf.tbl = foundTbl\n",
                "                                conf.col = column\n",
                "\n",
                "                                self.getColumns(onlyColNames=True)\n",
                "\n",
                "                                dbs[db][foundTbl].update(kb.data.cachedColumns[db][foundTbl])\n",
                "                                kb.data.cachedColumns = {}\n",
                "                            else:\n",
                "                                dbs[db][foundTbl][column] = None\n",
                "\n",
                "                            if db in foundCols[column]:\n",
                "                                foundCols[column][db].append(foundTbl)\n",
                "                            else:\n",
                "                                foundCols[column][db] = [ foundTbl ]\n",
                "                else:\n",
                "                    foundCols[column][db] = []\n",
                "\n",
                "                    infoMsg = \"fetching number of tables containing column\"\n",
                "                    if colConsider == \"1\":\n",
                "                        infoMsg += \"s like\"\n",
                "                    infoMsg += \" '%s' in database '%s'\" % (column, db)\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "                    query = rootQuery.blind.count2\n",
                "                    query = query % (db, db, db, db, db)\n",
                "                    query += \" AND %s\" % colQuery.replace(\"[DB]\", db)\n",
                "                    count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "                    if not isNumPosStrValue(count):\n",
                "                        warnMsg = \"no tables contain column\"\n",
                "                        if colConsider == \"1\":\n",
                "                            warnMsg += \"s like\"\n",
                "                        warnMsg += \" '%s' \" % column\n",
                "                        warnMsg += \"in database '%s'\" % db\n",
                "                        logger.warn(warnMsg)\n",
                "\n",
                "                        continue\n",
                "\n",
                "                    indexRange = getRange(count)\n",
                "\n",
                "                    for index in indexRange:\n",
                "                        query = rootQuery.blind.query2\n",
                "                        query = query % (db, db, db, db, db)\n",
                "                        query += \" AND %s\" % colQuery.replace(\"[DB]\", db)\n",
                "                        query = agent.limitQuery(index, query, colCond.replace(\"[DB]\", db))\n",
                "                        tbl = inject.getValue(query, inband=False)\n",
                "                        kb.hintValue = tbl\n",
                "\n",
                "                        if tbl not in dbs[db]:\n",
                "                            dbs[db][tbl] = {}\n",
                "\n",
                "                        if colConsider == \"1\":\n",
                "                            conf.db = db\n",
                "                            conf.tbl = tbl\n",
                "                            conf.col = column\n",
                "\n",
                "                            self.getColumns(onlyColNames=True)\n",
                "\n",
                "                            dbs[db][tbl].update(kb.data.cachedColumns[db][tbl])\n",
                "                            kb.data.cachedColumns = {}\n",
                "                        else:\n",
                "                            dbs[db][tbl][column] = None\n",
                "\n",
                "                        foundCols[column][db].append(tbl)\n",
                "\n",
                "        self.dumpFoundColumn(dbs, foundCols, colConsider)"
            ]
        ],
        "plugins/generic/enumeration.py": [
            [
                "#!/usr/bin/env python\n",
                "\n",
                "\"\"\"\n",
                "$Id$\n",
                "\n",
                "Copyright (c) 2006-2010 sqlmap developers (http://sqlmap.sourceforge.net/)\n",
                "See the file 'doc/COPYING' for copying permission\n",
                "\"\"\"\n",
                "\n",
                "import re\n",
                "import time\n",
                "\n",
                "from lib.core.agent import agent\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "from lib.core.common import arrayizeValue\n"
                ],
                "parent_version_range": {
                    "start": 13,
                    "end": 13
                },
                "child_version_range": {
                    "start": 13,
                    "end": 14
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 3,
                "hunk_diff": "File: plugins/generic/enumeration.py\nCode:\n  ...\n10 10    import time\n11 11    \n12 12    from lib.core.agent import agent\n   13  + from lib.core.common import arrayizeValue\n13 14    from lib.core.common import dataToStdout\n14 15    from lib.core.common import getRange\n15 16    from lib.core.common import getCompiledRegex\n       ...\n",
                "file_path": "plugins/generic/enumeration.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "arrayizeValue",
                    "common",
                    "core",
                    "lib"
                ],
                "prefix": [
                    "import time\n",
                    "\n",
                    "from lib.core.agent import agent\n"
                ],
                "suffix": [
                    "from lib.core.common import dataToStdout\n",
                    "from lib.core.common import getRange\n",
                    "from lib.core.common import getCompiledRegex\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 13,
                                    "column": 28
                                },
                                "end": {
                                    "line": 13,
                                    "column": 41
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/generic/enumeration.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 13,
                                    "column": 28
                                },
                                "end": {
                                    "line": 13,
                                    "column": 41
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/generic/enumeration.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 13,
                                    "column": 28
                                },
                                "end": {
                                    "line": 13,
                                    "column": 41
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/generic/enumeration.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    1
                ]
            },
            [
                "from lib.core.common import dataToStdout\n",
                "from lib.core.common import getRange\n",
                "from lib.core.common import getCompiledRegex\n",
                "from lib.core.common import getConsoleWidth\n",
                "from lib.core.common import getFileItems\n",
                "from lib.core.common import getUnicode\n",
                "from lib.core.common import isNumPosStrValue\n",
                "from lib.core.common import isTechniqueAvailable\n",
                "from lib.core.common import parsePasswordHash\n",
                "from lib.core.common import parseSqliteTableSchema\n",
                "from lib.core.common import popValue\n",
                "from lib.core.common import pushValue\n",
                "from lib.core.common import randomStr\n",
                "from lib.core.common import readInput\n",
                "from lib.core.common import safeStringFormat\n",
                "from lib.core.common import strToHex\n",
                "from lib.core.convert import utf8decode\n",
                "from lib.core.data import conf\n",
                "from lib.core.data import kb\n",
                "from lib.core.data import logger\n",
                "from lib.core.data import paths\n",
                "from lib.core.data import queries\n",
                "from lib.core.enums import DBMS\n",
                "from lib.core.enums import EXPECTED\n",
                "from lib.core.enums import PAYLOAD\n",
                "from lib.core.exception import sqlmapMissingMandatoryOptionException\n",
                "from lib.core.exception import sqlmapNoneDataException\n",
                "from lib.core.exception import sqlmapUnsupportedFeatureException\n",
                "from lib.core.exception import sqlmapUserQuitException\n",
                "from lib.core.session import setOs\n",
                "from lib.core.settings import SQL_STATEMENTS\n",
                "from lib.core.shell import autoCompletion\n",
                "from lib.core.unescaper import unescaper\n",
                "from lib.parse.banner import bannerParser\n",
                "from lib.request import inject\n",
                "from lib.request.connect import Connect as Request\n",
                "from lib.techniques.brute.use import columnExists\n",
                "from lib.techniques.brute.use import tableExists\n",
                "from lib.techniques.inband.union.test import unionTest\n",
                "from lib.utils.hash import dictionaryAttack\n",
                "\n",
                "class Enumeration:\n",
                "    \"\"\"\n",
                "    This class defines generic enumeration functionalities for plugins.\n",
                "    \"\"\"\n",
                "\n",
                "    def __init__(self, dbms):\n",
                "        kb.data.has_information_schema = False\n",
                "        kb.data.banner                 = \"\"\n",
                "        kb.data.currentUser            = \"\"\n",
                "        kb.data.currentDb              = \"\"\n",
                "        kb.data.cachedUsers            = []\n",
                "        kb.data.cachedUsersPasswords   = {}\n",
                "        kb.data.cachedUsersPrivileges  = {}\n",
                "        kb.data.cachedUsersRoles       = {}\n",
                "        kb.data.cachedDbs              = []\n",
                "        kb.data.cachedTables           = {}\n",
                "        kb.data.cachedColumns          = {}\n",
                "        kb.data.dumpedTable            = {}\n",
                "        kb.data.processChar            = None\n",
                "        kb.misc.testedDbms             = dbms\n",
                "\n",
                "    def getBanner(self):\n",
                "        if not conf.getBanner:\n",
                "            return\n",
                "\n",
                "        kb.dbmsDetected = True\n",
                "\n",
                "        infoMsg = \"fetching banner\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        if not kb.data.banner:\n",
                "            if conf.unionTest:\n",
                "                conf.dumper.technic(\"inband injection payload\", unionTest())\n",
                "\n",
                "            query          = queries[kb.dbms].banner.query\n",
                "            kb.data.banner = inject.getValue(query)\n",
                "            bannerParser(kb.data.banner)\n",
                "\n",
                "        if conf.os and conf.os == \"windows\":\n",
                "            kb.bannerFp[\"type\"] = set([ \"Windows\" ])\n",
                "\n",
                "        elif conf.os and conf.os == \"linux\":\n",
                "            kb.bannerFp[\"type\"] = set([ \"Linux\" ])\n",
                "\n",
                "        elif conf.os:\n",
                "            kb.bannerFp[\"type\"] = set([ \"%s%s\" % (conf.os[0].upper(), conf.os[1:]) ])\n",
                "\n",
                "        setOs()\n",
                "\n",
                "        return kb.data.banner\n",
                "\n",
                "    def getCurrentUser(self):\n",
                "        infoMsg = \"fetching current user\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        query = queries[kb.dbms].current_user.query\n",
                "\n",
                "        if not kb.data.currentUser:\n",
                "            kb.data.currentUser = inject.getValue(query)\n",
                "\n",
                "        return kb.data.currentUser\n",
                "\n",
                "    def getCurrentDb(self):\n",
                "        infoMsg = \"fetching current database\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        query = queries[kb.dbms].current_db.query\n",
                "\n",
                "        if not kb.data.currentDb:\n",
                "            kb.data.currentDb = inject.getValue(query)\n",
                "\n",
                "        return kb.data.currentDb\n",
                "\n",
                "    def isDba(self):\n",
                "        infoMsg = \"testing if current user is DBA\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        if kb.dbms == DBMS.MYSQL:\n",
                "            self.getCurrentUser()\n",
                "            query = queries[kb.dbms].is_dba.query % kb.data.currentUser.split(\"@\")[0]\n",
                "        else:\n",
                "            query = queries[kb.dbms].is_dba.query\n",
                "\n",
                "        query = agent.forgeCaseStatement(query)\n",
                "\n",
                "        kb.data.isDba = inject.getValue(query, unpack=False, charsetType=1)\n",
                "\n",
                "        return kb.data.isDba == \"1\"\n",
                "\n",
                "    def getUsers(self):\n",
                "        infoMsg = \"fetching database users\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        rootQuery = queries[kb.dbms].users\n",
                "\n",
                "        condition  = ( kb.dbms == DBMS.MSSQL and kb.dbmsVersion[0] in ( \"2005\", \"2008\" ) )\n",
                "        condition |= ( kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema )\n",
                "\n",
                "        if kb.unionPosition is not None or conf.direct:\n",
                "            if condition:\n",
                "                query = rootQuery.inband.query2\n",
                "            else:\n",
                "                query = rootQuery.inband.query\n",
                "            value = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "            if value:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                kb.data.cachedUsers = value\n"
                ],
                "after": [
                    "                kb.data.cachedUsers = arrayizeValue(value)\n"
                ],
                "parent_version_range": {
                    "start": 160,
                    "end": 161
                },
                "child_version_range": {
                    "start": 161,
                    "end": 162
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if kb.unionPosition is not None or conf.direct:",
                        "start_line": 152,
                        "end_line": 160
                    },
                    {
                        "type": "if_statement",
                        "statement": "if value:",
                        "start_line": 159,
                        "end_line": 160
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Enumeration",
                        "signature": "class Enumeration:",
                        "at_line": 54
                    },
                    {
                        "type": "function",
                        "name": "getUsers",
                        "signature": "def getUsers(self):",
                        "at_line": 143
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: plugins/generic/enumeration.py\nCode:\n           class Enumeration:\n               ...\n               def getUsers(self):\n                   ...\n157 158                value = inject.getValue(query, blind=False, error=False)\n158 159    \n159 160                if value:\n160      -                 kb.data.cachedUsers = value\n    161  +                 kb.data.cachedUsers = arrayizeValue(value)\n161 162    \n162 163            if not kb.data.cachedUsers and not conf.direct:\n163 164                infoMsg = \"fetching number of database users\"\n         ...\n",
                "file_path": "plugins/generic/enumeration.py",
                "identifiers_before": [
                    "cachedUsers",
                    "data",
                    "kb",
                    "value"
                ],
                "identifiers_after": [
                    "arrayizeValue",
                    "cachedUsers",
                    "data",
                    "kb",
                    "value"
                ],
                "prefix": [
                    "            value = inject.getValue(query, blind=False, error=False)\n",
                    "\n",
                    "            if value:\n"
                ],
                "suffix": [
                    "\n",
                    "        if not kb.data.cachedUsers and not conf.direct:\n",
                    "            infoMsg = \"fetching number of database users\"\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 161,
                                    "column": 38
                                },
                                "end": {
                                    "line": 161,
                                    "column": 51
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/generic/enumeration.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 161,
                                    "column": 38
                                },
                                "end": {
                                    "line": 161,
                                    "column": 51
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/generic/enumeration.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    2
                ]
            },
            [
                "\n",
                "        if not kb.data.cachedUsers and not conf.direct:\n",
                "            infoMsg = \"fetching number of database users\"\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            if condition:\n",
                "                query = rootQuery.blind.count2\n",
                "            else:\n",
                "                query = rootQuery.blind.count\n",
                "            count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "            if not isNumPosStrValue(count):\n",
                "                errMsg = \"unable to retrieve the number of database users\"\n",
                "                raise sqlmapNoneDataException, errMsg\n",
                "\n",
                "            if kb.dbms == DBMS.ORACLE:\n",
                "                plusOne = True\n",
                "            else:\n",
                "                plusOne = False\n",
                "            indexRange = getRange(count, plusOne=plusOne)\n",
                "\n",
                "            for index in indexRange:\n",
                "                if kb.dbms in (DBMS.SYBASE, DBMS.MAXDB):\n",
                "                    query = rootQuery.blind.query % (kb.data.cachedUsers[-1] if kb.data.cachedUsers else \" \")\n",
                "                elif condition:\n",
                "                    query = rootQuery.blind.query2 % index\n",
                "                else:\n",
                "                    query = rootQuery.blind.query % index\n",
                "                user = inject.getValue(query, inband=False)\n",
                "\n",
                "                if user:\n",
                "                    kb.data.cachedUsers.append(user)\n",
                "\n",
                "        if not kb.data.cachedUsers:\n",
                "            errMsg = \"unable to retrieve the database users\"\n",
                "            raise sqlmapNoneDataException, errMsg\n",
                "\n",
                "        return kb.data.cachedUsers\n",
                "\n",
                "    def getPasswordHashes(self):\n",
                "        infoMsg = \"fetching database users password hashes\"\n",
                "\n",
                "        rootQuery = queries[kb.dbms].passwords\n",
                "\n",
                "        if conf.user == \"CU\":\n",
                "            infoMsg += \" for current user\"\n",
                "            conf.user = self.getCurrentUser()\n",
                "\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        if kb.unionPosition is not None or conf.direct:\n",
                "            if kb.dbms == DBMS.MSSQL and kb.dbmsVersion[0] in ( \"2005\", \"2008\" ):\n",
                "                query = rootQuery.inband.query2\n",
                "            else:\n",
                "                query = rootQuery.inband.query\n",
                "\n",
                "            condition = rootQuery.inband.condition\n",
                "\n",
                "            if conf.user:\n",
                "                if \",\" in conf.user:\n",
                "                    users = conf.user.split(\",\")\n",
                "                    query += \" WHERE \"\n",
                "                    query += \" OR \".join(\"%s = '%s'\" % (condition, user) for user in users)\n",
                "                else:\n",
                "                    if kb.dbms == DBMS.MYSQL:\n",
                "                        parsedUser = re.search(\"[\\047]*(.*?)[\\047]*\\@\", conf.user)\n",
                "\n",
                "                        if parsedUser:\n",
                "                            conf.user = parsedUser.groups()[0]\n",
                "\n",
                "                    query += \" WHERE %s = '%s'\" % (condition, conf.user)\n",
                "\n",
                "            value = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "            if value:\n",
                "                for user, password in value:\n",
                "                    if not user or user == \" \":\n",
                "                        continue\n",
                "\n",
                "                    password = parsePasswordHash(password)\n",
                "\n",
                "                    if not kb.data.cachedUsersPasswords.has_key(user):\n",
                "                        kb.data.cachedUsersPasswords[user] = [password]\n",
                "                    else:\n",
                "                        kb.data.cachedUsersPasswords[user].append(password)\n",
                "\n",
                "        if not kb.data.cachedUsersPasswords and not conf.direct:\n",
                "            if conf.user:\n",
                "                if \",\" in conf.user:\n",
                "                    users = conf.user.split(\",\")\n",
                "                else:\n",
                "                    users = [conf.user]\n",
                "            else:\n",
                "                if not len(kb.data.cachedUsers):\n",
                "                    users = self.getUsers()\n",
                "                else:\n",
                "                    users = kb.data.cachedUsers\n",
                "\n",
                "            retrievedUsers = set()\n",
                "\n",
                "            for user in users:\n",
                "                if kb.dbms == DBMS.MYSQL:\n",
                "                    parsedUser = re.search(\"[\\047]*(.*?)[\\047]*\\@\", user)\n",
                "\n",
                "                    if parsedUser:\n",
                "                        user = parsedUser.groups()[0]\n",
                "\n",
                "                if user in retrievedUsers:\n",
                "                    continue\n",
                "\n",
                "                infoMsg  = \"fetching number of password hashes \"\n",
                "                infoMsg += \"for user '%s'\" % user\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                if kb.dbms == DBMS.MSSQL and kb.dbmsVersion[0] in ( \"2005\", \"2008\" ):\n",
                "                    query = rootQuery.blind.count2 % user\n",
                "                else:\n",
                "                    query = rootQuery.blind.count % user\n",
                "                count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "                if not isNumPosStrValue(count):\n",
                "                    warnMsg  = \"unable to retrieve the number of password \"\n",
                "                    warnMsg += \"hashes for user '%s'\" % user\n",
                "                    logger.warn(warnMsg)\n",
                "                    continue\n",
                "\n",
                "                infoMsg = \"fetching password hashes for user '%s'\" % user\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                passwords  = []\n",
                "\n",
                "                if kb.dbms == DBMS.ORACLE:\n",
                "                    plusOne = True\n",
                "                else:\n",
                "                    plusOne = False\n",
                "                indexRange = getRange(count, plusOne=plusOne)\n",
                "\n",
                "                for index in indexRange:\n",
                "                    if kb.dbms == DBMS.SYBASE:\n",
                "                        if index > 0:\n",
                "                            warnMsg  = \"unable to retrieve other password \"\n",
                "                            warnMsg += \"hashes for user '%s'\" % user\n",
                "                            logger.warn(warnMsg)\n",
                "                            break\n",
                "                        else:\n",
                "                            query = rootQuery.blind.query % user\n",
                "                            kb.disableStdOut = True\n",
                "                    elif kb.dbms == DBMS.MSSQL:\n",
                "                        if kb.dbmsVersion[0] in ( \"2005\", \"2008\" ):\n",
                "                            query = rootQuery.blind.query2 % (user, index, user)\n",
                "                        else:\n",
                "                            query = rootQuery.blind.query % (user, index, user)\n",
                "                    else:\n",
                "                        query = rootQuery.blind.query % (user, index)\n",
                "                    password = inject.getValue(query, inband=False)\n",
                "                    if kb.dbms == DBMS.SYBASE:\n",
                "                        kb.disableStdOut = False\n",
                "                        password = \"0x%s\" % strToHex(password)\n",
                "                        infoMsg = \"retrieved: %s\" % password\n",
                "                        logger.info(infoMsg)\n",
                "                    password = parsePasswordHash(password)\n",
                "                    passwords.append(password)\n",
                "\n",
                "                if passwords:\n",
                "                    kb.data.cachedUsersPasswords[user] = passwords\n",
                "                else:\n",
                "                    warnMsg  = \"unable to retrieve the password \"\n",
                "                    warnMsg += \"hashes for user '%s'\" % user\n",
                "                    logger.warn(warnMsg)\n",
                "\n",
                "                retrievedUsers.add(user)\n",
                "\n",
                "        if not kb.data.cachedUsersPasswords:\n",
                "            errMsg  = \"unable to retrieve the password \"\n",
                "            errMsg += \"hashes for the database users\"\n",
                "            raise sqlmapNoneDataException, errMsg\n",
                "\n",
                "        message = \"do you want to use dictionary attack on retrieved password hashes? [Y/n/q]\"\n",
                "        test = readInput(message, default=\"Y\")\n",
                "\n",
                "        if test[0] in (\"n\", \"N\"):\n",
                "            pass\n",
                "        elif test[0] in (\"q\", \"Q\"):\n",
                "            raise sqlmapUserQuitException\n",
                "        else:\n",
                "            dictionaryAttack()\n",
                "\n",
                "        return kb.data.cachedUsersPasswords\n",
                "\n",
                "    def __isAdminFromPrivileges(self, privileges):\n",
                "        # In PostgreSQL the usesuper privilege means that the\n",
                "        # user is DBA\n",
                "        dbaCondition  = ( kb.dbms == DBMS.PGSQL and \"super\" in privileges )\n",
                "\n",
                "        # In Oracle the DBA privilege means that the\n",
                "        # user is DBA\n",
                "        dbaCondition |= ( kb.dbms == DBMS.ORACLE and \"DBA\" in privileges )\n",
                "\n",
                "        # In MySQL >= 5.0 the SUPER privilege means\n",
                "        # that the user is DBA\n",
                "        dbaCondition |= ( kb.dbms == DBMS.MYSQL and kb.data.has_information_schema and \"SUPER\" in privileges )\n",
                "\n",
                "        # In MySQL < 5.0 the super_priv privilege means\n",
                "        # that the user is DBA\n",
                "        dbaCondition |= ( kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema and \"super_priv\" in privileges )\n",
                "\n",
                "        # In Firebird there is no specific privilege that means\n",
                "        # that the user is DBA\n",
                "        # TODO: confirm\n",
                "        dbaCondition |= ( kb.dbms == DBMS.FIREBIRD and \"SELECT\" in privileges and \"INSERT\" in privileges and \"UPDATE\" in privileges and \"DELETE\" in privileges and \"REFERENCES\" in privileges and \"EXECUTE\" in privileges )\n",
                "\n",
                "        return dbaCondition\n",
                "\n",
                "    def getPrivileges(self, query2=False):\n",
                "        infoMsg = \"fetching database users privileges\"\n",
                "\n",
                "        rootQuery = queries[kb.dbms].privileges\n",
                "\n",
                "        if conf.user == \"CU\":\n",
                "            infoMsg += \" for current user\"\n",
                "            conf.user = self.getCurrentUser()\n",
                "\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        # Set containing the list of DBMS administrators\n",
                "        areAdmins = set()\n",
                "\n",
                "        mysqlPrivs = (\n",
                "                        ( 1, \"select_priv\" ),\n",
                "                        ( 2, \"insert_priv\" ),\n",
                "                        ( 3, \"update_priv\" ),\n",
                "                        ( 4, \"delete_priv\" ),\n",
                "                        ( 5, \"create_priv\" ),\n",
                "                        ( 6, \"drop_priv\" ),\n",
                "                        ( 7, \"reload_priv\" ),\n",
                "                        ( 8, \"shutdown_priv\" ),\n",
                "                        ( 9, \"process_priv\" ),\n",
                "                        ( 10, \"file_priv\" ),\n",
                "                        ( 11, \"grant_priv\" ),\n",
                "                        ( 12, \"references_priv\" ),\n",
                "                        ( 13, \"index_priv\" ),\n",
                "                        ( 14, \"alter_priv\" ),\n",
                "                        ( 15, \"show_db_priv\" ),\n",
                "                        ( 16, \"super_priv\" ),\n",
                "                        ( 17, \"create_tmp_table_priv\" ),\n",
                "                        ( 18, \"lock_tables_priv\" ),\n",
                "                        ( 19, \"execute_priv\" ),\n",
                "                        ( 20, \"repl_slave_priv\" ),\n",
                "                        ( 21, \"repl_client_priv\" ),\n",
                "                        ( 22, \"create_view_priv\" ),\n",
                "                        ( 23, \"show_view_priv\" ),\n",
                "                        ( 24, \"create_routine_priv\" ),\n",
                "                        ( 25, \"alter_routine_priv\" ),\n",
                "                        ( 26, \"create_user_priv\" ),\n",
                "                     )\n",
                "\n",
                "        pgsqlPrivs = (\n",
                "                        ( 1, \"createdb\" ),\n",
                "                        ( 2, \"super\" ),\n",
                "                        ( 3, \"catupd\" ),\n",
                "                     )\n",
                "\n",
                "        firebirdPrivs = {\n",
                "                         \"S\": \"SELECT\",\n",
                "                         \"I\": \"INSERT\",\n",
                "                         \"U\": \"UPDATE\",\n",
                "                         \"D\": \"DELETE\",\n",
                "                         \"R\": \"REFERENCES\",\n",
                "                         \"E\": \"EXECUTE\"\n",
                "                     }\n",
                "\n",
                "        if kb.unionPosition is not None or conf.direct:\n",
                "            if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                query     = rootQuery.inband.query2\n",
                "                condition = rootQuery.inband.condition2\n",
                "            elif kb.dbms == DBMS.ORACLE and query2:\n",
                "                query     = rootQuery.inband.query2\n",
                "                condition = rootQuery.inband.condition2\n",
                "            else:\n",
                "                query     = rootQuery.inband.query\n",
                "                condition = rootQuery.inband.condition\n",
                "\n",
                "            if conf.user:\n",
                "                users = conf.user.split(\",\")\n",
                "                query += \" WHERE \"\n",
                "                # NOTE: I assume that the user provided is not in\n",
                "                # MySQL >= 5.0 syntax 'user'@'host'\n",
                "                if kb.dbms == DBMS.MYSQL and kb.data.has_information_schema:\n",
                "                    queryUser = \"%\" + conf.user + \"%\"\n",
                "                    query += \" OR \".join(\"%s LIKE '%s'\" % (condition, \"%\" + user + \"%\") for user in users)\n",
                "                else:\n",
                "                    query += \" OR \".join(\"%s = '%s'\" % (condition, user) for user in users)\n",
                "\n",
                "            values = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "            if not values and kb.dbms == DBMS.ORACLE and not query2:\n",
                "                infoMsg = \"trying with table USER_SYS_PRIVS\"\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                return self.getPrivileges(query2=True)\n",
                "\n",
                "            if values:\n",
                "                for value in values:\n",
                "                    user       = None\n",
                "                    privileges = set()\n",
                "\n",
                "                    for count in xrange(0, len(value)):\n",
                "                        # The first column is always the username\n",
                "                        if count == 0:\n",
                "                            user = value[count]\n",
                "\n",
                "                        # The other columns are the privileges\n",
                "                        else:\n",
                "                            privilege = value[count]\n",
                "\n",
                "                            # In PostgreSQL we get 1 if the privilege is\n",
                "                            # True, 0 otherwise\n",
                "                            if kb.dbms == DBMS.PGSQL and getUnicode(privilege).isdigit():\n",
                "                                for position, pgsqlPriv in pgsqlPrivs:\n",
                "                                    if count == position and int(privilege) == 1:\n",
                "                                        privileges.add(pgsqlPriv)\n",
                "\n",
                "                            # In MySQL >= 5.0 and Oracle we get the list\n",
                "                            # of privileges as string\n",
                "                            elif kb.dbms == DBMS.ORACLE or ( kb.dbms == DBMS.MYSQL and kb.data.has_information_schema ):\n",
                "                                privileges.add(privilege)\n",
                "\n",
                "                            # In MySQL < 5.0 we get Y if the privilege is \n",
                "                            # True, N otherwise\n",
                "                            elif kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                                for position, mysqlPriv in mysqlPrivs:\n",
                "                                    if count == position and privilege.upper() == \"Y\":\n",
                "                                        privileges.add(mysqlPriv)\n",
                "\n",
                "                    if self.__isAdminFromPrivileges(privileges):\n",
                "                        areAdmins.add(user)\n",
                "\n",
                "                    if kb.data.cachedUsersPrivileges.has_key(user):\n",
                "                        kb.data.cachedUsersPrivileges[user].extend(privileges)\n",
                "                    else:\n",
                "                        kb.data.cachedUsersPrivileges[user] = list(privileges)\n",
                "\n",
                "        if not kb.data.cachedUsersPrivileges and not conf.direct:\n",
                "            conditionChar = \"=\"\n",
                "\n",
                "            if conf.user:\n",
                "                if kb.dbms == DBMS.MYSQL and kb.data.has_information_schema:\n",
                "                    conditionChar = \" LIKE \"\n",
                "\n",
                "                    if \",\" in conf.user:\n",
                "                        users = set()\n",
                "                        for user in conf.user.split(\",\"):\n",
                "                            users.add(\"%\" + user + \"%\")\n",
                "                    else:\n",
                "                        parsedUser = re.search(\"[\\047]*(.*?)[\\047]*\\@\", conf.user)\n",
                "\n",
                "                        if parsedUser:\n",
                "                            conf.user = parsedUser.groups()[0]\n",
                "\n",
                "                        users = [ \"%\" + conf.user + \"%\" ]\n",
                "                else:\n",
                "                    users = conf.user.split(\",\")\n",
                "            else:\n",
                "                if not len(kb.data.cachedUsers):\n",
                "                    users = self.getUsers()\n",
                "                else:\n",
                "                    users = kb.data.cachedUsers\n",
                "\n",
                "            retrievedUsers = set()\n",
                "\n",
                "            for user in users:\n",
                "                unescapedUser = None\n",
                "\n",
                "                if kb.dbms == DBMS.MYSQL and kb.data.has_information_schema:\n",
                "                    unescapedUser = unescaper.unescape(user, quote=False)\n",
                "\n",
                "                if user in retrievedUsers:\n",
                "                    continue\n",
                "\n",
                "                infoMsg  = \"fetching number of privileges \"\n",
                "                infoMsg += \"for user '%s'\" % user\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                if unescapedUser:\n",
                "                    queryUser = unescapedUser\n",
                "                else:\n",
                "                    queryUser = user\n",
                "\n",
                "                if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                    query = rootQuery.blind.count2 % queryUser\n",
                "                elif kb.dbms == DBMS.MYSQL and kb.data.has_information_schema:\n",
                "                    query = rootQuery.blind.count % (conditionChar, queryUser)\n",
                "                elif kb.dbms == DBMS.ORACLE and query2:\n",
                "                    query = rootQuery.blind.count2 % queryUser\n",
                "                else:\n",
                "                    query = rootQuery.blind.count % queryUser\n",
                "                count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "                if not isNumPosStrValue(count):\n",
                "                    if not (isinstance(count, basestring) and count.isdigit()) and kb.dbms == DBMS.ORACLE and not query2:\n",
                "                        infoMsg = \"trying with table USER_SYS_PRIVS\"\n",
                "                        logger.info(infoMsg)\n",
                "\n",
                "                        return self.getPrivileges(query2=True)\n",
                "\n",
                "                    warnMsg  = \"unable to retrieve the number of \"\n",
                "                    warnMsg += \"privileges for user '%s'\" % user\n",
                "                    logger.warn(warnMsg)\n",
                "                    continue\n",
                "\n",
                "                infoMsg = \"fetching privileges for user '%s'\" % user\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                privileges = set()\n",
                "\n",
                "                if kb.dbms == DBMS.ORACLE:\n",
                "                    plusOne = True\n",
                "                else:\n",
                "                    plusOne = False\n",
                "                indexRange = getRange(count, plusOne=plusOne)\n",
                "\n",
                "                for index in indexRange:\n",
                "                    if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                        query = rootQuery.blind.query2 % (queryUser, index)\n",
                "                    elif kb.dbms == DBMS.MYSQL and kb.data.has_information_schema:\n",
                "                        query = rootQuery.blind.query % (conditionChar, queryUser, index)\n",
                "                    elif kb.dbms == DBMS.ORACLE and query2:\n",
                "                        query = rootQuery.blind.query2 % (queryUser, index)\n",
                "                    elif kb.dbms == DBMS.FIREBIRD:\n",
                "                        query = rootQuery.blind.query % (index, queryUser)\n",
                "                    else:\n",
                "                        query = rootQuery.blind.query % (queryUser, index)\n",
                "                    privilege = inject.getValue(query, inband=False)\n",
                "\n",
                "                    # In PostgreSQL we get 1 if the privilege is True,\n",
                "                    # 0 otherwise\n",
                "                    if kb.dbms == DBMS.PGSQL and \", \" in privilege:\n",
                "                        privilege = privilege.replace(\", \", \",\")\n",
                "                        privs = privilege.split(\",\")\n",
                "                        i = 1\n",
                "\n",
                "                        for priv in privs:\n",
                "                            if priv.isdigit() and int(priv) == 1:\n",
                "                                for position, pgsqlPriv in pgsqlPrivs:\n",
                "                                    if position == i:\n",
                "                                        privileges.add(pgsqlPriv)\n",
                "\n",
                "                            i += 1\n",
                "\n",
                "                    # In MySQL >= 5.0 and Oracle we get the list\n",
                "                    # of privileges as string\n",
                "                    elif kb.dbms == DBMS.ORACLE or ( kb.dbms == DBMS.MYSQL and kb.data.has_information_schema ):\n",
                "                        privileges.add(privilege)\n",
                "\n",
                "                    # In MySQL < 5.0 we get Y if the privilege is \n",
                "                    # True, N otherwise\n",
                "                    elif kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                        privilege = privilege.replace(\", \", \",\")\n",
                "                        privs = privilege.split(\",\")\n",
                "                        i = 1\n",
                "\n",
                "                        for priv in privs:\n",
                "                            if priv.upper() == \"Y\":\n",
                "                                for position, mysqlPriv in mysqlPrivs:\n",
                "                                    if position == i:\n",
                "                                        privileges.add(mysqlPriv)\n",
                "\n",
                "                            i += 1\n",
                "\n",
                "                    # In Firebird we get one letter for each privilege\n",
                "                    elif kb.dbms == DBMS.FIREBIRD:\n",
                "                        privileges.add(firebirdPrivs[privilege.strip()])\n",
                "\n",
                "                    if self.__isAdminFromPrivileges(privileges):\n",
                "                        areAdmins.add(user)\n",
                "\n",
                "                    # In MySQL < 5.0 we break the cycle after the first\n",
                "                    # time we get the user's privileges otherwise we\n",
                "                    # duplicate the same query\n",
                "                    if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                        break\n",
                "\n",
                "                if privileges:\n",
                "                    kb.data.cachedUsersPrivileges[user] = list(privileges)\n",
                "                else:\n",
                "                    warnMsg  = \"unable to retrieve the privileges \"\n",
                "                    warnMsg += \"for user '%s'\" % user\n",
                "                    logger.warn(warnMsg)\n",
                "\n",
                "                retrievedUsers.add(user)\n",
                "\n",
                "        if not kb.data.cachedUsersPrivileges:\n",
                "            errMsg  = \"unable to retrieve the privileges \"\n",
                "            errMsg += \"for the database users\"\n",
                "            raise sqlmapNoneDataException, errMsg\n",
                "\n",
                "        return ( kb.data.cachedUsersPrivileges, areAdmins )\n",
                "\n",
                "    def getRoles(self, query2=False):\n",
                "        warnMsg  = \"on %s the concept of roles does not \" % kb.dbms\n",
                "        warnMsg += \"exist. sqlmap will enumerate privileges instead\"\n",
                "        logger.warn(warnMsg)\n",
                "\n",
                "        return self.getPrivileges(query2)\n",
                "\n",
                "    def getDbs(self):\n",
                "        if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "            warnMsg  = \"information_schema not available, \"\n",
                "            warnMsg += \"back-end DBMS is MySQL < 5. database \"\n",
                "            warnMsg += \"names will be fetched from 'mysql' database\"\n",
                "            logger.warn(warnMsg)\n",
                "\n",
                "        infoMsg = \"fetching database names\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        rootQuery = queries[kb.dbms].dbs\n",
                "\n",
                "        if kb.unionPosition is not None or conf.direct:\n",
                "            if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                query = rootQuery.inband.query2\n",
                "            else:\n",
                "                query = rootQuery.inband.query\n",
                "            value = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "            if value:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                if isinstance(value, basestring):\n",
                    "                    kb.data.cachedDbs = [value]\n",
                    "                else:\n",
                    "                    kb.data.cachedDbs = value\n"
                ],
                "after": [
                    "                kb.data.cachedDbs = arrayizeValue(value)\n"
                ],
                "parent_version_range": {
                    "start": 686,
                    "end": 690
                },
                "child_version_range": {
                    "start": 687,
                    "end": 688
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if kb.unionPosition is not None or conf.direct:",
                        "start_line": 678,
                        "end_line": 689
                    },
                    {
                        "type": "if_statement",
                        "statement": "if value:",
                        "start_line": 685,
                        "end_line": 689
                    },
                    {
                        "type": "if_statement",
                        "statement": "if isinstance(value, basestring):",
                        "start_line": 686,
                        "end_line": 689
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Enumeration",
                        "signature": "class Enumeration:",
                        "at_line": 54
                    },
                    {
                        "type": "function",
                        "name": "getDbs",
                        "signature": "def getDbs(self):",
                        "at_line": 666
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: plugins/generic/enumeration.py\nCode:\n           class Enumeration:\n               ...\n               def getDbs(self):\n                   ...\n683 684                value = inject.getValue(query, blind=False, error=False)\n684 685    \n685 686                if value:\n686      -                 if isinstance(value, basestring):\n687      -                     kb.data.cachedDbs = [value]\n688      -                 else:\n689      -                     kb.data.cachedDbs = value\n    687  +                 kb.data.cachedDbs = arrayizeValue(value)\n690 688    \n691 689            if not kb.data.cachedDbs and not conf.direct:\n692 690                infoMsg = \"fetching number of databases\"\n         ...\n",
                "file_path": "plugins/generic/enumeration.py",
                "identifiers_before": [
                    "basestring",
                    "cachedDbs",
                    "data",
                    "isinstance",
                    "kb",
                    "value"
                ],
                "identifiers_after": [
                    "arrayizeValue",
                    "cachedDbs",
                    "data",
                    "kb",
                    "value"
                ],
                "prefix": [
                    "            value = inject.getValue(query, blind=False, error=False)\n",
                    "\n",
                    "            if value:\n"
                ],
                "suffix": [
                    "\n",
                    "        if not kb.data.cachedDbs and not conf.direct:\n",
                    "            infoMsg = \"fetching number of databases\"\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 687,
                                    "column": 36
                                },
                                "end": {
                                    "line": 687,
                                    "column": 49
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/generic/enumeration.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "arrayizeValue",
                            "position": {
                                "start": {
                                    "line": 687,
                                    "column": 36
                                },
                                "end": {
                                    "line": 687,
                                    "column": 49
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sqlmap/plugins/generic/enumeration.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "        if not kb.data.cachedDbs and not conf.direct:\n",
                "            infoMsg = \"fetching number of databases\"\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                query = rootQuery.blind.count2\n",
                "            else:\n",
                "                query = rootQuery.blind.count\n",
                "            count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "            if not isNumPosStrValue(count):\n",
                "                errMsg = \"unable to retrieve the number of databases\"\n",
                "                raise sqlmapNoneDataException, errMsg\n",
                "\n",
                "            indexRange = getRange(count)\n",
                "\n",
                "            for index in indexRange:\n",
                "                if kb.dbms == DBMS.SYBASE:\n",
                "                    query = rootQuery.blind.query % (kb.data.cachedDbs[-1] if kb.data.cachedDbs else \" \")\n",
                "                elif kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                    query = rootQuery.blind.query2 % index\n",
                "                else:\n",
                "                    query = rootQuery.blind.query % index\n",
                "                db = inject.getValue(query, inband=False)\n",
                "\n",
                "                if db:\n",
                "                    kb.data.cachedDbs.append(db)\n",
                "\n",
                "        if not kb.data.cachedDbs:\n",
                "            errMsg = \"unable to retrieve the database names\"\n",
                "            raise sqlmapNoneDataException, errMsg\n",
                "\n",
                "        return kb.data.cachedDbs\n",
                "\n",
                "    def getTables(self):\n",
                "        bruteForce = False\n",
                "\n",
                "        if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "            errMsg  = \"information_schema not available, \"\n",
                "            errMsg += \"back-end DBMS is MySQL < 5.0\"\n",
                "            logger.error(errMsg)\n",
                "            bruteForce = True\n",
                "\n",
                "        elif kb.dbms == DBMS.ACCESS:\n",
                "            errMsg  = \"cannot retrieve table names, \"\n",
                "            errMsg += \"back-end DBMS is Access\"\n",
                "            logger.error(errMsg)\n",
                "            bruteForce = True\n",
                "\n",
                "        if bruteForce:\n",
                "            message = \"do you want to use common table existance check? [Y/n/q]\"\n",
                "            test = readInput(message, default=\"Y\")\n",
                "\n",
                "            if test[0] in (\"n\", \"N\"):\n",
                "                return\n",
                "            elif test[0] in (\"q\", \"Q\"):\n",
                "                raise sqlmapUserQuitException\n",
                "            else:\n",
                "                return tableExists(paths.COMMON_TABLES)\n",
                "\n",
                "        self.forceDbmsEnum()\n",
                "\n",
                "        infoMsg = \"fetching tables\"\n",
                "        if conf.db:\n",
                "            infoMsg += \" for database '%s'\" % conf.db\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        rootQuery = queries[kb.dbms].tables\n",
                "\n",
                "        if conf.db:\n",
                "            if \",\" in conf.db:\n",
                "                dbs = conf.db.split(\",\")\n",
                "            else:\n",
                "                dbs = [conf.db]\n",
                "        else:\n",
                "            if not len(kb.data.cachedDbs):\n",
                "                dbs = self.getDbs()\n",
                "            else:\n",
                "                dbs = kb.data.cachedDbs\n",
                "\n",
                "        if kb.unionPosition is not None or conf.direct:\n",
                "            query = rootQuery.inband.query\n",
                "            condition = rootQuery.inband.condition if 'condition' in rootQuery.inband else None\n",
                "\n",
                "            if condition:\n",
                "                if conf.db and kb.dbms != DBMS.SQLITE:\n",
                "                    if \",\" in conf.db:\n",
                "                        dbs = conf.db.split(\",\")\n",
                "                        query += \" WHERE \"\n",
                "                        query += \" OR \".join(\"%s = '%s'\" % (condition, db) for db in dbs)\n",
                "                    else:\n",
                "                        query += \" WHERE %s='%s'\" % (condition, conf.db)\n",
                "                elif conf.excludeSysDbs:\n",
                "                    query += \" WHERE \"\n",
                "                    query += \" AND \".join(\"%s != '%s'\" % (condition, db) for db in self.excludeDbsList)\n",
                "                    infoMsg = \"skipping system databases '%s'\" % \", \".join(db for db in self.excludeDbsList)\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "            if kb.dbms in (DBMS.MSSQL, DBMS.SYBASE):\n",
                "                query = safeStringFormat(query, conf.db)\n",
                "            value = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "            if value:\n",
                "                if kb.dbms == DBMS.SQLITE:\n",
                "                    if isinstance(value, basestring):\n",
                "                        value = [[ DBMS.SQLITE, value ]]\n",
                "                    elif isinstance(value, (list, tuple, set)):\n",
                "                        newValue = []\n",
                "\n",
                "                        for v in value:\n",
                "                            newValue.append([ DBMS.SQLITE, v])\n",
                "\n",
                "                        value = newValue\n",
                "\n",
                "                for db, table in value:\n",
                "                    if not kb.data.cachedTables.has_key(db):\n",
                "                        kb.data.cachedTables[db] = [table]\n",
                "                    else:\n",
                "                        kb.data.cachedTables[db].append(table)\n",
                "\n",
                "        if not kb.data.cachedTables and not conf.direct:\n",
                "            for db in dbs:\n",
                "                if conf.excludeSysDbs and db in self.excludeDbsList:\n",
                "                    infoMsg = \"skipping system database '%s'\" % db\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "                    continue\n",
                "\n",
                "                infoMsg  = \"fetching number of tables for \"\n",
                "                infoMsg += \"database '%s'\" % db\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                if kb.dbms in (DBMS.SQLITE, DBMS.FIREBIRD, DBMS.MAXDB):\n",
                "                    query = rootQuery.blind.count\n",
                "                else:\n",
                "                    query = rootQuery.blind.count % db\n",
                "                count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "                if not isNumPosStrValue(count):\n",
                "                    warnMsg  = \"unable to retrieve the number of \"\n",
                "                    warnMsg += \"tables for database '%s'\" % db\n",
                "                    logger.warn(warnMsg)\n",
                "                    continue\n",
                "\n",
                "                tables = []\n",
                "\n",
                "                if kb.dbms in ( DBMS.MSSQL, DBMS.ORACLE ):\n",
                "                    plusOne = True\n",
                "                else:\n",
                "                    plusOne = False\n",
                "                indexRange = getRange(count, plusOne=plusOne)\n",
                "\n",
                "                for index in indexRange:\n",
                "                    if kb.dbms == DBMS.SYBASE:\n",
                "                        query = rootQuery.blind.query % (db, (kb.data.cachedTables[-1] if kb.data.cachedTables else \" \"))\n",
                "                    elif kb.dbms == DBMS.MAXDB:\n",
                "                        query = rootQuery.blind.query % (kb.data.cachedTables[-1] if kb.data.cachedTables else \" \")\n",
                "                    elif kb.dbms in (DBMS.SQLITE, DBMS.FIREBIRD):\n",
                "                        query = rootQuery.blind.query % index\n",
                "                    else:\n",
                "                        query = rootQuery.blind.query % (db, index)\n",
                "                    table = inject.getValue(query, inband=False)\n",
                "                    tables.append(table)\n",
                "                    kb.hintValue = table\n",
                "\n",
                "                if tables:\n",
                "                    kb.data.cachedTables[db] = tables\n",
                "                else:\n",
                "                    warnMsg  = \"unable to retrieve the tables \"\n",
                "                    warnMsg += \"for database '%s'\" % db\n",
                "                    logger.warn(warnMsg)\n",
                "\n",
                "        if not kb.data.cachedTables:\n",
                "            errMsg = \"unable to retrieve the tables for any database\"\n",
                "            raise sqlmapNoneDataException, errMsg\n",
                "\n",
                "        return kb.data.cachedTables\n",
                "\n",
                "    def getColumns(self, onlyColNames=False):\n",
                "        bruteForce = False\n",
                "\n",
                "        if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "            errMsg  = \"information_schema not available, \"\n",
                "            errMsg += \"back-end DBMS is MySQL < 5.0\"\n",
                "            logger.error(errMsg)\n",
                "            bruteForce = True\n",
                "\n",
                "        elif kb.dbms == DBMS.ACCESS:\n",
                "            errMsg  = \"cannot retrieve column names, \"\n",
                "            errMsg += \"back-end DBMS is Access\"\n",
                "            logger.error(errMsg)\n",
                "            bruteForce = True\n",
                "\n",
                "        if bruteForce:\n",
                "            message = \"do you want to use common columns existance check? [Y/n/q]\"\n",
                "            test = readInput(message, default=\"Y\")\n",
                "\n",
                "            if test[0] in (\"n\", \"N\"):\n",
                "                return\n",
                "            elif test[0] in (\"q\", \"Q\"):\n",
                "                raise sqlmapUserQuitException\n",
                "            else:\n",
                "                return columnExists(paths.COMMON_COLUMNS)\n",
                "\n",
                "        if not conf.tbl:\n",
                "            errMsg = \"missing table parameter\"\n",
                "            raise sqlmapMissingMandatoryOptionException, errMsg\n",
                "\n",
                "        if \".\" in conf.tbl:\n",
                "            conf.db, conf.tbl = conf.tbl.split(\".\")\n",
                "\n",
                "        self.forceDbmsEnum()\n",
                "\n",
                "        if not conf.db:\n",
                "            warnMsg  = \"missing database parameter, sqlmap is going to \"\n",
                "            warnMsg += \"use the current database to enumerate table \"\n",
                "            warnMsg += \"'%s' columns\" % conf.tbl\n",
                "            logger.warn(warnMsg)\n",
                "\n",
                "            conf.db = self.getCurrentDb()\n",
                "\n",
                "        firebirdTypes = {\n",
                "                            \"261\":\"BLOB\",\n",
                "                            \"14\":\"CHAR\",\n",
                "                            \"40\":\"CSTRING\",\n",
                "                            \"11\":\"D_FLOAT\",\n",
                "                            \"27\":\"DOUBLE\",\n",
                "                            \"10\":\"FLOAT\",\n",
                "                            \"16\":\"INT64\",\n",
                "                            \"8\":\"INTEGER\",\n",
                "                            \"9\":\"QUAD\",\n",
                "                            \"7\":\"SMALLINT\",\n",
                "                            \"12\":\"DATE\",\n",
                "                            \"13\":\"TIME\",\n",
                "                            \"35\":\"TIMESTAMP\",\n",
                "                            \"37\":\"VARCHAR\"\n",
                "                        }\n",
                "\n",
                "        rootQuery = queries[kb.dbms].columns\n",
                "        condition = rootQuery.blind.condition if 'condition' in rootQuery.blind else None\n",
                "\n",
                "        infoMsg = \"fetching columns \"\n",
                "\n",
                "        if conf.col:\n",
                "            if kb.dbms == DBMS.ORACLE:\n",
                "                conf.col = conf.col.upper()\n",
                "            colList = conf.col.split(\",\")\n",
                "            condQuery = \" AND (\" + \" OR \".join(\"%s LIKE '%s'\" % (condition, \"%\" + col + \"%\") for col in colList) + \")\"\n",
                "            infoMsg += \"like '%s' \" % \", \".join(col for col in colList)\n",
                "        else:\n",
                "            condQuery = \"\"\n",
                "\n",
                "        infoMsg += \"for table '%s' \" % conf.tbl\n",
                "        infoMsg += \"on database '%s'\" % conf.db\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        if kb.unionPosition is not None or conf.direct:\n",
                "            if kb.dbms in ( DBMS.MYSQL, DBMS.PGSQL ):\n",
                "                query = rootQuery.inband.query % (conf.tbl, conf.db)\n",
                "                query += condQuery\n",
                "            elif kb.dbms == DBMS.ORACLE:\n",
                "                query = rootQuery.inband.query % conf.tbl.upper()\n",
                "                query += condQuery\n",
                "            elif kb.dbms == DBMS.MSSQL:\n",
                "                query = rootQuery.inband.query % (conf.db, conf.db,\n",
                "                                                        conf.db, conf.db,\n",
                "                                                        conf.db, conf.db,\n",
                "                                                        conf.db, conf.tbl)\n",
                "                query += condQuery.replace(\"[DB]\", conf.db)\n",
                "            elif kb.dbms == DBMS.SQLITE:\n",
                "                query = rootQuery.inband.query % conf.tbl\n",
                "\n",
                "            value = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "            if kb.dbms == DBMS.SQLITE:\n",
                "                parseSqliteTableSchema(value)\n",
                "            elif value:\n",
                "                table = {}\n",
                "                columns = {}\n",
                "\n",
                "                for column, colType in value:\n",
                "                    columns[column] = colType\n",
                "\n",
                "                table[conf.tbl] = columns\n",
                "                kb.data.cachedColumns[conf.db] = table\n",
                "\n",
                "        if not kb.data.cachedColumns and not conf.direct:\n",
                "            infoMsg  = \"fetching number of columns \"\n",
                "            infoMsg += \"for table '%s'\" % conf.tbl\n",
                "            infoMsg += \" on database '%s'\" % conf.db\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            if kb.dbms in ( DBMS.MYSQL, DBMS.PGSQL ):\n",
                "                query = rootQuery.blind.count % (conf.tbl, conf.db)\n",
                "                query += condQuery\n",
                "            elif kb.dbms == DBMS.ORACLE:\n",
                "                query = rootQuery.blind.count % conf.tbl.upper()\n",
                "                query += condQuery\n",
                "            elif kb.dbms == DBMS.MSSQL:\n",
                "                query = rootQuery.blind.count % (conf.db, conf.db, conf.tbl)\n",
                "                query += condQuery.replace(\"[DB]\", conf.db)\n",
                "            elif kb.dbms == DBMS.FIREBIRD:\n",
                "                query = rootQuery.blind.count % (conf.tbl)\n",
                "                query += condQuery\n",
                "            elif kb.dbms == DBMS.SQLITE:\n",
                "                query = rootQuery.blind.query % conf.tbl\n",
                "                value = inject.getValue(query, inband=False)\n",
                "\n",
                "                parseSqliteTableSchema(value)\n",
                "\n",
                "                return kb.data.cachedColumns\n",
                "\n",
                "            count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "            if not isNumPosStrValue(count):\n",
                "                errMsg  = \"unable to retrieve the number of columns \"\n",
                "                errMsg += \"for table '%s' \" % conf.tbl\n",
                "                errMsg += \"on database '%s'\" % conf.db\n",
                "                raise sqlmapNoneDataException, errMsg\n",
                "\n",
                "            table   = {}\n",
                "            columns = {}\n",
                "\n",
                "            indexRange = getRange(count)\n",
                "\n",
                "            for index in indexRange:\n",
                "                if kb.dbms in ( DBMS.MYSQL, DBMS.PGSQL ):\n",
                "                    query = rootQuery.blind.query % (conf.tbl, conf.db)\n",
                "                    query += condQuery\n",
                "                    field = None\n",
                "                elif kb.dbms == DBMS.ORACLE:\n",
                "                    query = rootQuery.blind.query % (conf.tbl.upper())\n",
                "                    query += condQuery\n",
                "                    field = None\n",
                "                elif kb.dbms == DBMS.MSSQL:\n",
                "                    query = rootQuery.blind.query % (conf.db, conf.db,\n",
                "                                                           conf.db, conf.db,\n",
                "                                                           conf.db, conf.db,\n",
                "                                                           conf.tbl)\n",
                "                    query += condQuery.replace(\"[DB]\", conf.db)\n",
                "                    field = condition.replace(\"[DB]\", conf.db)\n",
                "                elif kb.dbms == DBMS.FIREBIRD:\n",
                "                    query = rootQuery.blind.query % (conf.tbl)\n",
                "                    query += condQuery\n",
                "                    field = None\n",
                "\n",
                "                query = agent.limitQuery(index, query, field)\n",
                "                column = inject.getValue(query, inband=False)\n",
                "\n",
                "                if not onlyColNames:\n",
                "                    if kb.dbms in ( DBMS.MYSQL, DBMS.PGSQL ):\n",
                "                        query = rootQuery.blind.query2 % (conf.tbl, column, conf.db)\n",
                "                    elif kb.dbms == DBMS.ORACLE:\n",
                "                        query = rootQuery.blind.query2 % (conf.tbl.upper(), column)\n",
                "                    elif kb.dbms == DBMS.MSSQL:\n",
                "                        query = rootQuery.blind.query2 % (conf.db, conf.db, conf.db,\n",
                "                                                                conf.db, column, conf.db,\n",
                "                                                                conf.db, conf.db, conf.tbl)\n",
                "                    elif kb.dbms == DBMS.FIREBIRD:\n",
                "                        query = rootQuery.blind.query2 % (conf.tbl, column)\n",
                "\n",
                "                    colType = inject.getValue(query, inband=False)\n",
                "\n",
                "                    if kb.dbms == DBMS.FIREBIRD:\n",
                "                        colType = firebirdTypes[colType] if colType in firebirdTypes else colType\n",
                "\n",
                "                    columns[column] = colType\n",
                "                else:\n",
                "                    columns[column] = None\n",
                "\n",
                "            if columns:\n",
                "                table[conf.tbl] = columns\n",
                "                kb.data.cachedColumns[conf.db] = table\n",
                "\n",
                "        if not kb.data.cachedColumns:\n",
                "            errMsg  = \"unable to retrieve the columns \"\n",
                "            errMsg += \"for table '%s' \" % conf.tbl\n",
                "            errMsg += \"on database '%s'\" % conf.db\n",
                "            raise sqlmapNoneDataException, errMsg\n",
                "\n",
                "        return kb.data.cachedColumns\n",
                "\n",
                "    def dumpTable(self):\n",
                "        if not conf.tbl and not conf.col:\n",
                "            errMsg = \"missing table parameter\"\n",
                "            raise sqlmapMissingMandatoryOptionException, errMsg\n",
                "\n",
                "        if conf.col and not conf.tbl:\n",
                "            warnMsg = \"missing table parameter. You only provided \"\n",
                "            warnMsg += \"column(s). sqlmap will search for all databases' \"\n",
                "            warnMsg += \"tables containing the provided column(s)\"\n",
                "            logger.warn(warnMsg)\n",
                "\n",
                "            self.searchColumn()\n",
                "            return\n",
                "\n",
                "        if \".\" in conf.tbl:\n",
                "            conf.db, conf.tbl = conf.tbl.split(\".\")\n",
                "\n",
                "        self.forceDbmsEnum()\n",
                "\n",
                "        if not conf.db:\n",
                "            warnMsg  = \"missing database parameter, sqlmap is going to \"\n",
                "            warnMsg += \"use the current database to dump table \"\n",
                "            warnMsg += \"'%s' entries\" % conf.tbl\n",
                "            logger.warn(warnMsg)\n",
                "\n",
                "            conf.db = self.getCurrentDb()\n",
                "\n",
                "        rootQuery = queries[kb.dbms].dump_table\n",
                "\n",
                "        if conf.col:\n",
                "            colList = conf.col.split(\",\")\n",
                "            kb.data.cachedColumns[conf.db] = {}\n",
                "            kb.data.cachedColumns[conf.db][conf.tbl] = {}\n",
                "\n",
                "            for column in colList:\n",
                "                kb.data.cachedColumns[conf.db][conf.tbl][column] = None\n",
                "\n",
                "        elif not kb.data.cachedColumns:\n",
                "            if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                errMsg  = \"information_schema not available, \"\n",
                "                errMsg += \"back-end DBMS is MySQL < 5.0\"\n",
                "                raise sqlmapUnsupportedFeatureException, errMsg\n",
                "\n",
                "            kb.data.cachedColumns = self.getColumns(onlyColNames=True)\n",
                "\n",
                "        colList = kb.data.cachedColumns[conf.db][conf.tbl].keys()\n",
                "        colList.sort(key=lambda x: x.lower() if isinstance(x, basestring) else None)\n",
                "\n",
                "        if colList in ([None], ['None']):\n",
                "            warnMsg = \"unable to retrieve column names\"\n",
                "            logger.warn(warnMsg)\n",
                "            return None\n",
                "\n",
                "        colString = \", \".join(column for column in colList)\n",
                "\n",
                "        infoMsg = \"fetching\"\n",
                "        if conf.col:\n",
                "            infoMsg += \" columns '%s'\" % colString\n",
                "        infoMsg += \" entries for table '%s'\" % conf.tbl\n",
                "        infoMsg += \" on database '%s'\" % conf.db\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        entriesCount = 0\n",
                "\n",
                "        if kb.unionPosition is not None or conf.direct:\n",
                "            if kb.dbms == DBMS.ORACLE:\n",
                "                query = rootQuery.inband.query % (colString, conf.tbl.upper())\n",
                "            elif kb.dbms == DBMS.SQLITE:\n",
                "                query = rootQuery.inband.query % (colString, conf.tbl)\n",
                "            else:\n",
                "                query = rootQuery.inband.query % (colString, conf.db, conf.tbl)\n",
                "            entries = inject.getValue(query, blind=False, error=False, dump=True)\n",
                "\n",
                "            if entries:\n",
                "                if isinstance(entries, basestring):\n",
                "                    entries = [ entries ]\n",
                "\n",
                "                entriesCount = len(entries)\n",
                "                index        = 0\n",
                "\n",
                "                for column in colList:\n",
                "                    colLen = len(column)\n",
                "\n",
                "                    if not kb.data.dumpedTable.has_key(column):\n",
                "                        kb.data.dumpedTable[column] = { \"length\": 0, \"values\": [] }\n",
                "\n",
                "                    for entry in entries:\n",
                "                        if entry is None or len(entry) == 0:\n",
                "                            continue\n",
                "\n",
                "                        if isinstance(entry, basestring):\n",
                "                            colEntry = entry\n",
                "                        else:\n",
                "                            colEntry = entry[index] if index < len(entry) else u''\n",
                "\n",
                "                        colEntryLen = len(getUnicode(colEntry))\n",
                "                        maxLen = max(colLen, colEntryLen)\n",
                "\n",
                "                        if maxLen > kb.data.dumpedTable[column][\"length\"]:\n",
                "                            kb.data.dumpedTable[column][\"length\"] = maxLen\n",
                "\n",
                "                        kb.data.dumpedTable[column][\"values\"].append(colEntry)\n",
                "\n",
                "                    index += 1\n",
                "\n",
                "        if not kb.data.dumpedTable and not conf.direct:\n",
                "            infoMsg = \"fetching number of \"\n",
                "            if conf.col:\n",
                "                infoMsg += \"columns '%s' \" % colString\n",
                "            infoMsg += \"entries for table '%s' \" % conf.tbl\n",
                "            infoMsg += \"on database '%s'\" % conf.db\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            if kb.dbms == DBMS.ORACLE:\n",
                "                query = rootQuery.blind.count % conf.tbl.upper()\n",
                "            elif kb.dbms in (DBMS.SQLITE, DBMS.ACCESS, DBMS.FIREBIRD):\n",
                "                query = rootQuery.blind.count % conf.tbl\n",
                "            else:\n",
                "                query = rootQuery.blind.count % (conf.db, conf.tbl)\n",
                "            count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "            if not isNumPosStrValue(count):\n",
                "                warnMsg = \"unable to retrieve the number of \"\n",
                "                if conf.col:\n",
                "                    warnMsg += \"columns '%s' \" % colString\n",
                "                warnMsg += \"entries for table '%s' \" % conf.tbl\n",
                "                warnMsg += \"on database '%s'\" % conf.db\n",
                "\n",
                "                logger.warn(warnMsg)\n",
                "\n",
                "                return None\n",
                "\n",
                "            lengths = {}\n",
                "            entries = {}\n",
                "\n",
                "            if kb.dbms in (DBMS.ORACLE, DBMS.MSSQL, DBMS.SYBASE):\n",
                "                plusOne = True\n",
                "            else:\n",
                "                plusOne = False\n",
                "            indexRange = getRange(count, dump=True, plusOne=plusOne)\n",
                "\n",
                "            for index in indexRange:\n",
                "                for column in colList:\n",
                "                    if column not in lengths:\n",
                "                        lengths[column] = 0\n",
                "\n",
                "                    if column not in entries:\n",
                "                        entries[column] = []\n",
                "\n",
                "                    if kb.dbms in ( DBMS.MYSQL, DBMS.PGSQL ):\n",
                "                        query = rootQuery.blind.query % (column, conf.db,\n",
                "                                                               conf.tbl, index)\n",
                "                    elif kb.dbms == DBMS.ORACLE:\n",
                "                        query = rootQuery.blind.query % (column, column,\n",
                "                                                               conf.tbl.upper(),\n",
                "                                                               index)\n",
                "                    elif kb.dbms in (DBMS.MSSQL, DBMS.SYBASE):\n",
                "                        query = rootQuery.blind.query % (column, index, conf.db,\n",
                "                                                               conf.tbl, colList[0],\n",
                "                                                               colList[0], colList[0])\n",
                "\n",
                "                    elif kb.dbms == DBMS.SQLITE:\n",
                "                        query = rootQuery.blind.query % (column, conf.tbl, index)\n",
                "\n",
                "                    elif kb.dbms == DBMS.FIREBIRD:\n",
                "                        query = rootQuery.blind.query % (index, column, conf.tbl)\n",
                "\n",
                "                    value = inject.getValue(query, inband=False)\n",
                "\n",
                "                    lengths[column] = max(lengths[column], len(value))\n",
                "                    entries[column].append(value)\n",
                "\n",
                "            for column, columnEntries in entries.items():\n",
                "                if lengths[column] < len(column):\n",
                "                    length = len(column)\n",
                "                else:\n",
                "                    length = lengths[column]\n",
                "\n",
                "                kb.data.dumpedTable[column] = { \"length\": length,\n",
                "                                                \"values\": columnEntries }\n",
                "\n",
                "                entriesCount = len(columnEntries)\n",
                "\n",
                "        if kb.data.dumpedTable:\n",
                "            kb.data.dumpedTable[\"__infos__\"] = { \"count\": entriesCount,\n",
                "                                                 \"table\": conf.tbl,\n",
                "                                                 \"db\":    conf.db }\n",
                "        else:\n",
                "            warnMsg = \"unable to retrieve the entries of \"\n",
                "            if conf.col:\n",
                "                warnMsg += \"columns '%s' \" % colString\n",
                "            warnMsg += \"for table '%s' \" % conf.tbl\n",
                "            warnMsg += \"on database '%s'\" % conf.db\n",
                "\n",
                "            logger.warn(warnMsg)\n",
                "\n",
                "            return None\n",
                "\n",
                "        return kb.data.dumpedTable\n",
                "\n",
                "    def dumpAll(self):\n",
                "        if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "            errMsg  = \"information_schema not available, \"\n",
                "            errMsg += \"back-end DBMS is MySQL < 5.0\"\n",
                "            raise sqlmapUnsupportedFeatureException, errMsg\n",
                "\n",
                "        conf.db              = None\n",
                "        conf.tbl             = None\n",
                "        conf.col             = None\n",
                "        kb.data.cachedDbs    = []\n",
                "        kb.data.cachedTables = self.getTables()\n",
                "\n",
                "        if kb.data.cachedTables:\n",
                "            if isinstance(kb.data.cachedTables, list):\n",
                "                kb.data.cachedTables = { None : kb.data.cachedTables }\n",
                "\n",
                "            for db, tables in kb.data.cachedTables.items():\n",
                "                conf.db = db\n",
                "\n",
                "                for table in tables:\n",
                "                    conf.tbl = table\n",
                "                    kb.data.cachedColumns = {}\n",
                "                    kb.data.dumpedTable = {}\n",
                "\n",
                "                    data = self.dumpTable()\n",
                "\n",
                "                    if data:\n",
                "                        conf.dumper.dbTableValues(data)\n",
                "\n",
                "    def dumpFoundColumn(self, dbs, foundCols, colConsider):\n",
                "        if not dbs:\n",
                "            warnMsg = \"no databases have tables containing any of the \"\n",
                "            warnMsg += \"provided columns\"\n",
                "            logger.warn(warnMsg)\n",
                "            return\n",
                "\n",
                "        conf.dumper.dbColumns(foundCols, colConsider, dbs)\n",
                "\n",
                "        message = \"do you want to dump entries? [Y/n] \"\n",
                "        output = readInput(message, default=\"Y\")\n",
                "\n",
                "        if output and output[0] not in (\"y\", \"Y\"):\n",
                "            return\n",
                "\n",
                "        dumpFromDbs = []\n",
                "        message = \"which database(s)?\\n[a]ll (default)\\n\"\n",
                "\n",
                "        for db, tblData in dbs.items():\n",
                "            if tblData:\n",
                "                message += \"[%s]\\n\" % db\n",
                "\n",
                "        message += \"[q]uit\"\n",
                "        test = readInput(message, default=\"a\")\n",
                "\n",
                "        if not test or test in (\"a\", \"A\"):\n",
                "            dumpFromDbs = dbs.keys()\n",
                "        elif test in (\"q\", \"Q\"):\n",
                "            return\n",
                "        else:\n",
                "            dumpFromDbs = test.replace(\" \", \"\").split(\",\")\n",
                "\n",
                "        for db, tblData in dbs.items():\n",
                "            if db not in dumpFromDbs or not tblData:\n",
                "                continue\n",
                "\n",
                "            conf.db = db\n",
                "            dumpFromTbls = []\n",
                "            message = \"which table(s) of database '%s'?\\n\" % db\n",
                "            message += \"[a]ll (default)\\n\"\n",
                "\n",
                "            for tbl in tblData:\n",
                "                message += \"[%s]\\n\" % tbl\n",
                "\n",
                "            message += \"[s]kip\\n\"\n",
                "            message += \"[q]uit\"\n",
                "            test = readInput(message, default=\"a\")\n",
                "\n",
                "            if not test or test in (\"a\", \"A\"):\n",
                "                dumpFromTbls = tblData\n",
                "            elif test in (\"s\", \"S\"):\n",
                "                continue\n",
                "            elif test in (\"q\", \"Q\"):\n",
                "                return\n",
                "            else:\n",
                "                dumpFromTbls = test.replace(\" \", \"\").split(\",\")\n",
                "\n",
                "            for table, columns in tblData.items():\n",
                "                if table not in dumpFromTbls:\n",
                "                    continue\n",
                "\n",
                "                conf.tbl = table\n",
                "                conf.col = \",\".join(column for column in columns)\n",
                "                kb.data.cachedColumns = {}\n",
                "                kb.data.dumpedTable = {}\n",
                "\n",
                "                data = self.dumpTable()\n",
                "\n",
                "                if data:\n",
                "                    conf.dumper.dbTableValues(data)\n",
                "\n",
                "    def searchDb(self):\n",
                "        foundDbs = []\n",
                "        rootQuery = queries[kb.dbms].search_db\n",
                "        dbList = conf.db.split(\",\")\n",
                "\n",
                "        if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "            dbCond = rootQuery.inband.condition2\n",
                "        else:\n",
                "            dbCond = rootQuery.inband.condition\n",
                "\n",
                "        dbConsider, dbCondParam = self.likeOrExact(\"database\")\n",
                "\n",
                "        for db in dbList:\n",
                "            infoMsg = \"searching database\"\n",
                "            if dbConsider == \"1\":\n",
                "                infoMsg += \"s like\"\n",
                "            infoMsg += \" '%s'\" % db\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            if conf.excludeSysDbs:\n",
                "                exclDbsQuery = \"\".join(\" AND '%s' != %s\" % (db, dbCond) for db in self.excludeDbsList)\n",
                "                infoMsg = \"skipping system databases '%s'\" % \", \".join(db for db in self.excludeDbsList)\n",
                "                logger.info(infoMsg)\n",
                "            else:\n",
                "                exclDbsQuery = \"\"\n",
                "\n",
                "            dbQuery = \"%s%s\" % (dbCond, dbCondParam)\n",
                "            dbQuery = dbQuery % db\n",
                "\n",
                "            if kb.unionPosition is not None or conf.direct:\n",
                "                if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                    query = rootQuery.inband.query2\n",
                "                else:\n",
                "                    query = rootQuery.inband.query\n",
                "                query += dbQuery\n",
                "                query += exclDbsQuery\n",
                "                values = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "                if values:\n",
                "                    if isinstance(values, basestring):\n",
                "                        values = [ values ]\n",
                "\n",
                "                    for value in values:\n",
                "                        foundDbs.append(value)\n",
                "            else:\n",
                "                infoMsg = \"fetching number of databases\"\n",
                "                if dbConsider == \"1\":\n",
                "                    infoMsg += \"s like\"\n",
                "                infoMsg += \" '%s'\" % db\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                    query = rootQuery.blind.count2\n",
                "                else:\n",
                "                    query = rootQuery.blind.count\n",
                "                query += dbQuery\n",
                "                query += exclDbsQuery\n",
                "                count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "                if not isNumPosStrValue(count):\n",
                "                    warnMsg  = \"no database\"\n",
                "                    if dbConsider == \"1\":\n",
                "                        warnMsg += \"s like\"\n",
                "                    warnMsg += \" '%s' found\" % db\n",
                "                    logger.warn(warnMsg)\n",
                "\n",
                "                    continue\n",
                "\n",
                "                indexRange = getRange(count)\n",
                "\n",
                "                for index in indexRange:\n",
                "                    if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "                        query = rootQuery.blind.query2\n",
                "                    else:\n",
                "                        query = rootQuery.blind.query\n",
                "                    query += dbQuery\n",
                "                    query += exclDbsQuery\n",
                "                    query = agent.limitQuery(index, query, dbCond)\n",
                "\n",
                "                    foundDbs.append(inject.getValue(query, inband=False))\n",
                "\n",
                "        return foundDbs\n",
                "\n",
                "    def searchTable(self):\n",
                "        if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "            errMsg  = \"information_schema not available, \"\n",
                "            errMsg += \"back-end DBMS is MySQL < 5.0\"\n",
                "            raise sqlmapUnsupportedFeatureException, errMsg\n",
                "\n",
                "        rootQuery = queries[kb.dbms].search_table\n",
                "        foundTbls = {}\n",
                "        tblList = conf.tbl.split(\",\")\n",
                "        tblCond = rootQuery.inband.condition\n",
                "        dbCond = rootQuery.inband.condition2\n",
                "\n",
                "        tblConsider, tblCondParam = self.likeOrExact(\"table\")\n",
                "\n",
                "        for tbl in tblList:\n",
                "            if kb.dbms == DBMS.ORACLE:\n",
                "                tbl = tbl.upper()\n",
                "\n",
                "            infoMsg = \"searching table\"\n",
                "            if tblConsider == \"1\":\n",
                "                infoMsg += \"s like\"\n",
                "            infoMsg += \" '%s'\" % tbl\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            if conf.excludeSysDbs:\n",
                "                exclDbsQuery = \"\".join(\" AND '%s' != %s\" % (db, dbCond) for db in self.excludeDbsList)\n",
                "                infoMsg = \"skipping system databases '%s'\" % \", \".join(db for db in self.excludeDbsList)\n",
                "                logger.info(infoMsg)\n",
                "            else:\n",
                "                exclDbsQuery = \"\"\n",
                "\n",
                "            tblQuery = \"%s%s\" % (tblCond, tblCondParam)\n",
                "            tblQuery = tblQuery % tbl\n",
                "\n",
                "            if kb.unionPosition is not None or conf.direct:\n",
                "                query = rootQuery.inband.query\n",
                "                query += tblQuery\n",
                "                query += exclDbsQuery\n",
                "                values = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "                if values:\n",
                "                    if isinstance(values, basestring):\n",
                "                        values = [ values ]\n",
                "\n",
                "                    for foundDb, foundTbl in values:\n",
                "                        if foundDb in foundTbls:\n",
                "                            foundTbls[foundDb].append(foundTbl)\n",
                "                        else:\n",
                "                            foundTbls[foundDb] = [ foundTbl ]\n",
                "            else:\n",
                "                infoMsg = \"fetching number of databases with table\"\n",
                "                if tblConsider == \"1\":\n",
                "                    infoMsg += \"s like\"\n",
                "                infoMsg += \" '%s'\" % tbl\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                query = rootQuery.blind.count\n",
                "                query += tblQuery\n",
                "                query += exclDbsQuery\n",
                "                count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "                if not isNumPosStrValue(count):\n",
                "                    warnMsg  = \"no databases have table\"\n",
                "                    if tblConsider == \"1\":\n",
                "                        warnMsg += \"s like\"\n",
                "                    warnMsg += \" '%s'\" % tbl\n",
                "                    logger.warn(warnMsg)\n",
                "\n",
                "                    continue\n",
                "\n",
                "                indexRange = getRange(count)\n",
                "\n",
                "                for index in indexRange:\n",
                "                    query = rootQuery.blind.query\n",
                "                    query += tblQuery\n",
                "                    query += exclDbsQuery\n",
                "                    query = agent.limitQuery(index, query)\n",
                "                    foundDb = inject.getValue(query, inband=False)\n",
                "                    foundTbls[foundDb] = []\n",
                "\n",
                "                    if tblConsider == \"2\":\n",
                "                        foundTbls[foundDb].append(tbl)\n",
                "\n",
                "                if tblConsider == \"2\":\n",
                "                    continue\n",
                "\n",
                "                for db in foundTbls.keys():\n",
                "                    infoMsg = \"fetching number of table\"\n",
                "                    if tblConsider == \"1\":\n",
                "                        infoMsg += \"s like\"\n",
                "                    infoMsg += \" '%s' in database '%s'\" % (tbl, db)\n",
                "                    logger.info(infoMsg)\n",
                "\n",
                "                    query = rootQuery.blind.count2\n",
                "                    query = query % db\n",
                "                    query += \" AND %s\" % tblQuery\n",
                "                    count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "                    if not isNumPosStrValue(count):\n",
                "                        warnMsg = \"no table\"\n",
                "                        if tblConsider == \"1\":\n",
                "                            warnMsg += \"s like\"\n",
                "                        warnMsg += \" '%s' \" % tbl\n",
                "                        warnMsg += \"in database '%s'\" % db\n",
                "                        logger.warn(warnMsg)\n",
                "\n",
                "                        continue\n",
                "\n",
                "                    indexRange = getRange(count)\n",
                "\n",
                "                    for index in indexRange:\n",
                "                        query = rootQuery.blind.query2\n",
                "                        query = query % db\n",
                "                        query += \" AND %s\" % tblQuery\n",
                "                        query = agent.limitQuery(index, query)\n",
                "                        foundTbl = inject.getValue(query, inband=False)\n",
                "                        kb.hintValue = foundTbl\n",
                "                        foundTbls[db].append(foundTbl)\n",
                "\n",
                "        return foundTbls\n",
                "\n",
                "    def searchColumn(self):\n",
                "        if kb.dbms == DBMS.MYSQL and not kb.data.has_information_schema:\n",
                "            errMsg  = \"information_schema not available, \"\n",
                "            errMsg += \"back-end DBMS is MySQL < 5.0\"\n",
                "            raise sqlmapUnsupportedFeatureException, errMsg\n",
                "\n",
                "        rootQuery = queries[kb.dbms].search_column\n",
                "        foundCols = {}\n",
                "        dbs = {}\n",
                "        colList = conf.col.split(\",\")\n",
                "        colCond = rootQuery.inband.condition\n",
                "        dbCond = rootQuery.inband.condition2\n",
                "\n",
                "        colConsider, colCondParam = self.likeOrExact(\"column\")\n",
                "\n",
                "        for column in colList:\n",
                "            infoMsg = \"searching column\"\n",
                "            if colConsider == \"1\":\n",
                "                infoMsg += \"s like\"\n",
                "            infoMsg += \" '%s'\" % column\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            foundCols[column] = {}\n",
                "\n",
                "            if conf.excludeSysDbs:\n",
                "                exclDbsQuery = \"\".join(\" AND '%s' != %s\" % (db, dbCond) for db in self.excludeDbsList)\n",
                "                infoMsg = \"skipping system databases '%s'\" % \", \".join(db for db in self.excludeDbsList)\n",
                "                logger.info(infoMsg)\n",
                "            else:\n",
                "                exclDbsQuery = \"\"\n",
                "\n",
                "            colQuery = \"%s%s\" % (colCond, colCondParam)\n",
                "            colQuery = colQuery % column\n",
                "\n",
                "            if kb.unionPosition is not None or conf.direct:\n",
                "                query = rootQuery.inband.query\n",
                "                query += colQuery\n",
                "                query += exclDbsQuery\n",
                "                values = inject.getValue(query, blind=False, error=False)\n",
                "\n",
                "                if values:\n",
                "                    if isinstance(values, basestring):\n",
                "                        values = [ values ]\n",
                "\n",
                "                    for foundDb, foundTbl in values:\n",
                "                        if foundDb not in dbs:\n",
                "                            dbs[foundDb] = {}\n",
                "\n",
                "                        if foundTbl not in dbs[foundDb]:\n",
                "                            dbs[foundDb][foundTbl] = {}\n",
                "\n",
                "                        if colConsider == \"1\":\n",
                "                            conf.db = foundDb\n",
                "                            conf.tbl = foundTbl\n",
                "                            conf.col = column\n",
                "\n",
                "                            self.getColumns(onlyColNames=True)\n",
                "\n",
                "                            dbs[foundDb][foundTbl].update(kb.data.cachedColumns[foundDb][foundTbl])\n",
                "                            kb.data.cachedColumns = {}\n",
                "                        else:\n",
                "                            dbs[foundDb][foundTbl][column] = None\n",
                "\n",
                "                        if foundDb in foundCols[column]:\n",
                "                            foundCols[column][foundDb].append(foundTbl)\n",
                "                        else:\n",
                "                            foundCols[column][foundDb] = [ foundTbl ]\n",
                "            else:\n",
                "                infoMsg = \"fetching number of databases with tables containing column\"\n",
                "                if colConsider == \"1\":\n",
                "                    infoMsg += \"s like\"\n",
                "                infoMsg += \" '%s'\" % column\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                query = rootQuery.blind.count\n",
                "                query += colQuery\n",
                "                query += exclDbsQuery\n",
                "                count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "                if not isNumPosStrValue(count):\n",
                "                    warnMsg  = \"no databases have tables containing column\"\n",
                "                    if colConsider == \"1\":\n",
                "                        warnMsg += \"s like\"\n",
                "                    warnMsg += \" '%s'\" % column\n",
                "                    logger.warn(warnMsg)\n",
                "\n",
                "                    continue\n",
                "\n",
                "                indexRange = getRange(count)\n",
                "\n",
                "                for index in indexRange:\n",
                "                    query = rootQuery.blind.query\n",
                "                    query += colQuery\n",
                "                    query += exclDbsQuery\n",
                "                    query = agent.limitQuery(index, query)\n",
                "                    db = inject.getValue(query, inband=False)\n",
                "\n",
                "                    if db not in dbs:\n",
                "                        dbs[db] = {}\n",
                "\n",
                "                    if db not in foundCols[column]:\n",
                "                        foundCols[column][db] = []\n",
                "\n",
                "                for column, dbData in foundCols.items():\n",
                "                    colQuery = \"%s%s\" % (colCond, colCondParam)\n",
                "                    colQuery = colQuery % column\n",
                "\n",
                "                    for db in dbData:\n",
                "                        infoMsg = \"fetching number of tables containing column\"\n",
                "                        if colConsider == \"1\":\n",
                "                            infoMsg += \"s like\"\n",
                "                        infoMsg += \" '%s' in database '%s'\" % (column, db)\n",
                "                        logger.info(infoMsg)\n",
                "\n",
                "                        query = rootQuery.blind.count2\n",
                "                        query = query % db\n",
                "                        query += \" AND %s\" % colQuery\n",
                "                        count = inject.getValue(query, inband=False, expected=EXPECTED.INT, charsetType=2)\n",
                "\n",
                "                        if not isNumPosStrValue(count):\n",
                "                            warnMsg = \"no tables contain column\"\n",
                "                            if colConsider == \"1\":\n",
                "                                warnMsg += \"s like\"\n",
                "                            warnMsg += \" '%s' \" % column\n",
                "                            warnMsg += \"in database '%s'\" % db\n",
                "                            logger.warn(warnMsg)\n",
                "\n",
                "                            continue\n",
                "\n",
                "                        indexRange = getRange(count)\n",
                "\n",
                "                        for index in indexRange:\n",
                "                            query = rootQuery.blind.query2\n",
                "                            query = query % db\n",
                "                            query += \" AND %s\" % colQuery\n",
                "                            query = agent.limitQuery(index, query)\n",
                "                            tbl = inject.getValue(query, inband=False)\n",
                "                            kb.hintValue = tbl\n",
                "\n",
                "                            if tbl not in dbs[db]:\n",
                "                                dbs[db][tbl] = {}\n",
                "\n",
                "                            if colConsider == \"1\":\n",
                "                                conf.db = db\n",
                "                                conf.tbl = tbl\n",
                "                                conf.col = column\n",
                "\n",
                "                                self.getColumns(onlyColNames=True)\n",
                "\n",
                "                                dbs[db][tbl].update(kb.data.cachedColumns[db][tbl])\n",
                "                                kb.data.cachedColumns = {}\n",
                "                            else:\n",
                "                                dbs[db][tbl][column] = None\n",
                "\n",
                "                            foundCols[column][db].append(tbl)\n",
                "\n",
                "        self.dumpFoundColumn(dbs, foundCols, colConsider)\n",
                "\n",
                "    def search(self):\n",
                "        if conf.db:\n",
                "            conf.dumper.lister(\"found databases\", self.searchDb())\n",
                "\n",
                "        if conf.tbl:\n",
                "            conf.dumper.dbTables(self.searchTable())\n",
                "\n",
                "        if conf.col:\n",
                "            self.searchColumn()\n",
                "\n",
                "        if not conf.db and not conf.tbl and not conf.col:\n",
                "            errMsg = \"missing parameter, provide -D, -T or -C together \"\n",
                "            errMsg += \"with --search\"\n",
                "            raise sqlmapMissingMandatoryOptionException, errMsg\n",
                "\n",
                "    def sqlQuery(self, query):\n",
                "        output  = None\n",
                "        sqlType = None\n",
                "\n",
                "        for sqlTitle, sqlStatements in SQL_STATEMENTS.items():\n",
                "            for sqlStatement in sqlStatements:\n",
                "                if query.lower().startswith(sqlStatement):\n",
                "                    sqlType = sqlTitle\n",
                "\n",
                "                    break\n",
                "\n",
                "        message   = \"do you want to retrieve the SQL statement output? \"\n",
                "        message  += \"[Y/n] \"\n",
                "        getOutput = readInput(message, default=\"Y\")\n",
                "\n",
                "        if not getOutput or getOutput in (\"y\", \"Y\"):\n",
                "            infoMsg = \"fetching %s query output: '%s'\" % (sqlType if sqlType is not None else \"SQL\", query)\n",
                "            logger.info(infoMsg)\n",
                "\n",
                "            output = inject.getValue(query, fromUser=True)\n",
                "\n",
                "            return output\n",
                "        else:\n",
                "            if not isTechniqueAvailable(PAYLOAD.TECHNIQUE.STACKED) and not conf.direct:\n",
                "                warnMsg  = \"execution of custom SQL queries is only \"\n",
                "                warnMsg += \"available when stacked queries are supported\"\n",
                "                logger.warn(warnMsg)\n",
                "                return None\n",
                "            else:\n",
                "                if sqlType:\n",
                "                    infoMsg = \"executing %s query: '%s'\" % (sqlType if sqlType is not None else \"SQL\", query)\n",
                "                else:\n",
                "                    infoMsg = \"executing unknown SQL type query: '%s'\" % query\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                inject.goStacked(query)\n",
                "\n",
                "                infoMsg = \"done\"\n",
                "                logger.info(infoMsg)\n",
                "\n",
                "                output = False\n",
                "\n",
                "        return output\n",
                "\n",
                "    def sqlShell(self):\n",
                "        infoMsg  = \"calling %s shell. To quit type \" % kb.dbms\n",
                "        infoMsg += \"'x' or 'q' and press ENTER\"\n",
                "        logger.info(infoMsg)\n",
                "\n",
                "        autoCompletion(sqlShell=True)\n",
                "\n",
                "        while True:\n",
                "            query = None\n",
                "\n",
                "            try:\n",
                "                query = raw_input(\"sql-shell> \")\n",
                "                query = utf8decode(query)\n",
                "            except KeyboardInterrupt:\n",
                "                print\n",
                "                errMsg = \"user aborted\"\n",
                "                logger.error(errMsg)\n",
                "            except EOFError:\n",
                "                print\n",
                "                errMsg = \"exit\"\n",
                "                logger.error(errMsg)\n",
                "                break\n",
                "\n",
                "            if not query:\n",
                "                continue\n",
                "\n",
                "            if query.lower() in ( \"x\", \"q\", \"exit\", \"quit\" ):\n",
                "                break\n",
                "\n",
                "            output = self.sqlQuery(query)\n",
                "\n",
                "            if output and output != \"Quit\":\n",
                "                conf.dumper.query(query, output)\n",
                "\n",
                "            elif not output:\n",
                "                pass\n",
                "\n",
                "            elif output != \"Quit\":\n",
                "                dataToStdout(\"No output\\n\")"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "def and import"
        },
        {
            "edit_hunk_pair": [
                0,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                0,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "def and import"
        },
        {
            "edit_hunk_pair": [
                0,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                0,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                1,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "clone"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                3,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        }
    ]
}