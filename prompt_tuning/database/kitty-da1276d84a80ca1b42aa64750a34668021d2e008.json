{
    "language": "python",
    "commit_url": "https://github.com/kovidgoyal/kitty/commit/da1276d84a80ca1b42aa64750a34668021d2e008",
    "commit_message": "Correct the naming of the window arg to call_remote_control",
    "commit_snapshots": {
        "kittens/hints/main.py": [
            [
                "#!/usr/bin/env python3\n",
                "# License: GPL v3 Copyright: 2018, Kovid Goyal <kovid at kovidgoyal.net>\n",
                "\n",
                "import sys\n",
                "from functools import lru_cache\n",
                "from typing import Any, Dict, List, Optional, Sequence, Tuple\n",
                "\n",
                "from kitty.cli_stub import HintsCLIOptions\n",
                "from kitty.clipboard import set_clipboard_string, set_primary_selection\n",
                "from kitty.constants import website_url\n",
                "from kitty.fast_data_types import get_options\n",
                "from kitty.typing import BossType\n",
                "from kitty.utils import resolve_custom_file\n",
                "\n",
                "from ..tui.handler import result_handler\n",
                "\n",
                "DEFAULT_REGEX = r'(?m)^\\s*(.+)\\s*$'\n",
                "\n",
                "def load_custom_processor(customize_processing: str) -> Any:\n",
                "    if customize_processing.startswith('::import::'):\n",
                "        import importlib\n",
                "        m = importlib.import_module(customize_processing[len('::import::'):])\n",
                "        return {k: getattr(m, k) for k in dir(m)}\n",
                "    if customize_processing == '::linenum::':\n",
                "        return {'handle_result': linenum_handle_result}\n",
                "    custom_path = resolve_custom_file(customize_processing)\n",
                "    import runpy\n",
                "    return runpy.run_path(custom_path, run_name='__main__')\n",
                "\n",
                "class Mark:\n",
                "\n",
                "    __slots__ = ('index', 'start', 'end', 'text', 'is_hyperlink', 'group_id', 'groupdict')\n",
                "\n",
                "    def __init__(\n",
                "            self,\n",
                "            index: int, start: int, end: int,\n",
                "            text: str,\n",
                "            groupdict: Any,\n",
                "            is_hyperlink: bool = False,\n",
                "            group_id: Optional[str] = None\n",
                "    ):\n",
                "        self.index, self.start, self.end = index, start, end\n",
                "        self.text = text\n",
                "        self.groupdict = groupdict\n",
                "        self.is_hyperlink = is_hyperlink\n",
                "        self.group_id = group_id\n",
                "\n",
                "    def as_dict(self) -> Dict[str, Any]:\n",
                "        return {\n",
                "            'index': self.index, 'start': self.start, 'end': self.end,\n",
                "            'text': self.text, 'groupdict': {str(k):v for k, v in (self.groupdict or {}).items()},\n",
                "            'group_id': self.group_id or '', 'is_hyperlink': self.is_hyperlink\n",
                "        }\n",
                "\n",
                "\n",
                "def parse_hints_args(args: List[str]) -> Tuple[HintsCLIOptions, List[str]]:\n",
                "    from kitty.cli import parse_args\n",
                "    return parse_args(args, OPTIONS, usage, help_text, 'kitty +kitten hints', result_class=HintsCLIOptions)\n",
                "\n",
                "\n",
                "def custom_marking() -> None:\n",
                "    import json\n",
                "    text = sys.stdin.read()\n",
                "    sys.stdin.close()\n",
                "    opts, extra_cli_args = parse_hints_args(sys.argv[1:])\n",
                "    m = load_custom_processor(opts.customize_processing or '::impossible::')\n",
                "    if 'mark' not in m:\n",
                "        raise SystemExit(2)\n",
                "    all_marks = tuple(x.as_dict() for x in m['mark'](text, opts, Mark, extra_cli_args))\n",
                "    sys.stdout.write(json.dumps(all_marks))\n",
                "    raise SystemExit(0)\n",
                "\n",
                "\n",
                "OPTIONS = r'''\n",
                "--program\n",
                "type=list\n",
                "What program to use to open matched text. Defaults to the default open program\n",
                "for the operating system. Various special values are supported:\n",
                "\n",
                ":code:`-`\n",
                "    paste the match into the terminal window.\n",
                "\n",
                ":code:`@`\n",
                "    copy the match to the clipboard\n",
                "\n",
                ":code:`*`\n",
                "    copy the match to the primary selection (on systems that support primary selections)\n",
                "\n",
                ":code:`@NAME`\n",
                "    copy the match to the specified buffer, e.g. :code:`@a`\n",
                "\n",
                ":code:`default`\n",
                "    run the default open program. Note that when using the hyperlink :code:`--type`\n",
                "    the default is to use the kitty :doc:`hyperlink handling </open_actions>` facilities.\n",
                "\n",
                ":code:`launch`\n",
                "    run :doc:`/launch` to open the program in a new kitty tab, window, overlay, etc.\n",
                "    For example::\n",
                "\n",
                "        --program \"launch --type=tab vim\"\n",
                "\n",
                "Can be specified multiple times to run multiple programs.\n",
                "\n",
                "\n",
                "--type\n",
                "default=url\n",
                "choices=url,regex,path,line,hash,word,linenum,hyperlink,ip\n",
                "The type of text to search for. A value of :code:`linenum` is special, it looks\n",
                "for error messages using the pattern specified with :option:`--regex`, which\n",
                "must have the named groups: :code:`path` and :code:`line`. If not specified,\n",
                "will look for :code:`path:line`. The :option:`--linenum-action` option\n",
                "controls where to display the selected error message, other options are ignored.\n",
                "\n",
                "\n",
                "--regex\n",
                "default={default_regex}\n",
                "The regular expression to use when option :option:`--type` is set to\n",
                ":code:`regex`, in python syntax. If you specify a numbered group in the regular\n",
                "expression, only the group will be matched. This allow you to match text\n",
                "ignoring a prefix/suffix, as needed. The default expression matches lines. To\n",
                "match text over multiple lines, you should prefix the regular expression with\n",
                ":code:`(?ms)`, which turns on MULTILINE and DOTALL modes for the regex engine.\n",
                "If you specify named groups and a :option:`--program`, then the program will be\n",
                "passed arguments corresponding to each named group of the form\n",
                ":code:`key=value`.\n",
                "\n",
                "\n",
                "--linenum-action\n",
                "default=self\n",
                "type=choice\n",
                "choices=self,window,tab,os_window,background\n",
                "Where to perform the action on matched errors. :code:`self` means the current\n",
                "window, :code:`window` a new kitty window, :code:`tab` a new tab,\n",
                ":code:`os_window` a new OS window and :code:`background` run in the background.\n",
                "The actual action is whatever arguments are provided to the kitten, for\n",
                "example:\n",
                ":code:`kitty +kitten hints --type=linenum --linenum-action=tab vim +{line} {path}`\n",
                "will open the matched path at the matched line number in vim in\n",
                "a new kitty tab. Note that in order to use :option:`--program` to copy or paste\n",
                "the provided arguments, you need to use the special value :code:`self`.\n",
                "\n",
                "\n",
                "--url-prefixes\n",
                "default=default\n",
                "Comma separated list of recognized URL prefixes. Defaults to the list of\n",
                "prefixes defined by the :opt:`url_prefixes` option in :file:`kitty.conf`.\n",
                "\n",
                "\n",
                "--word-characters\n",
                "Characters to consider as part of a word. In addition, all characters marked as\n",
                "alphanumeric in the Unicode database will be considered as word characters.\n",
                "Defaults to the :opt:`select_by_word_characters` option from :file:`kitty.conf`.\n",
                "\n",
                "\n",
                "--minimum-match-length\n",
                "default=3\n",
                "type=int\n",
                "The minimum number of characters to consider a match.\n",
                "\n",
                "\n",
                "--multiple\n",
                "type=bool-set\n",
                "Select multiple matches and perform the action on all of them together at the\n",
                "end. In this mode, press :kbd:`Esc` to finish selecting.\n",
                "\n",
                "\n",
                "--multiple-joiner\n",
                "default=auto\n",
                "String for joining multiple selections when copying to the clipboard or\n",
                "inserting into the terminal. The special values are: :code:`space` - a space\n",
                "character, :code:`newline` - a newline, :code:`empty` - an empty joiner,\n",
                ":code:`json` - a JSON serialized list, :code:`auto` - an automatic choice, based\n",
                "on the type of text being selected. In addition, integers are interpreted as\n",
                "zero-based indices into the list of selections. You can use :code:`0` for the\n",
                "first selection and :code:`-1` for the last.\n",
                "\n",
                "\n",
                "--add-trailing-space\n",
                "default=auto\n",
                "choices=auto,always,never\n",
                "Add trailing space after matched text. Defaults to :code:`auto`, which adds the\n",
                "space when used together with :option:`--multiple`.\n",
                "\n",
                "\n",
                "--hints-offset\n",
                "default=1\n",
                "type=int\n",
                "The offset (from zero) at which to start hint numbering. Note that only numbers\n",
                "greater than or equal to zero are respected.\n",
                "\n",
                "\n",
                "--alphabet\n",
                "The list of characters to use for hints. The default is to use numbers and\n",
                "lowercase English alphabets. Specify your preference as a string of characters.\n",
                "Note that you need to specify the :option:`--hints-offset` as zero to use the\n",
                "first character to highlight the first match, otherwise it will start with the\n",
                "second character by default.\n",
                "\n",
                "\n",
                "--ascending\n",
                "type=bool-set\n",
                "Make the hints increase from top to bottom, instead of decreasing from top to\n",
                "bottom.\n",
                "\n",
                "\n",
                "--hints-foreground-color\n",
                "default=black\n",
                "type=str\n",
                "The foreground color for hints.\n",
                "\n",
                "\n",
                "--hints-background-color\n",
                "default=green\n",
                "type=str\n",
                "The background color for hints.\n",
                "\n",
                "\n",
                "--hints-text-color\n",
                "default=gray\n",
                "type=str\n",
                "The foreground color for text pointed to by the hints.\n",
                "\n",
                "\n",
                "--customize-processing\n",
                "Name of a python file in the kitty config directory which will be imported to\n",
                "provide custom implementations for pattern finding and performing actions\n",
                "on selected matches. You can also specify absolute paths to load the script from\n",
                "elsewhere. See {hints_url} for details.\n",
                "\n",
                "\n",
                "--window-title\n",
                "The title for the hints window, default title is based on the type of text being\n",
                "hinted.\n",
                "'''.format(\n",
                "    default_regex=DEFAULT_REGEX,\n",
                "    line='{{line}}', path='{{path}}',\n",
                "    hints_url=website_url('kittens/hints'),\n",
                ").format\n",
                "help_text = 'Select text from the screen using the keyboard. Defaults to searching for URLs.'\n",
                "usage = ''\n",
                "\n",
                "\n",
                "def main(args: List[str]) -> Optional[Dict[str, Any]]:\n",
                "    raise SystemExit('Should be run as kitten hints')\n",
                "\n",
                "\n",
                "def linenum_process_result(data: Dict[str, Any]) -> Tuple[str, int]:\n",
                "    for match, g in zip(data['match'], data['groupdicts']):\n",
                "        path, line = g['path'], g['line']\n",
                "        if path and line:\n",
                "            return path, int(line)\n",
                "    return '', -1\n",
                "\n",
                "\n",
                "def linenum_handle_result(args: List[str], data: Dict[str, Any], target_window_id: int, boss: BossType, extra_cli_args: Sequence[str], *a: Any) -> None:\n",
                "    path, line = linenum_process_result(data)\n",
                "    if not path:\n",
                "        return\n",
                "\n",
                "    cmd = [x.format(path=path, line=line) for x in extra_cli_args or ('vim', '+{line}', '{path}')]\n",
                "    w = boss.window_id_map.get(target_window_id)\n",
                "    action = data['linenum_action']\n",
                "\n",
                "    if action == 'self':\n",
                "        if w is not None:\n",
                "            def is_copy_action(s: str) -> bool:\n",
                "                return s in ('-', '@', '*') or s.startswith('@')\n",
                "\n",
                "            programs = list(filter(is_copy_action, data['programs'] or ()))\n",
                "            # keep for backward compatibility, previously option `--program` does not need to be specified to perform copy actions\n",
                "            if is_copy_action(cmd[0]):\n",
                "                programs.append(cmd.pop(0))\n",
                "            if programs:\n",
                "                text = ' '.join(cmd)\n",
                "                for program in programs:\n",
                "                    if program == '-':\n",
                "                        w.paste_bytes(text)\n",
                "                    elif program == '@':\n",
                "                        set_clipboard_string(text)\n",
                "                    elif program == '*':\n",
                "                        set_primary_selection(text)\n",
                "                    elif program.startswith('@'):\n",
                "                        boss.set_clipboard_buffer(program[1:], text)\n",
                "            else:\n",
                "                import shlex\n",
                "                text = ' '.join(shlex.quote(arg) for arg in cmd)\n",
                "                w.paste_bytes(f'{text}\\r')\n",
                "    elif action == 'background':\n",
                "        import subprocess\n",
                "        subprocess.Popen(cmd, cwd=data['cwd'])\n",
                "    else:\n",
                "        getattr(boss, {\n",
                "            'window': 'new_window_with_cwd', 'tab': 'new_tab_with_cwd', 'os_window': 'new_os_window_with_cwd'\n",
                "            }[action])(*cmd)\n",
                "\n",
                "\n",
                "@result_handler(type_of_input='screen-ansi', has_ready_notification=True)\n",
                "def handle_result(args: List[str], data: Dict[str, Any], target_window_id: int, boss: BossType) -> None:\n",
                "    cp = data['customize_processing']\n",
                "    if data['type'] == 'linenum':\n",
                "        cp = '::linenum::'\n",
                "    if cp:\n",
                "        m = load_custom_processor(cp)\n",
                "        if 'handle_result' in m:\n",
                "            m['handle_result'](args, data, target_window_id, boss, data['extra_cli_args'])\n",
                "            return None\n",
                "\n",
                "    programs = data['programs'] or ('default',)\n",
                "    matches: List[str] = []\n",
                "    groupdicts = []\n",
                "    for m, g in zip(data['match'], data['groupdicts']):\n",
                "        if m:\n",
                "            matches.append(m)\n",
                "            groupdicts.append(g)\n",
                "    joiner = data['multiple_joiner']\n",
                "    try:\n",
                "        is_int: Optional[int] = int(joiner)\n",
                "    except Exception:\n",
                "        is_int = None\n",
                "    text_type = data['type']\n",
                "\n",
                "    @lru_cache()\n",
                "    def joined_text() -> str:\n",
                "        if is_int is not None:\n",
                "            try:\n",
                "                return matches[is_int]\n",
                "            except IndexError:\n",
                "                return matches[-1]\n",
                "        if joiner == 'json':\n",
                "            import json\n",
                "            return json.dumps(matches, ensure_ascii=False, indent='\\t')\n",
                "        if joiner == 'auto':\n",
                "            q = '\\n\\r' if text_type in ('line', 'url') else ' '\n",
                "        else:\n",
                "            q = {'newline': '\\n\\r', 'space': ' '}.get(joiner, '')\n",
                "        return q.join(matches)\n",
                "\n",
                "    for program in programs:\n",
                "        if program == '-':\n",
                "            w = boss.window_id_map.get(target_window_id)\n",
                "            if w is not None:\n",
                "                w.paste_text(joined_text())\n",
                "        elif program == '*':\n",
                "            set_primary_selection(joined_text())\n",
                "        elif program.startswith('@'):\n",
                "            if program == '@':\n",
                "                set_clipboard_string(joined_text())\n",
                "            else:\n",
                "                boss.set_clipboard_buffer(program[1:], joined_text())\n",
                "        else:\n",
                "            from kitty.conf.utils import to_cmdline\n",
                "            cwd = data['cwd']\n",
                "            is_default_program = program == 'default'\n",
                "            program = get_options().open_url_with if is_default_program else program\n",
                "            if text_type == 'hyperlink' and is_default_program:\n",
                "                w = boss.window_id_map.get(target_window_id)\n",
                "                for m in matches:\n",
                "                    if w is not None:\n",
                "                        w.open_url(m, hyperlink_id=1, cwd=cwd)\n",
                "            else:\n",
                "                launch_args = []\n",
                "                if isinstance(program, str) and program.startswith('launch '):\n",
                "                    launch_args = to_cmdline(program)\n",
                "                    launch_args.insert(1, '--cwd=' + cwd)\n",
                "                for m, groupdict in zip(matches, groupdicts):\n",
                "                    if groupdict:\n",
                "                        m = []\n",
                "                        for k, v in groupdict.items():\n",
                "                            m.append('{}={}'.format(k, v or ''))\n",
                "                    if launch_args:\n",
                "                        w = boss.window_id_map.get(target_window_id)\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                        boss.call_remote_control(active_window=w, args=tuple(launch_args + ([m] if isinstance(m, str) else m)))\n"
                ],
                "after": [
                    "                        boss.call_remote_control(self_window=w, args=tuple(launch_args + ([m] if isinstance(m, str) else m)))\n"
                ],
                "parent_version_range": {
                    "start": 371,
                    "end": 372
                },
                "child_version_range": {
                    "start": 371,
                    "end": 372
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for program in programs:",
                        "start_line": 337,
                        "end_line": 373
                    },
                    {
                        "type": "if_statement",
                        "statement": "if program == '-':",
                        "start_line": 338,
                        "end_line": 373
                    },
                    {
                        "type": "else_clause",
                        "statement": "else:",
                        "start_line": 349,
                        "end_line": 373
                    },
                    {
                        "type": "if_statement",
                        "statement": "if text_type == 'hyperlink' and is_default_program:",
                        "start_line": 354,
                        "end_line": 373
                    },
                    {
                        "type": "else_clause",
                        "statement": "else:",
                        "start_line": 359,
                        "end_line": 373
                    },
                    {
                        "type": "for_statement",
                        "statement": "for m, groupdict in zip(matches, groupdicts):",
                        "start_line": 364,
                        "end_line": 373
                    },
                    {
                        "type": "if_statement",
                        "statement": "if launch_args:",
                        "start_line": 369,
                        "end_line": 373
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "handle_result",
                        "signature": "def handle_result(args: List[str], data: Dict[str, Any], target_window_id: int, boss: BossType)->None:",
                        "at_line": 297
                    },
                    {
                        "type": "call",
                        "name": "boss.call_remote_control",
                        "signature": "boss.call_remote_control(active_window=w, args=tuple(launch_args + ([m] if isinstance(m, str) else m)))",
                        "at_line": 371,
                        "argument": "active_window=..."
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: kittens/hints/main.py\nCode:\n           def handle_result(args: List[str], data: Dict[str, Any], target_window_id: int, boss: BossType)->None:\n               ...\n368 368                                m.append('{}={}'.format(k, v or ''))\n369 369                        if launch_args:\n370 370                            w = boss.window_id_map.get(target_window_id)\n371      -                         boss.call_remote_control(active_window=w, args=tuple(launch_args + ([m] if isinstance(m, str) else m)))\n    371  +                         boss.call_remote_control(self_window=w, args=tuple(launch_args + ([m] if isinstance(m, str) else m)))\n372 372                        else:\n373 373                            boss.open_url(m, program, cwd=cwd)\n374 374    \n         ...\n",
                "file_path": "kittens/hints/main.py",
                "identifiers_before": [
                    "active_window",
                    "args",
                    "boss",
                    "call_remote_control",
                    "isinstance",
                    "launch_args",
                    "m",
                    "str",
                    "tuple",
                    "w"
                ],
                "identifiers_after": [
                    "args",
                    "boss",
                    "call_remote_control",
                    "isinstance",
                    "launch_args",
                    "m",
                    "self_window",
                    "str",
                    "tuple",
                    "w"
                ],
                "prefix": [
                    "                            m.append('{}={}'.format(k, v or ''))\n",
                    "                    if launch_args:\n",
                    "                        w = boss.window_id_map.get(target_window_id)\n"
                ],
                "suffix": [
                    "                    else:\n",
                    "                        boss.open_url(m, program, cwd=cwd)\n",
                    "\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "call_remote_control",
                            "position": {
                                "start": {
                                    "line": 371,
                                    "column": 29
                                },
                                "end": {
                                    "line": 371,
                                    "column": 48
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kittens/hints/main.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "active_window",
                            "position": {
                                "start": {
                                    "line": 371,
                                    "column": 49
                                },
                                "end": {
                                    "line": 371,
                                    "column": 62
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kittens/hints/main.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "args",
                            "position": {
                                "start": {
                                    "line": 371,
                                    "column": 66
                                },
                                "end": {
                                    "line": 371,
                                    "column": 70
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kittens/hints/main.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "call_remote_control",
                            "position": {
                                "start": {
                                    "line": 371,
                                    "column": 29
                                },
                                "end": {
                                    "line": 371,
                                    "column": 48
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kittens/hints/main.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "self_window",
                            "position": {
                                "start": {
                                    "line": 371,
                                    "column": 49
                                },
                                "end": {
                                    "line": 371,
                                    "column": 60
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kittens/hints/main.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "args",
                            "position": {
                                "start": {
                                    "line": 371,
                                    "column": 64
                                },
                                "end": {
                                    "line": 371,
                                    "column": 68
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kittens/hints/main.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    1,
                    2,
                    3
                ]
            },
            [
                "                    else:\n",
                "                        boss.open_url(m, program, cwd=cwd)\n",
                "\n",
                "\n",
                "if __name__ == '__main__':\n",
                "    # Run with kitty +kitten hints\n",
                "    ans = main(sys.argv)\n",
                "    if ans:\n",
                "        print(ans)\n",
                "elif __name__ == '__doc__':\n",
                "    cd = sys.cli_docs  # type: ignore\n",
                "    cd['usage'] = usage\n",
                "    cd['short_desc'] = 'Select text from screen with keyboard'\n",
                "    cd['options'] = OPTIONS\n",
                "    cd['help_text'] = help_text\n",
                "# }}}"
            ]
        ],
        "kitty/boss.py": [
            [
                "#!/usr/bin/env python3\n",
                "# License: GPL v3 Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n",
                "\n",
                "import atexit\n",
                "import base64\n",
                "import json\n",
                "import os\n",
                "import re\n",
                "import sys\n",
                "from contextlib import contextmanager, suppress\n",
                "from functools import partial\n",
                "from gettext import gettext as _\n",
                "from gettext import ngettext\n",
                "from time import monotonic, sleep\n",
                "from typing import (\n",
                "    TYPE_CHECKING,\n",
                "    Any,\n",
                "    Callable,\n",
                "    Container,\n",
                "    Dict,\n",
                "    Generator,\n",
                "    Iterable,\n",
                "    Iterator,\n",
                "    List,\n",
                "    Optional,\n",
                "    Set,\n",
                "    Tuple,\n",
                "    Union,\n",
                ")\n",
                "from weakref import WeakValueDictionary\n",
                "\n",
                "from .child import cached_process_data, default_env, set_default_env\n",
                "from .cli import create_opts, parse_args\n",
                "from .cli_stub import CLIOptions\n",
                "from .clipboard import (\n",
                "    Clipboard,\n",
                "    ClipboardType,\n",
                "    get_clipboard_string,\n",
                "    get_primary_selection,\n",
                "    set_clipboard_string,\n",
                "    set_primary_selection,\n",
                ")\n",
                "from .conf.utils import BadLine, KeyAction, to_cmdline\n",
                "from .config import common_opts_as_dict, prepare_config_file_for_editing\n",
                "from .constants import (\n",
                "    RC_ENCRYPTION_PROTOCOL_VERSION,\n",
                "    appname,\n",
                "    cache_dir,\n",
                "    clear_handled_signals,\n",
                "    config_dir,\n",
                "    handled_signals,\n",
                "    is_macos,\n",
                "    is_wayland,\n",
                "    kitten_exe,\n",
                "    kitty_exe,\n",
                "    logo_png_file,\n",
                "    supports_primary_selection,\n",
                "    website_url,\n",
                ")\n",
                "from .fast_data_types import (\n",
                "    CLOSE_BEING_CONFIRMED,\n",
                "    GLFW_MOD_ALT,\n",
                "    GLFW_MOD_CONTROL,\n",
                "    GLFW_MOD_SHIFT,\n",
                "    GLFW_MOD_SUPER,\n",
                "    GLFW_MOUSE_BUTTON_LEFT,\n",
                "    GLFW_PRESS,\n",
                "    GLFW_RELEASE,\n",
                "    IMPERATIVE_CLOSE_REQUESTED,\n",
                "    NO_CLOSE_REQUESTED,\n",
                "    ChildMonitor,\n",
                "    Color,\n",
                "    EllipticCurveKey,\n",
                "    KeyEvent,\n",
                "    SingleKey,\n",
                "    add_timer,\n",
                "    apply_options_update,\n",
                "    background_opacity_of,\n",
                "    change_background_opacity,\n",
                "    cocoa_hide_app,\n",
                "    cocoa_hide_other_apps,\n",
                "    cocoa_minimize_os_window,\n",
                "    cocoa_set_menubar_title,\n",
                "    create_os_window,\n",
                "    current_application_quit_request,\n",
                "    current_focused_os_window_id,\n",
                "    current_os_window,\n",
                "    destroy_global_data,\n",
                "    focus_os_window,\n",
                "    get_boss,\n",
                "    get_options,\n",
                "    get_os_window_size,\n",
                "    global_font_size,\n",
                "    is_modifier_key,\n",
                "    last_focused_os_window_id,\n",
                "    mark_os_window_for_close,\n",
                "    os_window_font_size,\n",
                "    patch_global_colors,\n",
                "    redirect_mouse_handling,\n",
                "    ring_bell,\n",
                "    run_with_activation_token,\n",
                "    safe_pipe,\n",
                "    send_data_to_peer,\n",
                "    set_application_quit_request,\n",
                "    set_background_image,\n",
                "    set_boss,\n",
                "    set_in_sequence_mode,\n",
                "    set_options,\n",
                "    set_os_window_size,\n",
                "    set_os_window_title,\n",
                "    thread_write,\n",
                "    toggle_fullscreen,\n",
                "    toggle_maximized,\n",
                "    toggle_secure_input,\n",
                "    wrapped_kitten_names,\n",
                ")\n",
                "from .key_encoding import get_name_to_functional_number_map\n",
                "from .keys import get_shortcut, shortcut_matches\n",
                "from .layout.base import set_layout_options\n",
                "from .notify import notification_activated\n",
                "from .options.types import Options\n",
                "from .options.utils import MINIMUM_FONT_SIZE, KeyMap, SubSequenceMap\n",
                "from .os_window_size import initial_window_size_func\n",
                "from .rgb import color_from_int\n",
                "from .session import Session, create_sessions, get_os_window_sizing_data\n",
                "from .tabs import SpecialWindow, SpecialWindowInstance, Tab, TabDict, TabManager\n",
                "from .types import _T, AsyncResponse, SingleInstanceData, WindowSystemMouseEvent, ac\n",
                "from .typing import PopenType, TypedDict\n",
                "from .utils import (\n",
                "    cleanup_ssh_control_masters,\n",
                "    func_name,\n",
                "    get_editor,\n",
                "    get_new_os_window_size,\n",
                "    is_ok_to_read_image_file,\n",
                "    is_path_in_temp_dir,\n",
                "    less_version,\n",
                "    log_error,\n",
                "    macos_version,\n",
                "    open_url,\n",
                "    parse_address_spec,\n",
                "    parse_os_window_state,\n",
                "    parse_uri_list,\n",
                "    platform_window_id,\n",
                "    remove_socket_file,\n",
                "    safe_print,\n",
                "    sanitize_url_for_dispay_to_user,\n",
                "    single_instance,\n",
                "    startup_notification_handler,\n",
                "    which,\n",
                ")\n",
                "from .window import CommandOutput, CwdRequest, Window, load_shader_programs\n",
                "\n",
                "if TYPE_CHECKING:\n",
                "    from .rc.base import ResponseType\n",
                "\n",
                "RCResponse = Union[Dict[str, Any], None, AsyncResponse]\n",
                "\n",
                "\n",
                "class OSWindowDict(TypedDict):\n",
                "    id: int\n",
                "    platform_window_id: Optional[int]\n",
                "    is_focused: bool\n",
                "    is_active: bool\n",
                "    last_focused: bool\n",
                "    tabs: List[TabDict]\n",
                "    wm_class: str\n",
                "    wm_name: str\n",
                "\n",
                "\n",
                "def listen_on(spec: str) -> int:\n",
                "    import socket\n",
                "    family, address, socket_path = parse_address_spec(spec)\n",
                "    s = socket.socket(family)\n",
                "    atexit.register(remove_socket_file, s, socket_path)\n",
                "    s.bind(address)\n",
                "    s.listen()\n",
                "    return s.fileno()\n",
                "\n",
                "\n",
                "def data_for_at(w: Optional[Window], arg: str, add_wrap_markers: bool = False) -> Optional[str]:\n",
                "    if not w:\n",
                "        return None\n",
                "\n",
                "    def as_text(**kw: bool) -> str:\n",
                "        kw['add_wrap_markers'] = add_wrap_markers\n",
                "        return w.as_text(**kw) if w else ''\n",
                "\n",
                "    if arg == '@selection':\n",
                "        return w.text_for_selection()\n",
                "    if arg in ('@ansi', '@ansi_screen_scrollback'):\n",
                "        return as_text(as_ansi=True, add_history=True)\n",
                "    if arg in ('@text', '@screen_scrollback'):\n",
                "        return as_text(add_history=True)\n",
                "    if arg == '@screen':\n",
                "        return as_text()\n",
                "    if arg == '@ansi_screen':\n",
                "        return as_text(as_ansi=True)\n",
                "    if arg == '@alternate':\n",
                "        return as_text(alternate_screen=True)\n",
                "    if arg == '@alternate_scrollback':\n",
                "        return as_text(alternate_screen=True, add_history=True)\n",
                "    if arg == '@ansi_alternate':\n",
                "        return as_text(as_ansi=True, alternate_screen=True)\n",
                "    if arg == '@ansi_alternate_scrollback':\n",
                "        return as_text(as_ansi=True, alternate_screen=True, add_history=True)\n",
                "    if arg == '@first_cmd_output_on_screen':\n",
                "        return w.cmd_output(CommandOutput.first_on_screen, add_wrap_markers=add_wrap_markers)\n",
                "    if arg == '@ansi_first_cmd_output_on_screen':\n",
                "        return w.cmd_output(CommandOutput.first_on_screen, as_ansi=True, add_wrap_markers=add_wrap_markers)\n",
                "    if arg == '@last_cmd_output':\n",
                "        return w.cmd_output(CommandOutput.last_run, add_wrap_markers=add_wrap_markers)\n",
                "    if arg == '@ansi_last_cmd_output':\n",
                "        return w.cmd_output(CommandOutput.last_run, as_ansi=True, add_wrap_markers=add_wrap_markers)\n",
                "    if arg == '@last_visited_cmd_output':\n",
                "        return w.cmd_output(CommandOutput.last_visited, add_wrap_markers=add_wrap_markers)\n",
                "    if arg == '@ansi_last_visited_cmd_output':\n",
                "        return w.cmd_output(CommandOutput.last_visited, as_ansi=True, add_wrap_markers=add_wrap_markers)\n",
                "    return None\n",
                "\n",
                "\n",
                "class DumpCommands:  # {{{\n",
                "\n",
                "    def __init__(self, args: CLIOptions):\n",
                "        self.draw_dump_buf: List[str] = []\n",
                "        if args.dump_bytes:\n",
                "            self.dump_bytes_to = open(args.dump_bytes, 'wb')\n",
                "\n",
                "    def __call__(self, *a: Any) -> None:\n",
                "        if a:\n",
                "            if a[0] == 'draw':\n",
                "                if a[1] is None:\n",
                "                    if self.draw_dump_buf:\n",
                "                        safe_print('draw', ''.join(self.draw_dump_buf))\n",
                "                        self.draw_dump_buf = []\n",
                "                else:\n",
                "                    self.draw_dump_buf.append(a[1])\n",
                "            elif a[0] == 'bytes':\n",
                "                self.dump_bytes_to.write(a[1])\n",
                "                self.dump_bytes_to.flush()\n",
                "            else:\n",
                "                if self.draw_dump_buf:\n",
                "                    safe_print('draw', ''.join(self.draw_dump_buf))\n",
                "                    self.draw_dump_buf = []\n",
                "                safe_print(*a)\n",
                "# }}}\n",
                "\n",
                "\n",
                "class VisualSelect:\n",
                "\n",
                "    def __init__(\n",
                "        self,\n",
                "        tab_id: int,\n",
                "        os_window_id: int,\n",
                "        prev_tab_id: Optional[int],\n",
                "        prev_os_window_id: Optional[int],\n",
                "        title: str,\n",
                "        callback: Callable[[Optional[Tab], Optional[Window]], None],\n",
                "        reactivate_prev_tab: bool\n",
                "    ) -> None:\n",
                "        self.tab_id = tab_id\n",
                "        self.os_window_id = os_window_id\n",
                "        self.prev_tab_id = prev_tab_id\n",
                "        self.prev_os_window_id = prev_os_window_id\n",
                "        self.callback = callback\n",
                "        self.window_ids: List[int] = []\n",
                "        self.window_used_for_selection_id = 0\n",
                "        self.reactivate_prev_tab = reactivate_prev_tab\n",
                "        set_os_window_title(self.os_window_id, title)\n",
                "\n",
                "    def cancel(self) -> None:\n",
                "        self.clear_global_state()\n",
                "        self.activate_prev_tab()\n",
                "        self.callback(None, None)\n",
                "\n",
                "    def trigger(self, window_id: int) -> None:\n",
                "        boss = self.clear_global_state()\n",
                "        self.activate_prev_tab()\n",
                "        w = boss.window_id_map.get(window_id)\n",
                "        if w is None:\n",
                "            self.callback(None, None)\n",
                "        else:\n",
                "            tab = w.tabref()\n",
                "            if tab is None:\n",
                "                self.callback(None, None)\n",
                "            else:\n",
                "                self.callback(tab, w)\n",
                "\n",
                "    def clear_global_state(self) -> 'Boss':\n",
                "        set_os_window_title(self.os_window_id, '')\n",
                "        boss = get_boss()\n",
                "        redirect_mouse_handling(False)\n",
                "        boss.clear_pending_sequences()\n",
                "        for wid in self.window_ids:\n",
                "            w = boss.window_id_map.get(wid)\n",
                "            if w is not None:\n",
                "                w.screen.set_window_char()\n",
                "        if self.window_used_for_selection_id:\n",
                "            w = boss.window_id_map.get(self.window_used_for_selection_id)\n",
                "            if w is not None:\n",
                "                boss.mark_window_for_close(w)\n",
                "        return boss\n",
                "\n",
                "    def activate_prev_tab(self) -> None:\n",
                "        if not self.reactivate_prev_tab or self.prev_tab_id is None:\n",
                "            return None\n",
                "        boss = get_boss()\n",
                "        tm = boss.os_window_map.get(self.os_window_id)\n",
                "        if tm is not None:\n",
                "            t = tm.tab_for_id(self.prev_tab_id)\n",
                "            if t is not tm.active_tab and t is not None:\n",
                "                tm.set_active_tab(t)\n",
                "        if current_focused_os_window_id() != self.prev_os_window_id and self.prev_os_window_id is not None:\n",
                "            focus_os_window(self.prev_os_window_id, True)\n",
                "\n",
                "\n",
                "class Boss:\n",
                "\n",
                "    def __init__(\n",
                "        self,\n",
                "        opts: Options,\n",
                "        args: CLIOptions,\n",
                "        cached_values: Dict[str, Any],\n",
                "        global_shortcuts: Dict[str, SingleKey],\n",
                "    ):\n",
                "        set_layout_options(opts)\n",
                "        self.clipboard = Clipboard()\n",
                "        self.primary_selection = Clipboard(ClipboardType.primary_selection)\n",
                "        self.update_check_started = False\n",
                "        self.encryption_key = EllipticCurveKey()\n",
                "        self.encryption_public_key = f'{RC_ENCRYPTION_PROTOCOL_VERSION}:{base64.b85encode(self.encryption_key.public).decode(\"ascii\")}'\n",
                "        self.clipboard_buffers: Dict[str, str] = {}\n",
                "        self.update_check_process: Optional['PopenType[bytes]'] = None\n",
                "        self.window_id_map: WeakValueDictionary[int, Window] = WeakValueDictionary()\n",
                "        self.startup_colors = {k: opts[k] for k in opts if isinstance(opts[k], Color)}\n",
                "        self.current_visual_select: Optional[VisualSelect] = None\n",
                "        self.startup_cursor_text_color = opts.cursor_text_color\n",
                "        self.pending_sequences: Optional[SubSequenceMap] = None\n",
                "        # A list of events received so far that are potentially part of a sequence keybinding.\n",
                "        self.current_sequence: List[KeyEvent] = []\n",
                "        self.default_pending_action: str = ''\n",
                "        self.cached_values = cached_values\n",
                "        self.os_window_map: Dict[int, TabManager] = {}\n",
                "        self.os_window_death_actions: Dict[int, Callable[[], None]] = {}\n",
                "        self.cursor_blinking = True\n",
                "        self.shutting_down = False\n",
                "        talk_fd = getattr(single_instance, 'socket', None)\n",
                "        talk_fd = -1 if talk_fd is None else talk_fd.fileno()\n",
                "        listen_fd = -1\n",
                "        # we dont allow reloading the config file to change\n",
                "        # allow_remote_control\n",
                "        self.allow_remote_control = opts.allow_remote_control\n",
                "        if self.allow_remote_control in ('y', 'yes', 'true'):\n",
                "            self.allow_remote_control = 'y'\n",
                "        elif self.allow_remote_control in ('n', 'no', 'false'):\n",
                "            self.allow_remote_control = 'n'\n",
                "        self.listening_on = ''\n",
                "        if args.listen_on and self.allow_remote_control in ('y', 'socket', 'socket-only', 'password'):\n",
                "            listen_fd = listen_on(args.listen_on)\n",
                "            self.listening_on = args.listen_on\n",
                "        self.child_monitor = ChildMonitor(\n",
                "            self.on_child_death,\n",
                "            DumpCommands(args) if args.dump_commands or args.dump_bytes else None,\n",
                "            talk_fd, listen_fd,\n",
                "        )\n",
                "        set_boss(self)\n",
                "        self.args = args\n",
                "        self.global_shortcuts_map: KeyMap = {v: k for k, v in global_shortcuts.items()}\n",
                "        self.global_shortcuts = global_shortcuts\n",
                "        self.mouse_handler: Optional[Callable[[WindowSystemMouseEvent], None]] = None\n",
                "        self.update_keymap()\n",
                "        if is_macos:\n",
                "            from .fast_data_types import cocoa_set_notification_activated_callback\n",
                "            cocoa_set_notification_activated_callback(notification_activated)\n",
                "\n",
                "    def update_keymap(self) -> None:\n",
                "        self.keymap = get_options().keymap.copy()\n",
                "        for sc in self.global_shortcuts.values():\n",
                "            self.keymap.pop(sc, None)\n",
                "\n",
                "    def startup_first_child(self, os_window_id: Optional[int], startup_sessions: Iterable[Session] = ()) -> None:\n",
                "        si = startup_sessions or create_sessions(get_options(), self.args, default_session=get_options().startup_session)\n",
                "        focused_os_window = wid = 0\n",
                "        token = os.environ.pop('XDG_ACTIVATION_TOKEN', '')\n",
                "        with Window.set_ignore_focus_changes_for_new_windows():\n",
                "            for startup_session in si:\n",
                "                # The window state from the CLI options will override and apply to every single OS window in startup session\n",
                "                wstate = self.args.start_as if self.args.start_as and self.args.start_as != 'normal' else None\n",
                "                wid = self.add_os_window(startup_session, window_state=wstate, os_window_id=os_window_id)\n",
                "                if startup_session.focus_os_window:\n",
                "                    focused_os_window = wid\n",
                "                os_window_id = None\n",
                "            if focused_os_window > 0:\n",
                "                focus_os_window(focused_os_window, True, token)\n",
                "            elif token and is_wayland() and wid:\n",
                "                focus_os_window(wid, True, token)\n",
                "        for w in self.all_windows:\n",
                "            w.ignore_focus_changes = False\n",
                "\n",
                "    def add_os_window(\n",
                "        self,\n",
                "        startup_session: Optional[Session] = None,\n",
                "        os_window_id: Optional[int] = None,\n",
                "        wclass: Optional[str] = None,\n",
                "        wname: Optional[str] = None,\n",
                "        window_state: Optional[str] = None,\n",
                "        opts_for_size: Optional[Options] = None,\n",
                "        startup_id: Optional[str] = None,\n",
                "        override_title: Optional[str] = None,\n",
                "    ) -> int:\n",
                "        if os_window_id is None:\n",
                "            size_data = get_os_window_sizing_data(opts_for_size or get_options(), startup_session)\n",
                "            wclass = wclass or getattr(startup_session, 'os_window_class', None) or self.args.cls or appname\n",
                "            wname = wname or self.args.name or wclass\n",
                "            wtitle = override_title or self.args.title\n",
                "            window_state = window_state or getattr(startup_session, 'os_window_state', None)\n",
                "            wstate = parse_os_window_state(window_state) if window_state is not None else None\n",
                "            with startup_notification_handler(do_notify=startup_id is not None, startup_id=startup_id) as pre_show_callback:\n",
                "                os_window_id = create_os_window(\n",
                "                        initial_window_size_func(size_data, self.cached_values),\n",
                "                        pre_show_callback,\n",
                "                        wtitle or appname, wname, wclass, wstate, disallow_override_title=bool(wtitle))\n",
                "        else:\n",
                "            wname = self.args.name or self.args.cls or appname\n",
                "            wclass = self.args.cls or appname\n",
                "        tm = TabManager(os_window_id, self.args, wclass, wname, startup_session)\n",
                "        self.os_window_map[os_window_id] = tm\n",
                "        return os_window_id\n",
                "\n",
                "    def list_os_windows(self, self_window: Optional[Window] = None) -> Iterator[OSWindowDict]:\n",
                "        with cached_process_data():\n",
                "            active_tab_manager = self.active_tab_manager\n",
                "            for os_window_id, tm in self.os_window_map.items():\n",
                "                yield {\n",
                "                    'id': os_window_id,\n",
                "                    'platform_window_id': platform_window_id(os_window_id),\n",
                "                    'is_active': tm is active_tab_manager,\n",
                "                    'is_focused': current_focused_os_window_id() == os_window_id,\n",
                "                    'last_focused': os_window_id == last_focused_os_window_id(),\n",
                "                    'tabs': list(tm.list_tabs(self_window)),\n",
                "                    'wm_class': tm.wm_class,\n",
                "                    'wm_name': tm.wm_name\n",
                "                }\n",
                "\n",
                "    @property\n",
                "    def all_tab_managers(self) -> Iterator[TabManager]:\n",
                "        yield from self.os_window_map.values()\n",
                "\n",
                "    @property\n",
                "    def all_tabs(self) -> Iterator[Tab]:\n",
                "        for tm in self.all_tab_managers:\n",
                "            yield from tm\n",
                "\n",
                "    @property\n",
                "    def all_windows(self) -> Iterator[Window]:\n",
                "        for tab in self.all_tabs:\n",
                "            yield from tab\n",
                "\n",
                "    def match_windows(self, match: str, self_window: Optional['Window'] = None) -> Iterator[Window]:\n",
                "        if match == 'all':\n",
                "            yield from self.all_windows\n",
                "            return\n",
                "        from .search_query_parser import search\n",
                "        tab = self.active_tab\n",
                "        if current_focused_os_window_id() <= 0:\n",
                "            tm = self.os_window_map.get(last_focused_os_window_id())\n",
                "            if tm is not None:\n",
                "                tab = tm.active_tab\n",
                "        window_id_limit = max(self.window_id_map, default=-1) + 1\n",
                "\n",
                "        def get_matches(location: str, query: str, candidates: Set[int]) -> Set[int]:\n",
                "            if location == 'id' and query.startswith('-'):\n",
                "                try:\n",
                "                    q = int(query)\n",
                "                except Exception:\n",
                "                    return set()\n",
                "                if q < 0:\n",
                "                    query = str(window_id_limit + q)\n",
                "            return {wid for wid in candidates if self.window_id_map[wid].matches_query(location, query, tab, self_window)}\n",
                "\n",
                "        for wid in search(match, (\n",
                "                'id', 'title', 'pid', 'cwd', 'cmdline', 'num', 'env', 'recent', 'state'\n",
                "        ), set(self.window_id_map), get_matches):\n",
                "            yield self.window_id_map[wid]\n",
                "\n",
                "    def tab_for_window(self, window: Window) -> Optional[Tab]:\n",
                "        for tab in self.all_tabs:\n",
                "            for w in tab:\n",
                "                if w.id == window.id:\n",
                "                    return tab\n",
                "        return None\n",
                "\n",
                "    def match_tabs(self, match: str) -> Iterator[Tab]:\n",
                "        if match == 'all':\n",
                "            yield from self.all_tabs\n",
                "            return\n",
                "        from .search_query_parser import search\n",
                "        tm = self.active_tab_manager\n",
                "        if current_focused_os_window_id() <= 0:\n",
                "            tm = self.os_window_map.get(last_focused_os_window_id()) or tm\n",
                "        tim = {t.id: t for t in self.all_tabs}\n",
                "        tab_id_limit = max(tim, default=-1) + 1\n",
                "        window_id_limit = max(self.window_id_map, default=-1) + 1\n",
                "\n",
                "        def get_matches(location: str, query: str, candidates: Set[int]) -> Set[int]:\n",
                "            if location in ('id', 'window_id') and query.startswith('-'):\n",
                "                try:\n",
                "                    q = int(query)\n",
                "                except Exception:\n",
                "                    return set()\n",
                "                if q < 0:\n",
                "                    limit = tab_id_limit if location == 'id' else window_id_limit\n",
                "                    query = str(limit + q)\n",
                "            return {wid for wid in candidates if tim[wid].matches_query(location, query, tm)}\n",
                "\n",
                "        found = False\n",
                "        for tid in search(match, (\n",
                "                'id', 'index', 'title', 'window_id', 'window_title', 'pid', 'cwd', 'env', 'cmdline', 'recent', 'state'\n",
                "        ), set(tim), get_matches):\n",
                "            found = True\n",
                "            yield tim[tid]\n",
                "\n",
                "        if not found:\n",
                "            tabs = {self.tab_for_window(w) for w in self.match_windows(match)}\n",
                "            for q in tabs:\n",
                "                if q:\n",
                "                    yield q\n",
                "\n",
                "    def set_active_window(self, window: Window, switch_os_window_if_needed: bool = False, for_keep_focus: bool = False) -> Optional[int]:\n",
                "        for os_window_id, tm in self.os_window_map.items():\n",
                "            for tab in tm:\n",
                "                for w in tab:\n",
                "                    if w.id == window.id:\n",
                "                        if tab is not self.active_tab:\n",
                "                            tm.set_active_tab(tab, for_keep_focus=window.tabref() if for_keep_focus else None)\n",
                "                        tab.set_active_window(w, for_keep_focus=window if for_keep_focus else None)\n",
                "                        if switch_os_window_if_needed and current_focused_os_window_id() != os_window_id:\n",
                "                            focus_os_window(os_window_id, True)\n",
                "                        return os_window_id\n",
                "        return None\n",
                "\n",
                "    def _new_os_window(self, args: Union[SpecialWindowInstance, Iterable[str]], cwd_from: Optional[CwdRequest] = None) -> int:\n",
                "        if isinstance(args, SpecialWindowInstance):\n",
                "            sw: Optional[SpecialWindowInstance] = args\n",
                "        else:\n",
                "            sw = self.args_to_special_window(args, cwd_from) if args else None\n",
                "        startup_session = next(create_sessions(get_options(), special_window=sw, cwd_from=cwd_from))\n",
                "        return self.add_os_window(startup_session)\n",
                "\n",
                "    @ac('win', 'New OS Window')\n",
                "    def new_os_window(self, *args: str) -> None:\n",
                "        self._new_os_window(args)\n",
                "\n",
                "    @property\n",
                "    def active_window_for_cwd(self) -> Optional[Window]:\n",
                "        t = self.active_tab\n",
                "        if t is not None:\n",
                "            return t.active_window_for_cwd\n",
                "        return None\n",
                "\n",
                "    @ac('win', 'New OS Window with the same working directory as the currently active window')\n",
                "    def new_os_window_with_cwd(self, *args: str) -> None:\n",
                "        w = self.active_window_for_cwd\n",
                "        self._new_os_window(args, CwdRequest(w))\n",
                "\n",
                "    def new_os_window_with_wd(self, wd: Union[str, List[str]], str_is_multiple_paths: bool = False) -> None:\n",
                "        if isinstance(wd, str):\n",
                "            wd = wd.split(os.pathsep) if str_is_multiple_paths else [wd]\n",
                "        for path in wd:\n",
                "            special_window = SpecialWindow(None, cwd=path)\n",
                "            self._new_os_window(special_window)\n",
                "\n",
                "    def add_child(self, window: Window) -> None:\n",
                "        assert window.child.pid is not None and window.child.child_fd is not None\n",
                "        self.child_monitor.add_child(window.id, window.child.pid, window.child.child_fd, window.screen)\n",
                "        self.window_id_map[window.id] = window\n",
                "\n",
                "    def _handle_remote_command(self, cmd: str, window: Optional[Window] = None, peer_id: int = 0) -> RCResponse:\n",
                "        from .remote_control import is_cmd_allowed, parse_cmd\n",
                "        response = None\n",
                "        window = window or None\n",
                "        window_has_remote_control = bool(window and window.allow_remote_control)\n",
                "        if not window_has_remote_control:\n",
                "            if self.allow_remote_control == 'n':\n",
                "                return {'ok': False, 'error': 'Remote control is disabled'}\n",
                "            if self.allow_remote_control == 'socket-only' and peer_id == 0:\n",
                "                return {'ok': False, 'error': 'Remote control is allowed over a socket only'}\n",
                "        try:\n",
                "            pcmd = parse_cmd(cmd, self.encryption_key)\n",
                "        except Exception as e:\n",
                "            log_error(f'Failed to parse remote command with error: {e}')\n",
                "            return response\n",
                "        if not pcmd:\n",
                "            return response\n",
                "        self_window: Optional[Window] = None\n",
                "        if window is not None:\n",
                "            self_window = window\n",
                "        else:\n",
                "            try:\n",
                "                swid = int(pcmd.get('kitty_window_id', 0))\n",
                "            except Exception:\n",
                "                pass\n",
                "            else:\n",
                "                if swid > 0:\n",
                "                    self_window = self.window_id_map.get(swid)\n",
                "\n",
                "        extra_data: Dict[str, Any] = {}\n",
                "        try:\n",
                "            allowed_unconditionally = (\n",
                "                self.allow_remote_control == 'y' or (peer_id > 0 and self.allow_remote_control in ('socket-only', 'socket')) or\n",
                "                (window and window.remote_control_allowed(pcmd, extra_data)))\n",
                "        except PermissionError:\n",
                "            return {'ok': False, 'error': 'Remote control disallowed by window specific password'}\n",
                "        if allowed_unconditionally:\n",
                "            return self._execute_remote_command(pcmd, window, peer_id, self_window)\n",
                "        q = is_cmd_allowed(pcmd, window, peer_id > 0, extra_data)\n",
                "        if q is True:\n",
                "            return self._execute_remote_command(pcmd, window, peer_id, self_window)\n",
                "        if q is None:\n",
                "            if self.ask_if_remote_cmd_is_allowed(pcmd, window, peer_id, self_window):\n",
                "                return AsyncResponse()\n",
                "        response = {'ok': False, 'error': 'Remote control is disabled. Add allow_remote_control to your kitty.conf'}\n",
                "        if q is False and pcmd.get('password'):\n",
                "            response['error'] = 'The user rejected this password or it is disallowed by remote_control_password in kitty.conf'\n",
                "        no_response = pcmd.get('no_response') or False\n",
                "        if no_response:\n",
                "            return None\n",
                "        return response\n",
                "\n",
                "    def ask_if_remote_cmd_is_allowed(\n",
                "        self, pcmd: Dict[str, Any], window: Optional[Window] = None, peer_id: int = 0, self_window: Optional[Window] = None\n",
                "    ) -> bool:\n",
                "        from kittens.tui.operations import styled\n",
                "        in_flight = 0\n",
                "        for w in self.window_id_map.values():\n",
                "            if w.window_custom_type == 'remote_command_permission_dialog':\n",
                "                in_flight += 1\n",
                "                if in_flight > 4:\n",
                "                    log_error('Denying remote command permission as there are too many existing permission requests')\n",
                "                    return False\n",
                "        wid = 0 if window is None else window.id\n",
                "        hidden_text = styled(pcmd['password'], fg='yellow')\n",
                "        overlay_window = self.choose(\n",
                "            _('A program wishes to control kitty.\\n'\n",
                "              'Action: {1}\\n' 'Password: {0}\\n\\n' '{2}'\n",
                "              ).format(\n",
                "                  hidden_text, styled(pcmd['cmd'], fg='magenta'),\n",
                "                  '\\x1b[m' + styled(_(\n",
                "                      'Note that allowing the password will allow all future actions using the same password, in this kitty instance.'\n",
                "                  ), dim=True, italic=True)),\n",
                "            partial(self.remote_cmd_permission_received, pcmd, wid, peer_id, self_window),\n",
                "            'a;green:Allow request', 'p;yellow:Allow password', 'r;magenta:Deny request', 'd;red:Deny password',\n",
                "            window=window, default='a', hidden_text=hidden_text\n",
                "        )\n",
                "        if overlay_window is None:\n",
                "            return False\n",
                "        overlay_window.window_custom_type = 'remote_command_permission_dialog'\n",
                "        return True\n",
                "\n",
                "    def remote_cmd_permission_received(self, pcmd: Dict[str, Any], window_id: int, peer_id: int, self_window: Optional[Window], choice: str) -> None:\n",
                "        from .remote_control import encode_response_for_peer, set_user_password_allowed\n",
                "        response: RCResponse = None\n",
                "        window = self.window_id_map.get(window_id)\n",
                "        choice = choice or 'r'\n",
                "        if choice in ('r', 'd'):\n",
                "            if choice == 'd':\n",
                "                set_user_password_allowed(pcmd['password'], False)\n",
                "            no_response = pcmd.get('no_response') or False\n",
                "            if not no_response:\n",
                "                response = {'ok': False, 'error': 'The user rejected this ' + ('request' if choice == 'r' else 'password')}\n",
                "        elif choice in ('a', 'p'):\n",
                "            if choice == 'p':\n",
                "                set_user_password_allowed(pcmd['password'], True)\n",
                "            response = self._execute_remote_command(pcmd, window, peer_id, self_window)\n",
                "        if window is not None and response is not None and not isinstance(response, AsyncResponse):\n",
                "            window.send_cmd_response(response)\n",
                "        if peer_id > 0:\n",
                "            if response is None:\n",
                "                send_data_to_peer(peer_id, b'')\n",
                "            elif not isinstance(response, AsyncResponse):\n",
                "                send_data_to_peer(peer_id, encode_response_for_peer(response))\n",
                "\n",
                "    def _execute_remote_command(\n",
                "        self, pcmd: Dict[str, Any], window: Optional[Window] = None, peer_id: int = 0, self_window: Optional[Window] = None\n",
                "    ) -> RCResponse:\n",
                "        from .remote_control import handle_cmd\n",
                "        try:\n",
                "            response = handle_cmd(self, window, pcmd, peer_id, self_window)\n",
                "        except Exception as err:\n",
                "            import traceback\n",
                "            response = {'ok': False, 'error': str(err)}\n",
                "            if not getattr(err, 'hide_traceback', False):\n",
                "                response['tb'] = traceback.format_exc()\n",
                "        return response\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Run a remote control command\n",
                "\n",
                "        For example::\n",
                "\n",
                "            map f1 remote_control set-spacing margin=30\n",
                "\n",
                "        See :ref:`rc_mapping` for details.\n",
                "        ''')\n",
                "    def remote_control(self, *args: str) -> None:\n",
                "        try:\n",
                "            self.call_remote_control(self.active_window, args)\n",
                "        except (Exception, SystemExit) as e:\n",
                "            import shlex\n",
                "            self.show_error(_('remote_control mapping failed'), shlex.join(args) + '\\n' + str(e))\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    def call_remote_control(self, active_window: Optional[Window], args: Tuple[str, ...]) -> 'ResponseType':\n"
                ],
                "after": [
                    "    def call_remote_control(self, self_window: Optional[Window], args: Tuple[str, ...]) -> 'ResponseType':\n"
                ],
                "parent_version_range": {
                    "start": 710,
                    "end": 711
                },
                "child_version_range": {
                    "start": 710,
                    "end": 711
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Boss",
                        "signature": "class Boss:",
                        "at_line": 315
                    },
                    {
                        "type": "function",
                        "name": "call_remote_control",
                        "signature": "def call_remote_control(self, active_window: Optional[Window], args: Tuple[str, ...])->'ResponseType':",
                        "at_line": 710
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: kitty/boss.py\nCode:\n           class Boss:\n               ...\n707 707                import shlex\n708 708                self.show_error(_('remote_control mapping failed'), shlex.join(args) + '\\n' + str(e))\n709 709    \n710      -     def call_remote_control(self, active_window: Optional[Window], args: Tuple[str, ...]) -> 'ResponseType':\n    710  +     def call_remote_control(self, self_window: Optional[Window], args: Tuple[str, ...]) -> 'ResponseType':\n711 711            from .rc.base import PayloadGetter, command_for_name, parse_subcommand_cli\n712 712            from .remote_control import parse_rc_args\n713 713            aa = list(args)\n         ...\n",
                "file_path": "kitty/boss.py",
                "identifiers_before": [
                    "Optional",
                    "Tuple",
                    "Window",
                    "active_window",
                    "args",
                    "call_remote_control",
                    "self",
                    "str"
                ],
                "identifiers_after": [
                    "Optional",
                    "Tuple",
                    "Window",
                    "args",
                    "call_remote_control",
                    "self",
                    "self_window",
                    "str"
                ],
                "prefix": [
                    "            import shlex\n",
                    "            self.show_error(_('remote_control mapping failed'), shlex.join(args) + '\\n' + str(e))\n",
                    "\n"
                ],
                "suffix": [
                    "        from .rc.base import PayloadGetter, command_for_name, parse_subcommand_cli\n",
                    "        from .remote_control import parse_rc_args\n",
                    "        aa = list(args)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "call_remote_control",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 8
                                },
                                "end": {
                                    "line": 710,
                                    "column": 27
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "active_window",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 34
                                },
                                "end": {
                                    "line": 710,
                                    "column": 47
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "active_window",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 34
                                },
                                "end": {
                                    "line": 710,
                                    "column": 47
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "active_window",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 34
                                },
                                "end": {
                                    "line": 710,
                                    "column": 47
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "args",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 67
                                },
                                "end": {
                                    "line": 710,
                                    "column": 71
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 28
                                },
                                "end": {
                                    "line": 710,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 28
                                },
                                "end": {
                                    "line": 710,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "call_remote_control",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 8
                                },
                                "end": {
                                    "line": 710,
                                    "column": 27
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "self_window",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 34
                                },
                                "end": {
                                    "line": 710,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "self_window",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 34
                                },
                                "end": {
                                    "line": 710,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "self_window",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 34
                                },
                                "end": {
                                    "line": 710,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "args",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 65
                                },
                                "end": {
                                    "line": 710,
                                    "column": 69
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 28
                                },
                                "end": {
                                    "line": 710,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 710,
                                    "column": 28
                                },
                                "end": {
                                    "line": 710,
                                    "column": 32
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    0,
                    2,
                    3
                ]
            },
            [
                "        from .rc.base import PayloadGetter, command_for_name, parse_subcommand_cli\n",
                "        from .remote_control import parse_rc_args\n",
                "        aa = list(args)\n",
                "        silent = False\n",
                "        if aa and aa[0].startswith('!'):\n",
                "            aa[0] = aa[0][1:]\n",
                "            silent = True\n",
                "        try:\n",
                "            global_opts, items = parse_rc_args(['@'] + aa)\n",
                "            if not items:\n",
                "                return None\n",
                "            cmd = items[0]\n",
                "            c = command_for_name(cmd)\n",
                "            opts, items = parse_subcommand_cli(c, items)\n",
                "            payload = c.message_to_kitty(global_opts, opts, items)\n",
                "        except SystemExit as e:\n",
                "            raise Exception(str(e)) from e\n",
                "        import types\n",
                "        try:\n",
                "            if isinstance(payload, types.GeneratorType):\n",
                "                for x in payload:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                    c.response_from_kitty(self, active_window, PayloadGetter(c, x if isinstance(x, dict) else {}))\n"
                ],
                "after": [
                    "                    c.response_from_kitty(self, self_window, PayloadGetter(c, x if isinstance(x, dict) else {}))\n"
                ],
                "parent_version_range": {
                    "start": 732,
                    "end": 733
                },
                "child_version_range": {
                    "start": 732,
                    "end": 733
                },
                "control_flow": [
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 729,
                        "end_line": 739
                    },
                    {
                        "type": "if_statement",
                        "statement": "if isinstance(payload, types.GeneratorType):",
                        "start_line": 730,
                        "end_line": 733
                    },
                    {
                        "type": "for_statement",
                        "statement": "for x in payload:",
                        "start_line": 731,
                        "end_line": 732
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Boss",
                        "signature": "class Boss:",
                        "at_line": 315
                    },
                    {
                        "type": "function",
                        "name": "call_remote_control",
                        "signature": "def call_remote_control(self, active_window: Optional[Window], args: Tuple[str, ...])->'ResponseType':",
                        "at_line": 710
                    },
                    {
                        "type": "call",
                        "name": "c.response_from_kitty",
                        "signature": "c.response_from_kitty(self, active_window, PayloadGetter(c, x if isinstance(x, dict) else {}))",
                        "at_line": 732,
                        "argument": "self"
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: kitty/boss.py\nCode:\n           class Boss:\n               ...\n               def call_remote_control(self, active_window: Optional[Window], args: Tuple[str, ...])->'ResponseType':\n                   ...\n729 729            try:\n730 730                if isinstance(payload, types.GeneratorType):\n731 731                    for x in payload:\n732      -                     c.response_from_kitty(self, active_window, PayloadGetter(c, x if isinstance(x, dict) else {}))\n    732  +                     c.response_from_kitty(self, self_window, PayloadGetter(c, x if isinstance(x, dict) else {}))\n733 733                    return None\n         ...\n",
                "file_path": "kitty/boss.py",
                "identifiers_before": [
                    "PayloadGetter",
                    "active_window",
                    "c",
                    "dict",
                    "isinstance",
                    "response_from_kitty",
                    "self",
                    "x"
                ],
                "identifiers_after": [
                    "PayloadGetter",
                    "c",
                    "dict",
                    "isinstance",
                    "response_from_kitty",
                    "self",
                    "self_window",
                    "x"
                ],
                "prefix": [
                    "        try:\n",
                    "            if isinstance(payload, types.GeneratorType):\n",
                    "                for x in payload:\n"
                ],
                "suffix": [
                    "                return None\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "active_window",
                            "position": {
                                "start": {
                                    "line": 732,
                                    "column": 48
                                },
                                "end": {
                                    "line": 732,
                                    "column": 61
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 732,
                                    "column": 42
                                },
                                "end": {
                                    "line": 732,
                                    "column": 46
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "self_window",
                            "position": {
                                "start": {
                                    "line": 732,
                                    "column": 48
                                },
                                "end": {
                                    "line": 732,
                                    "column": 59
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 732,
                                    "column": 42
                                },
                                "end": {
                                    "line": 732,
                                    "column": 46
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    0,
                    1,
                    3
                ]
            },
            [
                "                return None\n"
            ],
            {
                "type": "replace",
                "before": [
                    "            return c.response_from_kitty(self, active_window, PayloadGetter(c, payload if isinstance(payload, dict) else {}))\n"
                ],
                "after": [
                    "            return c.response_from_kitty(self, self_window, PayloadGetter(c, payload if isinstance(payload, dict) else {}))\n"
                ],
                "parent_version_range": {
                    "start": 734,
                    "end": 735
                },
                "child_version_range": {
                    "start": 734,
                    "end": 735
                },
                "control_flow": [
                    {
                        "type": "try_statement",
                        "statement": "try:",
                        "start_line": 729,
                        "end_line": 739
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Boss",
                        "signature": "class Boss:",
                        "at_line": 315
                    },
                    {
                        "type": "function",
                        "name": "call_remote_control",
                        "signature": "def call_remote_control(self, active_window: Optional[Window], args: Tuple[str, ...])->'ResponseType':",
                        "at_line": 710
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: kitty/boss.py\nCode:\n           class Boss:\n               ...\n               def call_remote_control(self, active_window: Optional[Window], args: Tuple[str, ...])->'ResponseType':\n                   ...\n733 733                    return None\n734      -             return c.response_from_kitty(self, active_window, PayloadGetter(c, payload if isinstance(payload, dict) else {}))\n    734  +             return c.response_from_kitty(self, self_window, PayloadGetter(c, payload if isinstance(payload, dict) else {}))\n735 735            except Exception as e:\n736 736                if silent:\n737 737                    log_error(f'Failed to run remote_control mapping: {aa} with error: {e}')\n         ...\n",
                "file_path": "kitty/boss.py",
                "identifiers_before": [
                    "PayloadGetter",
                    "active_window",
                    "c",
                    "dict",
                    "isinstance",
                    "payload",
                    "response_from_kitty",
                    "self"
                ],
                "identifiers_after": [
                    "PayloadGetter",
                    "c",
                    "dict",
                    "isinstance",
                    "payload",
                    "response_from_kitty",
                    "self",
                    "self_window"
                ],
                "prefix": [
                    "                return None\n"
                ],
                "suffix": [
                    "        except Exception as e:\n",
                    "            if silent:\n",
                    "                log_error(f'Failed to run remote_control mapping: {aa} with error: {e}')\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "active_window",
                            "position": {
                                "start": {
                                    "line": 734,
                                    "column": 47
                                },
                                "end": {
                                    "line": 734,
                                    "column": 60
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 734,
                                    "column": 41
                                },
                                "end": {
                                    "line": 734,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "self_window",
                            "position": {
                                "start": {
                                    "line": 734,
                                    "column": 47
                                },
                                "end": {
                                    "line": 734,
                                    "column": 58
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 734,
                                    "column": 41
                                },
                                "end": {
                                    "line": 734,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/kitty/kitty/boss.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": [
                    0,
                    1,
                    2
                ]
            },
            [
                "        except Exception as e:\n",
                "            if silent:\n",
                "                log_error(f'Failed to run remote_control mapping: {aa} with error: {e}')\n",
                "                return None\n",
                "            raise\n",
                "\n",
                "    def peer_message_received(self, msg_bytes: bytes, peer_id: int) -> Union[bytes, bool, None]:\n",
                "        cmd_prefix = b'\\x1bP@kitty-cmd'\n",
                "        terminator = b'\\x1b\\\\'\n",
                "        if msg_bytes.startswith(cmd_prefix) and msg_bytes.endswith(terminator):\n",
                "            cmd = msg_bytes[len(cmd_prefix):-len(terminator)].decode('utf-8')\n",
                "            response = self._handle_remote_command(cmd, peer_id=peer_id)\n",
                "            if response is None:\n",
                "                return None\n",
                "            if isinstance(response, AsyncResponse):\n",
                "                return True\n",
                "            from kitty.remote_control import encode_response_for_peer\n",
                "            return encode_response_for_peer(response)\n",
                "\n",
                "        data:SingleInstanceData = json.loads(msg_bytes.decode('utf-8'))\n",
                "        if isinstance(data, dict) and data.get('cmd') == 'new_instance':\n",
                "            from .cli_stub import CLIOptions\n",
                "            startup_id = data['environ'].get('DESKTOP_STARTUP_ID', '')\n",
                "            activation_token = data['environ'].get('XDG_ACTIVATION_TOKEN', '')\n",
                "            args, rest = parse_args(list(data['args'][1:]), result_class=CLIOptions)\n",
                "            cmdline_args_for_open = data.get('cmdline_args_for_open')\n",
                "            if cmdline_args_for_open:\n",
                "                self.launch_urls(*cmdline_args_for_open, no_replace_window=True)\n",
                "                return None\n",
                "            args.args = rest\n",
                "            opts = create_opts(args)\n",
                "            if data['session_data']:\n",
                "                if data['session_data'] == 'none':\n",
                "                    args.session = 'none'\n",
                "                else:\n",
                "                    from .session import PreReadSession\n",
                "                    args.session = PreReadSession(data['session_data'], data['environ'])\n",
                "            else:\n",
                "                args.session = ''\n",
                "            if not os.path.isabs(args.directory):\n",
                "                args.directory = os.path.join(data['cwd'], args.directory)\n",
                "            focused_os_window = os_window_id = 0\n",
                "            for session in create_sessions(opts, args, respect_cwd=True):\n",
                "                os_window_id = self.add_os_window(\n",
                "                    session, wclass=args.cls, wname=args.name, opts_for_size=opts, startup_id=startup_id,\n",
                "                    override_title=args.title or None)\n",
                "                if session.focus_os_window:\n",
                "                    focused_os_window = os_window_id\n",
                "                if opts.background_opacity != get_options().background_opacity:\n",
                "                    self._set_os_window_background_opacity(os_window_id, opts.background_opacity)\n",
                "                if data.get('notify_on_os_window_death'):\n",
                "                    self.os_window_death_actions[os_window_id] = partial(self.notify_on_os_window_death, data['notify_on_os_window_death'])\n",
                "            if focused_os_window > 0:\n",
                "                focus_os_window(focused_os_window, True, activation_token)\n",
                "            elif activation_token and is_wayland() and os_window_id:\n",
                "                focus_os_window(os_window_id, True, activation_token)\n",
                "        else:\n",
                "            log_error('Unknown message received from peer, ignoring')\n",
                "        return None\n",
                "\n",
                "    def handle_remote_cmd(self, cmd: str, window: Optional[Window] = None) -> None:\n",
                "        response = self._handle_remote_command(cmd, window)\n",
                "        if response is not None and not isinstance(response, AsyncResponse) and window is not None:\n",
                "            window.send_cmd_response(response)\n",
                "\n",
                "    def mark_os_window_for_close(self, os_window_id: int, request_type: int = IMPERATIVE_CLOSE_REQUESTED) -> None:\n",
                "        if self.current_visual_select is not None and self.current_visual_select.os_window_id == os_window_id and request_type == IMPERATIVE_CLOSE_REQUESTED:\n",
                "            self.cancel_current_visual_select()\n",
                "        mark_os_window_for_close(os_window_id, request_type)\n",
                "\n",
                "    def _cleanup_tab_after_window_removal(self, src_tab: Tab) -> None:\n",
                "        if len(src_tab) < 1:\n",
                "            tm = src_tab.tab_manager_ref()\n",
                "            if tm is not None:\n",
                "                tm.remove(src_tab)\n",
                "                src_tab.destroy()\n",
                "                if len(tm) == 0:\n",
                "                    if not self.shutting_down:\n",
                "                        self.mark_os_window_for_close(src_tab.os_window_id)\n",
                "\n",
                "    @contextmanager\n",
                "    def suppress_focus_change_events(self) -> Generator[None, None, None]:\n",
                "        changes = {}\n",
                "        for w in self.window_id_map.values():\n",
                "            changes[w] = w.ignore_focus_changes\n",
                "            w.ignore_focus_changes = True\n",
                "        try:\n",
                "            yield\n",
                "        finally:\n",
                "            for w, val in changes.items():\n",
                "                w.ignore_focus_changes = val\n",
                "\n",
                "    def on_child_death(self, window_id: int) -> None:\n",
                "        prev_active_window = self.active_window\n",
                "        window = self.window_id_map.pop(window_id, None)\n",
                "        if window is None:\n",
                "            return\n",
                "        with self.suppress_focus_change_events():\n",
                "            for close_action in window.actions_on_close:\n",
                "                try:\n",
                "                    close_action(window)\n",
                "                except Exception:\n",
                "                    import traceback\n",
                "                    traceback.print_exc()\n",
                "            os_window_id = window.os_window_id\n",
                "            window.destroy()\n",
                "            tm = self.os_window_map.get(os_window_id)\n",
                "            tab = None\n",
                "            if tm is not None:\n",
                "                for q in tm:\n",
                "                    if window in q:\n",
                "                        tab = q\n",
                "                        break\n",
                "            if tab is not None:\n",
                "                tab.remove_window(window)\n",
                "                self._cleanup_tab_after_window_removal(tab)\n",
                "            for removal_action in window.actions_on_removal:\n",
                "                try:\n",
                "                    removal_action(window)\n",
                "                except Exception:\n",
                "                    import traceback\n",
                "                    traceback.print_exc()\n",
                "            del window.actions_on_close[:], window.actions_on_removal[:]\n",
                "\n",
                "        window = self.active_window\n",
                "        if window is not prev_active_window:\n",
                "            if prev_active_window is not None:\n",
                "                prev_active_window.focus_changed(False)\n",
                "            if window is not None:\n",
                "                window.focus_changed(True)\n",
                "\n",
                "    def mark_window_for_close(self, q: Union[Window, None, int] = None) -> None:\n",
                "        if isinstance(q, int):\n",
                "            window = self.window_id_map.get(q)\n",
                "            if window is None:\n",
                "                return\n",
                "        else:\n",
                "            window = q or self.active_window\n",
                "        if window:\n",
                "            self.child_monitor.mark_for_close(window.id)\n",
                "\n",
                "    @ac('win', 'Close the currently active window')\n",
                "    def close_window(self) -> None:\n",
                "        self.mark_window_for_close()\n",
                "\n",
                "    @ac('win', '''\n",
                "    Close window with confirmation\n",
                "\n",
                "    Asks for confirmation before closing the window. If you don't want the\n",
                "    confirmation when the window is sitting at a shell prompt\n",
                "    (requires :ref:`shell_integration`), use::\n",
                "\n",
                "        map f1 close_window_with_confirmation ignore-shell\n",
                "    ''')\n",
                "    def close_window_with_confirmation(self, ignore_shell: bool = False) -> None:\n",
                "        window = self.active_window\n",
                "        if window is None:\n",
                "            return\n",
                "        if not ignore_shell or window.has_running_program:\n",
                "            msg = _('Are you sure you want to close this window?')\n",
                "            if window.has_running_program:\n",
                "                msg += ' ' + _('It is running a program.')\n",
                "            self.confirm(msg, self.handle_close_window_confirmation, window.id, window=window)\n",
                "        else:\n",
                "            self.mark_window_for_close(window)\n",
                "\n",
                "    def handle_close_window_confirmation(self, allowed: bool, window_id: int) -> None:\n",
                "        if allowed:\n",
                "            self.mark_window_for_close(window_id)\n",
                "\n",
                "    @ac('tab', 'Close the current tab')\n",
                "    def close_tab(self, tab: Optional[Tab] = None) -> None:\n",
                "        tab = tab or self.active_tab\n",
                "        if tab:\n",
                "            self.confirm_tab_close(tab)\n",
                "\n",
                "    @ac('tab', 'Close all the tabs in the current OS window other than the currently active tab')\n",
                "    def close_other_tabs_in_os_window(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None and len(tm.tabs) > 1:\n",
                "            active_tab = self.active_tab\n",
                "            for tab in tm:\n",
                "                if tab is not active_tab:\n",
                "                    self.close_tab(tab)\n",
                "\n",
                "    def confirm(\n",
                "        self, msg: str,  # can contain newlines and ANSI formatting\n",
                "        callback: Callable[..., None],  # called with True or False and *args\n",
                "        *args: Any,  # passed to the callback function\n",
                "        window: Optional[Window] = None,  # the window associated with the confirmation\n",
                "        confirm_on_cancel: bool = False,  # on closing window\n",
                "        confirm_on_accept: bool = True,  # on pressing enter\n",
                "    ) -> None:\n",
                "        result: bool = False\n",
                "\n",
                "        def callback_(res: Dict[str, Any], x: int, boss: Boss) -> None:\n",
                "            nonlocal result\n",
                "            result = res.get('response') == 'y'\n",
                "\n",
                "        def on_popup_overlay_removal(wid: int, boss: Boss) -> None:\n",
                "            callback(result, *args)\n",
                "\n",
                "        self.run_kitten_with_metadata(\n",
                "            'ask', ['--type=yesno', '--message', msg, '--default', 'y' if confirm_on_accept else 'n'],\n",
                "            window=window, custom_callback=callback_, action_on_removal=on_popup_overlay_removal,\n",
                "            default_data={'response': 'y' if confirm_on_cancel else 'n'})\n",
                "\n",
                "    def choose(\n",
                "        self, msg: str,  # can contain newlines and ANSI formatting\n",
                "        callback: Callable[..., None],  # called with the choice or empty string when aborted\n",
                "        *choices: str,   # The choices, see the help for the ask kitten for format of a choice\n",
                "        window: Optional[Window] = None,  # the window associated with the confirmation\n",
                "        default: str = '',  # the default choice when the user presses Enter\n",
                "        hidden_text: str = '',  # text to hide in the message\n",
                "        hidden_text_placeholder: str = 'HIDDEN_TEXT_PLACEHOLDER',  # placeholder text to insert in to message\n",
                "        unhide_key: str = 'u',  # key to press to unhide hidden text\n",
                "    ) -> Optional[Window]:\n",
                "        result: str = ''\n",
                "\n",
                "        def callback_(res: Dict[str, Any], x: int, boss: Boss) -> None:\n",
                "            nonlocal result\n",
                "            result = res.get('response') or ''\n",
                "\n",
                "        if hidden_text:\n",
                "            msg = msg.replace(hidden_text, hidden_text_placeholder)\n",
                "        cmd = ['--type=choices', '--message', msg]\n",
                "        if default:\n",
                "            cmd += ['-d', default]\n",
                "        for c in choices:\n",
                "            cmd += ['-c', c]\n",
                "        if hidden_text:\n",
                "            cmd += ['--hidden-text-placeholder', hidden_text_placeholder, '--unhide-key', unhide_key]\n",
                "            input_data = hidden_text\n",
                "        else:\n",
                "            input_data = None\n",
                "\n",
                "        def on_popup_overlay_removal(wid: int, boss: Boss) -> None:\n",
                "            callback(result)\n",
                "\n",
                "        ans = self.run_kitten_with_metadata(\n",
                "            'ask', cmd, window=window, custom_callback=callback_, input_data=input_data, default_data={'response': ''},\n",
                "            action_on_removal=on_popup_overlay_removal\n",
                "        )\n",
                "        if isinstance(ans, Window):\n",
                "            return ans\n",
                "        return None\n",
                "\n",
                "    def get_line(\n",
                "        self, msg: str,  # can contain newlines and ANSI formatting\n",
                "        callback: Callable[..., None],  # called with the answer or empty string when aborted\n",
                "        window: Optional[Window] = None,  # the window associated with the confirmation\n",
                "        prompt: str = '> ',\n",
                "        is_password: bool = False\n",
                "    ) -> None:\n",
                "        result: str = ''\n",
                "\n",
                "        def callback_(res: Dict[str, Any], x: int, boss: Boss) -> None:\n",
                "            nonlocal result\n",
                "            result = res.get('response') or ''\n",
                "\n",
                "        def on_popup_overlay_removal(wid: int, boss: Boss) -> None:\n",
                "            callback(result)\n",
                "\n",
                "        cmd = ['--type', 'password' if is_password else 'line', '--message', msg, '--prompt', prompt]\n",
                "        self.run_kitten_with_metadata(\n",
                "            'ask', cmd, window=window, custom_callback=callback_, default_data={'response': ''}, action_on_removal=on_popup_overlay_removal\n",
                "        )\n",
                "\n",
                "    def confirm_tab_close(self, tab: Tab) -> None:\n",
                "        x = get_options().confirm_os_window_close\n",
                "        num = tab.number_of_windows_with_running_programs if x < 0 else len(tab)\n",
                "        needs_confirmation = x != 0 and num >= abs(x)\n",
                "        if not needs_confirmation:\n",
                "            self.close_tab_no_confirm(tab)\n",
                "            return\n",
                "        if tab is not self.active_tab:\n",
                "            tm = tab.tab_manager_ref()\n",
                "            if tm is not None:\n",
                "                tm.set_active_tab(tab)\n",
                "        self.confirm(ngettext('Are you sure you want to close this tab, it has one window running?',\n",
                "                              'Are you sure you want to close this tab, it has {} windows running?', num).format(num),\n",
                "            self.handle_close_tab_confirmation, tab.id,\n",
                "            window=tab.active_window,\n",
                "        )\n",
                "\n",
                "    def handle_close_tab_confirmation(self, confirmed: bool, tab_id: int) -> None:\n",
                "        if not confirmed:\n",
                "            return\n",
                "        for tab in self.all_tabs:\n",
                "            if tab.id == tab_id:\n",
                "                break\n",
                "        else:\n",
                "            return\n",
                "        self.close_tab_no_confirm(tab)\n",
                "\n",
                "    def close_tab_no_confirm(self, tab: Tab) -> None:\n",
                "        if self.current_visual_select is not None and self.current_visual_select.tab_id == tab.id:\n",
                "            self.cancel_current_visual_select()\n",
                "        for window in tab:\n",
                "            self.mark_window_for_close(window)\n",
                "\n",
                "    @ac('win', 'Toggle the fullscreen status of the active OS Window')\n",
                "    def toggle_fullscreen(self, os_window_id: int = 0) -> None:\n",
                "        toggle_fullscreen(os_window_id)\n",
                "\n",
                "    @ac('win', 'Toggle the maximized status of the active OS Window')\n",
                "    def toggle_maximized(self, os_window_id: int = 0) -> None:\n",
                "        toggle_maximized(os_window_id)\n",
                "\n",
                "    @ac('misc', 'Toggle macOS secure keyboard entry')\n",
                "    def toggle_macos_secure_keyboard_entry(self) -> None:\n",
                "        toggle_secure_input()\n",
                "\n",
                "    @ac('misc', 'Hide macOS kitty application')\n",
                "    def hide_macos_app(self) -> None:\n",
                "        cocoa_hide_app()\n",
                "\n",
                "    @ac('misc', 'Hide macOS other applications')\n",
                "    def hide_macos_other_apps(self) -> None:\n",
                "        cocoa_hide_other_apps()\n",
                "\n",
                "    @ac('misc', 'Minimize macOS window')\n",
                "    def minimize_macos_window(self) -> None:\n",
                "        osw_id = current_os_window()\n",
                "        if osw_id is not None:\n",
                "            cocoa_minimize_os_window(osw_id)\n",
                "\n",
                "    def start(self, first_os_window_id: int, startup_sessions: Iterable[Session]) -> None:\n",
                "        if not getattr(self, 'io_thread_started', False):\n",
                "            self.child_monitor.start()\n",
                "            self.io_thread_started = True\n",
                "            for signum in self.child_monitor.handled_signals():\n",
                "                handled_signals.add(signum)\n",
                "            urls: List[str] = getattr(sys, 'cmdline_args_for_open', [])\n",
                "            if urls:\n",
                "                delattr(sys, 'cmdline_args_for_open')\n",
                "                sess = create_sessions(get_options(), self.args, special_window=SpecialWindow([kitty_exe(), '+runpy', 'input()']))\n",
                "                self.startup_first_child(first_os_window_id, startup_sessions=tuple(sess))\n",
                "                self.launch_urls(*urls)\n",
                "            else:\n",
                "                self.startup_first_child(first_os_window_id, startup_sessions=startup_sessions)\n",
                "\n",
                "        if get_options().update_check_interval > 0 and not self.update_check_started and getattr(sys, 'frozen', False):\n",
                "            from .update_check import run_update_check\n",
                "            run_update_check(get_options().update_check_interval * 60 * 60)\n",
                "            self.update_check_started = True\n",
                "\n",
                "    def handle_click_on_tab(self, os_window_id: int, x: int, button: int, modifiers: int, action: int) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            tm.handle_click_on_tab(x, button, modifiers, action)\n",
                "\n",
                "    def on_window_resize(self, os_window_id: int, w: int, h: int, dpi_changed: bool) -> None:\n",
                "        if dpi_changed:\n",
                "            self.on_dpi_change(os_window_id)\n",
                "        else:\n",
                "            tm = self.os_window_map.get(os_window_id)\n",
                "            if tm is not None:\n",
                "                tm.resize()\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Clear the terminal\n",
                "\n",
                "        See :sc:`reset_terminal <reset_terminal>` for details. For example::\n",
                "\n",
                "            # Reset the terminal\n",
                "            map f1 clear_terminal reset active\n",
                "            # Clear the terminal screen by erasing all contents\n",
                "            map f1 clear_terminal clear active\n",
                "            # Clear the terminal scrollback by erasing it\n",
                "            map f1 clear_terminal scrollback active\n",
                "            # Scroll the contents of the screen into the scrollback\n",
                "            map f1 clear_terminal scroll active\n",
                "            # Clear everything up to the line with the cursor\n",
                "            map f1 clear_terminal to_cursor active\n",
                "        ''')\n",
                "    def clear_terminal(self, action: str, only_active: bool) -> None:\n",
                "        if only_active:\n",
                "            windows = []\n",
                "            w = self.active_window\n",
                "            if w is not None:\n",
                "                windows.append(w)\n",
                "        else:\n",
                "            windows = list(self.all_windows)\n",
                "        if action == 'reset':\n",
                "            for w in windows:\n",
                "                w.clear_screen(reset=True, scrollback=True)\n",
                "        elif action == 'scrollback':\n",
                "            for w in windows:\n",
                "                w.clear_screen(scrollback=True)\n",
                "        elif action == 'clear':\n",
                "            for w in windows:\n",
                "                w.clear_screen()\n",
                "        elif action == 'scroll':\n",
                "            for w in windows:\n",
                "                w.scroll_prompt_to_top()\n",
                "        elif action == 'to_cursor':\n",
                "            for w in windows:\n",
                "                w.scroll_prompt_to_top(clear_scrollback=True)\n",
                "\n",
                "    def increase_font_size(self) -> None:  # legacy\n",
                "        cfs = global_font_size()\n",
                "        self.set_font_size(min(get_options().font_size * 5, cfs + 2.0))\n",
                "\n",
                "    def decrease_font_size(self) -> None:  # legacy\n",
                "        cfs = global_font_size()\n",
                "        self.set_font_size(max(MINIMUM_FONT_SIZE, cfs - 2.0))\n",
                "\n",
                "    def restore_font_size(self) -> None:  # legacy\n",
                "        self.set_font_size(get_options().font_size)\n",
                "\n",
                "    def set_font_size(self, new_size: float) -> None:  # legacy\n",
                "        self.change_font_size(True, None, new_size)\n",
                "\n",
                "    @ac('win', '''\n",
                "        Change the font size for the current or all OS Windows\n",
                "\n",
                "        See :ref:`conf-kitty-shortcuts.fonts` for details.\n",
                "        ''')\n",
                "    def change_font_size(self, all_windows: bool, increment_operation: Optional[str], amt: float) -> None:\n",
                "        def calc_new_size(old_size: float) -> float:\n",
                "            new_size = old_size\n",
                "            if amt == 0:\n",
                "                new_size = get_options().font_size\n",
                "            else:\n",
                "                if increment_operation:\n",
                "                    new_size += (1 if increment_operation == '+' else -1) * amt\n",
                "                else:\n",
                "                    new_size = amt\n",
                "                new_size = max(MINIMUM_FONT_SIZE, min(new_size, get_options().font_size * 5))\n",
                "            return new_size\n",
                "\n",
                "        if all_windows:\n",
                "            current_global_size = global_font_size()\n",
                "            new_size = calc_new_size(current_global_size)\n",
                "            if new_size != current_global_size:\n",
                "                global_font_size(new_size)\n",
                "            os_windows = list(self.os_window_map.keys())\n",
                "        else:\n",
                "            os_windows = []\n",
                "            w = self.active_window\n",
                "            if w is not None:\n",
                "                os_windows.append(w.os_window_id)\n",
                "        if os_windows:\n",
                "            final_windows = {}\n",
                "            for wid in os_windows:\n",
                "                current_size = os_window_font_size(wid)\n",
                "                if current_size:\n",
                "                    new_size = calc_new_size(current_size)\n",
                "                    if new_size != current_size:\n",
                "                        final_windows[wid] = new_size\n",
                "            if final_windows:\n",
                "                self._change_font_size(final_windows)\n",
                "\n",
                "    def _change_font_size(self, sz_map: Dict[int, float]) -> None:\n",
                "        for os_window_id, sz in sz_map.items():\n",
                "            tm = self.os_window_map.get(os_window_id)\n",
                "            if tm is not None:\n",
                "                os_window_font_size(os_window_id, sz)\n",
                "                tm.resize()\n",
                "\n",
                "    def on_dpi_change(self, os_window_id: int) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            sz = os_window_font_size(os_window_id)\n",
                "            if sz:\n",
                "                os_window_font_size(os_window_id, sz, True)\n",
                "                for tab in tm:\n",
                "                    for window in tab:\n",
                "                        window.on_dpi_change(sz)\n",
                "                tm.resize()\n",
                "\n",
                "    def _set_os_window_background_opacity(self, os_window_id: int, opacity: float) -> None:\n",
                "        change_background_opacity(os_window_id, max(0.1, min(opacity, 1.0)))\n",
                "\n",
                "    @ac('win', '''\n",
                "        Set the background opacity for the active OS Window\n",
                "\n",
                "        For example::\n",
                "\n",
                "            map f1 set_background_opacity +0.1\n",
                "            map f2 set_background_opacity -0.1\n",
                "            map f3 set_background_opacity 0.5\n",
                "        ''')\n",
                "    def set_background_opacity(self, opacity: str) -> None:\n",
                "        window = self.active_window\n",
                "        if window is None or not opacity:\n",
                "            return\n",
                "        if not get_options().dynamic_background_opacity:\n",
                "            self.show_error(\n",
                "                    _('Cannot change background opacity'),\n",
                "                    _('You must set the dynamic_background_opacity option in kitty.conf to be able to change background opacity'))\n",
                "            return\n",
                "        os_window_id = window.os_window_id\n",
                "        if opacity[0] in '+-':\n",
                "            old_opacity = background_opacity_of(os_window_id)\n",
                "            if old_opacity is None:\n",
                "                return\n",
                "            fin_opacity = old_opacity + float(opacity)\n",
                "        elif opacity == 'default':\n",
                "            fin_opacity = get_options().background_opacity\n",
                "        else:\n",
                "            fin_opacity = float(opacity)\n",
                "        self._set_os_window_background_opacity(os_window_id, fin_opacity)\n",
                "\n",
                "    @property\n",
                "    def active_tab_manager(self) -> Optional[TabManager]:\n",
                "        os_window_id = current_focused_os_window_id()\n",
                "        if os_window_id <= 0:\n",
                "            os_window_id = last_focused_os_window_id()\n",
                "        if os_window_id <= 0:\n",
                "            q = current_os_window()\n",
                "            if q is not None:\n",
                "                os_window_id = q\n",
                "        return self.os_window_map.get(os_window_id)\n",
                "\n",
                "    @property\n",
                "    def active_tab(self) -> Optional[Tab]:\n",
                "        tm = self.active_tab_manager\n",
                "        return None if tm is None else tm.active_tab\n",
                "\n",
                "    @property\n",
                "    def active_window(self) -> Optional[Window]:\n",
                "        t = self.active_tab\n",
                "        return None if t is None else t.active_window\n",
                "\n",
                "    def set_pending_sequences(self, sequences: SubSequenceMap, default_pending_action: str = '') -> None:\n",
                "        self.pending_sequences = sequences\n",
                "        self.default_pending_action = default_pending_action\n",
                "        set_in_sequence_mode(True)\n",
                "\n",
                "    def dispatch_possible_special_key(self, ev: KeyEvent) -> bool:\n",
                "        # Handles shortcuts, return True if the key was consumed\n",
                "        key_action = get_shortcut(self.keymap, ev)\n",
                "        if key_action is None:\n",
                "            sequences = get_shortcut(get_options().sequence_map, ev)\n",
                "            if sequences and not isinstance(sequences, str):\n",
                "                self.set_pending_sequences(sequences)\n",
                "                self.current_sequence = [ev]\n",
                "                return True\n",
                "            if self.global_shortcuts_map and get_shortcut(self.global_shortcuts_map, ev):\n",
                "                return True\n",
                "        elif isinstance(key_action, str):\n",
                "            return self.combine(key_action)\n",
                "        return False\n",
                "\n",
                "    def clear_pending_sequences(self) -> None:\n",
                "        self.pending_sequences = None\n",
                "        self.current_sequence = []\n",
                "        self.default_pending_action = ''\n",
                "        set_in_sequence_mode(False)\n",
                "\n",
                "    def process_sequence(self, ev: KeyEvent) -> bool:\n",
                "        # Process an event as part of a sequence. Returns whether the key\n",
                "        # is consumed as part of a kitty sequence keybinding.\n",
                "        if not self.pending_sequences:\n",
                "            set_in_sequence_mode(False)\n",
                "            return False\n",
                "\n",
                "        if self.current_sequence:\n",
                "            self.current_sequence.append(ev)\n",
                "        if ev.action == GLFW_RELEASE or is_modifier_key(ev.key):\n",
                "            return True\n",
                "        # For a press/repeat event that's not a modifier, try matching with\n",
                "        # kitty bindings:\n",
                "        remaining = {}\n",
                "        matched_action = None\n",
                "        for seq, key_action in self.pending_sequences.items():\n",
                "            if shortcut_matches(seq[0], ev):\n",
                "                seq = seq[1:]\n",
                "                if seq:\n",
                "                    remaining[seq] = key_action\n",
                "                else:\n",
                "                    matched_action = key_action\n",
                "\n",
                "        if remaining:\n",
                "            self.pending_sequences = remaining\n",
                "            return True\n",
                "        matched_action = matched_action or self.default_pending_action\n",
                "        if matched_action:\n",
                "            self.clear_pending_sequences()\n",
                "            self.combine(matched_action)\n",
                "            return True\n",
                "        w = self.active_window\n",
                "        if w is not None:\n",
                "            w.write_to_child(b''.join(w.encoded_key(ev) for ev in self.current_sequence))\n",
                "        self.clear_pending_sequences()\n",
                "        return False\n",
                "\n",
                "    def cancel_current_visual_select(self) -> None:\n",
                "        if self.current_visual_select:\n",
                "            self.current_visual_select.cancel()\n",
                "            self.current_visual_select = None\n",
                "\n",
                "    def visual_window_select_action(\n",
                "        self, tab: Tab,\n",
                "        callback: Callable[[Optional[Tab], Optional[Window]], None],\n",
                "        choose_msg: str,\n",
                "        only_window_ids: Container[int] = (),\n",
                "        reactivate_prev_tab: bool = False\n",
                "    ) -> None:\n",
                "        import string\n",
                "        self.cancel_current_visual_select()\n",
                "        initial_tab_id: Optional[int] = None\n",
                "        initial_os_window_id = current_os_window()\n",
                "        tm = tab.tab_manager_ref()\n",
                "        if tm is not None:\n",
                "            if tm.active_tab is not None:\n",
                "                initial_tab_id = tm.active_tab.id\n",
                "            tm.set_active_tab(tab)\n",
                "        if initial_os_window_id != tab.os_window_id:\n",
                "            focus_os_window(tab.os_window_id, True)\n",
                "        self.current_visual_select = VisualSelect(tab.id, tab.os_window_id, initial_tab_id, initial_os_window_id, choose_msg, callback, reactivate_prev_tab)\n",
                "        if tab.current_layout.only_active_window_visible:\n",
                "            w = self.select_window_in_tab_using_overlay(tab, choose_msg, only_window_ids)\n",
                "            self.current_visual_select.window_used_for_selection_id = 0 if w is None else w.id\n",
                "            return\n",
                "        pending_sequences: SubSequenceMap = {}\n",
                "        fmap = get_name_to_functional_number_map()\n",
                "        alphanumerics = get_options().visual_window_select_characters\n",
                "        for idx, window in tab.windows.iter_windows_with_number(only_visible=True):\n",
                "            if only_window_ids and window.id not in only_window_ids:\n",
                "                continue\n",
                "            ac = f'visual_window_select_action_trigger {window.id}'\n",
                "            if idx >= len(alphanumerics):\n",
                "                break\n",
                "            ch = alphanumerics[idx]\n",
                "            window.screen.set_window_char(ch)\n",
                "            self.current_visual_select.window_ids.append(window.id)\n",
                "            for mods in (0, GLFW_MOD_CONTROL, GLFW_MOD_CONTROL | GLFW_MOD_SHIFT, GLFW_MOD_SUPER, GLFW_MOD_ALT, GLFW_MOD_SHIFT):\n",
                "                pending_sequences[(SingleKey(mods=mods, key=ord(ch.lower())),)] = ac\n",
                "                if ch in string.digits:\n",
                "                    pending_sequences[(SingleKey(mods=mods, key=fmap[f'KP_{ch}']),)] = ac\n",
                "        if len(self.current_visual_select.window_ids) > 1:\n",
                "            self.set_pending_sequences(pending_sequences, default_pending_action='visual_window_select_action_trigger 0')\n",
                "            redirect_mouse_handling(True)\n",
                "            self.mouse_handler = self.visual_window_select_mouse_handler\n",
                "        else:\n",
                "            self.visual_window_select_action_trigger(self.current_visual_select.window_ids[0] if self.current_visual_select.window_ids else 0)\n",
                "            if get_options().enable_audio_bell:\n",
                "                ring_bell()\n",
                "\n",
                "    def visual_window_select_action_trigger(self, window_id: int = 0) -> None:\n",
                "        if self.current_visual_select:\n",
                "            self.current_visual_select.trigger(int(window_id))\n",
                "        self.current_visual_select = None\n",
                "\n",
                "    def visual_window_select_mouse_handler(self, ev: WindowSystemMouseEvent) -> None:\n",
                "        tab = self.active_tab\n",
                "        if ev.button == GLFW_MOUSE_BUTTON_LEFT and ev.action == GLFW_PRESS and ev.window_id:\n",
                "            w = self.window_id_map.get(ev.window_id)\n",
                "            if w is not None and tab is not None and w in tab:\n",
                "                if self.current_visual_select and self.current_visual_select.tab_id == tab.id:\n",
                "                    self.visual_window_select_action_trigger(w.id)\n",
                "                else:\n",
                "                    self.visual_window_select_action_trigger()\n",
                "                return\n",
                "        if ev.button > -1 and tab is not None:\n",
                "            self.visual_window_select_action_trigger()\n",
                "\n",
                "    def mouse_event(\n",
                "        self, in_tab_bar: bool, window_id: int, action: int, modifiers: int, button: int,\n",
                "        currently_pressed_button: int, x: float, y: float\n",
                "    ) -> None:\n",
                "        if self.mouse_handler is not None:\n",
                "            ev = WindowSystemMouseEvent(in_tab_bar, window_id, action, modifiers, button, currently_pressed_button, x, y)\n",
                "            self.mouse_handler(ev)\n",
                "\n",
                "    def select_window_in_tab_using_overlay(self, tab: Tab, msg: str, only_window_ids: Container[int] = ()) -> Optional[Window]:\n",
                "        windows = tuple((None, f'Current window: {w.title}' if w is self.active_window else w.title)\n",
                "                        if only_window_ids and w.id not in only_window_ids else (w.id, w.title)\n",
                "                        for i, w in tab.windows.iter_windows_with_number(only_visible=False))\n",
                "        if len(windows) < 1:\n",
                "            self.visual_window_select_action_trigger(windows[0][0] if windows and windows[0][0] is not None else 0)\n",
                "            if get_options().enable_audio_bell:\n",
                "                ring_bell()\n",
                "            return None\n",
                "        cvs = self.current_visual_select\n",
                "\n",
                "        def chosen(ans: Union[None, int, str]) -> None:\n",
                "            q = self.current_visual_select\n",
                "            self.current_visual_select = None\n",
                "            if cvs and q is cvs:\n",
                "                q.trigger(ans if isinstance(ans, int) else 0)\n",
                "\n",
                "        return self.choose_entry(msg, windows, chosen, hints_args=('--hints-offset=0', '--alphabet', get_options().visual_window_select_characters.lower()))\n",
                "\n",
                "    @ac('win', '''\n",
                "        Resize the active window interactively\n",
                "\n",
                "        See :ref:`window_resizing` for details.\n",
                "        ''')\n",
                "    def start_resizing_window(self) -> None:\n",
                "        w = self.active_window\n",
                "        if w is None:\n",
                "            return\n",
                "        overlay_window = self.run_kitten_with_metadata('resize_window', args=[\n",
                "            f'--horizontal-increment={get_options().window_resize_step_cells}',\n",
                "            f'--vertical-increment={get_options().window_resize_step_lines}'\n",
                "        ])\n",
                "        if overlay_window is not None:\n",
                "            overlay_window.allow_remote_control = True\n",
                "\n",
                "    def resize_layout_window(self, window: Window, increment: float, is_horizontal: bool, reset: bool = False) -> Union[bool, None, str]:\n",
                "        tab = window.tabref()\n",
                "        if tab is None or not increment:\n",
                "            return False\n",
                "        if reset:\n",
                "            tab.reset_window_sizes()\n",
                "            return None\n",
                "        return tab.resize_window_by(window.id, increment, is_horizontal)\n",
                "\n",
                "    def resize_os_window(self, os_window_id: int, width: int, height: int, unit: str, incremental: bool = False) -> None:\n",
                "        if not incremental and (width < 0 or height < 0):\n",
                "            return\n",
                "        metrics = get_os_window_size(os_window_id)\n",
                "        if metrics is None:\n",
                "            return\n",
                "        has_window_scaling = is_macos or is_wayland()\n",
                "        w, h = get_new_os_window_size(metrics, width, height, unit, incremental, has_window_scaling)\n",
                "        set_os_window_size(os_window_id, w, h)\n",
                "\n",
                "    def tab_for_id(self, tab_id: int) -> Optional[Tab]:\n",
                "        for tm in self.os_window_map.values():\n",
                "            tab = tm.tab_for_id(tab_id)\n",
                "            if tab is not None:\n",
                "                return tab\n",
                "        return None\n",
                "\n",
                "    def default_bg_changed_for(self, window_id: int) -> None:\n",
                "        w = self.window_id_map.get(window_id)\n",
                "        if w is not None:\n",
                "            tm = self.os_window_map.get(w.os_window_id)\n",
                "            if tm is not None:\n",
                "                tm.update_tab_bar_data()\n",
                "                tm.mark_tab_bar_dirty()\n",
                "                t = tm.tab_for_id(w.tab_id)\n",
                "                if t is not None:\n",
                "                    t.relayout_borders()\n",
                "\n",
                "    def dispatch_action(\n",
                "        self,\n",
                "        key_action: KeyAction,\n",
                "        window_for_dispatch: Optional[Window] = None,\n",
                "        dispatch_type: str = 'KeyPress'\n",
                "    ) -> bool:\n",
                "\n",
                "        def report_match(f: Callable[..., Any]) -> None:\n",
                "            if self.args.debug_keyboard:\n",
                "                prefix = '\\n' if dispatch_type == 'KeyPress' else ''\n",
                "                print(f'{prefix}\\x1b[35m{dispatch_type}\\x1b[m matched action:', func_name(f), flush=True)\n",
                "\n",
                "        if key_action is not None:\n",
                "            f = getattr(self, key_action.func, None)\n",
                "            if f is not None:\n",
                "                report_match(f)\n",
                "                passthrough = f(*key_action.args)\n",
                "                if passthrough is not True:\n",
                "                    return True\n",
                "        if window_for_dispatch is None:\n",
                "            tab = self.active_tab\n",
                "            window = self.active_window\n",
                "        else:\n",
                "            window = window_for_dispatch\n",
                "            tab = window.tabref()\n",
                "        if tab is None or window is None:\n",
                "            return False\n",
                "        if key_action is not None:\n",
                "            f = getattr(tab, key_action.func, getattr(window, key_action.func, None))\n",
                "            if f is not None:\n",
                "                passthrough = f(*key_action.args)\n",
                "                report_match(f)\n",
                "                if passthrough is not True:\n",
                "                    return True\n",
                "        return False\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Combine multiple actions and map to a single keypress\n",
                "\n",
                "        The syntax is::\n",
                "\n",
                "            map key combine <separator> action1 <separator> action2 <separator> action3 ...\n",
                "\n",
                "        For example::\n",
                "\n",
                "            map kitty_mod+e combine : new_window : next_layout\n",
                "        ''')\n",
                "    def combine(self, action_definition: str, window_for_dispatch: Optional[Window] = None, dispatch_type: str = 'KeyPress') -> bool:\n",
                "        consumed = False\n",
                "        if action_definition:\n",
                "            try:\n",
                "                actions = get_options().alias_map.resolve_aliases(action_definition, 'map' if dispatch_type == 'KeyPress' else 'mouse_map')\n",
                "            except Exception as e:\n",
                "                import traceback\n",
                "                traceback.print_exc()\n",
                "                self.show_error('Failed to parse action', f'{action_definition}\\n{e}')\n",
                "                return True\n",
                "            if actions:\n",
                "                try:\n",
                "                    if self.dispatch_action(actions[0], window_for_dispatch, dispatch_type):\n",
                "                        consumed = True\n",
                "                        if len(actions) > 1:\n",
                "                            self.drain_actions(list(actions[1:]), window_for_dispatch, dispatch_type)\n",
                "                except Exception as e:\n",
                "                    import traceback\n",
                "                    traceback.print_exc()\n",
                "                    self.show_error('Key action failed', f'{actions[0].pretty()}\\n{e}')\n",
                "                    consumed = True\n",
                "        return consumed\n",
                "\n",
                "    def on_focus(self, os_window_id: int, focused: bool) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            w = tm.active_window\n",
                "            if w is not None:\n",
                "                w.focus_changed(focused)\n",
                "                if is_macos and focused:\n",
                "                    cocoa_set_menubar_title(w.title or '')\n",
                "            tm.mark_tab_bar_dirty()\n",
                "\n",
                "    def on_activity_since_last_focus(self, window: Window) -> None:\n",
                "        os_window_id = window.os_window_id\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            tm.mark_tab_bar_dirty()\n",
                "\n",
                "    def update_tab_bar_data(self, os_window_id: int) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            tm.update_tab_bar_data()\n",
                "\n",
                "    def on_drop(self, os_window_id: int, mime: str, data: bytes) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            w = tm.active_window\n",
                "            if w is not None:\n",
                "                text = data.decode('utf-8', 'replace')\n",
                "                if mime == 'text/uri-list':\n",
                "                    urls = parse_uri_list(text)\n",
                "                    if w.at_prompt:\n",
                "                        import shlex\n",
                "                        text = ' '.join(map(shlex.quote, urls))\n",
                "                    else:\n",
                "                        text = '\\n'.join(urls)\n",
                "                w.paste_text(text)\n",
                "\n",
                "    @ac('win', 'Focus the nth OS window')\n",
                "    def nth_os_window(self, num: int = 1) -> None:\n",
                "        if self.os_window_map and num > 0:\n",
                "            ids = list(self.os_window_map.keys())\n",
                "            os_window_id = ids[min(num, len(ids)) - 1]\n",
                "            focus_os_window(os_window_id, True)\n",
                "\n",
                "    @ac('win', 'Close the currently active OS Window')\n",
                "    def close_os_window(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            self.confirm_os_window_close(tm.os_window_id)\n",
                "\n",
                "    def confirm_os_window_close(self, os_window_id: int) -> None:\n",
                "        tm = self.os_window_map.get(os_window_id)\n",
                "        q = get_options().confirm_os_window_close\n",
                "        num = 0 if tm is None else (tm.number_of_windows_with_running_programs if q < 0 else tm.number_of_windows)\n",
                "        needs_confirmation = tm is not None and q != 0 and num >= abs(q)\n",
                "        if not needs_confirmation:\n",
                "            self.mark_os_window_for_close(os_window_id)\n",
                "            return\n",
                "        if tm is not None:\n",
                "            w = tm.active_window\n",
                "            self.confirm(\n",
                "                ngettext('Are you sure you want to close this OS window, it has one window running?',\n",
                "                         'Are you sure you want to close this OS window, it has {} windows running', num).format(num),\n",
                "                self.handle_close_os_window_confirmation, os_window_id,\n",
                "                window=w,\n",
                "            )\n",
                "\n",
                "    def handle_close_os_window_confirmation(self, confirmed: bool, os_window_id: int) -> None:\n",
                "        if confirmed:\n",
                "            self.mark_os_window_for_close(os_window_id)\n",
                "        else:\n",
                "            self.mark_os_window_for_close(os_window_id, NO_CLOSE_REQUESTED)\n",
                "\n",
                "    def on_os_window_closed(self, os_window_id: int, viewport_width: int, viewport_height: int) -> None:\n",
                "        self.cached_values['window-size'] = viewport_width, viewport_height\n",
                "        tm = self.os_window_map.pop(os_window_id, None)\n",
                "        if tm is not None:\n",
                "            tm.destroy()\n",
                "        for window_id in tuple(w.id for w in self.window_id_map.values() if getattr(w, 'os_window_id', None) == os_window_id):\n",
                "            self.window_id_map.pop(window_id, None)\n",
                "        if not self.os_window_map and is_macos:\n",
                "            cocoa_set_menubar_title('')\n",
                "        action = self.os_window_death_actions.pop(os_window_id, None)\n",
                "        if action is not None:\n",
                "            action()\n",
                "\n",
                "    @ac('win', 'Quit, closing all windows')\n",
                "    def quit(self, *args: Any) -> None:\n",
                "        tm = self.active_tab\n",
                "        num = 0\n",
                "        x = get_options().confirm_os_window_close\n",
                "        for q in self.os_window_map.values():\n",
                "            num += q.number_of_windows_with_running_programs if x < 0 else q.number_of_windows\n",
                "        needs_confirmation = tm is not None and x != 0 and num >= abs(x)\n",
                "        if not needs_confirmation:\n",
                "            set_application_quit_request(IMPERATIVE_CLOSE_REQUESTED)\n",
                "            return\n",
                "        if current_application_quit_request() == CLOSE_BEING_CONFIRMED:\n",
                "            return\n",
                "        assert tm is not None\n",
                "        self.confirm(\n",
                "            ngettext('Are you sure you want to quit kitty, it has one window running?',\n",
                "                     'Are you sure you want to quit kitty, it has {} windows running?', num).format(num),\n",
                "            self.handle_quit_confirmation,\n",
                "            window=tm.active_window,\n",
                "        )\n",
                "        set_application_quit_request(CLOSE_BEING_CONFIRMED)\n",
                "\n",
                "    def handle_quit_confirmation(self, confirmed: bool) -> None:\n",
                "        set_application_quit_request(IMPERATIVE_CLOSE_REQUESTED if confirmed else NO_CLOSE_REQUESTED)\n",
                "\n",
                "    def notify_on_os_window_death(self, address: str) -> None:\n",
                "        import socket\n",
                "        s = socket.socket(family=socket.AF_UNIX)\n",
                "        with suppress(Exception):\n",
                "            s.connect(address)\n",
                "            s.sendall(b'c')\n",
                "            with suppress(OSError):\n",
                "                s.shutdown(socket.SHUT_RDWR)\n",
                "            s.close()\n",
                "\n",
                "    def display_scrollback(self, window: Window, data: Union[bytes, str], input_line_number: int = 0, title: str = '', report_cursor: bool = True) -> None:\n",
                "\n",
                "        def prepare_arg(x: str) -> str:\n",
                "            x = x.replace('INPUT_LINE_NUMBER', str(input_line_number))\n",
                "            x = x.replace('CURSOR_LINE', str(window.screen.cursor.y + 1) if report_cursor else '0')\n",
                "            x = x.replace('CURSOR_COLUMN', str(window.screen.cursor.x + 1) if report_cursor else '0')\n",
                "            return x\n",
                "\n",
                "        cmd = list(map(prepare_arg, get_options().scrollback_pager))\n",
                "        if not os.path.isabs(cmd[0]):\n",
                "            cmd[0] = which(cmd[0]) or cmd[0]\n",
                "\n",
                "        if os.path.basename(cmd[0]) == 'less':\n",
                "            cmd.append('-+F')  # reset --quit-if-one-screen\n",
                "        tab = self.active_tab\n",
                "        if tab is not None:\n",
                "            bdata = data.encode('utf-8') if isinstance(data, str) else data\n",
                "            if is_macos and cmd[0] == '/usr/bin/less' and macos_version()[:2] < (12, 3):\n",
                "                # the system less before macOS 12.3 barfs up OSC codes, so sanitize them ourselves\n",
                "                sentinel = os.path.join(cache_dir(), 'less-is-new-enough')\n",
                "                if not os.path.exists(sentinel):\n",
                "                    if less_version(cmd[0]) >= 581:\n",
                "                        open(sentinel, 'w').close()\n",
                "                    else:\n",
                "                        bdata = re.sub(br'\\x1b\\].*?\\x1b\\\\', b'', bdata)\n",
                "\n",
                "            tab.new_special_window(\n",
                "                SpecialWindow(cmd, bdata, title or _('History'), overlay_for=window.id, cwd=window.cwd_of_child),\n",
                "                copy_colors_from=self.active_window\n",
                "                )\n",
                "\n",
                "    @ac('misc', 'Edit the kitty.conf config file in your favorite text editor')\n",
                "    def edit_config_file(self, *a: Any) -> None:\n",
                "        confpath = prepare_config_file_for_editing()\n",
                "        cmd = [kitty_exe(), '+edit'] + get_editor(get_options()) + [confpath]\n",
                "        self.new_os_window(*cmd)\n",
                "\n",
                "    def run_kitten_with_metadata(\n",
                "        self,\n",
                "        kitten: str,\n",
                "        args: Iterable[str] = (),\n",
                "        input_data: Optional[Union[bytes, str]] = None,\n",
                "        window: Optional[Window] = None,\n",
                "        custom_callback: Optional[Callable[[Dict[str, Any], int, 'Boss'], None]] = None,\n",
                "        action_on_removal: Optional[Callable[[int, 'Boss'], None]] = None,\n",
                "        default_data: Optional[Dict[str, Any]] = None\n",
                "    ) -> Any:\n",
                "        orig_args, args = list(args), list(args)\n",
                "        from kittens.runner import create_kitten_handler\n",
                "        end_kitten = create_kitten_handler(kitten, orig_args)\n",
                "        is_wrapped = kitten in wrapped_kitten_names()\n",
                "        if window is None:\n",
                "            w = self.active_window\n",
                "            tab = self.active_tab\n",
                "        else:\n",
                "            w = window\n",
                "            tab = w.tabref() if w else None\n",
                "        if end_kitten.no_ui:\n",
                "            return end_kitten(None, getattr(w, 'id', None), self)\n",
                "\n",
                "        if w is not None and tab is not None:\n",
                "            if not is_wrapped:\n",
                "                args[0:0] = [config_dir, kitten]\n",
                "            if input_data is None:\n",
                "                type_of_input = end_kitten.type_of_input\n",
                "                q = type_of_input.split('-') if type_of_input else []\n",
                "                if not q:\n",
                "                    data: Optional[bytes] = None\n",
                "                elif q[0] in ('text', 'history', 'ansi', 'screen'):\n",
                "                    data = w.as_text(as_ansi='ansi' in q, add_history='history' in q, add_wrap_markers='screen' in q).encode('utf-8')\n",
                "                elif type_of_input == 'selection':\n",
                "                    sel = self.data_for_at(which='@selection', window=w)\n",
                "                    data = sel.encode('utf-8') if sel else None\n",
                "                elif q[0] in ('output', 'first_output', 'last_visited_output'):\n",
                "                    which = {\n",
                "                        'output': CommandOutput.last_run, 'first_output': CommandOutput.first_on_screen,\n",
                "                        'last_visited_output': CommandOutput.last_visited}[q[0]]\n",
                "                    data = w.cmd_output(which, as_ansi='ansi' in q, add_wrap_markers='screen' in q).encode('utf-8')\n",
                "                else:\n",
                "                    raise ValueError(f'Unknown type_of_input: {type_of_input}')\n",
                "            else:\n",
                "                data = input_data if isinstance(input_data, bytes) else input_data.encode('utf-8')\n",
                "            copts = common_opts_as_dict(get_options())\n",
                "            final_args: List[str] = []\n",
                "            for x in args:\n",
                "                if x == '@selection':\n",
                "                    sel = self.data_for_at(which='@selection', window=w)\n",
                "                    if sel:\n",
                "                        x = sel\n",
                "                final_args.append(x)\n",
                "            env = {\n",
                "                'KITTY_COMMON_OPTS': json.dumps(copts),\n",
                "                'KITTY_CHILD_PID': str(w.child.pid),\n",
                "                'OVERLAID_WINDOW_LINES': str(w.screen.lines),\n",
                "                'OVERLAID_WINDOW_COLS': str(w.screen.columns),\n",
                "            }\n",
                "            if is_wrapped:\n",
                "                cmd = [kitten_exe(), kitten]\n",
                "                env['KITTEN_RUNNING_AS_UI'] = '1'\n",
                "                env['KITTY_CONFIG_DIRECTORY'] = config_dir\n",
                "            else:\n",
                "                cmd = [kitty_exe(), '+runpy', 'from kittens.runner import main; main()']\n",
                "                env['PYTHONWARNINGS'] = 'ignore'\n",
                "            overlay_window = tab.new_special_window(\n",
                "                SpecialWindow(\n",
                "                    cmd + final_args,\n",
                "                    stdin=data,\n",
                "                    env=env,\n",
                "                    cwd=w.cwd_of_child,\n",
                "                    overlay_for=w.id,\n",
                "                    overlay_behind=end_kitten.has_ready_notification,\n",
                "                ),\n",
                "                copy_colors_from=w\n",
                "            )\n",
                "            wid = w.id\n",
                "            overlay_window.actions_on_close.append(partial(self.on_kitten_finish, wid, custom_callback or end_kitten, default_data=default_data))\n",
                "            if action_on_removal is not None:\n",
                "\n",
                "                def callback_wrapper(*a: Any) -> None:\n",
                "                    if action_on_removal is not None:\n",
                "                        action_on_removal(wid, self)\n",
                "                overlay_window.actions_on_removal.append(callback_wrapper)\n",
                "            return overlay_window\n",
                "    _run_kitten = run_kitten_with_metadata\n",
                "\n",
                "    @ac('misc', 'Run the specified kitten. See :doc:`/kittens/custom` for details')\n",
                "    def kitten(self, kitten: str, *kargs: str) -> None:\n",
                "        self.run_kitten_with_metadata(kitten, kargs)\n",
                "\n",
                "    def run_kitten(self, kitten: str, *args: str) -> None:\n",
                "        self.run_kitten_with_metadata(kitten, args)\n",
                "\n",
                "    def on_kitten_finish(\n",
                "        self, target_window_id: int, end_kitten: Callable[[Dict[str, Any], int, 'Boss'], None],\n",
                "        source_window: Window,\n",
                "        default_data: Optional[Dict[str, Any]] = None\n",
                "    ) -> None:\n",
                "        data, source_window.kitten_result = source_window.kitten_result, None\n",
                "        if data is None:\n",
                "            data = default_data\n",
                "        if data is not None:\n",
                "            end_kitten(data, target_window_id, self)\n",
                "\n",
                "    @ac('misc', 'Input an arbitrary unicode character. See :doc:`/kittens/unicode_input` for details.')\n",
                "    def input_unicode_character(self) -> None:\n",
                "        self.run_kitten_with_metadata('unicode_input')\n",
                "\n",
                "    @ac(\n",
                "        'tab', '''\n",
                "        Change the title of the active tab interactively, by typing in the new title.\n",
                "        If you specify an argument to this action then that is used as the title instead of asking for it.\n",
                "        Use the empty string (\"\") to reset the title to default. Use a space (\" \") to indicate that the\n",
                "        prompt should not be pre-filled. For example::\n",
                "\n",
                "            # interactive usage\n",
                "            map f1 set_tab_title\n",
                "            # set a specific title\n",
                "            map f2 set_tab_title some title\n",
                "            # reset to default\n",
                "            map f3 set_tab_title \"\"\n",
                "            # interactive usage without prefilled prompt\n",
                "            map f3 set_tab_title \" \"\n",
                "        '''\n",
                "    )\n",
                "    def set_tab_title(self, title: Optional[str] = None) -> None:\n",
                "        tab = self.active_tab\n",
                "        if tab:\n",
                "            if title is not None and title not in ('\" \"', \"' '\"):\n",
                "                if title in ('\"\"', \"''\"):\n",
                "                    title = ''\n",
                "                tab.set_title(title)\n",
                "                return\n",
                "            prefilled = tab.name or tab.title\n",
                "            if title in ('\" \"', \"' '\"):\n",
                "                prefilled = ''\n",
                "            args = [\n",
                "                '--name=tab-title', '--message', _('Enter the new title for this tab below.'),\n",
                "                '--default', prefilled, 'do_set_tab_title', str(tab.id)]\n",
                "            self.run_kitten_with_metadata('ask', args)\n",
                "\n",
                "    def do_set_tab_title(self, title: str, tab_id: int) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tab_id = int(tab_id)\n",
                "            for tab in tm.tabs:\n",
                "                if tab.id == tab_id:\n",
                "                    tab.set_title(title)\n",
                "                    break\n",
                "\n",
                "    def show_error(self, title: str, msg: str) -> None:\n",
                "        ec = sys.exc_info()\n",
                "        tb = ''\n",
                "        if ec != (None, None, None):\n",
                "            import traceback\n",
                "            tb = traceback.format_exc()\n",
                "        self.run_kitten_with_metadata('show_error', args=['--title', title], input_data=json.dumps({'msg': msg, 'tb': tb}))\n",
                "\n",
                "    @ac('mk', 'Create a new marker')\n",
                "    def create_marker(self) -> None:\n",
                "        w = self.active_window\n",
                "        if w:\n",
                "            spec = None\n",
                "\n",
                "            def done(data: Dict[str, Any], target_window_id: int, self: Boss) -> None:\n",
                "                nonlocal spec\n",
                "                spec = data['response']\n",
                "\n",
                "            def done2(target_window_id: int, self: Boss) -> None:\n",
                "                w = self.window_id_map.get(target_window_id)\n",
                "                if w is not None and spec:\n",
                "                    try:\n",
                "                        w.set_marker(spec)\n",
                "                    except Exception as err:\n",
                "                        self.show_error(_('Invalid marker specification'), str(err))\n",
                "\n",
                "            self.run_kitten_with_metadata('ask', [\n",
                "                '--name=create-marker', '--message',\n",
                "                _('Create marker, for example:\\ntext 1 ERROR\\nSee {}\\n').format(website_url('marks'))\n",
                "                ],\n",
                "                custom_callback=done, action_on_removal=done2)\n",
                "\n",
                "    @ac('misc', 'Run the kitty shell to control kitty with commands')\n",
                "    def kitty_shell(self, window_type: str = 'window') -> None:\n",
                "        kw: Dict[str, Any] = {}\n",
                "        cmd = [kitty_exe(), '@']\n",
                "        aw = self.active_window\n",
                "        if aw is not None:\n",
                "            env = {'KITTY_SHELL_ACTIVE_WINDOW_ID': str(aw.id)}\n",
                "            at = self.active_tab\n",
                "            if at is not None:\n",
                "                env['KITTY_SHELL_ACTIVE_TAB_ID'] = str(at.id)\n",
                "            kw['env'] = env\n",
                "        if window_type == 'tab':\n",
                "            tab = self._new_tab(SpecialWindow(cmd, **kw))\n",
                "            if tab is not None:\n",
                "                for w in tab:\n",
                "                    window = w\n",
                "        elif window_type == 'os_window':\n",
                "            os_window_id = self._new_os_window(SpecialWindow(cmd, **kw))\n",
                "            for tab in self.os_window_map[os_window_id]:\n",
                "                for w in tab:\n",
                "                    window = w\n",
                "        elif window_type == 'overlay':\n",
                "            tab = self.active_tab\n",
                "            if aw is not None and tab is not None:\n",
                "                kw['overlay_for'] = aw.id\n",
                "                window = tab.new_special_window(SpecialWindow(cmd, **kw))\n",
                "        else:\n",
                "            tab = self.active_tab\n",
                "            if tab is not None:\n",
                "                window = tab.new_special_window(SpecialWindow(cmd, **kw))\n",
                "\n",
                "        path, ext = os.path.splitext(logo_png_file)\n",
                "        window.set_logo(f'{path}-128{ext}', position='bottom-right', alpha=0.25)\n",
                "        window.allow_remote_control = True\n",
                "\n",
                "    def switch_focus_to(self, window_id: int) -> None:\n",
                "        tab = self.active_tab\n",
                "        if tab:\n",
                "            tab.set_active_window(window_id)\n",
                "\n",
                "    def open_kitty_website(self) -> None:\n",
                "        self.open_url(website_url())\n",
                "\n",
                "    @ac('misc', 'Open the specified URL')\n",
                "    def open_url(self, url: str, program: Optional[Union[str, List[str]]] = None, cwd: Optional[str] = None) -> None:\n",
                "        if not url:\n",
                "            return\n",
                "        if isinstance(program, str):\n",
                "            program = to_cmdline(program)\n",
                "        found_action = False\n",
                "        if program is None:\n",
                "            from .open_actions import actions_for_url\n",
                "            actions = list(actions_for_url(url))\n",
                "            if actions:\n",
                "                found_action = True\n",
                "                self.dispatch_action(actions.pop(0))\n",
                "                if actions:\n",
                "                    self.drain_actions(actions)\n",
                "        if not found_action:\n",
                "            extra_env = {}\n",
                "            if self.listening_on:\n",
                "                extra_env['KITTY_LISTEN_ON'] = self.listening_on\n",
                "\n",
                "            def doit(activation_token: str = '') -> None:\n",
                "                if activation_token:\n",
                "                    extra_env['XDG_ACTIVATION_TOKEN'] = activation_token\n",
                "                open_url(url, program or get_options().open_url_with, cwd=cwd, extra_env=extra_env)\n",
                "\n",
                "            if is_wayland():\n",
                "                run_with_activation_token(doit)\n",
                "            else:\n",
                "                doit()\n",
                "\n",
                "    @ac('misc', 'Sleep for the specified time period. Suffix can be s for seconds, m, for minutes, h for hours and d for days. The time can be fractional.')\n",
                "    def sleep(self, sleep_time: float = 1.0) -> None:\n",
                "        sleep(sleep_time)\n",
                "\n",
                "    @ac('misc', 'Click a URL using the keyboard')\n",
                "    def open_url_with_hints(self) -> None:\n",
                "        self.run_kitten_with_metadata('hints')\n",
                "\n",
                "    def drain_actions(self, actions: List[KeyAction], window_for_dispatch: Optional[Window] = None, dispatch_type: str = 'KeyPress') -> None:\n",
                "\n",
                "        def callback(timer_id: Optional[int]) -> None:\n",
                "            self.dispatch_action(actions.pop(0), window_for_dispatch, dispatch_type)\n",
                "            if actions:\n",
                "                self.drain_actions(actions)\n",
                "        add_timer(callback, 0, False)\n",
                "\n",
                "    def destroy(self) -> None:\n",
                "        self.shutting_down = True\n",
                "        self.child_monitor.shutdown_monitor()\n",
                "        self.set_update_check_process()\n",
                "        self.update_check_process = None\n",
                "        del self.child_monitor\n",
                "        for tm in self.os_window_map.values():\n",
                "            tm.destroy()\n",
                "        self.os_window_map = {}\n",
                "        destroy_global_data()\n",
                "\n",
                "    def paste_to_active_window(self, text: str) -> None:\n",
                "        if text:\n",
                "            w = self.active_window\n",
                "            if w is not None:\n",
                "                w.paste_with_actions(text)\n",
                "\n",
                "    @ac('cp', 'Paste from the clipboard to the active window')\n",
                "    def paste_from_clipboard(self) -> None:\n",
                "        text = get_clipboard_string()\n",
                "        self.paste_to_active_window(text)\n",
                "\n",
                "    def current_primary_selection(self) -> str:\n",
                "        return get_primary_selection() if supports_primary_selection else ''\n",
                "\n",
                "    def current_primary_selection_or_clipboard(self) -> str:\n",
                "        return get_primary_selection() if supports_primary_selection else get_clipboard_string()\n",
                "\n",
                "    @ac('cp', 'Paste from the primary selection, if present, otherwise the clipboard to the active window')\n",
                "    def paste_from_selection(self) -> None:\n",
                "        text = self.current_primary_selection_or_clipboard()\n",
                "        self.paste_to_active_window(text)\n",
                "\n",
                "    def set_primary_selection(self) -> None:\n",
                "        w = self.active_window\n",
                "        if w is not None and not w.destroyed:\n",
                "            text = w.text_for_selection()\n",
                "            if text:\n",
                "                set_primary_selection(text)\n",
                "                if get_options().copy_on_select:\n",
                "                    self.copy_to_buffer(get_options().copy_on_select)\n",
                "\n",
                "    def get_active_selection(self) -> Optional[str]:\n",
                "        w = self.active_window\n",
                "        if w is not None and not w.destroyed:\n",
                "            return w.text_for_selection()\n",
                "        return None\n",
                "\n",
                "    def has_active_selection(self) -> bool:\n",
                "        w = self.active_window\n",
                "        if w is not None and not w.destroyed:\n",
                "            return w.has_selection()\n",
                "        return False\n",
                "\n",
                "    def set_clipboard_buffer(self, buffer_name: str, text: Optional[str] = None) -> None:\n",
                "        if buffer_name:\n",
                "            if text is not None:\n",
                "                self.clipboard_buffers[buffer_name] = text\n",
                "            elif buffer_name in self.clipboard_buffers:\n",
                "                del self.clipboard_buffers[buffer_name]\n",
                "\n",
                "    def get_clipboard_buffer(self, buffer_name: str) -> Optional[str]:\n",
                "        return self.clipboard_buffers.get(buffer_name)\n",
                "\n",
                "    @ac('cp', '''\n",
                "        Copy the selection from the active window to the specified buffer\n",
                "\n",
                "        See :ref:`cpbuf` for details.\n",
                "        ''')\n",
                "    def copy_to_buffer(self, buffer_name: str) -> None:\n",
                "        w = self.active_window\n",
                "        if w is not None and not w.destroyed:\n",
                "            text = w.text_for_selection()\n",
                "            if text:\n",
                "                if buffer_name == 'clipboard':\n",
                "                    set_clipboard_string(text)\n",
                "                elif buffer_name == 'primary':\n",
                "                    set_primary_selection(text)\n",
                "                else:\n",
                "                    self.set_clipboard_buffer(buffer_name, text)\n",
                "\n",
                "    @ac('cp', '''\n",
                "        Paste from the specified buffer to the active window\n",
                "\n",
                "        See :ref:`cpbuf` for details.\n",
                "        ''')\n",
                "    def paste_from_buffer(self, buffer_name: str) -> None:\n",
                "        if buffer_name == 'clipboard':\n",
                "            text: Optional[str] = get_clipboard_string()\n",
                "        elif buffer_name == 'primary':\n",
                "            text = get_primary_selection()\n",
                "        else:\n",
                "            text = self.get_clipboard_buffer(buffer_name)\n",
                "        if text:\n",
                "            self.paste_to_active_window(text)\n",
                "\n",
                "    @ac('tab', '''\n",
                "        Go to the specified tab, by number, starting with 1\n",
                "\n",
                "        Zero and negative numbers go to previously active tabs\n",
                "        ''')\n",
                "    def goto_tab(self, tab_num: int) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tm.goto_tab(tab_num - 1)\n",
                "\n",
                "    def set_active_tab(self, tab: Tab) -> bool:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            return tm.set_active_tab(tab)\n",
                "        return False\n",
                "\n",
                "    @ac('tab', 'Make the next tab active')\n",
                "    def next_tab(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tm.next_tab()\n",
                "\n",
                "    @ac('tab', 'Make the previous tab active')\n",
                "    def previous_tab(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tm.next_tab(-1)\n",
                "\n",
                "    prev_tab = previous_tab\n",
                "\n",
                "    def process_stdin_source(\n",
                "        self, window: Optional[Window] = None,\n",
                "        stdin: Optional[str] = None, copy_pipe_data: Optional[Dict[str, Any]] = None\n",
                "    ) -> Tuple[Optional[Dict[str, str]], Optional[bytes]]:\n",
                "        w = window or self.active_window\n",
                "        if not w:\n",
                "            return None, None\n",
                "        env = None\n",
                "        input_data = None\n",
                "        if stdin:\n",
                "            add_wrap_markers = stdin.endswith('_wrap')\n",
                "            if add_wrap_markers:\n",
                "                stdin = stdin[:-len('_wrap')]\n",
                "            stdin = data_for_at(w, stdin, add_wrap_markers=add_wrap_markers)\n",
                "            if stdin is not None:\n",
                "                pipe_data = w.pipe_data(stdin, has_wrap_markers=add_wrap_markers) if w else None\n",
                "                if pipe_data:\n",
                "                    if copy_pipe_data is not None:\n",
                "                        copy_pipe_data.update(pipe_data)\n",
                "                    env = {\n",
                "                        'KITTY_PIPE_DATA':\n",
                "                        '{scrolled_by}:{cursor_x},{cursor_y}:{lines},{columns}'.format(**pipe_data)\n",
                "                    }\n",
                "                input_data = stdin.encode('utf-8')\n",
                "        return env, input_data\n",
                "\n",
                "    def data_for_at(self, which: str, window: Optional[Window] = None, add_wrap_markers: bool = False) -> Optional[str]:\n",
                "        window = window or self.active_window\n",
                "        if not window:\n",
                "            return None\n",
                "        return data_for_at(window, which, add_wrap_markers=add_wrap_markers)\n",
                "\n",
                "    def special_window_for_cmd(\n",
                "        self, cmd: List[str],\n",
                "        window: Optional[Window] = None,\n",
                "        stdin: Optional[str] = None,\n",
                "        cwd_from: Optional[CwdRequest] = None,\n",
                "        as_overlay: bool = False\n",
                "    ) -> SpecialWindowInstance:\n",
                "        w = window or self.active_window\n",
                "        env, input_data = self.process_stdin_source(w, stdin)\n",
                "        cmdline = []\n",
                "        for arg in cmd:\n",
                "            if arg == '@selection' and w:\n",
                "                q = data_for_at(w, arg)\n",
                "                if not q:\n",
                "                    continue\n",
                "                arg = q\n",
                "            cmdline.append(arg)\n",
                "        overlay_for = w.id if w and as_overlay else None\n",
                "        return SpecialWindow(cmd, input_data, cwd_from=cwd_from, overlay_for=overlay_for, env=env)\n",
                "\n",
                "    def run_background_process(\n",
                "        self,\n",
                "        cmd: List[str],\n",
                "        cwd: Optional[str] = None,\n",
                "        env: Optional[Dict[str, str]] = None,\n",
                "        stdin: Optional[bytes] = None,\n",
                "        cwd_from: Optional[CwdRequest] = None\n",
                "    ) -> None:\n",
                "        import subprocess\n",
                "        env = env or None\n",
                "        if env:\n",
                "            env_ = default_env().copy()\n",
                "            env_.update(env)\n",
                "            env = env_\n",
                "        if cwd_from:\n",
                "            with suppress(Exception):\n",
                "                cwd = cwd_from.cwd_of_child\n",
                "\n",
                "        def doit(activation_token: str = '') -> None:\n",
                "            nonlocal env\n",
                "            if activation_token:\n",
                "                if env is None:\n",
                "                    env = default_env().copy()\n",
                "                env['XDG_ACTIVATION_TOKEN'] = activation_token\n",
                "            if stdin:\n",
                "                r, w = safe_pipe(False)\n",
                "                try:\n",
                "                    subprocess.Popen(cmd, env=env, stdin=r, cwd=cwd, preexec_fn=clear_handled_signals)\n",
                "                except Exception:\n",
                "                    os.close(w)\n",
                "                else:\n",
                "                    thread_write(w, stdin)\n",
                "                finally:\n",
                "                    os.close(r)\n",
                "            else:\n",
                "                subprocess.Popen(cmd, env=env, cwd=cwd, preexec_fn=clear_handled_signals)\n",
                "        if is_wayland():\n",
                "            run_with_activation_token(doit)\n",
                "        else:\n",
                "            doit()\n",
                "\n",
                "    def pipe(self, source: str, dest: str, exe: str, *args: str) -> Optional[Window]:\n",
                "        cmd = [exe] + list(args)\n",
                "        window = self.active_window\n",
                "        cwd_from = CwdRequest(window) if window else None\n",
                "\n",
                "        def create_window() -> SpecialWindowInstance:\n",
                "            return self.special_window_for_cmd(\n",
                "                cmd, stdin=source, as_overlay=dest == 'overlay', cwd_from=cwd_from)\n",
                "\n",
                "        if dest == 'overlay' or dest == 'window':\n",
                "            tab = self.active_tab\n",
                "            if tab is not None:\n",
                "                return tab.new_special_window(create_window())\n",
                "        elif dest == 'tab':\n",
                "            tm = self.active_tab_manager\n",
                "            if tm is not None:\n",
                "                tm.new_tab(special_window=create_window(), cwd_from=cwd_from)\n",
                "        elif dest == 'os_window':\n",
                "            self._new_os_window(create_window(), cwd_from=cwd_from)\n",
                "        elif dest in ('clipboard', 'primary'):\n",
                "            env, stdin = self.process_stdin_source(stdin=source, window=window)\n",
                "            if stdin:\n",
                "                if dest == 'clipboard':\n",
                "                    set_clipboard_string(stdin)\n",
                "                else:\n",
                "                    set_primary_selection(stdin)\n",
                "        else:\n",
                "            env, stdin = self.process_stdin_source(stdin=source, window=window)\n",
                "            self.run_background_process(cmd, cwd_from=cwd_from, stdin=stdin, env=env)\n",
                "        return None\n",
                "\n",
                "    def args_to_special_window(self, args: Iterable[str], cwd_from: Optional[CwdRequest] = None) -> SpecialWindowInstance:\n",
                "        args = list(args)\n",
                "        stdin = None\n",
                "        w = self.active_window\n",
                "\n",
                "        if args[0].startswith('@') and args[0] != '@':\n",
                "            q = data_for_at(w, args[0]) or None\n",
                "            if q is not None:\n",
                "                stdin = q.encode('utf-8')\n",
                "            del args[0]\n",
                "\n",
                "        cmd = []\n",
                "        for arg in args:\n",
                "            if arg == '@selection':\n",
                "                q = data_for_at(w, arg)\n",
                "                if not q:\n",
                "                    continue\n",
                "                arg = q\n",
                "            cmd.append(arg)\n",
                "        return SpecialWindow(cmd, stdin, cwd_from=cwd_from)\n",
                "\n",
                "    def _new_tab(self, args: Union[SpecialWindowInstance, Iterable[str]], cwd_from: Optional[CwdRequest] = None, as_neighbor: bool = False) -> Optional[Tab]:\n",
                "        special_window = None\n",
                "        if args:\n",
                "            if isinstance(args, SpecialWindowInstance):\n",
                "                special_window = args\n",
                "            else:\n",
                "                special_window = self.args_to_special_window(args, cwd_from=cwd_from)\n",
                "        if not self.os_window_map:\n",
                "            self.add_os_window()\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is None and not self.os_window_map:\n",
                "            os_window_id = self.add_os_window()\n",
                "            tm = self.os_window_map.get(os_window_id)\n",
                "        if tm is not None:\n",
                "            return tm.new_tab(special_window=special_window, cwd_from=cwd_from, as_neighbor=as_neighbor)\n",
                "        return None\n",
                "\n",
                "    def _create_tab(self, args: List[str], cwd_from: Optional[CwdRequest] = None) -> None:\n",
                "        as_neighbor = False\n",
                "        if args and args[0].startswith('!'):\n",
                "            as_neighbor = 'neighbor' in args[0][1:].split(',')\n",
                "            args = args[1:]\n",
                "        self._new_tab(args, as_neighbor=as_neighbor, cwd_from=cwd_from)\n",
                "\n",
                "    @ac('tab', 'Create a new tab')\n",
                "    def new_tab(self, *args: str) -> None:\n",
                "        self._create_tab(list(args))\n",
                "\n",
                "    @ac('tab', 'Create a new tab with working directory for the window in it set to the same as the active window')\n",
                "    def new_tab_with_cwd(self, *args: str) -> None:\n",
                "        self._create_tab(list(args), cwd_from=CwdRequest(self.active_window_for_cwd))\n",
                "\n",
                "    def new_tab_with_wd(self, wd: Union[str, List[str]], str_is_multiple_paths: bool = False) -> None:\n",
                "        if isinstance(wd, str):\n",
                "            wd = wd.split(os.pathsep) if str_is_multiple_paths else [wd]\n",
                "        for path in wd:\n",
                "            special_window = SpecialWindow(None, cwd=path)\n",
                "            self._new_tab(special_window)\n",
                "\n",
                "    def _new_window(self, args: List[str], cwd_from: Optional[CwdRequest] = None) -> Optional[Window]:\n",
                "        if not self.os_window_map:\n",
                "            os_window_id = self.add_os_window()\n",
                "            tm = self.os_window_map.get(os_window_id)\n",
                "            if tm is not None and not tm.active_tab:\n",
                "                tm.new_tab(empty_tab=True)\n",
                "        tab = self.active_tab\n",
                "        if tab is None:\n",
                "            return None\n",
                "        allow_remote_control = False\n",
                "        location = None\n",
                "        if args and args[0].startswith('!'):\n",
                "            location = args[0][1:].lower()\n",
                "            args = args[1:]\n",
                "        if args and args[0] == '@':\n",
                "            args = args[1:]\n",
                "            allow_remote_control = True\n",
                "        if args:\n",
                "            return tab.new_special_window(\n",
                "                self.args_to_special_window(args, cwd_from=cwd_from),\n",
                "                location=location, allow_remote_control=allow_remote_control)\n",
                "        else:\n",
                "            return tab.new_window(cwd_from=cwd_from, location=location, allow_remote_control=allow_remote_control)\n",
                "\n",
                "    @ac('win', 'Create a new window')\n",
                "    def new_window(self, *args: str) -> None:\n",
                "        self._new_window(list(args))\n",
                "\n",
                "    @ac('win', 'Create a new window with working directory same as that of the active window')\n",
                "    def new_window_with_cwd(self, *args: str) -> None:\n",
                "        w = self.active_window_for_cwd\n",
                "        if w is None:\n",
                "            return self.new_window(*args)\n",
                "        self._new_window(list(args), cwd_from=CwdRequest(w))\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Launch the specified program in a new window/tab/etc.\n",
                "\n",
                "        See :doc:`launch` for details\n",
                "        ''')\n",
                "    def launch(self, *args: str) -> None:\n",
                "        from kitty.launch import launch, parse_launch_args\n",
                "        opts, args_ = parse_launch_args(args)\n",
                "        launch(self, opts, args_)\n",
                "\n",
                "    @ac('tab', 'Move the active tab forward')\n",
                "    def move_tab_forward(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tm.move_tab(1)\n",
                "\n",
                "    @ac('tab', 'Move the active tab backward')\n",
                "    def move_tab_backward(self) -> None:\n",
                "        tm = self.active_tab_manager\n",
                "        if tm is not None:\n",
                "            tm.move_tab(-1)\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Turn on/off ligatures in the specified window\n",
                "\n",
                "        See :opt:`disable_ligatures` for details\n",
                "        ''')\n",
                "    def disable_ligatures_in(self, where: Union[str, Iterable[Window]], strategy: int) -> None:\n",
                "        if isinstance(where, str):\n",
                "            windows: List[Window] = []\n",
                "            if where == 'active':\n",
                "                if self.active_window is not None:\n",
                "                    windows = [self.active_window]\n",
                "            elif where == 'all':\n",
                "                windows = list(self.all_windows)\n",
                "            elif where == 'tab':\n",
                "                if self.active_tab is not None:\n",
                "                    windows = list(self.active_tab)\n",
                "        else:\n",
                "            windows = list(where)\n",
                "        for window in windows:\n",
                "            window.screen.disable_ligatures = strategy\n",
                "            window.refresh()\n",
                "\n",
                "    def patch_colors(self, spec: Dict[str, Optional[int]], configured: bool = False) -> None:\n",
                "        from kitty.rc.set_colors import nullable_colors\n",
                "        opts = get_options()\n",
                "        if configured:\n",
                "            for k, v in spec.items():\n",
                "                if hasattr(opts, k):\n",
                "                    if v is None:\n",
                "                        if k in nullable_colors:\n",
                "                            setattr(opts, k, None)\n",
                "                    else:\n",
                "                        setattr(opts, k, color_from_int(v))\n",
                "        for tm in self.all_tab_managers:\n",
                "            tm.tab_bar.patch_colors(spec)\n",
                "            tm.tab_bar.layout()\n",
                "            tm.mark_tab_bar_dirty()\n",
                "            t = tm.active_tab\n",
                "            if t is not None:\n",
                "                t.relayout_borders()\n",
                "        patch_global_colors(spec, configured)\n",
                "\n",
                "    def apply_new_options(self, opts: Options) -> None:\n",
                "        from .fonts.box_drawing import set_scale\n",
                "        # Update options storage\n",
                "        set_options(opts, is_wayland(), self.args.debug_rendering, self.args.debug_font_fallback)\n",
                "        apply_options_update()\n",
                "        set_layout_options(opts)\n",
                "        set_default_env(opts.env.copy())\n",
                "        # Update font data\n",
                "        set_scale(opts.box_drawing_scale)\n",
                "        from .fonts.render import set_font_family\n",
                "        set_font_family(opts, debug_font_matching=self.args.debug_font_fallback)\n",
                "        for os_window_id, tm in self.os_window_map.items():\n",
                "            if tm is not None:\n",
                "                os_window_font_size(os_window_id, opts.font_size, True)\n",
                "                tm.resize()\n",
                "        # Update key bindings\n",
                "        self.update_keymap()\n",
                "        # Update misc options\n",
                "        try:\n",
                "            set_background_image(opts.background_image, tuple(self.os_window_map), True, opts.background_image_layout)\n",
                "        except Exception as e:\n",
                "            log_error(f'Failed to set background image with error: {e}')\n",
                "        for tm in self.all_tab_managers:\n",
                "            tm.apply_options()\n",
                "        # Update colors\n",
                "        for w in self.all_windows:\n",
                "            self.default_bg_changed_for(w.id)\n",
                "            w.refresh(reload_all_gpu_data=True)\n",
                "        load_shader_programs.recompile_if_needed()\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Reload the config file\n",
                "\n",
                "        If mapped without arguments reloads the default config file, otherwise loads\n",
                "        the specified config files, in order. Loading a config file *replaces* all\n",
                "        config options. For example::\n",
                "\n",
                "            map f5 load_config_file /path/to/some/kitty.conf\n",
                "        ''')\n",
                "    def load_config_file(self, *paths: str, apply_overrides: bool = True) -> None:\n",
                "        from .cli import default_config_paths\n",
                "        from .config import load_config\n",
                "        old_opts = get_options()\n",
                "        prev_paths = old_opts.config_paths or default_config_paths(self.args.config)\n",
                "        paths = paths or prev_paths\n",
                "        bad_lines: List[BadLine] = []\n",
                "        opts = load_config(*paths, overrides=old_opts.config_overrides if apply_overrides else None, accumulate_bad_lines=bad_lines)\n",
                "        if bad_lines:\n",
                "            self.show_bad_config_lines(bad_lines)\n",
                "        self.apply_new_options(opts)\n",
                "        from .open_actions import clear_caches\n",
                "        clear_caches()\n",
                "        from .guess_mime_type import clear_mime_cache\n",
                "        clear_mime_cache()\n",
                "\n",
                "    def safe_delete_temp_file(self, path: str) -> None:\n",
                "        if is_path_in_temp_dir(path):\n",
                "            with suppress(FileNotFoundError):\n",
                "                os.remove(path)\n",
                "\n",
                "    def is_ok_to_read_image_file(self, path: str, fd: int) -> bool:\n",
                "        return is_ok_to_read_image_file(path, fd)\n",
                "\n",
                "    def set_update_check_process(self, process: Optional['PopenType[bytes]'] = None) -> None:\n",
                "        if self.update_check_process is not None:\n",
                "            with suppress(Exception):\n",
                "                if self.update_check_process.poll() is None:\n",
                "                    self.update_check_process.kill()\n",
                "        self.update_check_process = process\n",
                "\n",
                "    def on_monitored_pid_death(self, pid: int, exit_status: int) -> None:\n",
                "        update_check_process = self.update_check_process\n",
                "        if update_check_process is not None and pid == update_check_process.pid:\n",
                "            self.update_check_process = None\n",
                "            from .update_check import process_current_release\n",
                "            try:\n",
                "                assert update_check_process.stdout is not None\n",
                "                raw = update_check_process.stdout.read().decode('utf-8')\n",
                "            except Exception as e:\n",
                "                log_error(f'Failed to read data from update check process, with error: {e}')\n",
                "            else:\n",
                "                try:\n",
                "                    process_current_release(raw)\n",
                "                except Exception as e:\n",
                "                    log_error(f'Failed to process update check data {raw!r}, with error: {e}')\n",
                "\n",
                "    def dbus_notification_callback(self, activated: bool, a: int, b: Union[int, str]) -> None:\n",
                "        from .notify import dbus_notification_activated, dbus_notification_created\n",
                "        if activated:\n",
                "            assert isinstance(b, str)\n",
                "            dbus_notification_activated(a, b)\n",
                "        else:\n",
                "            assert isinstance(b, int)\n",
                "            dbus_notification_created(a, b)\n",
                "\n",
                "    def show_bad_config_lines(self, bad_lines: Iterable[BadLine]) -> None:\n",
                "\n",
                "        def format_bad_line(bad_line: BadLine) -> str:\n",
                "            return f'{bad_line.number}:{bad_line.exception} in line: {bad_line.line}\\n'\n",
                "\n",
                "        groups: Dict[str, List[BadLine]] = {}\n",
                "        for bl in bad_lines:\n",
                "            groups.setdefault(bl.file, []).append(bl)\n",
                "        ans: List[str] = []\n",
                "        a = ans.append\n",
                "        for file in sorted(groups):\n",
                "            if file:\n",
                "                a(f'In file {file}:')\n",
                "            [a(format_bad_line(x)) for x in groups[file]]\n",
                "\n",
                "        msg = '\\n'.join(ans).rstrip()\n",
                "        self.show_error(_('Errors parsing configuration'), msg)\n",
                "\n",
                "    @ac('misc', '''\n",
                "        Change colors in the specified windows\n",
                "\n",
                "        For details, see :ref:`at-set-colors`. For example::\n",
                "\n",
                "            map f5 set_colors --configured /path/to/some/config/file/colors.conf\n",
                "        ''')\n",
                "    def set_colors(self, *args: str) -> None:\n",
                "        from kitty.rc.base import PayloadGetter, command_for_name, parse_subcommand_cli\n",
                "        from kitty.remote_control import parse_rc_args\n",
                "        c = command_for_name('set_colors')\n",
                "        try:\n",
                "            opts, items = parse_subcommand_cli(c, ['set-colors'] + list(args))\n",
                "        except (Exception, SystemExit) as err:\n",
                "            self.show_error('Invalid set_colors mapping', str(err))\n",
                "            return\n",
                "        try:\n",
                "            payload = c.message_to_kitty(parse_rc_args([])[0], opts, items)\n",
                "        except (Exception, SystemExit) as err:\n",
                "            self.show_error('Failed to set colors', str(err))\n",
                "            return\n",
                "        c.response_from_kitty(self, self.active_window, PayloadGetter(c, payload if isinstance(payload, dict) else {}))\n",
                "\n",
                "    def _move_window_to(\n",
                "        self,\n",
                "        window: Optional[Window] = None,\n",
                "        target_tab_id: Optional[Union[str, int]] = None,\n",
                "        target_os_window_id: Optional[Union[str, int]] = None\n",
                "    ) -> None:\n",
                "        window = window or self.active_window\n",
                "        if not window:\n",
                "            return\n",
                "        src_tab = self.tab_for_window(window)\n",
                "        if src_tab is None:\n",
                "            return\n",
                "        with self.suppress_focus_change_events():\n",
                "            if target_os_window_id == 'new':\n",
                "                target_os_window_id = self.add_os_window()\n",
                "                tm = self.os_window_map[target_os_window_id]\n",
                "                target_tab = tm.new_tab(empty_tab=True)\n",
                "            else:\n",
                "                target_os_window_id = target_os_window_id or current_os_window()\n",
                "                if isinstance(target_tab_id, str):\n",
                "                    if not isinstance(target_os_window_id, int):\n",
                "                        q = self.active_tab_manager\n",
                "                        assert q is not None\n",
                "                        tm = q\n",
                "                    else:\n",
                "                        tm = self.os_window_map[target_os_window_id]\n",
                "                    if target_tab_id == 'new':\n",
                "                        target_tab = tm.new_tab(empty_tab=True)\n",
                "                    else:\n",
                "                        target_tab = tm.tab_at_location(target_tab_id) or tm.new_tab(empty_tab=True)\n",
                "                else:\n",
                "                    for tab in self.all_tabs:\n",
                "                        if tab.id == target_tab_id:\n",
                "                            target_tab = tab\n",
                "                            target_os_window_id = tab.os_window_id\n",
                "                            break\n",
                "                    else:\n",
                "                        return\n",
                "\n",
                "            for detached_window in src_tab.detach_window(window):\n",
                "                target_tab.attach_window(detached_window)\n",
                "            self._cleanup_tab_after_window_removal(src_tab)\n",
                "            target_tab.make_active()\n",
                "\n",
                "    def _move_tab_to(self, tab: Optional[Tab] = None, target_os_window_id: Optional[int] = None) -> None:\n",
                "        tab = tab or self.active_tab\n",
                "        if tab is None:\n",
                "            return\n",
                "        if target_os_window_id is None:\n",
                "            target_os_window_id = self.add_os_window()\n",
                "        tm = self.os_window_map[target_os_window_id]\n",
                "        target_tab = tm.new_tab(empty_tab=True)\n",
                "        target_tab.take_over_from(tab)\n",
                "        self._cleanup_tab_after_window_removal(tab)\n",
                "        target_tab.make_active()\n",
                "\n",
                "    def choose_entry(\n",
                "        self, title: str, entries: Iterable[Tuple[Union[_T, str, None], str]],\n",
                "        callback: Callable[[Union[_T, str, None]], None],\n",
                "        subtitle: str = '',\n",
                "        hints_args: Optional[Tuple[str, ...]] = None,\n",
                "    ) -> Optional[Window]:\n",
                "        lines = [title, subtitle, ' '] if subtitle else [title, ' ']\n",
                "        idx_map: List[Union[_T, str, None]] = []\n",
                "        ans: Union[str, _T, None] = None\n",
                "        fmt = ': {1}'\n",
                "\n",
                "        for obj, text in entries:\n",
                "            idx_map.append(obj)\n",
                "            if obj is None:\n",
                "                lines.append(text)\n",
                "            else:\n",
                "                lines.append(fmt.format(len(idx_map), text))\n",
                "\n",
                "        def done(data: Dict[str, Any], target_window_id: int, self: Boss) -> None:\n",
                "            nonlocal ans\n",
                "            ans = idx_map[int(data['groupdicts'][0]['index'])]\n",
                "\n",
                "        def done2(target_window_id: int, self: Boss) -> None:\n",
                "            callback(ans)\n",
                "\n",
                "        q = self.run_kitten_with_metadata(\n",
                "            'hints', args=(\n",
                "                '--ascending', '--customize-processing=::import::kitty.choose_entry',\n",
                "                '--window-title', title,\n",
                "                *(hints_args or ())\n",
                "            ), input_data='\\r\\n'.join(lines).encode('utf-8'), custom_callback=done, action_on_removal=done2\n",
                "        )\n",
                "        return q if isinstance(q, Window) else None\n",
                "\n",
                "    @ac('tab', 'Interactively select a tab to switch to')\n",
                "    def select_tab(self) -> None:\n",
                "\n",
                "        def chosen(ans: Union[None, str, int]) -> None:\n",
                "            if isinstance(ans, int):\n",
                "                for tab in self.all_tabs:\n",
                "                    if tab.id == ans:\n",
                "                        self.set_active_tab(tab)\n",
                "\n",
                "        def format_tab_title(tab: Tab) -> str:\n",
                "            w = 'windows' if tab.num_window_groups > 1 else 'window'\n",
                "            return f'{tab.name or tab.title} [{tab.num_window_groups} {w}]'\n",
                "\n",
                "        ct = self.active_tab\n",
                "        self.choose_entry(\n",
                "            'Choose a tab to switch to',\n",
                "            ((None, f'Current tab: {format_tab_title(t)}') if t is ct else (t.id, format_tab_title(t)) for t in self.all_tabs),\n",
                "            chosen\n",
                "        )\n",
                "\n",
                "    @ac('win', '''\n",
                "        Detach a window, moving it to another tab or OS Window\n",
                "\n",
                "        See :ref:`detaching windows <detach_window>` for details.\n",
                "        ''')\n",
                "    def detach_window(self, *args: str) -> None:\n",
                "        if not args or args[0] == 'new':\n",
                "            return self._move_window_to(target_os_window_id='new')\n",
                "        if args[0] in ('new-tab', 'tab-prev', 'tab-left', 'tab-right'):\n",
                "            where = 'new' if args[0] == 'new-tab' else args[0][4:]\n",
                "            return self._move_window_to(target_tab_id=where)\n",
                "        ct = self.active_tab\n",
                "        items: List[Tuple[Union[str, int], str]] = [(t.id, t.effective_title) for t in self.all_tabs if t is not ct]\n",
                "        items.append(('new_tab', 'New tab'))\n",
                "        items.append(('new_os_window', 'New OS Window'))\n",
                "        target_window = self.active_window\n",
                "\n",
                "        def chosen(ans: Union[None, str, int]) -> None:\n",
                "            if ans is not None:\n",
                "                if isinstance(ans, str):\n",
                "                    if ans == 'new_os_window':\n",
                "                        self._move_window_to(target_os_window_id='new')\n",
                "                    elif ans == 'new_tab':\n",
                "                        self._move_window_to(target_tab_id=ans)\n",
                "                else:\n",
                "                    self._move_window_to(target_window, target_tab_id=ans)\n",
                "\n",
                "        self.choose_entry('Choose a tab to move the window to', items, chosen)\n",
                "\n",
                "    @ac('tab', '''\n",
                "        Detach a tab, moving it to another OS Window\n",
                "\n",
                "        See :ref:`detaching windows <detach_window>` for details.\n",
                "        ''')\n",
                "    def detach_tab(self, *args: str) -> None:\n",
                "        if not args or args[0] == 'new':\n",
                "            return self._move_tab_to()\n",
                "\n",
                "        items: List[Tuple[Union[str, int], str]] = []\n",
                "        ct = self.active_tab_manager\n",
                "        for osw_id, tm in self.os_window_map.items():\n",
                "            if tm is not ct and tm.active_tab:\n",
                "                items.append((osw_id, tm.active_tab.title))\n",
                "        items.append(('new', 'New OS Window'))\n",
                "        target_tab = self.active_tab\n",
                "\n",
                "        def chosen(ans: Union[None, int, str]) -> None:\n",
                "            if ans is not None:\n",
                "                os_window_id = None if isinstance(ans, str) else ans\n",
                "                self._move_tab_to(tab=target_tab, target_os_window_id=os_window_id)\n",
                "\n",
                "        self.choose_entry('Choose an OS window to move the tab to', items, chosen)\n",
                "\n",
                "    def set_background_image(self, path: Optional[str], os_windows: Tuple[int, ...], configured: bool, layout: Optional[str], png_data: bytes = b'') -> None:\n",
                "        set_background_image(path, os_windows, configured, layout, png_data)\n",
                "        for os_window_id in os_windows:\n",
                "            self.default_bg_changed_for(os_window_id)\n",
                "\n",
                "    # Can be called with kitty -o \"map f1 send_test_notification\"\n",
                "    def send_test_notification(self) -> None:\n",
                "        from .notify import notify\n",
                "        now = monotonic()\n",
                "        ident = f'test-notify-{now}'\n",
                "        notify(f'Test {now}', f'At: {now}', identifier=ident, subtitle=f'Test subtitle {now}')\n",
                "\n",
                "    def notification_activated(self, identifier: str, window_id: int, focus: bool, report: bool) -> None:\n",
                "        w = self.window_id_map.get(window_id)\n",
                "        if w is None:\n",
                "            return\n",
                "        if focus:\n",
                "            self.set_active_window(w, switch_os_window_if_needed=True)\n",
                "        if report:\n",
                "            w.report_notification_activated(identifier)\n",
                "\n",
                "    @ac('debug', 'Show the environment variables that the kitty process sees')\n",
                "    def show_kitty_env_vars(self) -> None:\n",
                "        w = self.active_window\n",
                "        env = os.environ.copy()\n",
                "        if is_macos and env.get('LC_CTYPE') == 'UTF-8' and not getattr(sys, 'kitty_run_data').get('lc_ctype_before_python'):\n",
                "            del env['LC_CTYPE']\n",
                "        if w:\n",
                "            output = '\\n'.join(f'{k}={v}' for k, v in env.items())\n",
                "            self.display_scrollback(w, output, title=_('Current kitty env vars'), report_cursor=False)\n",
                "\n",
                "    @ac('debug', '''\n",
                "        Close all shared SSH connections\n",
                "\n",
                "        See :opt:`share_connections <kitten-ssh.share_connections>` for details.\n",
                "        ''')\n",
                "    def close_shared_ssh_connections(self) -> None:\n",
                "        cleanup_ssh_control_masters()\n",
                "\n",
                "    def launch_urls(self, *urls: str, no_replace_window: bool = False) -> None:\n",
                "        from .launch import force_window_launch\n",
                "        from .open_actions import actions_for_launch\n",
                "        actions: List[KeyAction] = []\n",
                "        failures = []\n",
                "        for url in urls:\n",
                "            uactions = tuple(actions_for_launch(url))\n",
                "            if uactions:\n",
                "                actions.extend(uactions)\n",
                "            else:\n",
                "                failures.append(url)\n",
                "        tab = self.active_tab\n",
                "        if tab is not None:\n",
                "            w = tab.active_window\n",
                "        else:\n",
                "            w = None\n",
                "        needs_window_replaced = False\n",
                "        if not no_replace_window and not get_options().startup_session:\n",
                "            if w is not None and w.id == 1 and monotonic() - w.started_at < 2 and len(tuple(self.all_windows)) == 1:\n",
                "                # first window, soon after startup replace it\n",
                "                needs_window_replaced = True\n",
                "\n",
                "        def clear_initial_window() -> None:\n",
                "            if needs_window_replaced and tab is not None and w is not None:\n",
                "                tab.remove_window(w)\n",
                "\n",
                "        if failures:\n",
                "            from kittens.tui.operations import styled\n",
                "            spec = '\\n  '.join(styled(u, fg='yellow') for u in failures)\n",
                "            bdata = json.dumps({'msg': f\"Unknown URL type, cannot open:\\n  {spec}\"}).encode('utf-8')\n",
                "            special_window = SpecialWindow([kitty_exe(), '+kitten', 'show_error', '--title', 'Open URL Error'], bdata, 'Open URL Error')\n",
                "            if needs_window_replaced and tab is not None:\n",
                "                tab.new_special_window(special_window)\n",
                "            else:\n",
                "                self._new_os_window(special_window)\n",
                "            clear_initial_window()\n",
                "            needs_window_replaced = False\n",
                "        if actions:\n",
                "            with force_window_launch(needs_window_replaced):\n",
                "                self.dispatch_action(actions.pop(0))\n",
                "            clear_initial_window()\n",
                "            if actions:\n",
                "                self.drain_actions(actions)\n",
                "\n",
                "    @ac('debug', 'Show the effective configuration kitty is running with')\n",
                "    def debug_config(self) -> None:\n",
                "        from .debug_config import debug_config\n",
                "        w = self.active_window\n",
                "        if w is not None:\n",
                "            output = debug_config(get_options())\n",
                "            set_clipboard_string(re.sub(r'\\x1b.+?m', '', output))\n",
                "            output += '\\n\\x1b[35mThis debug output has been copied to the clipboard\\x1b[m'\n",
                "            self.display_scrollback(w, output, title=_('Current kitty options'), report_cursor=False)\n",
                "\n",
                "    @ac('misc', 'Discard this event completely ignoring it')\n",
                "    def discard_event(self) -> None:\n",
                "        pass\n",
                "    mouse_discard_event = discard_event\n",
                "\n",
                "    def sanitize_url_for_dispay_to_user(self, url: str) -> str:\n",
                "        return sanitize_url_for_dispay_to_user(url)\n",
                "\n",
                "    def on_system_color_scheme_change(self, appearance: int) -> None:\n",
                "        log_error('system color theme changed:', appearance)"
            ]
        ]
    },
    "edit_order": [
        [
            0,
            1,
            3,
            2
        ],
        [
            0,
            2,
            1,
            3
        ]
    ],
    "partial_orders": [
        {
            "edit_hunk_pair": [
                1,
                0
            ],
            "edit_order": "bi-directional",
            "reason": "Rename",
            "scenario of 0 -> 1": "edit 0 updates the logic first, then edit 1 afterwards.",
            "scenario of 1 -> 0": "edit 1 updates the logic first, then edit 0 afterwards."
        },
        {
            "edit_hunk_pair": [
                0,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "Rename",
            "scenario of 0 -> 1": "edit 0 updates the logic first, then edit 1 afterwards.",
            "scenario of 1 -> 0": "edit 1 updates the logic first, then edit 0 afterwards."
        },
        {
            "edit_hunk_pair": [
                0,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "Rename",
            "scenario of 0 -> 1": "edit 0 updates the logic first, then edit 1 afterwards.",
            "scenario of 1 -> 0": "edit 1 updates the logic first, then edit 0 afterwards."
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "Rename",
            "scenario of 0 -> 1": "edit 0 updates the logic first, then edit 1 afterwards.",
            "scenario of 1 -> 0": "edit 1 updates the logic first, then edit 0 afterwards."
        },
        {
            "edit_hunk_pair": [
                1,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "Rename",
            "scenario of 0 -> 1": "edit 0 updates the logic first, then edit 1 afterwards.",
            "scenario of 1 -> 0": "edit 1 updates the logic first, then edit 0 afterwards."
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "code clones",
            "scenario of 0 -> 1": "edit 0 updates the logic first, then copied pasted to edit 1 afterwards.",
            "scenario of 1 -> 0": "edit 1 updates the logic first, then copied pasted to edit 0 afterwards."
        }
    ]
}