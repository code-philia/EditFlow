{
    "language": "python",
    "commit_url": "https://github.com/deepfakes/faceswap/commit/e2d84bec50884c6d1ae4bf94fee7e4f10e836d69",
    "commit_message": "bugfix: - Alignment tool - remove faces:\n  - Only process faces that exist in alignments file",
    "commit_snapshots": {
        "tools/alignments/jobs_faces.py": [
            [
                "#!/usr/bin/env python3\n",
                "\"\"\" Tools for manipulating the alignments using extracted Faces as a source \"\"\"\n",
                "import logging\n",
                "import os\n",
                "import sys\n",
                "from argparse import Namespace\n",
                "from operator import itemgetter\n",
                "from typing import cast, Dict, List, Optional, Tuple, TYPE_CHECKING\n",
                "\n",
                "import numpy as np\n",
                "from tqdm import tqdm\n",
                "\n",
                "from lib.align import DetectedFace\n",
                "from lib.image import update_existing_metadata  # TODO remove\n",
                "from scripts.fsmedia import Alignments\n",
                "\n",
                "from .media import Faces\n",
                "\n",
                "if sys.version_info < (3, 8):\n",
                "    from typing_extensions import Literal\n",
                "else:\n",
                "    from typing import Literal\n",
                "\n",
                "if TYPE_CHECKING:\n",
                "    from .media import AlignmentData\n",
                "    from lib.align.alignments import (AlignmentDict, AlignmentFileDict,\n",
                "                                      PNGHeaderDict, PNGHeaderAlignmentsDict)\n",
                "\n",
                "logger = logging.getLogger(__name__)\n",
                "\n",
                "\n",
                "class FromFaces():  # pylint:disable=too-few-public-methods\n",
                "    \"\"\" Scan a folder of Faceswap Extracted Faces and re-create the associated alignments file(s)\n",
                "\n",
                "    Parameters\n",
                "    ----------\n",
                "    alignments: NoneType\n",
                "        Parameter included for standard job naming convention, but not used for this process.\n",
                "    arguments: :class:`argparse.Namespace`\n",
                "        The :mod:`argparse` arguments as passed in from :mod:`tools.py`\n",
                "    \"\"\"\n",
                "    def __init__(self, alignments: None, arguments: Namespace) -> None:\n",
                "        logger.debug(\"Initializing %s: (alignments: %s, arguments: %s)\",\n",
                "                     self.__class__.__name__, alignments, arguments)\n",
                "        self._faces_dir = arguments.faces_dir\n",
                "        self._faces = Faces(arguments.faces_dir)\n",
                "        logger.debug(\"Initialized %s\", self.__class__.__name__)\n",
                "\n",
                "    def process(self) -> None:\n",
                "        \"\"\" Run the job to read faces from a folder to create alignments file(s). \"\"\"\n",
                "        logger.info(\"[CREATE ALIGNMENTS FROM FACES]\")  # Tidy up cli output\n",
                "\n",
                "        all_versions: Dict[str, List[float]] = {}\n",
                "        d_align: Dict[str, Dict[str, List[Tuple[int, \"AlignmentFileDict\", str, dict]]]] = {}\n",
                "        filelist = cast(List[Tuple[str, \"PNGHeaderDict\"]], self._faces.file_list_sorted)\n",
                "        for filename, meta in tqdm(filelist,\n",
                "                                   desc=\"Generating Alignments\",\n",
                "                                   total=len(filelist),\n",
                "                                   leave=False):\n",
                "\n",
                "            align_fname = self._get_alignments_filename(meta[\"source\"])\n",
                "            source_name, f_idx, alignment = self._extract_alignment(meta)\n",
                "            full_info = (f_idx, alignment, filename, meta[\"source\"])\n",
                "\n",
                "            d_align.setdefault(align_fname, {}).setdefault(source_name, []).append(full_info)\n",
                "            all_versions.setdefault(align_fname, []).append(meta[\"source\"][\"alignments_version\"])\n",
                "\n",
                "        versions = {k: min(v) for k, v in all_versions.items()}\n",
                "        alignments = self._sort_alignments(d_align)\n",
                "        self._save_alignments(alignments, versions)\n",
                "\n",
                "    @classmethod\n",
                "    def _get_alignments_filename(cls, source_data: dict) -> str:\n",
                "        \"\"\" Obtain the name of the alignments file from the source information contained within the\n",
                "        PNG metadata.\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        source_data: dict\n",
                "            The source information contained within a Faceswap extracted PNG\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        str:\n",
                "            If the face was generated from a video file, the filename will be\n",
                "            `'<video_name>_alignments.fsa'`. If it was extracted from an image file it will be\n",
                "            `'alignments.fsa'`\n",
                "        \"\"\"\n",
                "        is_video = source_data[\"source_is_video\"]\n",
                "        src_name = source_data[\"source_filename\"]\n",
                "        prefix = f\"{src_name.rpartition('_')[0]}_\" if is_video else \"\"\n",
                "        retval = f\"{prefix}alignments.fsa\"\n",
                "        logger.trace(\"Extracted alignments file filename: '%s'\", retval)  # type:ignore\n",
                "        return retval\n",
                "\n",
                "    def _extract_alignment(self, metadata: dict) -> Tuple[str, int, \"AlignmentFileDict\"]:\n",
                "        \"\"\" Extract alignment data from a PNG image's itxt header.\n",
                "\n",
                "        Formats the landmarks into a numpy array and adds in mask centering information if it is\n",
                "        from an older extract.\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        metadata: dict\n",
                "            An extracted faces PNG Header data\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        tuple\n",
                "            The alignment's source frame name in position 0. The index of the face within the\n",
                "            alignment file in position 1. The alignment data correctly formatted for writing to an\n",
                "            alignments file in positin 2\n",
                "        \"\"\"\n",
                "        alignment = metadata[\"alignments\"]\n",
                "        alignment[\"landmarks_xy\"] = np.array(alignment[\"landmarks_xy\"], dtype=\"float32\")\n",
                "\n",
                "        src = metadata[\"source\"]\n",
                "        frame_name = src[\"source_filename\"]\n",
                "        face_index = int(src[\"face_index\"])\n",
                "\n",
                "        logger.trace(\"Extracted alignment for frame: '%s', face index: %s\",  # type:ignore\n",
                "                     frame_name, face_index)\n",
                "        return frame_name, face_index, alignment\n",
                "\n",
                "    def _sort_alignments(self,\n",
                "                         alignments: Dict[str, Dict[str, List[Tuple[int,\n",
                "                                                                    \"AlignmentFileDict\",\n",
                "                                                                    str,\n",
                "                                                                    dict]]]]\n",
                "                         ) -> Dict[str, Dict[str, \"AlignmentDict\"]]:\n",
                "        \"\"\" Sort the faces into face index order as they appeared in the original alignments file.\n",
                "\n",
                "        If the face index stored in the png header does not match it's position in the alignments\n",
                "        file (i.e. A face has been removed from a frame) then update the header of the\n",
                "        corresponding png to the correct index as exists in the newly created alignments file.\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        alignments: dict\n",
                "            The unsorted alignments file(s) as generated from the face PNG headers, including the\n",
                "            face index of the face within it's respective frame, the original face filename and\n",
                "            the orignal face header source information\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        dict\n",
                "            The alignments file dictionaries sorted into the correct face order, ready for saving\n",
                "        \"\"\"\n",
                "        logger.info(\"Sorting and checking faces...\")\n",
                "        aln_sorted: Dict[str, Dict[str, \"AlignmentDict\"]] = {}\n",
                "        for fname, frames in alignments.items():\n",
                "            this_file: Dict[str, \"AlignmentDict\"] = {}\n",
                "            for frame in tqdm(sorted(frames), desc=f\"Sorting {fname}\", leave=False):\n",
                "                this_file[frame] = dict(video_meta={}, faces=[])\n",
                "                for real_idx, (f_id, almt, f_path, f_src) in enumerate(sorted(frames[frame],\n",
                "                                                                              key=itemgetter(0))):\n",
                "                    if real_idx != f_id:\n",
                "                        full_path = os.path.join(self._faces_dir, f_path)\n",
                "                        self._update_png_header(full_path, real_idx, almt, f_src)\n",
                "                    this_file[frame][\"faces\"].append(almt)\n",
                "            aln_sorted[fname] = this_file\n",
                "        return aln_sorted\n",
                "\n",
                "    @classmethod\n",
                "    def _update_png_header(cls,\n",
                "                           face_path: str,\n",
                "                           new_index: int,\n",
                "                           alignment: \"AlignmentFileDict\",\n",
                "                           source_info: dict) -> None:\n",
                "        \"\"\" Update the PNG header for faces where the stored index does not correspond with the\n",
                "        alignments file. This can occur when frames with multiple faces have had some faces deleted\n",
                "        from the faces folder.\n",
                "\n",
                "        Updates the original filename and index in the png header.\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        face_path: str\n",
                "            Full path to the saved face image that requires updating\n",
                "        new_index: int\n",
                "            The new index as it appears in the newly generated alignments file\n",
                "        alignment: dict\n",
                "            The alignment information to store in the png header\n",
                "        source_info: dict\n",
                "            The face source information as extracted from the original face png file\n",
                "        \"\"\"\n",
                "        face = DetectedFace()\n",
                "        face.from_alignment(alignment)\n",
                "        new_filename = f\"{os.path.splitext(source_info['source_filename'])[0]}_{new_index}.png\"\n",
                "\n",
                "        logger.trace(\"Updating png header for '%s': (face index from %s to %s, \"  # type:ignore\n",
                "                     \"original filename from '%s' to '%s'\", face_path, source_info[\"face_index\"],\n",
                "                     new_index, source_info[\"original_filename\"], new_filename)\n",
                "\n",
                "        source_info[\"face_index\"] = new_index\n",
                "        source_info[\"original_filename\"] = new_filename\n",
                "        meta = dict(alignments=face.to_png_meta(), source=source_info)\n",
                "        update_existing_metadata(face_path, meta)\n",
                "\n",
                "    def _save_alignments(self,\n",
                "                         all_alignments: Dict[str, Dict[str, \"AlignmentDict\"]],\n",
                "                         versions: Dict[str, float]) -> None:\n",
                "        \"\"\" Save the newely generated alignments file(s).\n",
                "\n",
                "        If an alignments file already exists in the source faces folder, back it up rather than\n",
                "        overwriting\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        all_alignments: dict\n",
                "            The alignment(s) dictionaries found in the faces folder. Alignment filename as key,\n",
                "            corresponding alignments as value.\n",
                "        versions: dict\n",
                "            The minimum version number that exists in a face set for each alignments file to be\n",
                "            generated\n",
                "        \"\"\"\n",
                "        for fname, alignments in all_alignments.items():\n",
                "            version = versions[fname]\n",
                "            alignments_path = os.path.join(self._faces_dir, fname)\n",
                "            dummy_args = Namespace(alignments_path=alignments_path)\n",
                "            aln = Alignments(dummy_args, is_extract=True)\n",
                "            aln._data = alignments  # pylint:disable=protected-access\n",
                "            aln._io._version = version  # pylint:disable=protected-access\n",
                "            aln._io.update_legacy()  # pylint:disable=protected-access\n",
                "            aln.backup()\n",
                "            aln.save()\n",
                "\n",
                "\n",
                "class Rename():  # pylint:disable=too-few-public-methods\n",
                "    \"\"\" Rename faces in a folder to match their filename as stored in an alignments file.\n",
                "\n",
                "    Parameters\n",
                "    ----------\n",
                "    alignments: :class:`tools.lib_alignments.media.AlignmentData`\n",
                "        The alignments data loaded from an alignments file for this rename job\n",
                "    arguments: :class:`argparse.Namespace`\n",
                "        The :mod:`argparse` arguments as passed in from :mod:`tools.py`\n",
                "    faces: :class:`tools.lib_alignments.media.Faces`, Optional\n",
                "        An optional faces object, if the rename task is being called by another job.\n",
                "        Default: ``None``\n",
                "    \"\"\"\n",
                "    def __init__(self,\n",
                "                 alignments: \"AlignmentData\",\n",
                "                 arguments: Optional[Namespace],\n",
                "                 faces: Optional[Faces] = None) -> None:\n",
                "        logger.debug(\"Initializing %s: (arguments: %s, faces: %s)\",\n",
                "                     self.__class__.__name__, arguments, faces)\n",
                "        self._alignments = alignments\n",
                "\n",
                "        kwargs = {}\n",
                "        if alignments.version < 2.1:\n",
                "            # Update headers of faces generated with hash based alignments\n",
                "            kwargs[\"alignments\"] = alignments\n",
                "        if faces:\n",
                "            self._faces = faces\n",
                "        else:\n",
                "            assert arguments is not None\n",
                "            self._faces = Faces(arguments.faces_dir, **kwargs)  # type:ignore  # needs TypedDict :/\n",
                "        logger.debug(\"Initialized %s\", self.__class__.__name__)\n",
                "\n",
                "    def process(self) -> None:\n",
                "        \"\"\" Process the face renaming \"\"\"\n",
                "        logger.info(\"[RENAME FACES]\")  # Tidy up cli output\n",
                "        filelist = cast(List[Tuple[str, \"PNGHeaderDict\"]], self._faces.file_list_sorted)\n",
                "        rename_mappings = sorted([(face[0], face[1][\"source\"][\"original_filename\"])\n",
                "                                  for face in filelist\n",
                "                                  if face[0] != face[1][\"source\"][\"original_filename\"]],\n",
                "                                 key=lambda x: x[1])\n",
                "        rename_count = self._rename_faces(rename_mappings)\n",
                "        logger.info(\"%s faces renamed\", rename_count)\n",
                "\n",
                "        filelist = cast(List[Tuple[str, \"PNGHeaderDict\"]], self._faces.file_list_sorted)\n",
                "        copyback = FaceToFile(self._alignments, [val[1] for val in filelist])\n",
                "        if copyback():\n",
                "            self._alignments.save()\n",
                "\n",
                "    def _rename_faces(self, filename_mappings: List[Tuple[str, str]]) -> int:\n",
                "        \"\"\" Rename faces back to their original name as exists in the alignments file.\n",
                "\n",
                "        If the source and destination filename are the same then skip that file.\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        filename_mappings: list\n",
                "            List of tuples of (`source filename`, `destination filename`) ordered by destination\n",
                "            filename\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        int\n",
                "            The number of faces that have been renamed\n",
                "        \"\"\"\n",
                "        if not filename_mappings:\n",
                "            return 0\n",
                "\n",
                "        rename_count = 0\n",
                "        conflicts = []\n",
                "        for src, dst in tqdm(filename_mappings, desc=\"Renaming Faces\", leave=False):\n",
                "            old = os.path.join(self._faces.folder, src)\n",
                "            new = os.path.join(self._faces.folder, dst)\n",
                "\n",
                "            if os.path.exists(new):\n",
                "                # Interim add .tmp extension to files that will cause a rename conflict, to\n",
                "                # process afterwards\n",
                "                logger.debug(\"interim renaming file to avoid conflict: (src: '%s', dst: '%s')\",\n",
                "                             src, dst)\n",
                "                new = new + \".tmp\"\n",
                "                conflicts.append(new)\n",
                "\n",
                "            logger.verbose(\"Renaming '%s' to '%s'\", old, new)  # type:ignore\n",
                "            os.rename(old, new)\n",
                "            rename_count += 1\n",
                "        if conflicts:\n",
                "            for old in tqdm(conflicts, desc=\"Renaming Faces\", leave=False):\n",
                "                new = old[:-4]  # Remove .tmp extension\n",
                "                if os.path.exists(new):\n",
                "                    # This should only be running on faces. If there is still a conflict\n",
                "                    # then the user has done something stupid, so we will delete the file and\n",
                "                    # replace. They can always re-extract :/\n",
                "                    os.remove(new)\n",
                "                logger.verbose(\"Renaming '%s' to '%s'\", old, new)  # type:ignore\n",
                "                os.rename(old, new)\n",
                "        return rename_count\n",
                "\n",
                "\n",
                "class RemoveFaces():  # pylint:disable=too-few-public-methods\n",
                "    \"\"\" Remove items from alignments file.\n",
                "\n",
                "    Parameters\n",
                "    ---------\n",
                "    alignments: :class:`tools.alignments.media.AlignmentsData`\n",
                "        The loaded alignments containing faces to be removed\n",
                "    arguments: :class:`argparse.Namespace`\n",
                "        The command line arguments that have called this job\n",
                "    \"\"\"\n",
                "    def __init__(self, alignments: \"AlignmentData\", arguments: Namespace) -> None:\n",
                "        logger.debug(\"Initializing %s: (arguments: %s)\", self.__class__.__name__, arguments)\n",
                "        self._alignments = alignments\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        kwargs = {}\n",
                    "        if alignments.version < 2.1:\n",
                    "            # Update headers of faces generated with hash based alignments\n",
                    "            kwargs[\"alignments\"] = alignments\n",
                    "        self._items = Faces(arguments.faces_dir, **kwargs)  # type:ignore  # needs TypedDict :/\n"
                ],
                "after": [
                    "        self._items = Faces(arguments.faces_dir, alignments=alignments)\n"
                ],
                "parent_version_range": {
                    "start": 339,
                    "end": 344
                },
                "child_version_range": {
                    "start": 339,
                    "end": 340
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "RemoveFaces",
                        "signature": "class RemoveFaces():",
                        "at_line": 325
                    },
                    {
                        "type": "function",
                        "name": "__init__",
                        "signature": "def __init__(self, alignments: \"AlignmentData\", arguments: Namespace)->None:",
                        "at_line": 335
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: tools/alignments/jobs_faces.py\nCode:\n           class RemoveFaces():\n               ...\n               def __init__(self, alignments: \"AlignmentData\", arguments: Namespace)->None:\n                   ...\n336 336            logger.debug(\"Initializing %s: (arguments: %s)\", self.__class__.__name__, arguments)\n337 337            self._alignments = alignments\n338 338    \n339      -         kwargs = {}\n340      -         if alignments.version < 2.1:\n341      -             # Update headers of faces generated with hash based alignments\n342      -             kwargs[\"alignments\"] = alignments\n343      -         self._items = Faces(arguments.faces_dir, **kwargs)  # type:ignore  # needs TypedDict :/\n    339  +         self._items = Faces(arguments.faces_dir, alignments=alignments)\n344 340            logger.debug(\"Initialized %s\", self.__class__.__name__)\n345 341    \n346 342        def process(self) -> None:\n         ...\n",
                "file_path": "tools/alignments/jobs_faces.py",
                "identifiers_before": [
                    "Faces",
                    "_items",
                    "alignments",
                    "arguments",
                    "faces_dir",
                    "kwargs",
                    "self",
                    "version"
                ],
                "identifiers_after": [
                    "Faces",
                    "_items",
                    "alignments",
                    "arguments",
                    "faces_dir",
                    "self"
                ],
                "prefix": [
                    "        logger.debug(\"Initializing %s: (arguments: %s)\", self.__class__.__name__, arguments)\n",
                    "        self._alignments = alignments\n",
                    "\n"
                ],
                "suffix": [
                    "        logger.debug(\"Initialized %s\", self.__class__.__name__)\n",
                    "\n",
                    "    def process(self) -> None:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        logger.debug(\"Initialized %s\", self.__class__.__name__)\n",
                "\n",
                "    def process(self) -> None:\n",
                "        \"\"\" Run the job to remove faces from an alignments file that do not exist within a faces\n",
                "        folder. \"\"\"\n",
                "        logger.info(\"[REMOVE FACES FROM ALIGNMENTS]\")  # Tidy up cli output\n",
                "\n",
                "        if not self._items.items:\n",
                "            logger.error(\"No matching faces found in your faces folder. This would remove all \"\n",
                "                         \"faces from your alignments file. Process aborted.\")\n",
                "            return\n",
                "\n",
                "        items = cast(Dict[str, List[int]], self._items.items)\n",
                "        pre_face_count = self._alignments.faces_count\n",
                "        self._alignments.filter_faces(items, filter_out=False)\n",
                "        del_count = pre_face_count - self._alignments.faces_count\n",
                "        if del_count == 0:\n",
                "            logger.info(\"No changes made to alignments file. Exiting\")\n",
                "            return\n",
                "\n",
                "        logger.info(\"%s alignment(s) were removed from alignments file\", del_count)\n",
                "\n",
                "        self._update_png_headers()\n",
                "        self._alignments.save()\n",
                "\n",
                "        rename = Rename(self._alignments, None, self._items)\n",
                "        rename.process()\n",
                "\n",
                "    def _update_png_headers(self) -> None:\n",
                "        \"\"\" Update the EXIF iTXt field of any face PNGs that have had their face index changed.\n",
                "\n",
                "        Notes\n",
                "        -----\n",
                "        This could be quicker if parellizing in threads, however, Windows (at least) does not seem\n",
                "        to like this and has a tendency to throw permission errors, so this remains single threaded\n",
                "        for now.\n",
                "        \"\"\"\n",
                "        items = cast(Dict[str, List[int]], self._items.items)\n",
                "        srcs = [(x[0], x[1][\"source\"])\n",
                "                for x in cast(List[Tuple[str, \"PNGHeaderDict\"]], self._items.file_list_sorted)]\n",
                "        to_update = [  # Items whose face index has changed\n",
                "            x for x in srcs\n",
                "            if x[1][\"face_index\"] != items[x[1][\"source_filename\"]].index(x[1][\"face_index\"])]\n",
                "\n",
                "        for item in tqdm(to_update, desc=\"Updating PNG Headers\", leave=False):\n",
                "            filename, file_info = item\n",
                "            frame = file_info[\"source_filename\"]\n",
                "            face_index = file_info[\"face_index\"]\n",
                "            new_index = items[frame].index(face_index)\n",
                "\n",
                "            fullpath = os.path.join(self._items.folder, filename)\n",
                "            logger.debug(\"Updating png header for '%s': face index from %s to %s\",\n",
                "                         fullpath, face_index, new_index)\n",
                "\n",
                "            # Update file_list_sorted for rename task\n",
                "            orig_filename = f\"{os.path.splitext(frame)[0]}_{new_index}.png\"\n",
                "            file_info[\"face_index\"] = new_index\n",
                "            file_info[\"original_filename\"] = orig_filename\n",
                "\n",
                "            face = DetectedFace()\n",
                "            face.from_alignment(self._alignments.get_faces_in_frame(frame)[new_index])\n",
                "            meta = dict(alignments=face.to_png_meta(),\n",
                "                        source=dict(alignments_version=file_info[\"alignments_version\"],\n",
                "                                    original_filename=orig_filename,\n",
                "                                    face_index=new_index,\n",
                "                                    source_filename=frame,\n",
                "                                    source_is_video=file_info[\"source_is_video\"],\n",
                "                                    source_frame_dims=file_info.get(\"source_frame_dims\")))\n",
                "            update_existing_metadata(fullpath, meta)\n",
                "\n",
                "        logger.info(\"%s Extracted face(s) had their header information updated\", len(to_update))\n",
                "\n",
                "\n",
                "class FaceToFile():  # pylint:disable=too-few-public-methods\n",
                "    \"\"\" Updates any optional/missing keys in the alignments file with any data that has been\n",
                "    populated in a PNGHeader. Includes masks and identity fields.\n",
                "\n",
                "    Parameters\n",
                "    ---------\n",
                "    alignments: :class:`tools.alignments.media.AlignmentsData`\n",
                "        The loaded alignments containing faces to be removed\n",
                "    face_data: list\n",
                "        List of :class:`PNGHeaderDict` objects\n",
                "    \"\"\"\n",
                "    def __init__(self, alignments: \"AlignmentData\", face_data: List[\"PNGHeaderDict\"]) -> None:\n",
                "        logger.debug(\"Initializing %s: alignments: %s, face_data: %s\",\n",
                "                     self.__class__.__name__, alignments, len(face_data))\n",
                "        self._alignments = alignments\n",
                "        self._face_alignments = face_data\n",
                "        self._updatable_keys: List[Literal[\"identity\", \"mask\"]] = [\"identity\", \"mask\"]\n",
                "        self._counts: Dict[str, int] = {}\n",
                "        logger.debug(\"Initialized %s\", self.__class__.__name__)\n",
                "\n",
                "    def _check_and_update(self,\n",
                "                          alignment: \"PNGHeaderAlignmentsDict\",\n",
                "                          face: \"AlignmentFileDict\") -> None:\n",
                "        \"\"\" Check whether the key requires updating and update it.\n",
                "\n",
                "        alignment: dict\n",
                "            The alignment dictionary from the PNG Header\n",
                "        face: dict\n",
                "            The alignment dictionary for the face from the alignments file\n",
                "        \"\"\"\n",
                "        for key in self._updatable_keys:\n",
                "            if key == \"mask\":\n",
                "                exist_masks = face[\"mask\"]\n",
                "                for mask_name, mask_data in alignment[\"mask\"].items():\n",
                "                    if mask_name in exist_masks:\n",
                "                        continue\n",
                "                    exist_masks[mask_name] = mask_data\n",
                "                    count_key = f\"mask_{mask_name}\"\n",
                "                    self._counts[count_key] = self._counts.get(count_key, 0) + 1\n",
                "                continue\n",
                "\n",
                "            if not face.get(key, {}) and alignment.get(key):\n",
                "                face[key] = alignment[key]\n",
                "                self._counts[key] = self._counts.get(key, 0) + 1\n",
                "\n",
                "    def __call__(self) -> bool:\n",
                "        \"\"\" Parse through the face data updating any entries in the alignments file.\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        bool\n",
                "            ``True`` if any alignment information was updated otherwise ``False``\n",
                "        \"\"\"\n",
                "        for meta in tqdm(self._face_alignments,\n",
                "                         desc=\"Updating Alignments File from PNG Header\",\n",
                "                         leave=False):\n",
                "            src = meta[\"source\"]\n",
                "            alignment = meta[\"alignments\"]\n",
                "            if not any(alignment.get(key, {}) for key in self._updatable_keys):\n",
                "                continue\n",
                "\n",
                "            faces = self._alignments.get_faces_in_frame(src[\"source_filename\"])\n",
                "            if len(faces) < src[\"face_index\"] + 1:  # list index out of range\n",
                "                logger.debug(\"Skipped face '%s'. Index does not exist in alignments file\",\n",
                "                             src[\"original_filename\"])\n",
                "                continue\n",
                "\n",
                "            face = faces[src[\"face_index\"]]\n",
                "            self._check_and_update(alignment, face)\n",
                "\n",
                "        retval = False\n",
                "        if self._counts:\n",
                "            retval = True\n",
                "            logger.info(\"Updated alignments file from PNG Data: %s\", self._counts)\n",
                "        return retval"
            ]
        ],
        "tools/alignments/media.py": [
            [
                "#!/usr/bin/env python3\n",
                "\"\"\" Media items (Alignments, Faces, Frames)\n",
                "    for alignments tool \"\"\"\n",
                "\n",
                "import logging\n",
                "from operator import itemgetter\n",
                "import os\n",
                "import sys\n",
                "from typing import cast, Generator, Dict, List, Optional, Tuple, TYPE_CHECKING, Union\n",
                "\n",
                "import cv2\n",
                "from tqdm import tqdm\n",
                "\n",
                "# TODO imageio single frame seek seems slow. Look into this\n",
                "# import imageio\n",
                "\n",
                "from lib.align import Alignments, DetectedFace, update_legacy_png_header\n",
                "from lib.image import (count_frames, generate_thumbnail, ImagesLoader,\n",
                "                       png_write_meta, read_image, read_image_meta_batch)\n",
                "from lib.utils import _image_extensions, _video_extensions, FaceswapError\n",
                "\n",
                "if TYPE_CHECKING:\n",
                "    import numpy as np\n",
                "    from lib.align.alignments import AlignmentFileDict, PNGHeaderDict\n",
                "\n",
                "logger = logging.getLogger(__name__)  # pylint: disable=invalid-name\n",
                "\n",
                "\n",
                "class AlignmentData(Alignments):\n",
                "    \"\"\" Class to hold the alignment data\n",
                "\n",
                "    Parameters\n",
                "    ----------\n",
                "    alignments_file: str\n",
                "        Full path to an alignments file\n",
                "    \"\"\"\n",
                "    def __init__(self, alignments_file: str) -> None:\n",
                "        logger.debug(\"Initializing %s: (alignments file: '%s')\",\n",
                "                     self.__class__.__name__, alignments_file)\n",
                "        logger.info(\"[ALIGNMENT DATA]\")  # Tidy up cli output\n",
                "        folder, filename = self.check_file_exists(alignments_file)\n",
                "        super().__init__(folder, filename=filename)\n",
                "        logger.verbose(\"%s items loaded\", self.frames_count)  # type: ignore\n",
                "        logger.debug(\"Initialized %s\", self.__class__.__name__)\n",
                "\n",
                "    @staticmethod\n",
                "    def check_file_exists(alignments_file: str) -> Tuple[str, str]:\n",
                "        \"\"\" Check the alignments file exists\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        alignments_file: str\n",
                "            Full path to an alignments file\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        folder: str\n",
                "            The full path to the folder containing the alignments file\n",
                "        filename: str\n",
                "            The filename of the alignments file\n",
                "        \"\"\"\n",
                "        folder, filename = os.path.split(alignments_file)\n",
                "        if not os.path.isfile(alignments_file):\n",
                "            logger.error(\"ERROR: alignments file not found at: '%s'\", alignments_file)\n",
                "            sys.exit(0)\n",
                "        if folder:\n",
                "            logger.verbose(\"Alignments file exists at '%s'\", alignments_file)  # type: ignore\n",
                "        return folder, filename\n",
                "\n",
                "    def save(self) -> None:\n",
                "        \"\"\" Backup copy of old alignments and save new alignments \"\"\"\n",
                "        self.backup()\n",
                "        super().save()\n",
                "\n",
                "\n",
                "class MediaLoader():\n",
                "    \"\"\" Class to load images.\n",
                "\n",
                "    Parameters\n",
                "    ----------\n",
                "    folder: str\n",
                "        The folder of images or video file to load images from\n",
                "    count: int or ``None``, optional\n",
                "        If the total frame count is known it can be passed in here which will skip\n",
                "        analyzing a video file. If the count is not passed in, it will be calculated.\n",
                "    \"\"\"\n",
                "    def __init__(self, folder: str, count: Optional[int] = None):\n",
                "        logger.debug(\"Initializing %s: (folder: '%s')\", self.__class__.__name__, folder)\n",
                "        logger.info(\"[%s DATA]\", self.__class__.__name__.upper())\n",
                "        self._count = count\n",
                "        self.folder = folder\n",
                "        self._vid_reader = self.check_input_folder()\n",
                "        self.file_list_sorted = self.sorted_items()\n",
                "        self.items = self.load_items()\n",
                "        logger.verbose(\"%s items loaded\", self.count)  # type: ignore\n",
                "        logger.debug(\"Initialized %s\", self.__class__.__name__)\n",
                "\n",
                "    @property\n",
                "    def is_video(self) -> bool:\n",
                "        \"\"\" bool: Return whether source is a video or not \"\"\"\n",
                "        return self._vid_reader is not None\n",
                "\n",
                "    @property\n",
                "    def count(self) -> int:\n",
                "        \"\"\" int: Number of faces or frames \"\"\"\n",
                "        if self._count is not None:\n",
                "            return self._count\n",
                "        if self.is_video:\n",
                "            self._count = int(count_frames(self.folder))\n",
                "        else:\n",
                "            self._count = len(self.file_list_sorted)\n",
                "        return self._count\n",
                "\n",
                "    def check_input_folder(self) -> Optional[cv2.VideoCapture]:\n",
                "        \"\"\" makes sure that the frames or faces folder exists\n",
                "            If frames folder contains a video file return imageio reader object\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        :class:`cv2.VideoCapture`\n",
                "            Object for reading a video stream\n",
                "        \"\"\"\n",
                "        err = None\n",
                "        loadtype = self.__class__.__name__\n",
                "        if not self.folder:\n",
                "            err = f\"ERROR: A {loadtype} folder must be specified\"\n",
                "        elif not os.path.exists(self.folder):\n",
                "            err = f\"ERROR: The {loadtype} location {self.folder} could not be found\"\n",
                "        if err:\n",
                "            logger.error(err)\n",
                "            sys.exit(0)\n",
                "\n",
                "        if (loadtype == \"Frames\" and\n",
                "                os.path.isfile(self.folder) and\n",
                "                os.path.splitext(self.folder)[1].lower() in _video_extensions):\n",
                "            logger.verbose(\"Video exists at: '%s'\", self.folder)  # type: ignore\n",
                "            retval = cv2.VideoCapture(self.folder)  # pylint: disable=no-member\n",
                "            # TODO ImageIO single frame seek seems slow. Look into this\n",
                "            # retval = imageio.get_reader(self.folder, \"ffmpeg\")\n",
                "        else:\n",
                "            logger.verbose(\"Folder exists at '%s'\", self.folder)  # type: ignore\n",
                "            retval = None\n",
                "        return retval\n",
                "\n",
                "    @staticmethod\n",
                "    def valid_extension(filename) -> bool:\n",
                "        \"\"\" bool: Check whether passed in file has a valid extension \"\"\"\n",
                "        extension = os.path.splitext(filename)[1]\n",
                "        retval = extension.lower() in _image_extensions\n",
                "        logger.trace(\"Filename has valid extension: '%s': %s\", filename, retval)  # type: ignore\n",
                "        return retval\n",
                "\n",
                "    def sorted_items(self) -> Union[List[Dict[str, str]],\n",
                "                                    List[Tuple[str, \"PNGHeaderDict\"]]]:\n",
                "        \"\"\" Override for specific folder processing \"\"\"\n",
                "        raise NotImplementedError()\n",
                "\n",
                "    def process_folder(self) -> Union[Generator[Dict[str, str], None, None],\n",
                "                                      Generator[Tuple[str, \"PNGHeaderDict\"], None, None]]:\n",
                "        \"\"\" Override for specific folder processing \"\"\"\n",
                "        raise NotImplementedError()\n",
                "\n",
                "    def load_items(self) -> Union[Dict[str, List[int]],\n",
                "                                  Dict[str, Tuple[str, str]]]:\n",
                "        \"\"\" Override for specific item loading \"\"\"\n",
                "        raise NotImplementedError()\n",
                "\n",
                "    def load_image(self, filename: str) -> \"np.ndarray\":\n",
                "        \"\"\" Load an image\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        filename: str\n",
                "            The filename of the image to load\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        :class:`numpy.ndarray`\n",
                "            The loaded image\n",
                "        \"\"\"\n",
                "        if self.is_video:\n",
                "            image = self.load_video_frame(filename)\n",
                "        else:\n",
                "            src = os.path.join(self.folder, filename)\n",
                "            logger.trace(\"Loading image: '%s'\", src)  # type: ignore\n",
                "            image = read_image(src, raise_error=True)\n",
                "        return image\n",
                "\n",
                "    def load_video_frame(self, filename: str) -> \"np.ndarray\":\n",
                "        \"\"\" Load a requested frame from video\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        filename: str\n",
                "            The frame name to load\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        :class:`numpy.ndarray`\n",
                "            The loaded image\n",
                "        \"\"\"\n",
                "        assert self._vid_reader is not None\n",
                "        frame = os.path.splitext(filename)[0]\n",
                "        logger.trace(\"Loading video frame: '%s'\", frame)  # type: ignore\n",
                "        frame_no = int(frame[frame.rfind(\"_\") + 1:]) - 1\n",
                "        self._vid_reader.set(cv2.CAP_PROP_POS_FRAMES, frame_no)  # pylint: disable=no-member\n",
                "        _, image = self._vid_reader.read()\n",
                "        # TODO imageio single frame seek seems slow. Look into this\n",
                "        # self._vid_reader.set_image_index(frame_no)\n",
                "        # image = self._vid_reader.get_next_data()[:, :, ::-1]\n",
                "        return image\n",
                "\n",
                "    def stream(self, skip_list: Optional[List[int]] = None\n",
                "               ) -> Generator[Tuple[str, \"np.ndarray\"], None, None]:\n",
                "        \"\"\" Load the images in :attr:`folder` in the order they are received from\n",
                "        :class:`lib.image.ImagesLoader` in a background thread.\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        skip_list: list, optional\n",
                "            A list of frame indices that should not be loaded. Pass ``None`` if all images should\n",
                "            be loaded. Default: ``None``\n",
                "\n",
                "        Yields\n",
                "        ------\n",
                "        str\n",
                "            The filename of the image that is being returned\n",
                "        numpy.ndarray\n",
                "            The image that has been loaded from disk\n",
                "        \"\"\"\n",
                "        loader = ImagesLoader(self.folder, queue_size=32, count=self._count)\n",
                "        if skip_list is not None:\n",
                "            loader.add_skip_list(skip_list)\n",
                "        for filename, image in loader.load():\n",
                "            yield filename, image\n",
                "\n",
                "    @staticmethod\n",
                "    def save_image(output_folder: str,\n",
                "                   filename: str,\n",
                "                   image: \"np.ndarray\",\n",
                "                   metadata: Optional[\"PNGHeaderDict\"] = None) -> None:\n",
                "        \"\"\" Save an image \"\"\"\n",
                "        output_file = os.path.join(output_folder, filename)\n",
                "        output_file = os.path.splitext(output_file)[0] + \".png\"\n",
                "        logger.trace(\"Saving image: '%s'\", output_file)  # type: ignore\n",
                "        if metadata:\n",
                "            encoded_image = cv2.imencode(\".png\", image)[1]\n",
                "            encoded_image = png_write_meta(encoded_image.tobytes(), metadata)\n",
                "            with open(output_file, \"wb\") as out_file:\n",
                "                out_file.write(encoded_image)\n",
                "        else:\n",
                "            cv2.imwrite(output_file, image)  # pylint: disable=no-member\n",
                "\n",
                "\n",
                "class Faces(MediaLoader):\n",
                "    \"\"\" Object to load Extracted Faces from a folder.\n",
                "\n",
                "    Parameters\n",
                "    ----------\n",
                "    folder: str\n",
                "        The folder to load faces from\n",
                "    alignments: :class:`lib.align.Alignments`, optional\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        The alignments object that contains the faces. Used to update legacy hash based faces\n",
                    "        for <v2.1 alignments to png header based version. Pass in ``None`` to not update legacy\n",
                    "        faces (raises error instead). Default: ``None``\n"
                ],
                "after": [
                    "        The alignments object that contains the faces. This can be used for 2 purposes:\n",
                    "        - To update legacy hash based faces for <v2.1 alignments to png header based version.\n",
                    "        - When the remove-faces job is being run, when the process will only load faces that exist\n",
                    "        in the alignments file. Default: ``None``\n"
                ],
                "parent_version_range": {
                    "start": 262,
                    "end": 265
                },
                "child_version_range": {
                    "start": 262,
                    "end": 266
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Faces",
                        "signature": "class Faces(MediaLoader):",
                        "at_line": 254
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: tools/alignments/media.py\nCode:\n           class Faces(MediaLoader):\n               ...\n259 259        folder: str\n260 260            The folder to load faces from\n261 261        alignments: :class:`lib.align.Alignments`, optional\n262      -         The alignments object that contains the faces. Used to update legacy hash based faces\n263      -         for <v2.1 alignments to png header based version. Pass in ``None`` to not update legacy\n264      -         faces (raises error instead). Default: ``None``\n    262  +         The alignments object that contains the faces. This can be used for 2 purposes:\n    263  +         - To update legacy hash based faces for <v2.1 alignments to png header based version.\n    264  +         - When the remove-faces job is being run, when the process will only load faces that exist\n    265  +         in the alignments file. Default: ``None``\n265 266        \"\"\"\n266 267        def __init__(self, folder: str, alignments: Optional[Alignments] = None) -> None:\n267 268            self._alignments = alignments\n         ...\n",
                "file_path": "tools/alignments/media.py",
                "identifiers_before": [
                    "Default",
                    "None",
                    "Pass",
                    "The",
                    "Used",
                    "alignments",
                    "based",
                    "contains",
                    "error",
                    "faces",
                    "hash",
                    "header",
                    "instead",
                    "legacy",
                    "object",
                    "png",
                    "raises",
                    "that",
                    "the",
                    "to",
                    "update",
                    "v2",
                    "version"
                ],
                "identifiers_after": [
                    "Default",
                    "None",
                    "The",
                    "This",
                    "To",
                    "When",
                    "alignments",
                    "based",
                    "be",
                    "being",
                    "can",
                    "contains",
                    "exist",
                    "faces",
                    "file",
                    "hash",
                    "header",
                    "job",
                    "legacy",
                    "load",
                    "object",
                    "only",
                    "png",
                    "process",
                    "purposes",
                    "remove",
                    "run",
                    "that",
                    "the",
                    "to",
                    "update",
                    "used",
                    "v2",
                    "version",
                    "when",
                    "will"
                ],
                "prefix": [
                    "    folder: str\n",
                    "        The folder to load faces from\n",
                    "    alignments: :class:`lib.align.Alignments`, optional\n"
                ],
                "suffix": [
                    "    \"\"\"\n",
                    "    def __init__(self, folder: str, alignments: Optional[Alignments] = None) -> None:\n",
                    "        self._alignments = alignments\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    \"\"\"\n",
                "    def __init__(self, folder: str, alignments: Optional[Alignments] = None) -> None:\n",
                "        self._alignments = alignments\n",
                "        super().__init__(folder)\n",
                "\n",
                "    def process_folder(self) -> Generator[Tuple[str, \"PNGHeaderDict\"], None, None]:\n",
                "        \"\"\" Iterate through the faces folder pulling out various information for each face.\n",
                "\n",
                "        Yields\n",
                "        ------\n",
                "        dict\n",
                "            A dictionary for each face found containing the keys returned from\n",
                "            :class:`lib.image.read_image_meta_batch`\n",
                "        \"\"\"\n",
                "        logger.info(\"Loading file list from %s\", self.folder)\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        is_legacy = self._alignments is not None and self._alignments.version < 2.1\n",
                    "        filter_count = 0\n"
                ],
                "parent_version_range": {
                    "start": 280,
                    "end": 280
                },
                "child_version_range": {
                    "start": 281,
                    "end": 283
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Faces",
                        "signature": "class Faces(MediaLoader):",
                        "at_line": 254
                    },
                    {
                        "type": "function",
                        "name": "process_folder",
                        "signature": "def process_folder(self)->Generator[Tuple[str, \"PNGHeaderDict\"], None, None]:",
                        "at_line": 270
                    },
                    {
                        "type": "call",
                        "name": "logger.info",
                        "signature": "logger.info(\"Loading file list from %s\", self.folder)",
                        "at_line": 279,
                        "argument": "\"Loading file list from %s\""
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: tools/alignments/media.py\nCode:\n           class Faces(MediaLoader):\n               ...\n               def process_folder(self)->Generator[Tuple[str, \"PNGHeaderDict\"], None, None]:\n                   ...\n277 278                :class:`lib.image.read_image_meta_batch`\n278 279            \"\"\"\n279 280            logger.info(\"Loading file list from %s\", self.folder)\n    281  +         is_legacy = self._alignments is not None and self._alignments.version < 2.1\n    282  +         filter_count = 0\n280 283    \n         ...\n",
                "file_path": "tools/alignments/media.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "_alignments",
                    "filter_count",
                    "is_legacy",
                    "self",
                    "version"
                ],
                "prefix": [
                    "            :class:`lib.image.read_image_meta_batch`\n",
                    "        \"\"\"\n",
                    "        logger.info(\"Loading file list from %s\", self.folder)\n"
                ],
                "suffix": [
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "is_legacy",
                            "position": {
                                "start": {
                                    "line": 281,
                                    "column": 8
                                },
                                "end": {
                                    "line": 281,
                                    "column": 17
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/faceswap/tools/alignments/media.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        if self._alignments is not None:  # Legacy updating\n"
                ],
                "after": [
                    "        if is_legacy:  # Legacy updating\n"
                ],
                "parent_version_range": {
                    "start": 281,
                    "end": 282
                },
                "child_version_range": {
                    "start": 284,
                    "end": 285
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if self._alignments is not None:",
                        "start_line": 281,
                        "end_line": 288
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Faces",
                        "signature": "class Faces(MediaLoader):",
                        "at_line": 254
                    },
                    {
                        "type": "function",
                        "name": "process_folder",
                        "signature": "def process_folder(self)->Generator[Tuple[str, \"PNGHeaderDict\"], None, None]:",
                        "at_line": 270
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: tools/alignments/media.py\nCode:\n           class Faces(MediaLoader):\n               ...\n               def process_folder(self)->Generator[Tuple[str, \"PNGHeaderDict\"], None, None]:\n                   ...\n280 283    \n281      -         if self._alignments is not None:  # Legacy updating\n    284  +         if is_legacy:  # Legacy updating\n282 285                filelist = [os.path.join(self.folder, face)\n283 286                            for face in os.listdir(self.folder)\n284 287                            if self.valid_extension(face)]\n         ...\n",
                "file_path": "tools/alignments/media.py",
                "identifiers_before": [
                    "_alignments",
                    "self"
                ],
                "identifiers_after": [
                    "is_legacy"
                ],
                "prefix": [
                    "\n"
                ],
                "suffix": [
                    "            filelist = [os.path.join(self.folder, face)\n",
                    "                        for face in os.listdir(self.folder)\n",
                    "                        if self.valid_extension(face)]\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "is_legacy",
                            "position": {
                                "start": {
                                    "line": 284,
                                    "column": 11
                                },
                                "end": {
                                    "line": 284,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/faceswap/tools/alignments/media.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "            filelist = [os.path.join(self.folder, face)\n",
                "                        for face in os.listdir(self.folder)\n",
                "                        if self.valid_extension(face)]\n",
                "        else:\n",
                "            filelist = [os.path.join(self.folder, face)\n",
                "                        for face in os.listdir(self.folder)\n",
                "                        if os.path.splitext(face)[-1] == \".png\"]\n",
                "\n",
                "        log_once = False\n",
                "        for fullpath, metadata in tqdm(read_image_meta_batch(filelist),\n",
                "                                       total=len(filelist),\n",
                "                                       desc=\"Reading Face Data\"):\n",
                "\n",
                "            if \"itxt\" not in metadata or \"source\" not in metadata[\"itxt\"]:\n",
                "                if self._alignments is None:  # Can't update legacy\n",
                "                    raise FaceswapError(\n",
                "                        f\"The folder '{self.folder}' contains images that do not include Faceswap \"\n",
                "                        \"metadata.\\nAll images in the provided folder should contain faces \"\n",
                "                        \"generated from Faceswap's extraction process.\\nPlease double check the \"\n",
                "                        \"source and try again.\")\n",
                "\n",
                "                if not log_once:\n",
                "                    logger.warning(\"Legacy faces discovered. These faces will be updated\")\n",
                "                    log_once = True\n",
                "                data = update_legacy_png_header(fullpath, self._alignments)\n",
                "                if not data:\n",
                "                    raise FaceswapError(\n",
                "                        f\"Some of the faces being passed in from '{self.folder}' could not be \"\n",
                "                        f\"matched to the alignments file '{self._alignments.file}'\\nPlease double \"\n",
                "                        \"check your sources and try again.\")\n",
                "                sub_dict = data\n",
                "            else:\n",
                "                sub_dict = cast(\"PNGHeaderDict\", metadata[\"itxt\"])\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "            if (self._alignments is not None and  # filter existing\n",
                    "                    not self._alignments.frame_exists(sub_dict[\"source\"][\"source_filename\"])):\n",
                    "                filter_count += 1\n",
                    "                continue\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 316,
                    "end": 316
                },
                "child_version_range": {
                    "start": 319,
                    "end": 324
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for fullpath, metadata in tqdm(read_image_meta_batch(filelist),\n                                       total=len(filelist),\n                                       desc=\"Reading Face Data\"):",
                        "start_line": 291,
                        "end_line": 317
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Faces",
                        "signature": "class Faces(MediaLoader):",
                        "at_line": 254
                    },
                    {
                        "type": "function",
                        "name": "process_folder",
                        "signature": "def process_folder(self)->Generator[Tuple[str, \"PNGHeaderDict\"], None, None]:",
                        "at_line": 270
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: tools/alignments/media.py\nCode:\n           class Faces(MediaLoader):\n               ...\n               def process_folder(self)->Generator[Tuple[str, \"PNGHeaderDict\"], None, None]:\n                   ...\n313 316                else:\n314 317                    sub_dict = cast(\"PNGHeaderDict\", metadata[\"itxt\"])\n315 318    \n    319  +             if (self._alignments is not None and  # filter existing\n    320  +                     not self._alignments.frame_exists(sub_dict[\"source\"][\"source_filename\"])):\n    321  +                 filter_count += 1\n    322  +                 continue\n    323  + \n316 324                retval = (os.path.basename(fullpath), sub_dict)\n317 325                yield retval\n318 326    \n         ...\n",
                "file_path": "tools/alignments/media.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "_alignments",
                    "filter_count",
                    "frame_exists",
                    "self",
                    "sub_dict"
                ],
                "prefix": [
                    "            else:\n",
                    "                sub_dict = cast(\"PNGHeaderDict\", metadata[\"itxt\"])\n",
                    "\n"
                ],
                "suffix": [
                    "            retval = (os.path.basename(fullpath), sub_dict)\n",
                    "            yield retval\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "            retval = (os.path.basename(fullpath), sub_dict)\n",
                "            yield retval\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        if self._alignments is not None:\n",
                    "            logger.debug(\"Faces filtered out that did not exist in alignments file: %s\",\n",
                    "                         filter_count)\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 319,
                    "end": 319
                },
                "child_version_range": {
                    "start": 327,
                    "end": 331
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "Faces",
                        "signature": "class Faces(MediaLoader):",
                        "at_line": 254
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: tools/alignments/media.py\nCode:\n           class Faces(MediaLoader):\n               ...\n316 324                retval = (os.path.basename(fullpath), sub_dict)\n317 325                yield retval\n318 326    \n    327  +         if self._alignments is not None:\n    328  +             logger.debug(\"Faces filtered out that did not exist in alignments file: %s\",\n    329  +                          filter_count)\n    330  + \n319 331        def load_items(self) -> Dict[str, List[int]]:\n320 332            \"\"\" Load the face names into dictionary.\n321 333    \n         ...\n",
                "file_path": "tools/alignments/media.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "_alignments",
                    "debug",
                    "filter_count",
                    "logger",
                    "self"
                ],
                "prefix": [
                    "            retval = (os.path.basename(fullpath), sub_dict)\n",
                    "            yield retval\n",
                    "\n"
                ],
                "suffix": [
                    "    def load_items(self) -> Dict[str, List[int]]:\n",
                    "        \"\"\" Load the face names into dictionary.\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    def load_items(self) -> Dict[str, List[int]]:\n",
                "        \"\"\" Load the face names into dictionary.\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        dict\n",
                "            The source filename as key with list of face indices for the frame as value\n",
                "        \"\"\"\n",
                "        faces: Dict[str, List[int]] = {}\n",
                "        for face in cast(List[Tuple[str, \"PNGHeaderDict\"]], self.file_list_sorted):\n",
                "            src = face[1][\"source\"]\n",
                "            faces.setdefault(src[\"source_filename\"], []).append(src[\"face_index\"])\n",
                "        logger.trace(faces)  # type: ignore\n",
                "        return faces\n",
                "\n",
                "    def sorted_items(self) -> List[Tuple[str, \"PNGHeaderDict\"]]:\n",
                "        \"\"\" Return the items sorted by the saved file name.\n",
                "\n",
                "        Returns\n",
                "        --------\n",
                "        list\n",
                "            List of `dict` objects for each face found, sorted by the face's current filename\n",
                "        \"\"\"\n",
                "        items = sorted(self.process_folder(), key=itemgetter(0))\n",
                "        logger.trace(items)  # type: ignore\n",
                "        return items\n",
                "\n",
                "\n",
                "class Frames(MediaLoader):\n",
                "    \"\"\" Object to hold the frames that are to be checked against \"\"\"\n",
                "\n",
                "    def process_folder(self) -> Generator[Dict[str, str], None, None]:\n",
                "        \"\"\" Iterate through the frames folder pulling the base filename\n",
                "\n",
                "        Yields\n",
                "        ------\n",
                "        dict\n",
                "            The full framename, the filename and the file extension of the frame\n",
                "        \"\"\"\n",
                "        iterator = self.process_video if self.is_video else self.process_frames\n",
                "        for item in iterator():\n",
                "            yield item\n",
                "\n",
                "    def process_frames(self) -> Generator[Dict[str, str], None, None]:\n",
                "        \"\"\" Process exported Frames\n",
                "\n",
                "        Yields\n",
                "        ------\n",
                "        dict\n",
                "            The full framename, the filename and the file extension of the frame\n",
                "        \"\"\"\n",
                "        logger.info(\"Loading file list from %s\", self.folder)\n",
                "        for frame in os.listdir(self.folder):\n",
                "            if not self.valid_extension(frame):\n",
                "                continue\n",
                "            filename = os.path.splitext(frame)[0]\n",
                "            file_extension = os.path.splitext(frame)[1]\n",
                "\n",
                "            retval = {\"frame_fullname\": frame,\n",
                "                      \"frame_name\": filename,\n",
                "                      \"frame_extension\": file_extension}\n",
                "            logger.trace(retval)  # type: ignore\n",
                "            yield retval\n",
                "\n",
                "    def process_video(self) -> Generator[Dict[str, str], None, None]:\n",
                "        \"\"\"Dummy in frames for video\n",
                "\n",
                "        Yields\n",
                "        ------\n",
                "        dict\n",
                "            The full framename, the filename and the file extension of the frame\n",
                "        \"\"\"\n",
                "        logger.info(\"Loading video frames from %s\", self.folder)\n",
                "        vidname = os.path.splitext(os.path.basename(self.folder))[0]\n",
                "        for i in range(self.count):\n",
                "            idx = i + 1\n",
                "            # Keep filename format for outputted face\n",
                "            filename = f\"{vidname}_{idx:06d}\"\n",
                "            retval = {\"frame_fullname\": f\"{filename}.png\",\n",
                "                      \"frame_name\": filename,\n",
                "                      \"frame_extension\": \".png\"}\n",
                "            logger.trace(retval)  # type: ignore\n",
                "            yield retval\n",
                "\n",
                "    def load_items(self) -> Dict[str, Tuple[str, str]]:\n",
                "        \"\"\" Load the frame info into dictionary\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        dict\n",
                "            Fullname as key, tuple of frame name and extension as value\n",
                "        \"\"\"\n",
                "        frames: Dict[str, Tuple[str, str]] = {}\n",
                "        for frame in cast(List[Dict[str, str]], self.file_list_sorted):\n",
                "            frames[frame[\"frame_fullname\"]] = (frame[\"frame_name\"],\n",
                "                                               frame[\"frame_extension\"])\n",
                "        logger.trace(frames)  # type: ignore\n",
                "        return frames\n",
                "\n",
                "    def sorted_items(self) -> List[Dict[str, str]]:\n",
                "        \"\"\" Return the items sorted by filename\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        list\n",
                "            The sorted list of frame information\n",
                "        \"\"\"\n",
                "        items = sorted(self.process_folder(), key=lambda x: (x[\"frame_name\"]))\n",
                "        logger.trace(items)  # type: ignore\n",
                "        return items\n",
                "\n",
                "\n",
                "class ExtractedFaces():\n",
                "    \"\"\" Holds the extracted faces and matrix for alignments\n",
                "\n",
                "    Parameters\n",
                "    ----------\n",
                "    frames: :class:`Frames`\n",
                "        The frames object to extract faces from\n",
                "    alignments: :class:`AlignmentData`\n",
                "        The alignment data corresponding to the frames\n",
                "    size: int, optional\n",
                "        The extract face size. Default: 512\n",
                "    \"\"\"\n",
                "    def __init__(self, frames: Frames, alignments: AlignmentData, size: int = 512) -> None:\n",
                "        logger.trace(\"Initializing %s: size: %s\",  # type: ignore\n",
                "                     self.__class__.__name__, size)\n",
                "        self.size = size\n",
                "        self.padding = int(size * 0.1875)\n",
                "        self.alignments = alignments\n",
                "        self.frames = frames\n",
                "        self.current_frame: Optional[str] = None\n",
                "        self.faces: List[DetectedFace] = []\n",
                "        logger.trace(\"Initialized %s\", self.__class__.__name__)  # type: ignore\n",
                "\n",
                "    def get_faces(self, frame: str, image: Optional[\"np.ndarray\"] = None) -> None:\n",
                "        \"\"\" Obtain faces and transformed landmarks for each face in a given frame with its\n",
                "        alignments\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        frame: str\n",
                "            The frame name to obtain faces for\n",
                "        image: :class:`numpy.ndarray`, optional\n",
                "            The image to extract the face from, if we already have it, otherwise ``None`` to\n",
                "            load the image. Default: ``None``\n",
                "        \"\"\"\n",
                "        logger.trace(\"Getting faces for frame: '%s'\", frame)  # type: ignore\n",
                "        self.current_frame = None\n",
                "        alignments = self.alignments.get_faces_in_frame(frame)\n",
                "        logger.trace(\"Alignments for frame: (frame: '%s', alignments: %s)\",  # type: ignore\n",
                "                     frame, alignments)\n",
                "        if not alignments:\n",
                "            self.faces = []\n",
                "            return\n",
                "        image = self.frames.load_image(frame) if image is None else image\n",
                "        self.faces = [self.extract_one_face(alignment, image) for alignment in alignments]\n",
                "        self.current_frame = frame\n",
                "\n",
                "    def extract_one_face(self,\n",
                "                         alignment: \"AlignmentFileDict\",\n",
                "                         image: \"np.ndarray\") -> DetectedFace:\n",
                "        \"\"\" Extract one face from image\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        alignment: dict\n",
                "            The alignment for a single face\n",
                "        image: :class:`numpy.ndarray`\n",
                "            The image to extract the face from\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        :class:`~lib.align.DetectedFace`\n",
                "            The detected face object for the given alignment with the aligned face loaded\n",
                "        \"\"\"\n",
                "        logger.trace(\"Extracting one face: (frame: '%s', alignment: %s)\",  # type: ignore\n",
                "                     self.current_frame, alignment)\n",
                "        face = DetectedFace()\n",
                "        face.from_alignment(alignment, image=image)\n",
                "        face.load_aligned(image, size=self.size, centering=\"head\")\n",
                "        face.thumbnail = generate_thumbnail(face.aligned.face, size=80, quality=60)\n",
                "        return face\n",
                "\n",
                "    def get_faces_in_frame(self,\n",
                "                           frame: str,\n",
                "                           update: bool = False,\n",
                "                           image: Optional[\"np.ndarray\"] = None) -> List[DetectedFace]:\n",
                "        \"\"\" Return the faces for the selected frame\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        frame: str\n",
                "            The frame name to get the faces for\n",
                "        update: bool, optional\n",
                "            ``True`` if the faces should be refreshed regardless of current frame. ``False`` to not\n",
                "            force a refresh. Default ``False``\n",
                "        image: :class:`numpy.ndarray`, optional\n",
                "            Image to load faces from if it exists, otherwise ``None`` to load the image.\n",
                "            Default: ``None``\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        list\n",
                "            List of :class:`~lib.align.DetectedFace` objects for the frame, with the aligned face\n",
                "            loaded\n",
                "        \"\"\"\n",
                "        logger.trace(\"frame: '%s', update: %s\", frame, update)  # type: ignore\n",
                "        if self.current_frame != frame or update:\n",
                "            self.get_faces(frame, image=image)\n",
                "        return self.faces\n",
                "\n",
                "    def get_roi_size_for_frame(self, frame: str) -> List[int]:\n",
                "        \"\"\" Return the size of the original extract box for the selected frame.\n",
                "\n",
                "        Parameters\n",
                "        ----------\n",
                "        frame: str\n",
                "            The frame to obtain the original sized bounding boxes for\n",
                "\n",
                "        Returns\n",
                "        -------\n",
                "        list\n",
                "            List of original pixel sizes of faces held within the frame\n",
                "        \"\"\"\n",
                "        logger.trace(\"frame: '%s'\", frame)  # type: ignore\n",
                "        if self.current_frame != frame:\n",
                "            self.get_faces(frame)\n",
                "        sizes = []\n",
                "        for face in self.faces:\n",
                "            roi = face.aligned.original_roi.squeeze()\n",
                "            top_left, top_right = roi[0], roi[3]\n",
                "            len_x = top_right[0] - top_left[0]\n",
                "            len_y = top_right[1] - top_left[1]\n",
                "            if top_left[1] == top_right[1]:\n",
                "                length = len_y\n",
                "            else:\n",
                "                length = int(((len_x ** 2) + (len_y ** 2)) ** 0.5)\n",
                "            sizes.append(length)\n",
                "        logger.trace(\"sizes: '%s'\", sizes)  # type: ignore\n",
                "        return sizes"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "semantic sync"
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "semantic sync"
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                2,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                2,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        }
    ]
}