{
    "language": "python",
    "commit_url": "https://github.com/home-assistant/core/commit/9acca1bf5833cfa000e663f156f13411702c8114",
    "commit_message": "Make modbus retry fast on read errors (#99576)\n\n* Fast retry on read errors.\n\n* Review comments.",
    "commit_snapshots": {
        "homeassistant/components/modbus/base_platform.py": [
            [
                "\"\"\"Base implementation for all modbus platforms.\"\"\"\n",
                "from __future__ import annotations\n",
                "\n",
                "from abc import abstractmethod\n",
                "from collections.abc import Callable\n",
                "from datetime import datetime, timedelta\n",
                "import logging\n",
                "import struct\n",
                "from typing import Any, cast\n",
                "\n",
                "from homeassistant.const import (\n",
                "    CONF_ADDRESS,\n",
                "    CONF_COMMAND_OFF,\n",
                "    CONF_COMMAND_ON,\n",
                "    CONF_COUNT,\n",
                "    CONF_DELAY,\n",
                "    CONF_DEVICE_CLASS,\n",
                "    CONF_NAME,\n",
                "    CONF_OFFSET,\n",
                "    CONF_SCAN_INTERVAL,\n",
                "    CONF_SLAVE,\n",
                "    CONF_STRUCTURE,\n",
                "    CONF_UNIQUE_ID,\n",
                "    STATE_OFF,\n",
                "    STATE_ON,\n",
                ")\n",
                "from homeassistant.core import callback\n",
                "from homeassistant.helpers.dispatcher import async_dispatcher_connect\n",
                "from homeassistant.helpers.entity import Entity, ToggleEntity\n",
                "from homeassistant.helpers.event import async_call_later, async_track_time_interval\n",
                "from homeassistant.helpers.restore_state import RestoreEntity\n",
                "\n",
                "from .const import (\n",
                "    CALL_TYPE_COIL,\n",
                "    CALL_TYPE_DISCRETE,\n",
                "    CALL_TYPE_REGISTER_HOLDING,\n",
                "    CALL_TYPE_REGISTER_INPUT,\n",
                "    CALL_TYPE_WRITE_COIL,\n",
                "    CALL_TYPE_WRITE_COILS,\n",
                "    CALL_TYPE_WRITE_REGISTER,\n",
                "    CALL_TYPE_WRITE_REGISTERS,\n",
                "    CALL_TYPE_X_COILS,\n",
                "    CALL_TYPE_X_REGISTER_HOLDINGS,\n",
                "    CONF_DATA_TYPE,\n",
                "    CONF_INPUT_TYPE,\n",
                "    CONF_LAZY_ERROR,\n",
                "    CONF_MAX_VALUE,\n",
                "    CONF_MIN_VALUE,\n",
                "    CONF_NAN_VALUE,\n",
                "    CONF_PRECISION,\n",
                "    CONF_SCALE,\n",
                "    CONF_SLAVE_COUNT,\n",
                "    CONF_STATE_OFF,\n",
                "    CONF_STATE_ON,\n",
                "    CONF_SWAP,\n",
                "    CONF_SWAP_BYTE,\n",
                "    CONF_SWAP_NONE,\n",
                "    CONF_SWAP_WORD,\n",
                "    CONF_SWAP_WORD_BYTE,\n",
                "    CONF_VERIFY,\n",
                "    CONF_WRITE_TYPE,\n",
                "    CONF_ZERO_SUPPRESS,\n",
                "    SIGNAL_START_ENTITY,\n",
                "    SIGNAL_STOP_ENTITY,\n",
                "    DataType,\n",
                ")\n",
                "from .modbus import ModbusHub\n",
                "\n",
                "PARALLEL_UPDATES = 1\n",
                "_LOGGER = logging.getLogger(__name__)\n",
                "\n",
                "\n",
                "class BasePlatform(Entity):\n",
                "    \"\"\"Base for readonly platforms.\"\"\"\n",
                "\n",
                "    def __init__(self, hub: ModbusHub, entry: dict[str, Any]) -> None:\n",
                "        \"\"\"Initialize the Modbus binary sensor.\"\"\"\n",
                "        self._hub = hub\n",
                "        self._slave = entry.get(CONF_SLAVE, 0)\n",
                "        self._address = int(entry[CONF_ADDRESS])\n",
                "        self._input_type = entry[CONF_INPUT_TYPE]\n",
                "        self._value: str | None = None\n",
                "        self._scan_interval = int(entry[CONF_SCAN_INTERVAL])\n",
                "        self._call_active = False\n",
                "        self._cancel_timer: Callable[[], None] | None = None\n",
                "        self._cancel_call: Callable[[], None] | None = None\n",
                "\n",
                "        self._attr_unique_id = entry.get(CONF_UNIQUE_ID)\n",
                "        self._attr_name = entry[CONF_NAME]\n",
                "        self._attr_should_poll = False\n",
                "        self._attr_device_class = entry.get(CONF_DEVICE_CLASS)\n",
                "        self._attr_available = True\n",
                "        self._attr_unit_of_measurement = None\n",
                "        self._lazy_error_count = entry[CONF_LAZY_ERROR]\n",
                "        self._lazy_errors = self._lazy_error_count\n",
                "\n",
                "        def get_optional_numeric_config(config_name: str) -> int | float | None:\n",
                "            if (val := entry.get(config_name)) is None:\n",
                "                return None\n",
                "            assert isinstance(\n",
                "                val, (float, int)\n",
                "            ), f\"Expected float or int but {config_name} was {type(val)}\"\n",
                "            return val\n",
                "\n",
                "        self._min_value = get_optional_numeric_config(CONF_MIN_VALUE)\n",
                "        self._max_value = get_optional_numeric_config(CONF_MAX_VALUE)\n",
                "        self._nan_value = entry.get(CONF_NAN_VALUE, None)\n",
                "        self._zero_suppress = get_optional_numeric_config(CONF_ZERO_SUPPRESS)\n",
                "\n",
                "    @abstractmethod\n",
                "    async def async_update(self, now: datetime | None = None) -> None:\n",
                "        \"\"\"Virtual function to be overwritten.\"\"\"\n",
                "\n",
                "    @callback\n",
                "    def async_run(self) -> None:\n",
                "        \"\"\"Remote start entity.\"\"\"\n",
                "        self.async_hold(update=False)\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        self._cancel_call = async_call_later(self.hass, 1, self.async_update)\n"
                ],
                "after": [
                    "        self._cancel_call = async_call_later(\n",
                    "            self.hass, timedelta(milliseconds=100), self.async_update\n",
                    "        )\n"
                ],
                "parent_version_range": {
                    "start": 117,
                    "end": 118
                },
                "child_version_range": {
                    "start": 117,
                    "end": 120
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "BasePlatform",
                        "signature": "class BasePlatform(Entity):",
                        "at_line": 72
                    },
                    {
                        "type": "function",
                        "name": "async_run",
                        "signature": "def async_run(self)->None:",
                        "at_line": 114
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: homeassistant/components/modbus/base_platform.py\nCode:\n           class BasePlatform(Entity):\n               ...\n114 114        def async_run(self) -> None:\n115 115            \"\"\"Remote start entity.\"\"\"\n116 116            self.async_hold(update=False)\n117      -         self._cancel_call = async_call_later(self.hass, 1, self.async_update)\n    117  +         self._cancel_call = async_call_later(\n    118  +             self.hass, timedelta(milliseconds=100), self.async_update\n    119  +         )\n118 120            if self._scan_interval > 0:\n119 121                self._cancel_timer = async_track_time_interval(\n120 122                    self.hass, self.async_update, timedelta(seconds=self._scan_interval)\n         ...\n",
                "file_path": "homeassistant/components/modbus/base_platform.py",
                "identifiers_before": [
                    "_cancel_call",
                    "async_call_later",
                    "async_update",
                    "hass",
                    "self"
                ],
                "identifiers_after": [
                    "_cancel_call",
                    "async_call_later",
                    "async_update",
                    "hass",
                    "milliseconds",
                    "self",
                    "timedelta"
                ],
                "prefix": [
                    "    def async_run(self) -> None:\n",
                    "        \"\"\"Remote start entity.\"\"\"\n",
                    "        self.async_hold(update=False)\n"
                ],
                "suffix": [
                    "        if self._scan_interval > 0:\n",
                    "            self._cancel_timer = async_track_time_interval(\n",
                    "                self.hass, self.async_update, timedelta(seconds=self._scan_interval)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        if self._scan_interval > 0:\n",
                "            self._cancel_timer = async_track_time_interval(\n",
                "                self.hass, self.async_update, timedelta(seconds=self._scan_interval)\n",
                "            )\n",
                "        self._attr_available = True\n",
                "        self.async_write_ha_state()\n",
                "\n",
                "    @callback\n",
                "    def async_hold(self, update: bool = True) -> None:\n",
                "        \"\"\"Remote stop entity.\"\"\"\n",
                "        if self._cancel_call:\n",
                "            self._cancel_call()\n",
                "            self._cancel_call = None\n",
                "        if self._cancel_timer:\n",
                "            self._cancel_timer()\n",
                "            self._cancel_timer = None\n",
                "        if update:\n",
                "            self._attr_available = False\n",
                "            self.async_write_ha_state()\n",
                "\n",
                "    async def async_base_added_to_hass(self) -> None:\n",
                "        \"\"\"Handle entity which will be added.\"\"\"\n",
                "        self.async_run()\n",
                "        self.async_on_remove(\n",
                "            async_dispatcher_connect(self.hass, SIGNAL_STOP_ENTITY, self.async_hold)\n",
                "        )\n",
                "        self.async_on_remove(\n",
                "            async_dispatcher_connect(self.hass, SIGNAL_START_ENTITY, self.async_run)\n",
                "        )\n",
                "\n",
                "\n",
                "class BaseStructPlatform(BasePlatform, RestoreEntity):\n",
                "    \"\"\"Base class representing a sensor/climate.\"\"\"\n",
                "\n",
                "    def __init__(self, hub: ModbusHub, config: dict) -> None:\n",
                "        \"\"\"Initialize the switch.\"\"\"\n",
                "        super().__init__(hub, config)\n",
                "        self._swap = config[CONF_SWAP]\n",
                "        if self._swap == CONF_SWAP_NONE:\n",
                "            self._swap = None\n",
                "        self._data_type = config[CONF_DATA_TYPE]\n",
                "        self._structure: str = config[CONF_STRUCTURE]\n",
                "        self._precision = config[CONF_PRECISION]\n",
                "        self._scale = config[CONF_SCALE]\n",
                "        if self._scale < 1 and not self._precision:\n",
                "            self._precision = 2\n",
                "        self._offset = config[CONF_OFFSET]\n",
                "        self._slave_count = config.get(CONF_SLAVE_COUNT, 0)\n",
                "        self._slave_size = self._count = config[CONF_COUNT]\n",
                "\n",
                "    def _swap_registers(self, registers: list[int], slave_count: int) -> list[int]:\n",
                "        \"\"\"Do swap as needed.\"\"\"\n",
                "        if slave_count:\n",
                "            swapped = []\n",
                "            for i in range(0, self._slave_count + 1):\n",
                "                inx = i * self._slave_size\n",
                "                inx2 = inx + self._slave_size\n",
                "                swapped.extend(self._swap_registers(registers[inx:inx2], 0))\n",
                "            return swapped\n",
                "        if self._swap in (CONF_SWAP_BYTE, CONF_SWAP_WORD_BYTE):\n",
                "            # convert [12][34] --> [21][43]\n",
                "            for i, register in enumerate(registers):\n",
                "                registers[i] = int.from_bytes(\n",
                "                    register.to_bytes(2, byteorder=\"little\"),\n",
                "                    byteorder=\"big\",\n",
                "                    signed=False,\n",
                "                )\n",
                "        if self._swap in (CONF_SWAP_WORD, CONF_SWAP_WORD_BYTE):\n",
                "            # convert [12][34] ==> [34][12]\n",
                "            registers.reverse()\n",
                "        return registers\n",
                "\n",
                "    def __process_raw_value(self, entry: float | int | str) -> float | int | str | None:\n",
                "        \"\"\"Process value from sensor with NaN handling, scaling, offset, min/max etc.\"\"\"\n",
                "        if self._nan_value and entry in (self._nan_value, -self._nan_value):\n",
                "            return None\n",
                "        val: float | int = self._scale * entry + self._offset\n",
                "        if self._min_value is not None and val < self._min_value:\n",
                "            return self._min_value\n",
                "        if self._max_value is not None and val > self._max_value:\n",
                "            return self._max_value\n",
                "        if self._zero_suppress is not None and abs(val) <= self._zero_suppress:\n",
                "            return 0\n",
                "        return val\n",
                "\n",
                "    def unpack_structure_result(self, registers: list[int]) -> str | None:\n",
                "        \"\"\"Convert registers to proper result.\"\"\"\n",
                "\n",
                "        if self._swap:\n",
                "            registers = self._swap_registers(registers, self._slave_count)\n",
                "        byte_string = b\"\".join([x.to_bytes(2, byteorder=\"big\") for x in registers])\n",
                "        if self._data_type == DataType.STRING:\n",
                "            return byte_string.decode()\n",
                "\n",
                "        try:\n",
                "            val = struct.unpack(self._structure, byte_string)\n",
                "        except struct.error as err:\n",
                "            recv_size = len(registers) * 2\n",
                "            msg = f\"Received {recv_size} bytes, unpack error {err}\"\n",
                "            _LOGGER.error(msg)\n",
                "            return None\n",
                "        # Issue: https://github.com/home-assistant/core/issues/41944\n",
                "        # If unpack() returns a tuple greater than 1, don't try to process the value.\n",
                "        # Instead, return the values of unpack(...) separated by commas.\n",
                "        if len(val) > 1:\n",
                "            # Apply scale, precision, limits to floats and ints\n",
                "            v_result = []\n",
                "            for entry in val:\n",
                "                v_temp = self.__process_raw_value(entry)\n",
                "\n",
                "                # We could convert int to float, and the code would still work; however\n",
                "                # we lose some precision, and unit tests will fail. Therefore, we do\n",
                "                # the conversion only when it's absolutely necessary.\n",
                "                if isinstance(v_temp, int) and self._precision == 0:\n",
                "                    v_result.append(str(v_temp))\n",
                "                elif v_temp is None:\n",
                "                    v_result.append(\"\")  # pragma: no cover\n",
                "                elif v_temp != v_temp:  # noqa: PLR0124\n",
                "                    # NaN float detection replace with None\n",
                "                    v_result.append(\"nan\")  # pragma: no cover\n",
                "                else:\n",
                "                    v_result.append(f\"{float(v_temp):.{self._precision}f}\")\n",
                "            return \",\".join(map(str, v_result))\n",
                "\n",
                "        # Apply scale, precision, limits to floats and ints\n",
                "        val_result = self.__process_raw_value(val[0])\n",
                "\n",
                "        # We could convert int to float, and the code would still work; however\n",
                "        # we lose some precision, and unit tests will fail. Therefore, we do\n",
                "        # the conversion only when it's absolutely necessary.\n",
                "\n",
                "        if val_result is None:\n",
                "            return None\n",
                "        # NaN float detection replace with None\n",
                "        if val_result != val_result:  # noqa: PLR0124\n",
                "            return None  # pragma: no cover\n",
                "        if isinstance(val_result, int) and self._precision == 0:\n",
                "            return str(val_result)\n",
                "        if isinstance(val_result, str):\n",
                "            if val_result == \"nan\":\n",
                "                val_result = None  # pragma: no cover\n",
                "            return val_result\n",
                "        return f\"{float(val_result):.{self._precision}f}\"\n",
                "\n",
                "\n",
                "class BaseSwitch(BasePlatform, ToggleEntity, RestoreEntity):\n",
                "    \"\"\"Base class representing a Modbus switch.\"\"\"\n",
                "\n",
                "    def __init__(self, hub: ModbusHub, config: dict) -> None:\n",
                "        \"\"\"Initialize the switch.\"\"\"\n",
                "        config[CONF_INPUT_TYPE] = \"\"\n",
                "        super().__init__(hub, config)\n",
                "        self._attr_is_on = False\n",
                "        convert = {\n",
                "            CALL_TYPE_REGISTER_HOLDING: (\n",
                "                CALL_TYPE_REGISTER_HOLDING,\n",
                "                CALL_TYPE_WRITE_REGISTER,\n",
                "            ),\n",
                "            CALL_TYPE_DISCRETE: (\n",
                "                CALL_TYPE_DISCRETE,\n",
                "                None,\n",
                "            ),\n",
                "            CALL_TYPE_REGISTER_INPUT: (\n",
                "                CALL_TYPE_REGISTER_INPUT,\n",
                "                None,\n",
                "            ),\n",
                "            CALL_TYPE_COIL: (CALL_TYPE_COIL, CALL_TYPE_WRITE_COIL),\n",
                "            CALL_TYPE_X_COILS: (CALL_TYPE_COIL, CALL_TYPE_WRITE_COILS),\n",
                "            CALL_TYPE_X_REGISTER_HOLDINGS: (\n",
                "                CALL_TYPE_REGISTER_HOLDING,\n",
                "                CALL_TYPE_WRITE_REGISTERS,\n",
                "            ),\n",
                "        }\n",
                "        self._write_type = cast(str, convert[config[CONF_WRITE_TYPE]][1])\n",
                "        self.command_on = config[CONF_COMMAND_ON]\n",
                "        self._command_off = config[CONF_COMMAND_OFF]\n",
                "        if CONF_VERIFY in config:\n",
                "            if config[CONF_VERIFY] is None:\n",
                "                config[CONF_VERIFY] = {}\n",
                "            self._verify_active = True\n",
                "            self._verify_delay = config[CONF_VERIFY].get(CONF_DELAY, 0)\n",
                "            self._verify_address = config[CONF_VERIFY].get(\n",
                "                CONF_ADDRESS, config[CONF_ADDRESS]\n",
                "            )\n",
                "            self._verify_type = convert[\n",
                "                config[CONF_VERIFY].get(CONF_INPUT_TYPE, config[CONF_WRITE_TYPE])\n",
                "            ][0]\n",
                "            self._state_on = config[CONF_VERIFY].get(CONF_STATE_ON, self.command_on)\n",
                "            self._state_off = config[CONF_VERIFY].get(CONF_STATE_OFF, self._command_off)\n",
                "        else:\n",
                "            self._verify_active = False\n",
                "\n",
                "    async def async_added_to_hass(self) -> None:\n",
                "        \"\"\"Handle entity which will be added.\"\"\"\n",
                "        await self.async_base_added_to_hass()\n",
                "        if state := await self.async_get_last_state():\n",
                "            if state.state == STATE_ON:\n",
                "                self._attr_is_on = True\n",
                "            elif state.state == STATE_OFF:\n",
                "                self._attr_is_on = False\n",
                "\n",
                "    async def async_turn(self, command: int) -> None:\n",
                "        \"\"\"Evaluate switch result.\"\"\"\n",
                "        result = await self._hub.async_pb_call(\n",
                "            self._slave, self._address, command, self._write_type\n",
                "        )\n",
                "        if result is None:\n",
                "            self._attr_available = False\n",
                "            self.async_write_ha_state()\n",
                "            return\n",
                "\n",
                "        self._attr_available = True\n",
                "        if not self._verify_active:\n",
                "            self._attr_is_on = command == self.command_on\n",
                "            self.async_write_ha_state()\n",
                "            return\n",
                "\n",
                "        if self._verify_delay:\n",
                "            async_call_later(self.hass, self._verify_delay, self.async_update)\n",
                "        else:\n",
                "            await self.async_update()\n",
                "\n",
                "    async def async_turn_off(self, **kwargs: Any) -> None:\n",
                "        \"\"\"Set switch off.\"\"\"\n",
                "        await self.async_turn(self._command_off)\n",
                "\n",
                "    async def async_update(self, now: datetime | None = None) -> None:\n",
                "        \"\"\"Update the entity state.\"\"\"\n",
                "        # remark \"now\" is a dummy parameter to avoid problems with\n",
                "        # async_track_time_interval\n",
                "        if not self._verify_active:\n",
                "            self._attr_available = True\n",
                "            self.async_write_ha_state()\n",
                "            return\n",
                "\n",
                "        # do not allow multiple active calls to the same platform\n",
                "        if self._call_active:\n",
                "            return\n",
                "        self._call_active = True\n",
                "        result = await self._hub.async_pb_call(\n",
                "            self._slave, self._verify_address, 1, self._verify_type\n",
                "        )\n",
                "        self._call_active = False\n",
                "        if result is None:\n",
                "            if self._lazy_errors:\n",
                "                self._lazy_errors -= 1\n",
                "                return\n",
                "            self._lazy_errors = self._lazy_error_count\n",
                "            self._attr_available = False\n",
                "            self.async_write_ha_state()\n",
                "            return\n",
                "\n",
                "        self._lazy_errors = self._lazy_error_count\n",
                "        self._attr_available = True\n",
                "        if self._verify_type in (CALL_TYPE_COIL, CALL_TYPE_DISCRETE):\n",
                "            self._attr_is_on = bool(result.bits[0] & 1)\n",
                "        else:\n",
                "            value = int(result.registers[0])\n",
                "            if value == self._state_on:\n",
                "                self._attr_is_on = True\n",
                "            elif value == self._state_off:\n",
                "                self._attr_is_on = False\n",
                "            elif value is not None:\n",
                "                _LOGGER.error(\n",
                "                    (\n",
                "                        \"Unexpected response from modbus device slave %s register %s,\"\n",
                "                        \" got 0x%2x\"\n",
                "                    ),\n",
                "                    self._slave,\n",
                "                    self._verify_address,\n",
                "                    value,\n",
                "                )\n",
                "        self.async_write_ha_state()"
            ]
        ],
        "homeassistant/components/modbus/sensor.py": [
            [
                "\"\"\"Support for Modbus Register sensors.\"\"\"\n",
                "from __future__ import annotations\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "from datetime import datetime\n"
                ],
                "after": [
                    "from datetime import datetime, timedelta\n"
                ],
                "parent_version_range": {
                    "start": 3,
                    "end": 4
                },
                "child_version_range": {
                    "start": 3,
                    "end": 4
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 1,
                "hunk_diff": "File: homeassistant/components/modbus/sensor.py\nCode:\n  ...\n0 0    \"\"\"Support for Modbus Register sensors.\"\"\"\n1 1    from __future__ import annotations\n2 2    \n3    - from datetime import datetime\n  3  + from datetime import datetime, timedelta\n4 4    import logging\n5 5    from typing import Any\n6 6    \n     ...\n",
                "file_path": "homeassistant/components/modbus/sensor.py",
                "identifiers_before": [
                    "datetime"
                ],
                "identifiers_after": [
                    "datetime",
                    "timedelta"
                ],
                "prefix": [
                    "\"\"\"Support for Modbus Register sensors.\"\"\"\n",
                    "from __future__ import annotations\n",
                    "\n"
                ],
                "suffix": [
                    "import logging\n",
                    "from typing import Any\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "timedelta",
                            "position": {
                                "start": {
                                    "line": 3,
                                    "column": 31
                                },
                                "end": {
                                    "line": 3,
                                    "column": 40
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/modbus/sensor.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "import logging\n",
                "from typing import Any\n",
                "\n",
                "from homeassistant.components.sensor import (\n",
                "    CONF_STATE_CLASS,\n",
                "    RestoreSensor,\n",
                "    SensorEntity,\n",
                ")\n",
                "from homeassistant.const import (\n",
                "    CONF_DEVICE_CLASS,\n",
                "    CONF_NAME,\n",
                "    CONF_SENSORS,\n",
                "    CONF_UNIQUE_ID,\n",
                "    CONF_UNIT_OF_MEASUREMENT,\n",
                ")\n",
                "from homeassistant.core import HomeAssistant, callback\n",
                "from homeassistant.helpers.entity_platform import AddEntitiesCallback\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "from homeassistant.helpers.event import async_call_later\n"
                ],
                "parent_version_range": {
                    "start": 21,
                    "end": 21
                },
                "child_version_range": {
                    "start": 21,
                    "end": 22
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 2,
                "hunk_diff": "File: homeassistant/components/modbus/sensor.py\nCode:\n  ...\n18 18    )\n19 19    from homeassistant.core import HomeAssistant, callback\n20 20    from homeassistant.helpers.entity_platform import AddEntitiesCallback\n   21  + from homeassistant.helpers.event import async_call_later\n21 22    from homeassistant.helpers.typing import ConfigType, DiscoveryInfoType\n22 23    from homeassistant.helpers.update_coordinator import (\n23 24        CoordinatorEntity,\n       ...\n",
                "file_path": "homeassistant/components/modbus/sensor.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "async_call_later",
                    "event",
                    "helpers",
                    "homeassistant"
                ],
                "prefix": [
                    ")\n",
                    "from homeassistant.core import HomeAssistant, callback\n",
                    "from homeassistant.helpers.entity_platform import AddEntitiesCallback\n"
                ],
                "suffix": [
                    "from homeassistant.helpers.typing import ConfigType, DiscoveryInfoType\n",
                    "from homeassistant.helpers.update_coordinator import (\n",
                    "    CoordinatorEntity,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "async_call_later",
                            "position": {
                                "start": {
                                    "line": 21,
                                    "column": 40
                                },
                                "end": {
                                    "line": 21,
                                    "column": 56
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/modbus/sensor.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "from homeassistant.helpers.typing import ConfigType, DiscoveryInfoType\n",
                "from homeassistant.helpers.update_coordinator import (\n",
                "    CoordinatorEntity,\n",
                "    DataUpdateCoordinator,\n",
                ")\n",
                "\n",
                "from . import get_hub\n",
                "from .base_platform import BaseStructPlatform\n",
                "from .const import CONF_SLAVE_COUNT\n",
                "from .modbus import ModbusHub\n",
                "\n",
                "_LOGGER = logging.getLogger(__name__)\n",
                "\n",
                "PARALLEL_UPDATES = 1\n",
                "\n",
                "\n",
                "async def async_setup_platform(\n",
                "    hass: HomeAssistant,\n",
                "    config: ConfigType,\n",
                "    async_add_entities: AddEntitiesCallback,\n",
                "    discovery_info: DiscoveryInfoType | None = None,\n",
                ") -> None:\n",
                "    \"\"\"Set up the Modbus sensors.\"\"\"\n",
                "\n",
                "    if discovery_info is None:\n",
                "        return\n",
                "\n",
                "    sensors: list[ModbusRegisterSensor | SlaveSensor] = []\n",
                "    hub = get_hub(hass, discovery_info[CONF_NAME])\n",
                "    for entry in discovery_info[CONF_SENSORS]:\n",
                "        slave_count = entry.get(CONF_SLAVE_COUNT, 0)\n",
                "        sensor = ModbusRegisterSensor(hub, entry, slave_count)\n",
                "        if slave_count > 0:\n",
                "            sensors.extend(await sensor.async_setup_slaves(hass, slave_count, entry))\n",
                "        sensors.append(sensor)\n",
                "    async_add_entities(sensors)\n",
                "\n",
                "\n",
                "class ModbusRegisterSensor(BaseStructPlatform, RestoreSensor, SensorEntity):\n",
                "    \"\"\"Modbus register sensor.\"\"\"\n",
                "\n",
                "    def __init__(\n",
                "        self,\n",
                "        hub: ModbusHub,\n",
                "        entry: dict[str, Any],\n",
                "        slave_count: int,\n",
                "    ) -> None:\n",
                "        \"\"\"Initialize the modbus register sensor.\"\"\"\n",
                "        super().__init__(hub, entry)\n",
                "        if slave_count:\n",
                "            self._count = self._count * (slave_count + 1)\n",
                "        self._coordinator: DataUpdateCoordinator[list[int] | None] | None = None\n",
                "        self._attr_native_unit_of_measurement = entry.get(CONF_UNIT_OF_MEASUREMENT)\n",
                "        self._attr_state_class = entry.get(CONF_STATE_CLASS)\n",
                "        self._attr_device_class = entry.get(CONF_DEVICE_CLASS)\n",
                "\n",
                "    async def async_setup_slaves(\n",
                "        self, hass: HomeAssistant, slave_count: int, entry: dict[str, Any]\n",
                "    ) -> list[SlaveSensor]:\n",
                "        \"\"\"Add slaves as needed (1 read for multiple sensors).\"\"\"\n",
                "\n",
                "        # Add a dataCoordinator for each sensor that have slaves\n",
                "        # this ensures that idx = bit position of value in result\n",
                "        # polling is done with the base class\n",
                "        name = self._attr_name if self._attr_name else \"modbus_sensor\"\n",
                "        self._coordinator = DataUpdateCoordinator(\n",
                "            hass,\n",
                "            _LOGGER,\n",
                "            name=name,\n",
                "        )\n",
                "\n",
                "        slaves: list[SlaveSensor] = []\n",
                "        for idx in range(0, slave_count):\n",
                "            slaves.append(SlaveSensor(self._coordinator, idx, entry))\n",
                "        return slaves\n",
                "\n",
                "    async def async_added_to_hass(self) -> None:\n",
                "        \"\"\"Handle entity which will be added.\"\"\"\n",
                "        await self.async_base_added_to_hass()\n",
                "        state = await self.async_get_last_sensor_data()\n",
                "        if state:\n",
                "            self._attr_native_value = state.native_value\n",
                "\n",
                "    async def async_update(self, now: datetime | None = None) -> None:\n",
                "        \"\"\"Update the state of the sensor.\"\"\"\n",
                "        # remark \"now\" is a dummy parameter to avoid problems with\n",
                "        # async_track_time_interval\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        self._cancel_call = None\n"
                ],
                "parent_version_range": {
                    "start": 108,
                    "end": 108
                },
                "child_version_range": {
                    "start": 109,
                    "end": 110
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "ModbusRegisterSensor",
                        "signature": "class ModbusRegisterSensor(BaseStructPlatform, RestoreSensor, SensorEntity):",
                        "at_line": 59
                    },
                    {
                        "type": "function",
                        "name": "async_update",
                        "signature": "def async_update(self, now: datetime | None = None)->None:",
                        "at_line": 104
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: homeassistant/components/modbus/sensor.py\nCode:\n           class ModbusRegisterSensor(BaseStructPlatform, RestoreSensor, SensorEntity):\n               ...\n               def async_update(self, now: datetime | None = None)->None:\n                   ...\n105 106            \"\"\"Update the state of the sensor.\"\"\"\n106 107            # remark \"now\" is a dummy parameter to avoid problems with\n107 108            # async_track_time_interval\n    109  +         self._cancel_call = None\n108 110            raw_result = await self._hub.async_pb_call(\n109 111                self._slave, self._address, self._count, self._input_type\n110 112            )\n         ...\n",
                "file_path": "homeassistant/components/modbus/sensor.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "_cancel_call",
                    "self"
                ],
                "prefix": [
                    "        \"\"\"Update the state of the sensor.\"\"\"\n",
                    "        # remark \"now\" is a dummy parameter to avoid problems with\n",
                    "        # async_track_time_interval\n"
                ],
                "suffix": [
                    "        raw_result = await self._hub.async_pb_call(\n",
                    "            self._slave, self._address, self._count, self._input_type\n",
                    "        )\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        raw_result = await self._hub.async_pb_call(\n",
                "            self._slave, self._address, self._count, self._input_type\n",
                "        )\n",
                "        if raw_result is None:\n",
                "            if self._lazy_errors:\n",
                "                self._lazy_errors -= 1\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "                self._cancel_call = async_call_later(\n",
                    "                    self.hass, timedelta(seconds=1), self.async_update\n",
                    "                )\n"
                ],
                "parent_version_range": {
                    "start": 114,
                    "end": 114
                },
                "child_version_range": {
                    "start": 116,
                    "end": 119
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if raw_result is None:",
                        "start_line": 111,
                        "end_line": 121
                    },
                    {
                        "type": "if_statement",
                        "statement": "if self._lazy_errors:",
                        "start_line": 112,
                        "end_line": 114
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "ModbusRegisterSensor",
                        "signature": "class ModbusRegisterSensor(BaseStructPlatform, RestoreSensor, SensorEntity):",
                        "at_line": 59
                    },
                    {
                        "type": "function",
                        "name": "async_update",
                        "signature": "def async_update(self, now: datetime | None = None)->None:",
                        "at_line": 104
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: homeassistant/components/modbus/sensor.py\nCode:\n           class ModbusRegisterSensor(BaseStructPlatform, RestoreSensor, SensorEntity):\n               ...\n               def async_update(self, now: datetime | None = None)->None:\n                   ...\n111 113            if raw_result is None:\n112 114                if self._lazy_errors:\n113 115                    self._lazy_errors -= 1\n    116  +                 self._cancel_call = async_call_later(\n    117  +                     self.hass, timedelta(seconds=1), self.async_update\n    118  +                 )\n114 119                    return\n115 120                self._lazy_errors = self._lazy_error_count\n116 121                self._attr_available = False\n         ...\n",
                "file_path": "homeassistant/components/modbus/sensor.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "_cancel_call",
                    "async_call_later",
                    "async_update",
                    "hass",
                    "seconds",
                    "self",
                    "timedelta"
                ],
                "prefix": [
                    "        if raw_result is None:\n",
                    "            if self._lazy_errors:\n",
                    "                self._lazy_errors -= 1\n"
                ],
                "suffix": [
                    "                return\n",
                    "            self._lazy_errors = self._lazy_error_count\n",
                    "            self._attr_available = False\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "timedelta",
                            "position": {
                                "start": {
                                    "line": 117,
                                    "column": 31
                                },
                                "end": {
                                    "line": 117,
                                    "column": 40
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/modbus/sensor.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "async_call_later",
                            "position": {
                                "start": {
                                    "line": 116,
                                    "column": 36
                                },
                                "end": {
                                    "line": 116,
                                    "column": 52
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/modbus/sensor.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                return\n",
                "            self._lazy_errors = self._lazy_error_count\n",
                "            self._attr_available = False\n",
                "            self._attr_native_value = None\n",
                "            if self._coordinator:\n",
                "                self._coordinator.async_set_updated_data(None)\n",
                "            self.async_write_ha_state()\n",
                "            return\n",
                "\n",
                "        result = self.unpack_structure_result(raw_result.registers)\n",
                "        if self._coordinator:\n",
                "            if result:\n",
                "                result_array = list(\n",
                "                    map(float if self._precision else int, result.split(\",\"))\n",
                "                )\n",
                "                self._attr_native_value = result_array[0]\n",
                "                self._coordinator.async_set_updated_data(result_array)\n",
                "            else:\n",
                "                self._attr_native_value = None\n",
                "                self._coordinator.async_set_updated_data(None)\n",
                "        else:\n",
                "            self._attr_native_value = result\n",
                "        self._attr_available = self._attr_native_value is not None\n",
                "        self._lazy_errors = self._lazy_error_count\n",
                "        self.async_write_ha_state()\n",
                "\n",
                "\n",
                "class SlaveSensor(\n",
                "    CoordinatorEntity[DataUpdateCoordinator[list[int] | None]],\n",
                "    RestoreSensor,\n",
                "    SensorEntity,\n",
                "):\n",
                "    \"\"\"Modbus slave register sensor.\"\"\"\n",
                "\n",
                "    def __init__(\n",
                "        self,\n",
                "        coordinator: DataUpdateCoordinator[list[int] | None],\n",
                "        idx: int,\n",
                "        entry: dict[str, Any],\n",
                "    ) -> None:\n",
                "        \"\"\"Initialize the Modbus register sensor.\"\"\"\n",
                "        idx += 1\n",
                "        self._idx = idx\n",
                "        self._attr_name = f\"{entry[CONF_NAME]} {idx}\"\n",
                "        self._attr_unique_id = entry.get(CONF_UNIQUE_ID)\n",
                "        if self._attr_unique_id:\n",
                "            self._attr_unique_id = f\"{self._attr_unique_id}_{idx}\"\n",
                "        self._attr_native_unit_of_measurement = entry.get(CONF_UNIT_OF_MEASUREMENT)\n",
                "        self._attr_state_class = entry.get(CONF_STATE_CLASS)\n",
                "        self._attr_available = False\n",
                "        super().__init__(coordinator)\n",
                "\n",
                "    async def async_added_to_hass(self) -> None:\n",
                "        \"\"\"Handle entity which will be added.\"\"\"\n",
                "        if state := await self.async_get_last_state():\n",
                "            self._attr_native_value = state.state\n",
                "        await super().async_added_to_hass()\n",
                "\n",
                "    @callback\n",
                "    def _handle_coordinator_update(self) -> None:\n",
                "        \"\"\"Handle updated data from the coordinator.\"\"\"\n",
                "        result = self.coordinator.data\n",
                "        self._attr_native_value = result[self._idx] if result else None\n",
                "        super()._handle_coordinator_update()"
            ]
        ],
        "tests/components/modbus/test_sensor.py": [
            [
                "\"\"\"The tests for the Modbus sensor component.\"\"\"\n",
                "from freezegun.api import FrozenDateTimeFactory\n",
                "import pytest\n",
                "\n",
                "from homeassistant.components.modbus.const import (\n",
                "    CALL_TYPE_REGISTER_HOLDING,\n",
                "    CALL_TYPE_REGISTER_INPUT,\n",
                "    CONF_DATA_TYPE,\n",
                "    CONF_INPUT_TYPE,\n",
                "    CONF_LAZY_ERROR,\n",
                "    CONF_MAX_VALUE,\n",
                "    CONF_MIN_VALUE,\n",
                "    CONF_NAN_VALUE,\n",
                "    CONF_PRECISION,\n",
                "    CONF_SCALE,\n",
                "    CONF_SLAVE_COUNT,\n",
                "    CONF_SWAP,\n",
                "    CONF_SWAP_BYTE,\n",
                "    CONF_SWAP_NONE,\n",
                "    CONF_SWAP_WORD,\n",
                "    CONF_SWAP_WORD_BYTE,\n",
                "    CONF_ZERO_SUPPRESS,\n",
                "    MODBUS_DOMAIN,\n",
                "    DataType,\n",
                ")\n",
                "from homeassistant.components.sensor import (\n",
                "    CONF_STATE_CLASS,\n",
                "    DOMAIN as SENSOR_DOMAIN,\n",
                "    SensorStateClass,\n",
                ")\n",
                "from homeassistant.const import (\n",
                "    CONF_ADDRESS,\n",
                "    CONF_COUNT,\n",
                "    CONF_DEVICE_CLASS,\n",
                "    CONF_NAME,\n",
                "    CONF_OFFSET,\n",
                "    CONF_SCAN_INTERVAL,\n",
                "    CONF_SENSORS,\n",
                "    CONF_SLAVE,\n",
                "    CONF_STRUCTURE,\n",
                "    CONF_UNIQUE_ID,\n",
                "    STATE_UNAVAILABLE,\n",
                "    STATE_UNKNOWN,\n",
                ")\n",
                "from homeassistant.core import HomeAssistant, State\n",
                "from homeassistant.helpers import entity_registry as er\n",
                "from homeassistant.setup import async_setup_component\n",
                "\n",
                "from .conftest import TEST_ENTITY_NAME, ReadResult, do_next_cycle\n",
                "\n",
                "from tests.common import mock_restore_cache_with_extra_data\n",
                "\n",
                "ENTITY_ID = f\"{SENSOR_DOMAIN}.{TEST_ENTITY_NAME}\".replace(\" \", \"_\")\n",
                "SLAVE_UNIQUE_ID = \"ground_floor_sensor\"\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"do_config\",\n",
                "    [\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_DATA_TYPE: DataType.INT16,\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_SLAVE: 10,\n",
                "                    CONF_DATA_TYPE: DataType.INT16,\n",
                "                    CONF_PRECISION: 0,\n",
                "                    CONF_SCALE: 1,\n",
                "                    CONF_OFFSET: 0,\n",
                "                    CONF_STATE_CLASS: SensorStateClass.MEASUREMENT,\n",
                "                    CONF_LAZY_ERROR: 10,\n",
                "                    CONF_INPUT_TYPE: CALL_TYPE_REGISTER_HOLDING,\n",
                "                    CONF_DEVICE_CLASS: \"battery\",\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_SLAVE: 10,\n",
                "                    CONF_DATA_TYPE: DataType.INT16,\n",
                "                    CONF_PRECISION: 0,\n",
                "                    CONF_SCALE: 1,\n",
                "                    CONF_OFFSET: 0,\n",
                "                    CONF_INPUT_TYPE: CALL_TYPE_REGISTER_INPUT,\n",
                "                    CONF_DEVICE_CLASS: \"battery\",\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_DATA_TYPE: DataType.INT16,\n",
                "                    CONF_SWAP: CONF_SWAP_NONE,\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_DATA_TYPE: DataType.INT16,\n",
                "                    CONF_SWAP: CONF_SWAP_BYTE,\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_DATA_TYPE: DataType.INT32,\n",
                "                    CONF_SWAP: CONF_SWAP_WORD,\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_DATA_TYPE: DataType.INT32,\n",
                "                    CONF_SWAP: CONF_SWAP_WORD_BYTE,\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_DATA_TYPE: DataType.INT32,\n",
                "                    CONF_SLAVE_COUNT: 5,\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "    ],\n",
                ")\n",
                "async def test_config_sensor(hass: HomeAssistant, mock_modbus) -> None:\n",
                "    \"\"\"Run configuration test for sensor.\"\"\"\n",
                "    assert SENSOR_DOMAIN in hass.config.components\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\"check_config_loaded\", [False])\n",
                "@pytest.mark.parametrize(\n",
                "    (\"do_config\", \"error_message\"),\n",
                "    [\n",
                "        (\n",
                "            {\n",
                "                CONF_SENSORS: [\n",
                "                    {\n",
                "                        CONF_NAME: TEST_ENTITY_NAME,\n",
                "                        CONF_ADDRESS: 1234,\n",
                "                        CONF_COUNT: 8,\n",
                "                        CONF_PRECISION: 2,\n",
                "                        CONF_DATA_TYPE: DataType.CUSTOM,\n",
                "                        CONF_STRUCTURE: \">no struct\",\n",
                "                    },\n",
                "                ]\n",
                "            },\n",
                "            \"bad char in struct format\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SENSORS: [\n",
                "                    {\n",
                "                        CONF_NAME: TEST_ENTITY_NAME,\n",
                "                        CONF_ADDRESS: 1234,\n",
                "                        CONF_COUNT: 2,\n",
                "                        CONF_PRECISION: 2,\n",
                "                        CONF_DATA_TYPE: DataType.CUSTOM,\n",
                "                        CONF_STRUCTURE: \">4f\",\n",
                "                    },\n",
                "                ]\n",
                "            },\n",
                "            f\"{TEST_ENTITY_NAME}: Size of structure is 16 bytes but `{CONF_COUNT}: 2` is 4 bytes\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SENSORS: [\n",
                "                    {\n",
                "                        CONF_NAME: TEST_ENTITY_NAME,\n",
                "                        CONF_ADDRESS: 1234,\n",
                "                        CONF_DATA_TYPE: DataType.CUSTOM,\n",
                "                        CONF_COUNT: 4,\n",
                "                        CONF_SWAP: CONF_SWAP_NONE,\n",
                "                        CONF_STRUCTURE: \"invalid\",\n",
                "                    },\n",
                "                ]\n",
                "            },\n",
                "            \"bad char in struct format\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SENSORS: [\n",
                "                    {\n",
                "                        CONF_NAME: TEST_ENTITY_NAME,\n",
                "                        CONF_ADDRESS: 1234,\n",
                "                        CONF_DATA_TYPE: DataType.CUSTOM,\n",
                "                        CONF_COUNT: 4,\n",
                "                        CONF_STRUCTURE: \"\",\n",
                "                    },\n",
                "                ]\n",
                "            },\n",
                "            f\"{TEST_ENTITY_NAME}: `{CONF_STRUCTURE}` missing or empty, demanded with `{CONF_DATA_TYPE}: {DataType.CUSTOM}`\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SENSORS: [\n",
                "                    {\n",
                "                        CONF_NAME: TEST_ENTITY_NAME,\n",
                "                        CONF_ADDRESS: 1234,\n",
                "                        CONF_DATA_TYPE: DataType.CUSTOM,\n",
                "                        CONF_COUNT: 4,\n",
                "                        CONF_STRUCTURE: \"1s\",\n",
                "                    },\n",
                "                ]\n",
                "            },\n",
                "            f\"{TEST_ENTITY_NAME}: Size of structure is 1 bytes but `{CONF_COUNT}: 4` is 8 bytes\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SENSORS: [\n",
                "                    {\n",
                "                        CONF_NAME: TEST_ENTITY_NAME,\n",
                "                        CONF_ADDRESS: 1234,\n",
                "                        CONF_DATA_TYPE: DataType.CUSTOM,\n",
                "                        CONF_COUNT: 1,\n",
                "                        CONF_STRUCTURE: \"2s\",\n",
                "                        CONF_SWAP: CONF_SWAP_WORD,\n",
                "                    },\n",
                "                ]\n",
                "            },\n",
                "            f\"{TEST_ENTITY_NAME}: `{CONF_SWAP}:{CONF_SWAP_WORD}` cannot be combined with `{CONF_DATA_TYPE}: {DataType.CUSTOM}`\",\n",
                "        ),\n",
                "    ],\n",
                ")\n",
                "async def test_config_wrong_struct_sensor(\n",
                "    hass: HomeAssistant, error_message, mock_modbus, caplog: pytest.LogCaptureFixture\n",
                ") -> None:\n",
                "    \"\"\"Run test for sensor with wrong struct.\"\"\"\n",
                "    messages = str([x.message for x in caplog.get_records(\"setup\")])\n",
                "    assert error_message in messages\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"do_config\",\n",
                "    [\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                },\n",
                "            ],\n",
                "        },\n",
                "    ],\n",
                ")\n",
                "@pytest.mark.parametrize(\n",
                "    (\"config_addon\", \"register_words\", \"do_exception\", \"expected\"),\n",
                "    [\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0],\n",
                "            False,\n",
                "            \"0\",\n",
                "        ),\n",
                "        (\n",
                "            {},\n",
                "            [0x8000],\n",
                "            False,\n",
                "            \"-32768\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 13,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [7],\n",
                "            False,\n",
                "            \"20\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "                CONF_SCALE: 3,\n",
                "                CONF_OFFSET: 13,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [7],\n",
                "            False,\n",
                "            \"34\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.UINT16,\n",
                "                CONF_SCALE: 3,\n",
                "                CONF_OFFSET: 13,\n",
                "                CONF_PRECISION: 4,\n",
                "            },\n",
                "            [7],\n",
                "            False,\n",
                "            \"34.0000\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "                CONF_SCALE: 1.5,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [1],\n",
                "            False,\n",
                "            \"2\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "                CONF_SCALE: \"1.5\",\n",
                "                CONF_OFFSET: \"5\",\n",
                "                CONF_PRECISION: \"1\",\n",
                "            },\n",
                "            [9],\n",
                "            False,\n",
                "            \"18.5\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "                CONF_SCALE: 2.4,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 2,\n",
                "            },\n",
                "            [1],\n",
                "            False,\n",
                "            \"2.40\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: -10.3,\n",
                "                CONF_PRECISION: 1,\n",
                "            },\n",
                "            [2],\n",
                "            False,\n",
                "            \"-8.3\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x89AB, 0xCDEF],\n",
                "            False,\n",
                "            \"-1985229329\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x89AB, 0xCDEF],\n",
                "            False,\n",
                "            str(0x89ABCDEF),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.UINT64,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x89AB, 0xCDEF, 0x0123, 0x4567],\n",
                "            False,\n",
                "            \"9920249030613615975\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.UINT64,\n",
                "                CONF_SCALE: 2,\n",
                "                CONF_OFFSET: 3,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x0123, 0x4567, 0x89AB, 0xCDEF],\n",
                "            False,\n",
                "            \"163971058432973793\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.UINT64,\n",
                "                CONF_SCALE: 2.0,\n",
                "                CONF_OFFSET: 3.0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x0123, 0x4567, 0x89AB, 0xCDEF],\n",
                "            False,\n",
                "            \"163971058432973792\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_INPUT_TYPE: CALL_TYPE_REGISTER_INPUT,\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x89AB, 0xCDEF],\n",
                "            False,\n",
                "            str(0x89ABCDEF),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_INPUT_TYPE: CALL_TYPE_REGISTER_HOLDING,\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x89AB, 0xCDEF],\n",
                "            False,\n",
                "            str(0x89ABCDEF),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_INPUT_TYPE: CALL_TYPE_REGISTER_HOLDING,\n",
                "                CONF_DATA_TYPE: DataType.FLOAT32,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 5,\n",
                "            },\n",
                "            [16286, 1617],\n",
                "            False,\n",
                "            \"1.23457\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_COUNT: 8,\n",
                "                CONF_INPUT_TYPE: CALL_TYPE_REGISTER_HOLDING,\n",
                "                CONF_DATA_TYPE: DataType.STRING,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x3037, 0x2D30, 0x352D, 0x3230, 0x3230, 0x2031, 0x343A, 0x3335],\n",
                "            False,\n",
                "            \"07-05-2020 14:35\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_COUNT: 8,\n",
                "                CONF_INPUT_TYPE: CALL_TYPE_REGISTER_HOLDING,\n",
                "                CONF_DATA_TYPE: DataType.STRING,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x00],\n",
                "            True,\n",
                "            STATE_UNAVAILABLE,\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_INPUT_TYPE: CALL_TYPE_REGISTER_INPUT,\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "                CONF_SCALE: 1,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x00],\n",
                "            True,\n",
                "            STATE_UNAVAILABLE,\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "                CONF_SWAP: CONF_SWAP_NONE,\n",
                "            },\n",
                "            [0x0102],\n",
                "            False,\n",
                "            str(0x0102),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "                CONF_SWAP: CONF_SWAP_BYTE,\n",
                "            },\n",
                "            [0x0201],\n",
                "            False,\n",
                "            str(0x0102),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_SWAP: CONF_SWAP_BYTE,\n",
                "            },\n",
                "            [0x0102, 0x0304],\n",
                "            False,\n",
                "            str(0x02010403),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_SWAP: CONF_SWAP_WORD,\n",
                "            },\n",
                "            [0x0102, 0x0304],\n",
                "            False,\n",
                "            str(0x03040102),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_SWAP: CONF_SWAP_WORD_BYTE,\n",
                "            },\n",
                "            [0x0102, 0x0304],\n",
                "            False,\n",
                "            str(0x04030201),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_MAX_VALUE: 0x02010400,\n",
                "            },\n",
                "            [0x0201, 0x0403],\n",
                "            False,\n",
                "            str(0x02010400),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_MIN_VALUE: 0x02010404,\n",
                "            },\n",
                "            [0x0201, 0x0403],\n",
                "            False,\n",
                "            str(0x02010404),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_NAN_VALUE: \"0x80000000\",\n",
                "            },\n",
                "            [0x8000, 0x0000],\n",
                "            False,\n",
                "            STATE_UNAVAILABLE,\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_ZERO_SUPPRESS: 0x00000001,\n",
                "            },\n",
                "            [0x0000, 0x0002],\n",
                "            False,\n",
                "            str(0x00000002),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_ZERO_SUPPRESS: 0x00000002,\n",
                "            },\n",
                "            [0x0000, 0x0002],\n",
                "            False,\n",
                "            str(0),\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_INPUT_TYPE: CALL_TYPE_REGISTER_INPUT,\n",
                "                CONF_DATA_TYPE: DataType.FLOAT32,\n",
                "                CONF_PRECISION: 2,\n",
                "            },\n",
                "            [16286, 1617],\n",
                "            False,\n",
                "            \"1.23\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_SCALE: 10,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 0,\n",
                "            },\n",
                "            [0x00AB, 0xCDEF],\n",
                "            False,\n",
                "            \"112593750\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_SCALE: 0.01,\n",
                "                CONF_OFFSET: 0,\n",
                "                CONF_PRECISION: 2,\n",
                "            },\n",
                "            [0x00AB, 0xCDEF],\n",
                "            False,\n",
                "            \"112593.75\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "                CONF_SCALE: 0.01,\n",
                "                CONF_OFFSET: 0,\n",
                "            },\n",
                "            [0x00AB, 0xCDEF],\n",
                "            False,\n",
                "            \"112593.75\",\n",
                "        ),\n",
                "    ],\n",
                ")\n",
                "async def test_all_sensor(hass: HomeAssistant, mock_do_cycle, expected) -> None:\n",
                "    \"\"\"Run test for sensor.\"\"\"\n",
                "    assert hass.states.get(ENTITY_ID).state == expected\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"do_config\",\n",
                "    [\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_INPUT_TYPE: CALL_TYPE_REGISTER_HOLDING,\n",
                "                    CONF_DATA_TYPE: DataType.UINT32,\n",
                "                    CONF_SCAN_INTERVAL: 1,\n",
                "                },\n",
                "            ],\n",
                "        },\n",
                "    ],\n",
                ")\n",
                "@pytest.mark.parametrize(\n",
                "    (\"config_addon\", \"register_words\", \"do_exception\", \"expected\"),\n",
                "    [\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 0,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "            },\n",
                "            [0x0102, 0x0304],\n",
                "            False,\n",
                "            [\"16909060\"],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 1,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "            },\n",
                "            [0x0102, 0x0304, 0x0403, 0x0201],\n",
                "            False,\n",
                "            [\"16909060\", \"67305985\"],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 3,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "            },\n",
                "            [\n",
                "                0x0102,\n",
                "                0x0304,\n",
                "                0x0506,\n",
                "                0x0708,\n",
                "                0x090A,\n",
                "                0x0B0C,\n",
                "                0x0D0E,\n",
                "                0x0F00,\n",
                "            ],\n",
                "            False,\n",
                "            [\n",
                "                \"16909060\",\n",
                "                \"84281096\",\n",
                "                \"151653132\",\n",
                "                \"219025152\",\n",
                "            ],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 1,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "            },\n",
                "            [0x0102, 0x0304, 0x0403, 0x0201],\n",
                "            True,\n",
                "            [STATE_UNAVAILABLE, STATE_UNKNOWN],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 1,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "            },\n",
                "            [],\n",
                "            False,\n",
                "            [STATE_UNAVAILABLE, STATE_UNKNOWN],\n",
                "        ),\n",
                "    ],\n",
                ")\n",
                "async def test_slave_sensor(hass: HomeAssistant, mock_do_cycle, expected) -> None:\n",
                "    \"\"\"Run test for sensor.\"\"\"\n",
                "    entity_registry = er.async_get(hass)\n",
                "    for i in range(0, len(expected)):\n",
                "        entity_id = f\"{SENSOR_DOMAIN}.{TEST_ENTITY_NAME}\".replace(\" \", \"_\")\n",
                "        unique_id = f\"{SLAVE_UNIQUE_ID}\"\n",
                "        if i:\n",
                "            entity_id = f\"{entity_id}_{i}\"\n",
                "            unique_id = f\"{unique_id}_{i}\"\n",
                "        entry = entity_registry.async_get(entity_id)\n",
                "        state = hass.states.get(entity_id).state\n",
                "        assert state == expected[i]\n",
                "        assert entry.unique_id == unique_id\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"do_config\",\n",
                "    [\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_INPUT_TYPE: CALL_TYPE_REGISTER_HOLDING,\n",
                "                },\n",
                "            ],\n",
                "        },\n",
                "    ],\n",
                ")\n",
                "@pytest.mark.parametrize(\n",
                "    (\"config_addon\", \"register_words\", \"do_exception\", \"expected\"),\n",
                "    [\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 0,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "                CONF_SWAP: CONF_SWAP_BYTE,\n",
                "                CONF_DATA_TYPE: DataType.UINT16,\n",
                "            },\n",
                "            [0x0102],\n",
                "            False,\n",
                "            [str(0x0201)],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 0,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "                CONF_SWAP: CONF_SWAP_WORD,\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "            },\n",
                "            [0x0102, 0x0304],\n",
                "            False,\n",
                "            [str(0x03040102)],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 0,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "                CONF_SWAP: CONF_SWAP_WORD,\n",
                "                CONF_DATA_TYPE: DataType.UINT64,\n",
                "            },\n",
                "            [0x0102, 0x0304, 0x0506, 0x0708],\n",
                "            False,\n",
                "            [str(0x0708050603040102)],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 1,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "                CONF_DATA_TYPE: DataType.UINT16,\n",
                "                CONF_SWAP: CONF_SWAP_BYTE,\n",
                "            },\n",
                "            [0x0102, 0x0304],\n",
                "            False,\n",
                "            [str(0x0201), str(0x0403)],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 1,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "                CONF_SWAP: CONF_SWAP_WORD,\n",
                "            },\n",
                "            [0x0102, 0x0304, 0x0506, 0x0708],\n",
                "            False,\n",
                "            [str(0x03040102), str(0x07080506)],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 1,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "                CONF_DATA_TYPE: DataType.UINT64,\n",
                "                CONF_SWAP: CONF_SWAP_WORD,\n",
                "            },\n",
                "            [0x0102, 0x0304, 0x0506, 0x0708, 0x0901, 0x0902, 0x0903, 0x0904],\n",
                "            False,\n",
                "            [str(0x0708050603040102), str(0x0904090309020901)],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 3,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "                CONF_DATA_TYPE: DataType.UINT16,\n",
                "                CONF_SWAP: CONF_SWAP_BYTE,\n",
                "            },\n",
                "            [0x0102, 0x0304, 0x0506, 0x0708],\n",
                "            False,\n",
                "            [str(0x0201), str(0x0403), str(0x0605), str(0x0807)],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 3,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "                CONF_SWAP: CONF_SWAP_WORD,\n",
                "            },\n",
                "            [\n",
                "                0x0102,\n",
                "                0x0304,\n",
                "                0x0506,\n",
                "                0x0708,\n",
                "                0x090A,\n",
                "                0x0B0C,\n",
                "                0x0D0E,\n",
                "                0x0F00,\n",
                "            ],\n",
                "            False,\n",
                "            [\n",
                "                str(0x03040102),\n",
                "                str(0x07080506),\n",
                "                str(0x0B0C090A),\n",
                "                str(0x0F000D0E),\n",
                "            ],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SLAVE_COUNT: 3,\n",
                "                CONF_UNIQUE_ID: SLAVE_UNIQUE_ID,\n",
                "                CONF_DATA_TYPE: DataType.UINT64,\n",
                "                CONF_SWAP: CONF_SWAP_WORD,\n",
                "            },\n",
                "            [\n",
                "                0x0601,\n",
                "                0x0602,\n",
                "                0x0603,\n",
                "                0x0604,\n",
                "                0x0701,\n",
                "                0x0702,\n",
                "                0x0703,\n",
                "                0x0704,\n",
                "                0x0801,\n",
                "                0x0802,\n",
                "                0x0803,\n",
                "                0x0804,\n",
                "                0x0901,\n",
                "                0x0902,\n",
                "                0x0903,\n",
                "                0x0904,\n",
                "            ],\n",
                "            False,\n",
                "            [\n",
                "                str(0x0604060306020601),\n",
                "                str(0x0704070307020701),\n",
                "                str(0x0804080308020801),\n",
                "                str(0x0904090309020901),\n",
                "            ],\n",
                "        ),\n",
                "    ],\n",
                ")\n",
                "async def test_slave_swap_sensor(hass: HomeAssistant, mock_do_cycle, expected) -> None:\n",
                "    \"\"\"Run test for sensor.\"\"\"\n",
                "    for i in range(0, len(expected)):\n",
                "        entity_id = f\"{SENSOR_DOMAIN}.{TEST_ENTITY_NAME}\".replace(\" \", \"_\")\n",
                "        if i:\n",
                "            entity_id = f\"{entity_id}_{i}\"\n",
                "        state = hass.states.get(entity_id).state\n",
                "        assert state == expected[i]\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"do_config\",\n",
                "    [\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_SCAN_INTERVAL: 1,\n",
                "                },\n",
                "            ],\n",
                "        },\n",
                "    ],\n",
                ")\n",
                "@pytest.mark.parametrize(\n",
                "    (\"config_addon\", \"register_words\"),\n",
                "    [\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "            },\n",
                "            [7, 9],\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_DATA_TYPE: DataType.INT32,\n",
                "            },\n",
                "            [7],\n",
                "        ),\n",
                "    ],\n",
                ")\n",
                "async def test_wrong_unpack(hass: HomeAssistant, mock_do_cycle) -> None:\n",
                "    \"\"\"Run test for sensor.\"\"\"\n",
                "    assert hass.states.get(ENTITY_ID).state == STATE_UNAVAILABLE\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"do_config\",\n",
                "    [\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_SCAN_INTERVAL: 10,\n",
                "                    CONF_LAZY_ERROR: 1,\n",
                "                },\n",
                "            ],\n",
                "        },\n",
                "    ],\n",
                ")\n",
                "@pytest.mark.parametrize(\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    (\"register_words\", \"do_exception\", \"start_expect\", \"end_expect\"),\n"
                ],
                "after": [
                    "    (\"register_words\", \"do_exception\"),\n"
                ],
                "parent_version_range": {
                    "start": 948,
                    "end": 949
                },
                "child_version_range": {
                    "start": 948,
                    "end": 949
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "call",
                        "name": "pytest.mark.parametrize",
                        "signature": "pytest.mark.parametrize(\n    (\"register_words\", \"do_exception\", \"start_expect\", \"end_expect\"),\n    [\n        (\n            [0x8000],\n            True,\n            \"17\",\n            STATE_UNAVAILABLE,\n        ),\n    ],\n)",
                        "at_line": 947,
                        "argument": "(\"register_words\", \"do_excepti..."
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: tests/components/modbus/test_sensor.py\nCode:\n945 945        ],\n946 946    )\n947 947    @pytest.mark.parametrize(\n948      -     (\"register_words\", \"do_exception\", \"start_expect\", \"end_expect\"),\n    948  +     (\"register_words\", \"do_exception\"),\n949 949        [\n950 950            (\n951 951                [0x8000],\n         ...\n",
                "file_path": "tests/components/modbus/test_sensor.py",
                "identifiers_before": [],
                "identifiers_after": [],
                "prefix": [
                    "    ],\n",
                    ")\n",
                    "@pytest.mark.parametrize(\n"
                ],
                "suffix": [
                    "    [\n",
                    "        (\n",
                    "            [0x8000],\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    [\n",
                "        (\n",
                "            [0x8000],\n",
                "            True,\n"
            ],
            {
                "type": "delete",
                "before": [
                    "            \"17\",\n",
                    "            STATE_UNAVAILABLE,\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 953,
                    "end": 955
                },
                "child_version_range": {
                    "start": 953,
                    "end": 953
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "call",
                        "name": "pytest.mark.parametrize",
                        "signature": "pytest.mark.parametrize(\n    (\"register_words\", \"do_exception\", \"start_expect\", \"end_expect\"),\n    [\n        (\n            [0x8000],\n            True,\n            \"17\",\n            STATE_UNAVAILABLE,\n        ),\n    ],\n)",
                        "at_line": 947,
                        "argument": "[\n        (\n            [0x800..."
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: tests/components/modbus/test_sensor.py\nCode:\n           pytest.mark.parametrize(\n    (\"register_words\", \"do_exception\", \"start_expect\", \"end_expect\"),\n    [\n        (\n            [0x8000],\n            True,\n            \"17\",\n            STATE_UNAVAILABLE,\n        ),\n    ],\n)\n               ...\n950 950            (\n951 951                [0x8000],\n952 952                True,\n953      -             \"17\",\n954      -             STATE_UNAVAILABLE,\n955 953            ),\n956 954        ],\n957 955    )\n         ...\n",
                "file_path": "tests/components/modbus/test_sensor.py",
                "identifiers_before": [
                    "STATE_UNAVAILABLE"
                ],
                "identifiers_after": [],
                "prefix": [
                    "        (\n",
                    "            [0x8000],\n",
                    "            True,\n"
                ],
                "suffix": [
                    "        ),\n",
                    "    ],\n",
                    ")\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        ),\n",
                "    ],\n",
                ")\n",
                "async def test_lazy_error_sensor(\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    hass: HomeAssistant, mock_do_cycle: FrozenDateTimeFactory, start_expect, end_expect\n"
                ],
                "after": [
                    "    hass: HomeAssistant, mock_do_cycle: FrozenDateTimeFactory\n"
                ],
                "parent_version_range": {
                    "start": 959,
                    "end": 960
                },
                "child_version_range": {
                    "start": 957,
                    "end": 958
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_lazy_error_sensor",
                        "signature": "def test_lazy_error_sensor(\n    hass: HomeAssistant, mock_do_cycle: FrozenDateTimeFactory, start_expect, end_expect\n)->None:",
                        "at_line": 958
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: tests/components/modbus/test_sensor.py\nCode:\n956 954        ],\n957 955    )\n958 956    async def test_lazy_error_sensor(\n959      -     hass: HomeAssistant, mock_do_cycle: FrozenDateTimeFactory, start_expect, end_expect\n    957  +     hass: HomeAssistant, mock_do_cycle: FrozenDateTimeFactory\n960 958    ) -> None:\n961 959        \"\"\"Run test for sensor.\"\"\"\n962 960        hass.states.async_set(ENTITY_ID, 17)\n         ...\n",
                "file_path": "tests/components/modbus/test_sensor.py",
                "identifiers_before": [
                    "FrozenDateTimeFactory",
                    "HomeAssistant",
                    "end_expect",
                    "hass",
                    "mock_do_cycle",
                    "start_expect"
                ],
                "identifiers_after": [
                    "FrozenDateTimeFactory",
                    "HomeAssistant",
                    "hass",
                    "mock_do_cycle"
                ],
                "prefix": [
                    "    ],\n",
                    ")\n",
                    "async def test_lazy_error_sensor(\n"
                ],
                "suffix": [
                    ") -> None:\n",
                    "    \"\"\"Run test for sensor.\"\"\"\n",
                    "    hass.states.async_set(ENTITY_ID, 17)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 8,
                        "detail": {
                            "identifier": "start_expect",
                            "position": {
                                "start": {
                                    "line": 959,
                                    "column": 63
                                },
                                "end": {
                                    "line": 959,
                                    "column": 75
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/modbus/test_sensor.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 9,
                        "detail": {
                            "identifier": "start_expect",
                            "position": {
                                "start": {
                                    "line": 959,
                                    "column": 63
                                },
                                "end": {
                                    "line": 959,
                                    "column": 75
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/modbus/test_sensor.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 9,
                        "detail": {
                            "identifier": "end_expect",
                            "position": {
                                "start": {
                                    "line": 959,
                                    "column": 77
                                },
                                "end": {
                                    "line": 959,
                                    "column": 87
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/modbus/test_sensor.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                ") -> None:\n",
                "    \"\"\"Run test for sensor.\"\"\"\n",
                "    hass.states.async_set(ENTITY_ID, 17)\n",
                "    await hass.async_block_till_done()\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    assert hass.states.get(ENTITY_ID).state == start_expect\n"
                ],
                "after": [
                    "    assert hass.states.get(ENTITY_ID).state == \"17\"\n"
                ],
                "parent_version_range": {
                    "start": 964,
                    "end": 965
                },
                "child_version_range": {
                    "start": 962,
                    "end": 963
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_lazy_error_sensor",
                        "signature": "def test_lazy_error_sensor(\n    hass: HomeAssistant, mock_do_cycle: FrozenDateTimeFactory, start_expect, end_expect\n)->None:",
                        "at_line": 958
                    }
                ],
                "idx": 8,
                "hunk_diff": "File: tests/components/modbus/test_sensor.py\nCode:\n           def test_lazy_error_sensor(\n    hass: HomeAssistant, mock_do_cycle: FrozenDateTimeFactory, start_expect, end_expect\n)->None:\n               ...\n961 959        \"\"\"Run test for sensor.\"\"\"\n962 960        hass.states.async_set(ENTITY_ID, 17)\n963 961        await hass.async_block_till_done()\n964      -     assert hass.states.get(ENTITY_ID).state == start_expect\n    962  +     assert hass.states.get(ENTITY_ID).state == \"17\"\n965 963        await do_next_cycle(hass, mock_do_cycle, 5)\n         ...\n",
                "file_path": "tests/components/modbus/test_sensor.py",
                "identifiers_before": [
                    "ENTITY_ID",
                    "get",
                    "hass",
                    "start_expect",
                    "state",
                    "states"
                ],
                "identifiers_after": [
                    "ENTITY_ID",
                    "get",
                    "hass",
                    "state",
                    "states"
                ],
                "prefix": [
                    "    \"\"\"Run test for sensor.\"\"\"\n",
                    "    hass.states.async_set(ENTITY_ID, 17)\n",
                    "    await hass.async_block_till_done()\n"
                ],
                "suffix": [
                    "    await do_next_cycle(hass, mock_do_cycle, 5)\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "start_expect",
                            "position": {
                                "start": {
                                    "line": 964,
                                    "column": 47
                                },
                                "end": {
                                    "line": 964,
                                    "column": 59
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/modbus/test_sensor.py",
                            "hunk_idx": 8,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    await do_next_cycle(hass, mock_do_cycle, 5)\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    assert hass.states.get(ENTITY_ID).state == start_expect\n",
                    "    await do_next_cycle(hass, mock_do_cycle, 11)\n",
                    "    assert hass.states.get(ENTITY_ID).state == end_expect\n"
                ],
                "after": [
                    "    assert hass.states.get(ENTITY_ID).state == STATE_UNAVAILABLE\n"
                ],
                "parent_version_range": {
                    "start": 966,
                    "end": 969
                },
                "child_version_range": {
                    "start": 964,
                    "end": 965
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_lazy_error_sensor",
                        "signature": "def test_lazy_error_sensor(\n    hass: HomeAssistant, mock_do_cycle: FrozenDateTimeFactory, start_expect, end_expect\n)->None:",
                        "at_line": 958
                    }
                ],
                "idx": 9,
                "hunk_diff": "File: tests/components/modbus/test_sensor.py\nCode:\n           def test_lazy_error_sensor(\n    hass: HomeAssistant, mock_do_cycle: FrozenDateTimeFactory, start_expect, end_expect\n)->None:\n               ...\n965 963        await do_next_cycle(hass, mock_do_cycle, 5)\n966      -     assert hass.states.get(ENTITY_ID).state == start_expect\n967      -     await do_next_cycle(hass, mock_do_cycle, 11)\n968      -     assert hass.states.get(ENTITY_ID).state == end_expect\n    964  +     assert hass.states.get(ENTITY_ID).state == STATE_UNAVAILABLE\n969 965    \n970 966    \n971 967    @pytest.mark.parametrize(\n         ...\n",
                "file_path": "tests/components/modbus/test_sensor.py",
                "identifiers_before": [
                    "ENTITY_ID",
                    "do_next_cycle",
                    "end_expect",
                    "get",
                    "hass",
                    "mock_do_cycle",
                    "start_expect",
                    "state",
                    "states"
                ],
                "identifiers_after": [
                    "ENTITY_ID",
                    "STATE_UNAVAILABLE",
                    "get",
                    "hass",
                    "state",
                    "states"
                ],
                "prefix": [
                    "    await do_next_cycle(hass, mock_do_cycle, 5)\n"
                ],
                "suffix": [
                    "\n",
                    "\n",
                    "@pytest.mark.parametrize(\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "start_expect",
                            "position": {
                                "start": {
                                    "line": 966,
                                    "column": 47
                                },
                                "end": {
                                    "line": 966,
                                    "column": 59
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/modbus/test_sensor.py",
                            "hunk_idx": 9,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "end_expect",
                            "position": {
                                "start": {
                                    "line": 968,
                                    "column": 47
                                },
                                "end": {
                                    "line": 968,
                                    "column": 57
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/tests/components/modbus/test_sensor.py",
                            "hunk_idx": 9,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"do_config\",\n",
                "    [\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_SCAN_INTERVAL: 1,\n",
                "                },\n",
                "            ],\n",
                "        },\n",
                "    ],\n",
                ")\n",
                "@pytest.mark.parametrize(\n",
                "    (\"config_addon\", \"register_words\", \"expected\"),\n",
                "    [\n",
                "        (\n",
                "            {\n",
                "                CONF_COUNT: 8,\n",
                "                CONF_PRECISION: 2,\n",
                "                CONF_DATA_TYPE: DataType.CUSTOM,\n",
                "                CONF_STRUCTURE: \">4f\",\n",
                "            },\n",
                "            # floats: 7.931250095367432, 10.600000381469727,\n",
                "            #         1.000879611487865e-28, 10.566553115844727\n",
                "            [0x40FD, 0xCCCD, 0x4129, 0x999A, 0x10FD, 0xC0CD, 0x4129, 0x109A],\n",
                "            \"7.93,10.60,0.00,10.57\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_COUNT: 4,\n",
                "                CONF_PRECISION: 0,\n",
                "                CONF_DATA_TYPE: DataType.CUSTOM,\n",
                "                CONF_STRUCTURE: \">2i\",\n",
                "            },\n",
                "            [0x0000, 0x0100, 0x0000, 0x0032],\n",
                "            \"256,50\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_PRECISION: 0,\n",
                "                CONF_DATA_TYPE: DataType.INT16,\n",
                "            },\n",
                "            [0x0101],\n",
                "            \"257\",\n",
                "        ),\n",
                "    ],\n",
                ")\n",
                "async def test_struct_sensor(hass: HomeAssistant, mock_do_cycle, expected) -> None:\n",
                "    \"\"\"Run test for sensor struct.\"\"\"\n",
                "    assert hass.states.get(ENTITY_ID).state == expected\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"do_config\",\n",
                "    [\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 201,\n",
                "                },\n",
                "            ],\n",
                "        },\n",
                "    ],\n",
                ")\n",
                "@pytest.mark.parametrize(\n",
                "    (\"config_addon\", \"register_words\", \"expected\"),\n",
                "    [\n",
                "        (\n",
                "            {\n",
                "                CONF_SWAP: CONF_SWAP_NONE,\n",
                "                CONF_DATA_TYPE: DataType.UINT16,\n",
                "            },\n",
                "            [0x0102],\n",
                "            \"258\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SWAP: CONF_SWAP_BYTE,\n",
                "                CONF_DATA_TYPE: DataType.UINT16,\n",
                "            },\n",
                "            [0x0102],\n",
                "            \"513\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SWAP: CONF_SWAP_NONE,\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "            },\n",
                "            [0x0102, 0x0304],\n",
                "            \"16909060\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SWAP: CONF_SWAP_BYTE,\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "            },\n",
                "            [0x0102, 0x0304],\n",
                "            \"33620995\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SWAP: CONF_SWAP_WORD,\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "            },\n",
                "            [0x0102, 0x0304],\n",
                "            \"50594050\",\n",
                "        ),\n",
                "        (\n",
                "            {\n",
                "                CONF_SWAP: CONF_SWAP_WORD_BYTE,\n",
                "                CONF_DATA_TYPE: DataType.UINT32,\n",
                "            },\n",
                "            [0x0102, 0x0304],\n",
                "            \"67305985\",\n",
                "        ),\n",
                "    ],\n",
                ")\n",
                "async def test_wrap_sensor(hass: HomeAssistant, mock_do_cycle, expected) -> None:\n",
                "    \"\"\"Run test for sensor struct.\"\"\"\n",
                "    assert hass.states.get(ENTITY_ID).state == expected\n",
                "\n",
                "\n",
                "@pytest.fixture(name=\"mock_restore\")\n",
                "async def mock_restore(hass):\n",
                "    \"\"\"Mock restore cache.\"\"\"\n",
                "    mock_restore_cache_with_extra_data(\n",
                "        hass,\n",
                "        (\n",
                "            (\n",
                "                State(ENTITY_ID, \"121\"),\n",
                "                {\"native_value\": \"121\", \"native_unit_of_measurement\": \"kg\"},\n",
                "            ),\n",
                "            (\n",
                "                State(ENTITY_ID + \"_1\", \"119\"),\n",
                "                {\"native_value\": \"119\", \"native_unit_of_measurement\": \"kg\"},\n",
                "            ),\n",
                "        ),\n",
                "    )\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"do_config\",\n",
                "    [\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 51,\n",
                "                    CONF_SCAN_INTERVAL: 0,\n",
                "                    CONF_SLAVE_COUNT: 1,\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "    ],\n",
                ")\n",
                "async def test_restore_state_sensor(\n",
                "    hass: HomeAssistant, mock_restore, mock_modbus\n",
                ") -> None:\n",
                "    \"\"\"Run test for sensor restore state.\"\"\"\n",
                "    state = hass.states.get(ENTITY_ID).state\n",
                "    state2 = hass.states.get(ENTITY_ID + \"_1\").state\n",
                "    assert state\n",
                "    assert state2\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"do_config\",\n",
                "    [\n",
                "        {\n",
                "            CONF_SENSORS: [\n",
                "                {\n",
                "                    CONF_NAME: TEST_ENTITY_NAME,\n",
                "                    CONF_ADDRESS: 1234,\n",
                "                    CONF_INPUT_TYPE: CALL_TYPE_REGISTER_INPUT,\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "    ],\n",
                ")\n",
                "async def test_service_sensor_update(hass: HomeAssistant, mock_modbus, mock_ha) -> None:\n",
                "    \"\"\"Run test for service homeassistant.update_entity.\"\"\"\n",
                "    mock_modbus.read_input_registers.return_value = ReadResult([27])\n",
                "    await hass.services.async_call(\n",
                "        \"homeassistant\", \"update_entity\", {\"entity_id\": ENTITY_ID}, blocking=True\n",
                "    )\n",
                "    assert hass.states.get(ENTITY_ID).state == \"27\"\n",
                "    mock_modbus.read_input_registers.return_value = ReadResult([32])\n",
                "    await hass.services.async_call(\n",
                "        \"homeassistant\", \"update_entity\", {\"entity_id\": ENTITY_ID}, blocking=True\n",
                "    )\n",
                "    assert hass.states.get(ENTITY_ID).state == \"32\"\n",
                "\n",
                "\n",
                "async def test_no_discovery_info_sensor(\n",
                "    hass: HomeAssistant, caplog: pytest.LogCaptureFixture\n",
                ") -> None:\n",
                "    \"\"\"Test setup without discovery info.\"\"\"\n",
                "    assert SENSOR_DOMAIN not in hass.config.components\n",
                "    assert await async_setup_component(\n",
                "        hass,\n",
                "        SENSOR_DOMAIN,\n",
                "        {SENSOR_DOMAIN: {\"platform\": MODBUS_DOMAIN}},\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "    assert SENSOR_DOMAIN in hass.config.components"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                1,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                2,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                5,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "match argument number"
        },
        {
            "edit_hunk_pair": [
                5,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                5,
                8
            ],
            "edit_order": "bi-directional",
            "reason": "de-parameterize start_expert"
        },
        {
            "edit_hunk_pair": [
                5,
                9
            ],
            "edit_order": "bi-directional",
            "reason": "de-parameterize end_expert"
        },
        {
            "edit_hunk_pair": [
                6,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "match argument"
        },
        {
            "edit_hunk_pair": [
                7,
                8
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                7,
                9
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        }
    ]
}