{
    "language": "python",
    "commit_url": "https://github.com/home-assistant/core/commit/1f0ea73463f450b86d7f78bbf8d58034038fd53a",
    "commit_message": "Add support for entity aliases to Google Assistant (#84405)",
    "commit_snapshots": {
        "homeassistant/components/google_assistant/helpers.py": [
            [
                "\"\"\"Helper classes for Google Assistant integration.\"\"\"\n",
                "from __future__ import annotations\n",
                "\n",
                "from abc import ABC, abstractmethod\n",
                "from asyncio import gather\n",
                "from collections.abc import Mapping\n",
                "from datetime import datetime, timedelta\n",
                "from http import HTTPStatus\n",
                "import logging\n",
                "import pprint\n",
                "\n",
                "from aiohttp.web import json_response\n",
                "from awesomeversion import AwesomeVersion\n",
                "from yarl import URL\n",
                "\n",
                "from homeassistant.components import webhook\n",
                "from homeassistant.const import (\n",
                "    ATTR_DEVICE_CLASS,\n",
                "    ATTR_SUPPORTED_FEATURES,\n",
                "    CLOUD_NEVER_EXPOSED_ENTITIES,\n",
                "    CONF_NAME,\n",
                "    STATE_UNAVAILABLE,\n",
                ")\n",
                "from homeassistant.core import Context, HomeAssistant, State, callback\n",
                "from homeassistant.helpers import area_registry, device_registry, entity_registry, start\n",
                "from homeassistant.helpers.event import async_call_later\n",
                "from homeassistant.helpers.network import get_url\n",
                "from homeassistant.helpers.storage import Store\n",
                "from homeassistant.util.dt import utcnow\n",
                "\n",
                "from . import trait\n",
                "from .const import (\n",
                "    CONF_ALIASES,\n",
                "    CONF_ROOM_HINT,\n",
                "    DEVICE_CLASS_TO_GOOGLE_TYPES,\n",
                "    DOMAIN,\n",
                "    DOMAIN_TO_GOOGLE_TYPES,\n",
                "    ERR_FUNCTION_NOT_SUPPORTED,\n",
                "    NOT_EXPOSE_LOCAL,\n",
                "    SOURCE_LOCAL,\n",
                "    STORE_AGENT_USER_IDS,\n",
                "    STORE_GOOGLE_LOCAL_WEBHOOK_ID,\n",
                ")\n",
                "from .error import SmartHomeError\n",
                "\n",
                "SYNC_DELAY = 15\n",
                "_LOGGER = logging.getLogger(__name__)\n",
                "LOCAL_SDK_VERSION_HEADER = \"HA-Cloud-Version\"\n",
                "LOCAL_SDK_MIN_VERSION = AwesomeVersion(\"2.1.5\")\n",
                "\n",
                "\n",
                "@callback\n",
                "def _get_registry_entries(\n",
                "    hass: HomeAssistant, entity_id: str\n"
            ],
            {
                "type": "replace",
                "before": [
                    ") -> tuple[device_registry.DeviceEntry | None, area_registry.AreaEntry | None]:\n"
                ],
                "after": [
                    ") -> tuple[\n",
                    "    entity_registry.RegistryEntry | None,\n",
                    "    device_registry.DeviceEntry | None,\n",
                    "    area_registry.AreaEntry | None,\n",
                    "]:\n"
                ],
                "parent_version_range": {
                    "start": 54,
                    "end": 55
                },
                "child_version_range": {
                    "start": 54,
                    "end": 59
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "_get_registry_entries",
                        "signature": "def _get_registry_entries(\n    hass: HomeAssistant, entity_id: str\n)->tuple[device_registry.DeviceEntry | None, area_registry.AreaEntry | None]:",
                        "at_line": 52
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: homeassistant/components/google_assistant/helpers.py\nCode:\n51 51    @callback\n52 52    def _get_registry_entries(\n53 53        hass: HomeAssistant, entity_id: str\n54     - ) -> tuple[device_registry.DeviceEntry | None, area_registry.AreaEntry | None]:\n   54  + ) -> tuple[\n   55  +     entity_registry.RegistryEntry | None,\n   56  +     device_registry.DeviceEntry | None,\n   57  +     area_registry.AreaEntry | None,\n   58  + ]:\n55 59        \"\"\"Get registry entries.\"\"\"\n56 60        ent_reg = entity_registry.async_get(hass)\n57 61        dev_reg = device_registry.async_get(hass)\n       ...\n",
                "file_path": "homeassistant/components/google_assistant/helpers.py",
                "identifiers_before": [
                    "AreaEntry",
                    "DeviceEntry",
                    "area_registry",
                    "device_registry",
                    "tuple"
                ],
                "identifiers_after": [
                    "AreaEntry",
                    "DeviceEntry",
                    "RegistryEntry",
                    "area_registry",
                    "device_registry",
                    "entity_registry",
                    "tuple"
                ],
                "prefix": [
                    "@callback\n",
                    "def _get_registry_entries(\n",
                    "    hass: HomeAssistant, entity_id: str\n"
                ],
                "suffix": [
                    "    \"\"\"Get registry entries.\"\"\"\n",
                    "    ent_reg = entity_registry.async_get(hass)\n",
                    "    dev_reg = device_registry.async_get(hass)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    \"\"\"Get registry entries.\"\"\"\n",
                "    ent_reg = entity_registry.async_get(hass)\n",
                "    dev_reg = device_registry.async_get(hass)\n",
                "    area_reg = area_registry.async_get(hass)\n",
                "\n",
                "    if (entity_entry := ent_reg.async_get(entity_id)) and entity_entry.device_id:\n",
                "        device_entry = dev_reg.devices.get(entity_entry.device_id)\n",
                "    else:\n",
                "        device_entry = None\n",
                "\n",
                "    if entity_entry and entity_entry.area_id:\n",
                "        area_id = entity_entry.area_id\n",
                "    elif device_entry and device_entry.area_id:\n",
                "        area_id = device_entry.area_id\n",
                "    else:\n",
                "        area_id = None\n",
                "\n",
                "    if area_id is not None:\n",
                "        area_entry = area_reg.async_get_area(area_id)\n",
                "    else:\n",
                "        area_entry = None\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    return device_entry, area_entry\n"
                ],
                "after": [
                    "    return entity_entry, device_entry, area_entry\n"
                ],
                "parent_version_range": {
                    "start": 77,
                    "end": 78
                },
                "child_version_range": {
                    "start": 81,
                    "end": 82
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "_get_registry_entries",
                        "signature": "def _get_registry_entries(\n    hass: HomeAssistant, entity_id: str\n)->tuple[device_registry.DeviceEntry | None, area_registry.AreaEntry | None]:",
                        "at_line": 52
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: homeassistant/components/google_assistant/helpers.py\nCode:\n         def _get_registry_entries(\n    hass: HomeAssistant, entity_id: str\n)->tuple[device_registry.DeviceEntry | None, area_registry.AreaEntry | None]:\n             ...\n74 78        else:\n75 79            area_entry = None\n76 80    \n77     -     return device_entry, area_entry\n   81  +     return entity_entry, device_entry, area_entry\n78 82    \n79 83    \n80 84    class AbstractConfig(ABC):\n       ...\n",
                "file_path": "homeassistant/components/google_assistant/helpers.py",
                "identifiers_before": [
                    "area_entry",
                    "device_entry"
                ],
                "identifiers_after": [
                    "area_entry",
                    "device_entry",
                    "entity_entry"
                ],
                "prefix": [
                    "    else:\n",
                    "        area_entry = None\n",
                    "\n"
                ],
                "suffix": [
                    "\n",
                    "\n",
                    "class AbstractConfig(ABC):\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    2
                ]
            },
            [
                "\n",
                "\n",
                "class AbstractConfig(ABC):\n",
                "    \"\"\"Hold the configuration for Google Assistant.\"\"\"\n",
                "\n",
                "    _unsub_report_state = None\n",
                "\n",
                "    def __init__(self, hass):\n",
                "        \"\"\"Initialize abstract config.\"\"\"\n",
                "        self.hass = hass\n",
                "        self._store = None\n",
                "        self._google_sync_unsub = {}\n",
                "        self._local_sdk_active = False\n",
                "        self._local_last_active: datetime | None = None\n",
                "        self._local_sdk_version_warn = False\n",
                "        self.is_supported_cache: dict[str, tuple[int | None, bool]] = {}\n",
                "\n",
                "    async def async_initialize(self):\n",
                "        \"\"\"Perform async initialization of config.\"\"\"\n",
                "        self._store = GoogleConfigStore(self.hass)\n",
                "        await self._store.async_initialize()\n",
                "\n",
                "        if not self.enabled:\n",
                "            return\n",
                "\n",
                "        async def sync_google(_):\n",
                "            \"\"\"Sync entities to Google.\"\"\"\n",
                "            await self.async_sync_entities_all()\n",
                "\n",
                "        start.async_at_start(self.hass, sync_google)\n",
                "\n",
                "    @property\n",
                "    def enabled(self):\n",
                "        \"\"\"Return if Google is enabled.\"\"\"\n",
                "        return False\n",
                "\n",
                "    @property\n",
                "    def entity_config(self):\n",
                "        \"\"\"Return entity config.\"\"\"\n",
                "        return {}\n",
                "\n",
                "    @property\n",
                "    def secure_devices_pin(self):\n",
                "        \"\"\"Return entity config.\"\"\"\n",
                "        return None\n",
                "\n",
                "    @property\n",
                "    def is_reporting_state(self):\n",
                "        \"\"\"Return if we're actively reporting states.\"\"\"\n",
                "        return self._unsub_report_state is not None\n",
                "\n",
                "    @property\n",
                "    def is_local_sdk_active(self):\n",
                "        \"\"\"Return if we're actively accepting local messages.\"\"\"\n",
                "        return self._local_sdk_active\n",
                "\n",
                "    @property\n",
                "    def should_report_state(self):\n",
                "        \"\"\"Return if states should be proactively reported.\"\"\"\n",
                "        return False\n",
                "\n",
                "    @property\n",
                "    def is_local_connected(self) -> bool:\n",
                "        \"\"\"Return if local is connected.\"\"\"\n",
                "        return (\n",
                "            self._local_last_active is not None\n",
                "            # We get a reachable devices intent every minute.\n",
                "            and self._local_last_active > utcnow() - timedelta(seconds=70)\n",
                "        )\n",
                "\n",
                "    def get_local_agent_user_id(self, webhook_id):\n",
                "        \"\"\"Return the user ID to be used for actions received via the local SDK.\n",
                "\n",
                "        Return None is no agent user id is found.\n",
                "        \"\"\"\n",
                "        found_agent_user_id = None\n",
                "        for agent_user_id, agent_user_data in self._store.agent_user_ids.items():\n",
                "            if agent_user_data[STORE_GOOGLE_LOCAL_WEBHOOK_ID] == webhook_id:\n",
                "                found_agent_user_id = agent_user_id\n",
                "                break\n",
                "\n",
                "        return found_agent_user_id\n",
                "\n",
                "    def get_local_webhook_id(self, agent_user_id):\n",
                "        \"\"\"Return the webhook ID to be used for actions for a given agent user id via the local SDK.\"\"\"\n",
                "        if data := self._store.agent_user_ids.get(agent_user_id):\n",
                "            return data[STORE_GOOGLE_LOCAL_WEBHOOK_ID]\n",
                "        return None\n",
                "\n",
                "    @abstractmethod\n",
                "    def get_agent_user_id(self, context):\n",
                "        \"\"\"Get agent user ID from context.\"\"\"\n",
                "\n",
                "    @abstractmethod\n",
                "    def should_expose(self, state) -> bool:\n",
                "        \"\"\"Return if entity should be exposed.\"\"\"\n",
                "\n",
                "    def should_2fa(self, state):\n",
                "        \"\"\"If an entity should have 2FA checked.\"\"\"\n",
                "        return True\n",
                "\n",
                "    async def async_report_state(self, message, agent_user_id: str):\n",
                "        \"\"\"Send a state report to Google.\"\"\"\n",
                "        raise NotImplementedError\n",
                "\n",
                "    async def async_report_state_all(self, message):\n",
                "        \"\"\"Send a state report to Google for all previously synced users.\"\"\"\n",
                "        jobs = [\n",
                "            self.async_report_state(message, agent_user_id)\n",
                "            for agent_user_id in self._store.agent_user_ids\n",
                "        ]\n",
                "        await gather(*jobs)\n",
                "\n",
                "    @callback\n",
                "    def async_enable_report_state(self):\n",
                "        \"\"\"Enable proactive mode.\"\"\"\n",
                "        # Circular dep\n",
                "        # pylint: disable=import-outside-toplevel\n",
                "        from .report_state import async_enable_report_state\n",
                "\n",
                "        if self._unsub_report_state is None:\n",
                "            self._unsub_report_state = async_enable_report_state(self.hass, self)\n",
                "\n",
                "    @callback\n",
                "    def async_disable_report_state(self):\n",
                "        \"\"\"Disable report state.\"\"\"\n",
                "        if self._unsub_report_state is not None:\n",
                "            self._unsub_report_state()\n",
                "            self._unsub_report_state = None\n",
                "\n",
                "    async def async_sync_entities(self, agent_user_id: str):\n",
                "        \"\"\"Sync all entities to Google.\"\"\"\n",
                "        # Remove any pending sync\n",
                "        self._google_sync_unsub.pop(agent_user_id, lambda: None)()\n",
                "        status = await self._async_request_sync_devices(agent_user_id)\n",
                "        if status == HTTPStatus.NOT_FOUND:\n",
                "            await self.async_disconnect_agent_user(agent_user_id)\n",
                "        return status\n",
                "\n",
                "    async def async_sync_entities_all(self):\n",
                "        \"\"\"Sync all entities to Google for all registered agents.\"\"\"\n",
                "        if not self._store.agent_user_ids:\n",
                "            return 204\n",
                "\n",
                "        res = await gather(\n",
                "            *(\n",
                "                self.async_sync_entities(agent_user_id)\n",
                "                for agent_user_id in self._store.agent_user_ids\n",
                "            )\n",
                "        )\n",
                "        return max(res, default=204)\n",
                "\n",
                "    @callback\n",
                "    def async_schedule_google_sync(self, agent_user_id: str):\n",
                "        \"\"\"Schedule a sync.\"\"\"\n",
                "\n",
                "        async def _schedule_callback(_now):\n",
                "            \"\"\"Handle a scheduled sync callback.\"\"\"\n",
                "            self._google_sync_unsub.pop(agent_user_id, None)\n",
                "            await self.async_sync_entities(agent_user_id)\n",
                "\n",
                "        self._google_sync_unsub.pop(agent_user_id, lambda: None)()\n",
                "\n",
                "        self._google_sync_unsub[agent_user_id] = async_call_later(\n",
                "            self.hass, SYNC_DELAY, _schedule_callback\n",
                "        )\n",
                "\n",
                "    @callback\n",
                "    def async_schedule_google_sync_all(self):\n",
                "        \"\"\"Schedule a sync for all registered agents.\"\"\"\n",
                "        for agent_user_id in self._store.agent_user_ids:\n",
                "            self.async_schedule_google_sync(agent_user_id)\n",
                "\n",
                "    async def _async_request_sync_devices(self, agent_user_id: str) -> int:\n",
                "        \"\"\"Trigger a sync with Google.\n",
                "\n",
                "        Return value is the HTTP status code of the sync request.\n",
                "        \"\"\"\n",
                "        raise NotImplementedError\n",
                "\n",
                "    async def async_connect_agent_user(self, agent_user_id: str):\n",
                "        \"\"\"Add a synced and known agent_user_id.\n",
                "\n",
                "        Called before sending a sync response to Google.\n",
                "        \"\"\"\n",
                "        self._store.add_agent_user_id(agent_user_id)\n",
                "\n",
                "    async def async_disconnect_agent_user(self, agent_user_id: str):\n",
                "        \"\"\"Turn off report state and disable further state reporting.\n",
                "\n",
                "        Called when:\n",
                "         - The user disconnects their account from Google.\n",
                "         - When the cloud configuration is initialized\n",
                "         - When sync entities fails with 404\n",
                "        \"\"\"\n",
                "        self._store.pop_agent_user_id(agent_user_id)\n",
                "\n",
                "    @callback\n",
                "    def async_enable_local_sdk(self):\n",
                "        \"\"\"Enable the local SDK.\"\"\"\n",
                "        setup_successful = True\n",
                "        setup_webhook_ids = []\n",
                "\n",
                "        # Don't enable local SDK if ssl is enabled\n",
                "        if self.hass.config.api and self.hass.config.api.use_ssl:\n",
                "            self._local_sdk_active = False\n",
                "            return\n",
                "\n",
                "        for user_agent_id, _ in self._store.agent_user_ids.items():\n",
                "\n",
                "            if (webhook_id := self.get_local_webhook_id(user_agent_id)) is None:\n",
                "                setup_successful = False\n",
                "                break\n",
                "\n",
                "            try:\n",
                "                webhook.async_register(\n",
                "                    self.hass,\n",
                "                    DOMAIN,\n",
                "                    \"Local Support for \" + user_agent_id,\n",
                "                    webhook_id,\n",
                "                    self._handle_local_webhook,\n",
                "                    local_only=True,\n",
                "                )\n",
                "                setup_webhook_ids.append(webhook_id)\n",
                "            except ValueError:\n",
                "                _LOGGER.warning(\n",
                "                    \"Webhook handler %s for agent user id %s is already defined!\",\n",
                "                    webhook_id,\n",
                "                    user_agent_id,\n",
                "                )\n",
                "                setup_successful = False\n",
                "                break\n",
                "\n",
                "        if not setup_successful:\n",
                "            _LOGGER.warning(\n",
                "                \"Local fulfillment failed to setup, falling back to cloud fulfillment\"\n",
                "            )\n",
                "            for setup_webhook_id in setup_webhook_ids:\n",
                "                webhook.async_unregister(self.hass, setup_webhook_id)\n",
                "\n",
                "        self._local_sdk_active = setup_successful\n",
                "\n",
                "    @callback\n",
                "    def async_disable_local_sdk(self):\n",
                "        \"\"\"Disable the local SDK.\"\"\"\n",
                "        if not self._local_sdk_active:\n",
                "            return\n",
                "\n",
                "        for agent_user_id in self._store.agent_user_ids:\n",
                "            webhook.async_unregister(\n",
                "                self.hass, self.get_local_webhook_id(agent_user_id)\n",
                "            )\n",
                "\n",
                "        self._local_sdk_active = False\n",
                "\n",
                "    async def _handle_local_webhook(self, hass, webhook_id, request):\n",
                "        \"\"\"Handle an incoming local SDK message.\"\"\"\n",
                "        # Circular dep\n",
                "        # pylint: disable=import-outside-toplevel\n",
                "        from . import smart_home\n",
                "\n",
                "        self._local_last_active = utcnow()\n",
                "\n",
                "        # Check version local SDK.\n",
                "        version = request.headers.get(\"HA-Cloud-Version\")\n",
                "        if not self._local_sdk_version_warn and (\n",
                "            not version or AwesomeVersion(version) < LOCAL_SDK_MIN_VERSION\n",
                "        ):\n",
                "            _LOGGER.warning(\n",
                "                \"Local SDK version is too old (%s), check documentation on how to update to the latest version\",\n",
                "                version,\n",
                "            )\n",
                "            self._local_sdk_version_warn = True\n",
                "\n",
                "        payload = await request.json()\n",
                "\n",
                "        if _LOGGER.isEnabledFor(logging.DEBUG):\n",
                "            _LOGGER.debug(\n",
                "                \"Received local message from %s (JS %s):\\n%s\\n\",\n",
                "                request.remote,\n",
                "                request.headers.get(\"HA-Cloud-Version\", \"unknown\"),\n",
                "                pprint.pformat(payload),\n",
                "            )\n",
                "\n",
                "        if (agent_user_id := self.get_local_agent_user_id(webhook_id)) is None:\n",
                "            # No agent user linked to this webhook, means that the user has somehow unregistered\n",
                "            # removing webhook and stopping processing of this request.\n",
                "            _LOGGER.error(\n",
                "                \"Cannot process request for webhook %s as no linked agent user is found:\\n%s\\n\",\n",
                "                webhook_id,\n",
                "                pprint.pformat(payload),\n",
                "            )\n",
                "            webhook.async_unregister(self.hass, webhook_id)\n",
                "            return None\n",
                "\n",
                "        if not self.enabled:\n",
                "            return json_response(\n",
                "                smart_home.api_disabled_response(payload, agent_user_id)\n",
                "            )\n",
                "\n",
                "        result = await smart_home.async_handle_message(\n",
                "            self.hass,\n",
                "            self,\n",
                "            agent_user_id,\n",
                "            payload,\n",
                "            SOURCE_LOCAL,\n",
                "        )\n",
                "\n",
                "        if _LOGGER.isEnabledFor(logging.DEBUG):\n",
                "            _LOGGER.debug(\"Responding to local message:\\n%s\\n\", pprint.pformat(result))\n",
                "\n",
                "        return json_response(result)\n",
                "\n",
                "\n",
                "class GoogleConfigStore:\n",
                "    \"\"\"A configuration store for google assistant.\"\"\"\n",
                "\n",
                "    _STORAGE_VERSION = 1\n",
                "    _STORAGE_KEY = DOMAIN\n",
                "\n",
                "    def __init__(self, hass):\n",
                "        \"\"\"Initialize a configuration store.\"\"\"\n",
                "        self._hass = hass\n",
                "        self._store = Store(hass, self._STORAGE_VERSION, self._STORAGE_KEY)\n",
                "        self._data = None\n",
                "\n",
                "    async def async_initialize(self):\n",
                "        \"\"\"Finish initializing the ConfigStore.\"\"\"\n",
                "        should_save_data = False\n",
                "        if (data := await self._store.async_load()) is None:\n",
                "            # if the store is not found create an empty one\n",
                "            # Note that the first request is always a cloud request,\n",
                "            # and that will store the correct agent user id to be used for local requests\n",
                "            data = {\n",
                "                STORE_AGENT_USER_IDS: {},\n",
                "            }\n",
                "            should_save_data = True\n",
                "\n",
                "        for agent_user_id, agent_user_data in data[STORE_AGENT_USER_IDS].items():\n",
                "            if STORE_GOOGLE_LOCAL_WEBHOOK_ID not in agent_user_data:\n",
                "                data[STORE_AGENT_USER_IDS][agent_user_id] = {\n",
                "                    **agent_user_data,\n",
                "                    STORE_GOOGLE_LOCAL_WEBHOOK_ID: webhook.async_generate_id(),\n",
                "                }\n",
                "                should_save_data = True\n",
                "\n",
                "        if should_save_data:\n",
                "            await self._store.async_save(data)\n",
                "\n",
                "        self._data = data\n",
                "\n",
                "    @property\n",
                "    def agent_user_ids(self):\n",
                "        \"\"\"Return a list of connected agent user_ids.\"\"\"\n",
                "        return self._data[STORE_AGENT_USER_IDS]\n",
                "\n",
                "    @callback\n",
                "    def add_agent_user_id(self, agent_user_id):\n",
                "        \"\"\"Add an agent user id to store.\"\"\"\n",
                "        if agent_user_id not in self._data[STORE_AGENT_USER_IDS]:\n",
                "            self._data[STORE_AGENT_USER_IDS][agent_user_id] = {\n",
                "                STORE_GOOGLE_LOCAL_WEBHOOK_ID: webhook.async_generate_id(),\n",
                "            }\n",
                "            self._store.async_delay_save(lambda: self._data, 1.0)\n",
                "\n",
                "    @callback\n",
                "    def pop_agent_user_id(self, agent_user_id):\n",
                "        \"\"\"Remove agent user id from store.\"\"\"\n",
                "        if agent_user_id in self._data[STORE_AGENT_USER_IDS]:\n",
                "            self._data[STORE_AGENT_USER_IDS].pop(agent_user_id, None)\n",
                "            self._store.async_delay_save(lambda: self._data, 1.0)\n",
                "\n",
                "\n",
                "class RequestData:\n",
                "    \"\"\"Hold data associated with a particular request.\"\"\"\n",
                "\n",
                "    def __init__(\n",
                "        self,\n",
                "        config: AbstractConfig,\n",
                "        user_id: str,\n",
                "        source: str,\n",
                "        request_id: str,\n",
                "        devices: list[dict] | None,\n",
                "    ) -> None:\n",
                "        \"\"\"Initialize the request data.\"\"\"\n",
                "        self.config = config\n",
                "        self.source = source\n",
                "        self.request_id = request_id\n",
                "        self.context = Context(user_id=user_id)\n",
                "        self.devices = devices\n",
                "\n",
                "    @property\n",
                "    def is_local_request(self):\n",
                "        \"\"\"Return if this is a local request.\"\"\"\n",
                "        return self.source == SOURCE_LOCAL\n",
                "\n",
                "\n",
                "def get_google_type(domain, device_class):\n",
                "    \"\"\"Google type based on domain and device class.\"\"\"\n",
                "    typ = DEVICE_CLASS_TO_GOOGLE_TYPES.get((domain, device_class))\n",
                "\n",
                "    return typ if typ is not None else DOMAIN_TO_GOOGLE_TYPES[domain]\n",
                "\n",
                "\n",
                "class GoogleEntity:\n",
                "    \"\"\"Adaptation of Entity expressed in Google's terms.\"\"\"\n",
                "\n",
                "    def __init__(\n",
                "        self, hass: HomeAssistant, config: AbstractConfig, state: State\n",
                "    ) -> None:\n",
                "        \"\"\"Initialize a Google entity.\"\"\"\n",
                "        self.hass = hass\n",
                "        self.config = config\n",
                "        self.state = state\n",
                "        self._traits = None\n",
                "\n",
                "    @property\n",
                "    def entity_id(self):\n",
                "        \"\"\"Return entity ID.\"\"\"\n",
                "        return self.state.entity_id\n",
                "\n",
                "    @callback\n",
                "    def traits(self):\n",
                "        \"\"\"Return traits for entity.\"\"\"\n",
                "        if self._traits is not None:\n",
                "            return self._traits\n",
                "\n",
                "        state = self.state\n",
                "        domain = state.domain\n",
                "        attributes = state.attributes\n",
                "        features = attributes.get(ATTR_SUPPORTED_FEATURES, 0)\n",
                "\n",
                "        if not isinstance(features, int):\n",
                "            _LOGGER.warning(\n",
                "                \"Entity %s contains invalid supported_features value %s\",\n",
                "                self.entity_id,\n",
                "                features,\n",
                "            )\n",
                "            return []\n",
                "\n",
                "        device_class = state.attributes.get(ATTR_DEVICE_CLASS)\n",
                "\n",
                "        self._traits = [\n",
                "            Trait(self.hass, state, self.config)\n",
                "            for Trait in trait.TRAITS\n",
                "            if Trait.supported(domain, features, device_class, attributes)\n",
                "        ]\n",
                "        return self._traits\n",
                "\n",
                "    @callback\n",
                "    def should_expose(self):\n",
                "        \"\"\"If entity should be exposed.\"\"\"\n",
                "        return self.config.should_expose(self.state)\n",
                "\n",
                "    @callback\n",
                "    def should_expose_local(self) -> bool:\n",
                "        \"\"\"Return if the entity should be exposed locally.\"\"\"\n",
                "        return (\n",
                "            self.should_expose()\n",
                "            and get_google_type(\n",
                "                self.state.domain, self.state.attributes.get(ATTR_DEVICE_CLASS)\n",
                "            )\n",
                "            not in NOT_EXPOSE_LOCAL\n",
                "            and not self.might_2fa()\n",
                "        )\n",
                "\n",
                "    @callback\n",
                "    def is_supported(self) -> bool:\n",
                "        \"\"\"Return if the entity is supported by Google.\"\"\"\n",
                "        features: int | None = self.state.attributes.get(ATTR_SUPPORTED_FEATURES)\n",
                "\n",
                "        result = self.config.is_supported_cache.get(self.entity_id)\n",
                "\n",
                "        if result is None or result[0] != features:\n",
                "            result = self.config.is_supported_cache[self.entity_id] = (\n",
                "                features,\n",
                "                bool(self.traits()),\n",
                "            )\n",
                "\n",
                "        return result[1]\n",
                "\n",
                "    @callback\n",
                "    def might_2fa(self) -> bool:\n",
                "        \"\"\"Return if the entity might encounter 2FA.\"\"\"\n",
                "        if not self.config.should_2fa(self.state):\n",
                "            return False\n",
                "\n",
                "        return self.might_2fa_traits()\n",
                "\n",
                "    @callback\n",
                "    def might_2fa_traits(self) -> bool:\n",
                "        \"\"\"Return if the entity might encounter 2FA based on just traits.\"\"\"\n",
                "        state = self.state\n",
                "        domain = state.domain\n",
                "        features = state.attributes.get(ATTR_SUPPORTED_FEATURES, 0)\n",
                "        device_class = state.attributes.get(ATTR_DEVICE_CLASS)\n",
                "\n",
                "        return any(\n",
                "            trait.might_2fa(domain, features, device_class) for trait in self.traits()\n",
                "        )\n",
                "\n",
                "    def sync_serialize(self, agent_user_id, instance_uuid):\n",
                "        \"\"\"Serialize entity for a SYNC response.\n",
                "\n",
                "        https://developers.google.com/actions/smarthome/create-app#actiondevicessync\n",
                "        \"\"\"\n",
                "        state = self.state\n",
                "        traits = self.traits()\n",
                "        entity_config = self.config.entity_config.get(state.entity_id, {})\n",
                "        name = (entity_config.get(CONF_NAME) or state.name).strip()\n",
                "\n",
                "        # Find entity/device/area registry entries\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        device_entry, area_entry = _get_registry_entries(self.hass, self.entity_id)\n"
                ],
                "after": [
                    "        entity_entry, device_entry, area_entry = _get_registry_entries(\n",
                    "            self.hass, self.entity_id\n",
                    "        )\n"
                ],
                "parent_version_range": {
                    "start": 590,
                    "end": 591
                },
                "child_version_range": {
                    "start": 594,
                    "end": 597
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "GoogleEntity",
                        "signature": "class GoogleEntity:",
                        "at_line": 482
                    },
                    {
                        "type": "function",
                        "name": "sync_serialize",
                        "signature": "def sync_serialize(self, agent_user_id, instance_uuid):",
                        "at_line": 579
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: homeassistant/components/google_assistant/helpers.py\nCode:\n           class GoogleEntity:\n               ...\n               def sync_serialize(self, agent_user_id, instance_uuid):\n                   ...\n587 591            name = (entity_config.get(CONF_NAME) or state.name).strip()\n588 592    \n589 593            # Find entity/device/area registry entries\n590      -         device_entry, area_entry = _get_registry_entries(self.hass, self.entity_id)\n    594  +         entity_entry, device_entry, area_entry = _get_registry_entries(\n    595  +             self.hass, self.entity_id\n    596  +         )\n591 597    \n592 598            # Build the device info\n593 599            device = {\n         ...\n",
                "file_path": "homeassistant/components/google_assistant/helpers.py",
                "identifiers_before": [
                    "_get_registry_entries",
                    "area_entry",
                    "device_entry",
                    "entity_id",
                    "hass",
                    "self"
                ],
                "identifiers_after": [
                    "_get_registry_entries",
                    "area_entry",
                    "device_entry",
                    "entity_entry",
                    "entity_id",
                    "hass",
                    "self"
                ],
                "prefix": [
                    "        name = (entity_config.get(CONF_NAME) or state.name).strip()\n",
                    "\n",
                    "        # Find entity/device/area registry entries\n"
                ],
                "suffix": [
                    "\n",
                    "        # Build the device info\n",
                    "        device = {\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "entity_entry",
                            "position": {
                                "start": {
                                    "line": 594,
                                    "column": 8
                                },
                                "end": {
                                    "line": 594,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/google_assistant/helpers.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "entity_entry",
                            "position": {
                                "start": {
                                    "line": 594,
                                    "column": 8
                                },
                                "end": {
                                    "line": 594,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/google_assistant/helpers.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "entity_entry",
                            "position": {
                                "start": {
                                    "line": 594,
                                    "column": 8
                                },
                                "end": {
                                    "line": 594,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/google_assistant/helpers.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "entity_entry",
                            "position": {
                                "start": {
                                    "line": 594,
                                    "column": 8
                                },
                                "end": {
                                    "line": 594,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/google_assistant/helpers.py",
                            "hunk_idx": 2,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": [
                    1
                ]
            },
            [
                "\n",
                "        # Build the device info\n",
                "        device = {\n",
                "            \"id\": state.entity_id,\n",
                "            \"name\": {\"name\": name},\n",
                "            \"attributes\": {},\n",
                "            \"traits\": [trait.name for trait in traits],\n",
                "            \"willReportState\": self.config.should_report_state,\n",
                "            \"type\": get_google_type(\n",
                "                state.domain, state.attributes.get(ATTR_DEVICE_CLASS)\n",
                "            ),\n",
                "        }\n",
                "\n",
                "        # Add aliases\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        if aliases := entity_config.get(CONF_ALIASES):\n",
                    "            device[\"name\"][\"nicknames\"] = [name] + aliases\n"
                ],
                "after": [
                    "        if (config_aliases := entity_config.get(CONF_ALIASES, [])) or (\n",
                    "            entity_entry and entity_entry.aliases\n",
                    "        ):\n",
                    "            device[\"name\"][\"nicknames\"] = [name] + config_aliases\n",
                    "            if entity_entry:\n",
                    "                device[\"name\"][\"nicknames\"].extend(entity_entry.aliases)\n"
                ],
                "parent_version_range": {
                    "start": 605,
                    "end": 607
                },
                "child_version_range": {
                    "start": 611,
                    "end": 617
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if aliases :",
                        "start_line": 605,
                        "end_line": 606
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "GoogleEntity",
                        "signature": "class GoogleEntity:",
                        "at_line": 482
                    },
                    {
                        "type": "function",
                        "name": "sync_serialize",
                        "signature": "def sync_serialize(self, agent_user_id, instance_uuid):",
                        "at_line": 579
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: homeassistant/components/google_assistant/helpers.py\nCode:\n           class GoogleEntity:\n               ...\n               def sync_serialize(self, agent_user_id, instance_uuid):\n                   ...\n602 608            }\n603 609    \n604 610            # Add aliases\n605      -         if aliases := entity_config.get(CONF_ALIASES):\n606      -             device[\"name\"][\"nicknames\"] = [name] + aliases\n    611  +         if (config_aliases := entity_config.get(CONF_ALIASES, [])) or (\n    612  +             entity_entry and entity_entry.aliases\n    613  +         ):\n    614  +             device[\"name\"][\"nicknames\"] = [name] + config_aliases\n    615  +             if entity_entry:\n    616  +                 device[\"name\"][\"nicknames\"].extend(entity_entry.aliases)\n607 617    \n608 618            # Add local SDK info if enabled\n609 619            if self.config.is_local_sdk_active and self.should_expose_local():\n         ...\n",
                "file_path": "homeassistant/components/google_assistant/helpers.py",
                "identifiers_before": [
                    "CONF_ALIASES",
                    "aliases",
                    "device",
                    "entity_config",
                    "get",
                    "name"
                ],
                "identifiers_after": [
                    "CONF_ALIASES",
                    "aliases",
                    "config_aliases",
                    "device",
                    "entity_config",
                    "entity_entry",
                    "extend",
                    "get",
                    "name"
                ],
                "prefix": [
                    "        }\n",
                    "\n",
                    "        # Add aliases\n"
                ],
                "suffix": [
                    "\n",
                    "        # Add local SDK info if enabled\n",
                    "        if self.config.is_local_sdk_active and self.should_expose_local():\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "entity_entry",
                            "position": {
                                "start": {
                                    "line": 612,
                                    "column": 12
                                },
                                "end": {
                                    "line": 612,
                                    "column": 24
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/google_assistant/helpers.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "entity_entry",
                            "position": {
                                "start": {
                                    "line": 612,
                                    "column": 29
                                },
                                "end": {
                                    "line": 612,
                                    "column": 41
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/google_assistant/helpers.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "entity_entry",
                            "position": {
                                "start": {
                                    "line": 615,
                                    "column": 15
                                },
                                "end": {
                                    "line": 615,
                                    "column": 27
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/google_assistant/helpers.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 2,
                        "detail": {
                            "identifier": "entity_entry",
                            "position": {
                                "start": {
                                    "line": 616,
                                    "column": 51
                                },
                                "end": {
                                    "line": 616,
                                    "column": 63
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/core/homeassistant/components/google_assistant/helpers.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "        # Add local SDK info if enabled\n",
                "        if self.config.is_local_sdk_active and self.should_expose_local():\n",
                "            device[\"otherDeviceIds\"] = [{\"deviceId\": self.entity_id}]\n",
                "            device[\"customData\"] = {\n",
                "                \"webhookId\": self.config.get_local_webhook_id(agent_user_id),\n",
                "                \"httpPort\": URL(get_url(self.hass, allow_external=False)).port,\n",
                "                \"uuid\": instance_uuid,\n",
                "            }\n",
                "\n",
                "        # Add trait sync attributes\n",
                "        for trt in traits:\n",
                "            device[\"attributes\"].update(trt.sync_attributes())\n",
                "\n",
                "        # Add roomhint\n",
                "        if room := entity_config.get(CONF_ROOM_HINT):\n",
                "            device[\"roomHint\"] = room\n",
                "        elif area_entry and area_entry.name:\n",
                "            device[\"roomHint\"] = area_entry.name\n",
                "\n",
                "        # Add deviceInfo\n",
                "        if not device_entry:\n",
                "            return device\n",
                "\n",
                "        device_info = {}\n",
                "\n",
                "        if device_entry.manufacturer:\n",
                "            device_info[\"manufacturer\"] = device_entry.manufacturer\n",
                "        if device_entry.model:\n",
                "            device_info[\"model\"] = device_entry.model\n",
                "        if device_entry.sw_version:\n",
                "            device_info[\"swVersion\"] = device_entry.sw_version\n",
                "\n",
                "        if device_info:\n",
                "            device[\"deviceInfo\"] = device_info\n",
                "\n",
                "        return device\n",
                "\n",
                "    @callback\n",
                "    def query_serialize(self):\n",
                "        \"\"\"Serialize entity for a QUERY response.\n",
                "\n",
                "        https://developers.google.com/actions/smarthome/create-app#actiondevicesquery\n",
                "        \"\"\"\n",
                "        state = self.state\n",
                "\n",
                "        if state.state == STATE_UNAVAILABLE:\n",
                "            return {\"online\": False}\n",
                "\n",
                "        attrs = {\"online\": True}\n",
                "\n",
                "        for trt in self.traits():\n",
                "            deep_update(attrs, trt.query_attributes())\n",
                "\n",
                "        return attrs\n",
                "\n",
                "    @callback\n",
                "    def reachable_device_serialize(self):\n",
                "        \"\"\"Serialize entity for a REACHABLE_DEVICE response.\"\"\"\n",
                "        return {\"verificationId\": self.entity_id}\n",
                "\n",
                "    async def execute(self, data, command_payload):\n",
                "        \"\"\"Execute a command.\n",
                "\n",
                "        https://developers.google.com/actions/smarthome/create-app#actiondevicesexecute\n",
                "        \"\"\"\n",
                "        command = command_payload[\"command\"]\n",
                "        params = command_payload.get(\"params\", {})\n",
                "        challenge = command_payload.get(\"challenge\", {})\n",
                "        executed = False\n",
                "        for trt in self.traits():\n",
                "            if trt.can_execute(command, params):\n",
                "                await trt.execute(command, data, params, challenge)\n",
                "                executed = True\n",
                "                break\n",
                "\n",
                "        if not executed:\n",
                "            raise SmartHomeError(\n",
                "                ERR_FUNCTION_NOT_SUPPORTED,\n",
                "                f\"Unable to execute {command} for {self.state.entity_id}\",\n",
                "            )\n",
                "\n",
                "    @callback\n",
                "    def async_update(self):\n",
                "        \"\"\"Update the entity with latest info from Home Assistant.\"\"\"\n",
                "        self.state = self.hass.states.get(self.entity_id)\n",
                "\n",
                "        if self._traits is None:\n",
                "            return\n",
                "\n",
                "        for trt in self._traits:\n",
                "            trt.state = self.state\n",
                "\n",
                "\n",
                "def deep_update(target, source):\n",
                "    \"\"\"Update a nested dictionary with another nested dictionary.\"\"\"\n",
                "    for key, value in source.items():\n",
                "        if isinstance(value, Mapping):\n",
                "            target[key] = deep_update(target.get(key, {}), value)\n",
                "        else:\n",
                "            target[key] = value\n",
                "    return target\n",
                "\n",
                "\n",
                "@callback\n",
                "def async_get_entities(\n",
                "    hass: HomeAssistant, config: AbstractConfig\n",
                ") -> list[GoogleEntity]:\n",
                "    \"\"\"Return all entities that are supported by Google.\"\"\"\n",
                "    entities = []\n",
                "    for state in hass.states.async_all():\n",
                "        if state.entity_id in CLOUD_NEVER_EXPOSED_ENTITIES:\n",
                "            continue\n",
                "\n",
                "        entity = GoogleEntity(hass, config, state)\n",
                "\n",
                "        if entity.is_supported():\n",
                "            entities.append(entity)\n",
                "\n",
                "    return entities"
            ]
        ],
        "tests/components/google_assistant/test_smart_home.py": [
            [
                "\"\"\"Test Google Smart Home.\"\"\"\n",
                "import asyncio\n",
                "from unittest.mock import ANY, call, patch\n",
                "\n",
                "import pytest\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "from pytest_unordered import unordered\n"
                ],
                "parent_version_range": {
                    "start": 5,
                    "end": 5
                },
                "child_version_range": {
                    "start": 5,
                    "end": 6
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 4,
                "hunk_diff": "File: tests/components/google_assistant/test_smart_home.py\nCode:\n  ...\n2 2    from unittest.mock import ANY, call, patch\n3 3    \n4 4    import pytest\n  5  + from pytest_unordered import unordered\n5 6    \n6 7    from homeassistant.components import camera\n7 8    from homeassistant.components.climate import ATTR_MAX_TEMP, ATTR_MIN_TEMP, HVACMode\n     ...\n",
                "file_path": "tests/components/google_assistant/test_smart_home.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "pytest_unordered",
                    "unordered"
                ],
                "prefix": [
                    "from unittest.mock import ANY, call, patch\n",
                    "\n",
                    "import pytest\n"
                ],
                "suffix": [
                    "\n",
                    "from homeassistant.components import camera\n",
                    "from homeassistant.components.climate import ATTR_MAX_TEMP, ATTR_MIN_TEMP, HVACMode\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "from homeassistant.components import camera\n",
                "from homeassistant.components.climate import ATTR_MAX_TEMP, ATTR_MIN_TEMP, HVACMode\n",
                "from homeassistant.components.demo.binary_sensor import DemoBinarySensor\n",
                "from homeassistant.components.demo.cover import DemoCover\n",
                "from homeassistant.components.demo.light import LIGHT_EFFECT_LIST, DemoLight\n",
                "from homeassistant.components.demo.media_player import AbstractDemoPlayer\n",
                "from homeassistant.components.demo.switch import DemoSwitch\n",
                "from homeassistant.components.google_assistant import (\n",
                "    EVENT_COMMAND_RECEIVED,\n",
                "    EVENT_QUERY_RECEIVED,\n",
                "    EVENT_SYNC_RECEIVED,\n",
                "    const,\n",
                "    smart_home as sh,\n",
                "    trait,\n",
                ")\n",
                "from homeassistant.config import async_process_ha_core_config\n",
                "from homeassistant.const import ATTR_UNIT_OF_MEASUREMENT, TEMP_CELSIUS, __version__\n",
                "from homeassistant.core import EVENT_CALL_SERVICE, State\n",
                "from homeassistant.helpers import device_registry, entity_platform\n",
                "from homeassistant.setup import async_setup_component\n",
                "\n",
                "from . import BASIC_CONFIG, MockConfig\n",
                "\n",
                "from tests.common import (\n",
                "    async_capture_events,\n",
                "    mock_area_registry,\n",
                "    mock_device_registry,\n",
                "    mock_registry,\n",
                ")\n",
                "\n",
                "REQ_ID = \"ff36a3cc-ec34-11e6-b1a0-64510650abcf\"\n",
                "\n",
                "\n",
                "@pytest.fixture\n",
                "def registries(hass):\n",
                "    \"\"\"Registry mock setup.\"\"\"\n",
                "    from types import SimpleNamespace\n",
                "\n",
                "    ret = SimpleNamespace()\n",
                "    ret.entity = mock_registry(hass)\n",
                "    ret.device = mock_device_registry(hass)\n",
                "    ret.area = mock_area_registry(hass)\n",
                "    return ret\n",
                "\n",
                "\n",
                "async def test_async_handle_message(hass):\n",
                "    \"\"\"Test the async handle message method.\"\"\"\n",
                "    config = MockConfig(\n",
                "        should_expose=lambda state: state.entity_id != \"light.not_expose\",\n",
                "        entity_config={\n",
                "            \"light.demo_light\": {\n",
                "                const.CONF_ROOM_HINT: \"Living Room\",\n",
                "                const.CONF_ALIASES: [\"Hello\", \"World\"],\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        config,\n",
                "        \"test-agent\",\n",
                "        {\n",
                "            \"requestId\": REQ_ID,\n",
                "            \"inputs\": [\n",
                "                {\"intent\": \"action.devices.SYNC\"},\n",
                "                {\"intent\": \"action.devices.SYNC\"},\n",
                "            ],\n",
                "        },\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\"errorCode\": const.ERR_PROTOCOL_ERROR},\n",
                "    }\n",
                "\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        config,\n",
                "        \"test-agent\",\n",
                "        {\n",
                "            \"requestId\": REQ_ID,\n",
                "            \"inputs\": [\n",
                "                {\"intent\": \"action.devices.DOES_NOT_EXIST\"},\n",
                "            ],\n",
                "        },\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\"errorCode\": const.ERR_PROTOCOL_ERROR},\n",
                "    }\n",
                "\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "async def test_sync_message(hass):\n"
                ],
                "after": [
                    "async def test_sync_message(hass, registries):\n"
                ],
                "parent_version_range": {
                    "start": 103,
                    "end": 104
                },
                "child_version_range": {
                    "start": 104,
                    "end": 105
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_sync_message",
                        "signature": "def test_sync_message(hass):",
                        "at_line": 103
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: tests/components/google_assistant/test_smart_home.py\nCode:\n100 101        await hass.async_block_till_done()\n101 102    \n102 103    \n103      - async def test_sync_message(hass):\n    104  + async def test_sync_message(hass, registries):\n104 105        \"\"\"Test a sync message.\"\"\"\n         ...\n",
                "file_path": "tests/components/google_assistant/test_smart_home.py",
                "identifiers_before": [
                    "hass",
                    "test_sync_message"
                ],
                "identifiers_after": [
                    "hass",
                    "registries",
                    "test_sync_message"
                ],
                "prefix": [
                    "    await hass.async_block_till_done()\n",
                    "\n",
                    "\n"
                ],
                "suffix": [
                    "    \"\"\"Test a sync message.\"\"\"\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    \"\"\"Test a sync message.\"\"\"\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    entity = registries.entity.async_get_or_create(\n",
                    "        \"light\",\n",
                    "        \"test\",\n",
                    "        \"unique-demo-light\",\n",
                    "        suggested_object_id=\"demo_light\",\n",
                    "    )\n",
                    "    registries.entity.async_update_entity(\n",
                    "        entity.entity_id,\n",
                    "        aliases={\"Stay\", \"Healthy\"},\n",
                    "    )\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 105,
                    "end": 105
                },
                "child_version_range": {
                    "start": 106,
                    "end": 117
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_sync_message",
                        "signature": "def test_sync_message(hass):",
                        "at_line": 103
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: tests/components/google_assistant/test_smart_home.py\nCode:\n           def test_sync_message(hass):\n               ...\n104 105        \"\"\"Test a sync message.\"\"\"\n    106  +     entity = registries.entity.async_get_or_create(\n    107  +         \"light\",\n    108  +         \"test\",\n    109  +         \"unique-demo-light\",\n    110  +         suggested_object_id=\"demo_light\",\n    111  +     )\n    112  +     registries.entity.async_update_entity(\n    113  +         entity.entity_id,\n    114  +         aliases={\"Stay\", \"Healthy\"},\n    115  +     )\n    116  + \n105 117        light = DemoLight(\n         ...\n",
                "file_path": "tests/components/google_assistant/test_smart_home.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "aliases",
                    "async_get_or_create",
                    "async_update_entity",
                    "entity",
                    "entity_id",
                    "registries",
                    "suggested_object_id"
                ],
                "prefix": [
                    "    \"\"\"Test a sync message.\"\"\"\n"
                ],
                "suffix": [
                    "    light = DemoLight(\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    light = DemoLight(\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        None,\n"
                ],
                "after": [
                    "        \"unique-demo-light\",\n"
                ],
                "parent_version_range": {
                    "start": 106,
                    "end": 107
                },
                "child_version_range": {
                    "start": 118,
                    "end": 119
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_sync_message",
                        "signature": "def test_sync_message(hass):",
                        "at_line": 103
                    },
                    {
                        "type": "call",
                        "name": "DemoLight",
                        "signature": "DemoLight(\n        None,\n        \"Demo Light\",\n        state=False,\n        hs_color=(180, 75),\n        effect_list=LIGHT_EFFECT_LIST,\n        effect=LIGHT_EFFECT_LIST[0],\n    )",
                        "at_line": 105,
                        "argument": "None"
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: tests/components/google_assistant/test_smart_home.py\nCode:\n           def test_sync_message(hass):\n               ...\n105 117        light = DemoLight(\n106      -         None,\n    118  +         \"unique-demo-light\",\n107 119            \"Demo Light\",\n108 120            state=False,\n109 121            hs_color=(180, 75),\n         ...\n",
                "file_path": "tests/components/google_assistant/test_smart_home.py",
                "identifiers_before": [],
                "identifiers_after": [],
                "prefix": [
                    "    light = DemoLight(\n"
                ],
                "suffix": [
                    "        \"Demo Light\",\n",
                    "        state=False,\n",
                    "        hs_color=(180, 75),\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        \"Demo Light\",\n",
                "        state=False,\n",
                "        hs_color=(180, 75),\n",
                "        effect_list=LIGHT_EFFECT_LIST,\n",
                "        effect=LIGHT_EFFECT_LIST[0],\n",
                "    )\n",
                "    light.hass = hass\n",
                "    light.entity_id = \"light.demo_light\"\n",
                "    await light.async_update_ha_state()\n",
                "\n",
                "    # This should not show up in the sync request\n",
                "    hass.states.async_set(\"sensor.no_match\", \"something\")\n",
                "\n",
                "    # Excluded via config\n",
                "    hass.states.async_set(\"light.not_expose\", \"on\")\n",
                "\n",
                "    config = MockConfig(\n",
                "        should_expose=lambda state: state.entity_id != \"light.not_expose\",\n",
                "        entity_config={\n",
                "            \"light.demo_light\": {\n",
                "                const.CONF_ROOM_HINT: \"Living Room\",\n",
                "                const.CONF_ALIASES: [\"Hello\", \"World\"],\n",
                "            }\n",
                "        },\n",
                "    )\n",
                "\n",
                "    events = async_capture_events(hass, EVENT_SYNC_RECEIVED)\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        config,\n",
                "        \"test-agent\",\n",
                "        {\"requestId\": REQ_ID, \"inputs\": [{\"intent\": \"action.devices.SYNC\"}]},\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"agentUserId\": \"test-agent\",\n",
                "            \"devices\": [\n",
                "                {\n",
                "                    \"id\": \"light.demo_light\",\n",
                "                    \"name\": {\n",
                "                        \"name\": \"Demo Light\",\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                        \"nicknames\": [\"Demo Light\", \"Hello\", \"World\"],\n"
                ],
                "after": [
                    "                        \"nicknames\": unordered(\n",
                    "                            [\n",
                    "                                \"Demo Light\",\n",
                    "                                \"Hello\",\n",
                    "                                \"World\",\n",
                    "                                \"Stay\",\n",
                    "                                \"Healthy\",\n",
                    "                            ]\n",
                    "                        ),\n"
                ],
                "parent_version_range": {
                    "start": 152,
                    "end": 153
                },
                "child_version_range": {
                    "start": 164,
                    "end": 173
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_sync_message",
                        "signature": "def test_sync_message(hass):",
                        "at_line": 103
                    }
                ],
                "idx": 8,
                "hunk_diff": "File: tests/components/google_assistant/test_smart_home.py\nCode:\n           def test_sync_message(hass):\n               ...\n149 161                        \"id\": \"light.demo_light\",\n150 162                        \"name\": {\n151 163                            \"name\": \"Demo Light\",\n152      -                         \"nicknames\": [\"Demo Light\", \"Hello\", \"World\"],\n    164  +                         \"nicknames\": unordered(\n    165  +                             [\n    166  +                                 \"Demo Light\",\n    167  +                                 \"Hello\",\n    168  +                                 \"World\",\n    169  +                                 \"Stay\",\n    170  +                                 \"Healthy\",\n    171  +                             ]\n    172  +                         ),\n153 173                        },\n154 174                        \"traits\": [\n155 175                            trait.TRAIT_BRIGHTNESS,\n         ...\n",
                "file_path": "tests/components/google_assistant/test_smart_home.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "unordered"
                ],
                "prefix": [
                    "                    \"id\": \"light.demo_light\",\n",
                    "                    \"name\": {\n",
                    "                        \"name\": \"Demo Light\",\n"
                ],
                "suffix": [
                    "                    },\n",
                    "                    \"traits\": [\n",
                    "                        trait.TRAIT_BRIGHTNESS,\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                    },\n",
                "                    \"traits\": [\n",
                "                        trait.TRAIT_BRIGHTNESS,\n",
                "                        trait.TRAIT_ONOFF,\n",
                "                        trait.TRAIT_COLOR_SETTING,\n",
                "                        trait.TRAIT_MODES,\n",
                "                    ],\n",
                "                    \"type\": const.TYPE_LIGHT,\n",
                "                    \"willReportState\": False,\n",
                "                    \"attributes\": {\n",
                "                        \"availableModes\": [\n",
                "                            {\n",
                "                                \"name\": \"effect\",\n",
                "                                \"name_values\": [\n",
                "                                    {\"lang\": \"en\", \"name_synonym\": [\"effect\"]}\n",
                "                                ],\n",
                "                                \"ordered\": False,\n",
                "                                \"settings\": [\n",
                "                                    {\n",
                "                                        \"setting_name\": \"rainbow\",\n",
                "                                        \"setting_values\": [\n",
                "                                            {\n",
                "                                                \"lang\": \"en\",\n",
                "                                                \"setting_synonym\": [\"rainbow\"],\n",
                "                                            }\n",
                "                                        ],\n",
                "                                    },\n",
                "                                    {\n",
                "                                        \"setting_name\": \"none\",\n",
                "                                        \"setting_values\": [\n"
            ],
            {
                "type": "replace",
                "before": [
                    "                                            {\"lang\": \"en\", \"setting_synonym\": [\"none\"]}\n"
                ],
                "after": [
                    "                                            {\n",
                    "                                                \"lang\": \"en\",\n",
                    "                                                \"setting_synonym\": [\"none\"],\n",
                    "                                            }\n"
                ],
                "parent_version_range": {
                    "start": 183,
                    "end": 184
                },
                "child_version_range": {
                    "start": 203,
                    "end": 207
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "test_sync_message",
                        "signature": "def test_sync_message(hass):",
                        "at_line": 103
                    }
                ],
                "idx": 9,
                "hunk_diff": "File: tests/components/google_assistant/test_smart_home.py\nCode:\n           def test_sync_message(hass):\n               ...\n180 200                                        {\n181 201                                            \"setting_name\": \"none\",\n182 202                                            \"setting_values\": [\n183      -                                             {\"lang\": \"en\", \"setting_synonym\": [\"none\"]}\n    203  +                                             {\n    204  +                                                 \"lang\": \"en\",\n    205  +                                                 \"setting_synonym\": [\"none\"],\n    206  +                                             }\n184 207                                            ],\n185 208                                        },\n186 209                                    ],\n         ...\n",
                "file_path": "tests/components/google_assistant/test_smart_home.py",
                "identifiers_before": [],
                "identifiers_after": [],
                "prefix": [
                    "                                    {\n",
                    "                                        \"setting_name\": \"none\",\n",
                    "                                        \"setting_values\": [\n"
                ],
                "suffix": [
                    "                                        ],\n",
                    "                                    },\n",
                    "                                ],\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                                        ],\n",
                "                                    },\n",
                "                                ],\n",
                "                            }\n",
                "                        ],\n",
                "                        \"colorModel\": \"hsv\",\n",
                "                        \"colorTemperatureRange\": {\n",
                "                            \"temperatureMinK\": 2000,\n",
                "                            \"temperatureMaxK\": 6535,\n",
                "                        },\n",
                "                    },\n",
                "                    \"roomHint\": \"Living Room\",\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "    }\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(events) == 1\n",
                "    assert events[0].event_type == EVENT_SYNC_RECEIVED\n",
                "    assert events[0].data == {\"request_id\": REQ_ID, \"source\": \"cloud\"}\n",
                "\n",
                "\n",
                "# pylint: disable=redefined-outer-name\n",
                "@pytest.mark.parametrize(\"area_on_device\", [True, False])\n",
                "async def test_sync_in_area(area_on_device, hass, registries):\n",
                "    \"\"\"Test a sync message where room hint comes from area.\"\"\"\n",
                "    area = registries.area.async_create(\"Living Room\")\n",
                "\n",
                "    device = registries.device.async_get_or_create(\n",
                "        config_entry_id=\"1234\",\n",
                "        manufacturer=\"Someone\",\n",
                "        model=\"Some model\",\n",
                "        sw_version=\"Some Version\",\n",
                "        connections={(device_registry.CONNECTION_NETWORK_MAC, \"12:34:56:AB:CD:EF\")},\n",
                "    )\n",
                "    registries.device.async_update_device(\n",
                "        device.id, area_id=area.id if area_on_device else None\n",
                "    )\n",
                "\n",
                "    entity = registries.entity.async_get_or_create(\n",
                "        \"light\",\n",
                "        \"test\",\n",
                "        \"1235\",\n",
                "        suggested_object_id=\"demo_light\",\n",
                "        device_id=device.id,\n",
                "    )\n",
                "    entity = registries.entity.async_update_entity(\n",
                "        entity.entity_id, area_id=area.id if not area_on_device else None\n",
                "    )\n",
                "\n",
                "    light = DemoLight(\n",
                "        None,\n",
                "        \"Demo Light\",\n",
                "        state=False,\n",
                "        hs_color=(180, 75),\n",
                "        effect_list=LIGHT_EFFECT_LIST,\n",
                "        effect=LIGHT_EFFECT_LIST[0],\n",
                "    )\n",
                "    light.hass = hass\n",
                "    light.entity_id = entity.entity_id\n",
                "    await light.async_update_ha_state()\n",
                "\n",
                "    config = MockConfig(should_expose=lambda _: True, entity_config={})\n",
                "\n",
                "    events = async_capture_events(hass, EVENT_SYNC_RECEIVED)\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        config,\n",
                "        \"test-agent\",\n",
                "        {\"requestId\": REQ_ID, \"inputs\": [{\"intent\": \"action.devices.SYNC\"}]},\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"agentUserId\": \"test-agent\",\n",
                "            \"devices\": [\n",
                "                {\n",
                "                    \"id\": \"light.demo_light\",\n",
                "                    \"name\": {\"name\": \"Demo Light\"},\n",
                "                    \"traits\": [\n",
                "                        trait.TRAIT_BRIGHTNESS,\n",
                "                        trait.TRAIT_ONOFF,\n",
                "                        trait.TRAIT_COLOR_SETTING,\n",
                "                        trait.TRAIT_MODES,\n",
                "                    ],\n",
                "                    \"type\": const.TYPE_LIGHT,\n",
                "                    \"willReportState\": False,\n",
                "                    \"attributes\": {\n",
                "                        \"availableModes\": [\n",
                "                            {\n",
                "                                \"name\": \"effect\",\n",
                "                                \"name_values\": [\n",
                "                                    {\"lang\": \"en\", \"name_synonym\": [\"effect\"]}\n",
                "                                ],\n",
                "                                \"ordered\": False,\n",
                "                                \"settings\": [\n",
                "                                    {\n",
                "                                        \"setting_name\": \"rainbow\",\n",
                "                                        \"setting_values\": [\n",
                "                                            {\n",
                "                                                \"lang\": \"en\",\n",
                "                                                \"setting_synonym\": [\"rainbow\"],\n",
                "                                            }\n",
                "                                        ],\n",
                "                                    },\n",
                "                                    {\n",
                "                                        \"setting_name\": \"none\",\n",
                "                                        \"setting_values\": [\n",
                "                                            {\"lang\": \"en\", \"setting_synonym\": [\"none\"]}\n",
                "                                        ],\n",
                "                                    },\n",
                "                                ],\n",
                "                            }\n",
                "                        ],\n",
                "                        \"colorModel\": \"hsv\",\n",
                "                        \"colorTemperatureRange\": {\n",
                "                            \"temperatureMinK\": 2000,\n",
                "                            \"temperatureMaxK\": 6535,\n",
                "                        },\n",
                "                    },\n",
                "                    \"deviceInfo\": {\n",
                "                        \"manufacturer\": \"Someone\",\n",
                "                        \"model\": \"Some model\",\n",
                "                        \"swVersion\": \"Some Version\",\n",
                "                    },\n",
                "                    \"roomHint\": \"Living Room\",\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "    }\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(events) == 1\n",
                "    assert events[0].event_type == EVENT_SYNC_RECEIVED\n",
                "    assert events[0].data == {\"request_id\": REQ_ID, \"source\": \"cloud\"}\n",
                "\n",
                "\n",
                "async def test_query_message(hass):\n",
                "    \"\"\"Test a sync message.\"\"\"\n",
                "    light = DemoLight(\n",
                "        None,\n",
                "        \"Demo Light\",\n",
                "        state=False,\n",
                "        hs_color=(180, 75),\n",
                "        effect_list=LIGHT_EFFECT_LIST,\n",
                "        effect=LIGHT_EFFECT_LIST[0],\n",
                "    )\n",
                "    light.hass = hass\n",
                "    light.entity_id = \"light.demo_light\"\n",
                "    await light.async_update_ha_state()\n",
                "\n",
                "    light2 = DemoLight(\n",
                "        None, \"Another Light\", state=True, hs_color=(180, 75), ct=400, brightness=78\n",
                "    )\n",
                "    light2.hass = hass\n",
                "    light2.entity_id = \"light.another_light\"\n",
                "    await light2.async_update_ha_state()\n",
                "\n",
                "    light3 = DemoLight(None, \"Color temp Light\", state=True, ct=400, brightness=200)\n",
                "    light3.hass = hass\n",
                "    light3.entity_id = \"light.color_temp_light\"\n",
                "    await light3.async_update_ha_state()\n",
                "\n",
                "    events = async_capture_events(hass, EVENT_QUERY_RECEIVED)\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        \"test-agent\",\n",
                "        {\n",
                "            \"requestId\": REQ_ID,\n",
                "            \"inputs\": [\n",
                "                {\n",
                "                    \"intent\": \"action.devices.QUERY\",\n",
                "                    \"payload\": {\n",
                "                        \"devices\": [\n",
                "                            {\"id\": \"light.demo_light\"},\n",
                "                            {\"id\": \"light.another_light\"},\n",
                "                            {\"id\": \"light.color_temp_light\"},\n",
                "                            {\"id\": \"light.non_existing\"},\n",
                "                        ]\n",
                "                    },\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"devices\": {\n",
                "                \"light.non_existing\": {\"online\": False},\n",
                "                \"light.demo_light\": {\"on\": False, \"online\": True},\n",
                "                \"light.another_light\": {\n",
                "                    \"on\": True,\n",
                "                    \"online\": True,\n",
                "                    \"brightness\": 31,\n",
                "                    \"color\": {\n",
                "                        \"spectrumHsv\": {\n",
                "                            \"hue\": 180,\n",
                "                            \"saturation\": 0.75,\n",
                "                            \"value\": 0.3058823529411765,\n",
                "                        },\n",
                "                    },\n",
                "                },\n",
                "                \"light.color_temp_light\": {\n",
                "                    \"on\": True,\n",
                "                    \"online\": True,\n",
                "                    \"brightness\": 78,\n",
                "                    \"color\": {\"temperatureK\": 2500},\n",
                "                },\n",
                "            }\n",
                "        },\n",
                "    }\n",
                "\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(events) == 1\n",
                "    assert events[0].event_type == EVENT_QUERY_RECEIVED\n",
                "    assert events[0].data == {\n",
                "        \"request_id\": REQ_ID,\n",
                "        \"entity_id\": [\n",
                "            \"light.demo_light\",\n",
                "            \"light.another_light\",\n",
                "            \"light.color_temp_light\",\n",
                "            \"light.non_existing\",\n",
                "        ],\n",
                "        \"source\": \"cloud\",\n",
                "    }\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"report_state,on,brightness,value\", [(False, True, 20, 0.2), (True, ANY, ANY, ANY)]\n",
                ")\n",
                "async def test_execute(hass, report_state, on, brightness, value):\n",
                "    \"\"\"Test an execute command.\"\"\"\n",
                "    await async_setup_component(hass, \"light\", {\"light\": {\"platform\": \"demo\"}})\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    await hass.services.async_call(\n",
                "        \"light\", \"turn_off\", {\"entity_id\": \"light.ceiling_lights\"}, blocking=True\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    events = async_capture_events(hass, EVENT_COMMAND_RECEIVED)\n",
                "    service_events = async_capture_events(hass, EVENT_CALL_SERVICE)\n",
                "\n",
                "    with patch.object(\n",
                "        hass.services, \"async_call\", wraps=hass.services.async_call\n",
                "    ) as call_service_mock:\n",
                "        result = await sh.async_handle_message(\n",
                "            hass,\n",
                "            MockConfig(should_report_state=report_state),\n",
                "            None,\n",
                "            {\n",
                "                \"requestId\": REQ_ID,\n",
                "                \"inputs\": [\n",
                "                    {\n",
                "                        \"intent\": \"action.devices.EXECUTE\",\n",
                "                        \"payload\": {\n",
                "                            \"commands\": [\n",
                "                                {\n",
                "                                    \"devices\": [\n",
                "                                        {\"id\": \"light.non_existing\"},\n",
                "                                        {\"id\": \"light.ceiling_lights\"},\n",
                "                                        {\"id\": \"light.kitchen_lights\"},\n",
                "                                    ],\n",
                "                                    \"execution\": [\n",
                "                                        {\n",
                "                                            \"command\": \"action.devices.commands.OnOff\",\n",
                "                                            \"params\": {\"on\": True},\n",
                "                                        },\n",
                "                                        {\n",
                "                                            \"command\": \"action.devices.commands.BrightnessAbsolute\",\n",
                "                                            \"params\": {\"brightness\": 20},\n",
                "                                        },\n",
                "                                    ],\n",
                "                                }\n",
                "                            ]\n",
                "                        },\n",
                "                    }\n",
                "                ],\n",
                "            },\n",
                "            const.SOURCE_CLOUD,\n",
                "        )\n",
                "        assert call_service_mock.call_count == 4\n",
                "        expected_calls = [\n",
                "            call(\n",
                "                \"light\",\n",
                "                \"turn_on\",\n",
                "                {\"entity_id\": \"light.ceiling_lights\"},\n",
                "                blocking=not report_state,\n",
                "                context=ANY,\n",
                "            ),\n",
                "            call(\n",
                "                \"light\",\n",
                "                \"turn_on\",\n",
                "                {\"entity_id\": \"light.kitchen_lights\"},\n",
                "                blocking=not report_state,\n",
                "                context=ANY,\n",
                "            ),\n",
                "            call(\n",
                "                \"light\",\n",
                "                \"turn_on\",\n",
                "                {\"entity_id\": \"light.ceiling_lights\", \"brightness_pct\": 20},\n",
                "                blocking=not report_state,\n",
                "                context=ANY,\n",
                "            ),\n",
                "            call(\n",
                "                \"light\",\n",
                "                \"turn_on\",\n",
                "                {\"entity_id\": \"light.kitchen_lights\", \"brightness_pct\": 20},\n",
                "                blocking=not report_state,\n",
                "                context=ANY,\n",
                "            ),\n",
                "        ]\n",
                "        call_service_mock.assert_has_awaits(expected_calls, any_order=True)\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"commands\": [\n",
                "                {\n",
                "                    \"ids\": [\"light.non_existing\"],\n",
                "                    \"status\": \"ERROR\",\n",
                "                    \"errorCode\": \"deviceOffline\",\n",
                "                },\n",
                "                {\n",
                "                    \"ids\": [\"light.ceiling_lights\"],\n",
                "                    \"status\": \"SUCCESS\",\n",
                "                    \"states\": {\n",
                "                        \"on\": on,\n",
                "                        \"online\": True,\n",
                "                        \"brightness\": brightness,\n",
                "                        \"color\": {\"temperatureK\": 2631},\n",
                "                    },\n",
                "                },\n",
                "                {\n",
                "                    \"ids\": [\"light.kitchen_lights\"],\n",
                "                    \"status\": \"SUCCESS\",\n",
                "                    \"states\": {\n",
                "                        \"on\": True,\n",
                "                        \"online\": True,\n",
                "                        \"brightness\": brightness,\n",
                "                        \"color\": {\n",
                "                            \"spectrumHsv\": {\n",
                "                                \"hue\": 345,\n",
                "                                \"saturation\": 0.75,\n",
                "                                \"value\": value,\n",
                "                            },\n",
                "                        },\n",
                "                    },\n",
                "                },\n",
                "            ]\n",
                "        },\n",
                "    }\n",
                "\n",
                "    assert len(events) == 1\n",
                "    assert events[0].event_type == EVENT_COMMAND_RECEIVED\n",
                "    assert events[0].data == {\n",
                "        \"request_id\": REQ_ID,\n",
                "        \"entity_id\": [\n",
                "            \"light.non_existing\",\n",
                "            \"light.ceiling_lights\",\n",
                "            \"light.kitchen_lights\",\n",
                "        ],\n",
                "        \"execution\": [\n",
                "            {\n",
                "                \"command\": \"action.devices.commands.OnOff\",\n",
                "                \"params\": {\"on\": True},\n",
                "            },\n",
                "            {\n",
                "                \"command\": \"action.devices.commands.BrightnessAbsolute\",\n",
                "                \"params\": {\"brightness\": 20},\n",
                "            },\n",
                "        ],\n",
                "        \"source\": \"cloud\",\n",
                "    }\n",
                "\n",
                "    service_events = sorted(\n",
                "        service_events, key=lambda ev: ev.data[\"service_data\"][\"entity_id\"]\n",
                "    )\n",
                "    assert len(service_events) == 4\n",
                "    assert service_events[0].data == {\n",
                "        \"domain\": \"light\",\n",
                "        \"service\": \"turn_on\",\n",
                "        \"service_data\": {\"entity_id\": \"light.ceiling_lights\"},\n",
                "    }\n",
                "    assert service_events[1].data == {\n",
                "        \"domain\": \"light\",\n",
                "        \"service\": \"turn_on\",\n",
                "        \"service_data\": {\"brightness_pct\": 20, \"entity_id\": \"light.ceiling_lights\"},\n",
                "    }\n",
                "    assert service_events[0].context == events[0].context\n",
                "    assert service_events[1].context == events[0].context\n",
                "    assert service_events[2].data == {\n",
                "        \"domain\": \"light\",\n",
                "        \"service\": \"turn_on\",\n",
                "        \"service_data\": {\"entity_id\": \"light.kitchen_lights\"},\n",
                "    }\n",
                "    assert service_events[3].data == {\n",
                "        \"domain\": \"light\",\n",
                "        \"service\": \"turn_on\",\n",
                "        \"service_data\": {\"brightness_pct\": 20, \"entity_id\": \"light.kitchen_lights\"},\n",
                "    }\n",
                "    assert service_events[2].context == events[0].context\n",
                "    assert service_events[3].context == events[0].context\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\"report_state,on,brightness,value\", [(False, False, ANY, ANY)])\n",
                "async def test_execute_times_out(hass, report_state, on, brightness, value):\n",
                "    \"\"\"Test an execute command which times out.\"\"\"\n",
                "    orig_execute_limit = sh.EXECUTE_LIMIT\n",
                "    sh.EXECUTE_LIMIT = 0.02  # Decrease timeout to 20ms\n",
                "    await async_setup_component(hass, \"light\", {\"light\": {\"platform\": \"demo\"}})\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    await hass.services.async_call(\n",
                "        \"light\", \"turn_off\", {\"entity_id\": \"light.ceiling_lights\"}, blocking=True\n",
                "    )\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    events = async_capture_events(hass, EVENT_COMMAND_RECEIVED)\n",
                "    service_events = async_capture_events(hass, EVENT_CALL_SERVICE)\n",
                "\n",
                "    platforms = entity_platform.async_get_platforms(hass, \"demo\")\n",
                "    assert platforms[0].domain == \"light\"\n",
                "    assert platforms[0].entities[\"light.ceiling_lights\"]\n",
                "\n",
                "    turn_on_wait = asyncio.Event()\n",
                "\n",
                "    async def slow_turn_on(*args, **kwargs):\n",
                "        # Make DemoLigt.async_turn_on hang waiting for the turn_on_wait event\n",
                "        await turn_on_wait.wait(),\n",
                "\n",
                "    with patch.object(\n",
                "        hass.services, \"async_call\", wraps=hass.services.async_call\n",
                "    ) as call_service_mock, patch.object(\n",
                "        DemoLight, \"async_turn_on\", wraps=slow_turn_on\n",
                "    ):\n",
                "        result = await sh.async_handle_message(\n",
                "            hass,\n",
                "            MockConfig(should_report_state=report_state),\n",
                "            None,\n",
                "            {\n",
                "                \"requestId\": REQ_ID,\n",
                "                \"inputs\": [\n",
                "                    {\n",
                "                        \"intent\": \"action.devices.EXECUTE\",\n",
                "                        \"payload\": {\n",
                "                            \"commands\": [\n",
                "                                {\n",
                "                                    \"devices\": [\n",
                "                                        {\"id\": \"light.non_existing\"},\n",
                "                                        {\"id\": \"light.ceiling_lights\"},\n",
                "                                        {\"id\": \"light.kitchen_lights\"},\n",
                "                                    ],\n",
                "                                    \"execution\": [\n",
                "                                        {\n",
                "                                            \"command\": \"action.devices.commands.OnOff\",\n",
                "                                            \"params\": {\"on\": True},\n",
                "                                        },\n",
                "                                        {\n",
                "                                            \"command\": \"action.devices.commands.BrightnessAbsolute\",\n",
                "                                            \"params\": {\"brightness\": 20},\n",
                "                                        },\n",
                "                                    ],\n",
                "                                }\n",
                "                            ]\n",
                "                        },\n",
                "                    }\n",
                "                ],\n",
                "            },\n",
                "            const.SOURCE_CLOUD,\n",
                "        )\n",
                "        # Only the two first calls are executed\n",
                "        assert call_service_mock.call_count == 2\n",
                "        expected_calls = [\n",
                "            call(\n",
                "                \"light\",\n",
                "                \"turn_on\",\n",
                "                {\"entity_id\": \"light.ceiling_lights\"},\n",
                "                blocking=not report_state,\n",
                "                context=ANY,\n",
                "            ),\n",
                "            call(\n",
                "                \"light\",\n",
                "                \"turn_on\",\n",
                "                {\"entity_id\": \"light.kitchen_lights\"},\n",
                "                blocking=not report_state,\n",
                "                context=ANY,\n",
                "            ),\n",
                "        ]\n",
                "        call_service_mock.assert_has_awaits(expected_calls, any_order=True)\n",
                "\n",
                "        turn_on_wait.set()\n",
                "        await hass.async_block_till_done()\n",
                "        # The remaining two calls should now have executed\n",
                "        assert call_service_mock.call_count == 4\n",
                "        expected_calls.extend(\n",
                "            [\n",
                "                call(\n",
                "                    \"light\",\n",
                "                    \"turn_on\",\n",
                "                    {\"entity_id\": \"light.ceiling_lights\", \"brightness_pct\": 20},\n",
                "                    blocking=not report_state,\n",
                "                    context=ANY,\n",
                "                ),\n",
                "                call(\n",
                "                    \"light\",\n",
                "                    \"turn_on\",\n",
                "                    {\"entity_id\": \"light.kitchen_lights\", \"brightness_pct\": 20},\n",
                "                    blocking=not report_state,\n",
                "                    context=ANY,\n",
                "                ),\n",
                "            ]\n",
                "        )\n",
                "        call_service_mock.assert_has_awaits(expected_calls, any_order=True)\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"commands\": [\n",
                "                {\n",
                "                    \"ids\": [\"light.non_existing\"],\n",
                "                    \"status\": \"ERROR\",\n",
                "                    \"errorCode\": \"deviceOffline\",\n",
                "                },\n",
                "                {\n",
                "                    \"ids\": [\"light.ceiling_lights\"],\n",
                "                    \"status\": \"SUCCESS\",\n",
                "                    \"states\": {\n",
                "                        \"on\": on,\n",
                "                        \"online\": True,\n",
                "                    },\n",
                "                },\n",
                "                {\n",
                "                    \"ids\": [\"light.kitchen_lights\"],\n",
                "                    \"status\": \"SUCCESS\",\n",
                "                    \"states\": {\n",
                "                        \"on\": True,\n",
                "                        \"online\": True,\n",
                "                        \"brightness\": brightness,\n",
                "                        \"color\": {\n",
                "                            \"spectrumHsv\": {\n",
                "                                \"hue\": 345,\n",
                "                                \"saturation\": 0.75,\n",
                "                                \"value\": value,\n",
                "                            },\n",
                "                        },\n",
                "                    },\n",
                "                },\n",
                "            ]\n",
                "        },\n",
                "    }\n",
                "\n",
                "    assert len(events) == 1\n",
                "    assert events[0].event_type == EVENT_COMMAND_RECEIVED\n",
                "    assert events[0].data == {\n",
                "        \"request_id\": REQ_ID,\n",
                "        \"entity_id\": [\n",
                "            \"light.non_existing\",\n",
                "            \"light.ceiling_lights\",\n",
                "            \"light.kitchen_lights\",\n",
                "        ],\n",
                "        \"execution\": [\n",
                "            {\n",
                "                \"command\": \"action.devices.commands.OnOff\",\n",
                "                \"params\": {\"on\": True},\n",
                "            },\n",
                "            {\n",
                "                \"command\": \"action.devices.commands.BrightnessAbsolute\",\n",
                "                \"params\": {\"brightness\": 20},\n",
                "            },\n",
                "        ],\n",
                "        \"source\": \"cloud\",\n",
                "    }\n",
                "\n",
                "    service_events = sorted(\n",
                "        service_events, key=lambda ev: ev.data[\"service_data\"][\"entity_id\"]\n",
                "    )\n",
                "    assert len(service_events) == 4\n",
                "    assert service_events[0].data == {\n",
                "        \"domain\": \"light\",\n",
                "        \"service\": \"turn_on\",\n",
                "        \"service_data\": {\"entity_id\": \"light.ceiling_lights\"},\n",
                "    }\n",
                "    assert service_events[1].data == {\n",
                "        \"domain\": \"light\",\n",
                "        \"service\": \"turn_on\",\n",
                "        \"service_data\": {\"brightness_pct\": 20, \"entity_id\": \"light.ceiling_lights\"},\n",
                "    }\n",
                "    assert service_events[0].context == events[0].context\n",
                "    assert service_events[1].context == events[0].context\n",
                "    assert service_events[2].data == {\n",
                "        \"domain\": \"light\",\n",
                "        \"service\": \"turn_on\",\n",
                "        \"service_data\": {\"entity_id\": \"light.kitchen_lights\"},\n",
                "    }\n",
                "    assert service_events[3].data == {\n",
                "        \"domain\": \"light\",\n",
                "        \"service\": \"turn_on\",\n",
                "        \"service_data\": {\"brightness_pct\": 20, \"entity_id\": \"light.kitchen_lights\"},\n",
                "    }\n",
                "    assert service_events[2].context == events[0].context\n",
                "    assert service_events[3].context == events[0].context\n",
                "\n",
                "    sh.EXECUTE_LIMIT = orig_execute_limit\n",
                "\n",
                "\n",
                "async def test_raising_error_trait(hass):\n",
                "    \"\"\"Test raising an error while executing a trait command.\"\"\"\n",
                "    hass.states.async_set(\n",
                "        \"climate.bla\",\n",
                "        HVACMode.HEAT,\n",
                "        {ATTR_MIN_TEMP: 15, ATTR_MAX_TEMP: 30, ATTR_UNIT_OF_MEASUREMENT: TEMP_CELSIUS},\n",
                "    )\n",
                "\n",
                "    events = async_capture_events(hass, EVENT_COMMAND_RECEIVED)\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        \"test-agent\",\n",
                "        {\n",
                "            \"requestId\": REQ_ID,\n",
                "            \"inputs\": [\n",
                "                {\n",
                "                    \"intent\": \"action.devices.EXECUTE\",\n",
                "                    \"payload\": {\n",
                "                        \"commands\": [\n",
                "                            {\n",
                "                                \"devices\": [{\"id\": \"climate.bla\"}],\n",
                "                                \"execution\": [\n",
                "                                    {\n",
                "                                        \"command\": \"action.devices.commands.\"\n",
                "                                        \"ThermostatTemperatureSetpoint\",\n",
                "                                        \"params\": {\"thermostatTemperatureSetpoint\": 10},\n",
                "                                    }\n",
                "                                ],\n",
                "                            }\n",
                "                        ]\n",
                "                    },\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"commands\": [\n",
                "                {\n",
                "                    \"ids\": [\"climate.bla\"],\n",
                "                    \"status\": \"ERROR\",\n",
                "                    \"errorCode\": \"valueOutOfRange\",\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "    }\n",
                "\n",
                "    assert len(events) == 1\n",
                "    assert events[0].event_type == EVENT_COMMAND_RECEIVED\n",
                "    assert events[0].data == {\n",
                "        \"request_id\": REQ_ID,\n",
                "        \"entity_id\": [\"climate.bla\"],\n",
                "        \"execution\": [\n",
                "            {\n",
                "                \"command\": \"action.devices.commands.ThermostatTemperatureSetpoint\",\n",
                "                \"params\": {\"thermostatTemperatureSetpoint\": 10},\n",
                "            }\n",
                "        ],\n",
                "        \"source\": \"cloud\",\n",
                "    }\n",
                "\n",
                "\n",
                "async def test_serialize_input_boolean(hass):\n",
                "    \"\"\"Test serializing an input boolean entity.\"\"\"\n",
                "    state = State(\"input_boolean.bla\", \"on\")\n",
                "    # pylint: disable=protected-access\n",
                "    entity = sh.GoogleEntity(hass, BASIC_CONFIG, state)\n",
                "    result = entity.sync_serialize(None, \"mock-uuid\")\n",
                "    assert result == {\n",
                "        \"id\": \"input_boolean.bla\",\n",
                "        \"attributes\": {},\n",
                "        \"name\": {\"name\": \"bla\"},\n",
                "        \"traits\": [\"action.devices.traits.OnOff\"],\n",
                "        \"type\": \"action.devices.types.SWITCH\",\n",
                "        \"willReportState\": False,\n",
                "    }\n",
                "\n",
                "\n",
                "async def test_unavailable_state_does_sync(hass):\n",
                "    \"\"\"Test that an unavailable entity does sync over.\"\"\"\n",
                "    light = DemoLight(\n",
                "        None,\n",
                "        \"Demo Light\",\n",
                "        state=False,\n",
                "        hs_color=(180, 75),\n",
                "        effect_list=LIGHT_EFFECT_LIST,\n",
                "        effect=LIGHT_EFFECT_LIST[0],\n",
                "    )\n",
                "    light.hass = hass\n",
                "    light.entity_id = \"light.demo_light\"\n",
                "    light._available = False  # pylint: disable=protected-access\n",
                "    await light.async_update_ha_state()\n",
                "\n",
                "    events = async_capture_events(hass, EVENT_SYNC_RECEIVED)\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        \"test-agent\",\n",
                "        {\"requestId\": REQ_ID, \"inputs\": [{\"intent\": \"action.devices.SYNC\"}]},\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"agentUserId\": \"test-agent\",\n",
                "            \"devices\": [\n",
                "                {\n",
                "                    \"id\": \"light.demo_light\",\n",
                "                    \"name\": {\"name\": \"Demo Light\"},\n",
                "                    \"traits\": [\n",
                "                        trait.TRAIT_BRIGHTNESS,\n",
                "                        trait.TRAIT_ONOFF,\n",
                "                        trait.TRAIT_COLOR_SETTING,\n",
                "                        trait.TRAIT_MODES,\n",
                "                    ],\n",
                "                    \"type\": const.TYPE_LIGHT,\n",
                "                    \"willReportState\": False,\n",
                "                    \"attributes\": {\n",
                "                        \"availableModes\": [\n",
                "                            {\n",
                "                                \"name\": \"effect\",\n",
                "                                \"name_values\": [\n",
                "                                    {\"lang\": \"en\", \"name_synonym\": [\"effect\"]}\n",
                "                                ],\n",
                "                                \"ordered\": False,\n",
                "                                \"settings\": [\n",
                "                                    {\n",
                "                                        \"setting_name\": \"rainbow\",\n",
                "                                        \"setting_values\": [\n",
                "                                            {\n",
                "                                                \"lang\": \"en\",\n",
                "                                                \"setting_synonym\": [\"rainbow\"],\n",
                "                                            }\n",
                "                                        ],\n",
                "                                    },\n",
                "                                    {\n",
                "                                        \"setting_name\": \"none\",\n",
                "                                        \"setting_values\": [\n",
                "                                            {\"lang\": \"en\", \"setting_synonym\": [\"none\"]}\n",
                "                                        ],\n",
                "                                    },\n",
                "                                ],\n",
                "                            }\n",
                "                        ],\n",
                "                        \"colorModel\": \"hsv\",\n",
                "                        \"colorTemperatureRange\": {\n",
                "                            \"temperatureMinK\": 2000,\n",
                "                            \"temperatureMaxK\": 6535,\n",
                "                        },\n",
                "                    },\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "    }\n",
                "    await hass.async_block_till_done()\n",
                "\n",
                "    assert len(events) == 1\n",
                "    assert events[0].event_type == EVENT_SYNC_RECEIVED\n",
                "    assert events[0].data == {\"request_id\": REQ_ID, \"source\": \"cloud\"}\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"device_class,google_type\",\n",
                "    [\n",
                "        (\"non_existing_class\", \"action.devices.types.SWITCH\"),\n",
                "        (\"switch\", \"action.devices.types.SWITCH\"),\n",
                "        (\"outlet\", \"action.devices.types.OUTLET\"),\n",
                "    ],\n",
                ")\n",
                "async def test_device_class_switch(hass, device_class, google_type):\n",
                "    \"\"\"Test that a cover entity syncs to the correct device type.\"\"\"\n",
                "    sensor = DemoSwitch(\n",
                "        None,\n",
                "        \"Demo Sensor\",\n",
                "        state=False,\n",
                "        icon=\"mdi:switch\",\n",
                "        assumed=False,\n",
                "        device_class=device_class,\n",
                "    )\n",
                "    sensor.hass = hass\n",
                "    sensor.entity_id = \"switch.demo_sensor\"\n",
                "    await sensor.async_update_ha_state()\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        \"test-agent\",\n",
                "        {\"requestId\": REQ_ID, \"inputs\": [{\"intent\": \"action.devices.SYNC\"}]},\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"agentUserId\": \"test-agent\",\n",
                "            \"devices\": [\n",
                "                {\n",
                "                    \"attributes\": {},\n",
                "                    \"id\": \"switch.demo_sensor\",\n",
                "                    \"name\": {\"name\": \"Demo Sensor\"},\n",
                "                    \"traits\": [\"action.devices.traits.OnOff\"],\n",
                "                    \"type\": google_type,\n",
                "                    \"willReportState\": False,\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "    }\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"device_class,google_type\",\n",
                "    [\n",
                "        (\"door\", \"action.devices.types.DOOR\"),\n",
                "        (\"garage_door\", \"action.devices.types.GARAGE\"),\n",
                "        (\"lock\", \"action.devices.types.SENSOR\"),\n",
                "        (\"opening\", \"action.devices.types.SENSOR\"),\n",
                "        (\"window\", \"action.devices.types.WINDOW\"),\n",
                "    ],\n",
                ")\n",
                "async def test_device_class_binary_sensor(hass, device_class, google_type):\n",
                "    \"\"\"Test that a binary entity syncs to the correct device type.\"\"\"\n",
                "    sensor = DemoBinarySensor(\n",
                "        None, \"Demo Sensor\", state=False, device_class=device_class\n",
                "    )\n",
                "    sensor.hass = hass\n",
                "    sensor.entity_id = \"binary_sensor.demo_sensor\"\n",
                "    await sensor.async_update_ha_state()\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        \"test-agent\",\n",
                "        {\"requestId\": REQ_ID, \"inputs\": [{\"intent\": \"action.devices.SYNC\"}]},\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"agentUserId\": \"test-agent\",\n",
                "            \"devices\": [\n",
                "                {\n",
                "                    \"attributes\": {\n",
                "                        \"queryOnlyOpenClose\": True,\n",
                "                        \"discreteOnlyOpenClose\": True,\n",
                "                    },\n",
                "                    \"id\": \"binary_sensor.demo_sensor\",\n",
                "                    \"name\": {\"name\": \"Demo Sensor\"},\n",
                "                    \"traits\": [\"action.devices.traits.OpenClose\"],\n",
                "                    \"type\": google_type,\n",
                "                    \"willReportState\": False,\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "    }\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"device_class,google_type\",\n",
                "    [\n",
                "        (\"non_existing_class\", \"action.devices.types.BLINDS\"),\n",
                "        (\"door\", \"action.devices.types.DOOR\"),\n",
                "        (\"garage\", \"action.devices.types.GARAGE\"),\n",
                "        (\"gate\", \"action.devices.types.GARAGE\"),\n",
                "        (\"awning\", \"action.devices.types.AWNING\"),\n",
                "        (\"shutter\", \"action.devices.types.SHUTTER\"),\n",
                "        (\"curtain\", \"action.devices.types.CURTAIN\"),\n",
                "    ],\n",
                ")\n",
                "async def test_device_class_cover(hass, device_class, google_type):\n",
                "    \"\"\"Test that a cover entity syncs to the correct device type.\"\"\"\n",
                "    sensor = DemoCover(None, hass, \"Demo Sensor\", device_class=device_class)\n",
                "    sensor.hass = hass\n",
                "    sensor.entity_id = \"cover.demo_sensor\"\n",
                "    await sensor.async_update_ha_state()\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        \"test-agent\",\n",
                "        {\"requestId\": REQ_ID, \"inputs\": [{\"intent\": \"action.devices.SYNC\"}]},\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"agentUserId\": \"test-agent\",\n",
                "            \"devices\": [\n",
                "                {\n",
                "                    \"attributes\": {\"discreteOnlyOpenClose\": True},\n",
                "                    \"id\": \"cover.demo_sensor\",\n",
                "                    \"name\": {\"name\": \"Demo Sensor\"},\n",
                "                    \"traits\": [\n",
                "                        \"action.devices.traits.StartStop\",\n",
                "                        \"action.devices.traits.OpenClose\",\n",
                "                    ],\n",
                "                    \"type\": google_type,\n",
                "                    \"willReportState\": False,\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "    }\n",
                "\n",
                "\n",
                "@pytest.mark.parametrize(\n",
                "    \"device_class,google_type\",\n",
                "    [\n",
                "        (\"non_existing_class\", \"action.devices.types.SETTOP\"),\n",
                "        (\"tv\", \"action.devices.types.TV\"),\n",
                "        (\"speaker\", \"action.devices.types.SPEAKER\"),\n",
                "        (\"receiver\", \"action.devices.types.AUDIO_VIDEO_RECEIVER\"),\n",
                "    ],\n",
                ")\n",
                "async def test_device_media_player(hass, device_class, google_type):\n",
                "    \"\"\"Test that a binary entity syncs to the correct device type.\"\"\"\n",
                "    sensor = AbstractDemoPlayer(\"Demo\", device_class=device_class)\n",
                "    sensor.hass = hass\n",
                "    sensor.entity_id = \"media_player.demo\"\n",
                "    await sensor.async_update_ha_state()\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        \"test-agent\",\n",
                "        {\"requestId\": REQ_ID, \"inputs\": [{\"intent\": \"action.devices.SYNC\"}]},\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"agentUserId\": \"test-agent\",\n",
                "            \"devices\": [\n",
                "                {\n",
                "                    \"attributes\": {\n",
                "                        \"supportActivityState\": True,\n",
                "                        \"supportPlaybackState\": True,\n",
                "                    },\n",
                "                    \"id\": sensor.entity_id,\n",
                "                    \"name\": {\"name\": sensor.name},\n",
                "                    \"traits\": [\n",
                "                        \"action.devices.traits.OnOff\",\n",
                "                        \"action.devices.traits.MediaState\",\n",
                "                    ],\n",
                "                    \"type\": google_type,\n",
                "                    \"willReportState\": False,\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "    }\n",
                "\n",
                "\n",
                "async def test_query_disconnect(hass):\n",
                "    \"\"\"Test a disconnect message.\"\"\"\n",
                "    config = MockConfig(hass=hass)\n",
                "    config.async_enable_report_state()\n",
                "    assert config._unsub_report_state is not None\n",
                "    with patch.object(config, \"async_disconnect_agent_user\") as mock_disconnect:\n",
                "        result = await sh.async_handle_message(\n",
                "            hass,\n",
                "            config,\n",
                "            \"test-agent\",\n",
                "            {\"inputs\": [{\"intent\": \"action.devices.DISCONNECT\"}], \"requestId\": REQ_ID},\n",
                "            const.SOURCE_CLOUD,\n",
                "        )\n",
                "    assert result is None\n",
                "    assert len(mock_disconnect.mock_calls) == 1\n",
                "\n",
                "\n",
                "async def test_trait_execute_adding_query_data(hass):\n",
                "    \"\"\"Test a trait execute influencing query data.\"\"\"\n",
                "    await async_process_ha_core_config(\n",
                "        hass,\n",
                "        {\"external_url\": \"https://example.com\"},\n",
                "    )\n",
                "    hass.states.async_set(\n",
                "        \"camera.office\", \"idle\", {\"supported_features\": camera.SUPPORT_STREAM}\n",
                "    )\n",
                "\n",
                "    with patch(\n",
                "        \"homeassistant.components.camera.async_request_stream\",\n",
                "        return_value=\"/api/streams/bla\",\n",
                "    ):\n",
                "        result = await sh.async_handle_message(\n",
                "            hass,\n",
                "            BASIC_CONFIG,\n",
                "            None,\n",
                "            {\n",
                "                \"requestId\": REQ_ID,\n",
                "                \"inputs\": [\n",
                "                    {\n",
                "                        \"intent\": \"action.devices.EXECUTE\",\n",
                "                        \"payload\": {\n",
                "                            \"commands\": [\n",
                "                                {\n",
                "                                    \"devices\": [{\"id\": \"camera.office\"}],\n",
                "                                    \"execution\": [\n",
                "                                        {\n",
                "                                            \"command\": \"action.devices.commands.GetCameraStream\",\n",
                "                                            \"params\": {\n",
                "                                                \"StreamToChromecast\": True,\n",
                "                                                \"SupportedStreamProtocols\": [\n",
                "                                                    \"progressive_mp4\",\n",
                "                                                    \"hls\",\n",
                "                                                    \"dash\",\n",
                "                                                    \"smooth_stream\",\n",
                "                                                ],\n",
                "                                            },\n",
                "                                        }\n",
                "                                    ],\n",
                "                                }\n",
                "                            ]\n",
                "                        },\n",
                "                    }\n",
                "                ],\n",
                "            },\n",
                "            const.SOURCE_CLOUD,\n",
                "        )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"commands\": [\n",
                "                {\n",
                "                    \"ids\": [\"camera.office\"],\n",
                "                    \"status\": \"SUCCESS\",\n",
                "                    \"states\": {\n",
                "                        \"online\": True,\n",
                "                        \"cameraStreamAccessUrl\": \"https://example.com/api/streams/bla\",\n",
                "                        \"cameraStreamReceiverAppId\": \"B45F4572\",\n",
                "                    },\n",
                "                }\n",
                "            ]\n",
                "        },\n",
                "    }\n",
                "\n",
                "\n",
                "async def test_identify(hass):\n",
                "    \"\"\"Test identify message.\"\"\"\n",
                "    user_agent_id = \"mock-user-id\"\n",
                "    proxy_device_id = user_agent_id\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        user_agent_id,\n",
                "        {\n",
                "            \"requestId\": REQ_ID,\n",
                "            \"inputs\": [\n",
                "                {\n",
                "                    \"intent\": \"action.devices.IDENTIFY\",\n",
                "                    \"payload\": {\n",
                "                        \"device\": {\n",
                "                            \"mdnsScanData\": {\n",
                "                                \"additionals\": [\n",
                "                                    {\n",
                "                                        \"type\": \"TXT\",\n",
                "                                        \"class\": \"IN\",\n",
                "                                        \"name\": \"devhome._home-assistant._tcp.local\",\n",
                "                                        \"ttl\": 4500,\n",
                "                                        \"data\": [\n",
                "                                            \"version=0.101.0.dev0\",\n",
                "                                            \"base_url=http://192.168.1.101:8123\",\n",
                "                                            \"requires_api_password=true\",\n",
                "                                        ],\n",
                "                                    }\n",
                "                                ]\n",
                "                            }\n",
                "                        },\n",
                "                        \"structureData\": {},\n",
                "                    },\n",
                "                }\n",
                "            ],\n",
                "            \"devices\": [\n",
                "                {\n",
                "                    \"id\": \"light.ceiling_lights\",\n",
                "                    \"customData\": {\n",
                "                        \"httpPort\": 8123,\n",
                "                        \"httpSSL\": False,\n",
                "                        \"proxyDeviceId\": proxy_device_id,\n",
                "                        \"webhookId\": \"dde3b9800a905e886cc4d38e226a6e7e3f2a6993d2b9b9f63d13e42ee7de3219\",\n",
                "                    },\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"device\": {\n",
                "                \"id\": proxy_device_id,\n",
                "                \"isLocalOnly\": True,\n",
                "                \"isProxy\": True,\n",
                "                \"deviceInfo\": {\n",
                "                    \"hwVersion\": \"UNKNOWN_HW_VERSION\",\n",
                "                    \"manufacturer\": \"Home Assistant\",\n",
                "                    \"model\": \"Home Assistant\",\n",
                "                    \"swVersion\": __version__,\n",
                "                },\n",
                "            }\n",
                "        },\n",
                "    }\n",
                "\n",
                "\n",
                "async def test_reachable_devices(hass):\n",
                "    \"\"\"Test REACHABLE_DEVICES intent.\"\"\"\n",
                "    # Matching passed in device.\n",
                "    hass.states.async_set(\"light.ceiling_lights\", \"on\")\n",
                "\n",
                "    # Unsupported entity\n",
                "    hass.states.async_set(\"not_supported.entity\", \"something\")\n",
                "\n",
                "    # Excluded via config\n",
                "    hass.states.async_set(\"light.not_expose\", \"on\")\n",
                "\n",
                "    # Not passed in as google_id\n",
                "    hass.states.async_set(\"light.not_mentioned\", \"on\")\n",
                "\n",
                "    # Has 2FA\n",
                "    hass.states.async_set(\"lock.has_2fa\", \"on\")\n",
                "\n",
                "    config = MockConfig(\n",
                "        should_expose=lambda state: state.entity_id != \"light.not_expose\",\n",
                "    )\n",
                "\n",
                "    user_agent_id = \"mock-user-id\"\n",
                "    proxy_device_id = user_agent_id\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        config,\n",
                "        user_agent_id,\n",
                "        {\n",
                "            \"requestId\": REQ_ID,\n",
                "            \"inputs\": [\n",
                "                {\n",
                "                    \"intent\": \"action.devices.REACHABLE_DEVICES\",\n",
                "                    \"payload\": {\n",
                "                        \"device\": {\n",
                "                            \"proxyDevice\": {\n",
                "                                \"id\": proxy_device_id,\n",
                "                                \"customData\": \"{}\",\n",
                "                                \"proxyData\": \"{}\",\n",
                "                            }\n",
                "                        },\n",
                "                        \"structureData\": {},\n",
                "                    },\n",
                "                }\n",
                "            ],\n",
                "            \"devices\": [\n",
                "                {\n",
                "                    \"id\": \"light.ceiling_lights\",\n",
                "                    \"customData\": {\n",
                "                        \"httpPort\": 8123,\n",
                "                        \"httpSSL\": False,\n",
                "                        \"proxyDeviceId\": proxy_device_id,\n",
                "                        \"webhookId\": \"dde3b9800a905e886cc4d38e226a6e7e3f2a6993d2b9b9f63d13e42ee7de3219\",\n",
                "                    },\n",
                "                },\n",
                "                {\n",
                "                    \"id\": \"light.not_expose\",\n",
                "                    \"customData\": {\n",
                "                        \"httpPort\": 8123,\n",
                "                        \"httpSSL\": False,\n",
                "                        \"proxyDeviceId\": proxy_device_id,\n",
                "                        \"webhookId\": \"dde3b9800a905e886cc4d38e226a6e7e3f2a6993d2b9b9f63d13e42ee7de3219\",\n",
                "                    },\n",
                "                },\n",
                "                {\n",
                "                    \"id\": \"lock.has_2fa\",\n",
                "                    \"customData\": {\n",
                "                        \"httpPort\": 8123,\n",
                "                        \"httpSSL\": False,\n",
                "                        \"proxyDeviceId\": proxy_device_id,\n",
                "                        \"webhookId\": \"dde3b9800a905e886cc4d38e226a6e7e3f2a6993d2b9b9f63d13e42ee7de3219\",\n",
                "                    },\n",
                "                },\n",
                "                {\"id\": proxy_device_id, \"customData\": {}},\n",
                "            ],\n",
                "        },\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\"devices\": [{\"verificationId\": \"light.ceiling_lights\"}]},\n",
                "    }\n",
                "\n",
                "\n",
                "async def test_sync_message_recovery(hass, caplog):\n",
                "    \"\"\"Test a sync message recovers from bad entities.\"\"\"\n",
                "    light = DemoLight(\n",
                "        None,\n",
                "        \"Demo Light\",\n",
                "        state=False,\n",
                "        hs_color=(180, 75),\n",
                "    )\n",
                "    light.hass = hass\n",
                "    light.entity_id = \"light.demo_light\"\n",
                "    await light.async_update_ha_state()\n",
                "\n",
                "    hass.states.async_set(\n",
                "        \"light.bad_light\",\n",
                "        \"on\",\n",
                "        {\n",
                "            \"min_mireds\": \"badvalue\",\n",
                "            \"supported_color_modes\": [\"color_temp\"],\n",
                "        },\n",
                "    )\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        \"test-agent\",\n",
                "        {\"requestId\": REQ_ID, \"inputs\": [{\"intent\": \"action.devices.SYNC\"}]},\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"agentUserId\": \"test-agent\",\n",
                "            \"devices\": [\n",
                "                {\n",
                "                    \"id\": \"light.demo_light\",\n",
                "                    \"name\": {\"name\": \"Demo Light\"},\n",
                "                    \"attributes\": {\n",
                "                        \"colorModel\": \"hsv\",\n",
                "                        \"colorTemperatureRange\": {\n",
                "                            \"temperatureMaxK\": 6535,\n",
                "                            \"temperatureMinK\": 2000,\n",
                "                        },\n",
                "                    },\n",
                "                    \"traits\": [\n",
                "                        \"action.devices.traits.Brightness\",\n",
                "                        \"action.devices.traits.OnOff\",\n",
                "                        \"action.devices.traits.ColorSetting\",\n",
                "                    ],\n",
                "                    \"willReportState\": False,\n",
                "                    \"type\": \"action.devices.types.LIGHT\",\n",
                "                },\n",
                "            ],\n",
                "        },\n",
                "    }\n",
                "\n",
                "    assert \"Error serializing light.bad_light\" in caplog.text\n",
                "\n",
                "\n",
                "async def test_query_recover(hass, caplog):\n",
                "    \"\"\"Test that we recover if an entity raises during query.\"\"\"\n",
                "\n",
                "    hass.states.async_set(\n",
                "        \"light.good\",\n",
                "        \"on\",\n",
                "        {\n",
                "            \"supported_color_modes\": [\"brightness\"],\n",
                "            \"brightness\": 50,\n",
                "        },\n",
                "    )\n",
                "    hass.states.async_set(\n",
                "        \"light.bad\",\n",
                "        \"on\",\n",
                "        {\n",
                "            \"supported_color_modes\": [\"brightness\"],\n",
                "            \"brightness\": \"shoe\",\n",
                "        },\n",
                "    )\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        \"test-agent\",\n",
                "        {\n",
                "            \"requestId\": REQ_ID,\n",
                "            \"inputs\": [\n",
                "                {\n",
                "                    \"intent\": \"action.devices.QUERY\",\n",
                "                    \"payload\": {\n",
                "                        \"devices\": [\n",
                "                            {\"id\": \"light.good\"},\n",
                "                            {\"id\": \"light.bad\"},\n",
                "                        ]\n",
                "                    },\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "        const.SOURCE_CLOUD,\n",
                "    )\n",
                "\n",
                "    assert (\n",
                "        f\"Unexpected error serializing query for {hass.states.get('light.bad')}\"\n",
                "        in caplog.text\n",
                "    )\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {\n",
                "            \"devices\": {\n",
                "                \"light.bad\": {\"online\": False},\n",
                "                \"light.good\": {\"on\": True, \"online\": True, \"brightness\": 20},\n",
                "            }\n",
                "        },\n",
                "    }\n",
                "\n",
                "\n",
                "async def test_proxy_selected(hass, caplog):\n",
                "    \"\"\"Test that we handle proxy selected.\"\"\"\n",
                "\n",
                "    result = await sh.async_handle_message(\n",
                "        hass,\n",
                "        BASIC_CONFIG,\n",
                "        \"test-agent\",\n",
                "        {\n",
                "            \"requestId\": REQ_ID,\n",
                "            \"inputs\": [\n",
                "                {\n",
                "                    \"intent\": \"action.devices.PROXY_SELECTED\",\n",
                "                    \"payload\": {\n",
                "                        \"device\": {\n",
                "                            \"id\": \"abcdefg\",\n",
                "                            \"customData\": {},\n",
                "                        },\n",
                "                        \"structureData\": {},\n",
                "                    },\n",
                "                }\n",
                "            ],\n",
                "        },\n",
                "        const.SOURCE_LOCAL,\n",
                "    )\n",
                "\n",
                "    assert result == {\n",
                "        \"requestId\": REQ_ID,\n",
                "        \"payload\": {},\n",
                "    }"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "update return content and declared return type"
        },
        {
            "edit_hunk_pair": [
                0,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "update declared return type and update usage"
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "update return content and update usage"
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "create and usage of `config_aliases`"
        },
        {
            "edit_hunk_pair": [
                4,
                8
            ],
            "edit_order": "bi-directional",
            "reason": "import-use"
        },
        {
            "edit_hunk_pair": [
                5,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "define-implement"
        },
        {
            "edit_hunk_pair": [
                6,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "define-use of newly created entity"
        },
        {
            "edit_hunk_pair": [
                6,
                8
            ],
            "edit_order": "bi-directional",
            "reason": "define-use of newly created aliases"
        }
    ]
}