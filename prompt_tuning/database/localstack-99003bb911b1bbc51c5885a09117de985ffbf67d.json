{
    "language": "python",
    "commit_url": "https://github.com/localstack/localstack/commit/99003bb911b1bbc51c5885a09117de985ffbf67d",
    "commit_message": "fix default value for S3 LocationConstraint in CF (#2600)",
    "commit_snapshots": {
        "localstack/config.py": [
            [
                "import re\n",
                "import os\n",
                "import socket\n",
                "import logging\n",
                "import platform\n",
                "import tempfile\n",
                "import subprocess\n",
                "from os.path import expanduser\n",
                "import six\n",
                "from boto3 import Session\n",
                "from localstack.constants import (\n",
                "    DEFAULT_SERVICE_PORTS, LOCALHOST, DEFAULT_PORT_WEB_UI, TRUE_STRINGS, FALSE_STRINGS,\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    DEFAULT_LAMBDA_CONTAINER_REGISTRY, DEFAULT_PORT_EDGE)\n"
                ],
                "after": [
                    "    DEFAULT_LAMBDA_CONTAINER_REGISTRY, DEFAULT_PORT_EDGE, AWS_REGION_US_EAST_1)\n"
                ],
                "parent_version_range": {
                    "start": 12,
                    "end": 13
                },
                "child_version_range": {
                    "start": 12,
                    "end": 13
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 0,
                "hunk_diff": "File: localstack/config.py\nCode:\n  ...\n 9  9    from boto3 import Session\n10 10    from localstack.constants import (\n11 11        DEFAULT_SERVICE_PORTS, LOCALHOST, DEFAULT_PORT_WEB_UI, TRUE_STRINGS, FALSE_STRINGS,\n12     -     DEFAULT_LAMBDA_CONTAINER_REGISTRY, DEFAULT_PORT_EDGE)\n   12  +     DEFAULT_LAMBDA_CONTAINER_REGISTRY, DEFAULT_PORT_EDGE, AWS_REGION_US_EAST_1)\n13 13    \n14 14    \n15 15    def is_env_true(env_var_name):\n       ...\n",
                "file_path": "localstack/config.py",
                "identifiers_before": [
                    "DEFAULT_LAMBDA_CONTAINER_REGISTRY",
                    "DEFAULT_PORT_EDGE"
                ],
                "identifiers_after": [
                    "AWS_REGION_US_EAST_1",
                    "DEFAULT_LAMBDA_CONTAINER_REGISTRY",
                    "DEFAULT_PORT_EDGE"
                ],
                "prefix": [
                    "from boto3 import Session\n",
                    "from localstack.constants import (\n",
                    "    DEFAULT_SERVICE_PORTS, LOCALHOST, DEFAULT_PORT_WEB_UI, TRUE_STRINGS, FALSE_STRINGS,\n"
                ],
                "suffix": [
                    "\n",
                    "\n",
                    "def is_env_true(env_var_name):\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 12,
                                    "column": 58
                                },
                                "end": {
                                    "line": 12,
                                    "column": 78
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/config.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 12,
                                    "column": 58
                                },
                                "end": {
                                    "line": 12,
                                    "column": 78
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/config.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "\n",
                "\n",
                "def is_env_true(env_var_name):\n",
                "    \"\"\" Whether the given environment variable has a truthy value. \"\"\"\n",
                "    return os.environ.get(env_var_name, '').lower().strip() in TRUE_STRINGS\n",
                "\n",
                "\n",
                "def is_env_not_false(env_var_name):\n",
                "    \"\"\" Whether the given environment variable is empty or has a truthy value. \"\"\"\n",
                "    return os.environ.get(env_var_name, '').lower().strip() not in FALSE_STRINGS\n",
                "\n",
                "\n",
                "# java options to Lambda\n",
                "LAMBDA_JAVA_OPTS = os.environ.get('LAMBDA_JAVA_OPTS', '').strip()\n",
                "\n",
                "# limit in which to kinesalite will start throwing exceptions\n",
                "KINESIS_SHARD_LIMIT = os.environ.get('KINESIS_SHARD_LIMIT', '').strip() or '100'\n",
                "\n",
                "# delay in kinesalite response when making changes to streams\n",
                "KINESIS_LATENCY = os.environ.get('KINESIS_LATENCY', '').strip() or '500'\n",
                "\n",
                "# default AWS region\n",
                "if 'DEFAULT_REGION' not in os.environ:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    os.environ['DEFAULT_REGION'] = 'us-east-1'\n"
                ],
                "after": [
                    "    os.environ['DEFAULT_REGION'] = AWS_REGION_US_EAST_1\n"
                ],
                "parent_version_range": {
                    "start": 36,
                    "end": 37
                },
                "child_version_range": {
                    "start": 36,
                    "end": 37
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if 'DEFAULT_REGION' not in os.environ:",
                        "start_line": 35,
                        "end_line": 36
                    }
                ],
                "structural_path": [],
                "idx": 1,
                "hunk_diff": "File: localstack/config.py\nCode:\n  ...\n33 33    \n34 34    # default AWS region\n35 35    if 'DEFAULT_REGION' not in os.environ:\n36     -     os.environ['DEFAULT_REGION'] = 'us-east-1'\n   36  +     os.environ['DEFAULT_REGION'] = AWS_REGION_US_EAST_1\n37 37    DEFAULT_REGION = os.environ['DEFAULT_REGION']\n38 38    \n39 39    # Whether or not to handle lambda event sources as synchronous invocations\n       ...\n",
                "file_path": "localstack/config.py",
                "identifiers_before": [
                    "environ",
                    "os"
                ],
                "identifiers_after": [
                    "AWS_REGION_US_EAST_1",
                    "environ",
                    "os"
                ],
                "prefix": [
                    "\n",
                    "# default AWS region\n",
                    "if 'DEFAULT_REGION' not in os.environ:\n"
                ],
                "suffix": [
                    "DEFAULT_REGION = os.environ['DEFAULT_REGION']\n",
                    "\n",
                    "# Whether or not to handle lambda event sources as synchronous invocations\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 36,
                                    "column": 35
                                },
                                "end": {
                                    "line": 36,
                                    "column": 55
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/config.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 36,
                                    "column": 35
                                },
                                "end": {
                                    "line": 36,
                                    "column": 55
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/config.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "DEFAULT_REGION = os.environ['DEFAULT_REGION']\n",
                "\n",
                "# Whether or not to handle lambda event sources as synchronous invocations\n",
                "SYNCHRONOUS_SNS_EVENTS = is_env_true('SYNCHRONOUS_SNS_EVENTS')\n",
                "SYNCHRONOUS_SQS_EVENTS = is_env_true('SYNCHRONOUS_SQS_EVENTS')\n",
                "SYNCHRONOUS_API_GATEWAY_EVENTS = is_env_not_false('SYNCHRONOUS_API_GATEWAY_EVENTS')\n",
                "SYNCHRONOUS_KINESIS_EVENTS = is_env_not_false('SYNCHRONOUS_KINESIS_EVENTS')\n",
                "SYNCHRONOUS_DYNAMODB_EVENTS = is_env_not_false('SYNCHRONOUS_DYNAMODB_EVENTS')\n",
                "\n",
                "# randomly inject faults to Kinesis\n",
                "KINESIS_ERROR_PROBABILITY = float(os.environ.get('KINESIS_ERROR_PROBABILITY', '').strip() or 0.0)\n",
                "\n",
                "# randomly inject faults to DynamoDB\n",
                "DYNAMODB_ERROR_PROBABILITY = float(os.environ.get('DYNAMODB_ERROR_PROBABILITY', '').strip() or 0.0)\n",
                "\n",
                "# expose services on a specific host internally\n",
                "HOSTNAME = os.environ.get('HOSTNAME', '').strip() or LOCALHOST\n",
                "\n",
                "# expose services on a specific host externally\n",
                "HOSTNAME_EXTERNAL = os.environ.get('HOSTNAME_EXTERNAL', '').strip() or LOCALHOST\n",
                "\n",
                "# expose SQS on a specific port externally\n",
                "SQS_PORT_EXTERNAL = int(os.environ.get('SQS_PORT_EXTERNAL') or 0)\n",
                "\n",
                "# name of the host under which the LocalStack services are available\n",
                "LOCALSTACK_HOSTNAME = os.environ.get('LOCALSTACK_HOSTNAME', '').strip() or HOSTNAME\n",
                "\n",
                "# whether to remotely copy the lambda or locally mount a volume\n",
                "LAMBDA_REMOTE_DOCKER = is_env_true('LAMBDA_REMOTE_DOCKER')\n",
                "\n",
                "# network that the docker lambda container will be joining\n",
                "LAMBDA_DOCKER_NETWORK = os.environ.get('LAMBDA_DOCKER_NETWORK', '').strip()\n",
                "\n",
                "# default container registry for lambda execution images\n",
                "LAMBDA_CONTAINER_REGISTRY = os.environ.get('LAMBDA_CONTAINER_REGISTRY', '').strip() or DEFAULT_LAMBDA_CONTAINER_REGISTRY\n",
                "\n",
                "# whether to remove containers after Lambdas finished executing\n",
                "LAMBDA_REMOVE_CONTAINERS = os.environ.get('LAMBDA_REMOVE_CONTAINERS', '').lower().strip() not in FALSE_STRINGS\n",
                "\n",
                "# directory for persisting data\n",
                "DATA_DIR = os.environ.get('DATA_DIR', '').strip()\n",
                "\n",
                "# folder for temporary files and data\n",
                "TMP_FOLDER = os.path.join(tempfile.gettempdir(), 'localstack')\n",
                "\n",
                "# create folders\n",
                "for folder in [DATA_DIR, TMP_FOLDER]:\n",
                "    if folder and not os.path.exists(folder):\n",
                "        try:\n",
                "            os.makedirs(folder)\n",
                "        except Exception:\n",
                "            # this can happen due to a race condition when starting\n",
                "            # multiple processes in parallel. Should be safe to ignore\n",
                "            pass\n",
                "\n",
                "# fix for Mac OS, to be able to mount /var/folders in Docker\n",
                "if TMP_FOLDER.startswith('/var/folders/') and os.path.exists('/private%s' % TMP_FOLDER):\n",
                "    TMP_FOLDER = '/private%s' % TMP_FOLDER\n",
                "\n",
                "# temporary folder of the host (required when running in Docker). Fall back to local tmp folder if not set\n",
                "HOST_TMP_FOLDER = os.environ.get('HOST_TMP_FOLDER', TMP_FOLDER)\n",
                "\n",
                "# whether to enable verbose debug logging\n",
                "DEBUG = os.environ.get('DEBUG', '').lower() in TRUE_STRINGS\n",
                "\n",
                "# whether to use SSL encryption for the services\n",
                "USE_SSL = is_env_true('USE_SSL')\n",
                "\n",
                "# default encoding used to convert strings to byte arrays (mainly for Python 3 compatibility)\n",
                "DEFAULT_ENCODING = 'utf-8'\n",
                "\n",
                "# path to local Docker UNIX domain socket\n",
                "DOCKER_SOCK = os.environ.get('DOCKER_SOCK', '').strip() or '/var/run/docker.sock'\n",
                "\n",
                "# additional flags to pass to \"docker run\" when starting the stack in Docker\n",
                "DOCKER_FLAGS = os.environ.get('DOCKER_FLAGS', '').strip()\n",
                "\n",
                "# command used to run Docker containers (e.g., set to \"sudo docker\" to run as sudo)\n",
                "DOCKER_CMD = os.environ.get('DOCKER_CMD', '').strip() or 'docker'\n",
                "\n",
                "# whether to start the web API\n",
                "START_WEB = os.environ.get('START_WEB', '').strip() not in FALSE_STRINGS\n",
                "\n",
                "# port number for the edge service, the main entry point for all API invocations\n",
                "EDGE_PORT = int(os.environ.get('EDGE_PORT') or 0) or DEFAULT_PORT_EDGE\n",
                "# fallback port for non-SSL HTTP edge service (in case HTTPS edge service cannot be used)\n",
                "EDGE_PORT_HTTP = int(os.environ.get('EDGE_PORT_HTTP') or 0)\n",
                "\n",
                "# port of Web UI\n",
                "PORT_WEB_UI = int(os.environ.get('PORT_WEB_UI', '').strip() or DEFAULT_PORT_WEB_UI)\n",
                "PORT_WEB_UI_SSL = PORT_WEB_UI + 1\n",
                "\n",
                "# IP of the docker bridge used to enable access between containers\n",
                "DOCKER_BRIDGE_IP = os.environ.get('DOCKER_BRIDGE_IP', '').strip()\n",
                "\n",
                "# CORS settings\n",
                "EXTRA_CORS_ALLOWED_HEADERS = os.environ.get('EXTRA_CORS_ALLOWED_HEADERS', '').strip()\n",
                "EXTRA_CORS_EXPOSE_HEADERS = os.environ.get('EXTRA_CORS_EXPOSE_HEADERS', '').strip()\n",
                "\n",
                "# whether to disable publishing events to the API\n",
                "DISABLE_EVENTS = is_env_true('DISABLE_EVENTS')\n",
                "\n",
                "# Whether to skip downloading additional infrastructure components (e.g., custom Elasticsearch versions)\n",
                "SKIP_INFRA_DOWNLOADS = os.environ.get('SKIP_INFRA_DOWNLOADS', '').strip()\n",
                "\n",
                "# Stepfunctions lambda endpoint override\n",
                "STEPFUNCTIONS_LAMBDA_ENDPOINT = os.environ.get('STEPFUNCTIONS_LAMBDA_ENDPOINT', '').strip()\n",
                "\n",
                "# path prefix for windows volume mounting\n",
                "WINDOWS_DOCKER_MOUNT_PREFIX = os.environ.get('WINDOWS_DOCKER_MOUNT_PREFIX', '/host_mnt')\n",
                "\n",
                "# whether to use a proxy server with HTTP/2 support. TODO: remove in the future\n",
                "USE_HTTP2_SERVER = os.environ.get('USE_HTTP2_SERVER', '').strip() not in FALSE_STRINGS\n",
                "\n",
                "\n",
                "def has_docker():\n",
                "    try:\n",
                "        with open(os.devnull, 'w') as devnull:\n",
                "            subprocess.check_output('docker ps', stderr=devnull, shell=True)\n",
                "        return True\n",
                "    except Exception:\n",
                "        return False\n",
                "\n",
                "\n",
                "def is_linux():\n",
                "    try:\n",
                "        out = subprocess.check_output('uname -a', shell=True)\n",
                "        out = out.decode('utf-8') if isinstance(out, six.binary_type) else out\n",
                "        return 'Linux' in out\n",
                "    except subprocess.CalledProcessError:\n",
                "        return False\n",
                "\n",
                "\n",
                "# whether to use Lambda functions in a Docker container\n",
                "LAMBDA_EXECUTOR = os.environ.get('LAMBDA_EXECUTOR', '').strip()\n",
                "if not LAMBDA_EXECUTOR:\n",
                "    LAMBDA_EXECUTOR = 'docker'\n",
                "    if not has_docker():\n",
                "        LAMBDA_EXECUTOR = 'local'\n",
                "\n",
                "# Fallback URL to use when a non-existing Lambda is invoked. If this matches\n",
                "# `dynamodb://<table_name>`, then the invocation is recorded in the corresponding\n",
                "# DynamoDB table. If this matches `http(s)://...`, then the Lambda invocation is\n",
                "# forwarded as a POST request to that URL.\n",
                "LAMBDA_FALLBACK_URL = os.environ.get('LAMBDA_FALLBACK_URL', '').strip()\n",
                "\n",
                "# list of environment variable names used for configuration.\n",
                "# Make sure to keep this in sync with the above!\n",
                "# Note: do *not* include DATA_DIR in this list, as it is treated separately\n",
                "CONFIG_ENV_VARS = ['SERVICES', 'HOSTNAME', 'HOSTNAME_EXTERNAL', 'LOCALSTACK_HOSTNAME', 'LAMBDA_FALLBACK_URL',\n",
                "                   'LAMBDA_EXECUTOR', 'LAMBDA_REMOTE_DOCKER', 'LAMBDA_DOCKER_NETWORK', 'LAMBDA_REMOVE_CONTAINERS',\n",
                "                   'USE_SSL', 'DEBUG', 'KINESIS_ERROR_PROBABILITY', 'DYNAMODB_ERROR_PROBABILITY', 'PORT_WEB_UI',\n",
                "                   'START_WEB', 'DOCKER_BRIDGE_IP', 'DEFAULT_REGION', 'LAMBDA_JAVA_OPTS', 'LOCALSTACK_API_KEY',\n",
                "                   'LAMBDA_CONTAINER_REGISTRY', 'TEST_AWS_ACCOUNT_ID', 'DISABLE_EVENTS', 'EDGE_PORT',\n",
                "                   'EDGE_PORT_HTTP', 'SKIP_INFRA_DOWNLOADS', 'STEPFUNCTIONS_LAMBDA_ENDPOINT',\n",
                "                   'WINDOWS_DOCKER_MOUNT_PREFIX', 'USE_HTTP2_SERVER',\n",
                "                   'SYNCHRONOUS_API_GATEWAY_EVENTS', 'SYNCHRONOUS_KINESIS_EVENTS',\n",
                "                   'SYNCHRONOUS_SNS_EVENTS', 'SYNCHRONOUS_SQS_EVENTS', 'SYNCHRONOUS_DYNAMODB_EVENTS']\n",
                "\n",
                "for key, value in six.iteritems(DEFAULT_SERVICE_PORTS):\n",
                "    clean_key = key.upper().replace('-', '_')\n",
                "    CONFIG_ENV_VARS += [clean_key + '_BACKEND', clean_key + '_PORT', clean_key + '_PORT_EXTERNAL']\n",
                "\n",
                "\n",
                "def ping(host):\n",
                "    \"\"\" Returns True if host responds to a ping request \"\"\"\n",
                "    is_windows = platform.system().lower() == 'windows'\n",
                "    ping_opts = '-n 1' if is_windows else '-c 1'\n",
                "    args = 'ping %s %s' % (ping_opts, host)\n",
                "    return subprocess.call(args, shell=not is_windows, stdout=subprocess.PIPE, stderr=subprocess.PIPE) == 0\n",
                "\n",
                "\n",
                "def in_docker():\n",
                "    \"\"\" Returns True if running in a docker container, else False \"\"\"\n",
                "    if not os.path.exists('/proc/1/cgroup'):\n",
                "        return False\n",
                "    with open('/proc/1/cgroup', 'rt') as ifh:\n",
                "        return 'docker' in ifh.read()\n",
                "\n",
                "\n",
                "is_in_docker = in_docker()\n",
                "is_in_linux = is_linux()\n",
                "\n",
                "# determine IP of Docker bridge\n",
                "if not DOCKER_BRIDGE_IP:\n",
                "    DOCKER_BRIDGE_IP = '172.17.0.1'\n",
                "    if is_in_docker:\n",
                "        candidates = (DOCKER_BRIDGE_IP, '172.18.0.1')\n",
                "        for ip in candidates:\n",
                "            if ping(ip):\n",
                "                DOCKER_BRIDGE_IP = ip\n",
                "                break\n",
                "\n",
                "# determine route to Docker host from container\n",
                "try:\n",
                "    DOCKER_HOST_FROM_CONTAINER = DOCKER_BRIDGE_IP\n",
                "    if not is_in_docker and not is_in_linux:\n",
                "        # If we're running outside docker, and would like the Lambda containers to be able\n",
                "        # to access services running on the local machine, set DOCKER_HOST_FROM_CONTAINER accordingly\n",
                "        if LOCALSTACK_HOSTNAME == HOSTNAME:\n",
                "            DOCKER_HOST_FROM_CONTAINER = 'host.docker.internal'\n",
                "    # update LOCALSTACK_HOSTNAME if host.docker.internal is available\n",
                "    if is_in_docker:\n",
                "        DOCKER_HOST_FROM_CONTAINER = socket.gethostbyname('host.docker.internal')\n",
                "        if LOCALSTACK_HOSTNAME == DOCKER_BRIDGE_IP:\n",
                "            LOCALSTACK_HOSTNAME = DOCKER_HOST_FROM_CONTAINER\n",
                "except socket.error:\n",
                "    pass\n",
                "\n",
                "# make sure we default to LAMBDA_REMOTE_DOCKER=true if running in Docker\n",
                "if is_in_docker and not os.environ.get('LAMBDA_REMOTE_DOCKER', '').strip():\n",
                "    LAMBDA_REMOTE_DOCKER = True\n",
                "\n",
                "# local config file path in home directory\n",
                "CONFIG_FILE_PATH = os.path.join(expanduser('~'), '.localstack')\n",
                "\n",
                "# set variables no_proxy, i.e., run internal service calls directly\n",
                "no_proxy = ','.join(set((LOCALSTACK_HOSTNAME, HOSTNAME, LOCALHOST, '127.0.0.1', '[::1]')))\n",
                "if os.environ.get('no_proxy'):\n",
                "    os.environ['no_proxy'] += ',' + no_proxy\n",
                "elif os.environ.get('NO_PROXY'):\n",
                "    os.environ['NO_PROXY'] += ',' + no_proxy\n",
                "else:\n",
                "    os.environ['no_proxy'] = no_proxy\n",
                "\n",
                "# additional CLI commands, can be set by plugins\n",
                "CLI_COMMANDS = {}\n",
                "\n",
                "# set of valid regions\n",
                "VALID_REGIONS = set(Session().get_available_regions('sns'))\n",
                "\n",
                "\n",
                "def parse_service_ports():\n",
                "    \"\"\" Parses the environment variable $SERVICES with a comma-separated list of services\n",
                "        and (optional) ports they should run on: 'service1:port1,service2,service3:port3' \"\"\"\n",
                "    service_ports = os.environ.get('SERVICES', '').strip()\n",
                "    if not service_ports:\n",
                "        return DEFAULT_SERVICE_PORTS\n",
                "    result = {}\n",
                "    for service_port in re.split(r'\\s*,\\s*', service_ports):\n",
                "        parts = re.split(r'[:=]', service_port)\n",
                "        service = parts[0]\n",
                "        key_upper = service.upper().replace('-', '_')\n",
                "        port_env_name = '%s_PORT' % key_upper\n",
                "        # (1) set default port number\n",
                "        port_number = DEFAULT_SERVICE_PORTS.get(service)\n",
                "        # (2) set port number from <SERVICE>_PORT environment, if present\n",
                "        if os.environ.get(port_env_name):\n",
                "            port_number = os.environ.get(port_env_name)\n",
                "        # (3) set port number from <service>:<port> portion in $SERVICES, if present\n",
                "        if len(parts) > 1:\n",
                "            port_number = int(parts[-1])\n",
                "        # (4) try to parse as int, fall back to 0 (invalid port)\n",
                "        try:\n",
                "            port_number = int(port_number)\n",
                "        except Exception:\n",
                "            port_number = 0\n",
                "        result[service] = port_number\n",
                "    return result\n",
                "\n",
                "\n",
                "def populate_configs(service_ports=None):\n",
                "    global SERVICE_PORTS, CONFIG_ENV_VARS\n",
                "\n",
                "    SERVICE_PORTS = service_ports or parse_service_ports()\n",
                "    globs = globals()\n",
                "\n",
                "    # define service ports and URLs as environment variables\n",
                "    for key, value in six.iteritems(DEFAULT_SERVICE_PORTS):\n",
                "        key_upper = key.upper().replace('-', '_')\n",
                "\n",
                "        # define PORT_* variables with actual service ports as per configuration\n",
                "        port_var_name = 'PORT_%s' % key_upper\n",
                "        port_number = service_port(key)\n",
                "        globs[port_var_name] = port_number\n",
                "        url = 'http%s://%s:%s' % ('s' if USE_SSL else '', LOCALSTACK_HOSTNAME, port_number)\n",
                "        # define TEST_*_URL variables with mock service endpoints\n",
                "        url_key = 'TEST_%s_URL' % key_upper\n",
                "        globs[url_key] = url\n",
                "        # expose HOST_*_URL variables as environment variables\n",
                "        os.environ[url_key] = url\n",
                "\n",
                "    # expose LOCALSTACK_HOSTNAME as env. variable\n",
                "    os.environ['LOCALSTACK_HOSTNAME'] = LOCALSTACK_HOSTNAME\n",
                "\n",
                "    # create variable aliases prefixed with LOCALSTACK_ (except LOCALSTACK_HOSTNAME)\n",
                "    CONFIG_ENV_VARS += ['LOCALSTACK_' + v for v in CONFIG_ENV_VARS if not v.startswith('LOCALSTACK_')]\n",
                "    CONFIG_ENV_VARS = list(set(CONFIG_ENV_VARS))\n",
                "\n",
                "\n",
                "def service_port(service_key):\n",
                "    return SERVICE_PORTS.get(service_key, 0)\n",
                "\n",
                "\n",
                "def external_service_url(service_key, host=None):\n",
                "    host = host or HOSTNAME_EXTERNAL\n",
                "    return 'http%s://%s:%s' % ('s' if USE_SSL else '', host, service_port(service_key))\n",
                "\n",
                "\n",
                "# initialize config values\n",
                "populate_configs()\n",
                "\n",
                "# set log levels\n",
                "if DEBUG:\n",
                "    logging.getLogger('').setLevel(logging.DEBUG)\n",
                "    logging.getLogger('localstack').setLevel(logging.DEBUG)\n",
                "\n",
                "# whether to bundle multiple APIs into a single process, where possible\n",
                "BUNDLE_API_PROCESSES = True\n",
                "\n",
                "# whether to use a CPU/memory profiler when running the integration tests\n",
                "USE_PROFILER = is_env_true('USE_PROFILER')"
            ]
        ],
        "localstack/constants.py": [
            [
                "import os\n",
                "import localstack_client.config\n",
                "\n",
                "# LocalStack version\n",
                "VERSION = '0.11.2'\n",
                "\n",
                "# constant to represent the \"local\" region, i.e., local machine\n",
                "REGION_LOCAL = 'local'\n",
                "\n",
                "# dev environment\n",
                "ENV_DEV = 'dev'\n",
                "\n",
                "# HTTP headers used to forward proxy request URLs\n",
                "HEADER_LOCALSTACK_EDGE_URL = 'x-localstack-edge'\n",
                "HEADER_LOCALSTACK_TARGET = 'x-localstack-target'\n",
                "\n",
                "# backend service ports, for services that are behind a proxy (counting down from 4566)\n",
                "DEFAULT_PORT_EDGE = 4566\n",
                "DEFAULT_PORT_WEB_UI = 8080\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "# host name for localhost\n"
                ],
                "parent_version_range": {
                    "start": 20,
                    "end": 20
                },
                "child_version_range": {
                    "start": 20,
                    "end": 21
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 2,
                "hunk_diff": "File: localstack/constants.py\nCode:\n  ...\n17 17    DEFAULT_PORT_EDGE = 4566\n18 18    DEFAULT_PORT_WEB_UI = 8080\n19 19    \n   20  + # host name for localhost\n20 21    LOCALHOST = 'localhost'\n21 22    \n22 23    # version of the Maven dependency with Java utility code\n       ...\n",
                "file_path": "localstack/constants.py",
                "identifiers_before": [],
                "identifiers_after": [],
                "prefix": [
                    "DEFAULT_PORT_EDGE = 4566\n",
                    "DEFAULT_PORT_WEB_UI = 8080\n",
                    "\n"
                ],
                "suffix": [
                    "LOCALHOST = 'localhost'\n",
                    "\n",
                    "# version of the Maven dependency with Java utility code\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "LOCALHOST = 'localhost'\n",
                "\n",
                "# version of the Maven dependency with Java utility code\n",
                "LOCALSTACK_MAVEN_VERSION = '0.2.1'\n",
                "\n",
                "# map of default service APIs and ports to be spun up (fetch map from localstack_client)\n",
                "DEFAULT_SERVICE_PORTS = localstack_client.config.get_service_ports()\n",
                "\n",
                "# host to bind to when starting the services\n",
                "BIND_HOST = '0.0.0.0'\n",
                "\n",
                "# AWS user account ID used for tests\n",
                "if 'TEST_AWS_ACCOUNT_ID' not in os.environ:\n",
                "    os.environ['TEST_AWS_ACCOUNT_ID'] = '000000000000'\n",
                "TEST_AWS_ACCOUNT_ID = os.environ['TEST_AWS_ACCOUNT_ID']\n",
                "\n",
                "# root code folder\n",
                "LOCALSTACK_ROOT_FOLDER = os.path.realpath(os.path.join(os.path.dirname(os.path.realpath(__file__)), '..'))\n",
                "\n",
                "# virtualenv folder\n",
                "LOCALSTACK_VENV_FOLDER = os.path.join(LOCALSTACK_ROOT_FOLDER, '.venv')\n",
                "if not os.path.isdir(LOCALSTACK_VENV_FOLDER):\n",
                "    # assuming this package lives here: <python>/lib/pythonX.X/site-packages/localstack/\n",
                "    LOCALSTACK_VENV_FOLDER = os.path.realpath(os.path.join(LOCALSTACK_ROOT_FOLDER, '..', '..', '..'))\n",
                "\n",
                "# API Gateway path to indicate a user request sent to the gateway\n",
                "PATH_USER_REQUEST = '_user_request_'\n",
                "\n",
                "# name of LocalStack Docker image\n",
                "DOCKER_IMAGE_NAME = 'localstack/localstack'\n",
                "DOCKER_IMAGE_NAME_LIGHT = 'localstack/localstack-light'\n",
                "\n",
                "# backdoor API path used to retrieve or update config variables\n",
                "CONFIG_UPDATE_PATH = '/?_config_'\n",
                "\n",
                "# environment variable name to tag local test runs\n",
                "ENV_INTERNAL_TEST_RUN = 'LOCALSTACK_INTERNAL_TEST_RUN'\n",
                "\n",
                "# content types\n",
                "APPLICATION_AMZ_JSON_1_0 = 'application/x-amz-json-1.0'\n",
                "APPLICATION_AMZ_JSON_1_1 = 'application/x-amz-json-1.1'\n",
                "APPLICATION_JSON = 'application/json'\n",
                "APPLICATION_XML = 'application/xml'\n",
                "APPLICATION_X_WWW_FORM_URLENCODED = 'application/x-www-form-urlencoded'\n",
                "\n",
                "# strings to indicate truthy/falsy values\n",
                "TRUE_STRINGS = ('1', 'true', 'True')\n",
                "FALSE_STRINGS = ('0', 'false', 'False')\n",
                "\n",
                "# Lambda defaults\n",
                "LAMBDA_TEST_ROLE = 'arn:aws:iam::%s:role/lambda-test-role' % TEST_AWS_ACCOUNT_ID\n",
                "\n",
                "# installation constants\n",
                "ELASTICSEARCH_URLS = {\n",
                "    '7.4.0': 'https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.4.0-linux-x86_64.tar.gz',\n",
                "    '7.1.0': 'https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.1.0-linux-x86_64.tar.gz',\n",
                "    '6.7.0': 'https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.7.0.zip'\n",
                "}\n",
                "ELASTICSEARCH_DEFAULT_VERSION = '7.1.0'\n",
                "# See https://docs.aws.amazon.com/ja_jp/elasticsearch-service/latest/developerguide/aes-supported-plugins.html\n",
                "ELASTICSEARCH_PLUGIN_LIST = ['analysis-icu', 'ingest-attachment', 'analysis-kuromoji',\n",
                " 'mapper-murmur3', 'mapper-size', 'analysis-phonetic', 'analysis-smartcn', 'analysis-stempel', 'analysis-ukrainian']\n",
                "# Default ES modules to exclude (save apprx 66MB in the final image)\n",
                "ELASTICSEARCH_DELETE_MODULES = ['ingest-geoip']\n",
                "ELASTICMQ_JAR_URL = 'https://s3-eu-west-1.amazonaws.com/softwaremill-public/elasticmq-server-0.15.7.jar'\n",
                "STS_JAR_URL = 'https://repo1.maven.org/maven2/com/amazonaws/aws-java-sdk-sts/1.11.14/aws-java-sdk-sts-1.11.14.jar'\n",
                "STEPFUNCTIONS_ZIP_URL = 'https://s3.amazonaws.com/stepfunctionslocal/StepFunctionsLocal.zip'\n",
                "KMS_URL_PATTERN = 'https://s3-eu-west-2.amazonaws.com/local-kms/localstack/v3/local-kms.<arch>.bin'\n",
                "\n",
                "# TODO: Temporarily using a fixed version of DDB in Alpine, as we're hitting a SIGSEGV JVM crash with latest\n",
                "DYNAMODB_JAR_URL_ALPINE = 'https://github.com/whummer/dynamodb-local/raw/master/etc/DynamoDBLocal.zip'\n",
                "DYNAMODB_JAR_URL = 'https://s3-us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.zip'\n",
                "\n",
                "# API endpoint for analytics events\n",
                "API_ENDPOINT = os.environ.get('API_ENDPOINT') or 'https://api.localstack.cloud/v1'\n",
                "\n",
                "# environment variable to indicates that this process is running the Web UI\n",
                "LOCALSTACK_WEB_PROCESS = 'LOCALSTACK_WEB_PROCESS'\n",
                "LOCALSTACK_INFRA_PROCESS = 'LOCALSTACK_INFRA_PROCESS'\n",
                "\n",
                "# Hardcoded AWS account ID used by moto\n",
                "MOTO_ACCOUNT_ID = TEST_AWS_ACCOUNT_ID\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "# default AWS region us-east-1\n",
                    "AWS_REGION_US_EAST_1 = 'us-east-1'\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 103,
                    "end": 103
                },
                "child_version_range": {
                    "start": 104,
                    "end": 107
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 3,
                "hunk_diff": "File: localstack/constants.py\nCode:\n  ...\n100 101    # Hardcoded AWS account ID used by moto\n101 102    MOTO_ACCOUNT_ID = TEST_AWS_ACCOUNT_ID\n102 103    \n    104  + # default AWS region us-east-1\n    105  + AWS_REGION_US_EAST_1 = 'us-east-1'\n    106  + \n103 107    # Default lambda registry\n104 108    DEFAULT_LAMBDA_CONTAINER_REGISTRY = 'lambci/lambda'\n         ...\n",
                "file_path": "localstack/constants.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "AWS_REGION_US_EAST_1"
                ],
                "prefix": [
                    "# Hardcoded AWS account ID used by moto\n",
                    "MOTO_ACCOUNT_ID = TEST_AWS_ACCOUNT_ID\n",
                    "\n"
                ],
                "suffix": [
                    "# Default lambda registry\n",
                    "DEFAULT_LAMBDA_CONTAINER_REGISTRY = 'lambci/lambda'"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 105,
                                    "column": 0
                                },
                                "end": {
                                    "line": 105,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/constants.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 105,
                                    "column": 0
                                },
                                "end": {
                                    "line": 105,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/constants.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 105,
                                    "column": 0
                                },
                                "end": {
                                    "line": 105,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/constants.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 105,
                                    "column": 0
                                },
                                "end": {
                                    "line": 105,
                                    "column": 20
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/constants.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "# Default lambda registry\n",
                "DEFAULT_LAMBDA_CONTAINER_REGISTRY = 'lambci/lambda'"
            ]
        ],
        "localstack/utils/cloudformation/template_deployer.py": [
            [
                "import re\n",
                "import os\n",
                "import json\n",
                "import yaml\n",
                "import logging\n",
                "import traceback\n",
                "import moto.cloudformation.utils\n",
                "from six import iteritems\n"
            ],
            {
                "type": "delete",
                "before": [
                    "from localstack.services.s3 import s3_listener\n",
                    "from localstack.services.awslambda.lambda_api import get_handler_file_from_name\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 8,
                    "end": 10
                },
                "child_version_range": {
                    "start": 8,
                    "end": 8
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 4,
                "hunk_diff": "File: localstack/utils/cloudformation/template_deployer.py\nCode:\n  ...\n 5  5    import traceback\n 6  6    import moto.cloudformation.utils\n 7  7    from six import iteritems\n 8     - from localstack.services.s3 import s3_listener\n 9     - from localstack.services.awslambda.lambda_api import get_handler_file_from_name\n10  8    from localstack.utils import common\n11  9    from localstack.utils.aws import aws_stack\n       ...\n",
                "file_path": "localstack/utils/cloudformation/template_deployer.py",
                "identifiers_before": [
                    "awslambda",
                    "get_handler_file_from_name",
                    "lambda_api",
                    "localstack",
                    "s3",
                    "s3_listener",
                    "services"
                ],
                "identifiers_after": [],
                "prefix": [
                    "import traceback\n",
                    "import moto.cloudformation.utils\n",
                    "from six import iteritems\n"
                ],
                "suffix": [
                    "from localstack.utils import common\n",
                    "from localstack.utils.aws import aws_stack\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "from localstack.utils import common\n",
                "from localstack.utils.aws import aws_stack\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "from localstack.constants import AWS_REGION_US_EAST_1\n",
                    "from localstack.services.s3 import s3_listener\n"
                ],
                "parent_version_range": {
                    "start": 12,
                    "end": 12
                },
                "child_version_range": {
                    "start": 10,
                    "end": 12
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 5,
                "hunk_diff": "File: localstack/utils/cloudformation/template_deployer.py\nCode:\n  ...\n10  8    from localstack.utils import common\n11  9    from localstack.utils.aws import aws_stack\n   10  + from localstack.constants import AWS_REGION_US_EAST_1\n   11  + from localstack.services.s3 import s3_listener\n12 12    from localstack.utils.testutil import create_zip_file\n       ...\n",
                "file_path": "localstack/utils/cloudformation/template_deployer.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "AWS_REGION_US_EAST_1",
                    "constants",
                    "localstack",
                    "s3",
                    "s3_listener",
                    "services"
                ],
                "prefix": [
                    "from localstack.utils import common\n",
                    "from localstack.utils.aws import aws_stack\n"
                ],
                "suffix": [
                    "from localstack.utils.testutil import create_zip_file\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 10,
                                    "column": 33
                                },
                                "end": {
                                    "line": 10,
                                    "column": 53
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/cloudformation/template_deployer.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 7,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 10,
                                    "column": 33
                                },
                                "end": {
                                    "line": 10,
                                    "column": 53
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/cloudformation/template_deployer.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "from localstack.utils.testutil import create_zip_file\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "from localstack.services.awslambda.lambda_api import get_handler_file_from_name\n"
                ],
                "parent_version_range": {
                    "start": 13,
                    "end": 13
                },
                "child_version_range": {
                    "start": 13,
                    "end": 14
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 6,
                "hunk_diff": "File: localstack/utils/cloudformation/template_deployer.py\nCode:\n  ...\n12 12    from localstack.utils.testutil import create_zip_file\n   13  + from localstack.services.awslambda.lambda_api import get_handler_file_from_name\n13 14    \n14 15    ACTION_CREATE = 'create'\n15 16    ACTION_DELETE = 'delete'\n       ...\n",
                "file_path": "localstack/utils/cloudformation/template_deployer.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "awslambda",
                    "get_handler_file_from_name",
                    "lambda_api",
                    "localstack",
                    "services"
                ],
                "prefix": [
                    "from localstack.utils.testutil import create_zip_file\n"
                ],
                "suffix": [
                    "\n",
                    "ACTION_CREATE = 'create'\n",
                    "ACTION_DELETE = 'delete'\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "ACTION_CREATE = 'create'\n",
                "ACTION_DELETE = 'delete'\n",
                "PLACEHOLDER_RESOURCE_NAME = '__resource_name__'\n",
                "\n",
                "LOG = logging.getLogger(__name__)\n",
                "\n",
                "# list of resource types that can be updated\n",
                "UPDATEABLE_RESOURCES = ['Lambda::Function', 'ApiGateway::Method']\n",
                "\n",
                "# list of static attribute references to be replaced in {'Fn::Sub': '...'} strings\n",
                "STATIC_REFS = ['AWS::Region', 'AWS::Partition', 'AWS::StackName']\n",
                "\n",
                "# create safe yaml loader that parses date strings as string, not date objects\n",
                "NoDatesSafeLoader = yaml.SafeLoader\n",
                "NoDatesSafeLoader.yaml_implicit_resolvers = {\n",
                "    k: [r for r in v if r[0] != 'tag:yaml.org,2002:timestamp'] for\n",
                "    k, v in NoDatesSafeLoader.yaml_implicit_resolvers.items()\n",
                "}\n",
                "\n",
                "\n",
                "def str_or_none(o):\n",
                "    return o if o is None else json.dumps(o) if isinstance(o, (dict, list)) else str(o)\n",
                "\n",
                "\n",
                "def params_select_attributes(*attrs):\n",
                "    def do_select(params, **kwargs):\n",
                "        result = {}\n",
                "        for attr in attrs:\n",
                "            if params.get(attr) is not None:\n",
                "                result[attr] = str_or_none(params.get(attr))\n",
                "        return result\n",
                "    return do_select\n",
                "\n",
                "\n",
                "def get_bucket_location_config(**kwargs):\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    return {'LocationConstraint': aws_stack.get_region()}\n"
                ],
                "after": [
                    "    region = aws_stack.get_region()\n",
                    "    if region == AWS_REGION_US_EAST_1:\n",
                    "        return None\n",
                    "    return {'LocationConstraint': region}\n"
                ],
                "parent_version_range": {
                    "start": 49,
                    "end": 50
                },
                "child_version_range": {
                    "start": 50,
                    "end": 54
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_bucket_location_config",
                        "signature": "def get_bucket_location_config(**kwargs):",
                        "at_line": 48
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: localstack/utils/cloudformation/template_deployer.py\nCode:\n46 47    \n47 48    \n48 49    def get_bucket_location_config(**kwargs):\n49     -     return {'LocationConstraint': aws_stack.get_region()}\n   50  +     region = aws_stack.get_region()\n   51  +     if region == AWS_REGION_US_EAST_1:\n   52  +         return None\n   53  +     return {'LocationConstraint': region}\n50 54    \n51 55    \n52 56    def lambda_get_params():\n       ...\n",
                "file_path": "localstack/utils/cloudformation/template_deployer.py",
                "identifiers_before": [
                    "aws_stack",
                    "get_region"
                ],
                "identifiers_after": [
                    "AWS_REGION_US_EAST_1",
                    "aws_stack",
                    "get_region",
                    "region"
                ],
                "prefix": [
                    "\n",
                    "\n",
                    "def get_bucket_location_config(**kwargs):\n"
                ],
                "suffix": [
                    "\n",
                    "\n",
                    "def lambda_get_params():\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 51,
                                    "column": 17
                                },
                                "end": {
                                    "line": 51,
                                    "column": 37
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/cloudformation/template_deployer.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "AWS_REGION_US_EAST_1",
                            "position": {
                                "start": {
                                    "line": 51,
                                    "column": 17
                                },
                                "end": {
                                    "line": 51,
                                    "column": 37
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/localstack/localstack/utils/cloudformation/template_deployer.py",
                            "hunk_idx": 7,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "\n",
                "def lambda_get_params():\n",
                "    return lambda params, **kwargs: params\n",
                "\n",
                "\n",
                "def rename_params(func, rename_map):\n",
                "    def do_rename(params, **kwargs):\n",
                "        values = func(params, **kwargs) if func else params\n",
                "        for old_param, new_param in rename_map.items():\n",
                "            values[new_param] = values.pop(old_param, None)\n",
                "        return values\n",
                "    return do_rename\n",
                "\n",
                "\n",
                "def params_list_to_dict(param_name, key_attr_name='Key', value_attr_name='Value'):\n",
                "    def do_replace(params, **kwargs):\n",
                "        result = {}\n",
                "        for entry in params.get(param_name, []):\n",
                "            key = entry[key_attr_name]\n",
                "            value = entry[value_attr_name]\n",
                "            result[key] = value\n",
                "        return result\n",
                "    return do_replace\n",
                "\n",
                "\n",
                "def params_dict_to_list(param_name, key_attr_name='Key', value_attr_name='Value', wrapper=None):\n",
                "    def do_replace(params, **kwargs):\n",
                "        result = []\n",
                "        for key, value in params.get(param_name, {}).items():\n",
                "            result.append({key_attr_name: key, value_attr_name: value})\n",
                "        if wrapper:\n",
                "            result = {wrapper: result}\n",
                "        return result\n",
                "    return do_replace\n",
                "\n",
                "\n",
                "def get_nested_stack_params(params, **kwargs):\n",
                "    stack_name = kwargs.get('stack_name', 'stack')\n",
                "    nested_stack_name = '%s-%s' % (stack_name, common.short_uid())\n",
                "    stack_params = params.get('Parameters', {})\n",
                "    stack_params = [{'ParameterKey': k, 'ParameterValue': v} for k, v in stack_params.items()]\n",
                "    result = {\n",
                "        'StackName': nested_stack_name,\n",
                "        'TemplateURL': params.get('TemplateURL'),\n",
                "        'Parameters': stack_params\n",
                "    }\n",
                "    return result\n",
                "\n",
                "\n",
                "def get_lambda_code_param(params, **kwargs):\n",
                "    code = params.get('Code', {})\n",
                "    zip_file = code.get('ZipFile')\n",
                "    if zip_file and not common.is_base64(zip_file):\n",
                "        tmp_dir = common.new_tmp_dir()\n",
                "        handler_file = get_handler_file_from_name(params['Handler'], runtime=params['Runtime'])\n",
                "        tmp_file = os.path.join(tmp_dir, handler_file)\n",
                "        common.save_file(tmp_file, zip_file)\n",
                "        zip_file = create_zip_file(tmp_file, get_content=True)\n",
                "        code['ZipFile'] = zip_file\n",
                "        common.rm_rf(tmp_dir)\n",
                "    return code\n",
                "\n",
                "\n",
                "def sns_subscription_params(params, **kwargs):\n",
                "    def attr_val(val):\n",
                "        return json.dumps(val) if isinstance(val, (dict, list)) else str(val)\n",
                "\n",
                "    attrs = ['DeliveryPolicy', 'FilterPolicy', 'RawMessageDelivery', 'RedrivePolicy']\n",
                "    result = dict([(a, attr_val(params[a])) for a in attrs if a in params])\n",
                "    return result\n",
                "\n",
                "\n",
                "def events_put_rule_params(params, **kwargs):\n",
                "    attrs = ['ScheduleExpression', 'EventPattern', 'State', 'Description', 'Name']\n",
                "    result = select_parameters(*attrs)(params, **kwargs)\n",
                "    result['Name'] = result.get('Name') or PLACEHOLDER_RESOURCE_NAME\n",
                "\n",
                "    def wrap_in_lists(o, **kwargs):\n",
                "        if isinstance(o, dict):\n",
                "            for k, v in o.items():\n",
                "                if not isinstance(v, (dict, list)):\n",
                "                    o[k] = [v]\n",
                "        return o\n",
                "\n",
                "    pattern = result.get('EventPattern')\n",
                "    if isinstance(pattern, dict):\n",
                "        wrapped = common.recurse_object(pattern, wrap_in_lists)\n",
                "        result['EventPattern'] = json.dumps(wrapped)\n",
                "    return result\n",
                "\n",
                "\n",
                "def es_add_tags_params(params, **kwargs):\n",
                "    es_arn = aws_stack.es_domain_arn(params.get('DomainName'))\n",
                "    tags = params.get('Tags', [])\n",
                "    return {'ARN': es_arn, 'TagList': tags}\n",
                "\n",
                "\n",
                "def s3_bucket_notification_config(params, **kwargs):\n",
                "    notif_config = params.get('NotificationConfiguration')\n",
                "    if not notif_config:\n",
                "        return None\n",
                "\n",
                "    lambda_configs = []\n",
                "    queue_configs = []\n",
                "    topic_configs = []\n",
                "\n",
                "    attr_tuples = (\n",
                "        ('LambdaConfigurations', lambda_configs, 'LambdaFunctionArn', 'Function'),\n",
                "        ('QueueConfigurations', queue_configs, 'QueueArn', 'Queue'),\n",
                "        ('TopicConfigurations', topic_configs, 'TopicArn', 'Topic')\n",
                "    )\n",
                "\n",
                "    # prepare lambda/queue/topic notification configs\n",
                "    for attrs in attr_tuples:\n",
                "        for config in notif_config.get(attrs[0]) or []:\n",
                "            filter_rules = config.get('Filter', {}).get('S3Key', {}).get('Rules')\n",
                "            entry = {\n",
                "                attrs[2]: config[attrs[3]],\n",
                "                'Events': [config['Event']]\n",
                "            }\n",
                "            if filter_rules:\n",
                "                entry['Filter'] = {'Key': {'FilterRules': filter_rules}}\n",
                "            attrs[1].append(entry)\n",
                "\n",
                "    # construct final result\n",
                "    result = {\n",
                "        'Bucket': params.get('BucketName') or PLACEHOLDER_RESOURCE_NAME,\n",
                "        'NotificationConfiguration': {\n",
                "            'LambdaFunctionConfigurations': lambda_configs,\n",
                "            'QueueConfigurations': queue_configs,\n",
                "            'TopicConfigurations': topic_configs\n",
                "        }\n",
                "    }\n",
                "    return result\n",
                "\n",
                "\n",
                "def select_parameters(*param_names):\n",
                "    return lambda params, **kwargs: dict([(k, v) for k, v in params.items() if k in param_names])\n",
                "\n",
                "\n",
                "def merge_parameters(func1, func2):\n",
                "    return lambda params, **kwargs: common.merge_dicts(func1(params, **kwargs), func2(params, **kwargs))\n",
                "\n",
                "\n",
                "def dump_json_params(param_func=None, *param_names):\n",
                "    def replace(params, **kwargs):\n",
                "        result = param_func(params, **kwargs) if param_func else params\n",
                "        for name in param_names:\n",
                "            if isinstance(result.get(name), (dict, list)):\n",
                "                # Fix for https://github.com/localstack/localstack/issues/2022\n",
                "                # Convert any date instances to date strings, etc, Version: \"2012-10-17\"\n",
                "                param_value = common.json_safe(result[name])\n",
                "                result[name] = json.dumps(param_value)\n",
                "        return result\n",
                "    return replace\n",
                "\n",
                "\n",
                "def param_defaults(param_func, defaults):\n",
                "    def replace(params, **kwargs):\n",
                "        result = param_func(params, **kwargs)\n",
                "        for key, value in defaults.items():\n",
                "            if result.get(key) in ['', None]:\n",
                "                result[key] = value\n",
                "        return result\n",
                "    return replace\n",
                "\n",
                "\n",
                "# maps resource types to functions and parameters for creation\n",
                "RESOURCE_TO_FUNCTION = {\n",
                "    'S3::Bucket': {\n",
                "        'create': [{\n",
                "            'function': 'create_bucket',\n",
                "            'parameters': {\n",
                "                'Bucket': ['BucketName', PLACEHOLDER_RESOURCE_NAME],\n",
                "                'ACL': lambda params, **kwargs: convert_acl_cf_to_s3(params.get('AccessControl', 'PublicRead')),\n",
                "                'CreateBucketConfiguration': lambda params, **kwargs: get_bucket_location_config()\n",
                "            }\n",
                "        }, {\n",
                "            'function': 'put_bucket_notification_configuration',\n",
                "            'parameters': s3_bucket_notification_config\n",
                "        }],\n",
                "        'delete': [{\n",
                "            'function': 'delete_bucket_policy',\n",
                "            'parameters': {\n",
                "                'Bucket': 'PhysicalResourceId'\n",
                "            }\n",
                "        }, {\n",
                "            'function': 'delete_bucket',\n",
                "            'parameters': {\n",
                "                'Bucket': 'PhysicalResourceId'\n",
                "            }\n",
                "        }]\n",
                "    },\n",
                "    'S3::BucketPolicy': {\n",
                "        'create': {\n",
                "            'function': 'put_bucket_policy',\n",
                "            'parameters': rename_params(dump_json_params(None, 'PolicyDocument'), {'PolicyDocument': 'Policy'})\n",
                "        }\n",
                "    },\n",
                "    'SQS::Queue': {\n",
                "        'create': {\n",
                "            'function': 'create_queue',\n",
                "            'parameters': {\n",
                "                'QueueName': ['QueueName', PLACEHOLDER_RESOURCE_NAME],\n",
                "                'Attributes': params_select_attributes('ContentBasedDeduplication', 'DelaySeconds', 'FifoQueue',\n",
                "                                                       'MaximumMessageSize', 'MessageRetentionPeriod',\n",
                "                                                       'VisibilityTimeout', 'RedrivePolicy'),\n",
                "                'tags': params_list_to_dict('Tags')\n",
                "            }\n",
                "        },\n",
                "        'delete': {\n",
                "            'function': 'delete_queue',\n",
                "            'parameters': {\n",
                "                'QueueUrl': 'PhysicalResourceId'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'SNS::Topic': {\n",
                "        'create': {\n",
                "            'function': 'create_topic',\n",
                "            'parameters': {\n",
                "                'Name': 'TopicName',\n",
                "                'Tags': 'Tags'\n",
                "            }\n",
                "        },\n",
                "        'delete': {\n",
                "            'function': 'delete_topic',\n",
                "            'parameters': {\n",
                "                'TopicArn': 'PhysicalResourceId'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'SSM::Parameter': {\n",
                "        'create': {\n",
                "            'function': 'put_parameter',\n",
                "            'parameters': merge_parameters(params_dict_to_list('Tags', wrapper='Tags'), params_select_attributes(\n",
                "                'Name', 'Type', 'Value', 'Description', 'AllowedPattern', 'Policies', 'Tier'))\n",
                "        }\n",
                "    },\n",
                "    'SecretsManager::Secret': {\n",
                "        'create': {\n",
                "            'function': 'create_secret',\n",
                "            'parameters': select_parameters('Name', 'Description', 'SecretString', 'KmsKeyId', 'Tags')\n",
                "        },\n",
                "        'delete': {\n",
                "            'function': 'delete_secret',\n",
                "            'parameters': {\n",
                "                'SecretId': 'PhysicalResourceId'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'KinesisFirehose::DeliveryStream': {\n",
                "        'create': {\n",
                "            'function': 'create_delivery_stream',\n",
                "            'parameters': select_parameters('DeliveryStreamName', 'DeliveryStreamType',\n",
                "                'S3DestinationConfiguration', 'ElasticsearchDestinationConfiguration')\n",
                "        },\n",
                "        'delete': {\n",
                "            'function': 'delete_delivery_stream',\n",
                "            'parameters': {\n",
                "                'DeliveryStreamName': 'PhysicalResourceId'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'Elasticsearch::Domain': {\n",
                "        'create': [{\n",
                "            'function': 'create_elasticsearch_domain',\n",
                "            'parameters': select_parameters('AccessPolicies', 'AdvancedOptions', 'CognitoOptions',\n",
                "                'DomainName', 'EBSOptions', 'ElasticsearchClusterConfig', 'ElasticsearchVersion',\n",
                "                'EncryptionAtRestOptions', 'LogPublishingOptions', 'NodeToNodeEncryptionOptions',\n",
                "                'SnapshotOptions', 'VPCOptions')\n",
                "        }, {\n",
                "            'function': 'add_tags',\n",
                "            'parameters': es_add_tags_params\n",
                "        }],\n",
                "        'delete': {\n",
                "            'function': 'delete_elasticsearch_domain',\n",
                "            'parameters': {\n",
                "                'DomainName': 'PhysicalResourceId'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'Logs::LogGroup': {\n",
                "        'create': {\n",
                "            'function': 'create_log_group',\n",
                "            'parameters': {\n",
                "                'logGroupName': 'LogGroupName'\n",
                "            }\n",
                "        },\n",
                "        'delete': {\n",
                "            'function': 'delete_log_group',\n",
                "            'parameters': {\n",
                "                'logGroupName': 'PhysicalResourceId'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'Lambda::Function': {\n",
                "        'create': {\n",
                "            'function': 'create_function',\n",
                "            'parameters': {\n",
                "                'FunctionName': 'FunctionName',\n",
                "                'Runtime': 'Runtime',\n",
                "                'Role': 'Role',\n",
                "                'Handler': 'Handler',\n",
                "                'Code': get_lambda_code_param,\n",
                "                'Description': 'Description',\n",
                "                'Environment': 'Environment',\n",
                "                'Timeout': 'Timeout',\n",
                "                'MemorySize': 'MemorySize',\n",
                "                # TODO add missing fields\n",
                "            },\n",
                "            'defaults': {\n",
                "                'Role': 'test_role'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'Lambda::Version': {\n",
                "        'create': {\n",
                "            'function': 'publish_version',\n",
                "            'parameters': {\n",
                "                'FunctionName': 'FunctionName',\n",
                "                'CodeSha256': 'CodeSha256',\n",
                "                'Description': 'Description'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'Lambda::Permission': {},\n",
                "    'Lambda::EventSourceMapping': {\n",
                "        'create': {\n",
                "            'function': 'create_event_source_mapping',\n",
                "            'parameters': {\n",
                "                'FunctionName': 'FunctionName',\n",
                "                'EventSourceArn': 'EventSourceArn',\n",
                "                'StartingPosition': 'StartingPosition',\n",
                "                'Enabled': 'Enabled',\n",
                "                'BatchSize': 'BatchSize',\n",
                "                'StartingPositionTimestamp': 'StartingPositionTimestamp'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'DynamoDB::Table': {\n",
                "        'create': {\n",
                "            'function': 'create_table',\n",
                "            'parameters': {\n",
                "                'TableName': 'TableName',\n",
                "                'AttributeDefinitions': 'AttributeDefinitions',\n",
                "                'KeySchema': 'KeySchema',\n",
                "                'ProvisionedThroughput': 'ProvisionedThroughput',\n",
                "                'LocalSecondaryIndexes': 'LocalSecondaryIndexes',\n",
                "                'GlobalSecondaryIndexes': 'GlobalSecondaryIndexes',\n",
                "                'StreamSpecification': lambda params, **kwargs: (\n",
                "                    common.merge_dicts(params.get('StreamSpecification'), {'StreamEnabled': True}, default=None))\n",
                "            },\n",
                "            'defaults': {\n",
                "                'ProvisionedThroughput': {\n",
                "                    'ReadCapacityUnits': 5,\n",
                "                    'WriteCapacityUnits': 5\n",
                "                }\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'Events::Rule': {\n",
                "        'create': [{\n",
                "            'function': 'put_rule',\n",
                "            'parameters': events_put_rule_params\n",
                "        }, {\n",
                "            'function': 'put_targets',\n",
                "            'parameters': {\n",
                "                'Rule': PLACEHOLDER_RESOURCE_NAME,\n",
                "                'EventBusName': 'EventBusName',\n",
                "                'Targets': 'Targets'\n",
                "            }\n",
                "        }],\n",
                "        'delete': {\n",
                "            'function': 'delete_rule',\n",
                "            'parameters': {\n",
                "                'Name': 'PhysicalResourceId'\n",
                "            }\n",
                "\n",
                "        }\n",
                "    },\n",
                "    'IAM::Role': {\n",
                "        'create': {\n",
                "            'function': 'create_role',\n",
                "            'parameters':\n",
                "                param_defaults(\n",
                "                    dump_json_params(\n",
                "                        select_parameters('Path', 'RoleName', 'AssumeRolePolicyDocument',\n",
                "                            'Description', 'MaxSessionDuration', 'PermissionsBoundary', 'Tags'),\n",
                "                        'AssumeRolePolicyDocument'),\n",
                "                    {'RoleName': PLACEHOLDER_RESOURCE_NAME})\n",
                "        },\n",
                "        'delete': {\n",
                "            'function': 'delete_role',\n",
                "            'parameters': {\n",
                "                'RoleName': 'PhysicalResourceId'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'ApiGateway::RestApi': {\n",
                "        'create': {\n",
                "            'function': 'create_rest_api',\n",
                "            'parameters': {\n",
                "                'name': 'Name',\n",
                "                'description': 'Description'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'ApiGateway::Resource': {\n",
                "        'create': {\n",
                "            'function': 'create_resource',\n",
                "            'parameters': {\n",
                "                'restApiId': 'RestApiId',\n",
                "                'pathPart': 'PathPart',\n",
                "                'parentId': 'ParentId'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'ApiGateway::Method': {\n",
                "        'create': {\n",
                "            'function': 'put_method',\n",
                "            'parameters': {\n",
                "                'restApiId': 'RestApiId',\n",
                "                'resourceId': 'ResourceId',\n",
                "                'httpMethod': 'HttpMethod',\n",
                "                'authorizationType': 'AuthorizationType',\n",
                "                'requestParameters': 'RequestParameters'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'ApiGateway::Method::Integration': {\n",
                "    },\n",
                "    'ApiGateway::Deployment': {\n",
                "        'create': {\n",
                "            'function': 'create_deployment',\n",
                "            'parameters': {\n",
                "                'restApiId': 'RestApiId',\n",
                "                'stageName': 'StageName',\n",
                "                'stageDescription': 'StageDescription',\n",
                "                'description': 'Description'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'ApiGateway::GatewayResponse': {\n",
                "        'create': {\n",
                "            'function': 'put_gateway_response',\n",
                "            'parameters': {\n",
                "                'restApiId': 'RestApiId',\n",
                "                'responseType': 'ResponseType',\n",
                "                'statusCode': 'StatusCode',\n",
                "                'responseParameters': 'ResponseParameters',\n",
                "                'responseTemplates': 'ResponseTemplates'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'Kinesis::Stream': {\n",
                "        'create': {\n",
                "            'function': 'create_stream',\n",
                "            'parameters': {\n",
                "                'StreamName': 'Name',\n",
                "                'ShardCount': 'ShardCount'\n",
                "            },\n",
                "            'defaults': {\n",
                "                'ShardCount': 1\n",
                "            }\n",
                "        },\n",
                "        'delete': {\n",
                "            'function': 'delete_stream',\n",
                "            'parameters': {\n",
                "                'StreamName': 'PhysicalResourceId'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'StepFunctions::StateMachine': {\n",
                "        'create': {\n",
                "            'function': 'create_state_machine',\n",
                "            'parameters': {\n",
                "                'name': ['StateMachineName', PLACEHOLDER_RESOURCE_NAME],\n",
                "                'definition': 'DefinitionString',\n",
                "                'roleArn': lambda params, **kwargs: get_role_arn(params.get('RoleArn'), **kwargs)\n",
                "            }\n",
                "        },\n",
                "        'delete': {\n",
                "            'function': 'delete_state_machine',\n",
                "            'parameters': {\n",
                "                'stateMachineArn': 'PhysicalResourceId'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'StepFunctions::Activity': {\n",
                "        'create': {\n",
                "            'function': 'create_activity',\n",
                "            'parameters': {\n",
                "                'name': ['Name', PLACEHOLDER_RESOURCE_NAME],\n",
                "                'tags': 'Tags'\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'SNS::Subscription': {\n",
                "        'create': {\n",
                "            'function': 'subscribe',\n",
                "            'parameters': {\n",
                "                'TopicArn': 'TopicArn',\n",
                "                'Protocol': 'Protocol',\n",
                "                'Endpoint': 'Endpoint',\n",
                "                'Attributes': sns_subscription_params\n",
                "            }\n",
                "        }\n",
                "    },\n",
                "    'CloudFormation::Stack': {\n",
                "        'create': {\n",
                "            'function': 'create_stack',\n",
                "            'parameters': get_nested_stack_params\n",
                "        }\n",
                "    }\n",
                "}\n",
                "\n",
                "# ----------------\n",
                "# UTILITY METHODS\n",
                "# ----------------\n",
                "\n",
                "\n",
                "def convert_acl_cf_to_s3(acl):\n",
                "    \"\"\" Convert a CloudFormation ACL string (e.g., 'PublicRead') to an S3 ACL string (e.g., 'public-read') \"\"\"\n",
                "    return re.sub('(?<!^)(?=[A-Z])', '-', acl).lower()\n",
                "\n",
                "\n",
                "def retrieve_topic_arn(topic_name):\n",
                "    topics = aws_stack.connect_to_service('sns').list_topics()['Topics']\n",
                "    topic_arns = [t['TopicArn'] for t in topics if t['TopicArn'].endswith(':%s' % topic_name)]\n",
                "    return topic_arns[0]\n",
                "\n",
                "\n",
                "def get_role_arn(role_arn, **kwargs):\n",
                "    role_arn = resolve_refs_recursively(kwargs.get('stack_name'), role_arn, kwargs.get('resources'))\n",
                "    return aws_stack.role_arn(role_arn)\n",
                "\n",
                "\n",
                "# ---------------------\n",
                "# CF TEMPLATE HANDLING\n",
                "# ---------------------\n",
                "\n",
                "def parse_template(template):\n",
                "    try:\n",
                "        return json.loads(template)\n",
                "    except Exception:\n",
                "        yaml.add_multi_constructor('', moto.cloudformation.utils.yaml_tag_constructor, Loader=NoDatesSafeLoader)\n",
                "        try:\n",
                "            return yaml.safe_load(template)\n",
                "        except Exception:\n",
                "            return yaml.load(template, Loader=NoDatesSafeLoader)\n",
                "\n",
                "\n",
                "def template_to_json(template):\n",
                "    template = parse_template(template)\n",
                "    return json.dumps(template)\n",
                "\n",
                "\n",
                "def get_resource_type(resource):\n",
                "    res_type = resource.get('ResourceType') or resource.get('Type') or ''\n",
                "    parts = res_type.split('::', 1)\n",
                "    if len(parts) == 1:\n",
                "        return None\n",
                "    return parts[1]\n",
                "\n",
                "\n",
                "def get_service_name(resource):\n",
                "    res_type = resource.get('Type', resource.get('ResourceType', ''))\n",
                "    parts = res_type.split('::')\n",
                "    if len(parts) == 1:\n",
                "        return None\n",
                "    if res_type.endswith('Cognito::UserPool'):\n",
                "        return 'cognito-idp'\n",
                "    if parts[-2] == 'Cognito':\n",
                "        return 'cognito-idp'\n",
                "    if parts[-2] == 'Elasticsearch':\n",
                "        return 'es'\n",
                "    if parts[-2] == 'KinesisFirehose':\n",
                "        return 'firehose'\n",
                "    return parts[1].lower()\n",
                "\n",
                "\n",
                "def get_resource_name(resource):\n",
                "    res_type = get_resource_type(resource)\n",
                "    properties = resource.get('Properties') or {}\n",
                "    name = properties.get('Name')\n",
                "    if name:\n",
                "        return name\n",
                "\n",
                "    # try to extract name from attributes\n",
                "    if res_type == 'S3::Bucket':\n",
                "        name = s3_listener.normalize_bucket_name(properties.get('BucketName'))\n",
                "    elif res_type == 'SQS::Queue':\n",
                "        name = properties.get('QueueName')\n",
                "    elif res_type == 'Cognito::UserPool':\n",
                "        name = properties.get('PoolName')\n",
                "    elif res_type == 'StepFunctions::StateMachine':\n",
                "        name = properties.get('StateMachineName')\n",
                "    elif res_type == 'IAM::Role':\n",
                "        name = properties.get('RoleName')\n",
                "    else:\n",
                "        LOG.warning('Unable to extract name for resource type \"%s\"' % res_type)\n",
                "\n",
                "    return name\n",
                "\n",
                "\n",
                "def get_client(resource, func_config):\n",
                "    resource_type = get_resource_type(resource)\n",
                "    service = get_service_name(resource)\n",
                "    resource_config = RESOURCE_TO_FUNCTION.get(resource_type)\n",
                "    if resource_config is None:\n",
                "        raise Exception('CloudFormation deployment for resource type %s not yet implemented' % resource_type)\n",
                "    try:\n",
                "        if func_config.get('boto_client') == 'resource':\n",
                "            return aws_stack.connect_to_resource(service)\n",
                "        return aws_stack.connect_to_service(service)\n",
                "    except Exception as e:\n",
                "        LOG.warning('Unable to get client for \"%s\" API, skipping deployment: %s' % (service, e))\n",
                "        return None\n",
                "\n",
                "\n",
                "def describe_stack_resource(stack_name, logical_resource_id):\n",
                "    client = aws_stack.connect_to_service('cloudformation')\n",
                "    try:\n",
                "        result = client.describe_stack_resource(StackName=stack_name, LogicalResourceId=logical_resource_id)\n",
                "        return result['StackResourceDetail']\n",
                "    except Exception as e:\n",
                "        LOG.warning('Unable to get details for resource \"%s\" in CloudFormation stack \"%s\": %s' %\n",
                "                    (logical_resource_id, stack_name, e))\n",
                "\n",
                "\n",
                "def retrieve_resource_details(resource_id, resource_status, resources, stack_name):\n",
                "    resource = resources.get(resource_id)\n",
                "    resource_id = resource_status.get('PhysicalResourceId') or resource_id\n",
                "    if not resource:\n",
                "        resource = {}\n",
                "    resource_type = get_resource_type(resource)\n",
                "    resource_props = resource.get('Properties')\n",
                "    try:\n",
                "        if resource_type == 'Lambda::Function':\n",
                "            resource_props['FunctionName'] = (resource_props.get('FunctionName') or\n",
                "                '{}-lambda-{}'.format(stack_name[:45], common.short_uid()))\n",
                "            resource_id = resource_props['FunctionName'] if resource else resource_id\n",
                "            return aws_stack.connect_to_service('lambda').get_function(FunctionName=resource_id)\n",
                "        elif resource_type == 'Lambda::Version':\n",
                "            name = resource_props.get('FunctionName')\n",
                "            if not name:\n",
                "                return None\n",
                "            func_name = aws_stack.lambda_function_name(name)\n",
                "            func_version = name.split(':')[7] if len(name.split(':')) > 7 else '$LATEST'\n",
                "            versions = aws_stack.connect_to_service('lambda').list_versions_by_function(FunctionName=func_name)\n",
                "            return ([v for v in versions['Versions'] if v['Version'] == func_version] or [None])[0]\n",
                "        elif resource_type == 'Lambda::EventSourceMapping':\n",
                "            resource_id = resource_props['FunctionName'] if resource else resource_id\n",
                "            source_arn = resource_props.get('EventSourceArn')\n",
                "            resource_id = resolve_refs_recursively(stack_name, resource_id, resources)\n",
                "            source_arn = resolve_refs_recursively(stack_name, source_arn, resources)\n",
                "            if not resource_id or not source_arn:\n",
                "                raise Exception('ResourceNotFound')\n",
                "            mappings = aws_stack.connect_to_service('lambda').list_event_source_mappings(\n",
                "                FunctionName=resource_id, EventSourceArn=source_arn)\n",
                "            mapping = list(filter(lambda m:\n",
                "                m['EventSourceArn'] == source_arn and m['FunctionArn'] == aws_stack.lambda_function_arn(resource_id),\n",
                "                mappings['EventSourceMappings']))\n",
                "            if not mapping:\n",
                "                raise Exception('ResourceNotFound')\n",
                "            return mapping[0]\n",
                "        elif resource_type == 'IAM::Role':\n",
                "            role_name = resource_props.get('RoleName')\n",
                "            role_name = resolve_refs_recursively(stack_name, role_name, resources)\n",
                "            return aws_stack.connect_to_service('iam').get_role(RoleName=role_name)['Role']\n",
                "        elif resource_type == 'SSM::Parameter':\n",
                "            param_name = resource_props.get('Name') or resource_id\n",
                "            param_name = resolve_refs_recursively(stack_name, param_name, resources)\n",
                "            return aws_stack.connect_to_service('ssm').get_parameter(Name=param_name)['Parameter']\n",
                "        elif resource_type == 'DynamoDB::Table':\n",
                "            table_name = resource_props.get('TableName') or resource_id\n",
                "            table_name = resolve_refs_recursively(stack_name, table_name, resources)\n",
                "            return aws_stack.connect_to_service('dynamodb').describe_table(TableName=table_name)\n",
                "        elif resource_type == 'ApiGateway::RestApi':\n",
                "            apis = aws_stack.connect_to_service('apigateway').get_rest_apis()['items']\n",
                "            api_name = resource_props['Name'] if resource else resource_id\n",
                "            api_name = resolve_refs_recursively(stack_name, api_name, resources)\n",
                "            result = list(filter(lambda api: api['name'] == api_name, apis))\n",
                "            return result[0] if result else None\n",
                "        elif resource_type == 'ApiGateway::Resource':\n",
                "            api_id = resource_props['RestApiId'] if resource else resource_id\n",
                "            api_id = resolve_refs_recursively(stack_name, api_id, resources)\n",
                "            parent_id = resolve_refs_recursively(stack_name, resource_props['ParentId'], resources)\n",
                "            if not api_id or not parent_id:\n",
                "                return None\n",
                "            api_resources = aws_stack.connect_to_service('apigateway').get_resources(restApiId=api_id)['items']\n",
                "            target_resource = list(filter(lambda res:\n",
                "                res.get('parentId') == parent_id and res['pathPart'] == resource_props['PathPart'], api_resources))\n",
                "            if not target_resource:\n",
                "                return None\n",
                "            path = aws_stack.get_apigateway_path_for_resource(api_id,\n",
                "                target_resource[0]['id'], resources=api_resources)\n",
                "            result = list(filter(lambda res: res['path'] == path, api_resources))\n",
                "            return result[0] if result else None\n",
                "        elif resource_type == 'ApiGateway::Deployment':\n",
                "            api_id = resource_props['RestApiId'] if resource else resource_id\n",
                "            api_id = resolve_refs_recursively(stack_name, api_id, resources)\n",
                "            if not api_id:\n",
                "                return None\n",
                "            result = aws_stack.connect_to_service('apigateway').get_deployments(restApiId=api_id)['items']\n",
                "            # TODO possibly filter results by stage name or other criteria\n",
                "            return result[0] if result else None\n",
                "        elif resource_type == 'ApiGateway::Method':\n",
                "            api_id = resolve_refs_recursively(stack_name, resource_props['RestApiId'], resources)\n",
                "            res_id = resolve_refs_recursively(stack_name, resource_props['ResourceId'], resources)\n",
                "            if not api_id or not res_id:\n",
                "                return None\n",
                "            res_obj = aws_stack.connect_to_service('apigateway').get_resource(restApiId=api_id, resourceId=res_id)\n",
                "            match = [v for (k, v) in res_obj.get('resourceMethods', {}).items()\n",
                "                     if resource_props['HttpMethod'] in (v.get('httpMethod'), k)]\n",
                "            int_props = resource_props.get('Integration') or {}\n",
                "            if int_props.get('Type') == 'AWS_PROXY':\n",
                "                match = [m for m in match if\n",
                "                    m.get('methodIntegration', {}).get('type') == 'AWS_PROXY' and\n",
                "                    m.get('methodIntegration', {}).get('httpMethod') == int_props.get('IntegrationHttpMethod')]\n",
                "            return any(match) or None\n",
                "        elif resource_type == 'ApiGateway::GatewayResponse':\n",
                "            api_id = resolve_refs_recursively(stack_name, resource_props['RestApiId'], resources)\n",
                "            client = aws_stack.connect_to_service('apigateway')\n",
                "            result = client.get_gateway_response(restApiId=api_id, responseType=resource_props['ResponseType'])\n",
                "            return result if 'responseType' in result else None\n",
                "        elif resource_type == 'SQS::Queue':\n",
                "            sqs_client = aws_stack.connect_to_service('sqs')\n",
                "            queues = sqs_client.list_queues()\n",
                "            result = list(filter(lambda item:\n",
                "                # TODO possibly find a better way to compare resource_id with queue URLs\n",
                "                item.endswith('/%s' % resource_id), queues.get('QueueUrls', [])))\n",
                "            if not result:\n",
                "                return None\n",
                "            result = sqs_client.get_queue_attributes(QueueUrl=result[0], AttributeNames=['All'])['Attributes']\n",
                "            result['Arn'] = result['QueueArn']\n",
                "            return result\n",
                "        elif resource_type == 'SNS::Topic':\n",
                "            topics = aws_stack.connect_to_service('sns').list_topics()\n",
                "            result = list(filter(lambda item: item['TopicArn'] == resource_id, topics.get('Topics', [])))\n",
                "            return result[0] if result else None\n",
                "        elif resource_type == 'S3::Bucket':\n",
                "            bucket_name = resource_props.get('BucketName') or resource_id\n",
                "            bucket_name = resolve_refs_recursively(stack_name, bucket_name, resources)\n",
                "            bucket_name = s3_listener.normalize_bucket_name(bucket_name)\n",
                "            s3_client = aws_stack.connect_to_service('s3')\n",
                "            response = s3_client.get_bucket_location(Bucket=bucket_name)\n",
                "            notifs = resource_props.get('NotificationConfiguration')\n",
                "            if not response or not notifs:\n",
                "                return response\n",
                "            configs = s3_client.get_bucket_notification_configuration(Bucket=bucket_name)\n",
                "            has_notifs = (configs.get('TopicConfigurations') or configs.get('QueueConfigurations') or\n",
                "                configs.get('LambdaFunctionConfigurations'))\n",
                "            if notifs and not has_notifs:\n",
                "                return None\n",
                "            return response\n",
                "        elif resource_type == 'S3::BucketPolicy':\n",
                "            bucket_name = resource_props.get('Bucket') or resource_id\n",
                "            bucket_name = resolve_refs_recursively(stack_name, bucket_name, resources)\n",
                "            return aws_stack.connect_to_service('s3').get_bucket_policy(Bucket=bucket_name)\n",
                "        elif resource_type == 'Logs::LogGroup':\n",
                "            group_name = resource_props.get('LogGroupName')\n",
                "            group_name = resolve_refs_recursively(stack_name, group_name, resources)\n",
                "            logs = aws_stack.connect_to_service('logs')\n",
                "            groups = logs.describe_log_groups(logGroupNamePrefix=group_name)['logGroups']\n",
                "            return ([g for g in groups if g['logGroupName'] == group_name] or [None])[0]\n",
                "        elif resource_type == 'Kinesis::Stream':\n",
                "            stream_name = resolve_refs_recursively(stack_name, resource_props['Name'], resources)\n",
                "            result = aws_stack.connect_to_service('kinesis').describe_stream(StreamName=stream_name)\n",
                "            return result\n",
                "        elif resource_type == 'StepFunctions::StateMachine':\n",
                "            sm_name = resource_props.get('StateMachineName') or resource_id\n",
                "            sm_name = resolve_refs_recursively(stack_name, sm_name, resources)\n",
                "            sfn_client = aws_stack.connect_to_service('stepfunctions')\n",
                "            state_machines = sfn_client.list_state_machines()['stateMachines']\n",
                "            sm_arn = [m['stateMachineArn'] for m in state_machines if m['name'] == sm_name]\n",
                "            if not sm_arn:\n",
                "                return None\n",
                "            result = sfn_client.describe_state_machine(stateMachineArn=sm_arn[0])\n",
                "            return result\n",
                "        elif resource_type == 'StepFunctions::Activity':\n",
                "            act_name = resource_props.get('Name') or resource_id\n",
                "            act_name = resolve_refs_recursively(stack_name, act_name, resources)\n",
                "            sfn_client = aws_stack.connect_to_service('stepfunctions')\n",
                "            activities = sfn_client.list_activities()['activities']\n",
                "            result = [a['activityArn'] for a in activities if a['name'] == act_name]\n",
                "            if not result:\n",
                "                return None\n",
                "            return result[0]\n",
                "        elif resource_type == 'SecretsManager::Secret':\n",
                "            secret_name = resource_props.get('Name') or resource_id\n",
                "            secret_name = resolve_refs_recursively(stack_name, secret_name, resources)\n",
                "            return aws_stack.connect_to_service('secretsmanager').describe_secret(SecretId=secret_name)\n",
                "        elif resource_type == 'Elasticsearch::Domain':\n",
                "            domain_name = resource_props.get('DomainName') or resource_id\n",
                "            domain_name = resolve_refs_recursively(stack_name, domain_name, resources)\n",
                "            return aws_stack.connect_to_service('es').describe_elasticsearch_domain(DomainName=domain_name)\n",
                "        elif resource_type == 'KinesisFirehose::DeliveryStream':\n",
                "            stream_name = resource_props.get('DeliveryStreamName') or resource_id\n",
                "            stream_name = resolve_refs_recursively(stack_name, stream_name, resources)\n",
                "            return aws_stack.connect_to_service('firehose').describe_delivery_stream(DeliveryStreamName=stream_name)\n",
                "        if is_deployable_resource(resource):\n",
                "            LOG.warning('Unexpected resource type %s when resolving references of resource %s: %s' %\n",
                "                        (resource_type, resource_id, resource))\n",
                "    except Exception as e:\n",
                "        check_not_found_exception(e, resource_type, resource, resource_status)\n",
                "    return None\n",
                "\n",
                "\n",
                "def check_not_found_exception(e, resource_type, resource, resource_status):\n",
                "    # we expect this to be a \"not found\" exception\n",
                "    markers = ['NoSuchBucket', 'ResourceNotFound', '404', 'not found']\n",
                "    if not list(filter(lambda marker, e=e: marker in str(e), markers)):\n",
                "        LOG.warning('Unexpected error retrieving details for resource %s: %s %s - %s %s' %\n",
                "            (resource_type, e, traceback.format_exc(), resource, resource_status))\n",
                "\n",
                "\n",
                "def extract_resource_attribute(resource_type, resource, attribute):\n",
                "    LOG.debug('Extract resource attribute: %s %s' % (resource_type, attribute))\n",
                "    # extract resource specific attributes\n",
                "    if resource_type == 'Lambda::Function':\n",
                "        actual_attribute = 'FunctionArn' if attribute == 'Arn' else attribute\n",
                "        return resource['Configuration'][actual_attribute]\n",
                "    elif resource_type == 'DynamoDB::Table':\n",
                "        actual_attribute = 'LatestStreamArn' if attribute == 'StreamArn' else attribute\n",
                "        value = resource['Table'].get(actual_attribute)\n",
                "        return value\n",
                "    elif resource_type == 'ApiGateway::RestApi':\n",
                "        if attribute == 'PhysicalResourceId':\n",
                "            return resource['id']\n",
                "        if attribute == 'RootResourceId':\n",
                "            resources = aws_stack.connect_to_service('apigateway').get_resources(restApiId=resource['id'])['items']\n",
                "            for res in resources:\n",
                "                if res['path'] == '/' and not res.get('parentId'):\n",
                "                    return res['id']\n",
                "    elif resource_type == 'ApiGateway::Resource':\n",
                "        if attribute == 'PhysicalResourceId':\n",
                "            return resource['id']\n",
                "    attribute_lower = common.first_char_to_lower(attribute)\n",
                "    return resource.get(attribute) or resource.get(attribute_lower)\n",
                "\n",
                "\n",
                "def resolve_ref(stack_name, ref, resources, attribute):\n",
                "    if ref == 'AWS::Region':\n",
                "        return aws_stack.get_region()\n",
                "    if ref == 'AWS::Partition':\n",
                "        return 'aws'\n",
                "    if ref == 'AWS::StackName':\n",
                "        return stack_name\n",
                "\n",
                "    # first, check stack parameters\n",
                "    stack_param = get_stack_parameter(stack_name, ref)\n",
                "    if stack_param is not None:\n",
                "        return stack_param\n",
                "\n",
                "    # second, resolve resource references\n",
                "    resource_status = {}\n",
                "    if stack_name:\n",
                "        resource_status = describe_stack_resource(stack_name, ref)\n",
                "        if not resource_status:\n",
                "            return\n",
                "        attr_value = resource_status.get(attribute)\n",
                "        if attr_value not in [None, '']:\n",
                "            return attr_value\n",
                "    elif ref in resources:\n",
                "        resource_status = resources[ref]['__details__']\n",
                "    # fetch resource details\n",
                "    resource_new = retrieve_resource_details(ref, resource_status, resources, stack_name)\n",
                "    if not resource_new:\n",
                "        return\n",
                "    resource = resources.get(ref)\n",
                "    resource_type = get_resource_type(resource)\n",
                "    result = extract_resource_attribute(resource_type, resource_new, attribute)\n",
                "    if not result:\n",
                "        LOG.warning('Unable to extract reference attribute %s from resource: %s' % (attribute, resource_new))\n",
                "    return result\n",
                "\n",
                "\n",
                "def resolve_refs_recursively(stack_name, value, resources):\n",
                "    if isinstance(value, dict):\n",
                "        keys_list = list(value.keys())\n",
                "        # process special operators\n",
                "        if keys_list == ['Ref']:\n",
                "            return resolve_ref(stack_name, value['Ref'],\n",
                "                resources, attribute='PhysicalResourceId')\n",
                "        if keys_list and keys_list[0].lower() == 'fn::getatt':\n",
                "            return resolve_ref(stack_name, value[keys_list[0]][0],\n",
                "                resources, attribute=value[keys_list[0]][1])\n",
                "        if keys_list and keys_list[0].lower() == 'fn::join':\n",
                "            join_values = value[keys_list[0]][1]\n",
                "            join_values = [resolve_refs_recursively(stack_name, v, resources) for v in join_values]\n",
                "            none_values = [v for v in join_values if v is None]\n",
                "            if none_values:\n",
                "                raise Exception('Cannot resolve CF fn::Join %s due to null values: %s' % (value, join_values))\n",
                "            return value[keys_list[0]][0].join(join_values)\n",
                "        if keys_list and keys_list[0].lower() == 'fn::sub':\n",
                "            item_to_sub = value[keys_list[0]]\n",
                "            if not isinstance(item_to_sub, list):\n",
                "                attr_refs = dict([(r, {'Ref': r}) for r in STATIC_REFS])\n",
                "                item_to_sub = [item_to_sub, attr_refs]\n",
                "            result = item_to_sub[0]\n",
                "            for key, val in item_to_sub[1].items():\n",
                "                val = resolve_refs_recursively(stack_name, val, resources)\n",
                "                result = result.replace('${%s}' % key, val)\n",
                "            return result\n",
                "        else:\n",
                "            for key, val in iteritems(value):\n",
                "                value[key] = resolve_refs_recursively(stack_name, val, resources)\n",
                "    if isinstance(value, list):\n",
                "        for i in range(0, len(value)):\n",
                "            value[i] = resolve_refs_recursively(stack_name, value[i], resources)\n",
                "    return value\n",
                "\n",
                "\n",
                "def get_stack_parameter(stack_name, parameter):\n",
                "    try:\n",
                "        client = aws_stack.connect_to_service('cloudformation')\n",
                "        stack = client.describe_stacks(StackName=stack_name)['Stacks']\n",
                "    except Exception:\n",
                "        return None\n",
                "    stack = stack and stack[0]\n",
                "    if not stack:\n",
                "        return None\n",
                "    result = [p['ParameterValue'] for p in stack['Parameters'] if p['ParameterKey'] == parameter]\n",
                "    return (result or [None])[0]\n",
                "\n",
                "\n",
                "def update_resource(resource_id, resources, stack_name):\n",
                "    resource = resources[resource_id]\n",
                "    resource_type = get_resource_type(resource)\n",
                "    if resource_type not in UPDATEABLE_RESOURCES:\n",
                "        LOG.warning('Unable to update resource type \"%s\", id \"%s\"' % (resource_type, resource_id))\n",
                "        return\n",
                "    LOG.info('Updating resource %s of type %s' % (resource_id, resource_type))\n",
                "    props = resource['Properties']\n",
                "    if resource_type == 'Lambda::Function':\n",
                "        client = aws_stack.connect_to_service('lambda')\n",
                "        keys = ('FunctionName', 'Role', 'Handler', 'Description', 'Timeout', 'MemorySize', 'Environment', 'Runtime')\n",
                "        update_props = dict([(k, props[k]) for k in keys if k in props])\n",
                "        update_props = resolve_refs_recursively(stack_name, update_props, resources)\n",
                "        if 'Code' in props:\n",
                "            client.update_function_code(FunctionName=props['FunctionName'], **props['Code'])\n",
                "        return client.update_function_configuration(**update_props)\n",
                "    if resource_type == 'ApiGateway::Method':\n",
                "        client = aws_stack.connect_to_service('apigateway')\n",
                "        integration = props.get('Integration')\n",
                "        # TODO use RESOURCE_TO_FUNCTION mechanism for updates, instead of hardcoding here\n",
                "        kwargs = {\n",
                "            'restApiId': props['RestApiId'],\n",
                "            'resourceId': props['ResourceId'],\n",
                "            'httpMethod': props['HttpMethod'],\n",
                "            'requestParameters': props.get('RequestParameters')\n",
                "        }\n",
                "        if integration:\n",
                "            kwargs['type'] = integration['Type']\n",
                "            kwargs['integrationHttpMethod'] = integration.get('IntegrationHttpMethod')\n",
                "            kwargs['uri'] = integration.get('Uri')\n",
                "            return client.put_integration(**kwargs)\n",
                "        kwargs['authorizationType'] = props.get('AuthorizationType')\n",
                "        return client.put_method(**kwargs)\n",
                "\n",
                "\n",
                "def fix_account_id_in_arns(params):\n",
                "    def fix_ids(o, **kwargs):\n",
                "        if isinstance(o, dict):\n",
                "            for k, v in o.items():\n",
                "                if common.is_string(v, exclude_binary=True):\n",
                "                    o[k] = aws_stack.fix_account_id_in_arns(v)\n",
                "        elif common.is_string(o, exclude_binary=True):\n",
                "            o = aws_stack.fix_account_id_in_arns(o)\n",
                "        return o\n",
                "    result = common.recurse_object(params, fix_ids)\n",
                "    return result\n",
                "\n",
                "\n",
                "def convert_data_types(func_details, params):\n",
                "    \"\"\" Convert data types in the \"params\" object, with the type defs\n",
                "        specified in the 'types' attribute of \"func_details\". \"\"\"\n",
                "    types = func_details.get('types') or {}\n",
                "    attr_names = types.keys() or []\n",
                "\n",
                "    def cast(_obj, _type):\n",
                "        if _type == bool:\n",
                "            return _obj in ['True', 'true', True]\n",
                "        if _type == str:\n",
                "            return str(_obj)\n",
                "        if _type == int:\n",
                "            return int(_obj)\n",
                "        return _obj\n",
                "\n",
                "    def fix_types(o, **kwargs):\n",
                "        if isinstance(o, dict):\n",
                "            for k, v in o.items():\n",
                "                if k in attr_names:\n",
                "                    o[k] = cast(v, types[k])\n",
                "        return o\n",
                "    result = common.recurse_object(params, fix_types)\n",
                "    return result\n",
                "\n",
                "\n",
                "def remove_none_values(params):\n",
                "    \"\"\" Remove None values recursively in the given object. \"\"\"\n",
                "    def remove_nones(o, **kwargs):\n",
                "        if isinstance(o, dict):\n",
                "            for k, v in dict(o).items():\n",
                "                if v is None:\n",
                "                    o.pop(k)\n",
                "        return o\n",
                "    result = common.recurse_object(params, remove_nones)\n",
                "    return result\n",
                "\n",
                "\n",
                "def deploy_resource(resource_id, resources, stack_name):\n",
                "    return execute_resource_action(resource_id, resources, stack_name, ACTION_CREATE)\n",
                "\n",
                "\n",
                "def delete_resource(resource_id, resources, stack_name):\n",
                "    for res_id, res in resources.items():\n",
                "        if res['ResourceType'] == 'AWS::S3::Bucket':\n",
                "            s3_listener.remove_bucket_notification(res['PhysicalResourceId'])\n",
                "\n",
                "    return execute_resource_action(resource_id, resources, stack_name, ACTION_DELETE)\n",
                "\n",
                "\n",
                "def execute_resource_action(resource_id, resources, stack_name, action_name):\n",
                "    resource = resources[resource_id]\n",
                "    resource_type = get_resource_type(resource)\n",
                "    func_details = RESOURCE_TO_FUNCTION.get(resource_type)\n",
                "    if not func_details or action_name not in func_details:\n",
                "        LOG.warning('Action \"%s\" for resource type %s not yet implemented' % (action_name, resource_type))\n",
                "        return\n",
                "\n",
                "    LOG.debug('Running action \"%s\" for resource type \"%s\" id \"%s\"' % (action_name, resource_type, resource_id))\n",
                "    func_details = func_details[action_name]\n",
                "    func_details = func_details if isinstance(func_details, list) else [func_details]\n",
                "    results = []\n",
                "    for func in func_details:\n",
                "        if callable(func['function']):\n",
                "            result = func['function'](resource_id, resources, resource_type, func, stack_name)\n",
                "            results.append(result)\n",
                "            continue\n",
                "        client = get_client(resource, func)\n",
                "        if client:\n",
                "            result = configure_resource_via_sdk(resource_id, resources, resource_type, func, stack_name)\n",
                "            results.append(result)\n",
                "    return (results or [None])[0]\n",
                "\n",
                "\n",
                "def configure_resource_via_sdk(resource_id, resources, resource_type, func_details, stack_name):\n",
                "    resource = resources[resource_id]\n",
                "    client = get_client(resource, func_details)\n",
                "    function = getattr(client, func_details['function'])\n",
                "    params = func_details.get('parameters') or lambda_get_params()\n",
                "    defaults = func_details.get('defaults', {})\n",
                "    if 'Properties' not in resource:\n",
                "        resource['Properties'] = {}\n",
                "    resource_props = resource['Properties']\n",
                "\n",
                "    if callable(params):\n",
                "        params = params(resource_props, stack_name=stack_name, resources=resources)\n",
                "    else:\n",
                "        params = dict(params)\n",
                "        for param_key, prop_keys in dict(params).items():\n",
                "            params.pop(param_key, None)\n",
                "            if not isinstance(prop_keys, list):\n",
                "                prop_keys = [prop_keys]\n",
                "            for prop_key in prop_keys:\n",
                "                if prop_key == PLACEHOLDER_RESOURCE_NAME:\n",
                "                    params[param_key] = PLACEHOLDER_RESOURCE_NAME\n",
                "                else:\n",
                "                    if callable(prop_key):\n",
                "                        prop_value = prop_key(resource_props, stack_name=stack_name, resources=resources)\n",
                "                    else:\n",
                "                        prop_value = resource_props.get(prop_key)\n",
                "                    if prop_value is not None:\n",
                "                        params[param_key] = prop_value\n",
                "                        break\n",
                "\n",
                "    # replace PLACEHOLDER_RESOURCE_NAME in params\n",
                "    resource_name_holder = {}\n",
                "\n",
                "    def fix_placeholders(o, **kwargs):\n",
                "        if isinstance(o, dict):\n",
                "            for k, v in o.items():\n",
                "                if v == PLACEHOLDER_RESOURCE_NAME:\n",
                "                    if 'value' not in resource_name_holder:\n",
                "                        resource_name_holder['value'] = get_resource_name(resource) or resource_id\n",
                "                    o[k] = resource_name_holder['value']\n",
                "        return o\n",
                "    common.recurse_object(params, fix_placeholders)\n",
                "\n",
                "    # assign default values if empty\n",
                "    params = common.merge_recursive(defaults, params)\n",
                "\n",
                "    # this is an indicator that we should skip this resource deployment, and return\n",
                "    if params is None:\n",
                "        return\n",
                "\n",
                "    # convert refs and boolean strings\n",
                "    for param_key, param_value in dict(params).items():\n",
                "        if param_value is not None:\n",
                "            param_value = params[param_key] = resolve_refs_recursively(stack_name, param_value, resources)\n",
                "        # Convert to boolean (TODO: do this recursively?)\n",
                "        if str(param_value).lower() in ['true', 'false']:\n",
                "            params[param_key] = str(param_value).lower() == 'true'\n",
                "\n",
                "    # convert any moto account IDs (123456789012) in ARNs to our format (000000000000)\n",
                "    params = fix_account_id_in_arns(params)\n",
                "    # convert data types (e.g., boolean strings to bool)\n",
                "    params = convert_data_types(func_details, params)\n",
                "    # remove None values, as they usually raise boto3 errors\n",
                "    params = remove_none_values(params)\n",
                "\n",
                "    # invoke function\n",
                "    try:\n",
                "        LOG.debug('Request for resource type \"%s\" in region %s: %s %s' % (\n",
                "            resource_type, aws_stack.get_region(), func_details['function'], params))\n",
                "        result = function(**params)\n",
                "    except Exception as e:\n",
                "        LOG.warning('Error calling %s with params: %s for resource: %s' % (function, params, resource))\n",
                "        raise e\n",
                "\n",
                "    # some resources have attached/nested resources which we need to create recursively now\n",
                "    if resource_type == 'ApiGateway::Method':\n",
                "        integration = resource_props.get('Integration')\n",
                "        apigateway = aws_stack.connect_to_service('apigateway')\n",
                "        if integration:\n",
                "            api_id = resolve_refs_recursively(stack_name, resource_props['RestApiId'], resources)\n",
                "            res_id = resolve_refs_recursively(stack_name, resource_props['ResourceId'], resources)\n",
                "            kwargs = {}\n",
                "            if integration.get('Uri'):\n",
                "                uri = resolve_refs_recursively(stack_name, integration.get('Uri'), resources)\n",
                "                kwargs['uri'] = uri\n",
                "            if integration.get('IntegrationHttpMethod'):\n",
                "                kwargs['integrationHttpMethod'] = integration['IntegrationHttpMethod']\n",
                "            apigateway.put_integration(restApiId=api_id, resourceId=res_id,\n",
                "                httpMethod=resource_props['HttpMethod'], type=integration['Type'], **kwargs)\n",
                "        responses = resource_props.get('MethodResponses') or []\n",
                "        for response in responses:\n",
                "            api_id = resolve_refs_recursively(stack_name, resource_props['RestApiId'], resources)\n",
                "            res_id = resolve_refs_recursively(stack_name, resource_props['ResourceId'], resources)\n",
                "            apigateway.put_method_response(restApiId=api_id, resourceId=res_id,\n",
                "                httpMethod=resource_props['HttpMethod'], statusCode=response['StatusCode'],\n",
                "                responseParameters=response.get('ResponseParameters', {}))\n",
                "    elif resource_type == 'SNS::Topic':\n",
                "        subscriptions = resource_props.get('Subscription', [])\n",
                "        for subscription in subscriptions:\n",
                "            endpoint = resolve_refs_recursively(stack_name, subscription['Endpoint'], resources)\n",
                "            topic_arn = retrieve_topic_arn(params['Name'])\n",
                "            aws_stack.connect_to_service('sns').subscribe(\n",
                "                TopicArn=topic_arn, Protocol=subscription['Protocol'], Endpoint=endpoint)\n",
                "    elif resource_type == 'S3::Bucket':\n",
                "        tags = resource_props.get('Tags')\n",
                "        if tags:\n",
                "            aws_stack.connect_to_service('s3').put_bucket_tagging(\n",
                "                Bucket=params['Bucket'], Tagging={'TagSet': tags})\n",
                "\n",
                "    return result\n",
                "\n",
                "\n",
                "def delete_stack(stack_name, stack_resources):\n",
                "    resources = dict([(r['LogicalResourceId'], common.clone_safe(r)) for r in stack_resources])\n",
                "    for key, resource in resources.items():\n",
                "        resources[key]['Properties'] = common.clone_safe(resource)\n",
                "\n",
                "    for resource_id in resources.keys():\n",
                "        delete_resource(resource_id, resources, stack_name)\n",
                "\n",
                "\n",
                "# --------\n",
                "# Util methods for analyzing resource dependencies\n",
                "# --------\n",
                "\n",
                "def is_deployable_resource(resource):\n",
                "    resource_type = get_resource_type(resource)\n",
                "    entry = RESOURCE_TO_FUNCTION.get(resource_type)\n",
                "    if entry is None:\n",
                "        LOG.warning('Unknown resource type \"%s\": %s' % (resource_type, resource))\n",
                "    return bool(entry and entry.get(ACTION_CREATE))\n",
                "\n",
                "\n",
                "def is_deployed(resource_id, resources, stack_name):\n",
                "    resource = resources[resource_id]\n",
                "    resource_status = resource.get('__details__') or {}\n",
                "    details = retrieve_resource_details(resource_id, resource_status, resources, stack_name)\n",
                "    return bool(details)\n",
                "\n",
                "\n",
                "def should_be_deployed(resource_id, resources, stack_name):\n",
                "    \"\"\" Return whether the given resource is all of: (1) deployable, (2) not yet deployed,\n",
                "        and (3) has no unresolved dependencies. \"\"\"\n",
                "    resource = resources[resource_id]\n",
                "    if not is_deployable_resource(resource) or is_deployed(resource_id, resources, stack_name):\n",
                "        return False\n",
                "    return all_resource_dependencies_satisfied(resource_id, resources, stack_name)\n",
                "\n",
                "\n",
                "def is_updateable(resource_id, resources, stack_name):\n",
                "    \"\"\" Return whether the given resource can be updated or not \"\"\"\n",
                "    resource = resources[resource_id]\n",
                "    if not is_deployable_resource(resource) or not is_deployed(resource_id, resources, stack_name):\n",
                "        return False\n",
                "    resource_type = get_resource_type(resource)\n",
                "    return resource_type in UPDATEABLE_RESOURCES\n",
                "\n",
                "\n",
                "def all_resource_dependencies_satisfied(resource_id, resources, stack_name):\n",
                "    resource = resources[resource_id]\n",
                "    res_deps = get_resource_dependencies(resource_id, resource, resources)\n",
                "    return all_dependencies_satisfied(res_deps, stack_name, resources, resource_id)\n",
                "\n",
                "\n",
                "def all_dependencies_satisfied(resources, stack_name, all_resources, depending_resource=None):\n",
                "    for resource_id, resource in iteritems(resources):\n",
                "        if is_deployable_resource(resource):\n",
                "            if not is_deployed(resource_id, all_resources, stack_name):\n",
                "                LOG.debug('Dependency for resource %s not yet deployed: %s' % (depending_resource, resource_id))\n",
                "                return False\n",
                "    return True\n",
                "\n",
                "\n",
                "def resources_to_deploy_next(resources, stack_name):\n",
                "    result = {}\n",
                "    for resource_id, resource in resources.items():\n",
                "        if should_be_deployed(resource_id, resources, stack_name):\n",
                "            result[resource_id] = resource\n",
                "    return result\n",
                "\n",
                "\n",
                "def get_resource_dependencies(resource_id, resource, resources):\n",
                "    result = {}\n",
                "    dumped = json.dumps(common.json_safe(resource))\n",
                "    dependencies = resource.get('DependsOn', [])\n",
                "    dependencies = dependencies if isinstance(dependencies, list) else [dependencies]\n",
                "    for other_id, other in resources.items():\n",
                "        if resource != other:\n",
                "            # TODO: traverse dict instead of doing string search\n",
                "            search1 = '{\"Ref\": \"%s\"}' % other_id\n",
                "            search2 = '{\"Fn::GetAtt\": [\"%s\", ' % other_id\n",
                "            if search1 in dumped or search2 in dumped:\n",
                "                result[other_id] = other\n",
                "            if other_id in dependencies:\n",
                "                result[other_id] = other\n",
                "    return result"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                0,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "import and def"
        },
        {
            "edit_hunk_pair": [
                1,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "use and def"
        },
        {
            "edit_hunk_pair": [
                3,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "import and def"
        },
        {
            "edit_hunk_pair": [
                3,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "use and def"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "0 before 1",
            "reason": "move"
        },
        {
            "edit_hunk_pair": [
                4,
                6
            ],
            "edit_order": "0 before 1",
            "reason": "move"
        },
        {
            "edit_hunk_pair": [
                5,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        }
    ]
}