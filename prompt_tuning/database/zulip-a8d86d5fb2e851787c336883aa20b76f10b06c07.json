{
    "language": "python",
    "commit_url": "https://github.com/zulip/zulip/commit/a8d86d5fb2e851787c336883aa20b76f10b06c07",
    "commit_message": "get_old_messages: Refactor handling of UserMessage flags.\n\nThis is in preparation for having a case in which we query the\ndatabase directly to get the message flags, without going through a\nUserMessage object.\n\n(imported from commit d5218974680b0c4b028a84f3aae1c8242ceb08ce)",
    "commit_snapshots": {
        "zephyr/models.py": [
            [
                "from __future__ import absolute_import\n",
                "\n",
                "from django.db import models\n",
                "from django.conf import settings\n",
                "from django.contrib.auth.models import AbstractBaseUser, UserManager\n",
                "from zephyr.lib.cache import cache_with_key, update_user_profile_cache, \\\n",
                "    user_profile_by_id_cache_key, user_profile_by_email_cache_key, \\\n",
                "    update_user_presence_cache\n",
                "from zephyr.lib.utils import make_safe_digest\n",
                "import os\n",
                "from django.db import transaction, IntegrityError\n",
                "from zephyr.lib import bugdown\n",
                "from zephyr.lib.avatar import gravatar_hash, avatar_url\n",
                "from django.utils import timezone\n",
                "from django.contrib.sessions.models import Session\n",
                "from django.utils.html import escape\n",
                "from zephyr.lib.timestamp import datetime_to_timestamp\n",
                "from django.db.models.signals import post_save\n",
                "import zlib\n",
                "\n",
                "from bitfield import BitField\n",
                "import ujson\n",
                "\n",
                "MAX_SUBJECT_LENGTH = 60\n",
                "MAX_MESSAGE_LENGTH = 10000\n",
                "\n",
                "# Doing 1000 memcached requests to get_display_recipient is quite slow,\n",
                "# so add a local cache as well as the memcached cache.\n",
                "recipient_cache = {}\n",
                "def get_display_recipient(recipient):\n",
                "    if settings.TEST_SUITE:\n",
                "        # The test suite expects all caching to be turned off\n",
                "        return get_display_recipient_memcached(recipient)\n",
                "    if recipient.id not in recipient_cache:\n",
                "        recipient_cache[recipient.id] = get_display_recipient_memcached(recipient)\n",
                "    return recipient_cache[recipient.id]\n",
                "\n",
                "@cache_with_key(lambda self: 'display_recipient_dict:%d' % (self.id,),\n",
                "                timeout=3600*24*7)\n",
                "def get_display_recipient_memcached(recipient):\n",
                "    \"\"\"\n",
                "    recipient: an instance of Recipient.\n",
                "\n",
                "    returns: an appropriate object describing the recipient.  For a\n",
                "    stream this will be the stream name as a string.  For a huddle or\n",
                "    personal, it will be an array of dicts about each recipient.\n",
                "    \"\"\"\n",
                "    if recipient.type == Recipient.STREAM:\n",
                "        stream = Stream.objects.get(id=recipient.type_id)\n",
                "        return stream.name\n",
                "\n",
                "    # We don't really care what the ordering is, just that it's deterministic.\n",
                "    user_profile_list = (UserProfile.objects.filter(subscription__recipient=recipient)\n",
                "                                            .select_related()\n",
                "                                            .order_by('email'))\n",
                "    return [{'email': user_profile.email,\n",
                "             'domain': user_profile.realm.domain,\n",
                "             'full_name': user_profile.full_name,\n",
                "             'short_name': user_profile.short_name} for user_profile in user_profile_list]\n",
                "\n",
                "class Realm(models.Model):\n",
                "    domain = models.CharField(max_length=40, db_index=True, unique=True)\n",
                "    restricted_to_domain = models.BooleanField(default=True)\n",
                "\n",
                "    def __repr__(self):\n",
                "        return (u\"<Realm: %s %s>\" % (self.domain, self.id)).encode(\"utf-8\")\n",
                "    def __str__(self):\n",
                "        return self.__repr__()\n",
                "\n",
                "class UserProfile(AbstractBaseUser):\n",
                "    # Fields from models.AbstractUser minus last_name and first_name,\n",
                "    # which we don't use; email is modified to make it indexed and unique.\n",
                "    email = models.EmailField(blank=False, db_index=True, unique=True)\n",
                "    is_staff = models.BooleanField(default=False)\n",
                "    is_active = models.BooleanField(default=True)\n",
                "    is_bot = models.BooleanField(default=False)\n",
                "    date_joined = models.DateTimeField(default=timezone.now)\n",
                "    bot_owner = models.ForeignKey('self', null=True, on_delete=models.SET_NULL)\n",
                "\n",
                "    USERNAME_FIELD = 'email'\n",
                "\n",
                "    # Our custom site-specific fields\n",
                "    full_name = models.CharField(max_length=100)\n",
                "    short_name = models.CharField(max_length=100)\n",
                "    pointer = models.IntegerField()\n",
                "    last_pointer_updater = models.CharField(max_length=64)\n",
                "    realm = models.ForeignKey(Realm)\n",
                "    api_key = models.CharField(max_length=32)\n",
                "    enable_desktop_notifications = models.BooleanField(default=True)\n",
                "    enable_sounds = models.BooleanField(default=True)\n",
                "    enter_sends = models.NullBooleanField(default=False)\n",
                "    enable_offline_email_notifications = models.BooleanField(default=True)\n",
                "    last_reminder = models.DateTimeField(default=timezone.now, null=True)\n",
                "    rate_limits = models.CharField(default=\"\", max_length=100) # comma-separated list of range:max pairs\n",
                "\n",
                "    # Hours to wait before sending another email to a user\n",
                "    EMAIL_REMINDER_WAITPERIOD = 24\n",
                "\n",
                "    AVATAR_FROM_GRAVATAR = 'G'\n",
                "    AVATAR_FROM_USER = 'U'\n",
                "    AVATAR_FROM_SYSTEM = 'S'\n",
                "    AVATAR_SOURCES = (\n",
                "            (AVATAR_FROM_GRAVATAR, 'Hosted by Gravatar'),\n",
                "            (AVATAR_FROM_USER, 'Uploaded by user'),\n",
                "            (AVATAR_FROM_SYSTEM, 'System generated'),\n",
                "    )\n",
                "    avatar_source = models.CharField(default=AVATAR_FROM_GRAVATAR, choices=AVATAR_SOURCES, max_length=1)\n",
                "\n",
                "    TUTORIAL_WAITING  = 'W'\n",
                "    TUTORIAL_STARTED  = 'S'\n",
                "    TUTORIAL_FINISHED = 'F'\n",
                "    TUTORIAL_STATES   = ((TUTORIAL_WAITING,  \"Waiting\"),\n",
                "                         (TUTORIAL_STARTED,  \"Started\"),\n",
                "                         (TUTORIAL_FINISHED, \"Finished\"))\n",
                "\n",
                "    tutorial_status = models.CharField(default=TUTORIAL_WAITING, choices=TUTORIAL_STATES, max_length=1)\n",
                "    # Contains serialized JSON of the form:\n",
                "    #    [(\"step 1\", true), (\"step 2\", false)]\n",
                "    # where the second element of each tuple is if the step has been\n",
                "    # completed.\n",
                "    onboarding_steps = models.TextField(default=ujson.dumps([]))\n",
                "\n",
                "    def tutorial_stream_name(self):\n",
                "        # If you change this, you need to change the corresponding\n",
                "        # client-computed version of it in tutorial.js\n",
                "        long_name = \"tutorial-%s\" % (self.email.split('@')[0],)\n",
                "        short_name = long_name[:Stream.MAX_NAME_LENGTH]\n",
                "        return short_name\n",
                "\n",
                "    objects = UserManager()\n",
                "\n",
                "    def __repr__(self):\n",
                "        return (u\"<UserProfile: %s %s>\" % (self.email, self.realm)).encode(\"utf-8\")\n",
                "    def __str__(self):\n",
                "        return self.__repr__()\n",
                "\n",
                "# Make sure we flush the UserProfile object from our memcached\n",
                "# whenever we save it.\n",
                "post_save.connect(update_user_profile_cache, sender=UserProfile)\n",
                "\n",
                "class PreregistrationUser(models.Model):\n",
                "    email = models.EmailField()\n",
                "    referred_by = models.ForeignKey(UserProfile, null=True)\n",
                "    streams = models.ManyToManyField('Stream', null=True)\n",
                "    invited_at = models.DateTimeField(auto_now=True)\n",
                "\n",
                "    # status: whether an object has been confirmed.\n",
                "    #   if confirmed, set to confirmation.settings.STATUS_ACTIVE\n",
                "    status = models.IntegerField(default=0)\n",
                "\n",
                "class MitUser(models.Model):\n",
                "    email = models.EmailField(unique=True)\n",
                "    # status: whether an object has been confirmed.\n",
                "    #   if confirmed, set to confirmation.settings.STATUS_ACTIVE\n",
                "    status = models.IntegerField(default=0)\n",
                "\n",
                "class Stream(models.Model):\n",
                "    # If you change this, you also need to change the\n",
                "    # corresponding value in tutorial.js\n",
                "    MAX_NAME_LENGTH = 30\n",
                "    name = models.CharField(max_length=MAX_NAME_LENGTH, db_index=True)\n",
                "    realm = models.ForeignKey(Realm, db_index=True)\n",
                "    invite_only = models.NullBooleanField(default=False)\n",
                "\n",
                "    def __repr__(self):\n",
                "        return (u\"<Stream: %s>\" % (self.name,)).encode(\"utf-8\")\n",
                "    def __str__(self):\n",
                "        return self.__repr__()\n",
                "\n",
                "    def is_public(self):\n",
                "        # For every realm except for legacy realms on prod (aka those\n",
                "        # older than realm id 68 with some exceptions), we enable\n",
                "        # historical messages for all streams that are not invite-only.\n",
                "        return ((not settings.DEPLOYED or self.realm.domain in\n",
                "                 [\"humbughq.com\"] or self.realm.id > 68)\n",
                "                and not self.invite_only)\n",
                "\n",
                "    class Meta:\n",
                "        unique_together = (\"name\", \"realm\")\n",
                "\n",
                "    @classmethod\n",
                "    def create(cls, name, realm):\n",
                "        stream = cls(name=name, realm=realm)\n",
                "        stream.save()\n",
                "\n",
                "        recipient = Recipient.objects.create(type_id=stream.id,\n",
                "                                             type=Recipient.STREAM)\n",
                "        return (stream, recipient)\n",
                "\n",
                "def valid_stream_name(name):\n",
                "    return name != \"\"\n",
                "\n",
                "class Recipient(models.Model):\n",
                "    type_id = models.IntegerField(db_index=True)\n",
                "    type = models.PositiveSmallIntegerField(db_index=True)\n",
                "    # Valid types are {personal, stream, huddle}\n",
                "    PERSONAL = 1\n",
                "    STREAM = 2\n",
                "    HUDDLE = 3\n",
                "\n",
                "    class Meta:\n",
                "        unique_together = (\"type\", \"type_id\")\n",
                "\n",
                "    # N.B. If we used Django's choice=... we would get this for free (kinda)\n",
                "    _type_names = {\n",
                "        PERSONAL: 'personal',\n",
                "        STREAM:   'stream',\n",
                "        HUDDLE:   'huddle' }\n",
                "\n",
                "    def type_name(self):\n",
                "        # Raises KeyError if invalid\n",
                "        return self._type_names[self.type]\n",
                "\n",
                "    def __repr__(self):\n",
                "        display_recipient = get_display_recipient(self)\n",
                "        return (u\"<Recipient: %s (%d, %s)>\" % (display_recipient, self.type_id, self.type)).encode(\"utf-8\")\n",
                "\n",
                "class Client(models.Model):\n",
                "    name = models.CharField(max_length=30, db_index=True, unique=True)\n",
                "\n",
                "def get_client_cache_key(name):\n",
                "    return 'get_client:%s' % (make_safe_digest(name),)\n",
                "\n",
                "@cache_with_key(get_client_cache_key, timeout=3600*24*7)\n",
                "@transaction.commit_on_success\n",
                "def get_client(name):\n",
                "    try:\n",
                "        (client, _) = Client.objects.get_or_create(name=name)\n",
                "    except IntegrityError:\n",
                "        # If we're racing with other threads trying to create this\n",
                "        # client, get_or_create will throw IntegrityError (because our\n",
                "        # database is enforcing the no-duplicate-objects constraint);\n",
                "        # in this case one should just re-fetch the object.  This race\n",
                "        # actually happens with populate_db.\n",
                "        #\n",
                "        # Much of the rest of our code that writes to the database\n",
                "        # doesn't handle this duplicate object on race issue correctly :(\n",
                "        transaction.commit()\n",
                "        return Client.objects.get(name=name)\n",
                "    return client\n",
                "\n",
                "def get_stream_cache_key(stream_name, realm):\n",
                "    if isinstance(realm, Realm):\n",
                "        realm_id = realm.id\n",
                "    else:\n",
                "        realm_id = realm\n",
                "    return \"stream_by_realm_and_name:%s:%s\" % (\n",
                "        realm_id, make_safe_digest(stream_name.strip().lower()))\n",
                "\n",
                "# get_stream_backend takes either a realm id or a realm\n",
                "@cache_with_key(get_stream_cache_key, timeout=3600*24*7)\n",
                "def get_stream_backend(stream_name, realm):\n",
                "    if isinstance(realm, Realm):\n",
                "        realm_id = realm.id\n",
                "    else:\n",
                "        realm_id = realm\n",
                "    return Stream.objects.select_related(\"realm\").get(\n",
                "        name__iexact=stream_name.strip(), realm_id=realm_id)\n",
                "\n",
                "# get_stream takes either a realm id or a realm\n",
                "def get_stream(stream_name, realm):\n",
                "    try:\n",
                "        return get_stream_backend(stream_name, realm)\n",
                "    except Stream.DoesNotExist:\n",
                "        return None\n",
                "\n",
                "def get_recipient_cache_key(type, type_id):\n",
                "    return \"get_recipient:%s:%s\" % (type, type_id,)\n",
                "\n",
                "@cache_with_key(get_recipient_cache_key, timeout=3600*24*7)\n",
                "def get_recipient(type, type_id):\n",
                "    return Recipient.objects.get(type_id=type_id, type=type)\n",
                "\n",
                "# NB: This function is currently unused, but may come in handy.\n",
                "def linebreak(string):\n",
                "    return string.replace('\\n\\n', '<p/>').replace('\\n', '<br/>')\n",
                "\n",
                "def extract_message_dict(message_str):\n",
                "    return ujson.loads(zlib.decompress(message_str))\n",
                "\n",
                "def stringify_message_dict(message_dict):\n",
                "    return zlib.compress(ujson.dumps(message_dict))\n",
                "\n",
                "def to_dict_cache_key_id(message_id, apply_markdown, rendered_content=None):\n",
                "    return 'message_dict:%d:%d' % (message_id, apply_markdown)\n",
                "\n",
                "def to_dict_cache_key(message, apply_markdown, rendered_content=None):\n",
                "    return to_dict_cache_key_id(message.id, apply_markdown, rendered_content=None)\n",
                "\n",
                "class Message(models.Model):\n",
                "    sender = models.ForeignKey(UserProfile)\n",
                "    recipient = models.ForeignKey(Recipient)\n",
                "    subject = models.CharField(max_length=MAX_SUBJECT_LENGTH, db_index=True)\n",
                "    content = models.TextField()\n",
                "    rendered_content = models.TextField(null=True)\n",
                "    rendered_content_version = models.IntegerField(null=True)\n",
                "    pub_date = models.DateTimeField('date published', db_index=True)\n",
                "    sending_client = models.ForeignKey(Client)\n",
                "    last_edit_time = models.DateTimeField(null=True)\n",
                "    edit_history = models.TextField(null=True)\n",
                "\n",
                "    def __repr__(self):\n",
                "        display_recipient = get_display_recipient(self.recipient)\n",
                "        return (u\"<Message: %s / %s / %r>\" % (display_recipient, self.subject, self.sender)).encode(\"utf-8\")\n",
                "    def __str__(self):\n",
                "        return self.__repr__()\n",
                "\n",
                "    def to_dict(self, apply_markdown, rendered_content=None):\n",
                "        return extract_message_dict(self.to_dict_json(apply_markdown, rendered_content))\n",
                "\n",
                "    @cache_with_key(to_dict_cache_key, timeout=3600*24)\n",
                "    def to_dict_json(self, apply_markdown, rendered_content=None):\n",
                "        return stringify_message_dict(self.to_dict_uncached(apply_markdown, rendered_content))\n",
                "\n",
                "    def to_dict_uncached(self, apply_markdown, rendered_content=None):\n",
                "        display_recipient = get_display_recipient(self.recipient)\n",
                "        if self.recipient.type == Recipient.STREAM:\n",
                "            display_type = \"stream\"\n",
                "        elif self.recipient.type in (Recipient.HUDDLE, Recipient.PERSONAL):\n",
                "            display_type = \"private\"\n",
                "            if len(display_recipient) == 1:\n",
                "                # add the sender in if this isn't a message between\n",
                "                # someone and his self, preserving ordering\n",
                "                recip = {'email': self.sender.email,\n",
                "                         'domain': self.sender.realm.domain,\n",
                "                         'full_name': self.sender.full_name,\n",
                "                         'short_name': self.sender.short_name};\n",
                "                if recip['email'] < display_recipient[0]['email']:\n",
                "                    display_recipient = [recip, display_recipient[0]]\n",
                "                elif recip['email'] > display_recipient[0]['email']:\n",
                "                    display_recipient = [display_recipient[0], recip]\n",
                "        else:\n",
                "            display_type = self.recipient.type_name()\n",
                "\n",
                "        obj = dict(\n",
                "            id                = self.id,\n",
                "            sender_email      = self.sender.email,\n",
                "            sender_full_name  = self.sender.full_name,\n",
                "            sender_short_name = self.sender.short_name,\n",
                "            sender_domain     = self.sender.realm.domain,\n",
                "            type              = display_type,\n",
                "            display_recipient = display_recipient,\n",
                "            recipient_id      = self.recipient.id,\n",
                "            subject           = self.subject,\n",
                "            timestamp         = datetime_to_timestamp(self.pub_date),\n",
                "            gravatar_hash     = gravatar_hash(self.sender.email), # Deprecated June 2013\n",
                "            avatar_url        = avatar_url(self.sender),\n",
                "            client            = self.sending_client.name)\n",
                "\n",
                "        if self.last_edit_time != None:\n",
                "            obj['last_edit_timestamp'] = datetime_to_timestamp(self.last_edit_time)\n",
                "            obj['edit_history'] = ujson.loads(self.edit_history)\n",
                "        if apply_markdown and self.rendered_content_version is not None:\n",
                "            obj['content'] = self.rendered_content\n",
                "            obj['content_type'] = 'text/html'\n",
                "        elif apply_markdown:\n",
                "            if rendered_content is None:\n",
                "                rendered_content = bugdown.convert(self.content, self.sender.realm.domain)\n",
                "                if rendered_content is None:\n",
                "                    rendered_content = '<p>[Humbug note: Sorry, we could not understand the formatting of your message]</p>'\n",
                "\n",
                "                # Update the database cache of the rendered content\n",
                "                self.rendered_content = rendered_content\n",
                "                self.rendered_content_version = bugdown.version\n",
                "                self.save(update_fields=[\"rendered_content\", \"rendered_content_version\"])\n",
                "            obj['content'] = rendered_content\n",
                "            obj['content_type'] = 'text/html'\n",
                "        else:\n",
                "            obj['content'] = self.content\n",
                "            obj['content_type'] = 'text/x-markdown'\n",
                "\n",
                "        return obj\n",
                "\n",
                "    def to_log_dict(self):\n",
                "        return dict(\n",
                "            id                = self.id,\n",
                "            sender_email      = self.sender.email,\n",
                "            sender_domain     = self.sender.realm.domain,\n",
                "            sender_full_name  = self.sender.full_name,\n",
                "            sender_short_name = self.sender.short_name,\n",
                "            sending_client    = self.sending_client.name,\n",
                "            type              = self.recipient.type_name(),\n",
                "            recipient         = get_display_recipient(self.recipient),\n",
                "            subject           = self.subject,\n",
                "            content           = self.content,\n",
                "            timestamp         = datetime_to_timestamp(self.pub_date))\n",
                "\n",
                "    @classmethod\n",
                "    def remove_unreachable(cls):\n",
                "        \"\"\"Remove all Messages that are not referred to by any UserMessage.\"\"\"\n",
                "        cls.objects.exclude(id__in = UserMessage.objects.values('message_id')).delete()\n",
                "\n",
                "class UserMessage(models.Model):\n",
                "    user_profile = models.ForeignKey(UserProfile)\n",
                "    message = models.ForeignKey(Message)\n",
                "    # We're not using the archived field for now, but create it anyway\n",
                "    # since this table will be an unpleasant one to do schema changes\n",
                "    # on later\n",
                "    archived = models.BooleanField()\n",
                "    flags = BitField(flags=['read', 'starred', 'collapsed', 'mentioned', 'wildcard_mentioned'], default=0)\n",
                "\n",
                "    class Meta:\n",
                "        unique_together = (\"user_profile\", \"message\")\n",
                "\n",
                "    def __repr__(self):\n",
                "        display_recipient = get_display_recipient(self.message.recipient)\n",
                "        return (u\"<UserMessage: %s / %s (%s)>\" % (display_recipient, self.user_profile.email, self.flags_dict())).encode(\"utf-8\")\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    def flags_dict(self):\n",
                    "        return dict(flags = [flag for flag in self.flags.keys() if getattr(self.flags, flag).is_set])\n"
                ],
                "after": [
                    "    def flags_list(self):\n",
                    "        return [flag for flag in self.flags.keys() if getattr(self.flags, flag).is_set]\n"
                ],
                "parent_version_range": {
                    "start": 408,
                    "end": 410
                },
                "child_version_range": {
                    "start": 408,
                    "end": 410
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "UserMessage",
                        "signature": "class UserMessage(models.Model):",
                        "at_line": 392
                    },
                    {
                        "type": "function",
                        "name": "flags_dict",
                        "signature": "def flags_dict(self):",
                        "at_line": 408
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: zephyr/models.py\nCode:\n           class UserMessage(models.Model):\n               ...\n405 405            display_recipient = get_display_recipient(self.message.recipient)\n406 406            return (u\"<UserMessage: %s / %s (%s)>\" % (display_recipient, self.user_profile.email, self.flags_dict())).encode(\"utf-8\")\n407 407    \n408      -     def flags_dict(self):\n409      -         return dict(flags = [flag for flag in self.flags.keys() if getattr(self.flags, flag).is_set])\n    408  +     def flags_list(self):\n    409  +         return [flag for flag in self.flags.keys() if getattr(self.flags, flag).is_set]\n410 410    \n         ...\n",
                "file_path": "zephyr/models.py",
                "identifiers_before": [
                    "dict",
                    "flag",
                    "flags",
                    "flags_dict",
                    "getattr",
                    "is_set",
                    "keys",
                    "self"
                ],
                "identifiers_after": [
                    "flag",
                    "flags",
                    "flags_list",
                    "getattr",
                    "is_set",
                    "keys",
                    "self"
                ],
                "prefix": [
                    "        display_recipient = get_display_recipient(self.message.recipient)\n",
                    "        return (u\"<UserMessage: %s / %s (%s)>\" % (display_recipient, self.user_profile.email, self.flags_dict())).encode(\"utf-8\")\n",
                    "\n"
                ],
                "suffix": [
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "flags_list",
                            "position": {
                                "start": {
                                    "line": 408,
                                    "column": 8
                                },
                                "end": {
                                    "line": 408,
                                    "column": 18
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zephyr/models.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    def flags_dict(self):\n",
                    "        return dict(flags = [self.flags_list()])\n"
                ],
                "parent_version_range": {
                    "start": 411,
                    "end": 411
                },
                "child_version_range": {
                    "start": 411,
                    "end": 413
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 1,
                "hunk_diff": "File: zephyr/models.py\nCode:\n  ...\n410 410    \n    411  +     def flags_dict(self):\n    412  +         return dict(flags = [self.flags_list()])\n411 413    \n412 414    class Subscription(models.Model):\n413 415        user_profile = models.ForeignKey(UserProfile)\n         ...\n",
                "file_path": "zephyr/models.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "dict",
                    "flags",
                    "flags_dict",
                    "flags_list",
                    "self"
                ],
                "prefix": [
                    "\n"
                ],
                "suffix": [
                    "\n",
                    "class Subscription(models.Model):\n",
                    "    user_profile = models.ForeignKey(UserProfile)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "flags_list",
                            "position": {
                                "start": {
                                    "line": 412,
                                    "column": 34
                                },
                                "end": {
                                    "line": 412,
                                    "column": 44
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/zulip/zephyr/models.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "class Subscription(models.Model):\n",
                "    user_profile = models.ForeignKey(UserProfile)\n",
                "    recipient = models.ForeignKey(Recipient)\n",
                "    active = models.BooleanField(default=True)\n",
                "    in_home_view = models.NullBooleanField(default=True)\n",
                "\n",
                "    DEFAULT_STREAM_COLOR = \"#c2c2c2\"\n",
                "    color = models.CharField(max_length=10, default=DEFAULT_STREAM_COLOR)\n",
                "    notifications = models.BooleanField(default=False)\n",
                "\n",
                "    class Meta:\n",
                "        unique_together = (\"user_profile\", \"recipient\")\n",
                "\n",
                "    def __repr__(self):\n",
                "        return (u\"<Subscription: %r -> %s>\" % (self.user_profile, self.recipient)).encode(\"utf-8\")\n",
                "    def __str__(self):\n",
                "        return self.__repr__()\n",
                "\n",
                "@cache_with_key(user_profile_by_id_cache_key, timeout=3600*24*7)\n",
                "def get_user_profile_by_id(uid):\n",
                "    return UserProfile.objects.select_related().get(id=uid)\n",
                "\n",
                "@cache_with_key(user_profile_by_email_cache_key, timeout=3600*24*7)\n",
                "def get_user_profile_by_email(email):\n",
                "    return UserProfile.objects.select_related().get(email__iexact=email)\n",
                "\n",
                "def get_prereg_user_by_email(email):\n",
                "    # A user can be invited many times, so only return the result of the latest\n",
                "    # invite.\n",
                "    return PreregistrationUser.objects.filter(email__iexact=email).latest(\"invited_at\")\n",
                "\n",
                "class Huddle(models.Model):\n",
                "    # TODO: We should consider whether using\n",
                "    # CommaSeparatedIntegerField would be better.\n",
                "    huddle_hash = models.CharField(max_length=40, db_index=True, unique=True)\n",
                "\n",
                "def get_huddle_hash(id_list):\n",
                "    id_list = sorted(set(id_list))\n",
                "    hash_key = \",\".join(str(x) for x in id_list)\n",
                "    return make_safe_digest(hash_key)\n",
                "\n",
                "def huddle_hash_cache_key(huddle_hash):\n",
                "    return \"huddle_by_hash:%s\" % (huddle_hash,)\n",
                "\n",
                "def get_huddle(id_list):\n",
                "    huddle_hash = get_huddle_hash(id_list)\n",
                "    return get_huddle_backend(huddle_hash, id_list)\n",
                "\n",
                "@cache_with_key(lambda huddle_hash, id_list: huddle_hash_cache_key(huddle_hash), timeout=3600*24*7)\n",
                "def get_huddle_backend(huddle_hash, id_list):\n",
                "    (huddle, created) = Huddle.objects.get_or_create(huddle_hash=huddle_hash)\n",
                "    if created:\n",
                "        with transaction.commit_on_success():\n",
                "            recipient = Recipient.objects.create(type_id=huddle.id,\n",
                "                                                 type=Recipient.HUDDLE)\n",
                "            subs_to_create = [Subscription(recipient=recipient,\n",
                "                                           user_profile=get_user_profile_by_id(user_profile_id))\n",
                "                              for user_profile_id in id_list]\n",
                "            Subscription.objects.bulk_create(subs_to_create)\n",
                "    return huddle\n",
                "\n",
                "def get_realm(domain):\n",
                "    try:\n",
                "        return Realm.objects.get(domain__iexact=domain.strip())\n",
                "    except Realm.DoesNotExist:\n",
                "        return None\n",
                "\n",
                "# This function is used only by tests.\n",
                "# We have faster implementations within the app itself.\n",
                "def filter_by_subscriptions(messages, user_profile):\n",
                "    user_messages = []\n",
                "    subscriptions = [sub.recipient for sub in\n",
                "                     Subscription.objects.filter(user_profile=user_profile, active=True)]\n",
                "    for message in messages:\n",
                "        # If you are subscribed to the personal or stream, or if you\n",
                "        # sent the personal, you can see the message.\n",
                "        if (message.recipient in subscriptions) or \\\n",
                "                (message.recipient.type == Recipient.PERSONAL and\n",
                "                 message.sender == user_profile):\n",
                "            user_messages.append(message)\n",
                "\n",
                "    return user_messages\n",
                "\n",
                "def clear_database():\n",
                "    for model in [Message, Stream, UserProfile, Recipient,\n",
                "                  Realm, Subscription, Huddle, UserMessage, Client,\n",
                "                  DefaultStream]:\n",
                "        model.objects.all().delete()\n",
                "    Session.objects.all().delete()\n",
                "\n",
                "class UserActivity(models.Model):\n",
                "    user_profile = models.ForeignKey(UserProfile)\n",
                "    client = models.ForeignKey(Client)\n",
                "    query = models.CharField(max_length=50, db_index=True)\n",
                "\n",
                "    count = models.IntegerField()\n",
                "    last_visit = models.DateTimeField('last visit')\n",
                "\n",
                "    class Meta:\n",
                "        unique_together = (\"user_profile\", \"client\", \"query\")\n",
                "\n",
                "class UserPresence(models.Model):\n",
                "    user_profile = models.ForeignKey(UserProfile)\n",
                "    client = models.ForeignKey(Client)\n",
                "\n",
                "    # Valid statuses\n",
                "    ACTIVE = 1\n",
                "    IDLE = 2\n",
                "\n",
                "    timestamp = models.DateTimeField('presence changed')\n",
                "    status = models.PositiveSmallIntegerField(default=ACTIVE)\n",
                "\n",
                "    def to_dict(self):\n",
                "        if self.status == UserPresence.ACTIVE:\n",
                "            presence_val = 'active'\n",
                "        elif self.status == UserPresence.IDLE:\n",
                "            presence_val = 'idle'\n",
                "\n",
                "        return {'client'   : self.client.name,\n",
                "                'status'   : presence_val,\n",
                "                'timestamp': datetime_to_timestamp(self.timestamp)}\n",
                "\n",
                "    @staticmethod\n",
                "    def status_from_string(status):\n",
                "        if status == 'active':\n",
                "            status_val = UserPresence.ACTIVE\n",
                "        elif status == 'idle':\n",
                "            status_val = UserPresence.IDLE\n",
                "        else:\n",
                "            status_val = None\n",
                "\n",
                "        return status_val\n",
                "\n",
                "    class Meta:\n",
                "        unique_together = (\"user_profile\", \"client\")\n",
                "\n",
                "# Flush the cached user status_dict whenever a user's presence\n",
                "# changes\n",
                "post_save.connect(update_user_presence_cache, sender=UserPresence)\n",
                "\n",
                "class DefaultStream(models.Model):\n",
                "    realm = models.ForeignKey(Realm)\n",
                "    stream = models.ForeignKey(Stream)\n",
                "\n",
                "    class Meta:\n",
                "        unique_together = (\"realm\", \"stream\")\n",
                "\n",
                "# FIXME: The foreign key relationship here is backwards.\n",
                "#\n",
                "# We can't easily get a list of streams and their associated colors (if any) in\n",
                "# a single query.  See zephyr.views.gather_subscriptions for an example.\n",
                "#\n",
                "# We should change things around so that is possible.  Probably this should\n",
                "# just be a column on Subscription.\n",
                "class StreamColor(models.Model):\n",
                "    DEFAULT_STREAM_COLOR = \"#c2c2c2\"\n",
                "\n",
                "    subscription = models.ForeignKey(Subscription)\n",
                "    color = models.CharField(max_length=10)"
            ]
        ],
        "zephyr/views.py": [
            [
                "from __future__ import absolute_import\n",
                "\n",
                "from django.conf import settings\n",
                "from django.contrib.auth import authenticate, login\n",
                "from django.contrib.auth.decorators import login_required\n",
                "from django.core.urlresolvers import reverse\n",
                "from django.http import HttpResponseRedirect\n",
                "from django.shortcuts import render_to_response, redirect\n",
                "from django.template import RequestContext, loader\n",
                "from django.utils.timezone import now\n",
                "from django.core.exceptions import ValidationError\n",
                "from django.core import validators\n",
                "from django.contrib.auth.views import login as django_login_page, \\\n",
                "    logout_then_login as django_logout_then_login\n",
                "from django.db.models import Q, F\n",
                "from django.core.mail import send_mail, mail_admins\n",
                "from django.db import transaction\n",
                "from zephyr.models import Message, UserProfile, Stream, Subscription, \\\n",
                "    Recipient, Realm, UserMessage, \\\n",
                "    PreregistrationUser, get_client, MitUser, UserActivity, \\\n",
                "    MAX_SUBJECT_LENGTH, get_stream, UserPresence, \\\n",
                "    get_recipient, valid_stream_name, to_dict_cache_key, to_dict_cache_key_id, \\\n",
                "    extract_message_dict, stringify_message_dict\n",
                "from zephyr.lib.actions import do_add_subscription, do_remove_subscription, \\\n",
                "    do_change_password, create_mit_user_if_needed, do_change_full_name, \\\n",
                "    do_change_enable_desktop_notifications, do_change_enter_sends, do_change_enable_sounds, \\\n",
                "    do_send_confirmation_email, do_activate_user, do_create_user, check_send_message, \\\n",
                "    log_subscription_property_change, internal_send_message, \\\n",
                "    create_stream_if_needed, gather_subscriptions, subscribed_to_stream, \\\n",
                "    update_user_presence, bulk_add_subscriptions, update_message_flags, \\\n",
                "    recipient_for_emails, extract_recipients, do_events_register, do_finish_tutorial, \\\n",
                "    get_status_dict, do_change_enable_offline_email_notifications, \\\n",
                "    do_update_onboarding_steps, do_update_message, internal_prep_message, \\\n",
                "    do_send_messages\n",
                "from zephyr.forms import RegistrationForm, HomepageForm, ToSForm, CreateBotForm, \\\n",
                "    is_unique, is_inactive, isnt_mit\n",
                "from django.views.decorators.csrf import csrf_exempt\n",
                "from django_openid_auth.views import default_render_failure, login_complete, parse_openid_response\n",
                "from openid.consumer.consumer import SUCCESS as openid_SUCCESS\n",
                "from openid.extensions import ax\n",
                "\n",
                "from zephyr.decorator import require_post, \\\n",
                "    authenticated_api_view, authenticated_json_post_view, \\\n",
                "    has_request_variables, authenticated_json_view, \\\n",
                "    to_non_negative_int, json_to_dict, json_to_list, json_to_bool, \\\n",
                "    JsonableError, RequestVariableMissingError, get_user_profile_by_email, \\\n",
                "    authenticated_rest_api_view, process_as_post, REQ, rate_limit, rate_limit_user\n",
                "from zephyr.lib.query import last_n\n",
                "from zephyr.lib.avatar import avatar_url\n",
                "from zephyr.lib.upload import upload_message_image, upload_avatar_image\n",
                "from zephyr.lib.response import json_success, json_error, json_response, json_method_not_allowed\n",
                "from zephyr.lib.timestamp import datetime_to_timestamp\n",
                "from zephyr.lib.cache import cache_with_key, cache_get_many, cache_set_many\n",
                "from zephyr.lib.unminify import SourceMap\n",
                "from zephyr.lib.queue import queue_json_publish\n",
                "from zephyr.lib.utils import statsd\n",
                "from zephyr import tornado_callbacks\n",
                "\n",
                "from confirmation.models import Confirmation\n",
                "\n",
                "\n",
                "import datetime\n",
                "import ujson\n",
                "import simplejson\n",
                "import re\n",
                "import urllib\n",
                "import os\n",
                "import base64\n",
                "import time\n",
                "import logging\n",
                "from os import path\n",
                "from functools import wraps\n",
                "from collections import defaultdict\n",
                "\n",
                "from defusedxml.ElementTree import fromstring as xml_fromstring\n",
                "\n",
                "def list_to_streams(streams_raw, user_profile, autocreate=False, invite_only=False):\n",
                "    \"\"\"Converts plaintext stream names to a list of Streams, validating input in the process\n",
                "\n",
                "    For each stream name, we validate it to ensure it meets our requirements for a proper\n",
                "    stream name: that is, that it is shorter than 30 characters and passes valid_stream_name.\n",
                "\n",
                "    We also ensure the stream is visible to the user_profile who made the request; a call\n",
                "    to list_to_streams will fail if one of the streams is invite_only and user_profile\n",
                "    is not already on the stream.\n",
                "\n",
                "    This function in autocreate mode should be atomic: either an exception will be raised\n",
                "    during a precheck, or all the streams specified will have been created if applicable.\n",
                "\n",
                "    @param streams_raw The list of stream names to process\n",
                "    @param user_profile The user for whom we are retreiving the streams\n",
                "    @param autocreate Whether we should create streams if they don't already exist\n",
                "    @param invite_only Whether newly created streams should have the invite_only bit set\n",
                "    \"\"\"\n",
                "    streams = []\n",
                "    # Validate all streams, getting extant ones, then get-or-creating the rest.\n",
                "    stream_set = set(stream_name.strip() for stream_name in streams_raw)\n",
                "    rejects = []\n",
                "    for stream_name in stream_set:\n",
                "        if len(stream_name) > Stream.MAX_NAME_LENGTH:\n",
                "            raise JsonableError(\"Stream name (%s) too long.\" % (stream_name,))\n",
                "        if not valid_stream_name(stream_name):\n",
                "            raise JsonableError(\"Invalid stream name (%s).\" % (stream_name,))\n",
                "        stream = get_stream(stream_name, user_profile.realm)\n",
                "\n",
                "        if stream is None:\n",
                "            rejects.append(stream_name)\n",
                "        else:\n",
                "            streams.append(stream)\n",
                "            # Verify we can access the stream\n",
                "            if stream.invite_only and not subscribed_to_stream(user_profile, stream):\n",
                "                raise JsonableError(\"Unable to access invite-only stream (%s).\" % stream.name)\n",
                "    if autocreate:\n",
                "        for stream_name in rejects:\n",
                "            stream, created = create_stream_if_needed(user_profile.realm,\n",
                "                                                 stream_name,\n",
                "                                                 invite_only=invite_only)\n",
                "            streams.append(stream)\n",
                "    elif rejects:\n",
                "        raise JsonableError(\"Stream(s) (%s) do not exist\" % \", \".join(rejects))\n",
                "\n",
                "    return streams\n",
                "\n",
                "def send_signup_message(sender, signups_stream, user_profile, internal=False):\n",
                "    if internal:\n",
                "        # When this is done using manage.py vs. the web interface\n",
                "        internal_blurb = \" **INTERNAL SIGNUP** \"\n",
                "    else:\n",
                "        internal_blurb = \" \"\n",
                "\n",
                "    internal_send_message(sender,\n",
                "            \"stream\", signups_stream, user_profile.realm.domain,\n",
                "            \"%s <`%s`> just signed up for Humbug!%s(total: **%i**)\" % (\n",
                "                user_profile.full_name,\n",
                "                user_profile.email,\n",
                "                internal_blurb,\n",
                "                UserProfile.objects.filter(realm=user_profile.realm,\n",
                "                                           is_active=True).count(),\n",
                "                )\n",
                "            )\n",
                "\n",
                "def notify_new_user(user_profile, internal=False):\n",
                "    send_signup_message(\"humbug+signups@humbughq.com\", \"signups\", user_profile, internal)\n",
                "    statsd.gauge(\"users.signups.%s\" % (user_profile.realm.domain.replace('.', '_')), 1, delta=True)\n",
                "\n",
                "class PrincipalError(JsonableError):\n",
                "    def __init__(self, principal):\n",
                "        self.principal = principal\n",
                "\n",
                "    def to_json_error_msg(self):\n",
                "        return (\"User not authorized to execute queries on behalf of '%s'\"\n",
                "                % (self.principal,))\n",
                "\n",
                "def principal_to_user_profile(agent, principal):\n",
                "    principal_doesnt_exist = False\n",
                "    try:\n",
                "        principal_user_profile = get_user_profile_by_email(principal)\n",
                "    except UserProfile.DoesNotExist:\n",
                "        principal_doesnt_exist = True\n",
                "\n",
                "    if (principal_doesnt_exist\n",
                "        or agent.realm.domain == 'mit.edu'\n",
                "        or agent.realm != principal_user_profile.realm):\n",
                "        # We have to make sure we don't leak information about which users\n",
                "        # are registered for Humbug in a different realm.  We could do\n",
                "        # something a little more clever and check the domain part of the\n",
                "        # principal to maybe give a better error message\n",
                "        raise PrincipalError(principal)\n",
                "\n",
                "    return principal_user_profile\n",
                "\n",
                "METHODS = ('GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'PATCH')\n",
                "\n",
                "@csrf_exempt\n",
                "def rest_dispatch(request, **kwargs):\n",
                "    supported_methods = {}\n",
                "    # duplicate kwargs so we can mutate the original as we go\n",
                "    for arg in list(kwargs):\n",
                "        if arg in METHODS:\n",
                "            supported_methods[arg] = kwargs[arg]\n",
                "            del kwargs[arg]\n",
                "    if request.method in supported_methods.keys():\n",
                "        target_function = globals()[supported_methods[request.method]]\n",
                "        target_function = authenticated_rest_api_view(target_function)\n",
                "        if request.method not in [\"GET\", \"POST\"]:\n",
                "            # process_as_post needs to be the outer decorator, because\n",
                "            # otherwise we might access and thus cache a value for\n",
                "            # request.REQUEST.\n",
                "            target_function = process_as_post(target_function)\n",
                "        return target_function(request, **kwargs)\n",
                "    return json_method_not_allowed(supported_methods.keys())\n",
                "\n",
                "@require_post\n",
                "@has_request_variables\n",
                "def beta_signup_submission(request, name=REQ, email=REQ,\n",
                "                           company=REQ, count=REQ, product=REQ):\n",
                "    content = \"\"\"Name: %s\n",
                "Email: %s\n",
                "Company: %s\n",
                "# users: %s\n",
                "Currently using: %s\"\"\" % (name, email, company, count, product,)\n",
                "    subject = \"Interest in Humbug: %s\" % company\n",
                "    from_email = '\"%s\" via Web <humbug+signups@humbughq.com>' % (name,)\n",
                "    to_email = '\"Humbug Signups\" <humbug+signups@humbughq.com>'\n",
                "    send_mail(subject, content, from_email, [to_email])\n",
                "    return json_success()\n",
                "\n",
                "@require_post\n",
                "def accounts_register(request):\n",
                "    key = request.POST['key']\n",
                "    confirmation = Confirmation.objects.get(confirmation_key=key)\n",
                "    prereg_user = confirmation.content_object\n",
                "    email = prereg_user.email\n",
                "    mit_beta_user = isinstance(confirmation.content_object, MitUser)\n",
                "\n",
                "    # If someone invited you, you are joining their realm regardless\n",
                "    # of your e-mail address.\n",
                "    #\n",
                "    # MitUsers can't be referred and don't have a referred_by field.\n",
                "    if not mit_beta_user and prereg_user.referred_by:\n",
                "        domain = prereg_user.referred_by.realm.domain\n",
                "    else:\n",
                "        domain = email.split('@')[-1]\n",
                "\n",
                "    try:\n",
                "        if mit_beta_user:\n",
                "            # MIT users already exist, but are supposed to be inactive.\n",
                "            is_inactive(email)\n",
                "        else:\n",
                "            # Other users should not already exist at all.\n",
                "            is_unique(email)\n",
                "    except ValidationError:\n",
                "        return HttpResponseRedirect(reverse('django.contrib.auth.views.login') + '?email=' + urllib.quote_plus(email))\n",
                "\n",
                "    if request.POST.get('from_confirmation'):\n",
                "        form = RegistrationForm()\n",
                "    else:\n",
                "        form = RegistrationForm(request.POST)\n",
                "        if form.is_valid():\n",
                "            password   = form.cleaned_data['password']\n",
                "            full_name  = form.cleaned_data['full_name']\n",
                "            short_name = email.split('@')[0]\n",
                "            (realm, _) = Realm.objects.get_or_create(domain=domain)\n",
                "\n",
                "            # FIXME: sanitize email addresses and fullname\n",
                "            if mit_beta_user:\n",
                "                user_profile = get_user_profile_by_email(email)\n",
                "                do_activate_user(user_profile)\n",
                "                do_change_password(user_profile, password)\n",
                "                do_change_full_name(user_profile, full_name)\n",
                "            else:\n",
                "                user_profile = do_create_user(email, password, realm, full_name, short_name)\n",
                "                if prereg_user.referred_by is not None:\n",
                "                    # This is a cross-realm private message.\n",
                "                    internal_send_message(\"humbug+signups@humbughq.com\",\n",
                "                            \"private\", prereg_user.referred_by.email, user_profile.realm.domain,\n",
                "                            \"%s <`%s`> accepted your invitation to join Humbug!\" % (\n",
                "                                user_profile.full_name,\n",
                "                                user_profile.email,\n",
                "                                )\n",
                "                            )\n",
                "            # Mark any other PreregistrationUsers that are STATUS_ACTIVE as inactive\n",
                "            # so we can find the PreregistrationUser that we are actually working\n",
                "            # with here\n",
                "            PreregistrationUser.objects.filter(email=email)             \\\n",
                "                                       .exclude(id=prereg_user.id)      \\\n",
                "                                       .update(status=0)\n",
                "\n",
                "            notify_new_user(user_profile)\n",
                "            queue_json_publish(\n",
                "                    \"signups\",\n",
                "                    {\n",
                "                        'EMAIL': email,\n",
                "                        'merge_vars': {\n",
                "                            'NAME': full_name,\n",
                "                            'REALM': domain,\n",
                "                            'OPTIN_IP': request.META['REMOTE_ADDR'],\n",
                "                            'OPTIN_TIME': datetime.datetime.isoformat(datetime.datetime.now()),\n",
                "                        },\n",
                "                    },\n",
                "                    lambda event: None)\n",
                "\n",
                "            login(request, authenticate(username=email, password=password))\n",
                "            return HttpResponseRedirect(reverse('zephyr.views.home'))\n",
                "\n",
                "    return render_to_response('zephyr/register.html',\n",
                "            {'form': form,\n",
                "             'company_name': domain,\n",
                "             'email': email,\n",
                "             'key': key,\n",
                "             'gafyd_name': request.POST.get('gafyd_name', False),\n",
                "            },\n",
                "        context_instance=RequestContext(request))\n",
                "\n",
                "@login_required(login_url = settings.HOME_NOT_LOGGED_IN)\n",
                "def accounts_accept_terms(request):\n",
                "    email = request.user.email\n",
                "    company_name = email.split('@')[-1]\n",
                "    if request.method == \"POST\":\n",
                "        form = ToSForm(request.POST)\n",
                "        if form.is_valid():\n",
                "            full_name = form.cleaned_data['full_name']\n",
                "            send_mail('Terms acceptance for ' + full_name,\n",
                "                    loader.render_to_string('zephyr/tos_accept_body.txt',\n",
                "                        {'name': full_name,\n",
                "                         'email': email,\n",
                "                         'ip': request.META['REMOTE_ADDR'],\n",
                "                         'browser': request.META['HTTP_USER_AGENT']}),\n",
                "                        \"humbug@humbughq.com\",\n",
                "                        [\"all@humbughq.com\"])\n",
                "            do_change_full_name(request.user, full_name)\n",
                "            return redirect(home)\n",
                "\n",
                "    else:\n",
                "        form = ToSForm()\n",
                "    return render_to_response('zephyr/accounts_accept_terms.html',\n",
                "        { 'form': form, 'company_name': company_name, 'email': email },\n",
                "        context_instance=RequestContext(request))\n",
                "\n",
                "def api_endpoint_docs(request):\n",
                "    raw_calls = open('templates/zephyr/api_content.json', 'r').read()\n",
                "    calls = ujson.loads(raw_calls)\n",
                "    langs = set()\n",
                "    for call in calls:\n",
                "        for example_type in ('request', 'response'):\n",
                "            for lang in call.get('example_' + example_type, []):\n",
                "                langs.add(lang)\n",
                "    return render_to_response(\n",
                "            'zephyr/api_endpoints.html', {\n",
                "                'content': calls,\n",
                "                'langs': langs,\n",
                "                },\n",
                "        context_instance=RequestContext(request))\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_invite_users(request, user_profile, invitee_emails=REQ):\n",
                "    # Validation\n",
                "    if settings.ALLOW_REGISTER == False:\n",
                "        try:\n",
                "            isnt_mit(user_profile.email)\n",
                "        except ValidationError:\n",
                "            return json_error(\"Invitations are not enabled for MIT at this time.\")\n",
                "\n",
                "    if not invitee_emails:\n",
                "        return json_error(\"You must specify at least one email address.\")\n",
                "\n",
                "    invitee_emails = set(re.split(r'[, \\n]', invitee_emails))\n",
                "\n",
                "    stream_names = request.POST.getlist('stream')\n",
                "    if not stream_names:\n",
                "        return json_error(\"You must specify at least one stream for invitees to join.\")\n",
                "\n",
                "    streams = []\n",
                "    for stream_name in stream_names:\n",
                "        stream = get_stream(stream_name, user_profile.realm)\n",
                "        if stream is None:\n",
                "            return json_error(\"Stream does not exist: %s. No invites were sent.\" % stream_name)\n",
                "        streams.append(stream)\n",
                "\n",
                "    new_prereg_users = []\n",
                "    errors = []\n",
                "    skipped = []\n",
                "    for email in invitee_emails:\n",
                "        if email == '':\n",
                "            continue\n",
                "\n",
                "        if not validators.email_re.match(email):\n",
                "            errors.append((email, \"Invalid address.\"))\n",
                "            continue\n",
                "\n",
                "        if user_profile.realm.restricted_to_domain and \\\n",
                "                email.split('@', 1)[-1].lower() != user_profile.realm.domain.lower():\n",
                "            errors.append((email, \"Outside your domain.\"))\n",
                "            continue\n",
                "\n",
                "        # Redundant check in case earlier validation preventing MIT users from\n",
                "        # inviting people fails.\n",
                "        if settings.ALLOW_REGISTER == False:\n",
                "            try:\n",
                "                isnt_mit(email)\n",
                "            except ValidationError:\n",
                "                errors.append((email, \"Invitations are not enabled for MIT at this time.\"))\n",
                "                continue\n",
                "\n",
                "        try:\n",
                "            is_unique(email)\n",
                "        except ValidationError:\n",
                "            skipped.append((email, \"Already has an account.\"))\n",
                "            continue\n",
                "\n",
                "        # The logged in user is the referrer.\n",
                "        prereg_user = PreregistrationUser(email=email, referred_by=user_profile)\n",
                "\n",
                "        # We save twice because you cannot associate a ManyToMany field\n",
                "        # on an unsaved object.\n",
                "        prereg_user.save()\n",
                "        prereg_user.streams = streams\n",
                "        prereg_user.save()\n",
                "\n",
                "        new_prereg_users.append(prereg_user)\n",
                "\n",
                "    if errors:\n",
                "        return json_error(data={'errors': errors},\n",
                "                          msg=\"Some emails did not validate, so we didn't send any invitations.\")\n",
                "\n",
                "    if skipped and len(skipped) == len(invitee_emails):\n",
                "        # All e-mails were skipped, so we didn't actually invite anyone.\n",
                "        return json_error(data={'errors': skipped},\n",
                "                          msg=\"We weren't able to invite anyone.\")\n",
                "\n",
                "    # If we encounter an exception at any point before now, there are no unwanted side-effects,\n",
                "    # since it is totally fine to have duplicate PreregistrationUsers\n",
                "    for user in new_prereg_users:\n",
                "        event = {\"email\": user.email, \"referrer_email\": user_profile.email}\n",
                "        queue_json_publish(\"invites\", event,\n",
                "                           lambda event: do_send_confirmation_email(user, user_profile))\n",
                "\n",
                "    if skipped:\n",
                "        return json_error(data={'errors': skipped},\n",
                "                          msg=\"Some of those addresses are already using Humbug, \\\n",
                "so we didn't send them an invitation. We did send invitations to everyone else!\")\n",
                "    else:\n",
                "        return json_success()\n",
                "\n",
                "def handle_openid_errors(request, issue, openid_response=None):\n",
                "    if issue == \"Unknown user\":\n",
                "        if openid_response is not None and openid_response.status == openid_SUCCESS:\n",
                "            ax_response = ax.FetchResponse.fromSuccessResponse(openid_response)\n",
                "            google_email = openid_response.getSigned('http://openid.net/srv/ax/1.0', 'value.email')\n",
                "            full_name = \" \".join((\n",
                "                    ax_response.get('http://axschema.org/namePerson/first')[0],\n",
                "                    ax_response.get('http://axschema.org/namePerson/last')[0]))\n",
                "            form = HomepageForm({'email': google_email})\n",
                "            request.verified_email = None\n",
                "            if form.is_valid():\n",
                "                # Construct a PreregistrationUser object and send the user over to\n",
                "                # the confirmation view.\n",
                "                prereg_user = PreregistrationUser()\n",
                "                prereg_user.email = google_email\n",
                "                prereg_user.save()\n",
                "                return redirect(\"\".join((\n",
                "                    \"/\",\n",
                "                    # Split this so we only get the part after the /\n",
                "                    Confirmation.objects.get_link_for_object(prereg_user).split(\"/\", 3)[3],\n",
                "                    '?gafyd_name=',\n",
                "                    urllib.quote_plus(full_name))))\n",
                "            else:\n",
                "                return render_to_response('zephyr/accounts_home.html', {'form': form})\n",
                "    return default_render_failure(request, issue)\n",
                "\n",
                "def process_openid_login(request):\n",
                "    return login_complete(request, render_failure=handle_openid_errors)\n",
                "\n",
                "def login_page(request, **kwargs):\n",
                "    template_response = django_login_page(request, **kwargs)\n",
                "    try:\n",
                "        template_response.context_data['email'] = request.GET['email']\n",
                "    except KeyError:\n",
                "        pass\n",
                "    return template_response\n",
                "\n",
                "@require_post\n",
                "def logout_then_login(request, **kwargs):\n",
                "    return django_logout_then_login(request, kwargs)\n",
                "\n",
                "def accounts_home(request):\n",
                "    if request.method == 'POST':\n",
                "        form = HomepageForm(request.POST)\n",
                "        if form.is_valid():\n",
                "            email = form.cleaned_data['email']\n",
                "            prereg_user = PreregistrationUser()\n",
                "            prereg_user.email = email\n",
                "            prereg_user.save()\n",
                "            Confirmation.objects.send_confirmation(prereg_user, email)\n",
                "            return HttpResponseRedirect(reverse('send_confirm', kwargs={'email': email}))\n",
                "        try:\n",
                "            email = request.POST['email']\n",
                "            # Note: We don't check for uniqueness\n",
                "            is_inactive(email)\n",
                "        except ValidationError:\n",
                "            return HttpResponseRedirect(reverse('django.contrib.auth.views.login') + '?email=' + urllib.quote_plus(email))\n",
                "    else:\n",
                "        form = HomepageForm()\n",
                "    return render_to_response('zephyr/accounts_home.html', {'form': form},\n",
                "                              context_instance=RequestContext(request))\n",
                "\n",
                "@login_required(login_url = settings.HOME_NOT_LOGGED_IN)\n",
                "def home(request):\n",
                "    # We need to modify the session object every two weeks or it will expire.\n",
                "    # This line makes reloading the page a sufficient action to keep the\n",
                "    # session alive.\n",
                "    request.session.modified = True\n",
                "\n",
                "    user_profile = request.user\n",
                "\n",
                "    register_ret = do_events_register(user_profile, get_client(\"website\"),\n",
                "                                      apply_markdown=True)\n",
                "    user_has_messages = (register_ret['max_message_id'] != -1)\n",
                "\n",
                "    # Reset our don't-spam-users-with-email counter since the\n",
                "    # user has since logged in\n",
                "    if not user_profile.last_reminder is None:\n",
                "        user_profile.last_reminder = None\n",
                "        user_profile.save()\n",
                "\n",
                "    # Brand new users get the tutorial\n",
                "    needs_tutorial = settings.TUTORIAL_ENABLED and \\\n",
                "        user_profile.tutorial_status == UserProfile.TUTORIAL_WAITING\n",
                "\n",
                "    # If the user has previously started (but not completed) the tutorial,\n",
                "    # finish it for her and subscribe her to the default streams\n",
                "    if user_profile.tutorial_status == UserProfile.TUTORIAL_STARTED:\n",
                "        tutorial_stream = user_profile.tutorial_stream_name()\n",
                "        try:\n",
                "            stream = Stream.objects.get(realm=user_profile.realm, name=tutorial_stream)\n",
                "            do_remove_subscription(user_profile, stream)\n",
                "        except Stream.DoesNotExist:\n",
                "            pass\n",
                "\n",
                "        do_finish_tutorial(user_profile)\n",
                "\n",
                "    if user_profile.pointer == -1 and user_has_messages:\n",
                "        # Put the new user's pointer at the bottom\n",
                "        #\n",
                "        # This improves performance, because we limit backfilling of messages\n",
                "        # before the pointer.  It's also likely that someone joining an\n",
                "        # organization is interested in recent messages more than the very\n",
                "        # first messages on the system.\n",
                "\n",
                "        user_profile.pointer = register_ret['max_message_id']\n",
                "        user_profile.last_pointer_updater = request.session.session_key\n",
                "\n",
                "    # Pass parameters to the client-side JavaScript code.\n",
                "    # These end up in a global JavaScript Object named 'page_params'.\n",
                "    page_params = simplejson.encoder.JSONEncoderForHTML().encode(dict(\n",
                "        debug_mode            = settings.DEBUG,\n",
                "        poll_timeout          = settings.POLL_TIMEOUT,\n",
                "        have_initial_messages = user_has_messages,\n",
                "        stream_list           = register_ret['subscriptions'],\n",
                "        unsubbed_info         = register_ret['unsubscribed'],\n",
                "        people_list           = register_ret['realm_users'],\n",
                "        initial_pointer       = register_ret['pointer'],\n",
                "        initial_presences     = register_ret['presences'],\n",
                "        initial_servertime    = time.time(), # Used for calculating relative presence age\n",
                "        fullname              = user_profile.full_name,\n",
                "        email                 = user_profile.email,\n",
                "        domain                = user_profile.realm.domain,\n",
                "        enter_sends           = user_profile.enter_sends,\n",
                "        needs_tutorial        = needs_tutorial,\n",
                "        desktop_notifications_enabled =\n",
                "            user_profile.enable_desktop_notifications,\n",
                "        sounds_enabled =\n",
                "            user_profile.enable_sounds,\n",
                "        enable_offline_email_notifications =\n",
                "            user_profile.enable_offline_email_notifications,\n",
                "        event_queue_id        = register_ret['queue_id'],\n",
                "        last_event_id         = register_ret['last_event_id'],\n",
                "        max_message_id        = register_ret['max_message_id'],\n",
                "        onboarding_steps      = ujson.loads(user_profile.onboarding_steps),\n",
                "        staging               = settings.STAGING_DEPLOYED or settings.DEBUG\n",
                "    ))\n",
                "\n",
                "    statsd.incr('views.home')\n",
                "\n",
                "    try:\n",
                "        isnt_mit(user_profile.email)\n",
                "        show_invites = True\n",
                "    except ValidationError:\n",
                "        show_invites = settings.ALLOW_REGISTER\n",
                "\n",
                "    # For the CUSTOMER4 student realm, only let instructors (who have\n",
                "    # @customer4.invalid addresses) invite new users.\n",
                "    if ((user_profile.realm.domain == \"users.customer4.invalid\") and\n",
                "        (not user_profile.email.lower().endswith(\"@customer4.invalid\"))):\n",
                "        show_invites = False\n",
                "\n",
                "    return render_to_response('zephyr/index.html',\n",
                "                              {'user_profile': user_profile,\n",
                "                               'page_params' : page_params,\n",
                "                               'avatar_url': avatar_url(user_profile),\n",
                "                               'show_debug':\n",
                "                                   settings.DEBUG and ('show_debug' in request.GET),\n",
                "                               'show_invites': show_invites\n",
                "                               },\n",
                "                              context_instance=RequestContext(request))\n",
                "\n",
                "def get_pointer_backend(request, user_profile):\n",
                "    return json_success({'pointer': user_profile.pointer})\n",
                "\n",
                "@authenticated_api_view\n",
                "def api_update_pointer(request, user_profile):\n",
                "    return update_pointer_backend(request, user_profile)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_update_pointer(request, user_profile):\n",
                "    return update_pointer_backend(request, user_profile)\n",
                "\n",
                "@has_request_variables\n",
                "def update_pointer_backend(request, user_profile,\n",
                "                           pointer=REQ(converter=to_non_negative_int)):\n",
                "    if pointer <= user_profile.pointer:\n",
                "        return json_success()\n",
                "\n",
                "    prev_pointer = user_profile.pointer\n",
                "    user_profile.pointer = pointer\n",
                "    user_profile.save(update_fields=[\"pointer\"])\n",
                "\n",
                "    if request.client.name.lower() in ['android', 'iphone']:\n",
                "        # TODO (leo)\n",
                "        # Until we handle the new read counts in the mobile apps natively,\n",
                "        # this is a shim that will mark as read any messages up until the\n",
                "        # pointer move\n",
                "        UserMessage.objects.filter(user_profile=user_profile,\n",
                "                                   message__id__gt=prev_pointer,\n",
                "                                   message__id__lte=pointer,\n",
                "                                   flags=~UserMessage.flags.read)        \\\n",
                "                           .update(flags=F('flags').bitor(UserMessage.flags.read))\n",
                "\n",
                "    if settings.TORNADO_SERVER:\n",
                "        tornado_callbacks.send_notification(dict(\n",
                "            type            = 'pointer_update',\n",
                "            user            = user_profile.id,\n",
                "            new_pointer     = pointer))\n",
                "\n",
                "    return json_success()\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_get_old_messages(request, user_profile):\n",
                "    return get_old_messages_backend(request, user_profile,\n",
                "                                    apply_markdown=True)\n",
                "\n",
                "@authenticated_api_view\n",
                "@has_request_variables\n",
                "def api_get_old_messages(request, user_profile,\n",
                "                         apply_markdown=REQ(default=False,\n",
                "                                            converter=ujson.loads)):\n",
                "    return get_old_messages_backend(request, user_profile,\n",
                "                                    apply_markdown=apply_markdown)\n",
                "\n",
                "class BadNarrowOperator(Exception):\n",
                "    def __init__(self, desc):\n",
                "        self.desc = desc\n",
                "\n",
                "    def to_json_error_msg(self):\n",
                "        return 'Invalid narrow operator: ' + self.desc\n",
                "\n",
                "class NarrowBuilder(object):\n",
                "    def __init__(self, user_profile, prefix):\n",
                "        self.user_profile = user_profile\n",
                "        self.prefix = prefix\n",
                "\n",
                "    def __call__(self, query, operator, operand):\n",
                "        # We have to be careful here because we're letting users call a method\n",
                "        # by name! The prefix 'by_' prevents it from colliding with builtin\n",
                "        # Python __magic__ stuff.\n",
                "        method_name = 'by_' + operator.replace('-', '_')\n",
                "        if method_name == 'by_search':\n",
                "            return self.do_search(query, operand)\n",
                "        method = getattr(self, method_name, None)\n",
                "        if method is None:\n",
                "            raise BadNarrowOperator('unknown operator ' + operator)\n",
                "        return query.filter(method(operand))\n",
                "\n",
                "    # Wrapper for Q() which adds self.prefix to all the keys\n",
                "    def pQ(self, **kwargs):\n",
                "        return Q(**dict((self.prefix + key, kwargs[key]) for key in kwargs.keys()))\n",
                "\n",
                "    def by_is(self, operand):\n",
                "        if operand == 'private-message':\n",
                "            return (self.pQ(recipient__type=Recipient.PERSONAL) |\n",
                "                    self.pQ(recipient__type=Recipient.HUDDLE))\n",
                "        elif operand == 'starred':\n",
                "            return Q(flags=UserMessage.flags.starred)\n",
                "        elif operand == 'mentioned':\n",
                "            return Q(flags=UserMessage.flags.mentioned)\n",
                "        raise BadNarrowOperator(\"unknown 'is' operand \" + operand)\n",
                "\n",
                "    def by_stream(self, operand):\n",
                "        stream = get_stream(operand, self.user_profile.realm)\n",
                "        if stream is None:\n",
                "            raise BadNarrowOperator('unknown stream ' + operand)\n",
                "        recipient = get_recipient(Recipient.STREAM, type_id=stream.id)\n",
                "        return self.pQ(recipient=recipient)\n",
                "\n",
                "    def by_subject(self, operand):\n",
                "        return self.pQ(subject__iexact=operand)\n",
                "\n",
                "    def by_sender(self, operand):\n",
                "        return self.pQ(sender__email__iexact=operand)\n",
                "\n",
                "    def by_pm_with(self, operand):\n",
                "        if ',' in operand:\n",
                "            # Huddle\n",
                "            try:\n",
                "                emails = [e.strip() for e in operand.split(',')]\n",
                "                recipient = recipient_for_emails(emails, False,\n",
                "                    self.user_profile, self.user_profile)\n",
                "            except ValidationError:\n",
                "                raise BadNarrowOperator('unknown recipient ' + operand)\n",
                "            return self.pQ(recipient=recipient)\n",
                "        else:\n",
                "            # Personal message\n",
                "            self_recipient = get_recipient(Recipient.PERSONAL, type_id=self.user_profile.id)\n",
                "            if operand == self.user_profile.email:\n",
                "                # Personals with self\n",
                "                return self.pQ(recipient__type=Recipient.PERSONAL,\n",
                "                          sender=self.user_profile, recipient=self_recipient)\n",
                "\n",
                "            # Personals with other user; include both directions.\n",
                "            try:\n",
                "                narrow_profile = get_user_profile_by_email(operand)\n",
                "            except UserProfile.DoesNotExist:\n",
                "                raise BadNarrowOperator('unknown user ' + operand)\n",
                "\n",
                "            narrow_recipient = get_recipient(Recipient.PERSONAL, narrow_profile.id)\n",
                "            return ((self.pQ(sender=narrow_profile) & self.pQ(recipient=self_recipient)) |\n",
                "                    (self.pQ(sender=self.user_profile) & self.pQ(recipient=narrow_recipient)))\n",
                "\n",
                "    def do_search(self, query, operand):\n",
                "        if \"postgres\" in settings.DATABASES[\"default\"][\"ENGINE\"]:\n",
                "            tsquery = \"plainto_tsquery('humbug.english_us_search', %s)\"\n",
                "            where = \"search_tsvector @@ \" + tsquery\n",
                "            match_content = \"ts_headline('humbug.english_us_search', rendered_content, \" \\\n",
                "                + tsquery + \", 'StartSel=\\\"<span class=\\\"\\\"highlight\\\"\\\">\\\", StopSel=</span>, \" \\\n",
                "                \"HighlightAll=TRUE')\"\n",
                "            # We HTML-escape the subject in Postgres to avoid doing a server round-trip\n",
                "            match_subject = \"ts_headline('humbug.english_us_search', escape_html(subject), \" \\\n",
                "                + tsquery + \", 'StartSel=\\\"<span class=\\\"\\\"highlight\\\"\\\">\\\", StopSel=</span>, \" \\\n",
                "                \"HighlightAll=TRUE')\"\n",
                "\n",
                "            # Do quoted string matching.  We really want phrase\n",
                "            # search here so we can ignore punctuation and do\n",
                "            # stemming, but there isn't a standard phrase search\n",
                "            # mechanism in Postgres\n",
                "            for term in re.findall('\"[^\"]+\"|\\S+', operand):\n",
                "                if term[0] == '\"' and term[-1] == '\"':\n",
                "                    term = term[1:-1]\n",
                "                    query = query.filter(self.pQ(content__icontains=term) |\n",
                "                                         self.pQ(subject__icontains=term))\n",
                "\n",
                "            return query.extra(select={'match_content': match_content,\n",
                "                                       'match_subject': match_subject},\n",
                "                               where=[where],\n",
                "                               select_params=[operand, operand], params=[operand])\n",
                "        else:\n",
                "            for word in operand.split():\n",
                "                query = query.filter(self.pQ(content__icontains=word) |\n",
                "                                     self.pQ(subject__icontains=word))\n",
                "            return query\n",
                "\n",
                "\n",
                "def narrow_parameter(json):\n",
                "    # FIXME: A hack to support old mobile clients\n",
                "    if json == '{}':\n",
                "        return None\n",
                "\n",
                "    data = json_to_list(json)\n",
                "    for elem in data:\n",
                "        if not isinstance(elem, list):\n",
                "            raise ValueError(\"element is not a list\")\n",
                "        if (len(elem) != 2\n",
                "            or any(not isinstance(x, str) and not isinstance(x, unicode)\n",
                "                   for x in elem)):\n",
                "            raise ValueError(\"element is not a string pair\")\n",
                "    return data\n",
                "\n",
                "def is_public_stream(request, stream, realm):\n",
                "    if not valid_stream_name(stream):\n",
                "        raise JsonableError(\"Invalid stream name\")\n",
                "    stream = get_stream(stream, realm)\n",
                "    if stream is None:\n",
                "        return False\n",
                "    return stream.is_public()\n",
                "\n",
                "@has_request_variables\n",
                "def get_old_messages_backend(request, user_profile,\n",
                "                             anchor = REQ(converter=int),\n",
                "                             num_before = REQ(converter=to_non_negative_int),\n",
                "                             num_after = REQ(converter=to_non_negative_int),\n",
                "                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n",
                "                             apply_markdown=True):\n",
                "    include_history = False\n",
                "    if narrow is not None:\n",
                "        for operator, operand in narrow:\n",
                "            if operator == \"stream\":\n",
                "                if is_public_stream(request, operand, user_profile.realm):\n",
                "                    include_history = True\n",
                "        # Disable historical messages if the user is narrowing to show\n",
                "        # only starred messages (or anything else that's a property on\n",
                "        # the UserMessage table).  There cannot be historical messages\n",
                "        # in these cases anyway.\n",
                "        for operator, operand in narrow:\n",
                "            if operator == \"is\" and operand == \"starred\":\n",
                "                include_history = False\n",
                "\n",
                "    if include_history:\n",
                "        prefix = \"\"\n",
                "        query = Message.objects.only(\"id\").order_by('id')\n",
                "    else:\n",
                "        prefix = \"message__\"\n",
                "        # Conceptually this query should be\n",
                "        #   UserMessage.objects.filter(user_profile=user_profile).order_by('message')\n",
                "        #\n",
                "        # However, our do_search code above requires that there be a\n",
                "        # unique 'rendered_content' row in the query, so we need to\n",
                "        # somehow get the 'message' table into the query without\n",
                "        # actually fetching all the rows from the message table (since\n",
                "        # doing so would cause Django to consume a lot of resources\n",
                "        # rendering them).  The following achieves these objectives.\n",
                "        query = UserMessage.objects.select_related(\"message\").only(\"flags\", \"id\", \"message__id\") \\\n",
                "            .filter(user_profile=user_profile).order_by('message')\n",
                "\n",
                "    num_extra_messages = 1\n",
                "    is_search = False\n",
                "\n",
                "    if narrow is not None:\n",
                "        num_extra_messages = 0\n",
                "        build = NarrowBuilder(user_profile, prefix)\n",
                "        for operator, operand in narrow:\n",
                "            if operator == 'search':\n",
                "                is_search = True\n",
                "            query = build(query, operator, operand)\n",
                "\n",
                "    def add_prefix(**kwargs):\n",
                "        return dict((prefix + key, kwargs[key]) for key in kwargs.keys())\n",
                "\n",
                "    # We add 1 to the number of messages requested if no narrow was\n",
                "    # specified to ensure that the resulting list always contains the\n",
                "    # anchor message.  If a narrow was specified, the anchor message\n",
                "    # might not match the narrow anyway.\n",
                "    if num_after != 0:\n",
                "        num_after += num_extra_messages\n",
                "    else:\n",
                "        num_before += num_extra_messages\n",
                "\n",
                "    before_result = []\n",
                "    after_result = []\n",
                "    if num_before != 0:\n",
                "        before_anchor = anchor\n",
                "        if num_after != 0:\n",
                "            # Don't include the anchor in both the before query and the after query\n",
                "            before_anchor = anchor - 1\n",
                "        before_result = last_n(num_before, query.filter(**add_prefix(id__lte=before_anchor)))\n",
                "    if num_after != 0:\n",
                "        after_result = query.filter(**add_prefix(id__gte=anchor))[:num_after]\n",
                "    query_result = list(before_result) + list(after_result)\n",
                "\n",
                "    # The following is a little messy, but ensures that the code paths\n",
                "    # are similar regardless of the value of include_history.  The\n",
                "    # 'user_messages' dictionary maps each message to the user's\n",
                "    # UserMessage object for that message, which we will attach to the\n",
                "    # rendered message dict before returning it.  We attempt to\n",
                "    # bulk-fetch rendered message dicts from memcached using the\n",
                "    # 'messages' list.\n",
                "    search_fields = dict()\n",
                "    message_ids = []\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    user_message_flags = {}\n"
                ],
                "parent_version_range": {
                    "start": 857,
                    "end": 857
                },
                "child_version_range": {
                    "start": 857,
                    "end": 858
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_old_messages_backend",
                        "signature": "def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):",
                        "at_line": 776
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: zephyr/views.py\nCode:\n           def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):\n               ...\n854 854        # 'messages' list.\n855 855        search_fields = dict()\n856 856        message_ids = []\n    857  +     user_message_flags = {}\n857 858        if include_history:\n         ...\n",
                "file_path": "zephyr/views.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "user_message_flags"
                ],
                "prefix": [
                    "    # 'messages' list.\n",
                    "    search_fields = dict()\n",
                    "    message_ids = []\n"
                ],
                "suffix": [
                    "    if include_history:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    if include_history:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        user_messages = dict((user_message.message_id, user_message) for user_message in\n",
                    "                             UserMessage.objects.filter(user_profile=user_profile,\n",
                    "                                                        message__in=query_result))\n"
                ],
                "after": [
                    "        user_message_flags = dict((user_message.message_id, user_message.flags_list()) for user_message in\n",
                    "                                  UserMessage.objects.filter(user_profile=user_profile,\n",
                    "                                                             message__in=query_result))\n"
                ],
                "parent_version_range": {
                    "start": 858,
                    "end": 861
                },
                "child_version_range": {
                    "start": 859,
                    "end": 862
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if include_history:",
                        "start_line": 857,
                        "end_line": 874
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_old_messages_backend",
                        "signature": "def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):",
                        "at_line": 776
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: zephyr/views.py\nCode:\n           def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):\n               ...\n857 858        if include_history:\n858      -         user_messages = dict((user_message.message_id, user_message) for user_message in\n859      -                              UserMessage.objects.filter(user_profile=user_profile,\n860      -                                                         message__in=query_result))\n    859  +         user_message_flags = dict((user_message.message_id, user_message.flags_list()) for user_message in\n    860  +                                   UserMessage.objects.filter(user_profile=user_profile,\n    861  +                                                              message__in=query_result))\n861 862            for message in query_result:\n862 863                message_ids.append(message.id)\n         ...\n",
                "file_path": "zephyr/views.py",
                "identifiers_before": [
                    "UserMessage",
                    "dict",
                    "filter",
                    "message__in",
                    "message_id",
                    "objects",
                    "query_result",
                    "user_message",
                    "user_messages",
                    "user_profile"
                ],
                "identifiers_after": [
                    "UserMessage",
                    "dict",
                    "filter",
                    "flags_list",
                    "message__in",
                    "message_id",
                    "objects",
                    "query_result",
                    "user_message",
                    "user_message_flags",
                    "user_profile"
                ],
                "prefix": [
                    "    if include_history:\n"
                ],
                "suffix": [
                    "        for message in query_result:\n",
                    "            message_ids.append(message.id)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    5
                ]
            },
            [
                "        for message in query_result:\n",
                "            message_ids.append(message.id)\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "            if user_message_flags.get(message.id) is None:\n",
                    "                user_message_flags[message.id] = [\"read\", \"historical\"]\n"
                ],
                "parent_version_range": {
                    "start": 863,
                    "end": 863
                },
                "child_version_range": {
                    "start": 864,
                    "end": 866
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if include_history:",
                        "start_line": 857,
                        "end_line": 874
                    },
                    {
                        "type": "for_statement",
                        "statement": "for message in query_result:",
                        "start_line": 861,
                        "end_line": 865
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_old_messages_backend",
                        "signature": "def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):",
                        "at_line": 776
                    },
                    {
                        "type": "call",
                        "name": "message_ids.append",
                        "signature": "message_ids.append(message.id)",
                        "at_line": 862,
                        "argument": "message.id"
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: zephyr/views.py\nCode:\n           def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):\n               ...\n861 862            for message in query_result:\n862 863                message_ids.append(message.id)\n    864  +             if user_message_flags.get(message.id) is None:\n    865  +                 user_message_flags[message.id] = [\"read\", \"historical\"]\n863 866                if is_search:\n864 867                    search_fields[message.id] = dict([('match_subject', message.match_subject),\n865 868                                                      ('match_content', message.match_content)])\n         ...\n",
                "file_path": "zephyr/views.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "get",
                    "id",
                    "message",
                    "user_message_flags"
                ],
                "prefix": [
                    "        for message in query_result:\n",
                    "            message_ids.append(message.id)\n"
                ],
                "suffix": [
                    "            if is_search:\n",
                    "                search_fields[message.id] = dict([('match_subject', message.match_subject),\n",
                    "                                                  ('match_content', message.match_content)])\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "            if is_search:\n",
                "                search_fields[message.id] = dict([('match_subject', message.match_subject),\n",
                "                                                  ('match_content', message.match_content)])\n",
                "    else:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        user_messages = dict((user_message.message_id, user_message)\n",
                    "                             for user_message in query_result)\n"
                ],
                "after": [
                    "        user_message_flags = dict((user_message.message_id, user_message.flags_list())\n",
                    "                                  for user_message in query_result)\n"
                ],
                "parent_version_range": {
                    "start": 867,
                    "end": 869
                },
                "child_version_range": {
                    "start": 870,
                    "end": 872
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if include_history:",
                        "start_line": 857,
                        "end_line": 874
                    },
                    {
                        "type": "else_clause",
                        "statement": "else:",
                        "start_line": 866,
                        "end_line": 874
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_old_messages_backend",
                        "signature": "def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):",
                        "at_line": 776
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: zephyr/views.py\nCode:\n           def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):\n               ...\n864 867                    search_fields[message.id] = dict([('match_subject', message.match_subject),\n865 868                                                      ('match_content', message.match_content)])\n866 869        else:\n867      -         user_messages = dict((user_message.message_id, user_message)\n868      -                              for user_message in query_result)\n    870  +         user_message_flags = dict((user_message.message_id, user_message.flags_list())\n    871  +                                   for user_message in query_result)\n869 872            for user_message in query_result:\n870 873                message_ids.append(user_message.message_id)\n871 874                if is_search:\n         ...\n",
                "file_path": "zephyr/views.py",
                "identifiers_before": [
                    "dict",
                    "message_id",
                    "query_result",
                    "user_message",
                    "user_messages"
                ],
                "identifiers_after": [
                    "dict",
                    "flags_list",
                    "message_id",
                    "query_result",
                    "user_message",
                    "user_message_flags"
                ],
                "prefix": [
                    "                search_fields[message.id] = dict([('match_subject', message.match_subject),\n",
                    "                                                  ('match_content', message.match_content)])\n",
                    "    else:\n"
                ],
                "suffix": [
                    "        for user_message in query_result:\n",
                    "            message_ids.append(user_message.message_id)\n",
                    "            if is_search:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": [
                    3
                ]
            },
            [
                "        for user_message in query_result:\n",
                "            message_ids.append(user_message.message_id)\n",
                "            if is_search:\n",
                "                search_fields[user_message.message_id] = \\\n",
                "                    dict([('match_subject', user_message.match_subject),\n",
                "                          ('match_content', user_message.match_content)])\n",
                "\n",
                "    bulk_messages = cache_get_many([to_dict_cache_key_id(message_id, apply_markdown)\n",
                "                                    for message_id in message_ids])\n",
                "    for (key, val) in bulk_messages.items():\n",
                "        bulk_messages[key] = extract_message_dict(bulk_messages[key][0])\n",
                "\n",
                "    needed_ids = [message_id for message_id in message_ids if\n",
                "                  to_dict_cache_key_id(message_id, apply_markdown) not in bulk_messages]\n",
                "    if len(needed_ids) > 0:\n",
                "        full_messages = Message.objects.select_related().filter(id__in=needed_ids)\n",
                "\n",
                "        items_for_memcached = {}\n",
                "        for message in full_messages:\n",
                "            key = to_dict_cache_key(message, apply_markdown)\n",
                "            if bulk_messages.get(key) is None:\n",
                "                msg = message.to_dict_uncached(apply_markdown)\n",
                "                elt = stringify_message_dict(msg)\n",
                "                items_for_memcached[key] = (elt,)\n",
                "                bulk_messages[key] = msg\n",
                "        if len(items_for_memcached) > 0:\n",
                "            cache_set_many(items_for_memcached)\n",
                "\n",
                "    message_list = []\n",
                "    for message_id in message_ids:\n"
            ],
            {
                "type": "delete",
                "before": [
                    "        if include_history:\n",
                    "            flags_dict = {'flags': [\"read\", \"historical\"]}\n",
                    "        if message_id in user_messages:\n",
                    "            flags_dict = user_messages[message_id].flags_dict()\n"
                ],
                "after": [],
                "parent_version_range": {
                    "start": 899,
                    "end": 903
                },
                "child_version_range": {
                    "start": 902,
                    "end": 902
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for message_id in message_ids:",
                        "start_line": 898,
                        "end_line": 908
                    },
                    {
                        "type": "if_statement",
                        "statement": "if include_history:",
                        "start_line": 899,
                        "end_line": 900
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_old_messages_backend",
                        "signature": "def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):",
                        "at_line": 776
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: zephyr/views.py\nCode:\n           def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):\n               ...\n896 899    \n897 900        message_list = []\n898 901        for message_id in message_ids:\n899      -         if include_history:\n900      -             flags_dict = {'flags': [\"read\", \"historical\"]}\n901      -         if message_id in user_messages:\n902      -             flags_dict = user_messages[message_id].flags_dict()\n903 902            key = to_dict_cache_key_id(message_id, apply_markdown)\n904 903            elt = bulk_messages.get(key)\n905 904            msg_dict = dict(elt)\n         ...\n",
                "file_path": "zephyr/views.py",
                "identifiers_before": [
                    "flags_dict",
                    "include_history",
                    "message_id",
                    "user_messages"
                ],
                "identifiers_after": [],
                "prefix": [
                    "\n",
                    "    message_list = []\n",
                    "    for message_id in message_ids:\n"
                ],
                "suffix": [
                    "        key = to_dict_cache_key_id(message_id, apply_markdown)\n",
                    "        elt = bulk_messages.get(key)\n",
                    "        msg_dict = dict(elt)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        key = to_dict_cache_key_id(message_id, apply_markdown)\n",
                "        elt = bulk_messages.get(key)\n",
                "        msg_dict = dict(elt)\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        msg_dict.update(flags_dict)\n"
                ],
                "after": [
                    "        msg_dict.update({\"flags\": user_message_flags[message_id]})\n"
                ],
                "parent_version_range": {
                    "start": 906,
                    "end": 907
                },
                "child_version_range": {
                    "start": 905,
                    "end": 906
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for message_id in message_ids:",
                        "start_line": 898,
                        "end_line": 908
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "get_old_messages_backend",
                        "signature": "def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):",
                        "at_line": 776
                    },
                    {
                        "type": "call",
                        "name": "msg_dict.update",
                        "signature": "msg_dict.update(flags_dict)",
                        "at_line": 906,
                        "argument": "flags_dict"
                    }
                ],
                "idx": 7,
                "hunk_diff": "File: zephyr/views.py\nCode:\n           def get_old_messages_backend(request, user_profile,\n                             anchor = REQ(converter=int),\n                             num_before = REQ(converter=to_non_negative_int),\n                             num_after = REQ(converter=to_non_negative_int),\n                             narrow = REQ('narrow', converter=narrow_parameter, default=None),\n                             apply_markdown=True):\n               ...\n903 902            key = to_dict_cache_key_id(message_id, apply_markdown)\n904 903            elt = bulk_messages.get(key)\n905 904            msg_dict = dict(elt)\n906      -         msg_dict.update(flags_dict)\n    905  +         msg_dict.update({\"flags\": user_message_flags[message_id]})\n907 906            msg_dict.update(search_fields.get(elt['id'], {}))\n908 907            message_list.append(msg_dict)\n909 908    \n         ...\n",
                "file_path": "zephyr/views.py",
                "identifiers_before": [
                    "flags_dict",
                    "msg_dict",
                    "update"
                ],
                "identifiers_after": [
                    "message_id",
                    "msg_dict",
                    "update",
                    "user_message_flags"
                ],
                "prefix": [
                    "        key = to_dict_cache_key_id(message_id, apply_markdown)\n",
                    "        elt = bulk_messages.get(key)\n",
                    "        msg_dict = dict(elt)\n"
                ],
                "suffix": [
                    "        msg_dict.update(search_fields.get(elt['id'], {}))\n",
                    "        message_list.append(msg_dict)\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        msg_dict.update(search_fields.get(elt['id'], {}))\n",
                "        message_list.append(msg_dict)\n",
                "\n",
                "    statsd.incr('loaded_old_messages', len(message_list))\n",
                "    ret = {'messages': message_list,\n",
                "           \"result\": \"success\",\n",
                "           \"msg\": \"\"}\n",
                "    return json_success(ret)\n",
                "\n",
                "def generate_client_id():\n",
                "    return base64.b16encode(os.urandom(16)).lower()\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_get_profile(request, user_profile):\n",
                "    return get_profile_backend(request, user_profile)\n",
                "\n",
                "@authenticated_api_view\n",
                "def api_get_profile(request, user_profile):\n",
                "    return get_profile_backend(request, user_profile)\n",
                "\n",
                "def get_profile_backend(request, user_profile):\n",
                "    result = dict(pointer        = user_profile.pointer,\n",
                "                  client_id      = generate_client_id(),\n",
                "                  max_message_id = -1)\n",
                "\n",
                "    messages = Message.objects.filter(usermessage__user_profile=user_profile).order_by('-id')[:1]\n",
                "    if messages:\n",
                "        result['max_message_id'] = messages[0].id\n",
                "\n",
                "    return json_success(result)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_update_flags(request, user_profile, messages=REQ('messages', converter=json_to_list),\n",
                "                      operation=REQ('op'), flag=REQ('flag'),\n",
                "                      all=REQ('all', converter=json_to_bool, default=False)):\n",
                "    update_message_flags(user_profile, operation, flag, messages, all)\n",
                "    return json_success({'result': 'success',\n",
                "                         'messages': messages,\n",
                "                         'msg': ''})\n",
                "\n",
                "@authenticated_api_view\n",
                "def api_send_message(request, user_profile):\n",
                "    return send_message_backend(request, user_profile)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_send_message(request, user_profile):\n",
                "    return send_message_backend(request, user_profile)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_change_enter_sends(request, user_profile,\n",
                "                            enter_sends=REQ('enter_sends', json_to_bool)):\n",
                "    do_change_enter_sends(user_profile, enter_sends)\n",
                "    return json_success()\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_update_onboarding_steps(request, user_profile,\n",
                "                                 onboarding_steps=REQ(converter=json_to_list,\n",
                "                                                      default=[])):\n",
                "    do_update_onboarding_steps(user_profile, onboarding_steps)\n",
                "    return json_success()\n",
                "\n",
                "# Currently tabbott/extra@mit.edu is our only superuser.  TODO: Make\n",
                "# this a real superuser security check.\n",
                "def is_super_user_api(request):\n",
                "    return request.user.is_authenticated() and request.user.email == \"tabbott/extra@mit.edu\"\n",
                "\n",
                "def mit_to_mit(user_profile, email):\n",
                "    # Are the sender and recipient both @mit.edu addresses?\n",
                "    # We have to handle this specially, inferring the domain from the\n",
                "    # e-mail address, because the recipient may not existing in Humbug\n",
                "    # and we may need to make a stub MIT user on the fly.\n",
                "    if not validators.email_re.match(email):\n",
                "        return False\n",
                "\n",
                "    if user_profile.realm.domain != \"mit.edu\":\n",
                "        return False\n",
                "\n",
                "    domain = email.split(\"@\", 1)[1]\n",
                "    return user_profile.realm.domain == domain\n",
                "\n",
                "def create_mirrored_message_users(request, user_profile, recipients):\n",
                "    if \"sender\" not in request.POST:\n",
                "        return (False, None)\n",
                "\n",
                "    sender_email = request.POST[\"sender\"].strip().lower()\n",
                "    referenced_users = set([sender_email])\n",
                "    if request.POST['type'] == 'private':\n",
                "        for email in recipients:\n",
                "            referenced_users.add(email.lower())\n",
                "\n",
                "    # Check that all referenced users are in our realm:\n",
                "    for email in referenced_users:\n",
                "        if not mit_to_mit(user_profile, email):\n",
                "            return (False, None)\n",
                "\n",
                "    # Create users for the referenced users, if needed.\n",
                "    for email in referenced_users:\n",
                "        create_mit_user_if_needed(user_profile.realm, email)\n",
                "\n",
                "    sender = get_user_profile_by_email(sender_email)\n",
                "    return (True, sender)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_tutorial_send_message(request, user_profile,\n",
                "                               message_type_name = REQ('type'),\n",
                "                               subject_name = REQ('subject', lambda x: x.strip(), None),\n",
                "                               message_content = REQ('content')):\n",
                "    \"\"\"\n",
                "    This function, used by the onboarding tutorial, causes the\n",
                "    Tutorial Bot to send you the message you pass in here.\n",
                "    (That way, the Tutorial Bot's messages to you get rendered\n",
                "     by the server and therefore look like any other message.)\n",
                "    \"\"\"\n",
                "    sender_name = \"humbug+tutorial@humbughq.com\"\n",
                "    if message_type_name == 'private':\n",
                "        # For now, we discard the recipient on PMs; the tutorial bot\n",
                "        # can only send to you.\n",
                "        internal_send_message(sender_name,\n",
                "                              \"private\",\n",
                "                              user_profile.email,\n",
                "                              \"\",\n",
                "                              message_content,\n",
                "                              realm=user_profile.realm)\n",
                "        return json_success()\n",
                "    elif message_type_name == 'stream':\n",
                "        tutorial_stream_name = user_profile.tutorial_stream_name()\n",
                "        ## TODO: For open realms, we need to use the full name here,\n",
                "        ## so that me@gmail.com and me@hotmail.com don't get the same stream.\n",
                "        internal_send_message(sender_name,\n",
                "                              \"stream\",\n",
                "                              tutorial_stream_name,\n",
                "                              subject_name,\n",
                "                              message_content,\n",
                "                              realm=user_profile.realm)\n",
                "        return json_success()\n",
                "    return json_error('Bad data passed in to tutorial_send_message')\n",
                "\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_tutorial_status(request, user_profile, status=REQ('status')):\n",
                "    if status == 'started':\n",
                "        user_profile.tutorial_status = UserProfile.TUTORIAL_STARTED\n",
                "        user_profile.save()\n",
                "    elif status == 'finished':\n",
                "        do_finish_tutorial(user_profile)\n",
                "\n",
                "    return json_success()\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_update_message(request, user_profile):\n",
                "    return update_message_backend(request, user_profile)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_fetch_raw_message(request, user_profile,\n",
                "                           message_id=REQ(converter=to_non_negative_int)):\n",
                "    try:\n",
                "        message = Message.objects.get(id=message_id)\n",
                "    except Message.DoesNotExist:\n",
                "        return json_error(\"No such message\")\n",
                "\n",
                "    if message.sender != user_profile:\n",
                "        return json_error(\"Message was not sent by you\")\n",
                "\n",
                "    return json_success({\"raw_content\": message.content})\n",
                "\n",
                "@has_request_variables\n",
                "def update_message_backend(request, user_profile,\n",
                "                           message_id=REQ(converter=to_non_negative_int),\n",
                "                           subject=REQ(default=None),\n",
                "                           content=REQ(default=None)):\n",
                "    if subject is None and content is None:\n",
                "        return json_error(\"Nothing to change\")\n",
                "    do_update_message(user_profile, message_id, subject, content)\n",
                "    return json_success()\n",
                "\n",
                "# We do not @require_login for send_message_backend, since it is used\n",
                "# both from the API and the web service.  Code calling\n",
                "# send_message_backend should either check the API key or check that\n",
                "# the user is logged in.\n",
                "@has_request_variables\n",
                "def send_message_backend(request, user_profile,\n",
                "                         message_type_name = REQ('type'),\n",
                "                         message_to = REQ('to', converter=extract_recipients),\n",
                "                         forged = REQ(default=False),\n",
                "                         subject_name = REQ('subject', lambda x: x.strip(), None),\n",
                "                         message_content = REQ('content')):\n",
                "    client = request.client\n",
                "    is_super_user = is_super_user_api(request)\n",
                "    if forged and not is_super_user:\n",
                "        return json_error(\"User not authorized for this query\")\n",
                "\n",
                "    if client.name == \"zephyr_mirror\":\n",
                "        # Here's how security works for non-superuser mirroring:\n",
                "        #\n",
                "        # The message must be (1) a private message (2) that\n",
                "        # is both sent and received exclusively by other users in your\n",
                "        # realm which (3) must be the MIT realm and (4) you must have\n",
                "        # received the message.\n",
                "        #\n",
                "        # If that's the case, we let it through, but we still have the\n",
                "        # security flaw that we're trusting your Hesiod data for users\n",
                "        # you report having sent you a message.\n",
                "        if \"sender\" not in request.POST:\n",
                "            return json_error(\"Missing sender\")\n",
                "        if message_type_name != \"private\" and not is_super_user:\n",
                "            return json_error(\"User not authorized for this query\")\n",
                "        (valid_input, mirror_sender) = \\\n",
                "            create_mirrored_message_users(request, user_profile, message_to)\n",
                "        if not valid_input:\n",
                "            return json_error(\"Invalid mirrored message\")\n",
                "        if user_profile.realm.domain != \"mit.edu\":\n",
                "            return json_error(\"Invalid mirrored realm\")\n",
                "        sender = mirror_sender\n",
                "    else:\n",
                "        sender = user_profile\n",
                "\n",
                "    ret = check_send_message(sender, client, message_type_name, message_to,\n",
                "                             subject_name, message_content, forged=forged,\n",
                "                             forged_timestamp = request.POST.get('time'),\n",
                "                             forwarder_user_profile=user_profile)\n",
                "    if ret is not None:\n",
                "        return json_error(ret)\n",
                "    return json_success()\n",
                "\n",
                "@authenticated_api_view\n",
                "def api_get_public_streams(request, user_profile):\n",
                "    return get_public_streams_backend(request, user_profile)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_get_public_streams(request, user_profile):\n",
                "    return get_public_streams_backend(request, user_profile)\n",
                "\n",
                "def get_public_streams_backend(request, user_profile):\n",
                "    if user_profile.realm.domain == \"mit.edu\" and not is_super_user_api(request):\n",
                "        return json_error(\"User not authorized for this query\")\n",
                "\n",
                "    # Only get streams someone is currently subscribed to\n",
                "    subs_filter = Subscription.objects.filter(active=True).values('recipient_id')\n",
                "    stream_ids = Recipient.objects.filter(\n",
                "        type=Recipient.STREAM, id__in=subs_filter).values('type_id')\n",
                "    streams = sorted(stream.name for stream in\n",
                "                     Stream.objects.filter(id__in = stream_ids,\n",
                "                                           realm=user_profile.realm,\n",
                "                                           invite_only=False))\n",
                "    return json_success({\"streams\": streams})\n",
                "\n",
                "@authenticated_api_view\n",
                "def api_list_subscriptions(request, user_profile):\n",
                "    return json_success({\"subscriptions\": gather_subscriptions(user_profile)[0]})\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_list_subscriptions(request, user_profile):\n",
                "    all_subs = gather_subscriptions(user_profile)\n",
                "    return json_success({\"subscriptions\": all_subs[0], \"unsubscribed\": all_subs[1]})\n",
                "\n",
                "@transaction.commit_on_success\n",
                "@has_request_variables\n",
                "def update_subscriptions_backend(request, user_profile,\n",
                "                                 delete=REQ(converter=json_to_list, default=[]),\n",
                "                                 add=REQ(converter=json_to_list, default=[])):\n",
                "    if not add and not delete:\n",
                "        return json_error('Nothing to do. Specify at least one of \"add\" or \"delete\".')\n",
                "\n",
                "    json_dict = {}\n",
                "    for method, items in ((add_subscriptions_backend, add), (remove_subscriptions_backend, delete)):\n",
                "        response = method(request, user_profile, streams_raw=items)\n",
                "        if response.status_code != 200:\n",
                "            transaction.rollback()\n",
                "            return response\n",
                "        json_dict.update(ujson.loads(response.content))\n",
                "    return json_success(json_dict)\n",
                "\n",
                "@authenticated_api_view\n",
                "def api_remove_subscriptions(request, user_profile):\n",
                "    return remove_subscriptions_backend(request, user_profile)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_remove_subscriptions(request, user_profile):\n",
                "    return remove_subscriptions_backend(request, user_profile)\n",
                "\n",
                "@has_request_variables\n",
                "def remove_subscriptions_backend(request, user_profile,\n",
                "                                 streams_raw = REQ(\"subscriptions\", json_to_list)):\n",
                "\n",
                "    streams = list_to_streams(streams_raw, user_profile)\n",
                "\n",
                "    result = dict(removed=[], not_subscribed=[])\n",
                "    for stream in streams:\n",
                "        did_remove = do_remove_subscription(user_profile, stream)\n",
                "        if did_remove:\n",
                "            result[\"removed\"].append(stream.name)\n",
                "        else:\n",
                "            result[\"not_subscribed\"].append(stream.name)\n",
                "\n",
                "    return json_success(result)\n",
                "\n",
                "@authenticated_api_view\n",
                "def api_add_subscriptions(request, user_profile):\n",
                "    return add_subscriptions_backend(request, user_profile)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_add_subscriptions(request, user_profile):\n",
                "    return add_subscriptions_backend(request, user_profile)\n",
                "\n",
                "@has_request_variables\n",
                "def add_subscriptions_backend(request, user_profile,\n",
                "                              streams_raw = REQ('subscriptions', json_to_list),\n",
                "                              invite_only = REQ('invite_only', json_to_bool, default=False),\n",
                "                              principals = REQ('principals', json_to_list, default=None),):\n",
                "\n",
                "    stream_names = []\n",
                "    for stream_name in streams_raw:\n",
                "        stream_name = stream_name.strip()\n",
                "        if len(stream_name) > Stream.MAX_NAME_LENGTH:\n",
                "            return json_error(\"Stream name (%s) too long.\" % (stream_name,))\n",
                "        if not valid_stream_name(stream_name):\n",
                "            return json_error(\"Invalid stream name (%s).\" % (stream_name,))\n",
                "        stream_names.append(stream_name)\n",
                "\n",
                "    if principals is not None:\n",
                "        subscribers = set(principal_to_user_profile(user_profile, principal) for principal in principals)\n",
                "    else:\n",
                "        subscribers = [user_profile]\n",
                "\n",
                "    streams = list_to_streams(streams_raw, user_profile, autocreate=True, invite_only=invite_only)\n",
                "    private_streams = {}\n",
                "    result = dict(subscribed=[], already_subscribed=[])\n",
                "\n",
                "    result = dict(subscribed=defaultdict(list), already_subscribed=defaultdict(list))\n",
                "    for stream in streams:\n",
                "        (subscribed, already_subscribed) = bulk_add_subscriptions(stream, subscribers)\n",
                "        for subscriber in subscribed:\n",
                "            result[\"subscribed\"][subscriber.email].append(stream.name)\n",
                "        for subscriber in already_subscribed:\n",
                "            result[\"already_subscribed\"][subscriber.email].append(stream.name)\n",
                "        private_streams[stream.name] = stream.invite_only\n",
                "\n",
                "\n",
                "    # Inform the user if someone else subscribed them to stuff\n",
                "    if principals and result[\"subscribed\"]:\n",
                "        notifications = []\n",
                "        for email, subscriptions in result[\"subscribed\"].iteritems():\n",
                "            if email == user_profile.email:\n",
                "                # Don't send a Humbug if you invited yourself.\n",
                "                continue\n",
                "\n",
                "            if len(subscriptions) == 1:\n",
                "                msg = (\"Hi there!  We thought you'd like to know that %s just \"\n",
                "                       \"subscribed you to the%s stream '%s'\"\n",
                "                       % (user_profile.full_name,\n",
                "                          \" **invite-only**\" if private_streams[subscriptions[0]] else \"\",\n",
                "                          subscriptions[0]))\n",
                "            else:\n",
                "                msg = (\"Hi there!  We thought you'd like to know that %s just \"\n",
                "                       \"subscribed you to the following streams: \\n\\n\"\n",
                "                       % (user_profile.full_name,))\n",
                "                for stream in subscriptions:\n",
                "                    msg += \"* %s%s\\n\" % (\n",
                "                        stream,\n",
                "                        \" (**invite-only**)\" if private_streams[stream] else \"\")\n",
                "            msg += \"\\nYou can see historical content on a non-invite-only stream by narrowing to it.\"\n",
                "            notifications.append(internal_prep_message(\"humbug+notifications@humbughq.com\",\n",
                "                                                       \"private\", email, \"\", msg))\n",
                "        do_send_messages(notifications)\n",
                "\n",
                "    result[\"subscribed\"] = dict(result[\"subscribed\"])\n",
                "    result[\"already_subscribed\"] = dict(result[\"already_subscribed\"])\n",
                "    return json_success(result)\n",
                "\n",
                "@authenticated_api_view\n",
                "def api_get_members(request, user_profile):\n",
                "    return get_members_backend(request, user_profile)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_get_members(request, user_profile):\n",
                "    return get_members_backend(request, user_profile)\n",
                "\n",
                "def get_members_backend(request, user_profile):\n",
                "    members = [(profile.full_name, profile.email) for profile in \\\n",
                "                   UserProfile.objects.select_related().filter(realm=user_profile.realm)]\n",
                "    return json_success({'members': members})\n",
                "\n",
                "@authenticated_api_view\n",
                "def api_get_subscribers(request, user_profile):\n",
                "    return get_subscribers_backend(request, user_profile)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_get_subscribers(request, user_profile):\n",
                "    return get_subscribers_backend(request, user_profile)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_upload_file(request, user_profile):\n",
                "    if len(request.FILES) == 0:\n",
                "        return json_error(\"You must specify a file to upload\")\n",
                "    if len(request.FILES) != 1:\n",
                "        return json_error(\"You may only upload one file at a time\")\n",
                "\n",
                "    user_file = request.FILES.values()[0]\n",
                "    uri = upload_message_image(request, user_file, user_profile)\n",
                "    return json_success({'uri': uri})\n",
                "\n",
                "@has_request_variables\n",
                "def get_subscribers_backend(request, user_profile, stream_name=REQ('stream')):\n",
                "    if user_profile.realm.domain == \"mit.edu\":\n",
                "        return json_error(\"You cannot get subscribers in this realm\")\n",
                "\n",
                "    stream = get_stream(stream_name, user_profile.realm)\n",
                "    if stream is None:\n",
                "        return json_error(\"Stream does not exist: %s\" % stream_name)\n",
                "\n",
                "    if stream.invite_only and not subscribed_to_stream(user_profile, stream):\n",
                "        return json_error(\"Unable to retrieve subscribers for invite-only stream\")\n",
                "\n",
                "    subscriptions = Subscription.objects.filter(recipient__type=Recipient.STREAM,\n",
                "                                                recipient__type_id=stream.id,\n",
                "                                                active=True).select_related()\n",
                "\n",
                "    return json_success({'subscribers': [subscription.user_profile.email\n",
                "                                         for subscription in subscriptions]})\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_change_settings(request, user_profile, full_name=REQ,\n",
                "                         old_password=REQ, new_password=REQ,\n",
                "                         confirm_password=REQ,\n",
                "                         # enable_desktop_notification needs to default to False\n",
                "                         # because browsers POST nothing for an unchecked checkbox\n",
                "                         enable_desktop_notifications=REQ(converter=lambda x: x == \"on\",\n",
                "                                                          default=False),\n",
                "                         enable_sounds=REQ(converter=lambda x: x == \"on\",\n",
                "                                                          default=False),\n",
                "                         enable_offline_email_notifications=REQ(converter=lambda x: x == \"on\",\n",
                "                                                                default=False)):\n",
                "    if new_password != \"\" or confirm_password != \"\":\n",
                "        if new_password != confirm_password:\n",
                "            return json_error(\"New password must match confirmation password!\")\n",
                "        if not authenticate(username=user_profile.email, password=old_password):\n",
                "            return json_error(\"Wrong password!\")\n",
                "        do_change_password(user_profile, new_password)\n",
                "\n",
                "    result = {}\n",
                "    if user_profile.full_name != full_name and full_name.strip() != \"\":\n",
                "        do_change_full_name(user_profile, full_name.strip())\n",
                "        result['full_name'] = full_name\n",
                "\n",
                "    if user_profile.enable_desktop_notifications != enable_desktop_notifications:\n",
                "        do_change_enable_desktop_notifications(user_profile, enable_desktop_notifications)\n",
                "        result['enable_desktop_notifications'] = enable_desktop_notifications\n",
                "\n",
                "    if user_profile.enable_sounds != enable_sounds:\n",
                "        do_change_enable_sounds(user_profile, enable_sounds)\n",
                "        result['enable_sounds'] = enable_sounds\n",
                "\n",
                "    if user_profile.enable_offline_email_notifications != enable_offline_email_notifications:\n",
                "        do_change_enable_offline_email_notifications(user_profile, enable_offline_email_notifications)\n",
                "        result['enable_offline_email_notifications'] = enable_offline_email_notifications\n",
                "\n",
                "    return json_success(result)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_stream_exists(request, user_profile, stream=REQ):\n",
                "    return stream_exists_backend(request, user_profile, stream)\n",
                "\n",
                "def stream_exists_backend(request, user_profile, stream_name):\n",
                "    if not valid_stream_name(stream_name):\n",
                "        return json_error(\"Invalid characters in stream name\")\n",
                "    stream = get_stream(stream_name, user_profile.realm)\n",
                "    result = {\"exists\": bool(stream)}\n",
                "    if stream is not None:\n",
                "        recipient = get_recipient(Recipient.STREAM, stream.id)\n",
                "        result[\"subscribed\"] = Subscription.objects.filter(user_profile=user_profile,\n",
                "                                                           recipient=recipient,\n",
                "                                                           active=True).exists()\n",
                "        return json_success(result) # results are ignored for HEAD requests\n",
                "    return json_response(data=result, status=404)\n",
                "\n",
                "def get_subscription_or_die(stream_name, user_profile):\n",
                "    stream = get_stream(stream_name, user_profile.realm)\n",
                "    if not stream:\n",
                "        raise JsonableError(\"Invalid stream %s\" % (stream.name,))\n",
                "    recipient = get_recipient(Recipient.STREAM, stream.id)\n",
                "    subscription = Subscription.objects.filter(user_profile=user_profile,\n",
                "                                               recipient=recipient, active=True)\n",
                "\n",
                "    if not subscription.exists():\n",
                "        raise JsonableError(\"Not subscribed to stream %s\" % (stream_name,))\n",
                "\n",
                "    return subscription\n",
                "\n",
                "@authenticated_json_view\n",
                "@has_request_variables\n",
                "def json_subscription_property(request, user_profile, stream_name=REQ,\n",
                "                               property=REQ):\n",
                "    \"\"\"\n",
                "    This is the entry point to accessing or changing subscription\n",
                "    properties.\n",
                "    \"\"\"\n",
                "    property_converters = dict(color=lambda x: x,\n",
                "                               in_home_view=json_to_bool,\n",
                "                               notifications=json_to_bool)\n",
                "    if property not in property_converters:\n",
                "        return json_error(\"Unknown subscription property: %s\" % (property,))\n",
                "\n",
                "    sub = get_subscription_or_die(stream_name, user_profile)[0]\n",
                "    if request.method == \"GET\":\n",
                "        return json_success({'stream_name': stream_name,\n",
                "                             'value': getattr(sub, property)})\n",
                "    elif request.method == \"POST\":\n",
                "        @has_request_variables\n",
                "        def do_set_property(request,\n",
                "                            value=REQ(converter=property_converters[property])):\n",
                "            setattr(sub, property, value)\n",
                "            sub.save(update_fields=[property])\n",
                "            log_subscription_property_change(user_profile.email, stream_name,\n",
                "                                             property, value)\n",
                "        do_set_property(request)\n",
                "        return json_success()\n",
                "    else:\n",
                "        return json_error(\"Invalid verb\")\n",
                "\n",
                "@csrf_exempt\n",
                "@require_post\n",
                "@has_request_variables\n",
                "def api_fetch_api_key(request, username=REQ, password=REQ):\n",
                "    user_profile = authenticate(username=username, password=password)\n",
                "    if user_profile is None:\n",
                "        return json_error(\"Your username or password is incorrect.\", status=403)\n",
                "    if not user_profile.is_active:\n",
                "        return json_error(\"Your account has been disabled.\", status=403)\n",
                "    return json_success({\"api_key\": user_profile.api_key})\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_fetch_api_key(request, user_profile, password=REQ):\n",
                "    if not user_profile.check_password(password):\n",
                "        return json_error(\"Your username or password is incorrect.\")\n",
                "    return json_success({\"api_key\": user_profile.api_key})\n",
                "\n",
                "class ActivityTable(object):\n",
                "    def __init__(self, client_name, queries, default_tab=False):\n",
                "        self.default_tab = default_tab\n",
                "        self.has_pointer = False\n",
                "        self.rows = {}\n",
                "\n",
                "        def do_url(query_name, url):\n",
                "            for record in UserActivity.objects.filter(\n",
                "                    query=url,\n",
                "                    client__name__startswith=client_name).select_related():\n",
                "                row = self.rows.setdefault(record.user_profile.email,\n",
                "                                           {'realm': record.user_profile.realm.domain,\n",
                "                                            'full_name': record.user_profile.full_name,\n",
                "                                            'email': record.user_profile.email})\n",
                "                row[query_name + '_count'] = record.count\n",
                "                row[query_name + '_last' ] = record.last_visit\n",
                "\n",
                "        for query_name, urls in queries:\n",
                "            if 'pointer' in query_name:\n",
                "                self.has_pointer = True\n",
                "            for url in urls:\n",
                "                do_url(query_name, url)\n",
                "\n",
                "        for row in self.rows.values():\n",
                "            # kind of a hack\n",
                "            last_action = max(v for v in row.values() if isinstance(v, datetime.datetime))\n",
                "            age = now() - last_action\n",
                "            if age < datetime.timedelta(minutes=10):\n",
                "                row['class'] = 'recently_active'\n",
                "            elif age >= datetime.timedelta(days=1):\n",
                "                row['class'] = 'long_inactive'\n",
                "            row['age'] = age\n",
                "\n",
                "    def sorted_rows(self):\n",
                "        return sorted(self.rows.iteritems(), key=lambda (k,r): r['age'])\n",
                "\n",
                "def can_view_activity(request):\n",
                "    return request.user.realm.domain == 'humbughq.com'\n",
                "\n",
                "@login_required(login_url = settings.HOME_NOT_LOGGED_IN)\n",
                "def get_activity(request):\n",
                "    if not can_view_activity(request):\n",
                "        return HttpResponseRedirect(reverse('zephyr.views.login_page'))\n",
                "\n",
                "    web_queries = (\n",
                "        (\"get_updates\",    [\"/json/get_updates\", \"/json/get_events\"]),\n",
                "        (\"send_message\",   [\"/json/send_message\"]),\n",
                "        (\"update_pointer\", [\"/json/update_pointer\"]),\n",
                "    )\n",
                "\n",
                "    api_queries = (\n",
                "        (\"get_updates\",  [\"/api/v1/get_messages\", \"/api/v1/messages/latest\", \"/api/v1/events\"]),\n",
                "        (\"send_message\", [\"/api/v1/send_message\"]),\n",
                "    )\n",
                "\n",
                "    return render_to_response('zephyr/activity.html',\n",
                "        { 'data': {\n",
                "            'Website': ActivityTable('website',       web_queries, default_tab=True),\n",
                "            'Mirror':  ActivityTable('zephyr_mirror', api_queries),\n",
                "            'API':     ActivityTable('API',           api_queries),\n",
                "            'Android': ActivityTable('Android',       api_queries),\n",
                "            'iPhone':  ActivityTable('iPhone',        api_queries)\n",
                "        }}, context_instance=RequestContext(request))\n",
                "\n",
                "def build_message_from_gitlog(user_profile, name, ref, commits, before, after, url, pusher):\n",
                "    short_ref = re.sub(r'^refs/heads/', '', ref)\n",
                "    subject = name\n",
                "\n",
                "    if re.match(r'^0+$', after):\n",
                "        content = \"%s deleted branch %s\" % (pusher,\n",
                "                                            short_ref)\n",
                "    elif len(commits) == 0:\n",
                "        content = (\"%s [force pushed](%s) to branch %s.  Head is now %s\"\n",
                "                   % (pusher,\n",
                "                      url,\n",
                "                      short_ref,\n",
                "                      after[:7]))\n",
                "    else:\n",
                "        content = (\"%s [pushed](%s) to branch %s\\n\\n\"\n",
                "                   % (pusher,\n",
                "                      url,\n",
                "                      short_ref))\n",
                "        num_commits = len(commits)\n",
                "        max_commits = 10\n",
                "        truncated_commits = commits[:max_commits]\n",
                "        for commit in truncated_commits:\n",
                "            short_id = commit['id'][:7]\n",
                "            (short_commit_msg, _, _) = commit['message'].partition(\"\\n\")\n",
                "            content += \"* [%s](%s): %s\\n\" % (short_id, commit['url'],\n",
                "                                             short_commit_msg)\n",
                "        if (num_commits > max_commits):\n",
                "            content += (\"\\n[and %d more commits]\"\n",
                "                        % (num_commits - max_commits,))\n",
                "\n",
                "    return (subject, content)\n",
                "\n",
                "@authenticated_api_view\n",
                "@has_request_variables\n",
                "def api_github_landing(request, user_profile, event=REQ,\n",
                "                       payload=REQ(converter=json_to_dict),\n",
                "                       branches=REQ(default=''),\n",
                "                       stream=REQ(default='')):\n",
                "    # TODO: this should all be moved to an external bot\n",
                "    repository = payload['repository']\n",
                "\n",
                "    if not stream:\n",
                "        stream = 'commits'\n",
                "\n",
                "    # CUSTOMER18 has requested not to get pull request notifications\n",
                "    if event == 'pull_request' and user_profile.realm.domain not in ['customer18.invalid', 'humbughq.com']:\n",
                "        pull_req = payload['pull_request']\n",
                "\n",
                "        subject = \"%s: pull request %d\" % (repository['name'],\n",
                "                                           pull_req['number'])\n",
                "        content = (\"Pull request from %s [%s](%s):\\n\\n %s\\n\\n> %s\"\n",
                "                   % (pull_req['user']['login'],\n",
                "                      payload['action'],\n",
                "                      pull_req['html_url'],\n",
                "                      pull_req['title'],\n",
                "                      pull_req['body']))\n",
                "    elif event == 'push':\n",
                "        short_ref = re.sub(r'^refs/heads/', '', payload['ref'])\n",
                "        # This is a bit hackish, but is basically so that CUSTOMER18 doesn't\n",
                "        # get spammed when people commit to non-master all over the place.\n",
                "        # Long-term, this will be replaced by some GitHub configuration\n",
                "        # option of which branches to notify on.\n",
                "        if short_ref != 'master' and user_profile.realm.domain in ['customer18.invalid', 'humbughq.com']:\n",
                "            return json_success()\n",
                "\n",
                "        if branches:\n",
                "            # If we are given a whitelist of branches, then we silently ignore\n",
                "            # any push notification on a branch that is not in our whitelist.\n",
                "            if short_ref not in re.split('[\\s,;|]+', branches):\n",
                "                return json_success()\n",
                "\n",
                "\n",
                "        subject, content = build_message_from_gitlog(user_profile, repository['name'],\n",
                "                                                     payload['ref'], payload['commits'],\n",
                "                                                     payload['before'], payload['after'],\n",
                "                                                     payload['compare'],\n",
                "                                                     payload['pusher']['name'])\n",
                "    else:\n",
                "        # We don't handle other events even though we get notified\n",
                "        # about them\n",
                "        return json_success()\n",
                "\n",
                "    subject = elide_subject(subject)\n",
                "\n",
                "    request.client = get_client(\"github_bot\")\n",
                "    return send_message_backend(request, user_profile,\n",
                "                                message_type_name=\"stream\",\n",
                "                                message_to=[stream],\n",
                "                                forged=False, subject_name=subject,\n",
                "                                message_content=content)\n",
                "\n",
                "def elide_subject(subject):\n",
                "    if len(subject) > MAX_SUBJECT_LENGTH:\n",
                "        subject = subject[:57].rstrip() + '...'\n",
                "    return subject\n",
                "\n",
                "@csrf_exempt\n",
                "def api_jira_webhook(request):\n",
                "    try:\n",
                "        api_key = request.GET['api_key']\n",
                "    except (AttributeError, KeyError):\n",
                "        return json_error(\"Missing api_key parameter.\")\n",
                "\n",
                "    try:\n",
                "        payload = ujson.loads(request.body)\n",
                "    except ValueError:\n",
                "        return json_error(\"Malformed JSON input\")\n",
                "\n",
                "    try:\n",
                "        stream = request.GET['stream']\n",
                "    except (AttributeError, KeyError):\n",
                "        stream = 'jira'\n",
                "\n",
                "    try:\n",
                "        user_profile = UserProfile.objects.get(api_key=api_key)\n",
                "        request.user = user_profile\n",
                "    except UserProfile.DoesNotExist:\n",
                "        return json_error(\"Failed to find user with API key: %s\" % (api_key,))\n",
                "\n",
                "    rate_limit_user(request, user_profile, domain='all')\n",
                "\n",
                "    def get_in(payload, keys, default=''):\n",
                "        try:\n",
                "            for key in keys:\n",
                "                payload = payload[key]\n",
                "        except (AttributeError, KeyError):\n",
                "            return default\n",
                "        return payload\n",
                "\n",
                "    event = payload.get('webhookEvent')\n",
                "    author = get_in(payload, ['user', 'displayName'])\n",
                "    issueId = get_in(payload, ['issue', 'key'])\n",
                "    # Guess the URL as it is not specified in the payload\n",
                "    # We assume that there is a /browse/BUG-### page\n",
                "    # from the REST url of the issue itself\n",
                "    baseUrl = re.match(\"(.*)\\/rest\\/api/.*\", get_in(payload, ['issue', 'self']))\n",
                "    if baseUrl and len(baseUrl.groups()):\n",
                "        issue = \"[%s](%s/browse/%s)\" % (issueId, baseUrl.group(1), issueId)\n",
                "    else:\n",
                "        issue = issueId\n",
                "    title = get_in(payload, ['issue', 'fields', 'summary'])\n",
                "    priority = get_in(payload, ['issue', 'fields', 'priority', 'name'])\n",
                "    assignee = get_in(payload, ['assignee', 'displayName'], 'no one')\n",
                "    subject = \"%s: %s\" % (issueId, title)\n",
                "\n",
                "    if event == 'jira:issue_created':\n",
                "        content = \"%s **created** %s priority %s, assigned to **%s**:\\n\\n> %s\" % \\\n",
                "                  (author, issue, priority, assignee, title)\n",
                "    elif event == 'jira:issue_deleted':\n",
                "        content = \"%s **deleted** %s!\" % \\\n",
                "                  (author, issue)\n",
                "    elif event == 'jira:issue_updated':\n",
                "        # Reassigned, commented, reopened, and resolved events are all bundled\n",
                "        # into this one 'updated' event type, so we try to extract the meaningful\n",
                "        # event that happened\n",
                "        content = \"%s **updated** %s:\\n\\n\" % (author, issue)\n",
                "        changelog = get_in(payload, ['changelog',])\n",
                "        comment = get_in(payload, ['comment', 'body'])\n",
                "\n",
                "        if changelog != '':\n",
                "            # Use the changelog to display the changes, whitelist types we accept\n",
                "            items = changelog.get('items')\n",
                "            for item in items:\n",
                "                field = item.get('field')\n",
                "                if field in ('status', 'assignee'):\n",
                "                    content += \"* Changed %s from **%s** to **%s**\\n\" % (field, item.get('fromString'), item.get('toString'))\n",
                "\n",
                "        if comment != '':\n",
                "            content += \"\\n> %s\" % (comment,)\n",
                "    elif 'transition' in payload:\n",
                "        from_status = get_in(payload, ['transition', 'from_status'])\n",
                "        to_status = get_in(payload, ['transition', 'to_status'])\n",
                "        content = \"%s **transitioned** %s from %s to %s\" % (author, issue, from_status, to_status)\n",
                "    else:\n",
                "        # Unknown event type\n",
                "        if not settings.TEST_SUITE:\n",
                "            logging.warning(\"Got JIRA event type we don't understand: %s\" % (event,))\n",
                "        return json_error(\"Unknown JIRA event type\")\n",
                "\n",
                "    subject = elide_subject(subject)\n",
                "\n",
                "    ret = check_send_message(user_profile, get_client(\"API\"), \"stream\", [stream], subject, content)\n",
                "    if ret is not None:\n",
                "        return json_error(ret)\n",
                "    return json_success()\n",
                "\n",
                "@csrf_exempt\n",
                "def api_pivotal_webhook(request):\n",
                "    try:\n",
                "        api_key = request.GET['api_key']\n",
                "        stream = request.GET['stream']\n",
                "    except (AttributeError, KeyError):\n",
                "        return json_error(\"Missing api_key or stream parameter.\")\n",
                "\n",
                "    try:\n",
                "        user_profile = UserProfile.objects.get(api_key=api_key)\n",
                "        request.user = user_profile\n",
                "    except UserProfile.DoesNotExist:\n",
                "        return json_error(\"Failed to find user with API key: %s\" % (api_key,))\n",
                "\n",
                "    rate_limit_user(request, user_profile, domain='all')\n",
                "\n",
                "    payload = xml_fromstring(request.body)\n",
                "\n",
                "    def get_text(attrs):\n",
                "        start = payload\n",
                "        try:\n",
                "            for attr in attrs:\n",
                "                start = start.find(attr)\n",
                "            return start.text\n",
                "        except AttributeError:\n",
                "            return \"\"\n",
                "\n",
                "    try:\n",
                "        event_type = payload.find('event_type').text\n",
                "        description = payload.find('description').text\n",
                "        project_id = payload.find('project_id').text\n",
                "        story_id = get_text(['stories', 'story', 'id'])\n",
                "        # Ugh, the URL in the XML data is not a clickable url that works for the user\n",
                "        # so we try to build one that the user can actually click on\n",
                "        url = \"https://www.pivotaltracker.com/s/projects/%s/stories/%s\" % (project_id, story_id)\n",
                "\n",
                "        # Pivotal doesn't tell us the name of the story, but it's usually in the\n",
                "        # description in quotes as the first quoted string\n",
                "        name_re = re.compile(r'[^\"]+\"([^\"]+)\".*')\n",
                "        match = name_re.match(description)\n",
                "        if match and len(match.groups()):\n",
                "            name = match.group(1)\n",
                "        else:\n",
                "            name = \"Story changed\" # Failed for an unknown reason, show something\n",
                "        more_info = \" [(view)](%s)\" % (url,)\n",
                "\n",
                "        if event_type == 'story_update':\n",
                "            subject = name\n",
                "            content = description + more_info\n",
                "        elif event_type == 'note_create':\n",
                "            subject = \"Comment added\"\n",
                "            content = description +  more_info\n",
                "        elif event_type == 'story_create':\n",
                "            issue_desc = get_text(['stories', 'story', 'description'])\n",
                "            issue_type = get_text(['stories', 'story', 'story_type'])\n",
                "            issue_status = get_text(['stories', 'story', 'current_state'])\n",
                "            estimate = get_text(['stories', 'story', 'estimate'])\n",
                "            if estimate != '':\n",
                "                estimate = \" worth %s story points\" % (estimate,)\n",
                "            subject = name\n",
                "            content = \"%s (%s %s%s):\\n\\n> %s\\n\\n%s\" % (description,\n",
                "                                                       issue_status,\n",
                "                                                       issue_type,\n",
                "                                                       estimate,\n",
                "                                                       issue_desc,\n",
                "                                                       more_info)\n",
                "\n",
                "    except AttributeError:\n",
                "        return json_error(\"Failed to extract data from Pivotal XML response\")\n",
                "\n",
                "    subject = elide_subject(subject)\n",
                "\n",
                "    ret = check_send_message(user_profile, get_client(\"API\"), \"stream\", [stream], subject, content)\n",
                "    if ret is not None:\n",
                "        return json_error(ret)\n",
                "    return json_success()\n",
                "\n",
                "# Beanstalk's web hook UI rejects url with a @ in the username section of a url\n",
                "# So we ask the user to replace them with %40\n",
                "# We manually fix the username here before passing it along to @authenticated_rest_api_view\n",
                "def beanstalk_decoder(view_func):\n",
                "    @wraps(view_func)\n",
                "    def _wrapped_view_func(request, *args, **kwargs):\n",
                "        try:\n",
                "            auth_type, encoded_value = request.META['HTTP_AUTHORIZATION'].split()\n",
                "            if auth_type.lower() == \"basic\":\n",
                "                email, api_key = base64.b64decode(encoded_value).split(\":\")\n",
                "                email = email.replace('%40', '@')\n",
                "                request.META['HTTP_AUTHORIZATION'] = \"Basic %s\" % (base64.b64encode(\"%s:%s\" % (email, api_key)))\n",
                "        except:\n",
                "            pass\n",
                "\n",
                "        return view_func(request, *args, **kwargs)\n",
                "\n",
                "    return _wrapped_view_func\n",
                "\n",
                "@csrf_exempt\n",
                "@beanstalk_decoder\n",
                "@authenticated_rest_api_view\n",
                "@has_request_variables\n",
                "def api_beanstalk_webhook(request, user_profile,\n",
                "                          payload=REQ(converter=json_to_dict)):\n",
                "    # Beanstalk supports both SVN and git repositories\n",
                "    # We distinguish between the two by checking for a\n",
                "    # 'uri' key that is only present for git repos\n",
                "    git_repo = 'uri' in payload\n",
                "    if git_repo:\n",
                "        # To get a linkable url,\n",
                "        subject, content = build_message_from_gitlog(user_profile, payload['repository']['name'],\n",
                "                                                     payload['ref'], payload['commits'],\n",
                "                                                     payload['before'], payload['after'],\n",
                "                                                     payload['repository']['url'],\n",
                "                                                     payload['pusher_name'])\n",
                "    else:\n",
                "        author = payload.get('author_full_name')\n",
                "        url = payload.get('changeset_url')\n",
                "        revision = payload.get('revision')\n",
                "        (short_commit_msg, _, _) = payload.get('message').partition(\"\\n\")\n",
                "\n",
                "        subject = \"svn r%s\" % (revision,)\n",
                "        content = \"%s pushed [revision %s](%s):\\n\\n> %s\" % (author, revision, url, short_commit_msg)\n",
                "\n",
                "    subject = elide_subject(subject)\n",
                "\n",
                "    ret = check_send_message(user_profile, get_client(\"API\"), \"stream\", [\"commits\"], subject, content)\n",
                "    if ret is not None:\n",
                "        return json_error(ret)\n",
                "    return json_success()\n",
                "\n",
                "def get_status_list(requesting_user_profile):\n",
                "    return {'presences': get_status_dict(requesting_user_profile),\n",
                "            'server_timestamp': time.time()}\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_update_active_status(request, user_profile, status=REQ):\n",
                "    status_val = UserPresence.status_from_string(status)\n",
                "    if status_val is None:\n",
                "        raise JsonableError(\"Invalid presence status: %s\" % (status,))\n",
                "    else:\n",
                "        update_user_presence(user_profile, request.client, now(), status_val)\n",
                "\n",
                "    ret = get_status_list(user_profile)\n",
                "    if user_profile.realm.domain == \"mit.edu\":\n",
                "        try:\n",
                "            # We renamed /api/v1/get_messages to /api/v1/events\n",
                "            try:\n",
                "                activity = UserActivity.objects.get(user_profile = user_profile,\n",
                "                                                    query=\"/api/v1/events\",\n",
                "                                                    client__name=\"zephyr_mirror\")\n",
                "            except UserActivity.DoesNotExist:\n",
                "                activity = UserActivity.objects.get(user_profile = user_profile,\n",
                "                                                    query=\"/api/v1/get_messages\",\n",
                "                                                    client__name=\"zephyr_mirror\")\n",
                "\n",
                "            ret['zephyr_mirror_active'] = \\\n",
                "                (activity.last_visit.replace(tzinfo=None) >\n",
                "                 datetime.datetime.utcnow() - datetime.timedelta(minutes=5))\n",
                "        except UserActivity.DoesNotExist:\n",
                "            ret['zephyr_mirror_active'] = False\n",
                "\n",
                "    return json_success(ret)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_get_active_statuses(request, user_profile):\n",
                "    return json_success(get_status_list(user_profile))\n",
                "\n",
                "# Read the source map information for decoding JavaScript backtraces\n",
                "js_source_map = None\n",
                "if not (settings.DEBUG or settings.TEST_SUITE):\n",
                "    js_source_map = SourceMap(path.join(\n",
                "        settings.SITE_ROOT, '../prod-static/source-map/app.js.map'))\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_report_error(request, user_profile, message=REQ, stacktrace=REQ,\n",
                "                      ui_message=REQ(converter=json_to_bool), user_agent=REQ,\n",
                "                      href=REQ,\n",
                "                      more_info=REQ(converter=json_to_dict, default=None)):\n",
                "    subject = \"error for %s\" % (user_profile.email,)\n",
                "    if ui_message:\n",
                "        subject = \"User-visible browser \" + subject\n",
                "    else:\n",
                "        subject = \"Browser \" + subject\n",
                "\n",
                "    if js_source_map:\n",
                "        stacktrace = js_source_map.annotate_stacktrace(stacktrace)\n",
                "\n",
                "    body = (\"Message:\\n%s\\n\\nStacktrace:\\n%s\\n\\nUser agent: %s\\nhref: %s\\n\"\n",
                "            \"User saw error in UI: %s\"\n",
                "            % (message, stacktrace, user_agent, href, ui_message))\n",
                "\n",
                "    if more_info is not None:\n",
                "        body += \"\\n\\nAdditional information:\"\n",
                "        for (key, value) in more_info.iteritems():\n",
                "            body += \"\\n  %s: %s\" % (key, value)\n",
                "\n",
                "    mail_admins(subject, body)\n",
                "    return json_success()\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_events_register(request, user_profile):\n",
                "    return events_register_backend(request, user_profile)\n",
                "\n",
                "# Does not need to be authenticated because it's called from rest_dispatch\n",
                "@has_request_variables\n",
                "def api_events_register(request, user_profile,\n",
                "                        apply_markdown=REQ(default=False, converter=json_to_bool)):\n",
                "    return events_register_backend(request, user_profile,\n",
                "                                   apply_markdown=apply_markdown)\n",
                "\n",
                "@has_request_variables\n",
                "def events_register_backend(request, user_profile, apply_markdown=True,\n",
                "                            event_types=REQ(converter=json_to_list, default=None)):\n",
                "    ret = do_events_register(user_profile, request.client, apply_markdown,\n",
                "                             event_types)\n",
                "    return json_success(ret)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_messages_in_narrow(request, user_profile):\n",
                "    return messages_in_narrow_backend(request, user_profile)\n",
                "\n",
                "@has_request_variables\n",
                "def messages_in_narrow_backend(request, user_profile, msg_ids = REQ(converter=json_to_list),\n",
                "                               narrow = REQ(converter=narrow_parameter)):\n",
                "    # Note that this function will only work on messages the user\n",
                "    # actually received\n",
                "\n",
                "    query = UserMessage.objects.select_related(\"message\") \\\n",
                "                               .filter(user_profile=user_profile, message__id__in=msg_ids)\n",
                "    build = NarrowBuilder(user_profile, \"message__\")\n",
                "    for operator, operand in narrow:\n",
                "        query = build(query, operator, operand)\n",
                "\n",
                "    return json_success({\"messages\": dict((msg.message.id,\n",
                "                                           {'match_subject': msg.match_subject,\n",
                "                                            'match_content': msg.match_content})\n",
                "                                          for msg in query.iterator())})\n",
                "\n",
                "@authenticated_json_post_view\n",
                "@has_request_variables\n",
                "def json_create_bot(request, user_profile, full_name=REQ, short_name=REQ):\n",
                "    short_name += \"-bot\"\n",
                "    email = short_name + \"@\" + user_profile.realm.domain\n",
                "    form = CreateBotForm({'full_name': full_name, 'email': email})\n",
                "    if not form.is_valid():\n",
                "        # We validate client-side as well\n",
                "        return json_error('Bad name or username')\n",
                "\n",
                "    try:\n",
                "        get_user_profile_by_email(email)\n",
                "        return json_error(\"Username already in use\")\n",
                "    except UserProfile.DoesNotExist:\n",
                "        pass\n",
                "\n",
                "    if len(request.FILES) == 0:\n",
                "        avatar_source = UserProfile.AVATAR_FROM_GRAVATAR\n",
                "    elif len(request.FILES) != 1:\n",
                "        return json_error(\"You may only upload one file at a time\")\n",
                "    else:\n",
                "        user_file = request.FILES.values()[0]\n",
                "        upload_avatar_image(user_file, user_profile, email)\n",
                "        avatar_source = UserProfile.AVATAR_FROM_USER\n",
                "\n",
                "    bot_profile = do_create_user(email, '', user_profile.realm, full_name,\n",
                "                                 short_name, True, True,\n",
                "                                 user_profile, avatar_source)\n",
                "    json_result = dict(\n",
                "            api_key=bot_profile.api_key,\n",
                "            avatar_url=avatar_url(bot_profile)\n",
                "    )\n",
                "    return json_success(json_result)\n",
                "\n",
                "@authenticated_json_post_view\n",
                "def json_get_bots(request, user_profile):\n",
                "    bot_profiles = UserProfile.objects.filter(is_bot=True, is_active=True,\n",
                "                                              bot_owner=user_profile)\n",
                "    def bot_info(bot_profile):\n",
                "        return dict(\n",
                "                username   = bot_profile.email,\n",
                "                full_name  = bot_profile.full_name,\n",
                "                api_key    = bot_profile.api_key,\n",
                "                avatar_url = avatar_url(bot_profile)\n",
                "        )\n",
                "\n",
                "    return json_success({'bots': map(bot_info, bot_profiles)})"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "def and use and refactor"
        },
        {
            "edit_hunk_pair": [
                0,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                0,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                0,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                2,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                2,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                2,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                2,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                3,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "same intention in different if condition branch"
        },
        {
            "edit_hunk_pair": [
                3,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                3,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "same intention in different if condition branch"
        },
        {
            "edit_hunk_pair": [
                4,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                5,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                5,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        },
        {
            "edit_hunk_pair": [
                6,
                7
            ],
            "edit_order": "bi-directional",
            "reason": "data flow"
        }
    ]
}