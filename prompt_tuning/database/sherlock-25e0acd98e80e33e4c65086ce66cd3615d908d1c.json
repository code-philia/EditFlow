{
    "language": "python",
    "commit_url": "https://github.com/sherlock-project/sherlock/commit/25e0acd98e80e33e4c65086ce66cd3615d908d1c",
    "commit_message": "Skip content filter for explicitly chosen targets\n\nTargets specified via --site will no longer be excluded when --nsfw is not set, even if flagged as nsfw. If the target was specifically listed by the user, it's probably because they want that target.\n\nFixes sherlock-project/sherlock#2103",
    "commit_snapshots": {
        "sherlock/sherlock.py": [
            [
                "#! /usr/bin/env python3\n",
                "\n",
                "\"\"\"\n",
                "Sherlock: Find Usernames Across Social Networks Module\n",
                "\n",
                "This module contains the main logic to search for usernames at social\n",
                "networks.\n",
                "\"\"\"\n",
                "\n",
                "import csv\n",
                "import signal\n",
                "import pandas as pd\n",
                "import os\n",
                "import platform\n",
                "import re\n",
                "import sys\n",
                "from argparse import ArgumentParser, RawDescriptionHelpFormatter\n",
                "from time import monotonic\n",
                "\n",
                "import requests\n",
                "\n",
                "from requests_futures.sessions import FuturesSession\n",
                "from torrequest import TorRequest\n",
                "from result import QueryStatus\n",
                "from result import QueryResult\n",
                "from notify import QueryNotifyPrint\n",
                "from sites import SitesInformation\n",
                "from colorama import init\n",
                "from argparse import ArgumentTypeError\n",
                "\n",
                "module_name = \"Sherlock: Find Usernames Across Social Networks\"\n",
                "__version__ = \"0.14.3\"\n",
                "\n",
                "\n",
                "class SherlockFuturesSession(FuturesSession):\n",
                "    def request(self, method, url, hooks=None, *args, **kwargs):\n",
                "        \"\"\"Request URL.\n",
                "\n",
                "        This extends the FuturesSession request method to calculate a response\n",
                "        time metric to each request.\n",
                "\n",
                "        It is taken (almost) directly from the following Stack Overflow answer:\n",
                "        https://github.com/ross/requests-futures#working-in-the-background\n",
                "\n",
                "        Keyword Arguments:\n",
                "        self                   -- This object.\n",
                "        method                 -- String containing method desired for request.\n",
                "        url                    -- String containing URL for request.\n",
                "        hooks                  -- Dictionary containing hooks to execute after\n",
                "                                  request finishes.\n",
                "        args                   -- Arguments.\n",
                "        kwargs                 -- Keyword arguments.\n",
                "\n",
                "        Return Value:\n",
                "        Request object.\n",
                "        \"\"\"\n",
                "        # Record the start time for the request.\n",
                "        if hooks is None:\n",
                "            hooks = {}\n",
                "        start = monotonic()\n",
                "\n",
                "        def response_time(resp, *args, **kwargs):\n",
                "            \"\"\"Response Time Hook.\n",
                "\n",
                "            Keyword Arguments:\n",
                "            resp                   -- Response object.\n",
                "            args                   -- Arguments.\n",
                "            kwargs                 -- Keyword arguments.\n",
                "\n",
                "            Return Value:\n",
                "            Nothing.\n",
                "            \"\"\"\n",
                "            resp.elapsed = monotonic() - start\n",
                "\n",
                "            return\n",
                "\n",
                "        # Install hook to execute when response completes.\n",
                "        # Make sure that the time measurement hook is first, so we will not\n",
                "        # track any later hook's execution time.\n",
                "        try:\n",
                "            if isinstance(hooks[\"response\"], list):\n",
                "                hooks[\"response\"].insert(0, response_time)\n",
                "            elif isinstance(hooks[\"response\"], tuple):\n",
                "                # Convert tuple to list and insert time measurement hook first.\n",
                "                hooks[\"response\"] = list(hooks[\"response\"])\n",
                "                hooks[\"response\"].insert(0, response_time)\n",
                "            else:\n",
                "                # Must have previously contained a single hook function,\n",
                "                # so convert to list.\n",
                "                hooks[\"response\"] = [response_time, hooks[\"response\"]]\n",
                "        except KeyError:\n",
                "            # No response hook was already defined, so install it ourselves.\n",
                "            hooks[\"response\"] = [response_time]\n",
                "\n",
                "        return super(SherlockFuturesSession, self).request(\n",
                "            method, url, hooks=hooks, *args, **kwargs\n",
                "        )\n",
                "\n",
                "\n",
                "def get_response(request_future, error_type, social_network):\n",
                "    # Default for Response object if some failure occurs.\n",
                "    response = None\n",
                "\n",
                "    error_context = \"General Unknown Error\"\n",
                "    exception_text = None\n",
                "    try:\n",
                "        response = request_future.result()\n",
                "        if response.status_code:\n",
                "            # Status code exists in response object\n",
                "            error_context = None\n",
                "    except requests.exceptions.HTTPError as errh:\n",
                "        error_context = \"HTTP Error\"\n",
                "        exception_text = str(errh)\n",
                "    except requests.exceptions.ProxyError as errp:\n",
                "        error_context = \"Proxy Error\"\n",
                "        exception_text = str(errp)\n",
                "    except requests.exceptions.ConnectionError as errc:\n",
                "        error_context = \"Error Connecting\"\n",
                "        exception_text = str(errc)\n",
                "    except requests.exceptions.Timeout as errt:\n",
                "        error_context = \"Timeout Error\"\n",
                "        exception_text = str(errt)\n",
                "    except requests.exceptions.RequestException as err:\n",
                "        error_context = \"Unknown Error\"\n",
                "        exception_text = str(err)\n",
                "\n",
                "    return response, error_context, exception_text\n",
                "\n",
                "\n",
                "def interpolate_string(input_object, username):\n",
                "    if isinstance(input_object, str):\n",
                "        return input_object.replace(\"{}\", username)\n",
                "    elif isinstance(input_object, dict):\n",
                "        return {k: interpolate_string(v, username) for k, v in input_object.items()}\n",
                "    elif isinstance(input_object, list):\n",
                "        return [interpolate_string(i, username) for i in input_object]\n",
                "    return input_object\n",
                "\n",
                "\n",
                "def check_for_parameter(username):\n",
                "    \"\"\"checks if {?} exists in the username\n",
                "    if exist it means that sherlock is looking for more multiple username\"\"\"\n",
                "    return \"{?}\" in username\n",
                "\n",
                "\n",
                "checksymbols = []\n",
                "checksymbols = [\"_\", \"-\", \".\"]\n",
                "\n",
                "\n",
                "def multiple_usernames(username):\n",
                "    \"\"\"replace the parameter with with symbols and return a list of usernames\"\"\"\n",
                "    allUsernames = []\n",
                "    for i in checksymbols:\n",
                "        allUsernames.append(username.replace(\"{?}\", i))\n",
                "    return allUsernames\n",
                "\n",
                "\n",
                "def sherlock(\n",
                "    username,\n",
                "    site_data,\n",
                "    query_notify,\n",
                "    tor=False,\n",
                "    unique_tor=False,\n",
                "    proxy=None,\n",
                "    timeout=60,\n",
                "):\n",
                "    \"\"\"Run Sherlock Analysis.\n",
                "\n",
                "    Checks for existence of username on various social media sites.\n",
                "\n",
                "    Keyword Arguments:\n",
                "    username               -- String indicating username that report\n",
                "                              should be created against.\n",
                "    site_data              -- Dictionary containing all of the site data.\n",
                "    query_notify           -- Object with base type of QueryNotify().\n",
                "                              This will be used to notify the caller about\n",
                "                              query results.\n",
                "    tor                    -- Boolean indicating whether to use a tor circuit for the requests.\n",
                "    unique_tor             -- Boolean indicating whether to use a new tor circuit for each request.\n",
                "    proxy                  -- String indicating the proxy URL\n",
                "    timeout                -- Time in seconds to wait before timing out request.\n",
                "                              Default is 60 seconds.\n",
                "\n",
                "    Return Value:\n",
                "    Dictionary containing results from report. Key of dictionary is the name\n",
                "    of the social network site, and the value is another dictionary with\n",
                "    the following keys:\n",
                "        url_main:      URL of main site.\n",
                "        url_user:      URL of user on site (if account exists).\n",
                "        status:        QueryResult() object indicating results of test for\n",
                "                       account existence.\n",
                "        http_status:   HTTP status code of query which checked for existence on\n",
                "                       site.\n",
                "        response_text: Text that came back from request.  May be None if\n",
                "                       there was an HTTP error when checking for existence.\n",
                "    \"\"\"\n",
                "\n",
                "    # Notify caller that we are starting the query.\n",
                "    query_notify.start(username)\n",
                "    # Create session based on request methodology\n",
                "    if tor or unique_tor:\n",
                "        # Requests using Tor obfuscation\n",
                "        underlying_request = TorRequest()\n",
                "        underlying_session = underlying_request.session\n",
                "    else:\n",
                "        # Normal requests\n",
                "        underlying_session = requests.session()\n",
                "        underlying_request = requests.Request()\n",
                "\n",
                "    # Limit number of workers to 20.\n",
                "    # This is probably vastly overkill.\n",
                "    if len(site_data) >= 20:\n",
                "        max_workers = 20\n",
                "    else:\n",
                "        max_workers = len(site_data)\n",
                "\n",
                "    # Create multi-threaded session for all requests.\n",
                "    session = SherlockFuturesSession(\n",
                "        max_workers=max_workers, session=underlying_session\n",
                "    )\n",
                "\n",
                "    # Results from analysis of all sites\n",
                "    results_total = {}\n",
                "\n",
                "    # First create futures for all requests. This allows for the requests to run in parallel\n",
                "    for social_network, net_info in site_data.items():\n",
                "        # Results from analysis of this specific site\n",
                "        results_site = {\"url_main\": net_info.get(\"urlMain\")}\n",
                "\n",
                "        # Record URL of main site\n",
                "\n",
                "        # A user agent is needed because some sites don't return the correct\n",
                "        # information since they think that we are bots (Which we actually are...)\n",
                "        headers = {\n",
                "            \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/116.0\",\n",
                "        }\n",
                "\n",
                "        if \"headers\" in net_info:\n",
                "            # Override/append any extra headers required by a given site.\n",
                "            headers.update(net_info[\"headers\"])\n",
                "\n",
                "        # URL of user on site (if it exists)\n",
                "        url = interpolate_string(net_info[\"url\"], username)\n",
                "\n",
                "        # Don't make request if username is invalid for the site\n",
                "        regex_check = net_info.get(\"regexCheck\")\n",
                "        if regex_check and re.search(regex_check, username) is None:\n",
                "            # No need to do the check at the site: this username is not allowed.\n",
                "            results_site[\"status\"] = QueryResult(\n",
                "                username, social_network, url, QueryStatus.ILLEGAL\n",
                "            )\n",
                "            results_site[\"url_user\"] = \"\"\n",
                "            results_site[\"http_status\"] = \"\"\n",
                "            results_site[\"response_text\"] = \"\"\n",
                "            query_notify.update(results_site[\"status\"])\n",
                "        else:\n",
                "            # URL of user on site (if it exists)\n",
                "            results_site[\"url_user\"] = url\n",
                "            url_probe = net_info.get(\"urlProbe\")\n",
                "            request_method = net_info.get(\"request_method\")\n",
                "            request_payload = net_info.get(\"request_payload\")\n",
                "            request = None\n",
                "\n",
                "            if request_method is not None:\n",
                "                if request_method == \"GET\":\n",
                "                    request = session.get\n",
                "                elif request_method == \"HEAD\":\n",
                "                    request = session.head\n",
                "                elif request_method == \"POST\":\n",
                "                    request = session.post\n",
                "                elif request_method == \"PUT\":\n",
                "                    request = session.put\n",
                "                else:\n",
                "                    raise RuntimeError(f\"Unsupported request_method for {url}\")\n",
                "\n",
                "            if request_payload is not None:\n",
                "                request_payload = interpolate_string(request_payload, username)\n",
                "\n",
                "            if url_probe is None:\n",
                "                # Probe URL is normal one seen by people out on the web.\n",
                "                url_probe = url\n",
                "            else:\n",
                "                # There is a special URL for probing existence separate\n",
                "                # from where the user profile normally can be found.\n",
                "                url_probe = interpolate_string(url_probe, username)\n",
                "\n",
                "            if request is None:\n",
                "                if net_info[\"errorType\"] == \"status_code\":\n",
                "                    # In most cases when we are detecting by status code,\n",
                "                    # it is not necessary to get the entire body:  we can\n",
                "                    # detect fine with just the HEAD response.\n",
                "                    request = session.head\n",
                "                else:\n",
                "                    # Either this detect method needs the content associated\n",
                "                    # with the GET response, or this specific website will\n",
                "                    # not respond properly unless we request the whole page.\n",
                "                    request = session.get\n",
                "\n",
                "            if net_info[\"errorType\"] == \"response_url\":\n",
                "                # Site forwards request to a different URL if username not\n",
                "                # found.  Disallow the redirect so we can capture the\n",
                "                # http status from the original URL request.\n",
                "                allow_redirects = False\n",
                "            else:\n",
                "                # Allow whatever redirect that the site wants to do.\n",
                "                # The final result of the request will be what is available.\n",
                "                allow_redirects = True\n",
                "\n",
                "            # This future starts running the request in a new thread, doesn't block the main thread\n",
                "            if proxy is not None:\n",
                "                proxies = {\"http\": proxy, \"https\": proxy}\n",
                "                future = request(\n",
                "                    url=url_probe,\n",
                "                    headers=headers,\n",
                "                    proxies=proxies,\n",
                "                    allow_redirects=allow_redirects,\n",
                "                    timeout=timeout,\n",
                "                    json=request_payload,\n",
                "                )\n",
                "            else:\n",
                "                future = request(\n",
                "                    url=url_probe,\n",
                "                    headers=headers,\n",
                "                    allow_redirects=allow_redirects,\n",
                "                    timeout=timeout,\n",
                "                    json=request_payload,\n",
                "                )\n",
                "\n",
                "            # Store future in data for access later\n",
                "            net_info[\"request_future\"] = future\n",
                "\n",
                "            # Reset identify for tor (if needed)\n",
                "            if unique_tor:\n",
                "                underlying_request.reset_identity()\n",
                "\n",
                "        # Add this site's results into final dictionary with all the other results.\n",
                "        results_total[social_network] = results_site\n",
                "\n",
                "    # Open the file containing account links\n",
                "    # Core logic: If tor requests, make them here. If multi-threaded requests, wait for responses\n",
                "    for social_network, net_info in site_data.items():\n",
                "        # Retrieve results again\n",
                "        results_site = results_total.get(social_network)\n",
                "\n",
                "        # Retrieve other site information again\n",
                "        url = results_site.get(\"url_user\")\n",
                "        status = results_site.get(\"status\")\n",
                "        if status is not None:\n",
                "            # We have already determined the user doesn't exist here\n",
                "            continue\n",
                "\n",
                "        # Get the expected error type\n",
                "        error_type = net_info[\"errorType\"]\n",
                "\n",
                "        # Retrieve future and ensure it has finished\n",
                "        future = net_info[\"request_future\"]\n",
                "        r, error_text, exception_text = get_response(\n",
                "            request_future=future, error_type=error_type, social_network=social_network\n",
                "        )\n",
                "\n",
                "        # Get response time for response of our request.\n",
                "        try:\n",
                "            response_time = r.elapsed\n",
                "        except AttributeError:\n",
                "            response_time = None\n",
                "\n",
                "        # Attempt to get request information\n",
                "        try:\n",
                "            http_status = r.status_code\n",
                "        except Exception:\n",
                "            http_status = \"?\"\n",
                "        try:\n",
                "            response_text = r.text.encode(r.encoding or \"UTF-8\")\n",
                "        except Exception:\n",
                "            response_text = \"\"\n",
                "\n",
                "        query_status = QueryStatus.UNKNOWN\n",
                "        error_context = None\n",
                "\n",
                "        # As WAFs advance and evolve, they will occasionally block Sherlock and lead to false positives\n",
                "        # and negatives. Fingerprints should be added here to filter results that fail to bypass WAFs.\n",
                "        # Fingerprints should be highly targetted. Comment at the end of each fingerprint to indicate target and date.\n",
                "        WAFHitMsgs = [\n",
                "            '.loading-spinner{visibility:hidden}body.no-js .challenge-running{display:none}body.dark{background-color:#222;color:#d9d9d9}body.dark a{color:#fff}body.dark a:hover{color:#ee730a;text-decoration:underline}body.dark .lds-ring div{border-color:#999 transparent transparent}body.dark .font-red{color:#b20f03}body.dark .big-button,body.dark .pow-button{background-color:#4693ff;color:#1d1d1d}body.dark #challenge-success-text{background-image:url(data:image/svg+xml;base64,', # 2024-04-08 Cloudflare\n",
                "            '{return l.onPageView}}),Object.defineProperty(r,\"perimeterxIdentifiers\",{enumerable:' # 2024-04-09 PerimeterX / Human Security\n",
                "        ]\n",
                "\n",
                "        if error_text is not None:\n",
                "            error_context = error_text\n",
                "\n",
                "        elif any(hitMsg in r.text for hitMsg in WAFHitMsgs):\n",
                "            query_status = QueryStatus.WAF\n",
                "\n",
                "        elif error_type == \"message\":\n",
                "            # error_flag True denotes no error found in the HTML\n",
                "            # error_flag False denotes error found in the HTML\n",
                "            error_flag = True\n",
                "            errors = net_info.get(\"errorMsg\")\n",
                "            # errors will hold the error message\n",
                "            # it can be string or list\n",
                "            # by isinstance method we can detect that\n",
                "            # and handle the case for strings as normal procedure\n",
                "            # and if its list we can iterate the errors\n",
                "            if isinstance(errors, str):\n",
                "                # Checks if the error message is in the HTML\n",
                "                # if error is present we will set flag to False\n",
                "                if errors in r.text:\n",
                "                    error_flag = False\n",
                "            else:\n",
                "                # If it's list, it will iterate all the error message\n",
                "                for error in errors:\n",
                "                    if error in r.text:\n",
                "                        error_flag = False\n",
                "                        break\n",
                "            if error_flag:\n",
                "                query_status = QueryStatus.CLAIMED\n",
                "            else:\n",
                "                query_status = QueryStatus.AVAILABLE\n",
                "        elif error_type == \"status_code\":\n",
                "            error_codes = net_info.get(\"errorCode\")\n",
                "            query_status = QueryStatus.CLAIMED\n",
                "\n",
                "            # Type consistency, allowing for both singlets and lists in manifest\n",
                "            if isinstance(error_codes, int):\n",
                "                error_codes = [error_codes]\n",
                "            \n",
                "            if error_codes is not None and r.status_code in error_codes:\n",
                "                query_status = QueryStatus.AVAILABLE\n",
                "            elif r.status_code >= 300 or r.status_code < 200:\n",
                "                query_status = QueryStatus.AVAILABLE\n",
                "        elif error_type == \"response_url\":\n",
                "            # For this detection method, we have turned off the redirect.\n",
                "            # So, there is no need to check the response URL: it will always\n",
                "            # match the request.  Instead, we will ensure that the response\n",
                "            # code indicates that the request was successful (i.e. no 404, or\n",
                "            # forward to some odd redirect).\n",
                "            if 200 <= r.status_code < 300:\n",
                "                query_status = QueryStatus.CLAIMED\n",
                "            else:\n",
                "                query_status = QueryStatus.AVAILABLE\n",
                "        else:\n",
                "            # It should be impossible to ever get here...\n",
                "            raise ValueError(\n",
                "                f\"Unknown Error Type '{error_type}' for \" f\"site '{social_network}'\"\n",
                "            )\n",
                "\n",
                "        # Notify caller about results of query.\n",
                "        result = QueryResult(\n",
                "            username=username,\n",
                "            site_name=social_network,\n",
                "            site_url_user=url,\n",
                "            status=query_status,\n",
                "            query_time=response_time,\n",
                "            context=error_context,\n",
                "        )\n",
                "        query_notify.update(result)\n",
                "\n",
                "        # Save status of request\n",
                "        results_site[\"status\"] = result\n",
                "\n",
                "        # Save results from request\n",
                "        results_site[\"http_status\"] = http_status\n",
                "        results_site[\"response_text\"] = response_text\n",
                "\n",
                "        # Add this site's results into final dictionary with all of the other results.\n",
                "        results_total[social_network] = results_site\n",
                "\n",
                "    return results_total\n",
                "\n",
                "\n",
                "def timeout_check(value):\n",
                "    \"\"\"Check Timeout Argument.\n",
                "\n",
                "    Checks timeout for validity.\n",
                "\n",
                "    Keyword Arguments:\n",
                "    value                  -- Time in seconds to wait before timing out request.\n",
                "\n",
                "    Return Value:\n",
                "    Floating point number representing the time (in seconds) that should be\n",
                "    used for the timeout.\n",
                "\n",
                "    NOTE:  Will raise an exception if the timeout in invalid.\n",
                "    \"\"\"\n",
                "\n",
                "    float_value = float(value)\n",
                "\n",
                "    if float_value <= 0:\n",
                "        raise ArgumentTypeError(\n",
                "            f\"Invalid timeout value: {value}. Timeout must be a positive number.\"\n",
                "        )\n",
                "\n",
                "    return float_value\n",
                "\n",
                "\n",
                "def handler(signal_received, frame):\n",
                "    \"\"\"Exit gracefully without throwing errors\n",
                "\n",
                "    Source: https://www.devdungeon.com/content/python-catch-sigint-ctrl-c\n",
                "    \"\"\"\n",
                "    sys.exit(0)\n",
                "\n",
                "\n",
                "def main():\n",
                "    version_string = (\n",
                "        f\"%(prog)s {__version__}\\n\"\n",
                "        + f\"{requests.__description__}:  {requests.__version__}\\n\"\n",
                "        + f\"Python:  {platform.python_version()}\"\n",
                "    )\n",
                "\n",
                "    parser = ArgumentParser(\n",
                "        formatter_class=RawDescriptionHelpFormatter,\n",
                "        description=f\"{module_name} (Version {__version__})\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--version\",\n",
                "        action=\"version\",\n",
                "        version=version_string,\n",
                "        help=\"Display version information and dependencies.\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--verbose\",\n",
                "        \"-v\",\n",
                "        \"-d\",\n",
                "        \"--debug\",\n",
                "        action=\"store_true\",\n",
                "        dest=\"verbose\",\n",
                "        default=False,\n",
                "        help=\"Display extra debugging information and metrics.\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--folderoutput\",\n",
                "        \"-fo\",\n",
                "        dest=\"folderoutput\",\n",
                "        help=\"If using multiple usernames, the output of the results will be saved to this folder.\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--output\",\n",
                "        \"-o\",\n",
                "        dest=\"output\",\n",
                "        help=\"If using single username, the output of the result will be saved to this file.\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--tor\",\n",
                "        \"-t\",\n",
                "        action=\"store_true\",\n",
                "        dest=\"tor\",\n",
                "        default=False,\n",
                "        help=\"Make requests over Tor; increases runtime; requires Tor to be installed and in system path.\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--unique-tor\",\n",
                "        \"-u\",\n",
                "        action=\"store_true\",\n",
                "        dest=\"unique_tor\",\n",
                "        default=False,\n",
                "        help=\"Make requests over Tor with new Tor circuit after each request; increases runtime; requires Tor to be installed and in system path.\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--csv\",\n",
                "        action=\"store_true\",\n",
                "        dest=\"csv\",\n",
                "        default=False,\n",
                "        help=\"Create Comma-Separated Values (CSV) File.\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--xlsx\",\n",
                "        action=\"store_true\",\n",
                "        dest=\"xlsx\",\n",
                "        default=False,\n",
                "        help=\"Create the standard file for the modern Microsoft Excel spreadsheet (xlsx).\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--site\",\n",
                "        action=\"append\",\n",
                "        metavar=\"SITE_NAME\",\n",
                "        dest=\"site_list\",\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        default=None,\n"
                ],
                "after": [
                    "        default=[],\n"
                ],
                "parent_version_range": {
                    "start": 577,
                    "end": 578
                },
                "child_version_range": {
                    "start": 577,
                    "end": 578
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "main",
                        "signature": "def main():",
                        "at_line": 503
                    },
                    {
                        "type": "call",
                        "name": "parser.add_argument",
                        "signature": "parser.add_argument(\n        \"--site\",\n        action=\"append\",\n        metavar=\"SITE_NAME\",\n        dest=\"site_list\",\n        default=None,\n        help=\"Limit analysis to just the listed sites. Add multiple options to specify more than one site.\",\n    )",
                        "at_line": 572,
                        "argument": "default=..."
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: sherlock/sherlock.py\nCode:\n           def main():\n               ...\n               parser.add_argument(\n        \"--site\",\n        action=\"append\",\n        metavar=\"SITE_NAME\",\n        dest=\"site_list\",\n        default=None,\n        help=\"Limit analysis to just the listed sites. Add multiple options to specify more than one site.\",\n    )\n                   ...\n574 574            action=\"append\",\n575 575            metavar=\"SITE_NAME\",\n576 576            dest=\"site_list\",\n577      -         default=None,\n    577  +         default=[],\n578 578            help=\"Limit analysis to just the listed sites. Add multiple options to specify more than one site.\",\n579 579        )\n580 580        parser.add_argument(\n         ...\n",
                "file_path": "sherlock/sherlock.py",
                "identifiers_before": [
                    "default"
                ],
                "identifiers_after": [
                    "default"
                ],
                "prefix": [
                    "        action=\"append\",\n",
                    "        metavar=\"SITE_NAME\",\n",
                    "        dest=\"site_list\",\n"
                ],
                "suffix": [
                    "        help=\"Limit analysis to just the listed sites. Add multiple options to specify more than one site.\",\n",
                    "    )\n",
                    "    parser.add_argument(\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        help=\"Limit analysis to just the listed sites. Add multiple options to specify more than one site.\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--proxy\",\n",
                "        \"-p\",\n",
                "        metavar=\"PROXY_URL\",\n",
                "        action=\"store\",\n",
                "        dest=\"proxy\",\n",
                "        default=None,\n",
                "        help=\"Make requests over a proxy. e.g. socks5://127.0.0.1:1080\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--json\",\n",
                "        \"-j\",\n",
                "        metavar=\"JSON_FILE\",\n",
                "        dest=\"json_file\",\n",
                "        default=None,\n",
                "        help=\"Load data from a JSON file or an online, valid, JSON file.\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--timeout\",\n",
                "        action=\"store\",\n",
                "        metavar=\"TIMEOUT\",\n",
                "        dest=\"timeout\",\n",
                "        type=timeout_check,\n",
                "        default=60,\n",
                "        help=\"Time (in seconds) to wait for response to requests (Default: 60)\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--print-all\",\n",
                "        action=\"store_true\",\n",
                "        dest=\"print_all\",\n",
                "        default=False,\n",
                "        help=\"Output sites where the username was not found.\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--print-found\",\n",
                "        action=\"store_true\",\n",
                "        dest=\"print_found\",\n",
                "        default=True,\n",
                "        help=\"Output sites where the username was found (also if exported as file).\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--no-color\",\n",
                "        action=\"store_true\",\n",
                "        dest=\"no_color\",\n",
                "        default=False,\n",
                "        help=\"Don't color terminal output\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"username\",\n",
                "        nargs=\"+\",\n",
                "        metavar=\"USERNAMES\",\n",
                "        action=\"store\",\n",
                "        help=\"One or more usernames to check with social networks. Check similar usernames using {?} (replace to '_', '-', '.').\",\n",
                "    )\n",
                "    parser.add_argument(\n",
                "        \"--browse\",\n",
                "        \"-b\",\n",
                "        action=\"store_true\",\n",
                "        dest=\"browse\",\n",
                "        default=False,\n",
                "        help=\"Browse to all results on default browser.\",\n",
                "    )\n",
                "\n",
                "    parser.add_argument(\n",
                "        \"--local\",\n",
                "        \"-l\",\n",
                "        action=\"store_true\",\n",
                "        default=False,\n",
                "        help=\"Force the use of the local data.json file.\",\n",
                "    )\n",
                "\n",
                "    parser.add_argument(\n",
                "        \"--nsfw\",\n",
                "        action=\"store_true\",\n",
                "        default=False,\n",
                "        help=\"Include checking of NSFW sites from default list.\",\n",
                "    )\n",
                "\n",
                "    args = parser.parse_args()\n",
                "\n",
                "    # If the user presses CTRL-C, exit gracefully without throwing errors\n",
                "    signal.signal(signal.SIGINT, handler)\n",
                "\n",
                "    # Check for newer version of Sherlock. If it exists, let the user know about it\n",
                "    try:\n",
                "        r = requests.get(\n",
                "            \"https://raw.githubusercontent.com/sherlock-project/sherlock/master/sherlock/sherlock.py\"\n",
                "        )\n",
                "\n",
                "        remote_version = str(re.findall('__version__ = \"(.*)\"', r.text)[0])\n",
                "        local_version = __version__\n",
                "\n",
                "        if remote_version != local_version:\n",
                "            print(\n",
                "                \"Update Available!\\n\"\n",
                "                + f\"You are running version {local_version}. Version {remote_version} is available at https://github.com/sherlock-project/sherlock\"\n",
                "            )\n",
                "\n",
                "    except Exception as error:\n",
                "        print(f\"A problem occurred while checking for an update: {error}\")\n",
                "\n",
                "    # Argument check\n",
                "    # TODO regex check on args.proxy\n",
                "    if args.tor and (args.proxy is not None):\n",
                "        raise Exception(\"Tor and Proxy cannot be set at the same time.\")\n",
                "\n",
                "    # Make prompts\n",
                "    if args.proxy is not None:\n",
                "        print(\"Using the proxy: \" + args.proxy)\n",
                "\n",
                "    if args.tor or args.unique_tor:\n",
                "        print(\"Using Tor to make requests\")\n",
                "\n",
                "        print(\n",
                "            \"Warning: some websites might refuse connecting over Tor, so note that using this option might increase connection errors.\"\n",
                "        )\n",
                "\n",
                "    if args.no_color:\n",
                "        # Disable color output.\n",
                "        init(strip=True, convert=False)\n",
                "    else:\n",
                "        # Enable color output.\n",
                "        init(autoreset=True)\n",
                "\n",
                "    # Check if both output methods are entered as input.\n",
                "    if args.output is not None and args.folderoutput is not None:\n",
                "        print(\"You can only use one of the output methods.\")\n",
                "        sys.exit(1)\n",
                "\n",
                "    # Check validity for single username output.\n",
                "    if args.output is not None and len(args.username) != 1:\n",
                "        print(\"You can only use --output with a single username\")\n",
                "        sys.exit(1)\n",
                "\n",
                "    # Create object with all information about sites we are aware of.\n",
                "    try:\n",
                "        if args.local:\n",
                "            sites = SitesInformation(\n",
                "                os.path.join(os.path.dirname(__file__), \"resources/data.json\")\n",
                "            )\n",
                "        else:\n",
                "            sites = SitesInformation(args.json_file)\n",
                "    except Exception as error:\n",
                "        print(f\"ERROR:  {error}\")\n",
                "        sys.exit(1)\n",
                "\n",
                "    if not args.nsfw:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        sites.remove_nsfw_sites()\n"
                ],
                "after": [
                    "        sites.remove_nsfw_sites(do_not_remove=args.site_list)\n"
                ],
                "parent_version_range": {
                    "start": 727,
                    "end": 728
                },
                "child_version_range": {
                    "start": 727,
                    "end": 728
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if not args.nsfw:",
                        "start_line": 726,
                        "end_line": 727
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "main",
                        "signature": "def main():",
                        "at_line": 503
                    },
                    {
                        "type": "call",
                        "name": "sites.remove_nsfw_sites",
                        "signature": "sites.remove_nsfw_sites()",
                        "at_line": 727
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: sherlock/sherlock.py\nCode:\n           def main():\n               ...\n724 724            sys.exit(1)\n725 725    \n726 726        if not args.nsfw:\n727      -         sites.remove_nsfw_sites()\n    727  +         sites.remove_nsfw_sites(do_not_remove=args.site_list)\n728 728    \n729 729        # Create original dictionary from SitesInformation() object.\n730 730        # Eventually, the rest of the code will be updated to use the new object\n         ...\n",
                "file_path": "sherlock/sherlock.py",
                "identifiers_before": [
                    "remove_nsfw_sites",
                    "sites"
                ],
                "identifiers_after": [
                    "args",
                    "do_not_remove",
                    "remove_nsfw_sites",
                    "site_list",
                    "sites"
                ],
                "prefix": [
                    "        sys.exit(1)\n",
                    "\n",
                    "    if not args.nsfw:\n"
                ],
                "suffix": [
                    "\n",
                    "    # Create original dictionary from SitesInformation() object.\n",
                    "    # Eventually, the rest of the code will be updated to use the new object\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "remove_nsfw_sites",
                            "position": {
                                "start": {
                                    "line": 727,
                                    "column": 14
                                },
                                "end": {
                                    "line": 727,
                                    "column": 31
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sherlock.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "remove_nsfw_sites",
                            "position": {
                                "start": {
                                    "line": 727,
                                    "column": 14
                                },
                                "end": {
                                    "line": 727,
                                    "column": 31
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sherlock.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "do_not_remove",
                            "position": {
                                "start": {
                                    "line": 727,
                                    "column": 32
                                },
                                "end": {
                                    "line": 727,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sherlock.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "\n",
                "    # Create original dictionary from SitesInformation() object.\n",
                "    # Eventually, the rest of the code will be updated to use the new object\n",
                "    # directly, but this will glue the two pieces together.\n",
                "    site_data_all = {site.name: site.information for site in sites}\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    if args.site_list is None:\n"
                ],
                "after": [
                    "    if args.site_list == []:\n"
                ],
                "parent_version_range": {
                    "start": 733,
                    "end": 734
                },
                "child_version_range": {
                    "start": 733,
                    "end": 734
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if args.site_list is None:",
                        "start_line": 733,
                        "end_line": 755
                    }
                ],
                "structural_path": [
                    {
                        "type": "function",
                        "name": "main",
                        "signature": "def main():",
                        "at_line": 503
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: sherlock/sherlock.py\nCode:\n           def main():\n               ...\n730 730        # Eventually, the rest of the code will be updated to use the new object\n731 731        # directly, but this will glue the two pieces together.\n732 732        site_data_all = {site.name: site.information for site in sites}\n733      -     if args.site_list is None:\n    733  +     if args.site_list == []:\n734 734            # Not desired to look at a sub-set of sites\n735 735            site_data = site_data_all\n736 736        else:\n         ...\n",
                "file_path": "sherlock/sherlock.py",
                "identifiers_before": [
                    "args",
                    "site_list"
                ],
                "identifiers_after": [
                    "args",
                    "site_list"
                ],
                "prefix": [
                    "    # Eventually, the rest of the code will be updated to use the new object\n",
                    "    # directly, but this will glue the two pieces together.\n",
                    "    site_data_all = {site.name: site.information for site in sites}\n"
                ],
                "suffix": [
                    "        # Not desired to look at a sub-set of sites\n",
                    "        site_data = site_data_all\n",
                    "    else:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        # Not desired to look at a sub-set of sites\n",
                "        site_data = site_data_all\n",
                "    else:\n",
                "        # User desires to selectively run queries on a sub-set of the site list.\n",
                "        # Make sure that the sites are supported & build up pruned site database.\n",
                "        site_data = {}\n",
                "        site_missing = []\n",
                "        for site in args.site_list:\n",
                "            counter = 0\n",
                "            for existing_site in site_data_all:\n",
                "                if site.lower() == existing_site.lower():\n",
                "                    site_data[existing_site] = site_data_all[existing_site]\n",
                "                    counter += 1\n",
                "            if counter == 0:\n",
                "                # Build up list of sites not supported for future error message.\n",
                "                site_missing.append(f\"'{site}'\")\n",
                "\n",
                "        if site_missing:\n",
                "            print(f\"Error: Desired sites not found: {', '.join(site_missing)}.\")\n",
                "\n",
                "        if not site_data:\n",
                "            sys.exit(1)\n",
                "\n",
                "    # Create notify object for query results.\n",
                "    query_notify = QueryNotifyPrint(\n",
                "        result=None, verbose=args.verbose, print_all=args.print_all, browse=args.browse\n",
                "    )\n",
                "\n",
                "    # Run report on all specified users.\n",
                "    all_usernames = []\n",
                "    for username in args.username:\n",
                "        if check_for_parameter(username):\n",
                "            for name in multiple_usernames(username):\n",
                "                all_usernames.append(name)\n",
                "        else:\n",
                "            all_usernames.append(username)\n",
                "    for username in all_usernames:\n",
                "        results = sherlock(\n",
                "            username,\n",
                "            site_data,\n",
                "            query_notify,\n",
                "            tor=args.tor,\n",
                "            unique_tor=args.unique_tor,\n",
                "            proxy=args.proxy,\n",
                "            timeout=args.timeout,\n",
                "        )\n",
                "\n",
                "        if args.output:\n",
                "            result_file = args.output\n",
                "        elif args.folderoutput:\n",
                "            # The usernames results should be stored in a targeted folder.\n",
                "            # If the folder doesn't exist, create it first\n",
                "            os.makedirs(args.folderoutput, exist_ok=True)\n",
                "            result_file = os.path.join(args.folderoutput, f\"{username}.txt\")\n",
                "        else:\n",
                "            result_file = f\"{username}.txt\"\n",
                "\n",
                "        with open(result_file, \"w\", encoding=\"utf-8\") as file:\n",
                "            exists_counter = 0\n",
                "            for website_name in results:\n",
                "                dictionary = results[website_name]\n",
                "                if dictionary.get(\"status\").status == QueryStatus.CLAIMED:\n",
                "                    exists_counter += 1\n",
                "                    file.write(dictionary[\"url_user\"] + \"\\n\")\n",
                "            file.write(f\"Total Websites Username Detected On : {exists_counter}\\n\")\n",
                "\n",
                "        if args.csv:\n",
                "            result_file = f\"{username}.csv\"\n",
                "            if args.folderoutput:\n",
                "                # The usernames results should be stored in a targeted folder.\n",
                "                # If the folder doesn't exist, create it first\n",
                "                os.makedirs(args.folderoutput, exist_ok=True)\n",
                "                result_file = os.path.join(args.folderoutput, result_file)\n",
                "\n",
                "            with open(result_file, \"w\", newline=\"\", encoding=\"utf-8\") as csv_report:\n",
                "                writer = csv.writer(csv_report)\n",
                "                writer.writerow(\n",
                "                    [\n",
                "                        \"username\",\n",
                "                        \"name\",\n",
                "                        \"url_main\",\n",
                "                        \"url_user\",\n",
                "                        \"exists\",\n",
                "                        \"http_status\",\n",
                "                        \"response_time_s\",\n",
                "                    ]\n",
                "                )\n",
                "                for site in results:\n",
                "                    if (\n",
                "                        args.print_found\n",
                "                        and not args.print_all\n",
                "                        and results[site][\"status\"].status != QueryStatus.CLAIMED\n",
                "                    ):\n",
                "                        continue\n",
                "\n",
                "                    response_time_s = results[site][\"status\"].query_time\n",
                "                    if response_time_s is None:\n",
                "                        response_time_s = \"\"\n",
                "                    writer.writerow(\n",
                "                        [\n",
                "                            username,\n",
                "                            site,\n",
                "                            results[site][\"url_main\"],\n",
                "                            results[site][\"url_user\"],\n",
                "                            str(results[site][\"status\"].status),\n",
                "                            results[site][\"http_status\"],\n",
                "                            response_time_s,\n",
                "                        ]\n",
                "                    )\n",
                "        if args.xlsx:\n",
                "            usernames = []\n",
                "            names = []\n",
                "            url_main = []\n",
                "            url_user = []\n",
                "            exists = []\n",
                "            http_status = []\n",
                "            response_time_s = []\n",
                "\n",
                "            for site in results:\n",
                "                if (\n",
                "                    args.print_found\n",
                "                    and not args.print_all\n",
                "                    and results[site][\"status\"].status != QueryStatus.CLAIMED\n",
                "                ):\n",
                "                    continue\n",
                "\n",
                "                if response_time_s is None:\n",
                "                    response_time_s.append(\"\")\n",
                "                else:\n",
                "                    response_time_s.append(results[site][\"status\"].query_time)\n",
                "                usernames.append(username)\n",
                "                names.append(site)\n",
                "                url_main.append(results[site][\"url_main\"])\n",
                "                url_user.append(results[site][\"url_user\"])\n",
                "                exists.append(str(results[site][\"status\"].status))\n",
                "                http_status.append(results[site][\"http_status\"])\n",
                "\n",
                "            DataFrame = pd.DataFrame(\n",
                "                {\n",
                "                    \"username\": usernames,\n",
                "                    \"name\": names,\n",
                "                    \"url_main\": url_main,\n",
                "                    \"url_user\": url_user,\n",
                "                    \"exists\": exists,\n",
                "                    \"http_status\": http_status,\n",
                "                    \"response_time_s\": response_time_s,\n",
                "                }\n",
                "            )\n",
                "            DataFrame.to_excel(f\"{username}.xlsx\", sheet_name=\"sheet1\", index=False)\n",
                "\n",
                "        print()\n",
                "    query_notify.finish()\n",
                "\n",
                "\n",
                "if __name__ == \"__main__\":\n",
                "    main()"
            ]
        ],
        "sherlock/sites.py": [
            [
                "\"\"\"Sherlock Sites Information Module\n",
                "\n",
                "This module supports storing information about websites.\n",
                "This is the raw data that will be used to search for usernames.\n",
                "\"\"\"\n",
                "import json\n",
                "import requests\n",
                "import secrets\n",
                "\n",
                "class SiteInformation:\n",
                "    def __init__(self, name, url_home, url_username_format, username_claimed,\n",
                "                information, is_nsfw, username_unclaimed=secrets.token_urlsafe(10)):\n",
                "        \"\"\"Create Site Information Object.\n",
                "\n",
                "        Contains information about a specific website.\n",
                "\n",
                "        Keyword Arguments:\n",
                "        self                   -- This object.\n",
                "        name                   -- String which identifies site.\n",
                "        url_home               -- String containing URL for home of site.\n",
                "        url_username_format    -- String containing URL for Username format\n",
                "                                  on site.\n",
                "                                  NOTE:  The string should contain the\n",
                "                                         token \"{}\" where the username should\n",
                "                                         be substituted.  For example, a string\n",
                "                                         of \"https://somesite.com/users/{}\"\n",
                "                                         indicates that the individual\n",
                "                                         usernames would show up under the\n",
                "                                         \"https://somesite.com/users/\" area of\n",
                "                                         the website.\n",
                "        username_claimed       -- String containing username which is known\n",
                "                                  to be claimed on website.\n",
                "        username_unclaimed     -- String containing username which is known\n",
                "                                  to be unclaimed on website.\n",
                "        information            -- Dictionary containing all known information\n",
                "                                  about website.\n",
                "                                  NOTE:  Custom information about how to\n",
                "                                         actually detect the existence of the\n",
                "                                         username will be included in this\n",
                "                                         dictionary.  This information will\n",
                "                                         be needed by the detection method,\n",
                "                                         but it is only recorded in this\n",
                "                                         object for future use.\n",
                "        is_nsfw                -- Boolean indicating if site is Not Safe For Work.\n",
                "\n",
                "        Return Value:\n",
                "        Nothing.\n",
                "        \"\"\"\n",
                "\n",
                "        self.name = name\n",
                "        self.url_home = url_home\n",
                "        self.url_username_format = url_username_format\n",
                "\n",
                "        self.username_claimed = username_claimed\n",
                "        self.username_unclaimed = secrets.token_urlsafe(32)\n",
                "        self.information = information\n",
                "        self.is_nsfw  = is_nsfw\n",
                "\n",
                "        return\n",
                "\n",
                "    def __str__(self):\n",
                "        \"\"\"Convert Object To String.\n",
                "\n",
                "        Keyword Arguments:\n",
                "        self                   -- This object.\n",
                "\n",
                "        Return Value:\n",
                "        Nicely formatted string to get information about this object.\n",
                "        \"\"\"\n",
                "        \n",
                "        return f\"{self.name} ({self.url_home})\"\n",
                "\n",
                "\n",
                "class SitesInformation:\n",
                "    def __init__(self, data_file_path=None):\n",
                "        \"\"\"Create Sites Information Object.\n",
                "\n",
                "        Contains information about all supported websites.\n",
                "\n",
                "        Keyword Arguments:\n",
                "        self                   -- This object.\n",
                "        data_file_path         -- String which indicates path to data file.\n",
                "                                  The file name must end in \".json\".\n",
                "\n",
                "                                  There are 3 possible formats:\n",
                "                                   * Absolute File Format\n",
                "                                     For example, \"c:/stuff/data.json\".\n",
                "                                   * Relative File Format\n",
                "                                     The current working directory is used\n",
                "                                     as the context.\n",
                "                                     For example, \"data.json\".\n",
                "                                   * URL Format\n",
                "                                     For example,\n",
                "                                     \"https://example.com/data.json\", or\n",
                "                                     \"http://example.com/data.json\".\n",
                "\n",
                "                                  An exception will be thrown if the path\n",
                "                                  to the data file is not in the expected\n",
                "                                  format, or if there was any problem loading\n",
                "                                  the file.\n",
                "\n",
                "                                  If this option is not specified, then a\n",
                "                                  default site list will be used.\n",
                "\n",
                "        Return Value:\n",
                "        Nothing.\n",
                "        \"\"\"\n",
                "\n",
                "        if not data_file_path:\n",
                "            # The default data file is the live data.json which is in the GitHub repo. The reason why we are using\n",
                "            # this instead of the local one is so that the user has the most up-to-date data. This prevents\n",
                "            # users from creating issue about false positives which has already been fixed or having outdated data\n",
                "            data_file_path = \"https://raw.githubusercontent.com/sherlock-project/sherlock/master/sherlock/resources/data.json\"\n",
                "\n",
                "        # Ensure that specified data file has correct extension.\n",
                "        if not data_file_path.lower().endswith(\".json\"):\n",
                "            raise FileNotFoundError(f\"Incorrect JSON file extension for data file '{data_file_path}'.\")\n",
                "\n",
                "        # if \"http://\"  == data_file_path[:7].lower() or \"https://\" == data_file_path[:8].lower():\n",
                "        if data_file_path.lower().startswith(\"http\"):\n",
                "            # Reference is to a URL.\n",
                "            try:\n",
                "                response = requests.get(url=data_file_path)\n",
                "            except Exception as error:\n",
                "                raise FileNotFoundError(\n",
                "                    f\"Problem while attempting to access data file URL '{data_file_path}':  {error}\"\n",
                "                )\n",
                "\n",
                "            if response.status_code != 200:\n",
                "                raise FileNotFoundError(f\"Bad response while accessing \"\n",
                "                                        f\"data file URL '{data_file_path}'.\"\n",
                "                                        )\n",
                "            try:\n",
                "                site_data = response.json()\n",
                "            except Exception as error:\n",
                "                raise ValueError(\n",
                "                    f\"Problem parsing json contents at '{data_file_path}':  {error}.\"\n",
                "                )\n",
                "\n",
                "        else:\n",
                "            # Reference is to a file.\n",
                "            try:\n",
                "                with open(data_file_path, \"r\", encoding=\"utf-8\") as file:\n",
                "                    try:\n",
                "                        site_data = json.load(file)\n",
                "                    except Exception as error:\n",
                "                        raise ValueError(\n",
                "                            f\"Problem parsing json contents at '{data_file_path}':  {error}.\"\n",
                "                        )\n",
                "\n",
                "            except FileNotFoundError:\n",
                "                raise FileNotFoundError(f\"Problem while attempting to access \"\n",
                "                                        f\"data file '{data_file_path}'.\"\n",
                "                                        )\n",
                "\n",
                "        self.sites = {}\n",
                "\n",
                "        # Add all site information from the json file to internal site list.\n",
                "        for site_name in site_data:\n",
                "            try:\n",
                "\n",
                "                self.sites[site_name] = \\\n",
                "                    SiteInformation(site_name,\n",
                "                                    site_data[site_name][\"urlMain\"],\n",
                "                                    site_data[site_name][\"url\"],\n",
                "                                    site_data[site_name][\"username_claimed\"],\n",
                "                                    site_data[site_name],\n",
                "                                    site_data[site_name].get(\"isNSFW\",False)\n",
                "\n",
                "                                    )\n",
                "            except KeyError as error:\n",
                "                raise ValueError(\n",
                "                    f\"Problem parsing json contents at '{data_file_path}':  Missing attribute {error}.\"\n",
                "                )\n",
                "\n",
                "        return\n",
                "\n"
            ],
            {
                "type": "replace",
                "before": [
                    "    def remove_nsfw_sites(self):\n"
                ],
                "after": [
                    "    def remove_nsfw_sites(self, do_not_remove: list[str] = []):\n"
                ],
                "parent_version_range": {
                    "start": 177,
                    "end": 178
                },
                "child_version_range": {
                    "start": 177,
                    "end": 178
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "SitesInformation",
                        "signature": "class SitesInformation:",
                        "at_line": 73
                    },
                    {
                        "type": "function",
                        "name": "remove_nsfw_sites",
                        "signature": "def remove_nsfw_sites(self):",
                        "at_line": 177
                    }
                ],
                "idx": 3,
                "hunk_diff": "File: sherlock/sites.py\nCode:\n           class SitesInformation:\n               ...\n174 174    \n175 175            return\n176 176    \n177      -     def remove_nsfw_sites(self):\n    177  +     def remove_nsfw_sites(self, do_not_remove: list[str] = []):\n178 178            \"\"\"\n179 179            Remove NSFW sites from the sites, if isNSFW flag is true for site\n180 180    \n         ...\n",
                "file_path": "sherlock/sites.py",
                "identifiers_before": [
                    "remove_nsfw_sites",
                    "self"
                ],
                "identifiers_after": [
                    "do_not_remove",
                    "list",
                    "remove_nsfw_sites",
                    "self",
                    "str"
                ],
                "prefix": [
                    "\n",
                    "        return\n",
                    "\n"
                ],
                "suffix": [
                    "        \"\"\"\n",
                    "        Remove NSFW sites from the sites, if isNSFW flag is true for site\n",
                    "\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "remove_nsfw_sites",
                            "position": {
                                "start": {
                                    "line": 177,
                                    "column": 8
                                },
                                "end": {
                                    "line": 177,
                                    "column": 25
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 177,
                                    "column": 26
                                },
                                "end": {
                                    "line": 177,
                                    "column": 30
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "remove_nsfw_sites",
                            "position": {
                                "start": {
                                    "line": 177,
                                    "column": 8
                                },
                                "end": {
                                    "line": 177,
                                    "column": 25
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "do_not_remove",
                            "position": {
                                "start": {
                                    "line": 177,
                                    "column": 32
                                },
                                "end": {
                                    "line": 177,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "do_not_remove",
                            "position": {
                                "start": {
                                    "line": 177,
                                    "column": 32
                                },
                                "end": {
                                    "line": 177,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "do_not_remove",
                            "position": {
                                "start": {
                                    "line": 177,
                                    "column": 32
                                },
                                "end": {
                                    "line": 177,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "do_not_remove",
                            "position": {
                                "start": {
                                    "line": 177,
                                    "column": 32
                                },
                                "end": {
                                    "line": 177,
                                    "column": 45
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 177,
                                    "column": 26
                                },
                                "end": {
                                    "line": 177,
                                    "column": 30
                                }
                            },
                            "type": "identifier",
                            "kind": "parameter",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "        \"\"\"\n",
                "        Remove NSFW sites from the sites, if isNSFW flag is true for site\n",
                "\n",
                "        Keyword Arguments:\n",
                "        self                   -- This object.\n",
                "\n",
                "        Return Value:\n",
                "        None\n",
                "        \"\"\"\n",
                "        sites = {}\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        do_not_remove = [site.casefold() for site in do_not_remove]\n"
                ],
                "parent_version_range": {
                    "start": 188,
                    "end": 188
                },
                "child_version_range": {
                    "start": 188,
                    "end": 189
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "SitesInformation",
                        "signature": "class SitesInformation:",
                        "at_line": 73
                    },
                    {
                        "type": "function",
                        "name": "remove_nsfw_sites",
                        "signature": "def remove_nsfw_sites(self):",
                        "at_line": 177
                    }
                ],
                "idx": 4,
                "hunk_diff": "File: sherlock/sites.py\nCode:\n           class SitesInformation:\n               ...\n               def remove_nsfw_sites(self):\n                   ...\n185 185            None\n186 186            \"\"\"\n187 187            sites = {}\n    188  +         do_not_remove = [site.casefold() for site in do_not_remove]\n188 189            for site in self.sites:\n         ...\n",
                "file_path": "sherlock/sites.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "casefold",
                    "do_not_remove",
                    "site"
                ],
                "prefix": [
                    "        None\n",
                    "        \"\"\"\n",
                    "        sites = {}\n"
                ],
                "suffix": [
                    "        for site in self.sites:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "do_not_remove",
                            "position": {
                                "start": {
                                    "line": 188,
                                    "column": 8
                                },
                                "end": {
                                    "line": 188,
                                    "column": 21
                                }
                            },
                            "type": "identifier",
                            "kind": "variable",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "do_not_remove",
                            "position": {
                                "start": {
                                    "line": 188,
                                    "column": 53
                                },
                                "end": {
                                    "line": 188,
                                    "column": 66
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        for site in self.sites:\n"
            ],
            {
                "type": "replace",
                "before": [
                    "            if self.sites[site].is_nsfw:\n"
                ],
                "after": [
                    "            if self.sites[site].is_nsfw and site.casefold() not in do_not_remove:\n"
                ],
                "parent_version_range": {
                    "start": 189,
                    "end": 190
                },
                "child_version_range": {
                    "start": 190,
                    "end": 191
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for site in self.sites:",
                        "start_line": 188,
                        "end_line": 191
                    },
                    {
                        "type": "if_statement",
                        "statement": "if self.sites[site].is_nsfw:",
                        "start_line": 189,
                        "end_line": 190
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "SitesInformation",
                        "signature": "class SitesInformation:",
                        "at_line": 73
                    },
                    {
                        "type": "function",
                        "name": "remove_nsfw_sites",
                        "signature": "def remove_nsfw_sites(self):",
                        "at_line": 177
                    }
                ],
                "idx": 5,
                "hunk_diff": "File: sherlock/sites.py\nCode:\n           class SitesInformation:\n               ...\n               def remove_nsfw_sites(self):\n                   ...\n188 189            for site in self.sites:\n189      -             if self.sites[site].is_nsfw:\n    190  +             if self.sites[site].is_nsfw and site.casefold() not in do_not_remove:\n190 191                    continue\n191 192                sites[site] = self.sites[site]  \n192 193            self.sites =  sites\n         ...\n",
                "file_path": "sherlock/sites.py",
                "identifiers_before": [
                    "is_nsfw",
                    "self",
                    "site",
                    "sites"
                ],
                "identifiers_after": [
                    "casefold",
                    "do_not_remove",
                    "is_nsfw",
                    "self",
                    "site",
                    "sites"
                ],
                "prefix": [
                    "        for site in self.sites:\n"
                ],
                "suffix": [
                    "                continue\n",
                    "            sites[site] = self.sites[site]  \n",
                    "        self.sites =  sites\n"
                ],
                "base_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 189,
                                    "column": 15
                                },
                                "end": {
                                    "line": 189,
                                    "column": 19
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "do_not_remove",
                            "position": {
                                "start": {
                                    "line": 190,
                                    "column": 67
                                },
                                "end": {
                                    "line": 190,
                                    "column": 80
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "self",
                            "position": {
                                "start": {
                                    "line": 190,
                                    "column": 15
                                },
                                "end": {
                                    "line": 190,
                                    "column": 19
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/sherlock/sherlock/sites.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "                continue\n",
                "            sites[site] = self.sites[site]  \n",
                "        self.sites =  sites\n",
                "\n",
                "    def site_name_list(self):\n",
                "        \"\"\"Get Site Name List.\n",
                "\n",
                "        Keyword Arguments:\n",
                "        self                   -- This object.\n",
                "\n",
                "        Return Value:\n",
                "        List of strings containing names of sites.\n",
                "        \"\"\"\n",
                "\n",
                "        return sorted([site.name for site in self], key=str.lower)\n",
                "\n",
                "    def __iter__(self):\n",
                "        \"\"\"Iterator For Object.\n",
                "\n",
                "        Keyword Arguments:\n",
                "        self                   -- This object.\n",
                "\n",
                "        Return Value:\n",
                "        Iterator for sites object.\n",
                "        \"\"\"\n",
                "\n",
                "        for site_name in self.sites:\n",
                "            yield self.sites[site_name]\n",
                "\n",
                "    def __len__(self):\n",
                "        \"\"\"Length For Object.\n",
                "\n",
                "        Keyword Arguments:\n",
                "        self                   -- This object.\n",
                "\n",
                "        Return Value:\n",
                "        Length of sites object.\n",
                "        \"\"\"\n",
                "        return len(self.sites)"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "arg def use"
        },
        {
            "edit_hunk_pair": [
                0,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "arg def use"
        },
        {
            "edit_hunk_pair": [
                1,
                3
            ],
            "edit_order": "bi-directional",
            "reason": "func def use"
        },
        {
            "edit_hunk_pair": [
                1,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "func implement use"
        },
        {
            "edit_hunk_pair": [
                1,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "func implement use"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "arg def use"
        },
        {
            "edit_hunk_pair": [
                3,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "arg def use"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "arg data flow"
        }
    ]
}