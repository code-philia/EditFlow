{
    "language": "python",
    "commit_url": "https://github.com/mitmproxy/mitmproxy/commit/94ae720a220da4beaa2fc6111b4cafb60b41d33b",
    "commit_message": "Add a pretty-printing mode for urlencoded form data.",
    "commit_snapshots": {
        "libmproxy/console.py": [
            [
                "# Copyright (C) 2010  Aldo Cortesi\n",
                "# \n",
                "# This program is free software: you can redistribute it and/or modify\n",
                "# it under the terms of the GNU General Public License as published by\n",
                "# the Free Software Foundation, either version 3 of the License, or\n",
                "# (at your option) any later version.\n",
                "# \n",
                "# This program is distributed in the hope that it will be useful,\n",
                "# but WITHOUT ANY WARRANTY; without even the implied warranty of\n",
                "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n",
                "# GNU General Public License for more details.\n",
                "# \n",
                "# You should have received a copy of the GNU General Public License\n",
                "# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n",
                "\n",
                "import mailcap, mimetypes, tempfile, os, subprocess, glob, time\n",
                "import os.path, sys\n",
                "import cStringIO\n",
                "import urwid.raw_display\n",
                "import urwid\n",
                "import controller, utils, filt, proxy, flow\n",
                "\n",
                "VIEW_CUTOFF = 1024*100\n",
                "\n",
                "\n",
                "class Stop(Exception): pass\n",
                "\n",
                "\n",
                "def format_keyvals(lst, key=\"key\", val=\"text\", space=5, indent=0):\n",
                "    ret = []\n",
                "    if lst:\n",
                "        pad = max(len(i[0]) for i in lst if i and i[0]) + space\n",
                "        for i in lst:\n",
                "            if i is None:\n",
                "                ret.extend(\"\\n\")\n",
                "            elif i[0] is None:\n",
                "                ret.extend(\n",
                "                    [\n",
                "                        \" \"*(pad + indent),\n",
                "                        (val, i[1]),\n",
                "                        \"\\n\"\n",
                "                    ]\n",
                "                )\n",
                "            else:\n",
                "                ret.extend(\n",
                "                    [\n",
                "                        \" \"*indent,\n",
                "                        (key, i[0]),\n",
                "                        \" \"*(pad-len(i[0])),\n",
                "                        (val, i[1]),\n",
                "                        \"\\n\"\n",
                "                    ]\n",
                "                )\n",
                "    return ret\n",
                "\n",
                "\n",
                "def format_flow(f, focus, extended=False, padding=2):\n",
                "    txt = []\n",
                "    if extended:\n",
                "        txt.append((\"highlight\", utils.format_timestamp(f.request.timestamp)))\n",
                "    txt.append(\" \")\n",
                "    if f.request.is_replay():\n",
                "        txt.append((\"method\", \"[replay]\"))\n",
                "    txt.extend([\n",
                "        (\"ack\", \"!\") if f.intercepting and not f.request.acked else \" \",\n",
                "        (\"method\", f.request.method),\n",
                "        \" \",\n",
                "        (\n",
                "            \"text\" if (f.response or f.error) else \"title\",\n",
                "            f.request.url(),\n",
                "        ),\n",
                "    ])\n",
                "    if f.response or f.error or f.request.is_replay():\n",
                "        tsr = f.response or f.error\n",
                "        if extended and tsr:\n",
                "            ts = (\"highlight\", utils.format_timestamp(tsr.timestamp) + \" \")\n",
                "        else:\n",
                "            ts = \" \"\n",
                "\n",
                "        txt.append(\"\\n\") \n",
                "        txt.append((\"text\", ts))\n",
                "        txt.append(\" \"*(padding+2))\n",
                "        met = \"\"\n",
                "\n",
                "    if f.response:\n",
                "        txt.append(\n",
                "           (\"ack\", \"!\") if f.intercepting and not f.response.acked else \" \"\n",
                "        )\n",
                "        txt.append(\"<- \")\n",
                "        if f.response.is_replay():\n",
                "            txt.append((\"method\", \"[replay] \"))\n",
                "        if f.response.code in [200, 304]:\n",
                "            txt.append((\"goodcode\", str(f.response.code)))\n",
                "        else:\n",
                "            txt.append((\"error\", str(f.response.code)))\n",
                "        t = f.response.headers[\"content-type\"]\n",
                "        if t:\n",
                "            t = t[0].split(\";\")[0]\n",
                "            txt.append((\"text\", \" %s\"%t))\n",
                "        if f.response.content:\n",
                "            txt.append(\", %s\"%utils.pretty_size(len(f.response.content)))\n",
                "    elif f.error:\n",
                "        txt.append(\n",
                "           (\"error\", f.error.msg)\n",
                "        )\n",
                "\n",
                "    if focus:\n",
                "        txt.insert(0, (\"focus\", \">>\" + \" \"*(padding-2)))\n",
                "    else:\n",
                "        txt.insert(0, \" \"*padding)\n",
                "    return txt\n",
                "\n",
                "\n",
                "\n",
                "#begin nocover\n",
                "\n",
                "def int_version(v):\n",
                "    SIG = 3\n",
                "    v = urwid.__version__.split(\"-\")[0].split(\".\")\n",
                "    x = 0\n",
                "    for i in range(min(SIG, len(v))):\n",
                "        x += int(v[i]) * 10**(SIG-i)\n",
                "    return x\n",
                "    \n",
                "\n",
                "# We have to do this to be portable over 0.9.8 and 0.9.9 If compatibility\n",
                "# becomes a pain to maintain, we'll just mandate 0.9.9 or newer.\n",
                "class WWrap(urwid.WidgetWrap):\n",
                "    if int_version(urwid.__version__) >= 990:\n",
                "        def set_w(self, x):\n",
                "            self._w = x\n",
                "        def get_w(self):\n",
                "            return self._w\n",
                "        w = property(get_w, set_w)\n",
                "\n",
                "\n",
                "class ConnectionItem(WWrap):\n",
                "    def __init__(self, master, state, flow, focus):\n",
                "        self.master, self.state, self.flow = master, state, flow\n",
                "        self.focus = focus\n",
                "        w = self.get_text()\n",
                "        WWrap.__init__(self, w)\n",
                "\n",
                "    def get_text(self):\n",
                "        return urwid.Text(format_flow(self.flow, self.focus))\n",
                "\n",
                "    def selectable(self):\n",
                "        return True\n",
                "\n",
                "    def keypress(self, (maxcol,), key):\n",
                "        if key == \"a\":\n",
                "            self.flow.accept_intercept()\n",
                "            self.master.sync_list_view()\n",
                "        elif key == \"A\":\n",
                "            self.master.accept_all()\n",
                "            self.master.sync_list_view()\n",
                "        elif key == \"C\":\n",
                "            self.master.clear_connections()\n",
                "        elif key == \"d\":\n",
                "            self.flow.kill(self.master)\n",
                "            self.state.delete_flow(self.flow)\n",
                "            self.master.sync_list_view()\n",
                "        elif key == \"r\":\n",
                "            r = self.master.replay_request(self.flow)\n",
                "            if r:\n",
                "                self.master.statusbar.message(r)\n",
                "            self.master.sync_list_view()\n",
                "        elif key == \"R\":\n",
                "            self.state.revert(self.flow)\n",
                "            self.master.sync_list_view()\n",
                "        elif key == \"w\":\n",
                "            self.master.path_prompt(\n",
                "                \"Save this flow: \",\n",
                "                self.state.last_saveload,\n",
                "                self.master.save_one_flow,\n",
                "                self.flow\n",
                "            )\n",
                "        elif key == \"z\":\n",
                "            self.flow.kill(self.master)\n",
                "        elif key == \"enter\":\n",
                "            if self.flow.request:\n",
                "                self.master.view_flow(self.flow)\n",
                "        elif key == \" \":\n",
                "            key = \"page down\"\n",
                "        return key\n",
                "\n",
                "\n",
                "class ConnectionListView(urwid.ListWalker):\n",
                "    def __init__(self, master, state):\n",
                "        self.master, self.state = master, state\n",
                "        if self.state.flow_list:\n",
                "            self.set_focus(0)\n",
                "\n",
                "    def get_focus(self):\n",
                "        f, i = self.state.get_focus()\n",
                "        f = ConnectionItem(self.master, self.state, f, True) if f else None\n",
                "        return f, i\n",
                "\n",
                "    def set_focus(self, focus):\n",
                "        ret = self.state.set_focus(focus)\n",
                "        self._modified()\n",
                "        return ret\n",
                "\n",
                "    def get_next(self, pos):\n",
                "        f, i = self.state.get_next(pos)\n",
                "        f = ConnectionItem(self.master, self.state, f, False) if f else None\n",
                "        return f, i\n",
                "\n",
                "    def get_prev(self, pos):\n",
                "        f, i = self.state.get_prev(pos)\n",
                "        f = ConnectionItem(self.master, self.state, f, False) if f else None\n",
                "        return f, i\n",
                "\n",
                "\n",
                "class ConnectionViewHeader(WWrap):\n",
                "    def __init__(self, master, f):\n",
                "        self.master, self.flow = master, f\n",
                "        self.w = urwid.Text(format_flow(f, False, extended=True, padding=0))\n",
                "\n",
                "    def refresh_connection(self, f):\n",
                "        if f == self.flow:\n",
                "            self.w = urwid.Text(format_flow(f, False, extended=True, padding=0))\n",
                "\n",
                "\n",
                "VIEW_BODY_RAW = 0\n",
                "VIEW_BODY_HEX = 1\n",
                "VIEW_BODY_PRETTY = 2\n",
                "\n",
                "BODY_VIEWS = {\n",
                "    VIEW_BODY_RAW: \"raw\",\n",
                "    VIEW_BODY_HEX: \"hex\",\n",
                "    VIEW_BODY_PRETTY: \"pretty\"\n",
                "}\n",
                "\n",
                "VIEW_FLOW_REQUEST = 0\n",
                "VIEW_FLOW_RESPONSE = 1\n",
                "\n",
                "class ConnectionView(WWrap):\n",
                "    REQ = 0\n",
                "    RESP = 1\n",
                "    methods = [\n",
                "        (\"get\", \"g\"),\n",
                "        (\"post\", \"p\"),\n",
                "        (\"put\", \"u\"),\n",
                "        (\"head\", \"h\"),\n",
                "        (\"trace\", \"t\"),\n",
                "        (\"delete\", \"d\"),\n",
                "        (\"options\", \"o\"),\n",
                "    ]\n",
                "    def __init__(self, master, state, flow):\n",
                "        self.master, self.state, self.flow = master, state, flow\n",
                "        if self.state.view_flow_mode == VIEW_FLOW_RESPONSE and flow.response:\n",
                "            self.view_response()\n",
                "        else:\n",
                "            self.view_request()\n",
                "\n",
                "    def _tab(self, content, active):\n",
                "        if active:\n",
                "            attr = \"heading\"\n",
                "        else:\n",
                "            attr = \"inactive\"\n",
                "        p = urwid.Text(content)\n",
                "        p = urwid.Padding(p, align=\"left\", width=(\"relative\", 100))\n",
                "        p = urwid.AttrWrap(p, attr)\n",
                "        return p\n",
                "\n",
                "    def wrap_body(self, active, body):\n",
                "        parts = []\n",
                "\n",
                "        if self.flow.intercepting and not self.flow.request.acked:\n",
                "            qt = \"Request (intercepted)\"\n",
                "        else:\n",
                "            qt = \"Request\"\n",
                "        if active == VIEW_FLOW_REQUEST:\n",
                "            parts.append(self._tab(qt, True))\n",
                "        else:\n",
                "            parts.append(self._tab(qt, False))\n",
                "\n",
                "        if self.flow.response:\n",
                "            if self.flow.intercepting and not self.flow.response.acked:\n",
                "                st = \"Response (intercepted)\"\n",
                "            else:\n",
                "                st = \"Response\"\n",
                "            if active == VIEW_FLOW_RESPONSE:\n",
                "                parts.append(self._tab(st, True))\n",
                "            else:\n",
                "                parts.append(self._tab(st, False))\n",
                "\n",
                "        h = urwid.Columns(parts, dividechars=1)\n",
                "        f = urwid.Frame(\n",
                "                    body,\n",
                "                    header=h\n",
                "                )\n",
                "        return f\n",
                "\n",
                "    def _conn_text(self, conn, viewmode):\n",
                "        if conn:\n",
                "            return self.master._cached_conn_text(\n",
                "                        conn.content,\n",
                "                        tuple([tuple(i) for i in conn.headers.lst]),\n",
                "                        viewmode\n",
                "                    )\n",
                "        else:\n",
                "            return urwid.ListBox([])\n",
                "\n",
                "    def view_request(self):\n",
                "        self.state.view_flow_mode = VIEW_FLOW_REQUEST\n",
                "        self.master.statusbar.update(\"Calculating view...\")\n",
                "        body = self._conn_text(\n",
                "            self.flow.request,\n",
                "            self.state.view_body_mode\n",
                "        )\n",
                "        self.w = self.wrap_body(VIEW_FLOW_REQUEST, body)\n",
                "        self.master.statusbar.update(\"\")\n",
                "\n",
                "    def view_response(self):\n",
                "        self.state.view_flow_mode = VIEW_FLOW_RESPONSE\n",
                "        self.master.statusbar.update(\"Calculating view...\")\n",
                "        body = self._conn_text(\n",
                "            self.flow.response,\n",
                "            self.state.view_body_mode\n",
                "        )\n",
                "        self.w = self.wrap_body(VIEW_FLOW_RESPONSE, body)\n",
                "        self.master.statusbar.update(\"\")\n",
                "\n",
                "    def refresh_connection(self, c=None):\n",
                "        if c == self.flow:\n",
                "            if self.state.view_flow_mode == VIEW_FLOW_RESPONSE and self.flow.response:\n",
                "                self.view_response()\n",
                "            else:\n",
                "                self.view_request()\n",
                "\n",
                "    def _spawn_editor(self, data):\n",
                "        fd, name = tempfile.mkstemp('', \"mproxy\")\n",
                "        os.write(fd, data)\n",
                "        os.close(fd)\n",
                "        c = os.environ.get(\"EDITOR\")\n",
                "        #If no EDITOR is set, assume 'vi'\n",
                "        if not c:\n",
                "            c = \"vi\"\n",
                "        cmd = [c, name]\n",
                "        self.master.ui.stop()\n",
                "        try:\n",
                "            ret = subprocess.call(cmd)\n",
                "        except:\n",
                "            self.master.statusbar.message(\"Can't start editor: %s\" % c)\n",
                "            self.master.ui.start()\n",
                "            os.unlink(name)\n",
                "            return data\n",
                "        self.master.ui.start()\n",
                "        data = open(name).read()\n",
                "        os.unlink(name)\n",
                "        return data\n",
                "\n",
                "    def edit_method(self, m):\n",
                "        for i in self.methods:\n",
                "            if i[1] == m:\n",
                "                self.flow.request.method = i[0].upper()\n",
                "        self.master.refresh_connection(self.flow)\n",
                "\n",
                "    def save_body(self, path):\n",
                "        if not path:\n",
                "            return\n",
                "        self.state.last_saveload = path\n",
                "        if self.state.view_flow_mode == VIEW_FLOW_REQUEST:\n",
                "            c = self.flow.request\n",
                "        else:\n",
                "            c = self.flow.response\n",
                "        path = os.path.expanduser(path)\n",
                "        try:\n",
                "            f = file(path, \"wb\")\n",
                "            f.write(str(c.content))\n",
                "            f.close()\n",
                "        except IOError, v:\n",
                "            self.master.statusbar.message(v.strerror)\n",
                "\n",
                "    def set_url(self, url):\n",
                "        request = self.flow.request\n",
                "        if not request.set_url(url):\n",
                "            return \"Invalid URL.\"\n",
                "        self.master.refresh_connection(self.flow)\n",
                "\n",
                "    def set_resp_code(self, code):\n",
                "        response = self.flow.response\n",
                "        try:\n",
                "            response.code = int(code)\n",
                "        except ValueError:\n",
                "            return None\n",
                "        import BaseHTTPServer\n",
                "        if BaseHTTPServer.BaseHTTPRequestHandler.responses.has_key(int(code)):\n",
                "            response.msg = BaseHTTPServer.BaseHTTPRequestHandler.responses[int(code)][0]\n",
                "        self.master.refresh_connection(self.flow)\n",
                "\n",
                "    def set_resp_msg(self, msg):\n",
                "        response = self.flow.response\n",
                "        response.msg = msg\n",
                "        self.master.refresh_connection(self.flow)\n",
                "        \n",
                "    def edit(self, part):\n",
                "        if self.state.view_flow_mode == VIEW_FLOW_REQUEST:\n",
                "            conn = self.flow.request\n",
                "        else:\n",
                "            conn = self.flow.response\n",
                "\n",
                "        self.flow.backup()\n",
                "        if part == \"b\":\n",
                "            conn.content = self._spawn_editor(conn.content or \"\")\n",
                "        elif part == \"h\":\n",
                "            headertext = self._spawn_editor(repr(conn.headers))\n",
                "            headers = utils.Headers()\n",
                "            fp = cStringIO.StringIO(headertext)\n",
                "            headers.read(fp)\n",
                "            conn.headers = headers\n",
                "        elif part == \"u\" and self.state.view_flow_mode == VIEW_FLOW_REQUEST:\n",
                "            self.master.prompt_edit(\"URL\", conn.url(), self.set_url)\n",
                "        elif part == \"m\" and self.state.view_flow_mode == VIEW_FLOW_REQUEST:\n",
                "            self.master.prompt_onekey(\"Method\", self.methods, self.edit_method)\n",
                "        elif part == \"c\" and self.state.view_flow_mode == VIEW_FLOW_RESPONSE:\n",
                "            self.master.prompt_edit(\"Code\", str(conn.code), self.set_resp_code)\n",
                "        elif part == \"m\" and self.state.view_flow_mode == VIEW_FLOW_RESPONSE:\n",
                "            self.master.prompt_edit(\"Message\", conn.msg, self.set_resp_msg)\n",
                "        elif part == \"r\" and self.state.view_flow_mode == VIEW_FLOW_REQUEST:\n",
                "            if not conn.acked:\n",
                "                response = proxy.Response(conn, \"200\", \"OK\", utils.Headers(), \"\")\n",
                "                conn.ack(response)\n",
                "            self.view_response()\n",
                "        self.master.refresh_connection(self.flow)\n",
                "\n",
                "    def keypress(self, size, key):\n",
                "        if key == \"tab\":\n",
                "            if self.state.view_flow_mode == VIEW_FLOW_REQUEST and self.flow.response:\n",
                "                self.view_response()\n",
                "            else:\n",
                "                self.view_request()\n",
                "        elif key in (\"up\", \"down\", \"page up\", \"page down\"):\n",
                "            # Why doesn't this just work??\n",
                "            self.w.body.keypress(size, key)\n",
                "        elif key == \"a\":\n",
                "            self.flow.accept_intercept()\n",
                "            self.master.view_flow(self.flow)\n",
                "        elif key == \"A\":\n",
                "            self.master.accept_all()\n",
                "            self.master.view_flow(self.flow)\n",
                "        elif key == \"e\":\n",
                "            if self.state.view_flow_mode == VIEW_FLOW_REQUEST:\n",
                "                self.master.prompt_onekey(\n",
                "                    \"Edit request\",\n",
                "                    (\n",
                "                        (\"header\", \"h\"),\n",
                "                        (\"body\", \"b\"),\n",
                "                        (\"url\", \"u\"),\n",
                "                        (\"method\", \"m\"),\n",
                "                        (\"reply\", \"r\")\n",
                "                    ),\n",
                "                    self.edit\n",
                "                )\n",
                "            else:\n",
                "                self.master.prompt_onekey(\n",
                "                    \"Edit response\",\n",
                "                    (\n",
                "                        (\"code\", \"c\"),\n",
                "                        (\"message\", \"m\"),\n",
                "                        (\"header\", \"h\"),\n",
                "                        (\"body\", \"b\"),\n",
                "                    ),\n",
                "                    self.edit\n",
                "                )\n",
                "            key = None\n",
                "        elif key == \"p\":\n",
                "            self.master.view_prev_flow(self.flow)\n",
                "        elif key == \"r\":\n",
                "            r = self.master.replay_request(self.flow)\n",
                "            if r:\n",
                "                self.master.statusbar.message(r)\n",
                "            self.master.refresh_connection(self.flow)\n",
                "        elif key == \"R\":\n",
                "            self.state.revert(self.flow)\n",
                "            self.master.refresh_connection(self.flow)\n",
                "        elif key == \"w\":\n",
                "            self.master.path_prompt(\n",
                "                \"Save this flow: \",\n",
                "                self.state.last_saveload,\n",
                "                self.master.save_one_flow,\n",
                "                self.flow\n",
                "            )\n",
                "        elif key == \"v\":\n",
                "            if self.state.view_flow_mode == VIEW_FLOW_REQUEST:\n",
                "                conn = self.flow.request\n",
                "            else:\n",
                "                conn = self.flow.response\n",
                "            if conn.content:\n",
                "                t = conn.headers[\"content-type\"] or [None]\n",
                "                t = t[0]\n",
                "                self.master.spawn_external_viewer(conn.content, t)\n",
                "        elif key == \"b\":\n",
                "            if self.state.view_flow_mode == VIEW_FLOW_REQUEST:\n",
                "                self.master.path_prompt(\n",
                "                    \"Save request body: \",\n",
                "                    self.state.last_saveload,\n",
                "                    self.save_body\n",
                "                )\n",
                "            else:\n",
                "                self.master.path_prompt(\n",
                "                    \"Save response body: \",\n",
                "                    self.state.last_saveload,\n",
                "                    self.save_body\n",
                "                )\n",
                "        elif key == \" \":\n",
                "            self.master.view_next_flow(self.flow)\n",
                "        elif key == \"|\":\n",
                "            self.master.path_prompt(\"Script: \", self.state.last_script, self.run_script)\n",
                "        return key\n",
                "\n",
                "    def run_script(self, path):\n",
                "        if path:\n",
                "            self.master._runscript(self.flow, path)\n",
                "\n",
                "\n",
                "class _PathCompleter:\n",
                "    def __init__(self, _testing=False):\n",
                "        \"\"\"\n",
                "            _testing: disables reloading of the lookup table to make testing possible.\n",
                "        \"\"\"\n",
                "        self.lookup, self.offset = None, None\n",
                "        self.final = None\n",
                "        self._testing = _testing\n",
                "\n",
                "    def reset(self):\n",
                "        self.lookup = None\n",
                "        self.offset = -1\n",
                "\n",
                "    def complete(self, txt):\n",
                "        \"\"\"\n",
                "            Returns the next completion for txt, or None if there is no completion.\n",
                "        \"\"\"\n",
                "        path = os.path.expanduser(txt)\n",
                "        if not self.lookup:\n",
                "            if not self._testing:\n",
                "                # Lookup is a set of (display value, actual value) tuples.\n",
                "                self.lookup = []\n",
                "                if os.path.isdir(path):\n",
                "                    files = glob.glob(os.path.join(path, \"*\"))\n",
                "                    prefix = txt\n",
                "                else:\n",
                "                    files = glob.glob(path+\"*\")\n",
                "                    prefix = os.path.dirname(txt)\n",
                "                prefix = prefix or \"./\"\n",
                "                for f in files:\n",
                "                    display = os.path.join(prefix, os.path.basename(f))\n",
                "                    if os.path.isdir(f):\n",
                "                        display += \"/\"\n",
                "                    self.lookup.append((display, f))\n",
                "            if not self.lookup:\n",
                "                self.final = path\n",
                "                return path\n",
                "            self.lookup.sort()\n",
                "            self.offset = -1\n",
                "            self.lookup.append((txt, txt))\n",
                "        self.offset += 1\n",
                "        if self.offset >= len(self.lookup):\n",
                "            self.offset = 0\n",
                "        ret = self.lookup[self.offset]\n",
                "        self.final = ret[1]\n",
                "        return ret[0]\n",
                "\n",
                "\n",
                "class PathEdit(urwid.Edit, _PathCompleter):\n",
                "    def __init__(self, *args, **kwargs):\n",
                "        urwid.Edit.__init__(self, *args, **kwargs)\n",
                "        _PathCompleter.__init__(self)\n",
                "\n",
                "    def keypress(self, size, key):\n",
                "        if key == \"tab\":\n",
                "            comp = self.complete(self.get_edit_text())\n",
                "            self.set_edit_text(comp)\n",
                "            self.set_edit_pos(len(comp))\n",
                "        else:\n",
                "            self.reset()\n",
                "        return urwid.Edit.keypress(self, size, key)\n",
                "        \n",
                "\n",
                "class ActionBar(WWrap):\n",
                "    def __init__(self):\n",
                "        self.message(\"\")\n",
                "\n",
                "    def selectable(self):\n",
                "        return True\n",
                "\n",
                "    def path_prompt(self, prompt, text):\n",
                "        self.w = PathEdit(prompt, text)\n",
                "\n",
                "    def prompt(self, prompt, text = \"\"):\n",
                "        self.w = urwid.Edit(prompt, text or \"\")\n",
                "\n",
                "    def message(self, message):\n",
                "        self.w = urwid.Text(message)\n",
                "\n",
                "\n",
                "class StatusBar(WWrap):\n",
                "    def __init__(self, master, helptext):\n",
                "        self.master, self.helptext = master, helptext\n",
                "        self.expire = None\n",
                "        self.ab = ActionBar()\n",
                "        self.ib = WWrap(urwid.Text(\"\"))\n",
                "        self.w = urwid.Pile([self.ib, self.ab])\n",
                "\n",
                "    def get_status(self):\n",
                "        r = []\n",
                "\n",
                "        if self.master.client_playback:\n",
                "            r.append(\"[\")\n",
                "            r.append((\"statusbar_highlight\", \"cplayback\"))\n",
                "            r.append(\":%s to go]\"%self.master.client_playback.count())\n",
                "        if self.master.server_playback:\n",
                "            r.append(\"[\")\n",
                "            r.append((\"statusbar_highlight\", \"splayback\"))\n",
                "            r.append(\":%s to go]\"%self.master.server_playback.count())\n",
                "        if self.master.state.intercept_txt:\n",
                "            r.append(\"[\")\n",
                "            r.append((\"statusbar_highlight\", \"i\"))\n",
                "            r.append(\":%s]\"%self.master.state.intercept_txt)\n",
                "        if self.master.state.limit_txt:\n",
                "            r.append(\"[\")\n",
                "            r.append((\"statusbar_highlight\", \"l\"))\n",
                "            r.append(\":%s]\"%self.master.state.limit_txt)\n",
                "        if self.master.stickycookie_txt:\n",
                "            r.append(\"[\")\n",
                "            r.append((\"statusbar_highlight\", \"t\"))\n",
                "            r.append(\":%s]\"%self.master.stickycookie_txt)\n",
                "        if self.master.stickyauth_txt:\n",
                "            r.append(\"[\")\n",
                "            r.append((\"statusbar_highlight\", \"u\"))\n",
                "            r.append(\":%s]\"%self.master.stickyauth_txt)\n",
                "\n",
                "        opts = []\n",
                "        if self.master.anticache:\n",
                "            opts.append(\"anticache\")\n",
                "        if not self.master.refresh_server_playback:\n",
                "            opts.append(\"norefresh\")\n",
                "        if self.master.killextra:\n",
                "            opts.append(\"killextra\")\n",
                "\n",
                "        if opts:\n",
                "            r.append(\"[%s]\"%(\":\".join(opts)))\n",
                "\n",
                "        if self.master.debug:\n",
                "            r.append(\"[lt:%0.3f]\"%self.master.looptime)\n",
                "\n",
                "        return r\n",
                "\n",
                "    def redraw(self):\n",
                "        if self.expire and time.time() > self.expire:\n",
                "            self.message(\"\")\n",
                "\n",
                "        t = [\n",
                "                ('statusbar_text', (\"[%s]\"%len(self.master.state.flow_list)).ljust(7)),\n",
                "            ]\n",
                "        t.extend(self.get_status())\n",
                "            \n",
                "        if self.master.server:\n",
                "            boundaddr = \"[%s:%s]\"%(self.master.server.address or \"*\", self.master.server.port)\n",
                "        else:\n",
                "            boundaddr = \"\"\n",
                "\n",
                "        status = urwid.AttrWrap(urwid.Columns([\n",
                "            urwid.Text(t),\n",
                "            urwid.Text(\n",
                "                [\n",
                "                    self.helptext,\n",
                "                    \" \",\n",
                "                    ('statusbar_text', \"[\"),\n",
                "                    ('statusbar_key', \"m\"),\n",
                "                    ('statusbar_text', (\":%s]\"%BODY_VIEWS[self.master.state.view_body_mode])),\n",
                "                    ('statusbar_text', boundaddr),\n",
                "                ],\n",
                "                align=\"right\"\n",
                "            ),\n",
                "        ]), \"statusbar\")\n",
                "        self.ib.set_w(status)\n",
                "\n",
                "    def update(self, text):\n",
                "        self.helptext = text\n",
                "        self.redraw()\n",
                "        self.master.drawscreen()\n",
                "\n",
                "    def selectable(self):\n",
                "        return True\n",
                "\n",
                "    def get_edit_text(self):\n",
                "        return self.ab.w.get_edit_text()\n",
                "\n",
                "    def path_prompt(self, prompt, text):\n",
                "        return self.ab.path_prompt(prompt, text)\n",
                "\n",
                "    def prompt(self, prompt, text = \"\"):\n",
                "        self.ab.prompt(prompt, text)\n",
                "\n",
                "    def message(self, msg, expire=None):\n",
                "        if expire:\n",
                "            self.expire = time.time() + float(expire)/1000\n",
                "        else:\n",
                "            self.expire = None\n",
                "        self.ab.message(msg)\n",
                "\n",
                "\n",
                "#end nocover\n",
                "\n",
                "class ConsoleState(flow.State):\n",
                "    def __init__(self):\n",
                "        flow.State.__init__(self)\n",
                "        self.focus = None\n",
                "\n",
                "        self.view_body_mode = VIEW_BODY_PRETTY\n",
                "        self.view_flow_mode = VIEW_FLOW_REQUEST\n",
                "\n",
                "        self.last_script = \"\"\n",
                "        self.last_saveload = \"\"\n",
                "\n",
                "    def add_request(self, req):\n",
                "        f = flow.State.add_request(self, req)\n",
                "        if self.focus is None:\n",
                "            self.set_focus(0)\n",
                "        return f\n",
                "\n",
                "    def add_response(self, resp):\n",
                "        f = flow.State.add_response(self, resp)\n",
                "        if self.focus is None:\n",
                "            self.set_focus(0)\n",
                "        return f\n",
                "\n",
                "    def set_limit(self, limit):\n",
                "        ret = flow.State.set_limit(self, limit)\n",
                "        self.set_focus(self.focus)\n",
                "        return ret\n",
                "\n",
                "    def get_focus(self):\n",
                "        if not self.view or self.focus is None:\n",
                "            return None, None\n",
                "        return self.view[self.focus], self.focus\n",
                "\n",
                "    def set_focus(self, idx):\n",
                "        if self.view:\n",
                "            if idx >= len(self.view):\n",
                "                idx = len(self.view) - 1\n",
                "            elif idx < 0:\n",
                "                idx = 0\n",
                "            self.focus = idx\n",
                "\n",
                "    def get_from_pos(self, pos):\n",
                "        if len(self.view) <= pos or pos < 0:\n",
                "            return None, None\n",
                "        return self.view[pos], pos\n",
                "\n",
                "    def get_next(self, pos):\n",
                "        return self.get_from_pos(pos+1)\n",
                "\n",
                "    def get_prev(self, pos):\n",
                "        return self.get_from_pos(pos-1)\n",
                "\n",
                "    def delete_flow(self, f):\n",
                "        ret = flow.State.delete_flow(self, f)\n",
                "        self.set_focus(self.focus)\n",
                "        return ret\n",
                "\n",
                "\n",
                "\n",
                "class Options(object):\n",
                "    __slots__ = [\n",
                "        \"anticache\",\n",
                "        \"anticomp\",\n",
                "        \"client_replay\",\n",
                "        \"debug\",\n",
                "        \"keepserving\",\n",
                "        \"kill\",\n",
                "        \"intercept\",\n",
                "        \"limit\",\n",
                "        \"no_server\",\n",
                "        \"refresh_server_playback\",\n",
                "        \"request_script\",\n",
                "        \"response_script\",\n",
                "        \"rfile\",\n",
                "        \"rheaders\",\n",
                "        \"server_replay\",\n",
                "        \"stickycookie\",\n",
                "        \"stickyauth\",\n",
                "        \"verbosity\",\n",
                "        \"wfile\",\n",
                "    ]\n",
                "    def __init__(self, **kwargs):\n",
                "        for k, v in kwargs.items():\n",
                "            setattr(self, k, v)\n",
                "        for i in self.__slots__:\n",
                "            if not hasattr(self, i):\n",
                "                setattr(self, i, None)\n",
                "\n",
                "\n",
                "#begin nocover\n",
                "VIEW_CONNLIST = 0\n",
                "VIEW_FLOW = 1\n",
                "VIEW_HELP = 2\n",
                "\n",
                "class ConsoleMaster(flow.FlowMaster):\n",
                "    palette = []\n",
                "    footer_text_default = [\n",
                "        ('statusbar_key', \"?\"), \":help \",\n",
                "    ]\n",
                "    footer_text_help = [\n",
                "        ('statusbar_key', \"q\"), \":back\",\n",
                "    ]\n",
                "    footer_text_connview = [\n",
                "        ('statusbar_key', \"tab\"), \":toggle view \",\n",
                "        ('statusbar_key', \"?\"), \":help \",\n",
                "        ('statusbar_key', \"q\"), \":back \",\n",
                "    ]\n",
                "    def __init__(self, server, options):\n",
                "        flow.FlowMaster.__init__(self, server, ConsoleState())\n",
                "        self.looptime = 0\n",
                "        self.options = options\n",
                "\n",
                "        self.conn_list_view = None\n",
                "        self.set_palette()\n",
                "\n",
                "        if options.response_script:\n",
                "            self.set_response_script(options.response_script)  \n",
                "        if options.request_script:\n",
                "            self.set_request_script(options.request_script)  \n",
                "\n",
                "        r = self.set_limit(options.limit)\n",
                "        if r:\n",
                "            print >> sys.stderr, \"Limit error:\", r\n",
                "            sys.exit(1)\n",
                "\n",
                "        r = self.set_intercept(options.intercept)\n",
                "        if r:\n",
                "            print >> sys.stderr, \"Intercept error:\", r\n",
                "            sys.exit(1)\n",
                "\n",
                "        r = self.set_stickycookie(options.stickycookie)\n",
                "        if r:\n",
                "            print >> sys.stderr, \"Sticky cookies error:\", r\n",
                "            sys.exit(1)\n",
                "\n",
                "        r = self.set_stickyauth(options.stickyauth)\n",
                "        if r:\n",
                "            print >> sys.stderr, \"Sticky auth error:\", r\n",
                "            sys.exit(1)\n",
                "\n",
                "        self.refresh_server_playback = options.refresh_server_playback\n",
                "        self.anticache = options.anticache\n",
                "        self.anticomp = options.anticomp\n",
                "        self.killextra = options.kill\n",
                "        self.rheaders = options.rheaders\n",
                "\n",
                "        if options.client_replay:\n",
                "            self.client_playback_path(options.client_replay)\n",
                "\n",
                "        if options.server_replay:\n",
                "            self.server_playback_path(options.server_replay)\n",
                "\n",
                "        self.debug = options.debug\n",
                "\n",
                "\n",
                "    def _runscript(self, f, path):\n",
                "        path = os.path.expanduser(path)\n",
                "        self.state.last_script = path\n",
                "        try:\n",
                "            serr = f.run_script(path)\n",
                "        except flow.RunException, e:\n",
                "            if e.errout:\n",
                "                serr = \"Script error code: %s\\n\\n\"%e.returncode + e.errout\n",
                "                self.spawn_external_viewer(serr, None)\n",
                "            self.statusbar.message(\"Script error: %s\"%e)\n",
                "            return\n",
                "        if serr:\n",
                "            serr = \"Script output:\\n\\n\" + serr\n",
                "            self.spawn_external_viewer(serr, None)\n",
                "        self.refresh_connection(f)\n",
                "\n",
                "    def _trailer(self, clen, txt):\n",
                "        rem = clen - VIEW_CUTOFF\n",
                "        if rem > 0:\n",
                "            txt.append(urwid.Text(\"\"))\n",
                "            txt.append(\n",
                "                urwid.Text(\n",
                "                    [\n",
                "                        (\"highlight\", \"... %s of data not shown\"%utils.pretty_size(rem))\n",
                "                    ]\n",
                "                )\n",
                "            )\n",
                "\n",
                "    def _view_conn_raw(self, content, txt):\n",
                "        for i in utils.cleanBin(content[:VIEW_CUTOFF]).splitlines():\n",
                "            txt.append(\n",
                "                urwid.Text((\"text\", i))\n",
                "            )\n",
                "        self._trailer(len(content), txt)\n",
                "\n",
                "    def _view_conn_binary(self, content, txt):\n",
                "        for offset, hex, s in utils.hexdump(content[:VIEW_CUTOFF]):\n",
                "            txt.append(urwid.Text([\n",
                "                (\"offset\", offset),\n",
                "                \" \",\n",
                "                (\"text\", hex),\n",
                "                \"   \",\n",
                "                (\"text\", s),\n",
                "            ]))\n",
                "        self._trailer(len(content), txt)\n",
                "\n",
                "    def _view_conn_xmlish(self, content, txt):\n",
                "        for i in utils.pretty_xmlish(content[:VIEW_CUTOFF]):\n",
                "            txt.append(\n",
                "                urwid.Text((\"text\", i)),\n",
                "            )\n",
                "        self._trailer(len(content), txt)\n",
                "\n",
                "    def _view_conn_json(self, lines, txt):\n",
                "        sofar = 0\n",
                "        for i in lines:\n",
                "            sofar += len(i)\n",
                "            txt.append(\n",
                "                urwid.Text((\"text\", i)),\n",
                "            )\n",
                "            if sofar > VIEW_CUTOFF:\n",
                "                break\n",
                "        self._trailer(sum(len(i) for i in lines), txt)\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    def _view_conn_urlencoded(self, lines, txt):\n",
                    "        txt.append(urwid.Text((\"highlight\", \"URLencoded data:\\n\")))\n",
                    "        txt.append(\n",
                    "            urwid.Text(\n",
                    "                format_keyvals(\n",
                    "                    [(k+\":\", v) for (k, v) in lines],\n",
                    "                    key = \"header\",\n",
                    "                    val = \"text\"\n",
                    "                )\n",
                    "            )\n",
                    "        )\n"
                ],
                "parent_version_range": {
                    "start": 926,
                    "end": 926
                },
                "child_version_range": {
                    "start": 926,
                    "end": 937
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "ConsoleMaster",
                        "signature": "class ConsoleMaster(flow.FlowMaster):",
                        "at_line": 801
                    }
                ],
                "idx": 0,
                "hunk_diff": "File: libmproxy/console.py\nCode:\n           class ConsoleMaster(flow.FlowMaster):\n               ...\n923 923                    break\n924 924            self._trailer(sum(len(i) for i in lines), txt)\n925 925    \n    926  +     def _view_conn_urlencoded(self, lines, txt):\n    927  +         txt.append(urwid.Text((\"highlight\", \"URLencoded data:\\n\")))\n    928  +         txt.append(\n    929  +             urwid.Text(\n    930  +                 format_keyvals(\n    931  +                     [(k+\":\", v) for (k, v) in lines],\n    932  +                     key = \"header\",\n    933  +                     val = \"text\"\n    934  +                 )\n    935  +             )\n    936  +         )\n926 937    \n927 938        def _find_pretty_view(self, content, hdrItems, txt):\n928 939            ctype = None\n         ...\n",
                "file_path": "libmproxy/console.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "Text",
                    "_view_conn_urlencoded",
                    "append",
                    "format_keyvals",
                    "k",
                    "key",
                    "lines",
                    "self",
                    "txt",
                    "urwid",
                    "v",
                    "val"
                ],
                "prefix": [
                    "                break\n",
                    "        self._trailer(sum(len(i) for i in lines), txt)\n",
                    "\n"
                ],
                "suffix": [
                    "\n",
                    "    def _find_pretty_view(self, content, hdrItems, txt):\n",
                    "        ctype = None\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "_view_conn_urlencoded",
                            "position": {
                                "start": {
                                    "line": 926,
                                    "column": 8
                                },
                                "end": {
                                    "line": 926,
                                    "column": 29
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/libmproxy/console.py",
                            "hunk_idx": 0,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "\n",
                "    def _find_pretty_view(self, content, hdrItems, txt):\n",
                "        ctype = None\n",
                "        for i in hdrItems:\n",
                "            if i[0] == \"content-type\":\n",
                "                ctype = i[1]\n",
                "                break\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "        if ctype and \"x-www-form-urlencoded\" in ctype:\n",
                    "            data = utils.urldecode(content)\n",
                    "            if data:\n",
                    "                return self._view_conn_urlencoded(data, txt)\n"
                ],
                "parent_version_range": {
                    "start": 933,
                    "end": 933
                },
                "child_version_range": {
                    "start": 944,
                    "end": 948
                },
                "control_flow": [
                    {
                        "type": "for_statement",
                        "statement": "for i in hdrItems:",
                        "start_line": 929,
                        "end_line": 932
                    },
                    {
                        "type": "if_statement",
                        "statement": "if i[0] == \"content-type\":",
                        "start_line": 930,
                        "end_line": 932
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "ConsoleMaster",
                        "signature": "class ConsoleMaster(flow.FlowMaster):",
                        "at_line": 801
                    },
                    {
                        "type": "function",
                        "name": "_find_pretty_view",
                        "signature": "def _find_pretty_view(self, content, hdrItems, txt):",
                        "at_line": 927
                    }
                ],
                "idx": 1,
                "hunk_diff": "File: libmproxy/console.py\nCode:\n           class ConsoleMaster(flow.FlowMaster):\n               ...\n               def _find_pretty_view(self, content, hdrItems, txt):\n                   ...\n930 941                if i[0] == \"content-type\":\n931 942                    ctype = i[1]\n932 943                    break\n    944  +         if ctype and \"x-www-form-urlencoded\" in ctype:\n    945  +             data = utils.urldecode(content)\n    946  +             if data:\n    947  +                 return self._view_conn_urlencoded(data, txt)\n933 948            if utils.isXML(content):\n934 949                return self._view_conn_xmlish(content, txt)\n         ...\n",
                "file_path": "libmproxy/console.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "_view_conn_urlencoded",
                    "content",
                    "ctype",
                    "data",
                    "self",
                    "txt",
                    "urldecode",
                    "utils"
                ],
                "prefix": [
                    "            if i[0] == \"content-type\":\n",
                    "                ctype = i[1]\n",
                    "                break\n"
                ],
                "suffix": [
                    "        if utils.isXML(content):\n",
                    "            return self._view_conn_xmlish(content, txt)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 0,
                        "detail": {
                            "identifier": "_view_conn_urlencoded",
                            "position": {
                                "start": {
                                    "line": 947,
                                    "column": 28
                                },
                                "end": {
                                    "line": 947,
                                    "column": 49
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/libmproxy/console.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "urldecode",
                            "position": {
                                "start": {
                                    "line": 945,
                                    "column": 25
                                },
                                "end": {
                                    "line": 945,
                                    "column": 34
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/libmproxy/console.py",
                            "hunk_idx": 1,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "        if utils.isXML(content):\n",
                "            return self._view_conn_xmlish(content, txt)\n"
            ],
            {
                "type": "replace",
                "before": [
                    "        if ctype and \"application/json\" in ctype:\n"
                ],
                "after": [
                    "        elif ctype and \"application/json\" in ctype:\n"
                ],
                "parent_version_range": {
                    "start": 935,
                    "end": 936
                },
                "child_version_range": {
                    "start": 950,
                    "end": 951
                },
                "control_flow": [
                    {
                        "type": "if_statement",
                        "statement": "if ctype and \"application/json\" in ctype:",
                        "start_line": 935,
                        "end_line": 938
                    }
                ],
                "structural_path": [
                    {
                        "type": "class",
                        "name": "ConsoleMaster",
                        "signature": "class ConsoleMaster(flow.FlowMaster):",
                        "at_line": 801
                    },
                    {
                        "type": "function",
                        "name": "_find_pretty_view",
                        "signature": "def _find_pretty_view(self, content, hdrItems, txt):",
                        "at_line": 927
                    }
                ],
                "idx": 2,
                "hunk_diff": "File: libmproxy/console.py\nCode:\n           class ConsoleMaster(flow.FlowMaster):\n               ...\n               def _find_pretty_view(self, content, hdrItems, txt):\n                   ...\n933 948            if utils.isXML(content):\n934 949                return self._view_conn_xmlish(content, txt)\n935      -         if ctype and \"application/json\" in ctype:\n    950  +         elif ctype and \"application/json\" in ctype:\n936 951                lines = utils.pretty_json(content)\n937 952                if lines:\n938 953                    return self._view_conn_json(lines, txt)\n         ...\n",
                "file_path": "libmproxy/console.py",
                "identifiers_before": [
                    "ctype"
                ],
                "identifiers_after": [
                    "ctype",
                    "elif"
                ],
                "prefix": [
                    "        if utils.isXML(content):\n",
                    "            return self._view_conn_xmlish(content, txt)\n"
                ],
                "suffix": [
                    "            lines = utils.pretty_json(content)\n",
                    "            if lines:\n",
                    "                return self._view_conn_json(lines, txt)\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "            lines = utils.pretty_json(content)\n",
                "            if lines:\n",
                "                return self._view_conn_json(lines, txt)\n",
                "        return self._view_conn_raw(content, txt)\n",
                "\n",
                "    @utils.LRUCache(20)\n",
                "    def _cached_conn_text(self, content, hdrItems, viewmode):\n",
                "        hdr = []\n",
                "        hdr.extend(\n",
                "            format_keyvals(\n",
                "                [(h+\":\", v) for (h, v) in hdrItems],\n",
                "                key = \"header\",\n",
                "                val = \"text\"\n",
                "            )\n",
                "        )\n",
                "        hdr.append(\"\\n\")\n",
                "\n",
                "        txt = [urwid.Text(hdr)]\n",
                "        if content:\n",
                "            if viewmode == VIEW_BODY_HEX:\n",
                "                self._view_conn_binary(content, txt)\n",
                "            elif viewmode == VIEW_BODY_PRETTY:\n",
                "                self._find_pretty_view(content, hdrItems, txt)\n",
                "            else:\n",
                "                self._view_conn_raw(content, txt)\n",
                "        return urwid.ListBox(txt)\n",
                "\n",
                "    def _readflow(self, path):\n",
                "        path = os.path.expanduser(path)\n",
                "        try:\n",
                "            f = file(path, \"r\")\n",
                "            flows = list(flow.FlowReader(f).stream())\n",
                "        except (IOError, flow.FlowReadError), v:\n",
                "            return True, v.strerror\n",
                "        return False, flows\n",
                "\n",
                "    def client_playback_path(self, path):\n",
                "        err, ret = self._readflow(path)\n",
                "        if err:\n",
                "            self.statusbar.message(ret)\n",
                "        else:\n",
                "            self.start_client_playback(ret, False)\n",
                "\n",
                "    def server_playback_path(self, path):\n",
                "        err, ret = self._readflow(path)\n",
                "        if err:\n",
                "            self.statusbar.message(ret)\n",
                "        else:\n",
                "            self.start_server_playback(\n",
                "                ret,\n",
                "                self.killextra, self.rheaders,\n",
                "                False\n",
                "            )\n",
                "\n",
                "    def spawn_external_viewer(self, data, contenttype):\n",
                "        if contenttype:\n",
                "            ext = mimetypes.guess_extension(contenttype) or \"\"\n",
                "        else:\n",
                "            ext = \"\"\n",
                "        fd, name = tempfile.mkstemp(ext, \"mproxy\")\n",
                "        os.write(fd, data)\n",
                "        os.close(fd)\n",
                "\n",
                "        cmd = None\n",
                "        shell = False\n",
                "\n",
                "        if contenttype:\n",
                "            c = mailcap.getcaps()\n",
                "            cmd, _ = mailcap.findmatch(c, contenttype, filename=name)\n",
                "            if cmd:\n",
                "                shell = True\n",
                "        if not cmd:\n",
                "            c = os.environ.get(\"PAGER\") or os.environ.get(\"EDITOR\")\n",
                "            cmd = [c, name]\n",
                "        self.ui.stop()\n",
                "        ret = subprocess.call(cmd, shell=shell)\n",
                "        self.ui.start()\n",
                "        os.unlink(name)\n",
                "\n",
                "    def set_palette(self):\n",
                "        BARBG = \"dark blue\"\n",
                "        self.palette = [\n",
                "            ('body', 'black', 'dark cyan', 'standout'),\n",
                "            ('foot', 'light gray', 'default'),\n",
                "            ('title', 'white,bold', 'default',),\n",
                "            ('editline', 'white', 'default',),\n",
                "\n",
                "            # Status bar\n",
                "            ('statusbar', 'light gray', BARBG),\n",
                "            ('statusbar_key', 'light cyan', BARBG),\n",
                "            ('statusbar_text', 'light gray', BARBG),\n",
                "            ('statusbar_highlight', 'white', BARBG),\n",
                "\n",
                "            # Help\n",
                "            ('key', 'light cyan', 'default', 'underline'),\n",
                "            ('head', 'white,bold', 'default'),\n",
                "            ('text', 'light gray', 'default'),\n",
                "\n",
                "            # List and Connections\n",
                "            ('method', 'dark cyan', 'default'),\n",
                "            ('focus', 'yellow', 'default'),\n",
                "            ('goodcode', 'light green', 'default'),\n",
                "            ('error', 'light red', 'default'),\n",
                "            ('header', 'dark cyan', 'default'),\n",
                "            ('heading', 'white,bold', 'dark blue'),\n",
                "            ('highlight', 'white,bold', 'default'),\n",
                "            ('inactive', 'dark gray', 'default'),\n",
                "            ('ack', 'light red', 'default'),\n",
                "\n",
                "            # Hex view\n",
                "            ('offset', 'dark cyan', 'default'),\n",
                "        ]\n",
                "\n",
                "    def run(self):\n",
                "        self.viewstate = VIEW_CONNLIST\n",
                "        self.currentflow = None\n",
                "\n",
                "        self.ui = urwid.raw_display.Screen()\n",
                "        self.ui.register_palette(self.palette)\n",
                "        self.conn_list_view = ConnectionListView(self, self.state)\n",
                "\n",
                "        self.view = None\n",
                "        self.statusbar = None\n",
                "        self.header = None\n",
                "        self.body = None\n",
                "\n",
                "        self.prompting = False\n",
                "        self.onekey = False\n",
                "        self.view_connlist()\n",
                "\n",
                "        if self.server:\n",
                "            slave = controller.Slave(self.masterq, self.server)\n",
                "            slave.start()\n",
                "\n",
                "        if self.options.rfile:\n",
                "            self.load_flows(self.options.rfile)\n",
                "\n",
                "        self.ui.run_wrapper(self.loop)\n",
                "        # If True, quit just pops out to connection list view.\n",
                "        print >> sys.stderr, \"Shutting down...\"\n",
                "        sys.stderr.flush()\n",
                "        self.shutdown()\n",
                "\n",
                "    def make_view(self):\n",
                "        self.view = urwid.Frame(\n",
                "                        self.body,\n",
                "                        header = self.header,\n",
                "                        footer = self.statusbar\n",
                "                    )\n",
                "        self.view.set_focus(\"body\")\n",
                "\n",
                "    def view_help(self):\n",
                "        self.statusbar = StatusBar(self, self.footer_text_help)\n",
                "        self.body = self.helptext()\n",
                "        self.header = None\n",
                "        self.viewstate = VIEW_HELP\n",
                "        self.make_view()\n",
                "\n",
                "    def focus_current(self):\n",
                "        if self.currentflow:\n",
                "            try:\n",
                "                ids = [id(i) for i in self.state.view]\n",
                "                idx = ids.index(id(self.currentflow))\n",
                "                self.conn_list_view.set_focus(idx)\n",
                "            except (IndexError, ValueError):\n",
                "                pass\n",
                "\n",
                "    def view_connlist(self):\n",
                "        if self.ui.started:\n",
                "            self.ui.clear()\n",
                "        self.focus_current()\n",
                "        self.body = urwid.ListBox(self.conn_list_view)\n",
                "        self.statusbar = StatusBar(self, self.footer_text_default)\n",
                "        self.header = None\n",
                "        self.viewstate = VIEW_CONNLIST\n",
                "        self.currentflow = None\n",
                "        self.make_view()\n",
                "\n",
                "    def view_flow(self, flow):\n",
                "        self.statusbar = StatusBar(self, self.footer_text_connview)\n",
                "        self.body = ConnectionView(self, self.state, flow)\n",
                "        self.header = ConnectionViewHeader(self, flow)\n",
                "        self.viewstate = VIEW_FLOW\n",
                "        self.currentflow = flow\n",
                "        self.make_view()\n",
                "\n",
                "    def _view_nextprev_flow(self, np, flow):\n",
                "        try:\n",
                "            idx = self.state.view.index(flow)\n",
                "        except IndexError:\n",
                "            return\n",
                "        if np == \"next\":\n",
                "            new_flow, new_idx = self.state.get_next(idx)\n",
                "        else:\n",
                "            new_flow, new_idx = self.state.get_prev(idx)\n",
                "        if new_idx is None:\n",
                "            return\n",
                "        self.view_flow(new_flow)\n",
                "\n",
                "    def view_next_flow(self, flow):\n",
                "        return self._view_nextprev_flow(\"next\", flow)\n",
                "\n",
                "    def view_prev_flow(self, flow):\n",
                "        return self._view_nextprev_flow(\"prev\", flow)\n",
                "\n",
                "    def _write_flows(self, path, flows):\n",
                "        self.state.last_saveload = path\n",
                "        if not path:\n",
                "            return \n",
                "        path = os.path.expanduser(path)\n",
                "        try:\n",
                "            f = file(path, \"wb\")\n",
                "            fw = flow.FlowWriter(f)\n",
                "            for i in flows:\n",
                "                fw.add(i)\n",
                "            f.close()\n",
                "        except IOError, v:\n",
                "            self.statusbar.message(v.strerror)\n",
                "\n",
                "    def save_one_flow(self, path, flow):\n",
                "        return self._write_flows(path, [flow])\n",
                "\n",
                "    def save_flows(self, path):\n",
                "        return self._write_flows(path, self.state.view)\n",
                "\n",
                "    def load_flows(self, path):\n",
                "        if not path:\n",
                "            return \n",
                "        self.state.last_saveload = path\n",
                "        path = os.path.expanduser(path)\n",
                "        try:\n",
                "            f = file(path, \"r\")\n",
                "            fr = flow.FlowReader(f)\n",
                "        except IOError, v:\n",
                "            return v.strerror\n",
                "        flow.FlowMaster.load_flows(self, fr)\n",
                "        f.close()\n",
                "        if self.conn_list_view:\n",
                "            self.sync_list_view()\n",
                "            self.focus_current()\n",
                "        return \"Flows loaded from %s\"%path\n",
                "\n",
                "    def helptext(self):\n",
                "        text = []\n",
                "        text.extend([(\"head\", \"Global keys:\\n\")])\n",
                "        keys = [\n",
                "            (\"A\", \"accept all intercepted connections\"),\n",
                "            (\"a\", \"accept this intercepted connection\"),\n",
                "            (\"c\", \"client replay\"),\n",
                "            (\"i\", \"set interception pattern\"),\n",
                "            (\"j, k\", \"up, down\"),\n",
                "            (\"l\", \"set limit filter pattern\"),\n",
                "            (\"L\", \"load saved flows\"),\n",
                "            (\"o\", \"toggle options:\"),\n",
                "            (None, \"  anticache: modify requests to prevent cached responses\"),\n",
                "            (None, \"  killextra: kill requests not part of server replay\"),\n",
                "            (None, \"  norefresh: disable server replay response refresh\"),\n",
                "            (\"q\", \"quit / return to connection list\"),\n",
                "            (\"Q\", \"quit without confirm prompt\"),\n",
                "            (\"r\", \"replay request\"),\n",
                "            (\"R\", \"revert changes to request\"),\n",
                "            (\"S\", \"save all flows matching current limit\"),\n",
                "            (\"s\", \"server replay\"),\n",
                "            (\"t\", \"set sticky cookie expression\"),\n",
                "            (\"u\", \"set sticky auth expression\"),\n",
                "            (\"w\", \"save this flow\"),\n",
                "            (\"page up/down\", \"page up/down\"),\n",
                "            (\"enter\", \"view connection\"),\n",
                "        ]\n",
                "        text.extend(format_keyvals(keys, key=\"key\", val=\"text\", indent=4))\n",
                "\n",
                "        text.extend([(\"head\", \"\\n\\nConnection list keys:\\n\")])\n",
                "        keys = [\n",
                "            (\"C\", \"clear connection list\"),\n",
                "            (\"d\", \"delete connection from view\"),\n",
                "            (\"z\", \"kill and delete connection, even if it's mid-intercept\"),\n",
                "            (\"space\", \"page down\"),\n",
                "        ]\n",
                "        text.extend(format_keyvals(keys, key=\"key\", val=\"text\", indent=4))\n",
                "\n",
                "        text.extend([(\"head\", \"\\n\\nConnection view keys:\\n\")])\n",
                "        keys = [\n",
                "            (\"b\", \"save request/response body\"),\n",
                "            (\"e\", \"edit request/response\"),\n",
                "            (\"m\", \"change view mode (raw, pretty, hex)\"),\n",
                "            (None, \"  raw: raw data\"),\n",
                "            (None, \"  pretty: pretty-print XML, HTML and JSON\"),\n",
                "            (None, \"  hex: hex dump\"),\n",
                "            (\"p\", \"previous flow\"),\n",
                "            (\"v\", \"view body in external viewer\"),\n",
                "            (\"|\", \"run script\"),\n",
                "            (\"tab\", \"toggle response/request view\"),\n",
                "            (\"space\", \"next flow\"),\n",
                "        ]\n",
                "        text.extend(format_keyvals(keys, key=\"key\", val=\"text\", indent=4))\n",
                "\n",
                "        text.extend([(\"head\", \"\\n\\nFilter expressions:\\n\")])\n",
                "        f = []\n",
                "        for i in filt.filt_unary:\n",
                "            f.append(\n",
                "                (\"~%s\"%i.code, i.help)\n",
                "            )\n",
                "        for i in filt.filt_rex:\n",
                "            f.append(\n",
                "                (\"~%s regex\"%i.code, i.help)\n",
                "            )\n",
                "        for i in filt.filt_int:\n",
                "            f.append(\n",
                "                (\"~%s int\"%i.code, i.help)\n",
                "            )\n",
                "        f.sort()\n",
                "        f.extend(\n",
                "            [\n",
                "                (\"!\", \"unary not\"),\n",
                "                (\"&\", \"and\"),\n",
                "                (\"|\", \"or\"),\n",
                "                (\"(...)\", \"grouping\"),\n",
                "            ]\n",
                "        )\n",
                "        text.extend(format_keyvals(f, key=\"key\", val=\"text\", indent=4))\n",
                "\n",
                "        text.extend(\n",
                "           [\n",
                "                \"\\n\",\n",
                "                (\"text\", \"    Regexes are Python-style.\\n\"),\n",
                "                (\"text\", \"    Regexes can be specified as quoted strings.\\n\"),\n",
                "                (\"text\", \"    Header matching (~h, ~hq, ~hs) is against a string of the form \\\"name: value\\\".\\n\"),\n",
                "                (\"text\", \"    Expressions with no operators are regex matches against URL.\\n\"),\n",
                "                (\"text\", \"    Default binary operator is &.\\n\"),\n",
                "                (\"head\", \"\\n    Examples:\\n\"),\n",
                "           ]\n",
                "        )\n",
                "        examples = [\n",
                "                (\"google\\.com\", \"Url containing \\\"google.com\"),\n",
                "                (\"~r ~b test\", \"Requests where body contains \\\"test\\\"\"),\n",
                "                (\"!(~r & ~t \\\"text/html\\\")\", \"Anything but requests with a text/html content type.\"),\n",
                "        ]\n",
                "        text.extend(format_keyvals(examples, key=\"key\", val=\"text\", indent=4))\n",
                "        return urwid.ListBox([urwid.Text(text)])\n",
                "\n",
                "    def path_prompt(self, prompt, text, callback, *args):\n",
                "        self.statusbar.path_prompt(prompt, text)\n",
                "        self.view.set_focus(\"footer\")\n",
                "        self.prompting = (callback, args)\n",
                "\n",
                "    def prompt(self, prompt, text, callback, *args):\n",
                "        self.statusbar.prompt(prompt, text)\n",
                "        self.view.set_focus(\"footer\")\n",
                "        self.prompting = (callback, args)\n",
                "\n",
                "    def prompt_edit(self, prompt, text, callback):\n",
                "        self.statusbar.prompt(prompt + \": \", text)\n",
                "        self.view.set_focus(\"footer\")\n",
                "        self.prompting = (callback, [])\n",
                "\n",
                "    def prompt_onekey(self, prompt, keys, callback):\n",
                "        \"\"\"\n",
                "            Keys are a set of (word, key) tuples. The appropriate key in the\n",
                "            word is highlighted. \n",
                "        \"\"\"\n",
                "        prompt = [prompt, \" (\"]\n",
                "        mkup = []\n",
                "        for i, e in enumerate(keys):\n",
                "            parts = e[0].split(e[1], 1)\n",
                "            if parts[0]:\n",
                "                mkup.append((\"text\", parts[0]))\n",
                "            mkup.append((\"key\", e[1]))\n",
                "            if parts[1]:\n",
                "                mkup.append((\"text\", parts[1]))\n",
                "            if i < len(keys)-1:\n",
                "                mkup.append(\",\")\n",
                "        prompt.extend(mkup)\n",
                "        prompt.append(\")? \")\n",
                "        self.onekey = \"\".join([i[1] for i in keys])\n",
                "        self.prompt(prompt, \"\", callback)\n",
                "\n",
                "    def prompt_done(self):\n",
                "        self.prompting = False\n",
                "        self.onekey = False\n",
                "        self.view.set_focus(\"body\")\n",
                "        self.statusbar.message(\"\")\n",
                "\n",
                "    def prompt_execute(self, txt=None):\n",
                "        if not txt:\n",
                "            txt = self.statusbar.get_edit_text()\n",
                "        p, args = self.prompting\n",
                "        self.prompt_done()\n",
                "        msg = p(txt, *args)\n",
                "        if msg:\n",
                "            self.statusbar.message(msg, 1000)\n",
                "\n",
                "    def prompt_cancel(self):\n",
                "        self.prompt_done()\n",
                "\n",
                "    def accept_all(self):\n",
                "        self.state.accept_all()\n",
                "\n",
                "    def set_limit(self, txt):\n",
                "        return self.state.set_limit(txt)\n",
                "\n",
                "    def set_intercept(self, txt):\n",
                "        return self.state.set_intercept(txt)\n",
                "\n",
                "    def changeview(self, v):\n",
                "        if v == \"r\":\n",
                "            self.state.view_body_mode = VIEW_BODY_RAW\n",
                "        elif v == \"h\":\n",
                "            self.state.view_body_mode = VIEW_BODY_HEX\n",
                "        elif v == \"p\":\n",
                "            self.state.view_body_mode = VIEW_BODY_PRETTY\n",
                "        self.refresh_connection(self.currentflow)\n",
                "\n",
                "    def drawscreen(self):\n",
                "        size = self.ui.get_cols_rows()\n",
                "        canvas = self.view.render(size, focus=1)\n",
                "        self.ui.draw_screen(size, canvas)\n",
                "        return size\n",
                "\n",
                "    def loop(self):\n",
                "        changed = True\n",
                "        try:\n",
                "            while not controller.exit:\n",
                "                startloop = time.time()\n",
                "                if changed:\n",
                "                    self.statusbar.redraw()\n",
                "                    size = self.drawscreen()\n",
                "                changed = self.tick(self.masterq)\n",
                "                self.ui.set_input_timeouts(max_wait=0.1)\n",
                "                keys = self.ui.get_input()\n",
                "                if keys:\n",
                "                    changed = True\n",
                "                for k in keys:\n",
                "                    if self.prompting:\n",
                "                        if k == \"esc\":\n",
                "                            self.prompt_cancel()\n",
                "                            k = None\n",
                "                        elif self.onekey:\n",
                "                            if k == \"enter\":\n",
                "                                self.prompt_cancel()\n",
                "                            elif k in self.onekey:\n",
                "                                self.prompt_execute(k)\n",
                "                            k = None\n",
                "                        elif k == \"enter\":\n",
                "                            self.prompt_execute()\n",
                "                            k = None\n",
                "                    else:\n",
                "                        self.statusbar.message(\"\")\n",
                "                        if k == \"?\":\n",
                "                            self.view_help()\n",
                "                        elif k == \"c\":\n",
                "                            if not self.client_playback:\n",
                "                                self.path_prompt(\n",
                "                                    \"Client replay: \",\n",
                "                                    self.state.last_saveload,\n",
                "                                    self.client_playback_path\n",
                "                                )\n",
                "                            else:\n",
                "                                self.prompt_onekey(\n",
                "                                    \"Stop current client replay?\",\n",
                "                                    (\n",
                "                                        (\"yes\", \"y\"),\n",
                "                                        (\"no\", \"n\"),\n",
                "                                    ),\n",
                "                                    self.stop_client_playback_prompt,\n",
                "                                )\n",
                "\n",
                "                            k = None\n",
                "                        elif k == \"l\":\n",
                "                            self.prompt(\"Limit: \", self.state.limit_txt, self.set_limit)\n",
                "                            self.sync_list_view()\n",
                "                            k = None\n",
                "                        elif k == \"i\":\n",
                "                            self.prompt(\n",
                "                                \"Intercept filter: \",\n",
                "                                self.state.intercept_txt,\n",
                "                                self.set_intercept\n",
                "                            )\n",
                "                            self.sync_list_view()\n",
                "                            k = None\n",
                "                        elif k == \"j\":\n",
                "                            k = \"down\"\n",
                "                        elif k == \"k\":\n",
                "                            k = \"up\"\n",
                "                        elif k == \"m\":\n",
                "                            self.prompt_onekey(\n",
                "                                \"View\",\n",
                "                                (\n",
                "                                    (\"raw\", \"r\"),\n",
                "                                    (\"pretty\", \"p\"),\n",
                "                                    (\"hex\", \"h\"),\n",
                "                                ),\n",
                "                                self.changeview\n",
                "                            )\n",
                "                            k = None\n",
                "                        elif k in (\"q\", \"Q\"):\n",
                "                            if k == \"Q\":\n",
                "                                raise Stop\n",
                "                            if self.viewstate == VIEW_FLOW:\n",
                "                                self.view_connlist()\n",
                "                            elif self.viewstate == VIEW_HELP:\n",
                "                                if self.currentflow:\n",
                "                                    self.view_flow(self.currentflow)\n",
                "                                else:\n",
                "                                    self.view_connlist()\n",
                "                            else:\n",
                "                                self.prompt_onekey(\n",
                "                                    \"Quit\",\n",
                "                                    (\n",
                "                                        (\"yes\", \"y\"),\n",
                "                                        (\"no\", \"n\"),\n",
                "                                    ),\n",
                "                                    self.quit,\n",
                "                                )\n",
                "                            k = None\n",
                "                        elif k == \"S\":\n",
                "                            self.path_prompt(\n",
                "                                \"Save flows: \",\n",
                "                                self.state.last_saveload,\n",
                "                                self.save_flows\n",
                "                            )\n",
                "                            k = None\n",
                "                        elif k == \"s\":\n",
                "                            if not self.server_playback:\n",
                "                                self.path_prompt(\n",
                "                                    \"Server replay: \",\n",
                "                                    self.state.last_saveload,\n",
                "                                    self.server_playback_path\n",
                "                                )\n",
                "                            else:\n",
                "                                self.prompt_onekey(\n",
                "                                    \"Stop current server replay?\",\n",
                "                                    (\n",
                "                                        (\"yes\", \"y\"),\n",
                "                                        (\"no\", \"n\"),\n",
                "                                    ),\n",
                "                                    self.stop_server_playback_prompt,\n",
                "                                )\n",
                "                            k = None\n",
                "                        elif k == \"L\":\n",
                "                            self.path_prompt(\n",
                "                                \"Load flows: \",\n",
                "                                self.state.last_saveload,\n",
                "                                self.load_flows\n",
                "                            )\n",
                "                            k = None\n",
                "                        elif k == \"o\":\n",
                "                            self.prompt_onekey(\n",
                "                                    \"Options\",\n",
                "                                    (\n",
                "                                        (\"anticache\", \"a\"),\n",
                "                                        (\"killextra\", \"k\"),\n",
                "                                        (\"norefresh\", \"n\"),\n",
                "                                    ),\n",
                "                                    self._change_options\n",
                "                            )\n",
                "                            k = None\n",
                "                        elif k == \"t\":\n",
                "                            self.prompt(\n",
                "                                \"Sticky cookie filter: \",\n",
                "                                self.stickycookie_txt,\n",
                "                                self.set_stickycookie\n",
                "                            )\n",
                "                            k = None\n",
                "                        elif k == \"u\":\n",
                "                            self.prompt(\n",
                "                                \"Sticky auth filter: \",\n",
                "                                self.stickyauth_txt,\n",
                "                                self.set_stickyauth\n",
                "                            )\n",
                "                            k = None\n",
                "                    if k:\n",
                "                        self.view.keypress(size, k)\n",
                "                self.looptime = time.time() - startloop\n",
                "        except (Stop, KeyboardInterrupt):\n",
                "            pass\n",
                "\n",
                "    def stop_client_playback_prompt(self, a):\n",
                "        if a != \"n\":\n",
                "            self.stop_client_playback()\n",
                "\n",
                "    def stop_server_playback_prompt(self, a):\n",
                "        if a != \"n\":\n",
                "            self.stop_server_playback()\n",
                "\n",
                "    def quit(self, a):\n",
                "        if a != \"n\":\n",
                "            raise Stop\n",
                "\n",
                "    def _change_options(self, a):\n",
                "        if a == \"a\":\n",
                "            self.anticache = not self.anticache\n",
                "        elif a == \"k\":\n",
                "            self.killextra = not self.killextra\n",
                "        elif a == \"n\":\n",
                "            self.refresh_server_playback = not self.refresh_server_playback\n",
                "\n",
                "    def shutdown(self):\n",
                "        for i in self.state.flow_list:\n",
                "            i.kill(self)\n",
                "        controller.Master.shutdown(self)\n",
                "\n",
                "    def sync_list_view(self):\n",
                "        self.conn_list_view._modified()\n",
                "\n",
                "    def clear_connections(self):\n",
                "        self.state.clear()\n",
                "        self.sync_list_view()\n",
                "\n",
                "    def delete_connection(self, f):\n",
                "        self.state.delete_flow(f)\n",
                "        self.sync_list_view()\n",
                "\n",
                "    def refresh_connection(self, c):\n",
                "        if hasattr(self.header, \"refresh_connection\"):\n",
                "            self.header.refresh_connection(c)\n",
                "        if hasattr(self.body, \"refresh_connection\"):\n",
                "            self.body.refresh_connection(c)\n",
                "        if hasattr(self.statusbar, \"refresh_connection\"):\n",
                "            self.statusbar.refresh_connection(c)\n",
                "\n",
                "    def process_flow(self, f, r):\n",
                "        if f.match(self.state.intercept) and not f.request.is_replay():\n",
                "            f.intercept()\n",
                "        else:\n",
                "            r.ack()\n",
                "        self.sync_list_view()\n",
                "        self.refresh_connection(f)\n",
                "\n",
                "    # Handlers\n",
                "    def handle_clientconnect(self, r):\n",
                "        f = flow.FlowMaster.handle_clientconnect(self, r)\n",
                "        if f:\n",
                "            self.sync_list_view()\n",
                "\n",
                "    def handle_error(self, r):\n",
                "        f = flow.FlowMaster.handle_error(self, r)\n",
                "        if f:\n",
                "            self.process_flow(f, r)\n",
                "        return f\n",
                "\n",
                "    def handle_request(self, r):\n",
                "        f = flow.FlowMaster.handle_request(self, r)\n",
                "        if f:\n",
                "            self.process_flow(f, r)\n",
                "        return f\n",
                "\n",
                "    def handle_response(self, r):\n",
                "        f = flow.FlowMaster.handle_response(self, r)\n",
                "        if f:\n",
                "            self.process_flow(f, r)\n",
                "        return f\n",
                ""
            ]
        ],
        "libmproxy/utils.py": [
            [
                "# Copyright (C) 2010  Aldo Cortesi\n",
                "# \n",
                "# This program is free software: you can redistribute it and/or modify\n",
                "# it under the terms of the GNU General Public License as published by\n",
                "# the Free Software Foundation, either version 3 of the License, or\n",
                "# (at your option) any later version.\n",
                "# \n",
                "# This program is distributed in the hope that it will be useful,\n",
                "# but WITHOUT ANY WARRANTY; without even the implied warranty of\n",
                "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n",
                "# GNU General Public License for more details.\n",
                "# \n",
                "# You should have received a copy of the GNU General Public License\n",
                "# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
            ],
            {
                "type": "replace",
                "before": [
                    "import re, os, subprocess, datetime, textwrap, errno, sys, time, functools, copy\n"
                ],
                "after": [
                    "import re, os, subprocess, datetime, textwrap, errno\n",
                    "import time, functools, copy, cgi\n"
                ],
                "parent_version_range": {
                    "start": 14,
                    "end": 15
                },
                "child_version_range": {
                    "start": 14,
                    "end": 16
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 3,
                "hunk_diff": "File: libmproxy/utils.py\nCode:\n  ...\n11 11    # \n12 12    # You should have received a copy of the GNU General Public License\n13 13    # along with this program.  If not, see <http://www.gnu.org/licenses/>.\n14     - import re, os, subprocess, datetime, textwrap, errno, sys, time, functools, copy\n   14  + import re, os, subprocess, datetime, textwrap, errno\n   15  + import time, functools, copy, cgi\n15 16    import json\n16 17    \n17 18    CERT_SLEEP_TIME = 1\n       ...\n",
                "file_path": "libmproxy/utils.py",
                "identifiers_before": [
                    "copy",
                    "datetime",
                    "errno",
                    "functools",
                    "os",
                    "re",
                    "subprocess",
                    "sys",
                    "textwrap",
                    "time"
                ],
                "identifiers_after": [
                    "cgi",
                    "copy",
                    "datetime",
                    "errno",
                    "functools",
                    "os",
                    "re",
                    "subprocess",
                    "textwrap",
                    "time"
                ],
                "prefix": [
                    "# \n",
                    "# You should have received a copy of the GNU General Public License\n",
                    "# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
                ],
                "suffix": [
                    "import json\n",
                    "\n",
                    "CERT_SLEEP_TIME = 1\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "cgi",
                            "position": {
                                "start": {
                                    "line": 15,
                                    "column": 30
                                },
                                "end": {
                                    "line": 15,
                                    "column": 33
                                }
                            },
                            "type": "identifier",
                            "kind": "import",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/libmproxy/utils.py",
                            "hunk_idx": 3,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "import json\n",
                "\n",
                "CERT_SLEEP_TIME = 1\n",
                "\n",
                "def timestamp():\n",
                "    \"\"\"\n",
                "        Returns a serializable UTC timestamp.\n",
                "    \"\"\"\n",
                "    return time.time()\n",
                "\n",
                "\n",
                "def format_timestamp(s):\n",
                "    s = time.localtime(s)\n",
                "    d = datetime.datetime.fromtimestamp(time.mktime(s))\n",
                "    return d.strftime(\"%Y-%m-%d %H:%M:%S\")\n",
                "\n",
                "\n",
                "def isBin(s):\n",
                "    \"\"\"\n",
                "        Does this string have any non-ASCII characters?\n",
                "    \"\"\"\n",
                "    for i in s:\n",
                "        i = ord(i)\n",
                "        if i < 9:\n",
                "            return True\n",
                "        elif i > 13 and i < 32:\n",
                "            return True\n",
                "        elif i > 126:\n",
                "            return True\n",
                "    return False\n",
                "\n",
                "\n",
                "def isXML(s):\n",
                "    for i in s:\n",
                "        if i in \"\\n \\t\":\n",
                "            continue\n",
                "        elif i == \"<\":\n",
                "            return True\n",
                "        else:\n",
                "            return False\n",
                "\n",
                "\n",
                "def cleanBin(s):\n",
                "    parts = []\n",
                "    for i in s:\n",
                "        o = ord(i)\n",
                "        if o > 31 and o < 127:\n",
                "            parts.append(i)\n",
                "        else:\n",
                "            if i not in \"\\n\\r\\t\":\n",
                "                parts.append(\".\")\n",
                "    return \"\".join(parts)\n",
                "    \n",
                "\n",
                "TAG = r\"\"\"\n",
                "        <\\s*\n",
                "        (?!\\s*[!\"])\n",
                "        (?P<close>\\s*\\/)?\n",
                "        (?P<name>\\w+)\n",
                "        (\n",
                "            [^'\"\\t >]+ |\n",
                "            \"[^\\\"]*\"['\\\"]* |\n",
                "            '[^']*'['\\\"]* |\n",
                "            \\s+\n",
                "        )*\n",
                "        (?P<selfcont>\\s*\\/\\s*)?\n",
                "        \\s*>\n",
                "      \"\"\"\n",
                "UNI = set([\"br\", \"hr\", \"img\", \"input\", \"area\", \"link\"])\n",
                "INDENT = \" \"*4\n",
                "def pretty_xmlish(s):\n",
                "    \"\"\"\n",
                "        A robust pretty-printer for XML-ish data.\n",
                "        Returns a list of lines.\n",
                "    \"\"\"\n",
                "    s = cleanBin(s)\n",
                "    data, offset, indent, prev = [], 0, 0, None\n",
                "    for i in re.finditer(TAG, s, re.VERBOSE|re.MULTILINE):\n",
                "        start, end = i.span()\n",
                "        name = i.group(\"name\")\n",
                "        if start > offset:\n",
                "            txt = []\n",
                "            for x in textwrap.dedent(s[offset:start]).split(\"\\n\"):\n",
                "                if x.strip():\n",
                "                    txt.append(indent*INDENT + x)\n",
                "            data.extend(txt)\n",
                "        if i.group(\"close\") and not (name in UNI and name==prev):\n",
                "            indent = max(indent - 1, 0)\n",
                "        data.append(indent*INDENT + i.group().strip())\n",
                "        offset = end\n",
                "        if not any([i.group(\"close\"), i.group(\"selfcont\"), name in UNI]):\n",
                "            indent += 1\n",
                "        prev = name\n",
                "    trail = s[offset:]\n",
                "    if trail.strip():\n",
                "        data.append(s[offset:])\n",
                "    return data\n",
                "\n",
                "\n",
                "def pretty_json(s):\n",
                "    try:\n",
                "        p = json.loads(s)\n",
                "    except ValueError:\n",
                "        return None\n",
                "    return json.dumps(p, sort_keys=True, indent=4).split(\"\\n\")\n",
                "\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "def urldecode(s):\n",
                    "    return cgi.parse_qsl(s)\n",
                    "\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 122,
                    "end": 122
                },
                "child_version_range": {
                    "start": 123,
                    "end": 127
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 4,
                "hunk_diff": "File: libmproxy/utils.py\nCode:\n  ...\n119 120        return json.dumps(p, sort_keys=True, indent=4).split(\"\\n\")\n120 121    \n121 122    \n    123  + def urldecode(s):\n    124  +     return cgi.parse_qsl(s)\n    125  + \n    126  + \n122 127    def hexdump(s):\n123 128        \"\"\"\n124 129            Returns a set of typles:\n         ...\n",
                "file_path": "libmproxy/utils.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "cgi",
                    "parse_qsl",
                    "s",
                    "urldecode"
                ],
                "prefix": [
                    "    return json.dumps(p, sort_keys=True, indent=4).split(\"\\n\")\n",
                    "\n",
                    "\n"
                ],
                "suffix": [
                    "def hexdump(s):\n",
                    "    \"\"\"\n",
                    "        Returns a set of typles:\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 3,
                        "detail": {
                            "identifier": "cgi",
                            "position": {
                                "start": {
                                    "line": 124,
                                    "column": 11
                                },
                                "end": {
                                    "line": 124,
                                    "column": 14
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/libmproxy/utils.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 1,
                        "detail": {
                            "identifier": "urldecode",
                            "position": {
                                "start": {
                                    "line": 123,
                                    "column": 4
                                },
                                "end": {
                                    "line": 123,
                                    "column": 13
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/libmproxy/utils.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    },
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "urldecode",
                            "position": {
                                "start": {
                                    "line": 123,
                                    "column": 4
                                },
                                "end": {
                                    "line": 123,
                                    "column": 13
                                }
                            },
                            "type": "identifier",
                            "kind": "function",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/libmproxy/utils.py",
                            "hunk_idx": 4,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "def hexdump(s):\n",
                "    \"\"\"\n",
                "        Returns a set of typles:\n",
                "            (offset, hex, str)\n",
                "    \"\"\"\n",
                "    parts = []\n",
                "    for i in range(0, len(s), 16):\n",
                "        o = \"%.10x\"%i\n",
                "        part = s[i:i+16]\n",
                "        x = \" \".join([\"%.2x\"%ord(i) for i in part])\n",
                "        if len(part) < 16:\n",
                "            x += \" \"\n",
                "            x += \" \".join([\"  \" for i in range(16-len(part))])\n",
                "        parts.append(\n",
                "            (o, x, cleanBin(part))\n",
                "        )\n",
                "    return parts\n",
                "\n",
                "\n",
                "def isStringLike(anobj):\n",
                "    try:\n",
                "        # Avoid succeeding expensively if anobj is large.\n",
                "        anobj[:0]+''\n",
                "    except:\n",
                "        return 0\n",
                "    else:\n",
                "        return 1\n",
                "\n",
                "\n",
                "def isSequenceLike(anobj):\n",
                "    \"\"\"\n",
                "        Is anobj a non-string sequence type (list, tuple, iterator, or\n",
                "        similar)?  Crude, but mostly effective.\n",
                "    \"\"\"\n",
                "    if not hasattr(anobj, \"next\"):\n",
                "        if isStringLike(anobj):\n",
                "            return 0\n",
                "        try:\n",
                "            anobj[:0]\n",
                "        except:\n",
                "            return 0\n",
                "    return 1\n",
                "\n",
                "\n",
                "def try_del(dict, key):\n",
                "    try:\n",
                "        del dict[key]\n",
                "    except KeyError:\n",
                "        pass\n",
                "\n",
                "\n",
                "class Headers:\n",
                "    def __init__(self, lst=None):\n",
                "        if lst:\n",
                "            self.lst = lst\n",
                "        else:\n",
                "            self.lst = []\n",
                "\n",
                "    def _kconv(self, s):\n",
                "        return s.lower()\n",
                "\n",
                "    def __eq__(self, other):\n",
                "        return self.lst == other.lst\n",
                "\n",
                "    def __getitem__(self, k):\n",
                "        ret = []\n",
                "        k = self._kconv(k)\n",
                "        for i in self.lst:\n",
                "            if self._kconv(i[0]) == k:\n",
                "                ret.append(i[1])\n",
                "        return ret\n",
                "\n",
                "    def _filter_lst(self, k, lst):\n",
                "        new = []\n",
                "        for i in lst:\n",
                "            if self._kconv(i[0]) != k:\n",
                "                new.append(i)\n",
                "        return new\n",
                "\n",
                "    def __setitem__(self, k, hdrs):\n",
                "        k = self._kconv(k)\n",
                "        first = None\n",
                "        new = self._filter_lst(k, self.lst)\n",
                "        for i in hdrs:\n",
                "            new.append((k, i))\n",
                "        self.lst = new\n",
                "\n",
                "    def __delitem__(self, k):\n",
                "        self.lst = self._filter_lst(k, self.lst)\n",
                "\n",
                "    def __contains__(self, k):\n",
                "        for i in self.lst:\n",
                "            if self._kconv(i[0]) == k:\n",
                "                return True\n",
                "        return False\n",
                "\n",
                "    def add(self, key, value):\n",
                "        self.lst.append([key, str(value)])\n",
                "\n",
                "    def get_state(self):\n",
                "        return [tuple(i) for i in self.lst]\n",
                "\n",
                "    @classmethod\n",
                "    def from_state(klass, state):\n",
                "        return klass([list(i) for i in state])\n",
                "\n",
                "    def copy(self):\n",
                "        lst = copy.deepcopy(self.lst)\n",
                "        return Headers(lst)\n",
                "\n",
                "    def __repr__(self):\n",
                "        \"\"\"\n",
                "            Returns a string containing a formatted header string.\n",
                "        \"\"\"\n",
                "        headerElements = []\n",
                "        for itm in self.lst:\n",
                "            headerElements.append(itm[0] + \": \" + itm[1])\n",
                "        headerElements.append(\"\")\n",
                "        return \"\\r\\n\".join(headerElements)\n",
                "\n",
                "    def match_re(self, expr):\n",
                "        \"\"\"\n",
                "            Match the regular expression against each header (key, value) pair.\n",
                "        \"\"\"\n",
                "        for k, v in self.lst:\n",
                "            s = \"%s: %s\"%(k, v)\n",
                "            if re.search(expr, s):\n",
                "                return True\n",
                "        return False\n",
                "\n",
                "    def read(self, fp):\n",
                "        \"\"\"\n",
                "            Read a set of headers from a file pointer. Stop once a blank line\n",
                "            is reached.\n",
                "        \"\"\"\n",
                "        ret = []\n",
                "        name = ''\n",
                "        while 1:\n",
                "            line = fp.readline()\n",
                "            if not line or line == '\\r\\n' or line == '\\n':\n",
                "                break\n",
                "            if line[0] in ' \\t':\n",
                "                # continued header\n",
                "                ret[-1][1] = ret[-1][1] + '\\r\\n ' + line.strip()\n",
                "            else:\n",
                "                i = line.find(':')\n",
                "                # We're being liberal in what we accept, here.\n",
                "                if i > 0:\n",
                "                    name = line[:i]\n",
                "                    value = line[i+1:].strip()\n",
                "                    ret.append([name, value])\n",
                "        self.lst = ret\n",
                "\n",
                "\n",
                "def pretty_size(size):\n",
                "    suffixes = [\n",
                "        (\"B\",   2**10),\n",
                "        (\"kB\",   2**20),\n",
                "        (\"M\",   2**30),\n",
                "    ]\n",
                "    for suf, lim in suffixes:\n",
                "        if size >= lim:\n",
                "            continue\n",
                "        else:\n",
                "            x = round(size/float(lim/2**10), 2)\n",
                "            if x == int(x):\n",
                "                x = int(x)\n",
                "            return str(x) + suf\n",
                "\n",
                "\n",
                "class Data:\n",
                "    def __init__(self, name):\n",
                "        m = __import__(name)\n",
                "        dirname, _ = os.path.split(m.__file__)\n",
                "        self.dirname = os.path.abspath(dirname)\n",
                "\n",
                "    def path(self, path):\n",
                "        \"\"\"\n",
                "            Returns a path to the package data housed at 'path' under this\n",
                "            module.Path can be a path to a file, or to a directory.\n",
                "\n",
                "            This function will raise ValueError if the path does not exist.\n",
                "        \"\"\"\n",
                "        fullpath = os.path.join(self.dirname, path)\n",
                "        if not os.path.exists(fullpath):\n",
                "            raise ValueError, \"dataPath: %s does not exist.\"%fullpath\n",
                "        return fullpath\n",
                "data = Data(__name__)\n",
                "\n",
                "\n",
                "def dummy_ca(path):\n",
                "    \"\"\"\n",
                "        Creates a dummy CA, and writes it to path.\n",
                "\n",
                "        This function also creates the necessary directories if they don't exist.\n",
                "\n",
                "        Returns True if operation succeeded, False if not.\n",
                "    \"\"\"\n",
                "    dirname = os.path.dirname(path)\n",
                "    if not os.path.exists(dirname):\n",
                "        os.makedirs(dirname)\n",
                "\n",
                "    if path.endswith(\".pem\"):\n",
                "        basename, _ = os.path.splitext(path)\n",
                "    else:\n",
                "        basename = path\n",
                "\n",
                "    cmd = [\n",
                "        \"openssl\",\n",
                "        \"req\",\n",
                "        \"-new\",\n",
                "        \"-x509\",\n",
                "        \"-config\", data.path(\"resources/ca.cnf\"),\n",
                "        \"-nodes\",\n",
                "        \"-days\", \"9999\",\n",
                "        \"-out\", path,\n",
                "        \"-newkey\", \"rsa:1024\",\n",
                "        \"-keyout\", path,\n",
                "    ]\n",
                "    ret = subprocess.call(\n",
                "        cmd,\n",
                "        stderr=subprocess.PIPE,\n",
                "        stdout=subprocess.PIPE,\n",
                "        stdin=subprocess.PIPE\n",
                "    )\n",
                "    # begin nocover\n",
                "    if ret:\n",
                "        return False\n",
                "    # end nocover\n",
                "\n",
                "    cmd = [\n",
                "        \"openssl\",\n",
                "        \"pkcs12\",\n",
                "        \"-export\",\n",
                "        \"-password\", \"pass:\",\n",
                "        \"-nokeys\",\n",
                "        \"-in\", path,\n",
                "        \"-out\", os.path.join(dirname, basename + \"-cert.p12\")\n",
                "    ]\n",
                "    ret = subprocess.call(\n",
                "        cmd,\n",
                "        stderr=subprocess.PIPE,\n",
                "        stdout=subprocess.PIPE,\n",
                "        stdin=subprocess.PIPE\n",
                "    )\n",
                "    # begin nocover\n",
                "    if ret:\n",
                "        return False\n",
                "    # end nocover\n",
                "    cmd = [\n",
                "        \"openssl\",\n",
                "        \"x509\",\n",
                "        \"-in\", path,\n",
                "        \"-out\", os.path.join(dirname, basename + \"-cert.pem\")\n",
                "    ]\n",
                "    ret = subprocess.call(\n",
                "        cmd,\n",
                "        stderr=subprocess.PIPE,\n",
                "        stdout=subprocess.PIPE,\n",
                "        stdin=subprocess.PIPE\n",
                "    )\n",
                "    # begin nocover\n",
                "    if ret:\n",
                "        return False\n",
                "    # end nocover\n",
                "\n",
                "    return True\n",
                "\n",
                "\n",
                "def dummy_cert(certdir, ca, commonname):\n",
                "    \"\"\"\n",
                "        certdir: Certificate directory.\n",
                "        ca: Path to the certificate authority file, or None.\n",
                "        commonname: Common name for the generated certificate.\n",
                "\n",
                "        Returns cert path if operation succeeded, None if not.\n",
                "    \"\"\"\n",
                "    certpath = os.path.join(certdir, commonname + \".pem\")\n",
                "    if os.path.exists(certpath):\n",
                "        return certpath\n",
                "\n",
                "    confpath = os.path.join(certdir, commonname + \".cnf\")\n",
                "    reqpath = os.path.join(certdir, commonname + \".req\")\n",
                "\n",
                "    template = open(data.path(\"resources/cert.cnf\")).read()\n",
                "    f = open(confpath, \"w\").write(template%(dict(commonname=commonname)))\n",
                "\n",
                "    if ca:\n",
                "        # Create a dummy signed certificate. Uses same key as the signing CA\n",
                "        cmd = [\n",
                "            \"openssl\",\n",
                "            \"req\",\n",
                "            \"-new\",\n",
                "            \"-config\", confpath,\n",
                "            \"-out\", reqpath,\n",
                "            \"-key\", ca,\n",
                "        ]\n",
                "        ret = subprocess.call(\n",
                "            cmd,\n",
                "            stderr=subprocess.PIPE,\n",
                "            stdout=subprocess.PIPE,\n",
                "            stdin=subprocess.PIPE\n",
                "        )\n",
                "        if ret: return None\n",
                "        cmd = [\n",
                "            \"openssl\",\n",
                "            \"x509\",\n",
                "            \"-req\",\n",
                "            \"-in\", reqpath,\n",
                "            \"-days\", \"9999\",\n",
                "            \"-out\", certpath,\n",
                "            \"-CA\", ca,\n",
                "            \"-CAcreateserial\",\n",
                "            \"-extfile\", confpath,\n",
                "            \"-extensions\", \"v3_cert\",\n",
                "        ]\n",
                "        ret = subprocess.call(\n",
                "            cmd,\n",
                "            stderr=subprocess.PIPE,\n",
                "            stdout=subprocess.PIPE,\n",
                "            stdin=subprocess.PIPE\n",
                "        )\n",
                "        if ret: return None\n",
                "    else:\n",
                "        # Create a new selfsigned certificate + key\n",
                "        cmd = [\n",
                "            \"openssl\",\n",
                "            \"req\",\n",
                "            \"-new\",\n",
                "            \"-x509\",\n",
                "            \"-config\", confpath,\n",
                "            \"-nodes\",\n",
                "            \"-days\", \"9999\",\n",
                "            \"-out\", certpath,\n",
                "            \"-newkey\", \"rsa:1024\",\n",
                "            \"-keyout\", certpath,\n",
                "        ]\n",
                "        ret = subprocess.call(\n",
                "            cmd,\n",
                "            stderr=subprocess.PIPE,\n",
                "            stdout=subprocess.PIPE,\n",
                "            stdin=subprocess.PIPE\n",
                "        )\n",
                "        if ret: return None\n",
                "    return certpath\n",
                "\n",
                "\n",
                "class LRUCache:\n",
                "    \"\"\"\n",
                "        A decorator that implements a self-expiring LRU cache for class\n",
                "        methods (not functions!).\n",
                "\n",
                "        Cache data is tracked as attributes on the object itself. There is\n",
                "        therefore a separate cache for each object instance.\n",
                "    \"\"\"\n",
                "    def __init__(self, size=100):\n",
                "        self.size = size\n",
                "\n",
                "    def __call__(self, f):\n",
                "        cacheName = \"_cached_%s\"%f.__name__\n",
                "        cacheListName = \"_cachelist_%s\"%f.__name__\n",
                "        size = self.size\n",
                "\n",
                "        @functools.wraps(f)\n",
                "        def wrap(self, *args):\n",
                "            if not hasattr(self, cacheName):\n",
                "                setattr(self, cacheName, {})\n",
                "                setattr(self, cacheListName, [])\n",
                "            cache = getattr(self, cacheName)\n",
                "            cacheList = getattr(self, cacheListName)\n",
                "            if cache.has_key(args):\n",
                "                cacheList.remove(args)\n",
                "                cacheList.insert(0, args)\n",
                "                return cache[args]\n",
                "            else:\n",
                "                ret = f(self, *args)\n",
                "                cacheList.insert(0, args)\n",
                "                cache[args] = ret\n",
                "                if len(cacheList) > size:\n",
                "                    d = cacheList.pop()\n",
                "                    cache.pop(d)\n",
                "                return ret\n",
                "        return wrap"
            ]
        ],
        "test/test_utils.py": [
            [
                "import textwrap, cStringIO, os, time, re, json\n",
                "import libpry\n",
                "from libmproxy import utils\n",
                "\n",
                "utils.CERT_SLEEP_TIME = 0\n",
                "\n",
                "\n",
                "class uformat_timestamp(libpry.AutoTree):\n",
                "    def test_simple(self):\n",
                "        assert utils.format_timestamp(utils.timestamp())\n",
                "\n",
                "\n",
                "class uisBin(libpry.AutoTree):\n",
                "    def test_simple(self):\n",
                "        assert not utils.isBin(\"testing\\n\\r\")\n",
                "        assert utils.isBin(\"testing\\x01\")\n",
                "        assert utils.isBin(\"testing\\x0e\")\n",
                "        assert utils.isBin(\"testing\\x7f\")\n",
                "\n",
                "\n",
                "class uisXML(libpry.AutoTree):\n",
                "    def test_simple(self):\n",
                "        assert not utils.isXML(\"foo\")\n",
                "        assert utils.isXML(\"<foo\")\n",
                "        assert utils.isXML(\"  \\n<foo\")\n",
                "\n",
                "\n",
                "class uhexdump(libpry.AutoTree):\n",
                "    def test_simple(self):\n",
                "        assert utils.hexdump(\"one\\0\"*10)\n",
                "\n",
                "\n",
                "class upretty_size(libpry.AutoTree):\n",
                "    def test_simple(self):\n",
                "        assert utils.pretty_size(100) == \"100B\"\n",
                "        assert utils.pretty_size(1024) == \"1kB\"\n",
                "        assert utils.pretty_size(1024 + (1024/2)) == \"1.5kB\"\n",
                "        assert utils.pretty_size(1024*1024) == \"1M\"\n",
                "\n",
                "\n",
                "class uData(libpry.AutoTree):\n",
                "    def test_nonexistent(self):\n",
                "        libpry.raises(\"does not exist\", utils.data.path, \"nonexistent\")\n",
                "\n",
                "\n",
                "class uHeaders(libpry.AutoTree):\n",
                "    def setUp(self):\n",
                "        self.hd = utils.Headers()\n",
                "\n",
                "    def test_read_simple(self):\n",
                "        data = \"\"\"\n",
                "            Header: one\n",
                "            Header2: two\n",
                "            \\r\\n\n",
                "        \"\"\"\n",
                "        data = textwrap.dedent(data)\n",
                "        data = data.strip()\n",
                "        s = cStringIO.StringIO(data)\n",
                "        self.hd.read(s)\n",
                "        assert self.hd[\"header\"] == [\"one\"]\n",
                "        assert self.hd[\"header2\"] == [\"two\"]\n",
                "\n",
                "    def test_read_multi(self):\n",
                "        data = \"\"\"\n",
                "            Header: one\n",
                "            Header: two\n",
                "            \\r\\n\n",
                "        \"\"\"\n",
                "        data = textwrap.dedent(data)\n",
                "        data = data.strip()\n",
                "        s = cStringIO.StringIO(data)\n",
                "        self.hd.read(s)\n",
                "        assert self.hd[\"header\"] == [\"one\", \"two\"]\n",
                "\n",
                "    def test_read_continued(self):\n",
                "        data = \"\"\"\n",
                "            Header: one\n",
                "            \\ttwo\n",
                "            Header2: three\n",
                "            \\r\\n\n",
                "        \"\"\"\n",
                "        data = textwrap.dedent(data)\n",
                "        data = data.strip()\n",
                "        s = cStringIO.StringIO(data)\n",
                "        self.hd.read(s)\n",
                "        assert self.hd[\"header\"] == ['one\\r\\n two']\n",
                "\n",
                "    def test_dictToHeader1(self):\n",
                "        self.hd.add(\"one\", \"uno\")\n",
                "        self.hd.add(\"two\", \"due\")\n",
                "        self.hd.add(\"two\", \"tre\")\n",
                "        expected = [\n",
                "            \"one: uno\\r\\n\",\n",
                "            \"two: due\\r\\n\",\n",
                "            \"two: tre\\r\\n\",\n",
                "            \"\\r\\n\"\n",
                "        ]\n",
                "        out = repr(self.hd)\n",
                "        for i in expected:\n",
                "            assert out.find(i) >= 0\n",
                "        \n",
                "    def test_dictToHeader2(self):\n",
                "        self.hd[\"one\"] = [\"uno\"]\n",
                "        expected1 = \"one: uno\\r\\n\"\n",
                "        expected2 = \"\\r\\n\"\n",
                "        out = repr(self.hd)\n",
                "        assert out.find(expected1) >= 0\n",
                "        assert out.find(expected2) >= 0\n",
                "\n",
                "    def test_match_re(self):\n",
                "        h = utils.Headers()\n",
                "        h.add(\"one\", \"uno\")\n",
                "        h.add(\"two\", \"due\")\n",
                "        h.add(\"two\", \"tre\")\n",
                "        assert h.match_re(\"uno\")\n",
                "        assert h.match_re(\"two: due\")\n",
                "        assert not h.match_re(\"nonono\")\n",
                "\n",
                "    def test_getset_state(self):\n",
                "        self.hd.add(\"foo\", 1)\n",
                "        self.hd.add(\"foo\", 2)\n",
                "        self.hd.add(\"bar\", 3)\n",
                "        state = self.hd.get_state()\n",
                "        nd = utils.Headers.from_state(state)\n",
                "        assert nd == self.hd\n",
                "\n",
                "    def test_copy(self):\n",
                "        self.hd.add(\"foo\", 1)\n",
                "        self.hd.add(\"foo\", 2)\n",
                "        self.hd.add(\"bar\", 3)\n",
                "        assert self.hd == self.hd.copy()\n",
                "\n",
                "    def test_del(self):\n",
                "        self.hd.add(\"foo\", 1)\n",
                "        self.hd.add(\"Foo\", 2)\n",
                "        self.hd.add(\"bar\", 3)\n",
                "        del self.hd[\"foo\"]\n",
                "        assert len(self.hd.lst) == 1\n",
                "\n",
                "\n",
                "class uisStringLike(libpry.AutoTree):\n",
                "    def test_all(self):\n",
                "        assert utils.isStringLike(\"foo\")\n",
                "        assert not utils.isStringLike([1, 2, 3])\n",
                "        assert not utils.isStringLike((1, 2, 3))\n",
                "        assert not utils.isStringLike([\"1\", \"2\", \"3\"])\n",
                "\n",
                "\n",
                "class uisSequenceLike(libpry.AutoTree):\n",
                "    def test_all(self):\n",
                "        assert utils.isSequenceLike([1, 2, 3])\n",
                "        assert utils.isSequenceLike((1, 2, 3))\n",
                "        assert not utils.isSequenceLike(\"foobar\")\n",
                "        assert utils.isSequenceLike([\"foobar\", \"foo\"])\n",
                "        x = iter([1, 2, 3])\n",
                "        assert utils.isSequenceLike(x)\n",
                "        assert not utils.isSequenceLike(1)\n",
                "\n",
                "\n",
                "\n",
                "class upretty_xmlish(libpry.AutoTree):\n",
                "    def test_tagre(self):\n",
                "        def f(s):\n",
                "            return re.search(utils.TAG, s, re.VERBOSE|re.MULTILINE)\n",
                "        assert f(r\"<body>\")\n",
                "        assert f(r\"<body/>\")\n",
                "        assert f(r\"< body/>\")\n",
                "        assert f(r\"< body/ >\")\n",
                "        assert f(r\"< body / >\")\n",
                "        assert f(r\"<foo a=b>\")\n",
                "        assert f(r\"<foo a='b'>\")\n",
                "        assert f(r\"<foo a='b\\\"'>\")\n",
                "        assert f(r'<a b=(a.b) href=\"foo\">')\n",
                "        assert f('<td width=25%>')\n",
                "        assert f('<form name=\"search\" action=\"/search.php\" method=\"get\" accept-charset=\"utf-8\" class=\"search\">')\n",
                "        assert f('<img src=\"gif\" width=\"125\" height=\"16\" alt=&quot;&quot; />')\n",
                "\n",
                "\n",
                "    def test_all(self):\n",
                "        def isbalanced(ret):\n",
                "            # The last tag should have no indent\n",
                "            assert ret[-1].strip() == ret[-1]\n",
                "\n",
                "        s = \"<html><br><br></br><p>one</p></html>\"\n",
                "        ret = utils.pretty_xmlish(s)\n",
                "        isbalanced(ret)\n",
                "\n",
                "        s = r\"\"\"\n",
                "<body bgcolor=#ffffff text=#000000 link=#0000cc vlink=#551a8b alink=#ff0000 onload=\"document.f.q.focus();if(document.images)new Image().src='/images/srpr/nav_logo27.png'\" ><textarea id=csi style=display:none></textarea></body>\n",
                "        \"\"\"\n",
                "        isbalanced(utils.pretty_xmlish(textwrap.dedent(s)))\n",
                "\n",
                "        s = r\"\"\"\n",
                "                <a href=\"http://foo.com\" target=\"\">\n",
                "                   <img src=\"http://foo.gif\" alt=\"bar\" height=\"25\" width=\"132\">\n",
                "                </a>\n",
                "            \"\"\"\n",
                "        isbalanced(utils.pretty_xmlish(textwrap.dedent(s)))\n",
                "\n",
                "        s = r\"\"\"\n",
                "            <!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\"\n",
                "            \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\n",
                "            <html></html>\n",
                "        \"\"\"\n",
                "        ret = utils.pretty_xmlish(textwrap.dedent(s))\n",
                "        isbalanced(ret)\n",
                "\n",
                "        s = \"<html><br/><p>one</p></html>\"\n",
                "        ret = utils.pretty_xmlish(s)\n",
                "        assert len(ret) == 6\n",
                "        isbalanced(ret)\n",
                "\n",
                "        s = \"gobbledygook\"\n",
                "        assert utils.pretty_xmlish(s) == [\"gobbledygook\"]\n",
                "\n",
                "\n",
                "class upretty_json(libpry.AutoTree):\n",
                "    def test_one(self):\n",
                "        s = json.dumps({\"foo\": 1})\n",
                "        assert utils.pretty_json(s)\n",
                "        assert not utils.pretty_json(\"moo\")\n",
                "\n",
                "\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "class u_urldecode(libpry.AutoTree):\n",
                    "    def test_one(self):\n",
                    "        s = \"one=two&three=four\"\n",
                    "        assert len(utils.urldecode(s)) == 2\n",
                    "\n",
                    "\n"
                ],
                "parent_version_range": {
                    "start": 223,
                    "end": 223
                },
                "child_version_range": {
                    "start": 223,
                    "end": 229
                },
                "control_flow": [],
                "structural_path": [],
                "idx": 5,
                "hunk_diff": "File: test/test_utils.py\nCode:\n  ...\n220 220            assert not utils.pretty_json(\"moo\")\n221 221    \n222 222    \n    223  + class u_urldecode(libpry.AutoTree):\n    224  +     def test_one(self):\n    225  +         s = \"one=two&three=four\"\n    226  +         assert len(utils.urldecode(s)) == 2\n    227  + \n    228  + \n223 229    class udummy_ca(libpry.AutoTree):\n224 230        def test_all(self):\n225 231            d = self.tmpdir()\n         ...\n",
                "file_path": "test/test_utils.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "AutoTree",
                    "len",
                    "libpry",
                    "s",
                    "self",
                    "test_one",
                    "u_urldecode",
                    "urldecode",
                    "utils"
                ],
                "prefix": [
                    "        assert not utils.pretty_json(\"moo\")\n",
                    "\n",
                    "\n"
                ],
                "suffix": [
                    "class udummy_ca(libpry.AutoTree):\n",
                    "    def test_all(self):\n",
                    "        d = self.tmpdir()\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 4,
                        "detail": {
                            "identifier": "urldecode",
                            "position": {
                                "start": {
                                    "line": 226,
                                    "column": 25
                                },
                                "end": {
                                    "line": 226,
                                    "column": 34
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/test/test_utils.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [
                    {
                        "to_hunk_idx": 6,
                        "detail": {
                            "identifier": "u_urldecode",
                            "position": {
                                "start": {
                                    "line": 223,
                                    "column": 6
                                },
                                "end": {
                                    "line": 223,
                                    "column": 17
                                }
                            },
                            "type": "identifier",
                            "kind": "class",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/test/test_utils.py",
                            "hunk_idx": 5,
                            "dependency_checked": true
                        }
                    }
                ],
                "other_clones": []
            },
            [
                "class udummy_ca(libpry.AutoTree):\n",
                "    def test_all(self):\n",
                "        d = self.tmpdir()\n",
                "        path = os.path.join(d, \"foo/cert.cnf\")\n",
                "        assert utils.dummy_ca(path)\n",
                "        assert os.path.exists(path)\n",
                "\n",
                "        path = os.path.join(d, \"foo/cert2.pem\")\n",
                "        assert utils.dummy_ca(path)\n",
                "        assert os.path.exists(path)\n",
                "        assert os.path.exists(os.path.join(d, \"foo/cert2-cert.pem\"))\n",
                "        assert os.path.exists(os.path.join(d, \"foo/cert2-cert.p12\"))\n",
                "\n",
                "\n",
                "class udummy_cert(libpry.AutoTree):\n",
                "    def test_with_ca(self):\n",
                "        d = self.tmpdir()\n",
                "        cacert = os.path.join(d, \"foo/cert.cnf\")\n",
                "        assert utils.dummy_ca(cacert)\n",
                "        assert utils.dummy_cert(\n",
                "            os.path.join(d, \"foo\"),\n",
                "            cacert,\n",
                "            \"foo.com\"\n",
                "        )\n",
                "        assert os.path.exists(os.path.join(d, \"foo\", \"foo.com.pem\"))\n",
                "        # Short-circuit\n",
                "        assert utils.dummy_cert(\n",
                "            os.path.join(d, \"foo\"),\n",
                "            cacert,\n",
                "            \"foo.com\"\n",
                "        )\n",
                "\n",
                "    def test_no_ca(self):\n",
                "        d = self.tmpdir()\n",
                "        assert utils.dummy_cert(\n",
                "            d,\n",
                "            None,\n",
                "            \"foo.com\"\n",
                "        )\n",
                "        assert os.path.exists(os.path.join(d, \"foo.com.pem\"))\n",
                "\n",
                "\n",
                "class uLRUCache(libpry.AutoTree):\n",
                "    def test_one(self):\n",
                "        class Foo:\n",
                "            ran = False\n",
                "            @utils.LRUCache(2)\n",
                "            def one(self, x):\n",
                "                self.ran = True\n",
                "                return x\n",
                "\n",
                "        f = Foo()\n",
                "        assert f.one(1) == 1\n",
                "        assert f.ran\n",
                "        f.ran = False\n",
                "        assert f.one(1) == 1\n",
                "        assert not f.ran\n",
                "\n",
                "        f.ran = False\n",
                "        assert f.one(1) == 1\n",
                "        assert not f.ran\n",
                "        assert f.one(2) == 2\n",
                "        assert f.one(3) == 3\n",
                "        assert f.ran\n",
                "\n",
                "        f.ran = False\n",
                "        assert f.one(1) == 1\n",
                "        assert f.ran\n",
                "\n",
                "        assert len(f._cached_one) == 2\n",
                "        assert len(f._cachelist_one) == 2\n",
                "\n",
                "\n",
                "tests = [\n",
                "    uformat_timestamp(),\n",
                "    uisBin(),\n",
                "    uisXML(),\n",
                "    uhexdump(),\n",
                "    upretty_size(),\n",
                "    uisStringLike(),\n",
                "    uisSequenceLike(),\n",
                "    uHeaders(),\n",
                "    uData(),\n",
                "    upretty_xmlish(),\n",
                "    upretty_json(),\n"
            ],
            {
                "type": "insert",
                "before": [],
                "after": [
                    "    u_urldecode(),\n"
                ],
                "parent_version_range": {
                    "start": 308,
                    "end": 308
                },
                "child_version_range": {
                    "start": 314,
                    "end": 315
                },
                "control_flow": [],
                "structural_path": [
                    {
                        "type": "call",
                        "name": "upretty_json",
                        "signature": "upretty_json()",
                        "at_line": 307
                    }
                ],
                "idx": 6,
                "hunk_diff": "File: test/test_utils.py\nCode:\n305 311        uData(),\n306 312        upretty_xmlish(),\n307 313        upretty_json(),\n    314  +     u_urldecode(),\n308 315        udummy_ca(),\n309 316        udummy_cert(),\n310 317        uLRUCache(),\n         ...\n",
                "file_path": "test/test_utils.py",
                "identifiers_before": [],
                "identifiers_after": [
                    "u_urldecode"
                ],
                "prefix": [
                    "    uData(),\n",
                    "    upretty_xmlish(),\n",
                    "    upretty_json(),\n"
                ],
                "suffix": [
                    "    udummy_ca(),\n",
                    "    udummy_cert(),\n",
                    "    uLRUCache(),\n"
                ],
                "base_dependency_callee": [],
                "base_dependency_caller": [],
                "head_dependency_callee": [
                    {
                        "to_hunk_idx": 5,
                        "detail": {
                            "identifier": "u_urldecode",
                            "position": {
                                "start": {
                                    "line": 314,
                                    "column": 4
                                },
                                "end": {
                                    "line": 314,
                                    "column": 15
                                }
                            },
                            "type": "identifier",
                            "kind": "unknown",
                            "abs_file_path": "/data2/chenyan/repos/mitmproxy/test/test_utils.py",
                            "hunk_idx": 6,
                            "dependency_checked": true
                        }
                    }
                ],
                "head_dependency_caller": [],
                "other_clones": []
            },
            [
                "    udummy_ca(),\n",
                "    udummy_cert(),\n",
                "    uLRUCache(),\n",
                "]"
            ]
        ]
    },
    "partial_orders": [
        {
            "edit_hunk_pair": [
                0,
                1
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                1,
                2
            ],
            "edit_order": "bi-directional",
            "reason": "update if condition"
        },
        {
            "edit_hunk_pair": [
                1,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                3,
                4
            ],
            "edit_order": "bi-directional",
            "reason": "import and use"
        },
        {
            "edit_hunk_pair": [
                4,
                5
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        },
        {
            "edit_hunk_pair": [
                5,
                6
            ],
            "edit_order": "bi-directional",
            "reason": "def and use"
        }
    ]
}