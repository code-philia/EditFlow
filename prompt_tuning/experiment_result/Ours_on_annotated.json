{
    "0": [
        {
            "sample_idx": 1,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are part of adding ACL support to GCS feed storage functionality. Edit 0 adds a 'predefined_acl=self.acl' parameter to the blob.upload_from_file() call in the production code, while Edit 1 adds an 'acl = publicRead' variable in the test setup. However, the changed lines reference different symbols - Edit 0 references 'self.acl' (an instance attribute) while Edit 1 defines a local variable 'acl'. There is no direct code dependency or explicit symbol linkage between the changed lines themselves. While both edits are conceptually related to the same feature (ACL support), they don't reference the exact same symbol, and making one edit doesn't create an immediate, mechanically obvious prompt for the other at the code level."
        },
        {
            "sample_idx": 0,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and files with no direct code linkage. Edit 0 removes a line that uses `time.time()` in the `__goInference` function in `lib/request/inject.py`, while Edit 1 adds `import time` to `lib/utils/resume.py`. Although both edits relate to the `time` module, they reference different symbols in different files - Edit 0 references `time.time()` (which was already imported somewhere in inject.py) and Edit 1 imports the `time` module in a completely different file. There is no explicit code dependency between these changed lines, and they appear to be separate, unrelated modifications happening in different parts of the codebase. The removal of time usage in one file and addition of time import in another file does not create any immediate, mechanically obvious prompt for one edit to follow the other."
        },
        {
            "sample_idx": 2,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a new update method that calls pause_external_data_schedule(str(instance.id)), while Edit 1 changes the pause_external_data_schedule function to accept an 'id' parameter instead of 'external_data_source.id'. However, these edits reference different symbols and have incompatible changes. Edit 0 calls the function with str(instance.id) as a string argument, but Edit 1 changes the function to expect a parameter named 'id' instead of extracting the id from external_data_source. The function signature change in Edit 1 would actually break the call in Edit 0, as Edit 0 passes a string but Edit 1 expects the function to receive an 'id' parameter directly. These are not synchronized changes to the same symbol, but rather conflicting modifications that would need to be resolved together in a different way."
        },
        {
            "sample_idx": 3,
            "yi": "bi-directional",
            "pred": "0 before 1",
            "pred_reason": "Edit 0 removes the definition of the method `_test_error_exc_info` from the `RemoteTestResultTest` class, while Edit 1 changes a call from `self._test_error_exc_info()` to `_test_error_exc_info()` - referencing the exact same symbol. This creates a direct code dependency where both edits reference the same symbol `_test_error_exc_info`. However, this appears to be a refactoring where the method is being moved from an instance method to a module-level function. For the code to remain functional, the method must first be removed from the class (Edit 0) before the call site can be updated to reference it as a module-level function (Edit 1). If Edit 1 were applied first, the call to `_test_error_exc_info()` would fail because that function wouldn't exist yet at module level, while `self._test_error_exc_info()` would still be available. The logical sequence is to first remove the instance method, then update the call site to reference the new location."
        },
        {
            "sample_idx": 4,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits show a bi-directional relationship where both changed lines reference the exact same symbol: the dictionary key \"is_legacy_optimizer\". Edit 0 adds this key to a config dictionary in the get_config method, while Edit 1 removes this same key from a config dictionary in the from_config method. This creates an immediate, mechanically obvious code-driven relationship - adding the key in one location naturally prompts handling its removal in the deserialization logic, and vice versa. Both edits reference the identical string literal \"is_legacy_optimizer\" and form part of a synchronized configuration serialization/deserialization pair. Either edit can be made first and would naturally prompt the other as the next contiguous action to maintain proper config handling."
        },
        {
            "sample_idx": 6,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol 'self.skip_models' within the same class. Edit 0 defines/initializes the 'skip_models' attribute in the __init__ method, while Edit 1 uses that same attribute in the __repr__ method. The changed lines in both edits explicitly reference the same symbol. After making either edit, the other becomes a natural next step - if you add the skip_models attribute, you'd want to include it in the string representation, and vice versa. Both edits can be staged in either order without causing parse errors (the __repr__ method referencing an undefined attribute is valid Python syntax that would only fail at runtime)."
        },
        {
            "sample_idx": 5,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are both within the same function `get_configuration(args)` and involve removing code related to configuration settings. However, they reference different symbols and serve different purposes. Edit 0 removes the line setting `'preview': not write_file` from what appears to be a configuration dictionary, while Edit 1 removes the entire logic for setting `config['skip_animations']` based on `args.skip_animations` and `args.start_at_animation_number`. The changed lines in each edit reference completely different configuration keys ('preview' vs 'skip_animations') and different variables/logic. There is no direct code dependency between these removals - neither edit creates an immediate, mechanically obvious prompt for the other. They appear to be separate cleanup operations that happen to be in the same function but don't reference the same symbols."
        },
        {
            "sample_idx": 7,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add the same key-value pair 'is_legacy_optimizer': True to config dictionaries in get_config methods of different optimizer classes. While this appears to be a synchronized addition of the same configuration field, the changed lines reference different symbols - they modify different config dictionaries in different classes (Optimizer vs OptimizerV2) in different files. The config variable in each edit is a different symbol despite having the same name, as they exist in different scopes/contexts. There is no direct code dependency between these specific changed lines - neither edit creates an immediate, mechanically obvious prompt for the other. This is a thematic/conceptual relationship (adding the same configuration to related classes) rather than an explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 8,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 removes the import of `aget_schema_by_id` from line 34, while Edit 1 removes the usage of that same function `aget_schema_by_id` from lines 122-126. These edits reference the exact same symbol - the `aget_schema_by_id` function. Both edits are part of removing this function entirely from the codebase. Either edit can be made first without causing parse errors - removing the import first leaves unused code that can still be parsed, and removing the usage first leaves an unused import that can still be parsed. The relationship is bi-directional because after making either edit, the other becomes the immediate next step to complete the removal of this function from the file."
        },
        {
            "sample_idx": 10,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new parameter 'run_tests' to the startup function signature, and Edit 1 updates the call site to include this new parameter. Both edits reference the exact same symbol (the startup function) - Edit 0 modifies its definition while Edit 1 modifies its usage. After making either edit, the other becomes the immediate next step to maintain code consistency. The function signature change creates a direct code dependency with its call site. In Python, both edits can be staged in either order without causing parse errors (the call with extra arguments or the definition with unused parameters are both syntactically valid), making this a bi-directional relationship."
        },
        {
            "sample_idx": 9,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite both referencing 'acl'. Edit 0 adds 'self.acl = acl' in the GCSFeedStorage.__init__ method, where 'acl' refers to a parameter that should be added to the constructor signature (but isn't shown in this edit). Edit 1 modifies a test assertion to include 'predefined_acl=acl' where 'acl' appears to be a test variable or mock parameter. The changed lines reference different 'acl' symbols - one is an instance attribute assignment in the production code, the other is a parameter in a test assertion. These are different symbols in different scopes (production class vs test method), and there's no direct code dependency between the specific changed lines."
        },
        {
            "sample_idx": 12,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a line incrementing `row_index` in the backtesting logic within the `Backtesting` class. Edit 1 adds an import statement for `timedelta` from the datetime module in a test file. There is no shared symbol, no direct code dependency, and no structural relationship between incrementing a row index and importing a datetime utility. The changed lines reference entirely different elements - one references a local variable `row_index` and the other imports a datetime class. These appear to be separate, independent changes with no mechanical linkage."
        },
        {
            "sample_idx": 11,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits are modifying calls to the same function `get_free_trial_days()` by adding a parameter. In edit 0, the function call is changed from `get_free_trial_days()` to `get_free_trial_days(is_self_hosted_billing)`, and in edit 1, it's changed from `get_free_trial_days()` to `get_free_trial_days(False)`. This appears to be part of a bulk refactoring where the function signature was changed to require a parameter, and all call sites are being updated to provide that parameter. Both edits reference the exact same symbol (the `get_free_trial_days` function) and represent the same type of structural change (adding a parameter to function calls). This is a uniform substitution pattern where either edit could be made first, and both are part of the same contiguous refactoring task to update all call sites after a function signature change."
        },
        {
            "sample_idx": 13,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and contexts. Edit 0 modifies a docstring example in the serialize function to show 'is_legacy_optimizer': True in the output format. Edit 1 modifies test code that handles configuration cleanup by removing 'is_legacy_optimizer' from configs when it's not present in the original. While both edits involve the same string 'is_legacy_optimizer', they are referencing this field in completely different contexts - one as documentation of expected output format, the other as test logic for configuration handling. The changed lines do not reference the exact same symbol or create a direct code dependency between them. This is a thematic relationship around the same configuration field name, but not a direct code linkage."
        },
        {
            "sample_idx": 14,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 reformats the '--enable-irq' argument parser configuration, while Edit 1 adds a new 'separator_line' method that references 'self.args.enable_separator' (a different configuration option). Although both edits involve argument/configuration handling conceptually, the changed lines reference different symbols ('enable_irq' vs 'enable_separator') and there is no explicit code dependency between them. The connection is purely thematic/conceptual rather than based on direct symbol references or structural dependencies."
        },
        {
            "sample_idx": 15,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are part of a conditional structure where edit 0 removes an 'elif is_cfg_pp:' branch and edit 1 modifies the 'else:' branch that follows it. The edits appear to be refactoring how condition scaling is handled - removing a specific CFG++ scaling approach and replacing it with a more general multiplier approach. However, the changed lines in each edit reference different code paths and different symbols. Edit 0 removes a call to combine_denoised with a hardcoded scale calculation (cond_scale/12.5), while edit 1 modifies a different call to combine_denoised with a new multiplier approach (cond_scale * self.cond_scale_miltiplier). While both edits call the same method (combine_denoised), they are in different conditional branches and the actual symbols being referenced in the changed lines are different - one uses a division operation with a literal, the other uses multiplication with an instance variable. The relationship is conceptual/thematic (both related to scaling refactor) but lacks direct code linkage between the exact same symbols in the changed lines."
        },
        {
            "sample_idx": 16,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports `__version__` from the current module (`. import __version__`), and Edit 1 uses that exact same imported symbol `__version__` in a user_agent dictionary assignment. The changed lines reference the exact same symbol - the `__version__` that is imported in Edit 0 and used in Edit 1. This creates a direct import-usage relationship where making either edit creates an immediate, mechanically obvious prompt for the other. Both edits can be staged in either order in Python (usage before import would only cause a runtime NameError, not a parse error), making this a bi-directional relationship."
        },
        {
            "sample_idx": 17,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits add the same import statement 'from . import __version__' to different files (modeling_flax_utils.py and modeling_utils.py). While they involve the exact same symbol (__version__) and follow an identical pattern (adding the same import), these are separate files with no direct code dependency between the changed lines. The edits appear to be part of a bulk refactoring to add version imports across multiple modules, but there's no immediate, mechanically obvious prompt where making one edit creates a direct code-driven need for the other. Each file can function independently with its own __version__ import. This represents a thematic/conceptual relationship (bulk import addition) rather than a direct code dependency between the specific changed lines."
        },
        {
            "sample_idx": 18,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern within the same SQL string literal. Edit 0 changes 'CREATE TABLE' to 'CREATE TABLE IF NOT EXISTS' for TABLE1, and Edit 1 makes the exact same substitution for TABLE2. Both are part of the same multi-line SQL string in the same TrinoOperator call, and both apply the identical before\u2192after pattern ('CREATE TABLE' \u2192 'CREATE TABLE IF NOT EXISTS') to the same type of syntactic construct (CREATE TABLE statements). This represents a bulk uniform substitution that would naturally occur as part of a single, contiguous refactoring task to add idempotency to all table creation statements in this SQL block. Either edit could be made first, and after making one, the other becomes the immediate next step to complete the uniform pattern application."
        },
        {
            "sample_idx": 19,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats argument parsing code for the '--enable-plugin' command line option by splitting it across multiple lines for better readability. Edit 1 modifies display logic for cloud statistics by adding a conditional check before displaying the cloud plugin. The changed lines reference entirely different symbols and code constructs - one deals with argument parser configuration while the other handles UI display logic. There is no shared symbol, no code dependency, and no structural relationship between reformatting command line arguments and conditionally displaying cloud statistics."
        },
        {
            "sample_idx": 21,
            "yi": "0 before 1",
            "pred": "0 before 1",
            "pred_reason": "These edits involve moving the same line of code (`row_index += 1`) from one location to another within the same function. Edit 0 removes the line from its original position (line 478), while Edit 1 adds the same line at a new position (line 481). This is a classic cut-and-paste move operation where the removal must occur before the relocation to avoid code duplication. The edits reference the exact same symbol (`row_index`) and the same operation (`+= 1`), but Edit 0 must be applied first to remove the line before Edit 1 can add it at the new location."
        },
        {
            "sample_idx": 20,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they both reference the exact same symbol 'x_shape' and are part of a coordinated modification to the sm3 optimizer function. Edit 0 introduces x_shape by storing the original shape and flattening x0, while Edit 1 unpacks x_shape from the state and uses it to reshape x back to its original form. The changes create an immediate, mechanically obvious code dependency - after making either edit, the other becomes necessary to maintain the function's correctness. Both edits reference the same x_shape symbol and form a synchronized pair that handles shape preservation across the optimizer's state management."
        },
        {
            "sample_idx": 22,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different files and different code constructs with no shared symbols or dependencies. Edit 0 reformats argument parsing code in glances/main.py by splitting a single parser.add_argument() call across multiple lines for better readability. Edit 1 adds new Unicode character mappings ('MEDIUM_LINE' and 'LOW_LINE') to a dictionary in glances/outputs/glances_unicode.py. There is no explicit code linkage between the changed lines - they don't reference, assign, call, or import the same symbols. The edits are unrelated formatting/refactoring changes that happen to be part of the same codebase but have no direct code dependency or synchronized pattern."
        },
        {
            "sample_idx": 23,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 changes a string literal 'us-east-1' to use a constant AWS_REGION_US_EAST_1 in the config.py file. Edit 1 adds an import statement for get_handler_file_from_name function in a completely different file (template_deployer.py). The changed lines do not reference, assign, call, or import the same symbol. There is no explicit code dependency, structural relationship, or synchronized substitution pattern between these edits. They appear to be independent changes that happen to be part of the same broader development work but lack the immediate, mechanically obvious code-driven linkage required for neighbour classification."
        },
        {
            "sample_idx": 24,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 imports JinaLogger from jina.logging.logger, while Edit 1 uses self.logger in an error handling block. However, these edits reference different symbols. Edit 0 imports the JinaLogger class, but Edit 1 uses self.logger, which is likely an instance attribute of the GatewayRequestHandler class that was already initialized elsewhere. The changed lines do not reference the exact same symbol - one references the JinaLogger class being imported, while the other references a logger instance attribute. There is no direct code dependency between the import of JinaLogger and the usage of self.logger in the exception handler."
        },
        {
            "sample_idx": 25,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code dependency. Edit 0 adds an import statement for 'unicode_message' from a Unicode module, while Edit 1 modifies the signature of the 'new_line' method by adding a 'separator' parameter. The changed lines do not reference the same symbol - one involves importing 'unicode_message' and the other involves modifying the 'new_line' method signature. There is no explicit code linkage between these changes, and neither edit creates an immediate, mechanically obvious prompt for the other. They appear to be independent modifications that happen to be in the same file but serve different purposes."
        },
        {
            "sample_idx": 26,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve completely different symbols and functionalities. Edit 0 adds a command-line argument '--add-stop-route' to an argument parser in cmd_args.py, while Edit 1 adds 'Response' to an import statement from fastapi in webui.py. There is no direct code dependency between these changes - the changed lines reference entirely different symbols (a parser argument vs. an import). While both edits might be part of implementing the same feature (adding a stop route), there is no explicit, immediate, code-driven linkage between the specific lines that were changed. The argument parser change does not create a mechanical prompt for the import change, nor vice versa."
        },
        {
            "sample_idx": 27,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural substitution on the same type of syntactic construct - they both change function parameter signatures from 'external_data_source: ExternalDataSource' to 'id: str'. This represents a uniform refactoring pattern applied to two related functions (pause/unpause) within the same file. The edits involve the exact same before\u2192after pattern on the same construct type (function parameters), making this a clear case of bulk-edit synchronization. Either edit could be made first, and after making one, the other becomes the natural next step to maintain consistency in the API."
        },
        {
            "sample_idx": 29,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different files and different symbols. Edit 0 imports 'ExcInfo' from 'celery.worker', while Edit 1 adds imports of 'sys' and 'traceback' to the worker.py file. Although Edit 0 imports from the same file that Edit 1 modifies, the changed lines reference completely different symbols - 'ExcInfo' vs 'sys' and 'traceback'. There is no direct code dependency or synchronized substitution pattern between these specific imports. The edits are conceptually related (both involve imports that might be used for error handling) but lack the explicit, immediate code linkage required for neighbour classification."
        },
        {
            "sample_idx": 28,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbors in mental flow. Edit 0 changes a call to get_free_trial_days() to include a new parameter is_self_hosted_billing, while Edit 1 adds a new configuration setting SELF_HOSTING_FREE_TRIAL_DAYS. Although both edits are conceptually related to implementing self-hosted billing functionality, they do not reference the exact same symbol. The changed lines in Edit 0 reference the get_free_trial_days function, while the changed lines in Edit 1 define a new configuration constant. There is no direct, explicit code dependency between these specific changed lines - they are part of the same feature implementation but lack the immediate, mechanically obvious code-driven linkage required for neighbor classification."
        },
        {
            "sample_idx": 30,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new constant `AWS_REGION_US_EAST_1` in the constants.py file, while Edit 1 uses that exact same constant in a conditional check within the get_bucket_location_config function. The changed lines in Edit 1 explicitly reference the same symbol that was defined in Edit 0's changed lines. This creates a direct definition-usage relationship where both edits reference the exact same symbol. Since this is Python, the usage can be written and parsed before the definition is present (it would only cause a NameError at runtime), making this a bi-directional relationship rather than ordered. After making either edit, the other becomes the immediate next step due to the explicit code dependency."
        },
        {
            "sample_idx": 31,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits both add new parameters to function/constructor signatures, but they are adding different parameters to completely unrelated functions in different files. Edit 0 adds 'test_round_allowed=5' to the QaEngineer class constructor in metagpt/roles/qa_engineer.py, while Edit 1 adds 'run_tests: bool = False' to the main function in startup.py. The changed lines reference different symbols (QaEngineer.__init__ vs main function) and there is no direct code dependency, explicit symbol reference, or synchronized substitution pattern between them. The only connection is conceptual (both relate to testing functionality), which does not meet the criteria for being neighbours."
        },
        {
            "sample_idx": 32,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to handling legacy optimizer configuration, but they reference different symbols and occur in different contexts. Edit 0 adds a 'use_legacy_optimizer=True' parameter to an optimizers.deserialize() call in LossScaleOptimizer, while Edit 1 removes an 'is_legacy_optimizer' key from a config dictionary in Adagrad's from_config method. The changed lines don't reference the exact same symbol - one is adding a parameter to a function call, the other is deleting a dictionary key. While they're conceptually related to the same feature (legacy optimizer handling), there's no direct code dependency or explicit symbol linkage between the specific lines being changed."
        },
        {
            "sample_idx": 33,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits show a clear definition-usage relationship for the exact same symbol 'add_stop_route'. Edit 0 defines a new command-line argument '--add-stop-route' which creates the attribute 'cmd_opts.add_stop_route', and Edit 1 uses this exact same attribute in a conditional check 'if cmd_opts.add_stop_route:'. After making either edit, the other becomes the immediate next step - if you add the argument definition, you need to use it in the code, and if you add the usage, you need the argument definition. Both edits reference the same symbol and can be staged in either order without parser errors (the usage would just reference an undefined attribute at runtime if the definition isn't present, but this doesn't prevent parsing or staging)."
        },
        {
            "sample_idx": 34,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new method `filter_relations` in the `BaseDeletionTask` class, and Edit 1 calls that exact same method (`self.filter_relations(child_relations)`) within the `delete_bulk` method of the same class. The changed lines reference the exact same symbol - the `filter_relations` method. After defining the method in Edit 0, the natural next step would be to use it, which is exactly what Edit 1 does. Conversely, Edit 1's call to `filter_relations` creates an immediate code-driven prompt to define that method if it doesn't exist. Both edits can be written and parsed in either order in Python (the call before definition would only cause a runtime AttributeError, not a parse-time syntax error), making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "sample_idx": 36,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of optimizer serialization/deserialization but do not reference the exact same symbol. Edit 0 adds a 'use_legacy_optimizer=True' parameter to a deserialize() call, while Edit 1 adds an 'is_legacy_optimizer': True field to a config dictionary in a get_config() method. While both are conceptually related to legacy optimizer handling, the changed lines reference different symbols - one is a parameter to deserialize() and the other is a field in a config dict. There is no direct code dependency where making one edit creates an immediate, mechanically obvious prompt for the other at the symbol level."
        },
        {
            "sample_idx": 35,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a 'weights' parameter to the Embedding class constructor's __init__ method signature. Edit 1 adds code in the constructor body that references and uses this exact same 'weights' parameter - checking if it's not None, validating its format, and calling set_weights() with it. The changed lines in edit 1 explicitly reference the same 'weights' parameter symbol that was added in edit 0's signature. This creates a direct definition-usage relationship where the parameter must be defined in the signature before it can be referenced in the method body. However, in Python, referencing a parameter in the method body before adding it to the signature would cause a NameError at runtime but not a parse-time syntax error - both edits can be written and parsed in either order. Therefore, this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 37,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are within the same method `_add_browser_connection` but they modify completely different aspects of the code. Edit 0 changes only the docstring text from 'Registers' to 'Register', while Edit 1 modifies the actual implementation logic by replacing a simple ReportContext assignment with more complex conditional logic that handles preheated contexts. The edits don't reference the same symbols - the docstring change doesn't create any code dependency that would prompt the implementation change, and vice versa. There is no explicit code linkage between changing a docstring and refactoring the ReportContext assignment logic. While both edits are in the same method and could be part of the same feature development, they represent independent changes that can be made in any order without creating syntactic dependencies."
        },
        {
            "sample_idx": 38,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts. Edit 0 adds an import statement for the 'os' module in devserver.py, while Edit 1 removes a line that uses 'os.path.realpath' and 'os.path.join' in http.py. Although both edits involve the 'os' module, they reference different usages of 'os' in completely separate files and functions. The changed lines do not reference the exact same symbol - Edit 0 imports 'os' in one context, while Edit 1 removes usage of 'os.path' methods in an entirely different context. There is no direct code dependency or linkage between these specific changes, and they appear to be part of separate, unrelated modifications."
        },
        {
            "sample_idx": 40,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve completely different symbols and contexts. Edit 0 changes a line in the QaEngineer class constructor to use a parameter 'test_round_allowed' instead of a hardcoded value 5. Edit 1 modifies a function call in startup.py to add a 'run_tests' parameter. The changed lines reference entirely different symbols: 'test_round_allowed' in edit 0 and 'run_tests' in edit 1. There is no direct code dependency, shared symbol reference, or structural relationship between these changes. They appear to be part of different modifications to unrelated parts of the codebase."
        },
        {
            "sample_idx": 39,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of optimizer configuration handling. Edit 0 adds a 'use_legacy_optimizer=False' parameter to an 'optimizers.deserialize()' call in LossScaleOptimizerV3, while Edit 1 removes an 'is_legacy_optimizer' key from config in a different class (Optimizer) and different method context. Although both relate to legacy optimizer handling conceptually, the changed lines reference different symbols: 'optimizers.deserialize()' vs config dictionary manipulation, and 'use_legacy_optimizer' vs 'is_legacy_optimizer'. There is no direct code dependency where one edit's changed lines reference the exact same symbol as the other edit's changed lines. The connection is only thematic/conceptual around legacy optimizer handling, not a direct code linkage."
        },
        {
            "sample_idx": 42,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports `TrinoQueryError` from `trino.exceptions`, and Edit 1 uses this exact same symbol in a try-except block (`except TrinoQueryError as e:`). The import creates the symbol that is then referenced in the exception handling code. After making the import edit, the usage becomes the immediate next step to handle the exception. After adding the usage, the import becomes necessary for the code to function. Both edits reference the exact same symbol `TrinoQueryError` and either edit naturally prompts the other as the next mechanical step within the same development task of adding error handling to the `on_kill` method."
        },
        {
            "sample_idx": 41,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the symbol 'unicode_message' from glances.outputs.glances_unicode, and Edit 1 uses that exact same symbol 'unicode_message' in a function call on line 544. This creates a direct import-usage relationship where both edits reference the exact same symbol. After making the import in Edit 0, using the symbol in Edit 1 becomes the natural next step. Conversely, if Edit 1 were made first, it would create an undefined symbol that would prompt adding the import in Edit 0. Since Python allows referencing undefined symbols at parse time (they only fail at runtime), both edits can be staged in either order, making this a bi-directional relationship."
        },
        {
            "sample_idx": 43,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new method `separator_line` within the `_GlancesCurses` class, and Edit 1 calls that exact same method `self.separator_line()` within the same class. The changed lines reference the exact same symbol - the `separator_line` method. After defining the method in Edit 0, calling it in Edit 1 becomes a natural next step, and vice versa - if you're calling a method, you need it to be defined. Both edits can be staged in either order since Python allows method calls to be written before the method definition (it would only fail at runtime when the method is actually invoked). This creates a bi-directional relationship where either edit naturally prompts the other as the immediate next mechanical step within the same development micro-task."
        },
        {
            "sample_idx": 44,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits reference the exact same symbol SEND_CELERY_TASK_ERROR_EMAILS. Edit 0 defines this configuration setting in celery/conf.py, while edit 1 uses this same setting in celery/datastructures.py to conditionally send error emails. The changed lines in both edits explicitly reference the same symbol - one defining it and the other using it. This creates a direct code dependency where defining the setting enables its usage elsewhere in the codebase. Since Python allows referencing undefined variables at parse time (they only fail at runtime), either edit can be staged first, making this a bi-directional relationship where making either edit creates an immediate prompt for the other as part of implementing the error email functionality."
        },
        {
            "sample_idx": 45,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different symbols in different files. Edit 0 removes an import of 'aget_schema_by_id' from external_data_job.py, while Edit 1 adds an import of 'schedule_exists' to service.py. The changed lines reference entirely different symbols ('aget_schema_by_id' vs 'schedule_exists') with no code dependency or relationship between them. There is no explicit code linkage, no shared symbol reference, and no structural dependency that would make one edit prompt the other as the next mechanical step."
        },
        {
            "sample_idx": 46,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform identical structural reformatting - taking single-line function calls with multiple arguments and splitting them into multi-line format with each argument on its own line. However, they operate on completely different symbols in different files: edit 0 reformats a parser.add_argument() call in main.py, while edit 1 reformats a self.display_plugin() call in glances_curses.py. While the formatting pattern is identical, there is no direct code dependency or symbol linkage between these specific changed lines. They are part of a bulk formatting operation but affect different symbols in different contexts."
        },
        {
            "sample_idx": 48,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite having similar names. Edit 0 changes a variable reference from 'endpoint' to 'email_type' within the one_click_unsubscribe_link function, while Edit 1 changes parameter names from 'type' and 'token' to 'email_type' and 'confirmation_key' in the email_unsubscribe function. Although both edits involve a parameter named 'email_type', they are in completely different functions and different files. The 'email_type' in edit 0 is a parameter of one_click_unsubscribe_link function, while the 'email_type' in edit 1 is a parameter of email_unsubscribe function. These are different symbols in different scopes, so there is no direct code linkage between the changed lines themselves."
        },
        {
            "sample_idx": 47,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same string literal 'is_legacy_optimizer' but in completely different contexts and files. Edit 0 adds this key-value pair to a test configuration dictionary in one test file, while Edit 1 adds conditional logic to remove this key from a config dictionary in a different test file. The changed lines reference the same string literal but within different scopes, different test methods, different classes, and different files. There is no direct code dependency between these specific changed lines - they are separate test scenarios that happen to involve the same configuration parameter name. This appears to be part of a broader feature implementation where multiple test files need to handle the 'is_legacy_optimizer' parameter, but the specific changed lines do not create an immediate, mechanically obvious prompt for each other. According to the criteria, same name in different scopes represents different symbols, and conceptual/thematic connections without direct code linkage should be labeled as 'no relation'."
        },
        {
            "sample_idx": 50,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are part of the same function `get_configuration(args)` and both modify a dictionary being constructed, but they reference completely different symbols. Edit 0 adds a new key-value pair `\"skip_animations\": args.skip_animations` while Edit 1 removes a different key-value pair `\"preview\": not write_file`. The changed lines do not reference the exact same symbol - one references `args.skip_animations` and the other references `write_file`. There is no direct code dependency between these specific changes, and neither edit creates an immediate, mechanically obvious prompt for the other. They appear to be separate modifications to the configuration dictionary that happen to be in the same function but are conceptually independent."
        },
        {
            "sample_idx": 52,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of optimizer configuration. Edit 0 adds a 'use_legacy_optimizer=True' parameter to an 'optimizers.deserialize()' call in the LossScaleOptimizer class. Edit 1 adds handling for an 'is_legacy_optimizer' key in the config dictionary within the Optimizer class's from_config method. While both edits relate to legacy optimizer handling conceptually, they reference different symbols: edit 0 modifies a call to 'optimizers.deserialize()' while edit 1 modifies the 'from_config' method of a different class. The changed lines do not reference the exact same symbol - one is adding a parameter to a function call, the other is adding config key handling in a different method. There is no direct code dependency or explicit symbol linkage between these specific changed lines."
        },
        {
            "sample_idx": 49,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 defines a new class 'ExcInfo' in the celery/worker.py file, while Edit 0 imports that exact same 'ExcInfo' class from celery.worker in the celery/datastructures.py file. The changed lines reference the exact same symbol - the ExcInfo class. This creates a definition-usage relationship where the class must be defined before it can be imported. However, in Python, import statements can be written before the target symbol exists (they only fail at runtime/import time, not at parse time). Both edits can be staged in either order without causing parser errors. After making either edit, the other becomes the immediate next step to complete the functionality - either defining the class that's being imported, or importing the class that's been defined."
        },
        {
            "sample_idx": 51,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and code locations. Edit 0 adds a 'logger' parameter to the __init__ method signature of GatewayRequestHandler class. Edit 1 modifies an error message string within a nested function (gather_endpoints) inside the handle_request method, changing the wording from 'Communication error with deployment' to 'Communication error while gathering endpoints with deployment'. There is no direct code dependency, symbol linkage, or structural relationship between adding a logger parameter to the constructor and modifying an error message string in a different method. The changed lines reference entirely different symbols and serve different purposes - one is a parameter addition, the other is a string literal modification. This is purely a conceptual relationship at best, as both happen to be in the same class, but there's no explicit code-driven linkage between the exact symbols being changed."
        },
        {
            "sample_idx": 53,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats the arguments of a parser.add_argument() call for the '--enable-irq' option by splitting it across multiple lines. Edit 1 removes a blank line in a different file (glances_unicode.py). The changed lines reference completely different symbols and code constructs - one involves argument parsing configuration while the other is a whitespace formatting change. There is no explicit code linkage, no shared symbols, and no mechanical dependency between these edits. They appear to be independent formatting/cleanup changes that happen to be part of the same commit but have no direct code relationship."
        },
        {
            "sample_idx": 55,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different files and different functionality. Edit 0 reformats argument parsing code in main.py by splitting a single line into multiple lines for better readability. Edit 1 adds method calls (init_column() and separator_line()) to a display function in the curses output module. There is no shared symbol, function, class, or variable being referenced between the changed lines. The edits are part of different subsystems - one deals with command-line argument parsing while the other deals with terminal display formatting. There is no explicit code dependency, import relationship, or structural synchronization between these changes."
        },
        {
            "sample_idx": 54,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 adds a new function `schedule_exists` to the schedule.py module, while Edit 1 imports several functions (`external_data_workflow_exists`, `sync_external_data_job_workflow`, `pause_external_data_schedule`, `unpause_external_data_schedule`) from a different service module. The changed lines in each edit reference entirely different symbols - there is no overlap between the `schedule_exists` function being defined in Edit 0 and any of the functions being imported in Edit 1. While both edits may be conceptually related to scheduling functionality, there is no explicit code dependency or synchronized substitution between the exact symbols referenced in the changed lines."
        },
        {
            "sample_idx": 57,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural transformation on the same type of syntactic construct (user_agent dictionary initialization). They both add the same new key-value pair ('diffusers': __version__) in the same position within similar user_agent dictionaries in related classes (FlaxModelMixin and ModelMixin). This represents a bulk-edit pattern where the same before\u2192after substitution is being applied uniformly across multiple locations of the same construct type. The edits are part of a single, contiguous refactor to add version information to user agent dictionaries across both Flax and PyTorch model implementations. Either edit can be made first, and after making either one, the other becomes the natural next step to complete the synchronized pattern."
        },
        {
            "sample_idx": 58,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern: changing 'str(external_data_source.id)' to 'id' in the schedule_id parameter. They target the same type of syntactic construct (function call parameter assignments) within similar function contexts (pause vs unpause external data schedule). This represents a bulk edit or pattern synchronization where the same refactoring change is being applied uniformly across multiple locations. The edits are clearly part of a single, contiguous refactor operation applying the same before\u2192after pattern to the same construct type."
        },
        {
            "sample_idx": 56,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform identical structural transformations on the same type of function calls within the same file and function context. Edit 0 changes `pause_external_data_schedule(job.pipeline)` to `pause_external_data_schedule(str(job.pipeline.id))`, while Edit 1 changes `unpause_external_data_schedule(source)` to `unpause_external_data_schedule(str(source.id))`. This represents a uniform substitution pattern where both calls are being modified to pass `str(object.id)` instead of the raw object. Both edits target the same syntactic construct type (function calls to related schedule management functions) and apply the identical before\u2192after transformation pattern. This appears to be part of a single, contiguous refactor to standardize how these schedule management functions receive their parameters. Either edit could be made first, and both represent the same mechanical change being applied consistently across related function calls."
        },
        {
            "sample_idx": 59,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Edit 1 defines a new class 'ExcInfo' in celery/worker.py, while Edit 0 changes code in celery/datastructures.py to use 'ExcInfo' in an isinstance() check. However, these edits reference different symbols despite having the same name. Edit 0's changed line references 'ExcInfo' without any import statement visible, suggesting it expects ExcInfo to be available in the celery/datastructures.py namespace. Edit 1 defines ExcInfo in celery/worker.py. For Edit 0 to actually use the ExcInfo class defined in Edit 1, there would need to be an import statement in celery/datastructures.py, which is not present in either edit. Therefore, these are different symbols with the same name in different scopes/namespaces, and there is no direct code linkage between the exact same symbol in the changed lines."
        },
        {
            "sample_idx": 60,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits show a classic definition-usage pattern for the exact same symbol. Edit 0 adds a parameter `read_with_timeout` to the `__init__` method and assigns it to `self.read_with_timeout`. Edit 1 then uses that exact same attribute `self.read_with_timeout` in the `__enter__` method, replacing the hardcoded `True` value. Both changed lines reference the exact same symbol (`self.read_with_timeout`), and making either edit creates an immediate, mechanically obvious prompt for the other. After adding the parameter and assignment in `__init__`, the natural next step is to use that parameter instead of the hardcoded value. Conversely, if you first change the hardcoded value to use `self.read_with_timeout`, you'd immediately need to define that attribute in `__init__`. Since both edits can be written and parsed in either order (Python allows referencing undefined attributes at parse time), this is bi-directional rather than ordered."
        },
        {
            "sample_idx": 61,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits affect completely different aspects of the codebase with no direct code linkage. Edit 0 adds a 'preview' configuration parameter in the config.py file, while Edit 1 modifies the stop_skipping method implementation in the Scene class by changing how skip_animations and timing are handled. The changed lines reference entirely different symbols - Edit 0 references 'write_file' and adds a 'preview' key, while Edit 1 references 'self.virtual_animation_start_time', 'self.skip_animations', 'self.time', and 'self.skip_time'. There is no explicit code dependency, shared symbol reference, or structural pattern between these changes. They appear to be independent modifications that may be conceptually related to the same feature but lack the direct, mechanical code linkage required for neighbour classification."
        },
        {
            "sample_idx": 62,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the 'connection' module from django.db, and Edit 1 uses that exact same 'connection' symbol by calling connection.connect(). This creates a direct import-usage relationship where the changed lines reference the exact same symbol. After importing 'connection' in Edit 0, using it in Edit 1 becomes a natural next step. In Python, usage before import would cause a runtime NameError but both edits can be written and parsed in either order, making this bi-directional rather than ordered."
        },
        {
            "sample_idx": 64,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are unrelated. Edit 0 adds a comment about localhost in constants.py, while Edit 1 adds imports for AWS_REGION_US_EAST_1 and s3_listener in a different file. The changed lines reference completely different symbols and there is no direct code dependency between adding a localhost comment and importing AWS region/S3 constants. They appear to be separate, independent changes with no mechanical linkage."
        },
        {
            "sample_idx": 65,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds an import of the 'operator' module, while Edit 1 uses a function called 'viewkeys'. These edits reference completely different symbols - 'operator' is a standard Python module for operator functions, while 'viewkeys' appears to be a compatibility function (likely for Python 2/3 compatibility given the file path). There is no direct code dependency between importing 'operator' and using 'viewkeys'. The changed lines reference entirely different symbols with no explicit linkage."
        },
        {
            "sample_idx": 66,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different files and modify completely different aspects of the codebase. Edit 0 modifies a conditional check in the TopologyGraph class by adding a condition to check if 'self.name' exists in 'executor_endpoint_mapping' before accessing it. Edit 1 adds exception handling and logging to the 'gather_endpoints' function in the GatewayRequestHandler class. While both files are part of the gateway functionality, the changed lines reference completely different symbols and operations - one deals with endpoint mapping validation, the other with exception handling. There is no direct code dependency, shared symbol reference, or structural synchronization between these specific changes."
        },
        {
            "sample_idx": 63,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbors in mental flow. Edit 0 imports symbols (SEND_CELERY_TASK_ERROR_EMAILS and mail_admins) in celery/datastructures.py, while Edit 1 defines a new ExcInfo class in celery/worker.py. The changed lines in each edit do not reference, assign, call, or import the exact same symbol. There is no explicit code dependency between the specific imports added in Edit 0 and the ExcInfo class definition in Edit 1. While both edits may be conceptually related to error handling functionality, they lack the direct, mechanically obvious code linkage required for neighbor classification. The symbols being added/defined are completely different and there is no immediate, code-driven prompt from one edit to the other."
        },
        {
            "sample_idx": 67,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve changes to similarly named variables (`stagle_table_name`) in different files and different functions. Edit 0 modifies the assignment logic in `insert_into_redshift_activity` by adding timestamp formatting and incorporating it into the stage table name. Edit 1 removes the assignment of `stagle_table_name` in `insert_into_snowflake_activity`. While both edits affect variables with the same name, they are in completely different scopes (different functions in different files) and therefore reference different symbols. There is no direct code dependency or linkage between these changed lines - they don't reference the same symbol, and neither edit creates a mechanical prompt for the other. The relationship is purely conceptual (both related to stage table naming logic) rather than based on explicit code linkage."
        },
        {
            "sample_idx": 70,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits are related to the GCSFeedStorage class and involve the 'acl' parameter, but they reference different instances of the class in different test methods. Edit 0 adds an assertion testing the 'acl' attribute in the test_parse_settings method, while Edit 1 adds the 'acl' parameter to a GCSFeedStorage constructor call in the test_store method. These are different symbols (different GCSFeedStorage instances in different scopes) and there is no direct code dependency between the changed lines - they don't reference the exact same symbol. The relationship is only conceptual/thematic (both relate to ACL functionality) rather than involving explicit code linkage between the same symbol."
        },
        {
            "sample_idx": 69,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits affect different functions and different symbols. Edit 0 adds a 'use_legacy_optimizer=True' parameter to an 'optimizers.deserialize()' call, while Edit 1 adds an 'is_legacy_optimizer': True' field to a dictionary in the docstring example of a 'serialize()' function. Although both relate to legacy optimizer functionality, the changed lines reference different symbols: 'deserialize' vs 'serialize'. The edits modify different functions (deserialize call vs serialize function docstring), in different files, and there is no direct code dependency between the specific lines being changed. The connection is only conceptual/thematic (both related to legacy optimizer support) rather than an explicit code linkage where the exact same symbol is referenced in both changed lines."
        },
        {
            "sample_idx": 68,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different files, different functions, and different variables. Edit 0 modifies the `stage_table_name` variable in the BigQuery batch export function, adding a timestamp suffix using `data_interval_end_str`. Edit 1 appears to be removing a line with a typo (`stagle_table_name` instead of `stage_table_name`) in the Snowflake batch export function. While both edits relate to stage table naming in batch export functions, they reference completely different symbols in different scopes - the `stage_table_name` variable in the BigQuery function is a different symbol from the `stagle_table_name` variable in the Snowflake function. There is no direct code dependency or explicit linkage between the changed lines themselves. The connection is only conceptual/thematic (both relating to batch export stage table naming) rather than involving the exact same symbol."
        },
        {
            "sample_idx": 71,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and have no direct code linkage. Edit 0 removes an import of 'aget_schema_by_id' from one file, while Edit 1 changes the parameter signature of 'pause_external_data_schedule' function from taking an 'ExternalDataSource' object to taking a string 'id'. The changed lines reference completely different symbols - one is about importing a schema function, the other is about changing a function parameter type. There is no explicit code dependency, no shared symbol reference, and no mechanical prompt from one edit to the other. They appear to be separate refactoring operations that happen to be part of the same broader change but lack direct code linkage between the specific changed lines."
        },
        {
            "sample_idx": 73,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and code constructs. Edit 0 adds an import statement for 'unicode_message' from 'glances.outputs.glances_unicode' at the top of the file. Edit 1 removes a comment line ('# Second line (optional)') from within a method called '__display_header'. There is no explicit code linkage between the imported 'unicode_message' symbol and the removed comment. The changed lines do not reference the same symbol, and there is no direct syntactic or structural dependency between adding an import and removing an unrelated comment. The connection, if any, would be purely conceptual or thematic rather than a direct code-driven prompt."
        },
        {
            "sample_idx": 72,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the symbol SEND_CELERY_TASK_ERROR_EMAILS from celery.conf, and edit 1 uses that exact same symbol in a conditional statement. The changed lines reference the exact same symbol - SEND_CELERY_TASK_ERROR_EMAILS. After making edit 0 (the import), edit 1 becomes immediately viable as it can now reference the imported symbol. After making edit 1 (the usage), edit 0 becomes necessary to provide the symbol definition. This is a classic import-usage relationship within the same file where both edits reference the exact same symbol, making either edit prompt the other as the next mechanical step."
        },
        {
            "sample_idx": 75,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite both touching 'skip_animations'. Edit 0 removes code that sets config['skip_animations'] in the get_configuration function, while Edit 1 modifies the stop_skipping method that uses self.skip_animations. The changed lines reference different symbols: config['skip_animations'] (a dictionary entry) versus self.skip_animations (an instance attribute). Even though they have the same name, they are different symbols in different scopes and contexts. There is no direct code dependency between the changed lines - removing the config setting logic doesn't create an immediate mechanical prompt to modify the stop_skipping method implementation, and vice versa. The connection is only conceptual (both relate to skip_animations functionality) rather than an explicit code linkage between the exact same symbol."
        },
        {
            "sample_idx": 74,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of optimizer configuration. Edit 0 adds a 'use_legacy_optimizer=False' parameter to an 'optimizers.deserialize()' call, while Edit 1 adds an 'is_legacy_optimizer': False' entry to a config dictionary returned by 'get_config()'. Although both relate to legacy optimizer handling, they reference different symbols: one is a parameter to a deserialize function call, the other is a dictionary key in a config return value. The changed lines do not reference the exact same symbol - they involve different function calls and different data structures. There is no direct code dependency where making one edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 76,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of CFG++ implementation but do not reference the exact same symbol. Edit 0 removes a line that checks for 'CFG++' in the sampler config name within the CFGDenoiser.forward method. Edit 1 adds properties (cond_scale_miltiplier and need_last_noise_uncond) to a model object in the ddim_cfgpp function. While both edits are conceptually related to CFG++ functionality, the changed lines reference different symbols - edit 0 references self.sampler.config.name, while edit 1 references model.cond_scale_miltiplier and model.need_last_noise_uncond. There is no direct code dependency or explicit symbol linkage between the changed lines themselves."
        },
        {
            "sample_idx": 78,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern: changing 'CREATE TABLE' to 'CREATE TABLE IF NOT EXISTS' in SQL statements within TrinoOperator configurations. This is a uniform, synchronized substitution across the same type of syntactic construct (SQL CREATE TABLE statements) within the same file. Both changes apply the exact same before\u2192after pattern and target identical construct types, making this a clear case of bulk-edit pattern synchronization that would naturally occur in a single, contiguous refactoring session."
        },
        {
            "sample_idx": 79,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file but affect completely different aspects of the code. Edit 0 modifies an error message string in the gather_endpoints function to be more specific about 'gathering endpoints'. Edit 1 replaces a hardcoded string 'gateway' with a constant GATEWAY_NAME in the handle_result function. The changed lines reference different symbols and serve different purposes - one is about error messaging and the other is about replacing a magic string with a constant. There is no direct code dependency, shared symbol reference, or structural relationship between these changes. They appear to be independent improvements made to different parts of the codebase."
        },
        {
            "sample_idx": 77,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a 'query_id' attribute to the TrinoHook class, and Edit 1 adds an on_kill method that directly references 'self.hook.query_id' in line 86. The changed lines in Edit 1 explicitly reference the exact same symbol (query_id attribute) that is being defined in Edit 0. This creates a direct definition-usage relationship where both edits reference the same symbol. After adding the query_id attribute in Edit 0, the next logical step would be to use it in the operator code (Edit 1), or vice versa - if implementing the on_kill method first, adding the query_id attribute would be the immediate next step to make the code functional. Both edits can be staged in either order since Python allows referencing undefined attributes at parse time (would only fail at runtime), making this a bi-directional relationship."
        },
        {
            "sample_idx": 81,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern: changing 'CREATE TABLE' to 'CREATE TABLE IF NOT EXISTS' in SQL statements. This is a uniform bulk edit applying the same before\u2192after pattern to the same type of syntactic construct (CREATE TABLE statements) within the same file. Both changes are part of a single, contiguous refactoring task to add idempotency to table creation operations. Either edit could be made first, and after making one, the other becomes an obvious next step to maintain consistency in the codebase."
        },
        {
            "sample_idx": 83,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve different aspects of the CFGDenoiser class and reference completely different symbols. Edit 0 adds two new instance attributes (cond_scale_miltiplier and need_last_noise_uncond) in the __init__ method. Edit 1 removes a line that assigns a boolean value to is_cfg_pp variable in the forward method. There is no direct code linkage between the changed lines - they don't reference the same symbols, variables, or create any immediate mechanical dependency. The edits are part of different methods and involve entirely separate functionality within the class. This appears to be coincidental cleanup/refactoring work rather than edits with explicit code dependencies."
        },
        {
            "sample_idx": 80,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and contexts. Edit 0 modifies a conditional check in the `_wait_previous_and_send` method of `TopologyGraph._ReqReplyNode` class, adding a check for `self.name in executor_endpoint_mapping`. Edit 1 modifies a string comparison in the `handle_result` method of `GatewayRequestHandler` class, replacing the hardcoded string 'gateway' with a constant `GATEWAY_NAME`. The changed lines do not reference the same symbol, function, variable, or import. There is no explicit code dependency between these edits - they are in different files, different classes, different methods, and modify different aspects of the codebase. While both may be conceptually related to gateway functionality, there is no direct, mechanical code linkage that would make one edit prompt the other as the next immediate step."
        },
        {
            "sample_idx": 82,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These edits modify adjacent lines in the same method and are part of a single cohesive refactoring operation. Edit 0 removes the comment '# Second line (optional)' from line 729, while Edit 1 wraps the code that displays the second line (including the same comment and the self.new_line() and self.display_plugin() calls) in a conditional check. The comment removed in Edit 0 is re-added in Edit 1 as part of the conditional block. This represents a single micro-task where the developer is restructuring the display logic to make the second line truly optional based on a width check. However, there is no direct code dependency between the changed lines - they don't reference the same symbol or create an immediate mechanical prompt for each other. The relationship is structural/contextual rather than based on explicit symbol linkage."
        },
        {
            "sample_idx": 85,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 adds a call to `self.separator_line()` after `self.__display_header()` in the `display` method. Edit 1 modifies the internal logic of the `__display_header` method by conditionally calling `self.new_line()` and `self.display_plugin()` based on cloud stats width. While both edits affect display formatting, they reference different symbols and have different purposes: Edit 0 adds a separator line call, while Edit 1 changes conditional display logic for cloud stats. The changed lines do not reference the exact same symbol - one calls `separator_line()` and the other involves `get_stats_display_width()`, `new_line()`, and `display_plugin()`. There is no direct code dependency or synchronized substitution between these specific changes."
        },
        {
            "sample_idx": 84,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol 'logger' within the same function (__init__). Edit 0 adds 'logger' as a parameter to the function signature, and Edit 1 uses that same parameter in the function body to assign it to self.logger. This creates a direct parameter definition \u2192 parameter usage relationship where both changed lines reference the identical symbol. After adding the parameter in Edit 0, using it in the function body (Edit 1) becomes the immediate, mechanically obvious next step. Since this is Python and both edits can be written and parsed in either order (no syntax errors), this is a bi-directional relationship."
        },
        {
            "sample_idx": 87,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbors because they both reference the exact same symbol 'vcs_rev' in the same function context. Edit 0 adds the 'vcs_rev' parameter to the function signature, and Edit 1 uses that same parameter in the return statement by passing it to the Env constructor. This creates an immediate, mechanically obvious code-driven relationship - after adding the parameter to the signature, the next natural step is to use it in the function body, and vice versa. Both edits can be staged in either order without causing parse errors (Python allows unused parameters and undefined variables at parse time), making this a bi-directional relationship rather than ordered."
        },
        {
            "sample_idx": 88,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 changes a string literal 'us-east-1' to a constant AWS_REGION_US_EAST_1 in config.py, while Edit 1 removes import statements for s3_listener and get_handler_file_from_name in a different file. There is no shared symbol, no definition-usage relationship, no mirrored substitution pattern, and no explicit code dependency between the changed lines. The edits appear to be unrelated cleanup/refactoring operations that happen to be part of the same broader codebase change but lack any immediate, mechanically obvious code-driven connection."
        },
        {
            "sample_idx": 86,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform the exact same textual substitution pattern: changing 'self._test_error_exc_info()' to '_test_error_exc_info()' in method calls. This is a uniform refactoring operation that removes the 'self.' prefix from the same method name across multiple locations within the same test class. Both changed lines reference the same syntactic construct (method calls) and apply identical before\u2192after transformation. This represents a bulk edit/pattern synchronization where either change could be made first, and after making one, the other becomes an obvious next step to maintain consistency. The edits are part of a single, contiguous refactoring task with no dependency on order - both can be staged independently and either naturally prompts completing the pattern."
        },
        {
            "sample_idx": 89,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits add the identical line 'connection.connect()' at the same structural position within similar nested functions that operate on proxy records. However, these are different functions in different files (record_exists vs delete_record, create.py vs delete.py) that reference different symbols despite the identical added code. The changed lines don't reference the exact same symbol - they are separate connection.connect() calls in different scopes. While this appears to be part of a bulk refactoring pattern to add connection initialization, the edits operate on different functions and don't create direct code dependencies between each other. The relationship is purely conceptual/thematic rather than involving explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 90,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern: changing 'self._test_error_exc_info()' to '_test_error_exc_info()' in method calls. This is a uniform refactoring operation that removes the 'self.' prefix from the same method call across multiple locations within the same test class. Both edits target the same type of syntactic construct (method calls) and apply the exact same before\u2192after transformation pattern. This represents a bulk edit/pattern synchronization where either change could be made first, and both are part of the same contiguous refactoring micro-task to change how this helper method is accessed."
        },
        {
            "sample_idx": 92,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the GlancesPassword class from glances.core.glances_password module, and Edit 1 uses that exact same GlancesPassword symbol as a base class for GlancesPasswordList. The changed lines reference the exact same symbol - GlancesPassword. After making either edit, the other becomes the immediate next step: if you import GlancesPassword first, you can then use it as a base class; if you change the class to inherit from GlancesPassword first, you need the import to resolve the symbol. Both edits can be parsed and staged in either order (the inheritance will just cause a NameError at runtime if the import is missing, but won't cause a parse error), making this a bi-directional relationship."
        },
        {
            "sample_idx": 91,
            "yi": "0 before 1",
            "pred": "no relation",
            "pred_reason": "These edits involve the same function `_newnames` but they are making different types of changes to different parts of the function. Edit 0 removes comment lines above the function definition (lines 283-285), while Edit 1 adds a docstring inside the function body (lines 284-287). Although both edits relate to the same function and involve similar descriptive text about the function's purpose, they are modifying different structural elements - external comments vs. internal docstring. The changed lines do not reference the exact same symbol or create a direct code dependency. The removal of comments and addition of docstrings are separate refactoring actions that could be done independently without one mechanically prompting the other. This appears to be a case where both edits are part of improving documentation for the same function, but there is no explicit code linkage between the specific lines being changed."
        },
        {
            "sample_idx": 94,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and functionality with no direct code dependency. Edit 0 adds a command-line argument '--separator' with destination 'enable_separator' in the argument parser. Edit 1 adds calls to 'init_column()' and 'separator_line()' methods in the display logic. While both edits are conceptually related to separator functionality, there is no explicit code linkage between the changed lines - they don't reference the same symbol, and the argument parsing in edit 0 doesn't directly connect to the method calls in edit 1. The relationship is thematic/feature-based rather than mechanically code-driven."
        },
        {
            "sample_idx": 93,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a call to `self.build()` in what appears to be the constructor or initialization method of the Embedding class. Edit 1 adds an early return guard `if self.built: return` at the beginning of the `build` method itself. These edits reference the exact same symbol (`self.build()` method) and create a direct code dependency. Edit 0 introduces a call to `build()`, and Edit 1 modifies that same `build()` method to handle multiple calls gracefully by checking if it's already built. This is a classic definition-usage relationship where one edit calls a method and the other edit modifies that same method's behavior. The guard in Edit 1 makes sense as a direct response to the potential for multiple calls introduced in Edit 0. Both edits can be staged in either order without parse errors, making this bi-directional."
        },
        {
            "sample_idx": 96,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different symbols and operations. Edit 0 adds 'AWS_REGION_US_EAST_1' to an import statement in config.py, while Edit 1 removes two import lines ('s3_listener' and 'get_handler_file_from_name') from template_deployer.py. The changed lines reference entirely different symbols in different files with no direct code dependency or linkage between them. There is no explicit reference to the same symbol, no structural dependency, and no synchronized pattern. These appear to be independent code changes that happen to be part of the same broader refactoring but lack any immediate, mechanically obvious connection at the locus of change."
        },
        {
            "sample_idx": 97,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits do not reference the same symbol or have any direct code dependency. Edit 0 adds 'schedule_exists' to what appears to be an import list, while Edit 1 changes a parameter from 'str(external_data_source.id)' to 'id' in a function call. The changed lines reference completely different symbols - 'schedule_exists' in edit 0 and the parameter substitution in edit 1. There is no explicit code linkage, structural dependency, or mirrored substitution pattern between these edits. They appear to be separate, unrelated changes that happen to be in the same file."
        },
        {
            "sample_idx": 95,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of optimizer configuration. Edit 0 adds a 'use_legacy_optimizer=True' parameter to an 'optimizers.deserialize()' function call, while Edit 1 adds an 'is_legacy_optimizer': False' entry to a config dictionary in a completely different class and method. Although both relate to legacy optimizer handling, the changed lines reference different symbols (a function parameter vs a dictionary key) in different contexts (deserialization vs config generation). There is no direct code dependency between these specific changes - they don't reference the same symbol, and neither edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 98,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a variable `cwd` by assigning it a value computed from `os.path.realpath(...)`. Edit 1 uses this exact same variable `cwd` as an argument to the `run_subprocess()` method call. The changed lines reference the exact same symbol - the variable `cwd`. After making edit 0 (defining `cwd`), edit 1 (using `cwd` as a parameter) becomes the immediate, mechanically obvious next step since the variable was defined to be used. Similarly, after making edit 1, edit 0 becomes necessary to provide the definition. This is a classic definition-usage relationship within the same function scope where both edits reference the exact same symbol."
        },
        {
            "sample_idx": 100,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats a function call by splitting the parameters across multiple lines in the curses display module, while Edit 1 adds new Unicode character mappings to a Unicode constants dictionary. The edits operate on different files, different data structures, and different symbols. There is no shared symbol, function, variable, or structural element between the changed lines. The only connection is that both files are part of the same codebase, but this represents a purely conceptual relationship without any direct code dependency or mechanical prompt between the edits."
        },
        {
            "sample_idx": 99,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new class `ExcInfo` and Edit 1 uses that exact same class by instantiating it with `ExcInfo(sys.exc_info())`. The changed lines reference the exact same symbol - the `ExcInfo` class. After defining the class in Edit 0, using it in Edit 1 becomes an immediate, mechanically obvious next step. However, since this is Python, Edit 1 could be written and parsed even before Edit 0 exists (it would only fail at runtime with a NameError). Both edits can be staged in either order without parser errors, making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "sample_idx": 102,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 imports the function `unpause_external_data_schedule` from the service module, while Edit 1 modifies the implementation of that same function by changing a parameter reference from `str(external_data_source.id)` to `id`. However, the changed lines do not reference the exact same symbol - the import statement references the function name itself, while the implementation change references a parameter usage within the function body. The import can exist independently of the parameter change, and the parameter change can be made independently of whether the function is imported elsewhere. There is no immediate, mechanically obvious code-driven prompt between these specific changes."
        },
        {
            "sample_idx": 101,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Edit 0 changes the class name from 'GlancesPassword' to 'GlancesPasswordList(GlancesPassword)', making it inherit from GlancesPassword. Edit 1 adds a super() call within what appears to be the __init__ method of this class. However, after edit 0, the class is now 'GlancesPasswordList' inheriting from 'GlancesPassword', but edit 1's super() call references 'GlancesPassword' as the class name in the super() call. This creates a mismatch - the super() call should reference 'GlancesPasswordList' (the actual class name after edit 0) not 'GlancesPassword'. The edits reference different symbols: edit 0 changes the class definition to 'GlancesPasswordList', while edit 1's super() call references 'GlancesPassword'. These are different symbols despite the naming relationship, and there's no direct code dependency between the changed lines themselves."
        },
        {
            "sample_idx": 104,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 modifies the implementation of the sm3 optimizer's init function to handle scalar inputs by adding shape preservation and using jnp.atleast_1d(). Edit 1 refactors the test by renaming the existing testSM3 method to testSM3Vector and adding a new testSM3Scalar method. While both edits relate to scalar handling in the SM3 optimizer, they reference different symbols and contexts: Edit 0 changes internal implementation variables (x_shape, x0) within the init function, while Edit 1 changes test method names and adds a new test method. The changed lines do not reference the exact same symbol - they are conceptually related improvements to scalar support but lack direct code dependency or synchronized substitution at the locus of change."
        },
        {
            "sample_idx": 103,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite the name 'connection' appearing in both. Edit 0 adds a call to 'connection.connect()' within an existing function that presumably already has access to a connection object in scope. Edit 1 adds an import statement 'from django.db import connection' in a different file. While both reference something called 'connection', they are not referencing the exact same symbol - Edit 0 uses a connection object that's already in scope in that function, while Edit 1 imports the Django database connection module. There is no direct code dependency between these changed lines, as they occur in different files and involve different connection objects/modules. The relationship is only conceptual (both deal with database connections) rather than an explicit code linkage between the exact same symbol."
        },
        {
            "sample_idx": 105,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new constant `AWS_REGION_US_EAST_1` in the constants.py file, and Edit 1 imports that exact same constant in template_deployer.py. The changed lines reference the exact same symbol - `AWS_REGION_US_EAST_1`. After defining the constant in Edit 0, importing it in Edit 1 becomes a natural next step if that symbol is needed. Conversely, if Edit 1 is made first (importing the constant), Edit 0 becomes immediately necessary to define the symbol being imported. In Python, importing an undefined symbol is allowed at parse time and only fails at runtime with an ImportError, so both edits can be staged in either order without parser-level syntax errors. This is a classic definition-usage relationship for the same symbol across files."
        },
        {
            "sample_idx": 106,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same configuration key 'is_legacy_optimizer' but in completely different contexts and test files. Edit 0 adds an assertion checking that 'is_legacy_optimizer' is True in a specific optimizer test, while Edit 1 adds logic to remove the 'is_legacy_optimizer' key from a config dictionary if it's not present in the original config. Although both reference the same string literal 'is_legacy_optimizer', they are not referencing the same symbol - they are working with different config objects in different test methods in different files. There is no direct code dependency between these edits, and making one does not create an immediate, mechanically obvious prompt for the other. The relationship is conceptual (both deal with the same configuration property) but lacks the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 108,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a command-line argument '--add-stop-route' that controls whether to add a stop route functionality. Edit 1 defines the 'stop_route' function that would be used when this command-line option is enabled. While these edits are conceptually related (both are part of implementing a stop route feature), they reference different symbols and have no direct code dependency between the changed lines. The command-line argument definition in edit 0 does not reference the stop_route function, and the function definition in edit 1 does not reference the command-line argument. There is no explicit code linkage, import relationship, or direct symbol reference between the changed lines themselves. This is a feature-based relationship rather than a direct code dependency."
        },
        {
            "sample_idx": 107,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds an early return check `if self.built: return` to the `build` method of the Embedding layer, which changes the behavior so that the method can be called multiple times without error. Edit 1 removes a test called `test_quantize_on_unbuilt_layer` that was testing that quantizing an unbuilt layer would raise a ValueError. These edits are related because the implementation change in edit 0 (allowing build to be called multiple times safely) makes the test behavior in edit 1 no longer valid - the test was expecting an error condition that may no longer occur due to the build method changes. However, the changed lines don't reference the exact same symbol - edit 0 modifies the `build` method while edit 1 removes a `test_quantize_on_unbuilt_layer` method. While they are conceptually related (the implementation change affects the test expectations), there is no direct code dependency or reference to the exact same symbol between the changed lines."
        },
        {
            "sample_idx": 109,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions and different parameters. Edit 0 changes a call to `get_free_trial_days()` to pass a new `is_self_hosted_billing` parameter within the `get_initial_upgrade_context` method. Edit 1 adds an `is_self_hosted_billing` parameter to the `compute_plan_parameters` function signature. While both edits involve a parameter with the same name (`is_self_hosted_billing`), they are in completely different functions and there is no direct code linkage between the changed lines. The changed lines do not reference the exact same symbol - one is adding a parameter to a function signature, the other is computing and passing a parameter to a different function call. This is a case of same parameter name in different scopes/contexts, which represents different symbols according to the criteria."
        },
        {
            "sample_idx": 110,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different files and affect completely different functions with different purposes. Edit 0 removes code from a function called 'check_schedule_activity' that was checking if a schema should sync, while Edit 1 changes the parameter signature of a function called 'pause_external_data_schedule' from taking an ExternalDataSource object to taking a string id. There is no direct code linkage between these edits - they don't reference the same symbols, functions, or variables. The changed lines in each edit don't reference any common symbols. While both edits may be conceptually related to external data processing, there is no explicit, immediate code-driven dependency or synchronized pattern between the specific lines being changed."
        },
        {
            "sample_idx": 112,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (GCS ACL configuration) but do not have direct code linkage between the changed lines. Edit 0 adds `self.acl = acl` in the GCSFeedStorage constructor, referencing a local parameter `acl`. Edit 1 adds a default setting `FEED_STORAGE_GCS_ACL = None` in the settings file. While these are conceptually related (both dealing with GCS ACL functionality), the changed lines do not reference the exact same symbol - one references a parameter `acl` and the other defines a setting constant `FEED_STORAGE_GCS_ACL`. There is no direct, explicit code dependency where one edit's changed line references the same symbol as the other edit's changed line. This is a thematic/feature-based relationship without direct symbol linkage."
        },
        {
            "sample_idx": 113,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are adding different imports to different files for different purposes. Edit 0 adds imports related to email functionality (SEND_CELERY_TASK_ERROR_EMAILS from celery.conf and mail_admins from django.core.mail) to celery/datastructures.py. Edit 1 adds sys and traceback imports to celery/worker.py, which are typically used for error handling and system operations. While both edits involve adding imports, they reference completely different symbols (different import names) in different files, and there is no direct code dependency or synchronized pattern between them. The changed lines do not reference the exact same symbol, and making one edit does not create an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 111,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new function `schedule_exists` in the `posthog/temporal/common/schedule.py` file. Edit 1 imports this exact same function `schedule_exists` in the `posthog/warehouse/data_load/service.py` file by adding it to an existing import statement. This is a classic definition-usage relationship where the changed lines reference the exact same symbol. In Python, both edits can be staged in either order since the import will only fail at runtime/import-time (not at parse time) if the function doesn't exist. After making either edit, the other becomes the immediate next step to complete the functionality - either defining the function that's being imported, or importing the function that was just defined."
        },
        {
            "sample_idx": 114,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a constant `PREHEATED_REPORT_CONTEXT` at the module level, and Edit 1 uses this exact same constant in multiple places within the changed lines (lines 211, 212, and 213). The constant is referenced directly in the conditional check and dictionary operations. After making Edit 0, the constant becomes available for use, making Edit 1's usage of it the natural next step. However, in Python, referencing an undefined name in code that won't be executed immediately (like inside a method body) only causes a runtime NameError, not a parse-time syntax error. Both edits can be written and parsed in either order, so this is a bi-directional definition-usage relationship where both edits reference the exact same symbol."
        },
        {
            "sample_idx": 115,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new method `filter_relations` in the `BaseDeletionTask` class, and Edit 1 calls that exact same method within the same class. The changed lines reference the exact same symbol - the `filter_relations` method. After defining the method in Edit 0, Edit 1 becomes the immediate next step to use it, and vice versa - after adding the call in Edit 1, defining the method in Edit 0 becomes necessary. Both edits can be written and parsed in either order (the call to an undefined method would only cause a runtime AttributeError, not a parse-time syntax error), making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "sample_idx": 116,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different function calls and different symbols. Edit 0 modifies a call to `optimizers.deserialize()` by adding a `use_legacy_optimizer=True` parameter. Edit 1 modifies a different function that calls `learning_rate_schedule.deserialize()` and adds code to handle an `is_legacy_optimizer` config key. While both edits are conceptually related to legacy optimizer handling, the changed lines reference completely different symbols: `optimizers.deserialize` vs `learning_rate_schedule.deserialize`, and different parameters: `use_legacy_optimizer` vs `is_legacy_optimizer`. There is no direct code dependency or explicit symbol linkage between the changed lines themselves."
        },
        {
            "sample_idx": 118,
            "yi": "bi-directional",
            "pred": "0 before 1",
            "pred_reason": "Edit 0 creates a new variable `is_self_hosted_billing` and modifies the call to `get_free_trial_days()` to pass this variable as an argument. Edit 1 then uses this exact same variable `is_self_hosted_billing` as a named parameter in a call to `compute_plan_parameters()`. The changed lines in both edits reference the exact same symbol - the variable `is_self_hosted_billing` that is defined in edit 0 and used in edit 1. This creates an immediate code dependency where edit 0 must occur before edit 1, as edit 1 references a variable that doesn't exist until edit 0 creates it. Both edits are within the same function scope and represent a single micro-task of threading the new variable through multiple function calls."
        },
        {
            "sample_idx": 117,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a 'logger' parameter to the __init__ method of GatewayRequestHandler class, while Edit 1 uses 'self.logger' in an error handling block within the same class. These edits reference the exact same symbol - the logger attribute of the GatewayRequestHandler instance. After adding the logger parameter to the constructor (Edit 0), using self.logger in the handle_request method (Edit 1) becomes the natural next step to utilize the newly added logger functionality. Both edits can be staged in either order since Python allows referencing undefined attributes at parse time (would only cause AttributeError at runtime), making this a bi-directional relationship where either edit naturally prompts the other as part of the same micro-task of adding logging capability to the class."
        },
        {
            "sample_idx": 119,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds 'AWS_REGION_US_EAST_1' to an import statement in config.py, while Edit 1 adds a comment about localhost in constants.py. These edits reference completely different symbols and concepts - one is importing a region constant, the other is adding documentation about a localhost constant. There is no direct code dependency, no shared symbol reference, and no mechanical prompt relationship between adding a region import and adding a localhost comment. The edits appear to be independent changes that happen to occur in related configuration files but have no explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 120,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits affect completely different parts of the codebase and different symbols. Edit 0 modifies a call to `pause_external_data_schedule` by changing the argument from `job.pipeline` to `str(job.pipeline.id)` in the warehouse.py file. Edit 1 removes code related to schema checking in the external_data_job.py file, specifically removing calls to `aget_schema_by_id` and related logic. The changed lines reference entirely different symbols (`pause_external_data_schedule` vs `aget_schema_by_id` and `schema_model`) and there is no direct code dependency or structural relationship between them. While both edits may be part of the same feature or refactoring effort conceptually, there is no explicit code linkage where one edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 122,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 changes a type check from 'Exception' to 'ExcInfo' in a method within celery/datastructures.py. Edit 1 adds import statements for 'sys' and 'traceback' modules in celery/worker.py. While both edits might be conceptually related to exception handling improvements, the changed lines do not reference the same symbol - Edit 0 references 'ExcInfo' while Edit 1 imports standard library modules. There is no explicit code dependency or synchronized substitution pattern between these changes."
        },
        {
            "sample_idx": 121,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are both within the same method (CFGDenoiser.forward) and appear to be part of the same conditional logic flow, but they modify different branches of an if-elif-else statement. Edit 0 modifies the `is_edit_model` branch by changing how `cond_scale` is passed to `combine_denoised_for_edit_model`, while Edit 1 removes the `is_cfg_pp` elif branch entirely. While both edits relate to conditional denoising logic and involve `cond_scale` handling, the changed lines do not reference the exact same symbol or create a direct code dependency. The edits affect different conditional branches and there's no explicit code linkage between the specific lines being changed - one modifies a parameter calculation, the other removes an entire conditional branch. This appears to be conceptual/thematic refactoring rather than mechanical code dependency."
        },
        {
            "sample_idx": 124,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are unrelated. Edit 0 modifies a conditional statement within a method in the TopologyGraph class, adding a check for 'self.name in executor_endpoint_mapping'. Edit 1 adds an import statement for 'JinaLogger' in a different file. The changed lines do not reference the same symbol - edit 0 references 'executor_endpoint_mapping' and 'self.name' in a conditional context, while edit 1 imports 'JinaLogger'. There is no direct code dependency, shared symbol reference, or structural synchronization between these edits. They appear to be part of different micro-tasks with no immediate mechanical connection."
        },
        {
            "sample_idx": 123,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits change the parameter names from 'type' and 'token' to 'email_type' and 'confirmation_key' for the exact same function (email_unsubscribe). Edit 0 changes the function signature in the definition, while Edit 1 changes the URL pattern that calls this function. The URL pattern uses named groups that must match the function's parameter names exactly for Django's URL routing to work. Both edits reference the same function and the same parameters - this is a signature change paired with its corresponding caller update. Either edit can be made first since both are syntactically valid independently, but after making either edit, the other becomes the immediate next step to maintain consistency between the URL pattern and function signature."
        },
        {
            "sample_idx": 125,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits form a classic function signature change and corresponding call-site update pattern. Edit 0 adds a 'dtype' parameter to the load_unet function definition in comfy/sd.py, and Edit 1 updates the call to that exact same function in nodes.py to pass the new dtype parameter. The changed lines in both edits reference the exact same symbol (comfy.sd.load_unet) and the exact same parameter (dtype). After making either edit, the other becomes the immediate, mechanically obvious next step to maintain code consistency. Both edits can be staged in either order without causing parse errors - the function signature can be changed first (call site will just ignore the new optional parameter) or the call site can be updated first (passing an extra argument to a function that will soon accept it)."
        },
        {
            "sample_idx": 126,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 removes the definition of the variable 'is_cfg_pp' at line 164, while Edit 1 removes the usage of that same variable 'is_cfg_pp' at line 279 and replaces it with 'self.need_last_noise_uncond'. Both edits reference the exact same symbol 'is_cfg_pp' - one removes its definition and the other removes its usage. This creates a direct code dependency where after making either edit, the other becomes mechanically necessary to maintain code consistency. The edits are part of the same refactoring task to replace the 'is_cfg_pp' variable with 'self.need_last_noise_uncond'. Since both edits can be staged in either order without causing parse errors (the usage would just reference an undefined variable at runtime), this is a bi-directional relationship."
        },
        {
            "sample_idx": 128,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts with no direct code dependency. Edit 0 adds a 'use_legacy_optimizer=True' parameter to an optimizers.deserialize() call in the LossScaleOptimizer class. Edit 1 adds logic to handle 'is_legacy_optimizer' in optimizer configuration testing. While both relate to legacy optimizer handling conceptually, the changed lines reference different symbols: edit 0 references the 'use_legacy_optimizer' parameter in a deserialize call, while edit 1 references 'is_legacy_optimizer' in config dictionaries. These are different parameter names in different contexts (deserialize parameter vs config dictionary key), so they are different symbols despite the conceptual relationship."
        },
        {
            "sample_idx": 127,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an import statement 'from glances.outputs.glances_unicode import unicode_message' which imports the unicode_message function. Edit 1 modifies the unicode_message function definition by removing a blank line above it. These edits reference the exact same symbol (unicode_message function) - one imports it and the other defines it. However, since this is Python, the import can be successfully parsed and staged even if the function definition doesn't exist yet (it would only fail at runtime with an ImportError). Similarly, the function definition can exist without the import. Both edits can be written and parsed in either order, making this a bi-directional relationship where either edit naturally prompts attention to the other as part of working with the same symbol."
        },
        {
            "sample_idx": 130,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 imports the `unicode_message` function from `glances.outputs.glances_unicode`, while Edit 1 modifies display logic for the cloud plugin by adding a conditional check around `self.new_line()` and `self.display_plugin()` calls. The changed lines in each edit do not reference, assign, call, or import the exact same symbol. The `unicode_message` import in Edit 0 is not used in the changed lines of Edit 1, and the display logic modification in Edit 1 does not involve the imported `unicode_message` function. These are separate changes that happen to be in the same file but lack explicit code linkage between the exact symbols being modified."
        },
        {
            "sample_idx": 129,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes the function signature of `get_free_trial_days()` by adding a new parameter `is_self_hosted_billing: bool = False`. Edit 1 updates a call site of the exact same function `get_free_trial_days()` to pass the new parameter as `get_free_trial_days(True)`. This is a classic definition-usage relationship where both edits reference the exact same symbol. The signature change in edit 0 creates an immediate, mechanically obvious prompt to update call sites like the one in edit 1. Since Python allows both edits to be parsed and staged in either order (the call with the argument will work with the updated signature, and the signature with default parameter will work with existing calls), this is a bi-directional relationship rather than ordered."
        },
        {
            "sample_idx": 132,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits modify different functions in different files and do not reference the same symbol. Edit 0 adds a 'dtype' parameter to the load_unet function signature in comfy/sd.py, while Edit 1 adds a 'weight_dtype' parameter to the INPUT_TYPES method of UNETLoader class in nodes.py. Although both relate to data type handling and may be part of the same feature implementation, the changed lines reference different symbols (different parameter names in different functions). There is no direct code dependency where one edit's changed lines reference the exact same symbol as the other edit's changed lines. The connection is conceptual/thematic rather than based on explicit code linkage between the same symbols."
        },
        {
            "sample_idx": 131,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are part of different test methods within the same test class and involve different aspects of GCS configuration testing. Edit 0 adds 'FEED_STORAGE_GCS_ACL': None to a mock patch decorator for the test_parse_settings method, while Edit 1 adds a local variable 'acl = publicRead' within the test_store method. Although both edits relate to ACL (Access Control List) functionality for GCS feed storage, they reference different symbols in different scopes - one is a dictionary key in a mock configuration, the other is a local variable assignment. There is no direct code dependency between the changed lines, and neither edit creates an immediate, mechanically obvious prompt for the other. The connection is purely conceptual/thematic around ACL testing functionality."
        },
        {
            "sample_idx": 133,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different aspects of the QaEngineer class without direct code linkage. Edit 0 removes the recv method from the QaEngineer class definition, while Edit 1 modifies how QaEngineer instances are hired in the startup function - moving QaEngineer hiring to a conditional block. Although both edits involve QaEngineer, they don't reference the exact same symbol at the locus of change. Edit 0 changes the class definition by removing a method, while Edit 1 changes instantiation/hiring logic. There's no immediate, mechanically obvious prompt from one edit to the other - removing a method doesn't directly necessitate changing hiring logic, and vice versa. The connection is conceptual (both relate to QaEngineer functionality) rather than an explicit code dependency between the changed lines."
        },
        {
            "sample_idx": 135,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 adds a 'seen = set()' variable initialization in the _newnames function in _internal.py, which appears to be setting up for duplicate detection logic. Edit 1 adds a test that verifies a ValueError with 'duplicate' message is raised when sorting with duplicate field names. While both edits are conceptually related to handling duplicates, they reference completely different symbols and contexts. The changed lines do not reference the same symbol - edit 0 initializes a local 'seen' variable, while edit 1 calls assert_raises_regex and a lambda function with r.sort(). There is no direct code dependency or explicit linkage between the exact symbols being modified in each edit. The connection is purely thematic/conceptual rather than based on direct symbol references."
        },
        {
            "sample_idx": 134,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are making changes to different parts of the same file but involve completely different symbols and code constructs. Edit 0 adds a constant definition 'PREHEATED_REPORT_CONTEXT' at the module level, while Edit 1 reformats a conditional expression involving config options in a method. The changed lines reference entirely different symbols - one introduces a new constant, the other modifies how existing config function calls are formatted. There is no direct code dependency, shared symbol reference, or structural relationship between adding a constant definition and reformatting a conditional expression. These appear to be separate, independent changes that happen to be in the same file."
        },
        {
            "sample_idx": 136,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file and class, but they reference completely different symbols and serve different purposes. Edit 0 adds a logger initialization using 'JinaLogger' in the constructor, while Edit 1 replaces a string literal 'gateway' with a constant 'GATEWAY_NAME' in a route handling method. There is no direct code dependency between these changes - they don't reference the same symbol, and neither edit creates an immediate mechanical prompt for the other. The changes are conceptually related to the same class but lack explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 137,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 changes the function signature of `unpause_external_data_schedule` from taking an `ExternalDataSource` parameter to taking a `str` parameter named `id`. Edit 0 updates the call site to pass `str(source.id)` instead of just `source` to match this new signature. Both edits reference the exact same function symbol `unpause_external_data_schedule`. After making either edit, the other becomes the immediate, mechanically obvious next step to maintain code consistency - if you change the signature without updating the call site (or vice versa), you get a type mismatch. This is a classic definition-usage relationship where both edits can be staged in either order (no parser errors), making it bi-directional."
        },
        {
            "sample_idx": 138,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new key 'is_legacy_optimizer' to the config dictionary returned by the get_config() method in the OptimizerV2 class. Edit 1 adds a test assertion that checks for this exact same key in the config returned by get_config(). The test directly validates the behavior introduced in edit 0 - both edits reference the exact same symbol (the 'is_legacy_optimizer' key in the config dictionary) and form a clear test-production code synchronization pattern. After making edit 0, adding the corresponding test assertion becomes the immediate next step to validate the new behavior, and vice versa - if writing the test first, implementing the feature becomes the obvious next step."
        },
        {
            "sample_idx": 140,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are within the same function `_newnames` but they modify completely different aspects of the function. Edit 0 adds a docstring at the beginning of the function, while Edit 1 modifies the error handling logic in the middle of the function to add duplicate field name detection. The changed lines in each edit do not reference the same symbols - Edit 0 only adds documentation, while Edit 1 modifies exception handling and adds a `seen.add(name)` call. There is no direct code dependency between adding a docstring and changing error handling logic. These are separate, independent improvements to the same function that could be made in any order without creating immediate code-driven prompts for each other."
        },
        {
            "sample_idx": 139,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different contexts. Edit 0 adds a new function `external_data_workflow_exists` that takes a parameter `id: str` and uses it directly in a `schedule_exists` call. Edit 1 modifies an existing function `unpause_external_data_schedule` by changing how the `schedule_id` parameter is passed to `unpause_schedule` - from `str(external_data_source.id)` to just `id`. While both edits involve parameters named `id`, they reference completely different symbols: the `id` parameter in the new function from edit 0 is a different symbol from the `id` being referenced in edit 1 (which appears to be referencing some `id` variable in the scope of `unpause_external_data_schedule`). The changed lines do not reference the exact same symbol, and there is no direct code dependency or synchronized substitution pattern between them."
        },
        {
            "sample_idx": 141,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits modify the `skip_animations` attribute of the same Scene class, but they reference different aspects of the skipping logic and occur in different methods with different purposes. Edit 0 sets `skip_animations = True` conditionally in the constructor when `start_at_animation_number` is not None. Edit 1 unconditionally sets `skip_animations = False` in the `stop_skipping` method while also adding a new line for `virtual_animation_start_time`. While both edits involve the same attribute name, they are part of different logical flows - one is initialization logic and the other is state transition logic. The changed lines don't create an immediate, mechanically obvious prompt for each other, and there's no direct code dependency between the specific changes made. This appears to be a refactoring of animation skipping logic where multiple independent changes are being made to improve the overall system."
        },
        {
            "sample_idx": 143,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the function `pause_external_data_schedule` from the service module, while Edit 1 changes the signature of that exact same function by modifying its parameter from `external_data_source: ExternalDataSource` to `id: str`. These edits reference the exact same symbol - the `pause_external_data_schedule` function. After making the signature change in Edit 1, the import in Edit 0 would still work (imports don't break due to parameter changes), and after adding the import in Edit 0, the signature change in Edit 1 would still be valid. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship where either edit naturally prompts the other as part of the same refactoring task."
        },
        {
            "sample_idx": 142,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits involve calls to the exact same method `self.init_column()`. Edit 0 adds a call to `self.init_column()` in the `display` method, while Edit 1 shows an existing call to `self.init_column()` in the `__display_header` method (with a comment removal). However, these are calls to the same method from different locations in the codebase, not a definition-usage relationship or synchronized pattern. The changed lines reference the same method symbol but in completely different contexts and methods. There's no direct code dependency between these specific call sites - adding the call in `display` doesn't create an immediate prompt to modify the call in `__display_header`, nor vice versa. These appear to be separate, independent uses of the same utility method."
        },
        {
            "sample_idx": 144,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 removes the line that assigns `duration = int(time.time() - start)`, while edit 1 removes the usage of the `duration` variable and replaces it with the inline expression `int(time.time() - start)`. These edits reference the exact same symbol (`duration`) and represent a refactoring where the variable assignment is eliminated in favor of direct inline usage. After making edit 0 (removing the assignment), edit 1 becomes the immediate next step to handle the now-undefined usage of `duration`. Conversely, if edit 1 is made first (inlining the expression), then edit 0 becomes the natural cleanup step to remove the now-unused variable assignment. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "sample_idx": 145,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a `skip_models` parameter to the `BaseDeletionTask.__init__` method signature. Edit 1 adds a `skip_models` argument to a call to `deletions.get()`. However, these edits reference different functions/methods - one modifies the constructor of `BaseDeletionTask` while the other modifies a call to `deletions.get()`. The changed lines do not reference the exact same symbol. Even though both involve a parameter named `skip_models`, they are in different contexts (different functions/methods) and therefore represent different symbols. There is no direct code dependency between these specific changed lines."
        },
        {
            "sample_idx": 146,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits modify different methods within the same class and reference completely different symbols. Edit 0 modifies the __repr__ method to add skip_models to the string representation, while Edit 1 modifies the delete_bulk method to add a call to filter_relations. The changed lines reference different symbols (skip_models vs filter_relations method call) and there is no explicit code dependency between them. While both edits are in the same class and may be part of the same feature implementation, there is no direct, mechanically obvious code-driven prompt from one edit to the other."
        },
        {
            "sample_idx": 148,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and operations. Edit 0 modifies the structure of a `user_agent` dictionary within the `ModelMixin.from_pretrained` method by adding a 'diffusers' version field. Edit 1 adds a `user_agent` parameter to a `snapshot_download` function call within the `DiffusionPipeline.from_pretrained` method. While both edits involve variables named 'user_agent', they reference different symbols in different classes and contexts - the changed lines do not reference the exact same symbol. The `user_agent` in edit 0 is a local dictionary being constructed in one method, while the `user_agent` in edit 1 is a parameter being passed to a function call in a completely different method and class. There is no direct code dependency or explicit linkage between these specific changed lines."
        },
        {
            "sample_idx": 147,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions and different symbols. Edit 0 adds an 'is_self_hosted_billing' parameter to the 'compute_plan_parameters' function, while Edit 1 modifies a call to 'get_free_trial_days' function by adding a True argument. The changed lines reference completely different symbols - one is adding a parameter to compute_plan_parameters, the other is modifying a call to get_free_trial_days. There is no direct code dependency, shared symbol reference, or synchronized substitution pattern between these edits. They appear to be part of the same feature (self-hosted billing) but lack the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 150,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a new setting FEED_STORAGE_GCS_ACL = None to the default settings file, while Edit 1 adds a test assertion checking that storage.acl == 'publicRead' in a GCS feed storage test. Although both edits relate to GCS ACL functionality, they reference different symbols and contexts. Edit 0 defines a configuration constant FEED_STORAGE_GCS_ACL, while Edit 1 tests a storage.acl attribute. The changed lines do not reference the exact same symbol - one is a module-level constant definition and the other is an attribute access on a storage object. There is no direct, explicit code dependency between these specific lines of code, only a conceptual relationship around GCS ACL configuration."
        },
        {
            "sample_idx": 149,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes the signature of the `get_free_trial_days` function by adding a new parameter `is_self_hosted_billing: bool = False`. Edit 1 updates a call site of the exact same function `get_free_trial_days` to pass the argument `True` for the new parameter. These edits reference the exact same symbol and create a direct code dependency - after changing the function signature to accept the new parameter, updating the call site to use that parameter is the immediate, mechanically obvious next step. Both edits can be staged in either order since the new parameter has a default value, making the relationship bi-directional rather than ordered."
        },
        {
            "sample_idx": 151,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a variable `user_agent` by creating a dictionary with diffusers version and pipeline class information. Edit 1 uses this exact same `user_agent` variable by passing it as a parameter to the `snapshot_download` function call. The changed lines reference the exact same symbol - the `user_agent` variable defined in edit 0 is directly referenced in edit 1. This creates an immediate code dependency where defining the variable naturally prompts its usage as the next step in the same function. Both edits can be staged in either order without parser errors (Python allows referencing undefined variables), making this a bi-directional relationship where either edit creates a mechanical prompt for the other."
        },
        {
            "sample_idx": 154,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 adds an import statement for the 'os' module at the top of the function, while Edit 1 adds a 'cwd=cwd' parameter to a method call. Although both edits are within the same function and the 'os' module might be used to work with directory paths (which could be related to the 'cwd' parameter conceptually), there is no direct, explicit code linkage between the changed lines themselves. The import statement in Edit 0 does not reference the same symbol that is being modified in Edit 1, and the method call in Edit 1 does not directly reference the 'os' import. The connection is only conceptual/thematic rather than representing a direct code dependency or synchronized substitution pattern."
        },
        {
            "sample_idx": 152,
            "yi": "0 before 1",
            "pred": "no relation",
            "pred_reason": "These edits affect different aspects of the backtesting system without direct code linkage. Edit 0 removes a line that increments row_index in the main backtesting logic (freqtrade/optimize/backtesting.py), while Edit 1 updates test assertions about cached dataframe length and adds new validation logic in the test file (tests/optimize/test_backtesting.py). Although both edits may be related to the same conceptual change (fixing an off-by-one error in data processing), the changed lines do not reference the exact same symbol. The removed 'row_index += 1' line and the test assertions about dataframe length are different code elements. The test is validating the behavior that results from the production code change, but there's no direct symbol reference between the specific lines being changed. This is a case where the relationship is thematic/conceptual rather than having explicit code dependency between the exact same symbols in the changed lines."
        },
        {
            "sample_idx": 153,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different aspects of the QaEngineer class and do not have direct code linkage. Edit 0 changes the QaEngineer constructor to accept a test_round_allowed parameter instead of hardcoding the value. Edit 1 modifies how QaEngineer is instantiated in the startup function, moving it to a conditional block but still calling it without any parameters (QaEngineer()). The changed lines do not reference the same symbol - edit 0 changes the constructor signature to accept test_round_allowed, while edit 1's changed lines only show the QaEngineer() instantiation without passing the new parameter. There is no immediate, mechanically obvious code-driven prompt between these edits at the locus of change."
        },
        {
            "sample_idx": 155,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code dependency. Edit 0 adds an import statement for 'unicode_message' from the glances_unicode module. Edit 1 reformats a function call by splitting parameters across multiple lines, involving the 'display_plugin' method call with 'stat_display' parameters. The changed lines in each edit reference entirely different symbols - the import references 'unicode_message' while the reformatting references 'display_plugin', 'stat_display', and 'get_stats_display_width'. There is no explicit code linkage between these symbols, and neither edit creates a mechanical prompt for the other. This is purely a case of two independent code changes that happen to be in the same file."
        },
        {
            "sample_idx": 156,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same identifier name 'skip_animations' but they reference different symbols in different scopes. Edit 0 adds 'skip_animations' to a configuration dictionary in the get_configuration function, referencing args.skip_animations (a command-line argument). Edit 1 modifies code that uses self.skip_animations (an instance attribute of the Scene class). While both edits involve 'skip_animations', the changed lines reference different symbols - one is args.skip_animations and the other is self.skip_animations. There is no direct code dependency or explicit linkage between these specific symbols in the changed lines themselves."
        },
        {
            "sample_idx": 157,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same configuration key 'is_legacy_optimizer' but in different contexts and classes. Edit 0 adds this key to the config dictionary in the experimental optimizer's get_config method, while Edit 1 removes this key from the config dictionary in the legacy optimizer's from_config method. However, the changed lines reference different symbols - one is adding to self's config in _BaseOptimizer.get_config(), while the other is removing from a parameter config in Optimizer.from_config(). These are different config dictionaries in different classes, even though they share the same key name. There's no direct code dependency where one edit creates an immediate prompt for the other - they appear to be part of a coordinated change to handle legacy optimizer detection, but the actual symbols (the config dictionaries) are different."
        },
        {
            "sample_idx": 159,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds an import statement for `TrinoQueryError` in the trino operators module, while Edit 1 modifies a SQL query string in a test file to add 'IF NOT EXISTS' clause. The changed lines reference completely different symbols - one references the `TrinoQueryError` exception class being imported, while the other references a SQL string literal. There is no direct code dependency, shared symbol reference, or mirrored substitution pattern between these edits. They appear to be separate changes that happen to both involve Trino-related code but have no explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 158,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 modifies a string formatting operation in the `_DebugHandler.get()` method by breaking a `self.write()` call across multiple lines. Edit 1 adds a method call `server.add_preheated_report_context()` in the `run()` function. The changed lines do not reference, assign, call, or import any shared symbols. There is no explicit code dependency, synchronized pattern, or structural relationship between reformatting a write statement and adding a server method call. The connection is purely coincidental - both happen to be in the same codebase but involve entirely different functionality."
        },
        {
            "sample_idx": 160,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural transformation: converting single-line parser.add_argument() calls into multi-line format by splitting the parameters across separate lines. This is a uniform formatting/style refactor applied to the same type of syntactic construct (parser.add_argument calls) with the exact same before\u2192after pattern (single-line \u2192 multi-line parameter formatting). Both edits are part of a single, contiguous code formatting task and either could be applied first as they are independent formatting changes that follow the same mechanical pattern."
        },
        {
            "sample_idx": 161,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 adds 'Response' to an import statement from fastapi, while Edit 1 removes a print statement about keyboard interrupts. The changed lines do not reference the same symbol - one involves importing 'Response' and the other involves removing a print call. There is no explicit code dependency, structural relationship, or mirrored substitution pattern between importing 'Response' and removing a print statement. They appear to be independent changes that happen to be in the same file but serve different purposes."
        },
        {
            "sample_idx": 162,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new method `separator_line` that calls `unicode_message('MEDIUM_LINE', self.args)` on line 544. Edit 1 adds the 'MEDIUM_LINE' key to what appears to be a unicode message dictionary. The changed line in edit 0 explicitly references the exact same symbol ('MEDIUM_LINE') that is being defined in edit 1. This creates a direct code dependency where the usage in edit 0 depends on the definition in edit 1. However, since this appears to be Python code and the reference to 'MEDIUM_LINE' would only cause a runtime KeyError (not a parse-time syntax error) if the key doesn't exist, both edits can be written and parsed in either order. The relationship is bi-directional because either edit naturally prompts the other as the next mechanical step within the same development session."
        },
        {
            "sample_idx": 164,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve changes to two different functions in the same file. Edit 0 adds a new function `external_data_workflow_exists(id: str)` that takes a string `id` parameter. Edit 1 changes the signature of `unpause_external_data_schedule` from taking an `ExternalDataSource` parameter to taking a string `id` parameter. While both edits involve string `id` parameters, they reference different symbols - the `id` parameter in the new function is a different symbol from the `id` parameter in the modified function signature. The changed lines do not reference the exact same symbol, and there is no direct code dependency between these two function changes. This appears to be part of a broader refactoring but lacks the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 163,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and are not directly linked by explicit code dependencies. Edit 0 modifies a call to `get_free_trial_days()` by adding a parameter `is_self_hosted_billing`, while Edit 1 adds a new configuration setting `SELF_HOSTING_FREE_TRIAL_DAYS`. Although they may be conceptually related to the same feature (supporting different trial periods for self-hosted vs cloud billing), the changed lines do not reference the exact same symbol. Edit 0 changes a function call, while Edit 1 adds a configuration variable. There is no direct, mechanical code linkage between these specific changes - they represent different symbols in different contexts, even though they may be part of the same logical feature implementation."
        },
        {
            "sample_idx": 165,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and contexts. Edit 0 modifies the return statement of the `init` function within the `sm3` optimizer implementation, adding `x_shape` to the returned tuple. Edit 1 renames and restructures test methods for the SM3 optimizer, changing `testSM3` to `testSM3Scalar` and adding a new `testSM3Vector` method. While both edits relate to the SM3 optimizer conceptually, the changed lines reference entirely different symbols - one modifies the implementation's return values, the other modifies test method names and structure. There is no direct code dependency or explicit symbol reference between the changed lines. The relationship is purely thematic/conceptual rather than mechanically code-driven."
        },
        {
            "sample_idx": 166,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different test methods within the same test class. Edit 0 removes the `test_enable_lora_on_unbuilt_layer` method, while Edit 1 adds a new `test_weights_constructor_arg` method. The changed lines in each edit reference entirely different symbols and functionality - one deals with LoRA (Low-Rank Adaptation) functionality testing, while the other tests weight constructor arguments. There is no direct code dependency, no shared symbols being referenced, and no mechanical prompt from one edit to the other. They are independent test method changes that happen to be in the same file but have no explicit code linkage between the changed lines themselves."
        },
        {
            "sample_idx": 168,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern within the same method. They both change function calls by replacing 'cond_scale' with 'cond_scale * self.cond_scale_miltiplier' as a parameter. This is a uniform find-and-replace operation targeting the same syntactic construct (function call parameters) with the exact same before\u2192after pattern, occurring within a single method context. This represents a bulk edit where both changes are part of the same contiguous refactoring task - applying the same multiplier transformation to all instances of cond_scale usage in parameter positions within this method."
        },
        {
            "sample_idx": 167,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions and different symbols. Edit 0 adds an 'is_self_hosted_billing' parameter to the 'compute_plan_parameters' function signature, while Edit 1 modifies a call to 'get_free_trial_days' function by adding a 'False' argument. The changed lines reference completely different symbols - 'compute_plan_parameters' vs 'get_free_trial_days'. There is no direct code dependency, shared symbol reference, or structural synchronization between these edits. They appear to be part of different micro-tasks within the same broader feature work, but lack the explicit code linkage required for neighbor classification."
        },
        {
            "sample_idx": 169,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are operating on completely different test methods within the same test class. Edit 0 removes the `test_quantize_on_unbuilt_layer` method, while Edit 1 adds a new `test_weights_constructor_arg` method in a different location in the file. The changed lines do not reference the same symbols - they are modifying entirely different test methods with different purposes (one about quantization, one about weights constructor). There is no explicit code linkage, dependency, or structural relationship between removing one test method and adding another unrelated test method. This appears to be part of a broader test suite refactoring where multiple independent changes are being made, but the specific edits themselves have no direct code-driven relationship."
        },
        {
            "sample_idx": 170,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are not related by any direct code dependency or structural linkage. Edit 0 adds 'Response' to the import statement from fastapi, while Edit 1 adds a print statement in a server stop condition. The changed lines do not reference the same symbol - Edit 0 imports 'Response' but Edit 1 only adds a print statement that doesn't use 'Response' or any symbol from Edit 0. There is no explicit code linkage, no mirrored substitution pattern, and no immediate mechanical prompt between these edits. They appear to be separate, unrelated changes that happen to be in the same file."
        },
        {
            "sample_idx": 171,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits do not reference the same symbol or have any direct code linkage. Edit 0 changes the signature of the `new_line` method by adding a `separator` parameter. Edit 1 removes a comment line in a completely different method (`__display_header`). The changed lines do not reference, call, assign, or import the same symbol. There is no explicit code dependency between removing a comment and adding a parameter to an unrelated method. This is purely coincidental - both edits happen to be in the same file but affect different parts of the code with no mechanical relationship."
        },
        {
            "sample_idx": 172,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they implement a synchronized feature where edit 1 adds the 'is_legacy_optimizer' key to the config dictionary in the get_config method, and edit 0 adds code to check for and use that exact same 'is_legacy_optimizer' key from the config. The changed lines reference the same dictionary key 'is_legacy_optimizer' - one edit produces it in the config, the other consumes it. This creates an immediate code-driven relationship where either edit naturally prompts the need for the other to complete the feature implementation. Both edits can be staged in either order without parse errors, making this bi-directional rather than ordered."
        },
        {
            "sample_idx": 173,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve adding the same parameter name 'is_legacy_optimizer' to different contexts, but they reference different symbols in different scopes. Edit 0 adds this key-value pair to a test configuration dictionary within a test method, while Edit 1 adds it to the get_config method of the Optimizer class in production code. The changed lines don't reference the exact same symbol - they are adding the same string key to completely different dictionaries in different classes and files. There is no direct code dependency or explicit linkage between these specific changed lines, even though they may be conceptually related to distinguishing legacy vs non-legacy optimizers. This is a case of same name, different symbols/contexts."
        },
        {
            "sample_idx": 174,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different files and different symbols. Edit 0 adds a call to `connection.connect()` in the `create.py` file, while Edit 1 adds an import statement `from django.db import connection` in the `delete.py` file. Although both involve the `connection` symbol, they are in completely different files and contexts. The `connection` being imported in `delete.py` is not the same symbol being used in `create.py` - they are different instances of the Django database connection in separate modules. There is no direct code dependency between these changed lines, and no immediate mechanical prompt from one edit to the other. This appears to be coincidental usage of the same Django API in different files rather than a synchronized change to the exact same symbol."
        },
        {
            "sample_idx": 176,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits add identical import statements ('from django.db import connection') to different files. While this appears to be part of a bulk addition pattern, these are different files with different contexts, and there is no direct code dependency between the changed lines themselves. The edits reference the same import statement but in completely separate contexts - one in common.py and one in create.py. There is no explicit code linkage where making one edit creates an immediate, mechanically obvious prompt for the other. This is a thematic/conceptual relationship (both files need the same import) rather than a direct code dependency between the exact same symbol references in the changed lines."
        },
        {
            "sample_idx": 175,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes a method call from 'self._test_error_exc_info()' to '_test_error_exc_info()', removing the 'self.' prefix to reference a module-level function instead of an instance method. Edit 1 removes the definition of the '_test_error_exc_info' function entirely. After edit 1 is applied, the code in edit 0 would fail at runtime with a NameError because '_test_error_exc_info()' would be undefined. However, both edits can be written and parsed in either order - the issue is only a runtime error, not a parse-time syntax error. In Python, referencing an undefined function is allowed at parse time. Since both edits reference the exact same symbol '_test_error_exc_info' and either edit creates an immediate prompt for the other (defining it after calling it, or removing the call after removing the definition), this represents a bi-directional relationship where both edits are part of the same micro-task of cleaning up this function."
        },
        {
            "sample_idx": 177,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 modifies a function call to `pause_external_data_schedule` by changing the argument from `job.pipeline` to `str(job.pipeline.id)`. Edit 1 removes an import of `aget_schema_by_id` from a different file. The changed lines reference entirely different symbols - one involves the `pause_external_data_schedule` function and `job.pipeline`, while the other involves the `aget_schema_by_id` import. There is no explicit code dependency, shared symbol reference, or structural relationship between these changes. They appear to be independent cleanup or refactoring operations."
        },
        {
            "sample_idx": 178,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits modify the return statements of functions within the same sm3 optimizer implementation to add the same new element 'x_shape' to their return tuples. The init function returns the initial state tuple and the update function returns the updated state tuple - these must have matching structures since the output of init becomes input to update, and update's output feeds back as state in subsequent calls. Adding x_shape to one return statement without adding it to the other would break the state tuple structure contract between these functions. This creates a direct structural dependency where both changes must be made together as part of the same micro-task to maintain the optimizer's state consistency."
        },
        {
            "sample_idx": 181,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different symbols and functionality. Edit 0 adds a command-line argument '--separator' to the argument parser in main.py, while Edit 1 adds an import statement for 'unicode_message' from a Unicode module in the curses output file. The changed lines reference entirely different symbols ('enable_separator' argument vs 'unicode_message' import) and there is no direct code dependency, structural relationship, or synchronized pattern between them. They appear to be separate, unrelated changes that happen to be part of the same codebase but serve different purposes."
        },
        {
            "sample_idx": 179,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols despite similar naming. Edit 0 adds a 'vcs_rev' parameter to the init_env function signature. Edit 1 uses 'args.vcs_rev' (accessing the vcs_rev attribute from an args object) within the build_static_kittens function. While both involve VCS revision handling, the changed lines reference different symbols: the parameter 'vcs_rev' in init_env versus the attribute access 'args.vcs_rev' in build_static_kittens. There is no direct code dependency between these specific changed lines - they don't reference the exact same symbol."
        },
        {
            "sample_idx": 180,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and functionality. Edit 0 adds a command-line argument '--separator' with destination 'enable_separator' in the argument parser. Edit 1 modifies display logic for cloud statistics in the curses output module, adding a conditional check around cloud display. There is no explicit code linkage between the changed lines - they don't reference the same symbol, function, variable, or import. The edits are in different files, different classes, and involve different aspects of the codebase (argument parsing vs display logic). While both might conceptually relate to UI improvements, there is no direct, mechanical code dependency or synchronized substitution pattern between the specific lines that were changed."
        },
        {
            "sample_idx": 184,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the codebase. Edit 0 modifies the `load_unet_state_dict` function to add conditional logic for a `dtype` parameter, while Edit 1 modifies the `load_unet` method in the `UNETLoader` class to add a `weight_dtype` parameter. Although both edits relate to dtype handling in UNET loading functionality, the changed lines reference completely different symbols: Edit 0 references a `dtype` parameter and `unet_dtype` variable within `load_unet_state_dict`, while Edit 1 references a `weight_dtype` parameter within the `UNETLoader.load_unet` method. There is no direct code dependency between these specific symbols - they are different parameters in different functions. The relationship is conceptual/thematic (both relate to dtype handling) but lacks the explicit, immediate code linkage required for neighbour classification."
        },
        {
            "sample_idx": 183,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve changes to completely different parts of the codebase with no direct code linkage. Edit 0 removes a 'preview' key assignment in a configuration dictionary in manimlib/config.py, while Edit 1 modifies the stop_skipping method implementation in manimlib/scene/scene.py by changing how skip_animations is handled and adding a virtual_animation_start_time assignment. The changed lines reference entirely different symbols and variables - there is no shared symbol, function call, import, or structural dependency between removing a 'preview' configuration key and modifying animation skipping logic. These appear to be independent changes that may be part of the same feature but lack the explicit, immediate code-driven linkage required for neighbour classification."
        },
        {
            "sample_idx": 182,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Edit 0 modifies the _newnames function to add duplicate field name detection, raising a ValueError with 'duplicate field name' message when a duplicate is found. Edit 1 adds a test that specifically checks for this new duplicate detection behavior by calling sort() with duplicate field names and asserting that it raises a ValueError containing 'duplicate'. While these edits are conceptually related (one implements duplicate detection, the other tests it), they reference different symbols - Edit 0 modifies the _newnames function while Edit 1 tests the sort method. The changed lines don't reference the exact same symbol, and there's no direct code dependency between the specific lines that were modified. This is a test-implementation relationship but not at the level of the exact same symbol being modified and tested."
        },
        {
            "sample_idx": 185,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits are updating calls to the same function `get_free_trial_days()` to include a parameter. Edit 0 changes the call from `get_free_trial_days()` to `get_free_trial_days(is_self_hosted_billing)` where `is_self_hosted_billing` is a boolean variable. Edit 1 changes the call from `get_free_trial_days()` to `get_free_trial_days(True)`. This represents a uniform substitution pattern where the same function signature change is being applied across multiple call sites - both edits are updating calls to the exact same function symbol `get_free_trial_days` by adding a boolean parameter. This is a classic bulk refactoring pattern where a function signature has been changed and all call sites need to be updated accordingly. Both edits reference the exact same symbol and perform structurally identical updates (adding a boolean parameter to the function call)."
        },
        {
            "sample_idx": 188,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports `__version__` from the current package (`. import __version__`), and Edit 1 uses this exact same `__version__` symbol in a dictionary assignment (`\"diffusers\": __version__`). The changed lines reference the exact same symbol - the `__version__` that is imported in Edit 0 and used in Edit 1. This creates an immediate code dependency where importing the symbol naturally prompts its usage, and using the symbol requires its import. Both edits can be staged in either order in Python (the usage before import would only cause a runtime NameError, not a parse error), making this a bi-directional relationship."
        },
        {
            "sample_idx": 186,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and contexts. Edit 0 adds 'self.acl = acl' to the GCSFeedStorage constructor, referencing a parameter 'acl' that should exist in the constructor signature. Edit 1 modifies test settings to include 'FEED_STORAGE_GCS_ACL': 'publicRead'. While both relate to ACL functionality, the changed lines reference different symbols: edit 0 references a constructor parameter 'acl', while edit 1 references a settings dictionary key 'FEED_STORAGE_GCS_ACL'. There is no direct code dependency between these specific changed lines - they are part of the same feature but don't reference the exact same symbol."
        },
        {
            "sample_idx": 189,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes a method call from `self._test_error_exc_info()` to `_test_error_exc_info()` (removing the 'self.' prefix), while Edit 1 removes the definition of the `_test_error_exc_info` method entirely. These edits reference the exact same symbol (`_test_error_exc_info`). After Edit 1 removes the method definition, Edit 0's change to call the now-undefined function would result in a NameError at runtime. However, since Python allows referencing undefined symbols at parse time (only failing at runtime), both edits can be written and staged in either order without causing parser errors. The relationship is bi-directional because either edit creates an immediate, code-driven prompt for the other as the next step."
        },
        {
            "sample_idx": 187,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits show a clear definition-usage relationship for the exact same symbol 'external_data_workflow_exists'. Edit 1 defines the function 'external_data_workflow_exists' in posthog/warehouse/data_load/service.py, while Edit 0 uses this function in posthog/warehouse/api/external_data_schema.py (line 35). The changed lines reference the same symbol - Edit 0's line 35 calls 'external_data_workflow_exists(str(instance.id))' and Edit 1's line 113 defines 'def external_data_workflow_exists(id: str) -> bool:'. This is a cross-file definition-usage pattern where both edits appear to be part of the same development session introducing a new function and immediately using it. In Python, both edits can be written and parsed in either order (the usage would only fail at import/runtime, not at parse time), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 190,
            "yi": "1 before 0",
            "pred": "bi-directional",
            "pred_reason": "These edits represent a cut-and-paste move operation of the exact same function `_test_error_exc_info()`. Edit 1 removes the function from inside the `RemoteTestResultTest` class (lines 77-81), while Edit 0 adds the identical function at module level (lines 17-21). This is a classic move operation where the function must be removed from its original location before or after being added to the new location. However, since both edits can be staged independently without causing parse errors (the function can exist in both locations simultaneously, or be missing from one while present in the other), and either edit naturally prompts the other as the next step to complete the move operation, this is bi-directional rather than ordered."
        },
        {
            "sample_idx": 192,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different files and contexts - one adds a comment explaining data handling logic in the main backtesting implementation, while the other adds a conditional check in a test function. While both relate to data processing concepts, they don't reference the same symbols, functions, or variables. The changed lines don't have any direct code dependency or explicit linkage. Edit 0 adds documentation about row handling, while Edit 1 adds a safety check for the 'tres' parameter. There is no immediate, mechanically obvious prompt from one edit to the other, and they could be made independently without any code-driven necessity for the other."
        },
        {
            "sample_idx": 191,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits are updating calls to the same function `get_free_trial_days()` by adding a parameter. In edit 0, the function call is changed from `get_free_trial_days()` to `get_free_trial_days(is_self_hosted_billing)`, and in edit 1, it's changed from `get_free_trial_days()` to `get_free_trial_days(True)`. This represents a bulk edit pattern where the same function signature change is being applied across multiple call sites. Both edits reference the exact same symbol (`get_free_trial_days`) and perform an identical structural substitution (adding a parameter to the function call). This would typically be part of a single, contiguous refactoring task where a function signature was changed and all call sites need to be updated accordingly. Either edit could be made first, and both are mechanically required updates to the same function calls."
        },
        {
            "sample_idx": 194,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add break conditions to the same while loop structure, but they check different conditions and serve different purposes. Edit 0 adds a check for `tty.wait_till_read_available()` before reading data, while Edit 1 adds a check for empty data after reading. These are independent guard conditions that don't reference the same symbols or create direct code dependencies between each other. The changes are conceptually related (both are loop exit conditions) but there's no explicit code linkage where one edit's changed lines reference the same symbol as the other edit's changed lines. They can be applied in either order without creating syntax errors or direct mechanical prompts for each other."
        },
        {
            "sample_idx": 193,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits reference the exact same symbol 'is_legacy_optimizer' and are directly related through a definition-usage pattern. Edit 0 adds 'is_legacy_optimizer': False to a configuration dictionary in the optimizer's get_config() method. Edit 1 adds code to handle the absence of this same 'is_legacy_optimizer' key in test configuration comparison logic. The test code is specifically designed to handle the new configuration key that was added in edit 0. Both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step - adding the config key requires updating the test to handle it, and the test handling implies the config key exists. This represents a bi-directional definition-usage relationship where both edits can be staged in either order without parse errors."
        },
        {
            "sample_idx": 195,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different types of changes. Edit 0 adds 'schedule_exists' to what appears to be an import list or parameter list, while Edit 1 changes the parameter signature of the function 'pause_external_data_schedule' from 'external_data_source: ExternalDataSource' to 'id: str'. There is no direct code linkage between these changes - they don't reference the same symbol, and neither edit creates an immediate mechanical prompt for the other. The 'schedule_exists' being imported/added in Edit 0 is not the same as changing a function parameter type in Edit 1. These appear to be separate changes that happen to be in the same file but don't have explicit code dependency."
        },
        {
            "sample_idx": 198,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different aspects of the Trino codebase and reference different symbols. Edit 0 adds a line to assign `cur.stats[\"queryId\"]` to `self.query_id` within the `run` method of the `TrinoHook` class - this is modifying the hook's internal state tracking. Edit 1 modifies a SQL string in a test file to add 'IF NOT EXISTS' to a CREATE TABLE statement within a `TrinoOperator` configuration. The changed lines reference entirely different symbols: Edit 0 references the `query_id` attribute and cursor stats, while Edit 1 references a SQL string literal. There is no direct code dependency, shared symbol reference, or synchronized substitution pattern between these edits. They are conceptually related to the Trino provider but have no explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 196,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits reference the exact same symbol 'is_legacy_optimizer' within config dictionaries, but they serve different purposes and there is no direct code dependency between them. Edit 0 adds logic to check for and use 'is_legacy_optimizer' from a config during deserialization, while Edit 1 adds logic to remove 'is_legacy_optimizer' from a config during testing when it's not present in the original config. While both edits handle the same configuration key, they are in different files (production code vs test code), serve different logical purposes (using vs cleaning up the field), and neither edit creates an immediate, mechanically obvious prompt for the other. The test code is not directly testing the specific deserialization logic added in Edit 0, but rather appears to be doing general config comparison cleanup. There is no explicit code linkage where making one edit creates a direct syntactic or structural prompt for the other as the next contiguous action."
        },
        {
            "sample_idx": 199,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits handle the 'is_legacy_optimizer' key in configuration dictionaries, but they operate on different symbols in different contexts. Edit 0 removes 'is_legacy_optimizer' from a config parameter in the Adagrad.from_config method, while Edit 1 conditionally removes 'is_legacy_optimizer' from new_config['config'] in a test method. The changed lines reference different config objects (config vs new_config['config']) in completely different scopes and files. There is no direct code dependency or explicit symbol linkage between these edits - they are conceptually related cleanup operations but reference different symbols."
        },
        {
            "sample_idx": 201,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits handle the same configuration key 'is_legacy_optimizer' but in different contexts and files. Edit 0 reads this key from config['config']['is_legacy_optimizer'] in the deserialize function, while Edit 1 removes this key from config['is_legacy_optimizer'] in the from_config method. However, these are different symbols - one accesses config['config']['is_legacy_optimizer'] and the other accesses config['is_legacy_optimizer']. The changed lines reference different nested paths in the configuration structure, making them different symbols despite the similar key name. There is no direct code dependency where one edit's changed lines reference the exact same symbol as the other edit's changed lines."
        },
        {
            "sample_idx": 200,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols despite having similar variable names. Edit 0 removes a line that assigns `unet_dtype` from a function call at line 578, while Edit 1 modifies a different assignment to `unet_dtype` at line 605 by wrapping it in conditional logic. Although both edits involve variables named `unet_dtype`, they are different symbols in different scopes within the same function - they are separate variable assignments that happen at different points in the execution flow. The changed lines do not reference the exact same symbol, and there is no direct code dependency between the removal in Edit 0 and the conditional modification in Edit 1. The relationship appears to be part of a broader refactoring but lacks the immediate, mechanically obvious code-driven linkage required for neighbour classification."
        },
        {
            "sample_idx": 202,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add the same line 'acl = 'publicRead'' or 'assert storage.acl == 'publicRead'' within the same test class (GCSFeedStorageTest) but in different test methods. Edit 0 adds an assertion for the acl attribute in test_parse_settings, while Edit 1 adds an acl variable assignment in test_store. These appear to be part of adding ACL support to the GCS feed storage functionality - one test verifies that ACL settings are parsed correctly, and another test sets up ACL for the store operation. However, the changed lines reference different symbols: Edit 0 references 'storage.acl' (an attribute) while Edit 1 references 'acl' (a local variable). Even though they're conceptually related and part of the same feature addition, they don't reference the exact same symbol and there's no direct code dependency between the changed lines themselves."
        },
        {
            "sample_idx": 203,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols despite both involving 'time'. Edit 0 changes a line that calls 'time.time()' in lib/request/inject.py, while Edit 1 adds 'import time' to lib/utils/resume.py. The changed lines reference different time symbols in different files - the time module being imported in resume.py is not the same symbol as the time module already being used in inject.py (which must have its own import elsewhere). There is no direct code dependency between these specific changed lines, and they appear to be separate, unrelated modifications to different parts of the codebase."
        },
        {
            "sample_idx": 204,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits involve assertions about the length of analyzed dataframes returned by backtesting.dataprovider.get_analyzed_dataframe(), but they are testing different scenarios in separate test functions. Edit 0 is in test_backtest_alternate_buy_sell() and tests the UNITTEST/BTC pair with 1m timeframe, while Edit 1 is in test_backtest_multi_pair() and tests the NXT/BTC pair with 5m timeframe. Although both use the same method call pattern, they reference different symbols (different pairs and timeframes) and are part of independent test cases. There is no direct code dependency or explicit linkage between the changed lines - they are conceptually related as both test backtesting functionality, but the exact same symbol is not being referenced in both edits."
        },
        {
            "sample_idx": 197,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a 'query_id' attribute to the TrinoHook class in the production code, while Edit 1 modifies a SQL statement in a test file to add 'IF NOT EXISTS' to a CREATE TABLE statement. These edits reference completely different symbols and code elements - one is adding a class attribute in the hook implementation, while the other is modifying SQL syntax in a test configuration. There is no direct code dependency, no shared symbol reference, and no explicit linkage between the changed lines. The edits are in different files, affect different types of code constructs (class attribute vs SQL string), and serve different purposes (adding functionality vs making tests more robust). This is purely a conceptual relationship at best, not a mechanical code dependency."
        },
        {
            "sample_idx": 205,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference the same attribute name 'traceback' but on completely different objects in different contexts. Edit 0 accesses 'traceback' on a 'ret_value' object within an error handling method, while Edit 1 defines a 'traceback' attribute on a new 'ExcInfo' class. Despite the identical attribute name, these are different symbols in different scopes - ret_value.traceback vs self.traceback on ExcInfo instances. There is no direct code dependency or explicit linkage between the changed lines themselves, only a coincidental use of the same attribute name."
        },
        {
            "sample_idx": 208,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of user_agent handling. Edit 0 modifies the structure/content of a user_agent dictionary by adding a 'diffusers' key with __version__ value in the FlaxModelMixin class. Edit 1 adds a user_agent parameter to a snapshot_download function call in the DiffusionPipeline class. While both edits relate to user_agent functionality, they reference different user_agent variables in different scopes and classes. The changed lines do not reference the exact same symbol - one modifies the contents of a user_agent dict in one class, while the other passes a user_agent parameter to a function call in a different class. There is no direct code dependency or explicit linkage between these specific changed lines."
        },
        {
            "sample_idx": 206,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same code flow within the same function, but they address different aspects of the TTYIO usage. Edit 0 modifies the TTYIO constructor call to add a parameter 'read_with_timeout=False', while Edit 1 adds a data validation check after the os.read() call. While both edits are part of improving the same pipe() function's behavior, the changed lines reference different symbols and operations - Edit 0 changes the TTYIO constructor call, while Edit 1 adds logic to handle the 'data' variable returned by os.read(). There is no direct code dependency between the specific lines changed - neither edit creates an immediate, mechanically obvious prompt for the other. The TTYIO parameter change doesn't directly necessitate the data check, and the data check doesn't require the parameter change. These appear to be separate improvements to the same function rather than interdependent code changes."
        },
        {
            "sample_idx": 207,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes a call to TTYIO() constructor to pass a parameter `read_with_timeout=False`, while Edit 1 modifies the TTYIO class's __enter__ method to use `self.read_with_timeout` instead of the hardcoded `True` value. These edits reference the exact same symbol (the TTYIO class and its read_with_timeout parameter) and form a definition-usage relationship. Edit 0 introduces the parameter usage at the call site, and Edit 1 implements the corresponding handling of that parameter within the class. Either edit can be made first without causing parse errors - the call site can pass the parameter before the implementation uses it (would just be ignored), and the implementation can reference self.read_with_timeout before any call site passes it (would use default value). This creates a bi-directional relationship where making either edit creates an immediate, mechanically obvious prompt for the other as the next step to complete the parameter threading."
        },
        {
            "sample_idx": 210,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve different aspects of the Trino codebase with no direct code linkage. Edit 0 adds a new `on_kill` method to the `TrinoOperator` class that handles query termination, while Edit 1 modifies a SQL statement in a test file to use 'CREATE TABLE IF NOT EXISTS' instead of 'CREATE TABLE'. The changed lines reference completely different symbols and contexts - Edit 0 introduces new functionality for query management using `self.hook.run()` and `self.hook.query_id`, while Edit 1 simply modifies a SQL string literal in a test case. There is no explicit code dependency, no shared symbol references, and no immediate mechanical prompt from one edit to the other. They are conceptually related to Trino operations but lack the direct, explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 209,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits involve the exact same symbol - the GCSFeedStorage constructor. Edit 0 changes the constructor call in the from_crawler method to include a third parameter (FEED_STORAGE_GCS_ACL), while edit 1 updates a test that creates a GCSFeedStorage instance to also include the third parameter (acl). Both changed lines reference the same constructor signature, and after making either edit, the other becomes immediately necessary to maintain consistency - if you add the parameter to the from_crawler call without updating the test, the test would fail due to argument mismatch, and vice versa. This is a classic signature-caller synchronization pattern where both edits reference the exact same symbol (GCSFeedStorage constructor) and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 211,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats argument parser code in main.py by splitting a single line into multiple lines for better readability, while Edit 1 adds new Unicode character mappings to a dictionary in a different file (glances_unicode.py). The edits involve different files, different functionality, and different symbols - there is no shared symbol, import, function call, or any direct code dependency between the changed lines. This is purely coincidental editing that may have happened in the same development session but lacks any mechanical code-driven relationship."
        },
        {
            "sample_idx": 212,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits modify user_agent dictionaries by adding the same 'diffusers': __version__ key-value pair, but they are occurring in different classes (ModelMixin vs DiffusionPipeline), different methods (though both are from_pretrained), and different files. While the pattern of adding version information to user_agent dictionaries is identical, the changed lines reference different user_agent variables in different scopes - they are different symbols despite having the same name. There is no direct code dependency between these specific user_agent dictionaries, and no explicit cross-reference between the changed lines. This appears to be a coordinated refactoring to add version tracking across multiple components, but the relationship is conceptual/thematic rather than a direct code linkage."
        },
        {
            "sample_idx": 215,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 1 adds an import statement `from . import __version__` at the top of pipeline_utils.py, while Edit 0 uses `__version__` in a user_agent dictionary within modeling_flax_utils.py. These edits reference different symbols despite having the same name '__version__'. The __version__ imported in pipeline_utils.py is a different symbol from any __version__ that might be used in modeling_flax_utils.py, as they are in different files with different import contexts. There is no explicit code linkage between the changed lines - the import in Edit 1 does not directly enable or relate to the usage in Edit 0, as they operate on different symbols in different scopes."
        },
        {
            "sample_idx": 214,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the 'operator' module, and Edit 1 uses that exact same 'operator' module in the changed lines by calling operator.methodcaller(). This creates a direct import-usage relationship where both edits reference the exact same symbol 'operator'. In Python, using an undefined import results in a NameError at runtime, not a parse error, so both edits can be written and parsed in either order. After making either edit, the other becomes the immediate, mechanically obvious next step - either importing the module that's being used, or using the module that was just imported. This fits the bi-directional pattern for import-usage within the same file."
        },
        {
            "sample_idx": 213,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits affect the same function `load_unet_state_dict` but reference different symbols. Edit 0 adds a `dtype=None` parameter to the function signature, while Edit 1 removes a line that assigns `model_management.unet_dtype(model_params=parameters)` to a local variable `unet_dtype`. The changed lines do not reference the exact same symbol - Edit 0 introduces a new parameter `dtype` while Edit 1 removes usage of a completely different symbol `unet_dtype` (which comes from a function call, not the parameter). Although these edits may be conceptually related (both dealing with dtype handling), there is no direct code dependency or reference to the exact same symbol between the changed lines."
        },
        {
            "sample_idx": 216,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file (metagpt/roles/qa_engineer.py) and both modify the QaEngineer class, but they affect completely different aspects of the class with no direct code dependency between them. Edit 0 adds a comment to an existing line in the __init__ method about the _init_actions call, while Edit 1 removes the recv method definition entirely. There is no explicit code linkage between these changes - the comment addition doesn't reference the recv method, and the recv method removal doesn't affect the _init_actions call or its comment. The changed lines reference different symbols and code constructs, with no shared variables, function calls, or structural dependencies. While both edits modify the same class, this represents only a conceptual/thematic relationship rather than a direct, mechanically obvious code-driven prompt for one edit to follow the other."
        },
        {
            "sample_idx": 218,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve adding the same parameter name 'is_legacy_optimizer' to different contexts - one in a test configuration dictionary and another in a production optimizer configuration method. However, they reference different symbols in different scopes: the test edit adds to a local test dictionary while the production edit adds to the get_config method of OptimizerV2 class. The changed lines do not reference the exact same symbol, and there is no direct code dependency between them. This appears to be a coordinated feature addition across test and production code, but the relationship is conceptual/thematic rather than involving explicit code linkage between the same symbol."
        },
        {
            "sample_idx": 217,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a function `_test_error_exc_info()` at the module level, while Edit 1 changes a call from `self._test_error_exc_info()` to `_test_error_exc_info()`. Both edits reference the exact same symbol `_test_error_exc_info`, but they are not creating a definition-usage relationship. Instead, Edit 1 is changing from calling an instance method to calling the module-level function that was defined in Edit 0. This appears to be a refactoring where the function was moved from being an instance method to a module-level function. Since both edits can be staged in either order (the old method call would just fail at runtime, not at parse time in Python), and both reference the same symbol as part of a coordinated refactoring, this is bi-directional."
        },
        {
            "sample_idx": 219,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 adds an import for 'timedelta' from the datetime module at the file level. Edit 1 modifies logic within a specific test function to add a conditional check before slicing data, using the 'tres' parameter. The changed lines do not reference the same symbol - edit 0 introduces 'timedelta' while edit 1 works with 'tres', 'data', and 'pair'. There is no explicit dependency where one edit creates an immediate, mechanically obvious prompt for the other. The import of 'timedelta' does not directly relate to the conditional logic being added around the data slicing operation."
        },
        {
            "sample_idx": 220,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports four functions (external_data_workflow_exists, sync_external_data_job_workflow, pause_external_data_schedule, unpause_external_data_schedule) from posthog.warehouse.data_load.service. Edit 1 uses all four of these exact same imported functions in the update method implementation. The changed lines in edit 1 directly reference the symbols that are imported in edit 0's changed lines. This creates an immediate code dependency where edit 1 cannot be executed without the imports from edit 0, but both edits can be written and parsed in either order (Python allows referencing undefined symbols at parse time, with errors only occurring at runtime/import time). After making either edit, the other becomes the mechanically obvious next step to complete the functionality."
        },
        {
            "sample_idx": 221,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours because they reference different symbols despite both being related to GCS functionality. Edit 0 modifies the `from_crawler` method in the production code to add a new parameter `crawler.settings['FEED_STORAGE_GCS_ACL']` to the constructor call. Edit 1 adds a local variable `acl = 'publicRead'` in a test method. While both edits are conceptually related to ACL (Access Control List) functionality for GCS, the changed lines reference completely different symbols: Edit 0 references the settings key 'FEED_STORAGE_GCS_ACL' within a constructor call, while Edit 1 creates a new local variable 'acl' in a test context. There is no direct code dependency or explicit symbol linkage between these specific changes - they are different symbols in different scopes (production method vs test method). The relationship is purely conceptual/thematic rather than based on direct code linkage."
        },
        {
            "sample_idx": 222,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of the UNET loading system but do not have direct code linkage between the exact same symbols. Edit 0 removes a line that calculates `unet_dtype` within the `load_unet_state_dict` function, while Edit 1 modifies a call to `comfy.sd.load_unet` by adding a `dtype=weight_dtype` parameter. Although both edits relate to UNET dtype handling, they reference different functions (`load_unet_state_dict` vs `load_unet`) and different variables (`unet_dtype` vs `weight_dtype`). The changed lines do not reference, assign, call, or import the exact same symbol. This appears to be a refactoring where dtype handling is being moved or restructured, but the edits themselves lack the direct, explicit code dependency required for neighbour classification."
        },
        {
            "sample_idx": 223,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new symbol 'viewkeys' by assigning it to operator.methodcaller('viewkeys'), and Edit 1 uses that exact same symbol 'viewkeys' in a function call. The changed line in Edit 1 directly references the symbol that was defined in Edit 0. This creates an immediate code dependency where defining 'viewkeys' naturally prompts its usage, and using 'viewkeys' requires its prior definition. However, since Python allows referencing undefined names at parse time (they only fail at runtime), both edits can be written and parsed in either order - the relationship is bi-directional rather than ordered."
        },
        {
            "sample_idx": 224,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different files, functions, and symbols. Edit 0 removes code related to schema model checking and `should_sync` logic in an external data job workflow function. Edit 1 changes a parameter from `str(external_data_source.id)` to `id` in a schedule unpausing function. There is no shared symbol, function, variable, or direct code dependency between the changed lines. The edits are in different files (`posthog/temporal/data_imports/external_data_job.py` vs `posthog/warehouse/data_load/service.py`), different functions (`check_schedule_activity` vs `unpause_external_data_schedule`), and the changed lines reference entirely different symbols (`schema_model`, `should_sync` vs `external_data_source.id`, `id`). While both may be conceptually related to external data processing, there is no explicit, immediate code linkage between the exact symbols being modified."
        },
        {
            "sample_idx": 226,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits show a classic function signature change followed by a call-site update for the exact same method. Edit 0 adds an 'update' parameter with default value True to the pull_path method definition. Edit 1 updates a call to that same pull_path method to pass the 'update' parameter. Both edits reference the exact same symbol (pull_path method) and the exact same parameter name (update). After making either edit, the other becomes the immediate next step to maintain consistency between the method signature and its usage. Since Python allows both edits to be parsed and staged in either order (the default parameter makes the signature backward compatible), this is bi-directional rather than ordered."
        },
        {
            "sample_idx": 225,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 introduces a variable 'start' that captures the current time, and Edit 1 references this exact same variable 'start' in a calculation (time.time() - start). The changed lines reference the exact same symbol 'start' - Edit 0 assigns to it and Edit 1 uses it. This creates an immediate, mechanically obvious code dependency where defining 'start' in Edit 0 prompts its usage in Edit 1 as the next contiguous action within the same micro-task of adding timing measurement to the function. While Edit 1 could technically be parsed before Edit 0 (resulting in a runtime NameError rather than a syntax error), both edits reference the same symbol and either naturally prompts the other as the next mechanical step in implementing the timing feature."
        },
        {
            "sample_idx": 227,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds AWS_REGION_US_EAST_1 to an import statement in config.py, while Edit 1 adds an import for get_handler_file_from_name in a different file (template_deployer.py). The changed lines reference entirely different symbols - AWS_REGION_US_EAST_1 in one case and get_handler_file_from_name in the other. There is no direct code dependency, no shared symbol reference, and no mechanical prompt from one edit to the other. They appear to be independent changes that happen to both involve import statements but target different symbols in different files."
        },
        {
            "sample_idx": 229,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits both handle the 'is_legacy_optimizer' key in configuration dictionaries, but they reference different config objects in completely different contexts. Edit 0 removes 'is_legacy_optimizer' from a config parameter in the from_config class method of _BaseOptimizer, while Edit 1 conditionally removes 'is_legacy_optimizer' from new_config['config'] in a test method. The changed lines do not reference the exact same symbol - they operate on different config dictionaries (config vs new_config['config']) in different scopes (production code vs test code). While both edits deal with the same key name, they are handling different configuration objects and there is no direct code dependency or explicit symbol linkage between the changed lines."
        },
        {
            "sample_idx": 230,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are unrelated. Edit 0 adds a constant AWS_REGION_US_EAST_1 in constants.py, while Edit 1 adds an import for get_handler_file_from_name in template_deployer.py. The changed lines do not reference the same symbol - one defines a region constant and the other imports a lambda-related function. There is no direct code dependency, explicit symbol linkage, or synchronized pattern between these edits. They appear to be part of different development tasks with no immediate, mechanically obvious connection."
        },
        {
            "sample_idx": 228,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are within the same function `get_configuration(args)` but they modify different parts of the configuration dictionary without any direct code dependency between them. Edit 0 adds a 'preview' key to the config dictionary, while Edit 1 removes the 'skip_animations' key assignment. The changed lines do not reference the same symbol - they involve different dictionary keys ('preview' vs 'skip_animations') and different variables ('write_file' vs 'args.skip_animations', 'args.start_at_animation_number'). There is no explicit code linkage where making one edit creates an immediate, mechanically obvious prompt for the other. Both edits can be made independently without referencing the same symbols in their changed lines."
        },
        {
            "sample_idx": 231,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol AWS_REGION_US_EAST_1. Edit 0 imports this symbol from constants, while edit 1 uses this imported symbol to replace a hardcoded string value. This creates a direct code dependency where the import in edit 0 makes the symbol available for use in edit 1. However, in Python, both edits can be written and parsed in either order - if edit 1 were applied first, it would only cause a runtime NameError when executed, not a parse-time syntax error. Since both edits can be staged in either order and both reference the same symbol as part of what appears to be a single refactoring task (replacing hardcoded 'us-east-1' with a named constant), this is a bi-directional relationship."
        },
        {
            "sample_idx": 232,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and different function calls. Edit 0 modifies a call to `optimizers.deserialize()` by adding a `use_legacy_optimizer=False` parameter. Edit 1 modifies a different function that calls `learning_rate_schedule.deserialize()` and adds logic to handle an `is_legacy_optimizer` config key. While both edits are conceptually related to legacy optimizer handling, the changed lines reference completely different symbols - `optimizers.deserialize` vs `learning_rate_schedule.deserialize`, and different config keys - `use_legacy_optimizer` vs `is_legacy_optimizer`. There is no direct code dependency or explicit symbol linkage between the changed lines themselves."
        },
        {
            "sample_idx": 233,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the `timedelta` symbol from the datetime module, and Edit 1 uses that exact same `timedelta` symbol in line 749 to create a timedelta object. The changed line in Edit 1 directly references the symbol that was imported in Edit 0. This creates an immediate code dependency - after adding the import in Edit 0, using timedelta becomes the natural next step, and after using timedelta in Edit 1, ensuring the import exists becomes necessary. Both edits reference the exact same symbol and either can be staged first (the usage would cause a runtime NameError if imported first, but both can be parsed and staged in either order in Python)."
        },
        {
            "sample_idx": 235,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and lack direct code linkage. Edit 0 modifies the `_add_browser_connection` method to handle a `PREHEATED_REPORT_CONTEXT` constant and uses conditional logic to either reuse a preheated context or create a new one. Edit 1 calls a method `add_preheated_report_context()` on a server object. While both edits are conceptually related to preheating report contexts, the changed lines reference completely different symbols: Edit 0 references the constant `PREHEATED_REPORT_CONTEXT` and modifies context assignment logic, while Edit 1 calls the method `add_preheated_report_context()`. There is no explicit code dependency between these specific changed lines - they don't reference, assign, call, or import the exact same symbol. The relationship is purely conceptual/thematic rather than creating an immediate, mechanically obvious code-driven prompt between the changed lines themselves."
        },
        {
            "sample_idx": 234,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are not neighbours. Edit 0 removes imports of `s3_listener` and `get_handler_file_from_name` from the file, while Edit 1 modifies the implementation of the `get_bucket_location_config` function to handle the US East 1 region differently. The changed lines in each edit reference completely different symbols - Edit 0 deals with import statements for specific modules/functions, while Edit 1 deals with `aws_stack.get_region()`, `AWS_REGION_US_EAST_1`, and local variable assignments. There is no direct code dependency or reference to the exact same symbol between these edits. The connection, if any, would be conceptual (both related to AWS/S3 functionality) but there is no explicit, immediate code linkage where making one edit creates a mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 237,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve completely different symbols and code constructs. Edit 0 adds a constant definition 'PREHEATED_REPORT_CONTEXT' at the module level, while Edit 1 reformats a self.write() method call in the _DebugHandler class by splitting it across multiple lines. There is no code dependency, shared symbol reference, or structural relationship between adding a constant and reformatting an unrelated method call. The changes are in different parts of the file, affect different symbols, and have no explicit code linkage."
        },
        {
            "sample_idx": 236,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they both reference the exact same symbol 'vcs_rev' as an attribute of the Env object. Edit 0 adds 'vcs_rev=vcs_rev' as a parameter when constructing the Env object, while Edit 1 accesses and uses 'env.vcs_rev' in the get_source_specific_defines function. The changed lines in both edits explicitly reference the same symbol (the vcs_rev attribute of the Env instance), creating a direct code dependency. After making either edit, the other becomes a mechanically obvious next step - if you add vcs_rev to the Env constructor, you'd naturally want to use it where VCS revision is needed, and vice versa. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship."
        },
        {
            "sample_idx": 238,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits do not reference the same symbol or have direct code linkage. Edit 0 adds a line incrementing `row_index` in the backtesting implementation, while Edit 1 adds a test assertion for checking dataframe length for a specific trading pair ('NXT/BTC'). Although both edits are related to backtesting functionality and may be part of the same feature development, they don't reference the exact same symbol - the changed lines don't share any common variables, functions, or imports. The connection is only conceptual/thematic (both related to backtesting) rather than having explicit code dependency between the specific symbols referenced in each edit."
        },
        {
            "sample_idx": 241,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 imports the 'unicode_message' function from glances.outputs.glances_unicode, while Edit 1 calls the 'separator_line()' method within the display function. The changed lines do not reference the same symbol - one is importing 'unicode_message' and the other is calling 'separator_line'. There is no explicit code linkage between these two operations, and they appear to be independent changes that could be made in any order without creating a mechanical prompt for the other."
        },
        {
            "sample_idx": 239,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits form a bi-directional relationship because they both reference the exact same symbol 'is_legacy_optimizer' in a synchronized add-remove pattern. Edit 1 adds 'is_legacy_optimizer': True to the config dictionary in the base OptimizerV2 class's get_config method, while Edit 0 removes 'is_legacy_optimizer' from the config dictionary in the Adagrad subclass's from_config method. This creates a direct code dependency where the config key added in one location needs to be cleaned up in the other to prevent it from being passed as an unexpected parameter to the constructor. Either edit can be made first - if Edit 1 is made first, the key will be in configs but needs removal in from_config; if Edit 0 is made first, it defensively handles a key that will be added by Edit 1. Both edits reference the same string literal 'is_legacy_optimizer' and form part of a single micro-task to add legacy optimizer marking while ensuring clean config processing."
        },
        {
            "sample_idx": 240,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols despite superficial similarity. Edit 0 adds an 'acl' parameter to the GCSFeedStorage.__init__ method signature. Edit 1 adds an assertion checking storage.acl in a test method. However, the changed lines reference different symbols: Edit 0 references the parameter 'acl' in the constructor signature, while Edit 1 references the attribute 'storage.acl' on a storage instance. These are different symbols in different scopes - one is a parameter symbol, the other is an attribute access symbol. While they may be conceptually related (the parameter likely gets assigned to an attribute), there is no direct, explicit code linkage between the exact same symbol in the changed lines themselves."
        },
        {
            "sample_idx": 242,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits modify the docstring of the same method `_add_browser_connection` within the same class `Server`. Edit 0 changes the description line from 'Registers a connected browser to the server' to 'Register a connected browser with the server', while Edit 1 updates the parameter documentation for `ws` from just `_BrowserWebSocketHandler` to `_BrowserWebSocketHandler or PREHEATED_REPORT_CONTEXT`. These are both part of updating the same docstring for the same method, representing a single micro-task of improving the method's documentation. The edits reference the exact same symbol (the `_add_browser_connection` method) and would naturally be done together as part of a single documentation update task. Either edit could be made first, and after making either one, continuing to refine other parts of the same docstring would be the natural next step."
        },
        {
            "sample_idx": 243,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different files, functions, and code constructs with no shared symbols or dependencies. Edit 0 reformats argument parameters in a command-line parser setup in main.py, while Edit 1 adds a method call in a display function in a curses output module. The changed lines reference entirely different symbols (__display_header vs parser.add_argument parameters) and there is no explicit code linkage, import relationship, or structural dependency between them. They appear to be independent code improvements made to separate parts of the codebase."
        },
        {
            "sample_idx": 244,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds 'viewkeys' to the import statement from glances.compat, while Edit 1 uses 'viewkeys' in a for loop to iterate over dictionary keys. This is a classic import-usage relationship where both edits reference the exact same symbol 'viewkeys'. In Python, the usage can be written before the import (it would only cause a NameError at runtime, not a parse error), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the functionality."
        },
        {
            "sample_idx": 245,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and contexts. Edit 0 adds a 'vcs_rev' parameter to an Env constructor call in the init_env function, while Edit 1 creates a local 'vcs_rev' variable in the build_static_kittens function and uses it in a Go build command. Although both involve VCS revision handling, the changed lines reference completely different symbols: one is a parameter being passed to Env(), and the other is a local variable assignment. There is no direct code dependency or explicit linkage between the exact same symbol in both edits - they are separate uses of VCS revision data in different contexts and functions."
        },
        {
            "sample_idx": 247,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of optimizer serialization/deserialization but do not reference the exact same symbol or create a direct code dependency. Edit 0 adds a 'use_legacy_optimizer=False' parameter to a deserialize call, while Edit 1 adds an 'is_legacy_optimizer': True field to a config dictionary in a different class method. While both are conceptually related to legacy optimizer handling, the changed lines reference different symbols - one is a parameter in a deserialize call and the other is a dictionary key in a config. There is no direct, explicit code linkage between these specific changes that would make one edit mechanically prompt the other as the immediate next step."
        },
        {
            "sample_idx": 246,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 adds two new dictionary entries ('MEDIUM_LINE' and 'LOW_LINE') to what appears to be a unicode character mapping dictionary. Edit 1 removes a blank line from the code structure. While both edits occur in the same file, there is no explicit code linkage between them - the changed lines do not reference the same symbol, and removing a blank line does not create any mechanical prompt to add dictionary entries or vice versa. The relationship is purely coincidental formatting cleanup that happened to occur near a feature addition, but there is no direct syntactic or structural dependency between the specific changes made."
        },
        {
            "sample_idx": 248,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different files (Server.py and bootstrap.py) and involve completely different operations. Edit 0 is a code formatting change that adds line breaks to improve readability of a conditional statement in the Server class's _get_routes method. Edit 1 adds a method call 'server.add_preheated_report_context()' in the run function of bootstrap.py. The changed lines reference entirely different symbols and operations - one involves config.get_option calls for conditional logic, while the other involves a server method call. There is no direct code dependency, shared symbol reference, or structural relationship between these changes. They appear to be independent modifications made as part of separate concerns."
        },
        {
            "sample_idx": 249,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are not neighbours. Edit 0 changes a function call to `unpause_external_data_schedule` by converting the `source` parameter to a string (`str(source.id)`). Edit 1 removes code related to schema checking in a different function (`check_schedule_activity`) that deals with `aget_schema_by_id` and schema synchronization logic. While both edits are in the same codebase and relate to external data processing, the changed lines reference completely different symbols and functions. There is no direct code dependency, shared symbol reference, or synchronized pattern between modifying the parameter type in `unpause_external_data_schedule` and removing schema validation logic. The edits affect different functions in different files with no explicit linkage between the exact symbols being modified."
        },
        {
            "sample_idx": 251,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of VCS revision handling but do not reference the exact same symbol. Edit 0 modifies the get_source_specific_defines function to use env.vcs_rev instead of calling get_vcs_rev_define() directly, while Edit 1 adds a new command-line argument '--vcs-rev' to the argument parser. Although both are conceptually related to VCS revision functionality, the changed lines reference different symbols: Edit 0 references env.vcs_rev and get_vcs_rev(), while Edit 1 adds a new argument parser option. There is no direct code dependency where one edit's changed lines reference the exact same symbol as the other edit's changed lines. The relationship is thematic/conceptual rather than having explicit code linkage between the same symbols."
        },
        {
            "sample_idx": 250,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they both reference the exact same symbol 'FEED_STORAGE_GCS_ACL' and work together to implement ACL functionality in the GCSFeedStorage class. Edit 0 adds the ACL parameter from settings to the constructor call, while Edit 1 uses that ACL parameter in the upload operation. Both edits are part of a single micro-task to add ACL support, and either edit naturally prompts the other as the next mechanical step - adding the parameter retrieval requires using it, and using the ACL parameter requires retrieving it. The changed lines have direct code linkage through the same configuration symbol."
        },
        {
            "sample_idx": 252,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits add the identical line 'connection.connect()' at the same structural position within similar nested functions that operate on proxy records. This represents a bulk/pattern synchronization where the same code change (adding the connection.connect() call) is being applied uniformly across multiple similar functions. Both edits perform an identical textual substitution (adding the same line) and target the same type of syntactic construct (nested functions handling proxy records). This appears to be part of a single, contiguous refactor to ensure database connections are established before proxy record operations."
        },
        {
            "sample_idx": 253,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same configuration key 'is_legacy_optimizer' but in different contexts and files. Edit 0 adds logic to read and use the 'is_legacy_optimizer' value from a config dictionary in the deserialize function, while Edit 1 adds this key-value pair to what appears to be a test configuration dictionary. However, the changed lines reference different symbols - Edit 0 references config['config']['is_legacy_optimizer'] while Edit 1 adds a literal key-value pair to a test dictionary. While they share the same string literal 'is_legacy_optimizer', they are not referencing the exact same symbol or creating a direct code dependency between the changed lines. The relationship is conceptual/thematic rather than creating an immediate, mechanically obvious prompt for one edit after the other."
        },
        {
            "sample_idx": 255,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are completely unrelated. Edit 0 adds a line to assign `self.query_id = cur.stats[\"queryId\"]` in the TrinoHook's run method, which is adding functionality to store query ID information. Edit 1 modifies a SQL statement in a test file to add 'IF NOT EXISTS' to a CREATE TABLE statement. The changed lines reference completely different symbols and code constructs - one is adding an attribute assignment using cursor stats, the other is modifying SQL text. There is no direct code dependency, shared symbol reference, or mechanical prompt between these changes. They appear to be separate, independent modifications to different parts of the codebase."
        },
        {
            "sample_idx": 254,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits modify different functions in different files and do not reference the same symbol. Edit 0 adds a 'dtype' parameter to the load_unet_state_dict function signature, while Edit 1 adds a 'weight_dtype' parameter to the INPUT_TYPES method of the UNETLoader class. Although both relate to data type handling for neural networks, the changed lines reference completely different symbols (dtype vs weight_dtype) in different functions and files. There is no direct code dependency or explicit symbol linkage between the two edits - they are different parameters with different names in unrelated function signatures. The relationship is purely conceptual/thematic rather than based on explicit code linkage."
        },
        {
            "sample_idx": 258,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new method `add_preheated_report_context()` that calls `self._add_browser_connection(PREHEATED_REPORT_CONTEXT)` on line 190. Edit 1 modifies the `_add_browser_connection()` method to handle the case where `PREHEATED_REPORT_CONTEXT` is passed as the `ws` parameter (lines 210-213). The changed lines in both edits reference the exact same symbol `PREHEATED_REPORT_CONTEXT` and the same method `_add_browser_connection`. Edit 0 creates a direct call to the method that Edit 1 modifies to handle that specific call. This is a clear definition-usage relationship where both edits reference the exact same symbols and either edit naturally prompts the other as the next mechanical step in implementing the preheated report context feature."
        },
        {
            "sample_idx": 259,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds the initialization of the attribute `self.cond_scale_miltiplier = 1.0` in the `__init__` method of the CFGDenoiser class. Edit 1 uses this exact same attribute in the `forward` method by referencing `self.cond_scale_miltiplier` in the expression `cond_scale * self.cond_scale_miltiplier`. Both edits reference the exact same symbol - the instance attribute `cond_scale_miltiplier` of the CFGDenoiser class. This creates an immediate definition-usage relationship where defining the attribute in the constructor enables its use in the forward method. Since Python allows referencing undefined attributes (resulting in AttributeError at runtime rather than parse error), both edits can be staged in either order, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 257,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same test class and appear to be part of updating the GCSFeedStorage interface, but they reference different symbols and contexts. Edit 0 modifies a mock patch dictionary by adding 'FEED_STORAGE_GCS_ACL': None to the settings configuration in the test_parse_settings method. Edit 1 modifies a constructor call to GCSFeedStorage by adding an 'acl' parameter in the test_store method. While both edits involve ACL-related changes to the GCS storage functionality, the changed lines reference different symbols: Edit 0 references a settings dictionary key 'FEED_STORAGE_GCS_ACL', while Edit 1 references a constructor parameter 'acl'. These are different symbols in different scopes (mock settings vs constructor call), and there is no direct code dependency between the specific changed lines. The relationship is conceptual/thematic (both related to ACL functionality) rather than an explicit code linkage where one edit's changed lines reference the exact same symbol as the other edit's changed lines."
        },
        {
            "sample_idx": 256,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 changes the function signature of 'unpause_external_data_schedule' from taking an 'ExternalDataSource' parameter to taking a 'str' parameter named 'id'. Edit 0 calls this exact same function with 'str(instance.id)' as an argument. After making edit 1 (the signature change), edit 0's call site becomes the immediate next step to ensure the function call matches the new signature. Both edits reference the exact same symbol 'unpause_external_data_schedule' - one modifies its definition and the other uses it. This creates a direct code dependency where either edit can be made first and the other becomes the mechanically obvious next step."
        },
        {
            "sample_idx": 263,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different files and affect completely different functions with no shared symbols. Edit 0 removes code related to schema checking in `check_schedule_activity` function in the temporal data imports module, while Edit 1 changes the function signature of `unpause_external_data_schedule` in the warehouse data load service module, replacing an `ExternalDataSource` parameter with a string `id` parameter. The changed lines reference entirely different symbols - one deals with schema model checking logic and the other modifies a function parameter type. There is no direct code dependency, shared symbol reference, or structural relationship between these edits."
        },
        {
            "sample_idx": 261,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions and different parameters being modified. Edit 0 changes a call to `pause_external_data_schedule()` by wrapping `job.pipeline.id` with `str()`, while Edit 1 changes a call to `unpause_schedule()` by removing the `str()` wrapper and changing from `external_data_source.id` to just `id`. Although both edits involve string conversion of ID parameters, they reference completely different symbols (`job.pipeline.id` vs `external_data_source.id` vs `id`) and different functions (`pause_external_data_schedule` vs `unpause_schedule`). The changed lines do not reference the exact same symbol, and there is no direct code dependency between these specific function calls. The relationship is only conceptual (both dealing with ID parameter formatting) rather than an explicit code linkage."
        },
        {
            "sample_idx": 262,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are both making changes to argument parser configurations in the same file, but they involve completely different command-line arguments and different symbols. Edit 0 reformats the '--enable-plugin' argument definition by splitting it across multiple lines, while Edit 1 adds an entirely new '--separator'/'--enable-separator' argument. The changed lines reference different argument names ('enable_plugin' vs 'enable_separator'), different help text, and different functionality. There is no direct code dependency between these edits - neither edit references the same symbol or creates a mechanical prompt for the other. They are simply two separate argument parser modifications that happen to be in the same method but are conceptually and structurally independent."
        },
        {
            "sample_idx": 260,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits have a direct definition-usage relationship for the exact same symbol. Edit 1 adds a new parameter 'read_with_timeout' to the TTYIO class constructor, and Edit 0 immediately uses that new parameter when creating a TTYIO instance. The changed lines reference the exact same symbol (the read_with_timeout parameter), creating an immediate code-driven prompt where after adding the parameter definition, the next natural step is to use it at call sites, or vice versa. This is a classic signature change \u2194 call-site update pattern for the same class constructor. In Python, both edits can be staged in either order without parser errors (the call with the new parameter would work even before the parameter is defined, only failing at runtime), making this bi-directional rather than ordered."
        },
        {
            "sample_idx": 264,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are both within the same function (CFGDenoiser.forward) but they modify completely different aspects of the code without any direct code dependency. Edit 0 changes a conditional check from 'is_cfg_pp' to 'self.need_last_noise_uncond' and optimizes the cloning operation. Edit 1 modifies a parameter passed to 'combine_denoised_for_edit_model' by multiplying 'cond_scale' with 'self.cond_scale_miltiplier'. The changed lines in each edit do not reference the same symbols - they involve different variables, different conditional logic, and different function calls. There is no explicit code linkage where one edit creates an immediate, mechanically obvious prompt for the other. While both edits are in the same function and may be part of the same feature development, they represent independent code changes without direct symbol dependencies."
        },
        {
            "sample_idx": 267,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different symbols and operations. Edit 0 adds a new constant AWS_REGION_US_EAST_1 to constants.py, while Edit 1 removes import statements for s3_listener and get_handler_file_from_name from template_deployer.py. There is no direct code linkage between the changed lines - they don't reference, assign, call, or import the same symbols. The addition of a region constant and the removal of unrelated imports are separate operations with no explicit code dependency or structural relationship between the specific lines being changed."
        },
        {
            "sample_idx": 266,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits show a parameter rename refactoring where the URL route parameters are being renamed from 'type' and 'token' to 'email_type' and 'confirmation_key'. Edit 1 changes the URL pattern parameter names, and Edit 0 updates the function body to use the new parameter names. Both edits reference the exact same symbols - the URL parameters that get passed to the email_unsubscribe function. The URL route definition and the function implementation that receives those parameters have a direct syntactic dependency. After making either edit, the other becomes immediately necessary to maintain consistency between the URL parameter names and their usage in the function body. This is a signature-caller relationship where both edits can be staged in either order (no parse errors), making it bi-directional."
        },
        {
            "sample_idx": 265,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same function `webui()` but they modify different aspects of the code without any direct code dependency. Edit 0 adds a conditional route registration using `cmd_opts.add_stop_route`, while Edit 1 adds a print statement in a KeyboardInterrupt exception handler. The changed lines don't reference the same symbols - Edit 0 references `cmd_opts.add_stop_route`, `app.add_route`, and `stop_route`, while Edit 1 references a print statement and `server_command`. There is no explicit code linkage between these changes, and neither edit creates an immediate, mechanically obvious prompt for the other. They appear to be separate improvements to different parts of the same function's logic."
        },
        {
            "sample_idx": 268,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 sets the attribute `model.need_last_noise_uncond = True` on the model object, and Edit 0 uses this exact same attribute in a conditional check `if self.need_last_noise_uncond:`. The changed lines reference the exact same symbol (`need_last_noise_uncond`) where one edit defines/sets the attribute and the other edit uses it. This creates a direct code dependency - setting the attribute in Edit 1 enables the conditional logic in Edit 0. Both edits can be staged in either order without parser errors (the attribute access in Edit 0 would only cause a runtime AttributeError if the attribute doesn't exist), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 271,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits add the exact same parameter 'run_tests: bool = False' to function signatures in the same file. This represents a uniform, synchronized parameter addition pattern where the same structural change (adding the same parameter with identical name, type, and default value) is being applied to multiple function signatures. This is a classic bulk-edit/pattern synchronization case where both edits perform an identical structural substitution on the same type of syntactic construct (function signatures). Either edit can be made first, and after making either one, the other becomes a natural next step to maintain consistency in the API. The edits reference the same parameter name and structure, making this a bi-directional relationship driven by the need for synchronized parameter threading across related functions."
        },
        {
            "sample_idx": 269,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a 'seen = set()' variable initialization in the _newnames function in numpy/core/_internal.py. Edit 1 adds 'assert_raises_regex' to an import statement in numpy/core/tests/test_multiarray.py. The changed lines reference entirely different symbols - one creates a local variable 'seen' and the other imports a testing utility function 'assert_raises_regex'. There is no direct code dependency, shared symbol reference, or structural relationship between these changes. They appear to be part of different, independent modifications to the codebase."
        },
        {
            "sample_idx": 270,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits involve handling the 'is_legacy_optimizer' key in configuration dictionaries, but they reference different config objects in different contexts. Edit 0 removes 'is_legacy_optimizer' from a config parameter in the from_config class method, while Edit 1 conditionally removes 'is_legacy_optimizer' from new_config['config'] in a test method. These are different symbols (config vs new_config['config']) in different scopes (production code vs test code), and there is no direct code dependency between the changed lines - they don't reference the exact same symbol. The relationship is only conceptual/thematic (both handle the same configuration key) rather than having explicit code linkage."
        },
        {
            "sample_idx": 272,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These edits reference different aspects of the same function call but do not create an immediate, mechanically obvious prompt for each other. Edit 0 adds a parameter 'use_legacy_optimizer=False' to a call to optimizers.deserialize(), while Edit 1 adds logic inside the deserialize() function to handle an 'is_legacy_optimizer' config parameter. Although both edits relate to the same deserialize function, they reference different symbols and mechanisms: Edit 0 deals with the 'use_legacy_optimizer' parameter being passed in, while Edit 1 deals with 'is_legacy_optimizer' from the config dictionary. The changed lines do not reference the exact same symbol - one references a parameter being passed, the other references a config key. Neither edit creates a direct, code-driven prompt for the other as the next contiguous action, as they address different aspects of optimizer legacy handling logic."
        },
        {
            "sample_idx": 274,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different parts of the same class and involve different symbols and functionality. Edit 0 adds a new method `separator_line` to the class, while Edit 1 reformats the arguments in a call to `display_plugin` within the existing `__display_header` method. There is no direct code dependency between these edits - the changed lines don't reference the same symbols, functions, or variables. The `separator_line` method being added in Edit 0 is not called, referenced, or related to the argument formatting change in Edit 1. These are independent code changes that happen to be in the same file and class, but lack any explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 273,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different files and contexts, with no direct code linkage between them. Edit 0 adds a line incrementing 'row_index' in the backtesting implementation, while Edit 1 adds a conditional check around data slicing in a test function. The changed lines reference completely different symbols and operations - 'row_index' increment vs 'tres' conditional check and 'data[pair]' slicing. There is no explicit dependency, shared symbol reference, or synchronized pattern between these edits. They appear to be separate bug fixes or improvements that happen to be part of the same codebase but don't create immediate, mechanically obvious prompts for each other."
        },
        {
            "sample_idx": 275,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits add identical import statements (`from django.db import connection`) to different files. While this appears to be part of a bulk edit or synchronized change, the edits are adding imports to completely separate files (common.py and delete.py) without any direct code dependency between the changed lines themselves. The changed lines don't reference the exact same symbol being used across both files - they are simply adding the same import capability to different modules. This is a thematic/conceptual relationship (both files need the same import) rather than an explicit code linkage where one edit's changed line references a symbol defined or modified in the other edit's changed line. According to the criteria, edits that only share conceptual or thematic connections without direct symbol reference between the changed lines should be labeled as 'no relation'."
        },
        {
            "sample_idx": 276,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new parameter 'run_tests' to the function signature, and Edit 1 uses that exact same parameter in a conditional statement within the function body. The changed lines reference the exact same symbol - the 'run_tests' parameter. After adding the parameter in the signature (Edit 0), using it in the function body (Edit 1) becomes the immediate, mechanically obvious next step. This is a classic definition-usage pattern within the same function where both edits reference the same symbol. Since this is Python, both edits can be parsed in either order (no syntax error), making this bi-directional rather than ordered."
        },
        {
            "sample_idx": 278,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a 'skip_models' parameter to the __init__ method of BaseDeletionTask class, and Edit 1 adds a 'filter_relations' method that references 'self.skip_models' in its implementation. The changed lines in Edit 1 explicitly reference the exact same symbol (skip_models) that was added as a parameter in Edit 0. However, both edits can be written and parsed independently - Edit 1 would only fail at runtime with an AttributeError if skip_models wasn't initialized, but Python allows referencing undefined attributes at parse time. Since either edit could be made first and the other would be the immediate next step to complete the functionality, this is a bi-directional relationship with direct code linkage through the same symbol."
        },
        {
            "sample_idx": 277,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These edits involve the exact same function `_test_error_exc_info` with identical implementation. Edit 0 removes the function from inside the `RemoteTestResultTest` class (lines 77-81), while Edit 1 removes the same function from module level (lines 287-291). This appears to be a cleanup operation removing duplicate or unused helper functions. However, these are different symbols despite having the same name - one is a method `RemoteTestResultTest._test_error_exc_info` and the other is a module-level function `_test_error_exc_info`. The changed lines in each edit don't reference the exact same symbol, and there's no direct code dependency between them. This is a case of 'same name, different symbols' which should be labeled as 'no relation' according to the criteria."
        },
        {
            "sample_idx": 279,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 adds an `on_kill` method to the `TrinoOperator` class that handles query termination, while Edit 1 modifies a SQL string in a test file by adding 'IF NOT EXISTS' to a CREATE TABLE statement. The changed lines do not reference the same symbol - Edit 0 involves adding a new method with calls to `self.hook.run()` and `self.hook.query_id`, while Edit 1 only changes a SQL string literal. There is no explicit code dependency, no shared symbol references, and no mirrored substitution pattern. The connection is purely conceptual (both relate to Trino operations) but lacks the required direct, mechanical code linkage between the exact same symbols."
        },
        {
            "sample_idx": 280,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds an import statement for `__version__` in modeling_utils.py, while Edit 1 adds a `user_agent` parameter to a `snapshot_download` function call in pipeline_utils.py. The changed lines reference completely different symbols - one references `__version__` and the other references `user_agent`. There is no explicit code linkage, dependency, or synchronized pattern between these edits. They appear to be separate changes that happen to be part of the same codebase but have no direct relationship at the code level."
        },
        {
            "sample_idx": 284,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of the skip_animations functionality but do not have a direct code dependency between the changed lines themselves. Edit 0 adds 'skip_animations' to a configuration dictionary in the get_configuration function, while Edit 1 uses 'self.skip_animations' in a conditional statement within the Scene class constructor. Although both edits relate to the skip_animations feature, the changed lines reference different symbols: args.skip_animations (from function arguments) in Edit 0 versus self.skip_animations (instance attribute) in Edit 1. There is no direct syntactic dependency where making one edit creates an immediate, mechanically obvious prompt for the other - they are separate implementation details of the same feature rather than definition-usage or import-usage of the exact same symbol."
        },
        {
            "sample_idx": 282,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different aspects of the same class (GCSFeedStorage) but do not have direct code linkage between the changed lines. Edit 0 modifies the upload_from_file method call to use self.acl as a parameter, while Edit 1 adds a test assertion to verify that storage.acl has the expected value. While both edits involve the 'acl' attribute of the GCSFeedStorage class, the changed lines don't reference the exact same symbol - one references self.acl in the implementation and the other references storage.acl in a test assertion. This is a test-production relationship, but the test is verifying attribute parsing/setting rather than directly testing the modified upload behavior. The relationship is thematic (both relate to ACL functionality) rather than having explicit code dependency where one edit creates an immediate prompt for the other."
        },
        {
            "sample_idx": 281,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds 'Response' to the import statement from fastapi, while Edit 1 adds a print statement inside a KeyboardInterrupt exception handler. These edits reference completely different symbols and code constructs. Edit 0 modifies an import to make the 'Response' class available, while Edit 1 adds logging functionality to an exception handler. There is no direct code dependency between these changes - the print statement does not use the Response class, and the import change does not create any mechanical prompt for adding the print statement. The changes are conceptually unrelated and reference different symbols with no explicit code linkage between the changed lines."
        },
        {
            "sample_idx": 283,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a 'weights' parameter to the Embedding class constructor, and Edit 1 adds a test method that specifically tests this new 'weights' parameter by passing it to the Embedding constructor and verifying its behavior. The changed lines in both edits reference the exact same symbol - the 'weights' parameter. Edit 0 defines the parameter in the constructor signature, while Edit 1 uses that exact parameter in test calls. This creates an immediate code-driven linkage where adding the parameter naturally prompts the need for tests to verify its functionality, and vice versa - writing tests for the weights parameter would prompt adding it to the constructor. Both edits can be staged in either order (the test would fail at runtime if the parameter doesn't exist, but would parse successfully), making this a bi-directional relationship."
        },
        {
            "sample_idx": 285,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve adding a 'vcs_rev' parameter in two different contexts - one adds it as a parameter to an Env constructor call, and the other adds a command-line argument parser option for '--vcs-rev'. While both edits involve the same concept (vcs_rev), they reference different symbols in different scopes: one is adding a parameter to a function call (Env constructor), and the other is adding an argument parser option. The changed lines do not reference the exact same symbol - one references 'vcs_rev' as a variable being passed to Env(), while the other defines '--vcs-rev' as a command-line option. There is no direct code dependency between these specific changed lines, and they could be implemented independently without one mechanically requiring the other as the immediate next step."
        },
        {
            "sample_idx": 286,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different aspects of the same symbol AWS_REGION_US_EAST_1, but they don't create a direct code dependency between the changed lines. Edit 0 adds AWS_REGION_US_EAST_1 to an import statement in config.py, while Edit 1 adds an import of AWS_REGION_US_EAST_1 in a different file (template_deployer.py). The changed lines don't reference the exact same symbol usage - one is exporting/re-exporting the symbol, the other is importing it for local use. There's no immediate, mechanically obvious prompt from one edit to the other, as they are independent import operations in different files for different purposes. This appears to be part of a broader refactoring to use the constant in multiple places, but the edits themselves don't have explicit code linkage between the changed lines."
        },
        {
            "sample_idx": 287,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours because they reference different symbols and lack direct code dependency. Edit 0 changes a type check from 'Exception' to 'ExcInfo', while Edit 1 adds email functionality that accesses 'ret_value.traceback'. Although Edit 1's new code assumes ret_value has a traceback attribute (which ExcInfo would have but Exception might not), the changed lines themselves don't reference the exact same symbol. Edit 0 changes the isinstance() check, while Edit 1 adds new functionality. The relationship is conceptual (both relate to error handling) rather than an explicit code dependency where one edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 288,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern: changing 'self._test_error_exc_info()' to '_test_error_exc_info()' in method calls. This is a uniform refactoring operation that removes 'self.' from the same method name across multiple locations within the same test class. Both changed lines reference the exact same symbol (_test_error_exc_info) and represent the same type of syntactic construct (method calls). This appears to be part of a single, contiguous refactor operation where the method is being changed from an instance method to a module-level function or static method. Either edit could be made first, and both are part of the same mechanical substitution pattern."
        },
        {
            "sample_idx": 289,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve adding the same variable name 'acl' in different contexts - one in the production code's __init__ method and another in a test method. However, they reference different symbols despite having the same name. Edit 0 adds 'self.acl = acl' in the GCSFeedStorage.__init__ method, while Edit 1 adds 'acl = 'publicRead'' as a local variable in a test method. These are different symbols in different scopes with no direct code dependency between the changed lines. The relationship is only conceptual (both relate to ACL functionality) but lacks the explicit, immediate code linkage required for neighbour classification."
        },
        {
            "sample_idx": 290,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits affect different parts of the QaEngineer class and reference completely different symbols. Edit 0 adds a 'test_round_allowed' parameter to the __init__ method signature, while Edit 1 removes the recv method entirely. There is no direct code dependency between these changes - the added parameter in the constructor is not referenced by the recv method, and removing the recv method does not create any immediate prompt to modify the constructor signature. The changes are conceptually related to the same class but lack explicit code linkage between the exact same symbols in their changed lines."
        },
        {
            "sample_idx": 291,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the codebase. Edit 0 removes a line that calculates `unet_dtype` using `model_management.unet_dtype()` in the `load_unet_state_dict` function in `comfy/sd.py`. Edit 1 adds a `weight_dtype` parameter to the input types of the `UNETLoader` class in `nodes.py`. While both edits relate to data types for neural network models, they reference completely different symbols (`unet_dtype` vs `weight_dtype`), are in different files, different functions/classes, and there is no direct code dependency between the changed lines. The removal of `unet_dtype` calculation does not create an immediate, mechanically obvious prompt to add a `weight_dtype` parameter to a different class, nor vice versa. These appear to be separate changes that happen to be thematically related to model loading but lack explicit code linkage."
        },
        {
            "sample_idx": 292,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are part of a bulk uniform substitution pattern within the same file and same type of function. Edit 0 changes the parameter from 'external_data_source: ExternalDataSource' to 'id: str' in the pause function, while Edit 1 updates the corresponding usage from 'str(external_data_source.id)' to just 'id' in what appears to be the unpause function. Both edits follow the identical pattern of simplifying the parameter interface from a complex object to a simple string ID. This represents a synchronized refactoring where both functions are being updated with the same before\u2192after pattern (complex parameter object \u2192 simple string ID) on the same type of syntactic construct (function signatures and their corresponding parameter usage). Either edit can be made first as both are syntactically valid independently, but they naturally form a cohesive refactoring unit."
        },
        {
            "sample_idx": 294,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions and different symbols. Edit 0 modifies a call to `compute_plan_parameters` by adding an `is_self_hosted_billing` parameter, while Edit 1 modifies a call to `get_free_trial_days` by adding a `True` argument. The changed lines reference completely different function symbols (`compute_plan_parameters` vs `get_free_trial_days`) and there is no direct code dependency or linkage between them. While both may be conceptually related to self-hosted billing functionality, there is no explicit, immediate code-driven prompt from one edit to the other at the locus of change."
        },
        {
            "sample_idx": 296,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits affect different parts of the same class but involve completely different functionality. Edit 0 adds a new `separator_line` method that handles drawing separator lines in the curses interface. Edit 1 modifies the `__display_header` method to conditionally display cloud statistics based on width. There is no direct code linkage between these changes - they don't reference the same symbols, functions, or variables. The changed lines in each edit operate on different methods and different functionality within the curses display system. While both are part of the same class and may be related to UI improvements, there is no explicit, immediate code dependency or mechanically obvious prompt from one edit to the other."
        },
        {
            "sample_idx": 293,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are both modifications within the same __init__ method of the QaEngineer class, but they affect completely different aspects of the initialization. Edit 0 adds a comment to an existing line about _init_actions, while Edit 1 changes a hardcoded value assignment to use a parameter 'test_round_allowed'. The changed lines reference entirely different symbols and operations - one involves _init_actions method call and a comment, the other involves test_round_allowed assignment. There is no direct code dependency, shared symbol reference, or structural synchronization between these changes. They appear to be independent modifications that happen to be in the same method but serve different purposes."
        },
        {
            "sample_idx": 295,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 removes the definition of the variable 'is_cfg_pp', while Edit 1 removes code that references this same variable 'is_cfg_pp' in a conditional statement. Both edits are removing code that involves the exact same symbol within the same function scope. The changed lines in both edits reference the identical symbol 'is_cfg_pp' - one removes its definition and the other removes its usage. This creates a direct code dependency where both edits are part of removing the CFG++ functionality, and either edit naturally prompts the other as the next step in a single micro-task of cleaning up this feature."
        },
        {
            "sample_idx": 298,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 changes a function call to `get_free_trial_days(True)` by adding a parameter, while Edit 1 adds a new configuration setting `SELF_HOSTING_FREE_TRIAL_DAYS`. Although these edits may be conceptually related (both dealing with free trial configuration), the changed lines do not reference the exact same symbol. Edit 0 modifies a call to `get_free_trial_days()` function, while Edit 1 adds a completely different configuration variable. There is no direct code dependency or explicit linkage between the specific lines being changed - they reference different symbols despite potentially being part of the same feature implementation."
        },
        {
            "sample_idx": 297,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions (unpause_external_data_schedule vs pause_external_data_schedule) and different parameter handling patterns. Edit 0 changes a call to unpause_external_data_schedule to pass str(source.id) instead of source, while Edit 1 changes the implementation of pause_external_data_schedule to use a parameter 'id' instead of str(external_data_source.id). While both edits deal with schedule ID handling, they reference different symbols and different functions. The changed lines do not reference the exact same symbol - one is about unpause_external_data_schedule and the other is about pause_external_data_schedule. There is no direct code dependency or synchronized substitution between these specific changed lines."
        },
        {
            "sample_idx": 299,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve completely different operations on different symbols in different files. Edit 0 removes an import of 'aget_schema_by_id' from posthog/temporal/data_imports/external_data_job.py, while Edit 1 changes a parameter from 'str(external_data_source.id)' to 'id' in the unpause_schedule function call in posthog/warehouse/data_load/service.py. There is no shared symbol, function, or direct code dependency between these changes. The edits reference entirely different symbols and perform unrelated operations - one is an import removal, the other is a parameter substitution. There is no explicit code linkage or mechanical prompt relationship between removing an import and changing a function parameter in a different file."
        },
        {
            "sample_idx": 302,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions and different symbols. Edit 0 modifies a call to `compute_plan_parameters` by adding an `is_self_hosted_billing` parameter, while Edit 1 modifies a call to `get_free_trial_days` by adding a `True` argument. The changed lines reference completely different function symbols (`compute_plan_parameters` vs `get_free_trial_days`) and there is no direct code dependency between them. While both edits may be conceptually related to self-hosted billing functionality, there is no explicit, immediate code linkage where making one edit creates a mechanically obvious prompt for the other. The relationship appears to be thematic/feature-based rather than based on direct symbol references."
        },
        {
            "sample_idx": 300,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of the same class but reference completely different symbols and functionality. Edit 0 adds a `skip_models` attribute initialization in the constructor, while Edit 1 adds a call to `filter_relations()` method in the `delete_bulk` method. There is no direct code dependency between these changes - they don't reference the same symbol, and neither edit creates an immediate, mechanically obvious prompt for the other. The `skip_models` attribute being set in the constructor and the `filter_relations()` method call in `delete_bulk` are separate operations that could be implemented independently. While they may be conceptually related to the same feature (filtering functionality), there is no explicit code linkage between the changed lines themselves."
        },
        {
            "sample_idx": 301,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new setting 'FEED_STORAGE_GCS_ACL = None' to the default settings file, while Edit 1 uses this exact same setting name in a test by adding 'FEED_STORAGE_GCS_ACL': 'publicRead' to the test settings dictionary. Both edits reference the exact same symbol (FEED_STORAGE_GCS_ACL) - one defining it as a default setting and the other using it in a test configuration. This creates a direct code linkage where either edit can be made first since Python allows referencing undefined settings at parse time (would only fail at runtime/import if the setting is actually accessed), making this a bi-directional relationship where making either edit creates an immediate prompt for the other as part of implementing GCS ACL functionality."
        },
        {
            "sample_idx": 303,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 modifies the TTYIO constructor call to add the parameter `read_with_timeout=False` and creates a `tty` variable. Edit 1 then immediately uses that same `tty` variable by calling `tty.wait_till_read_available()` on the very next lines within the same while loop. The changed lines reference the exact same symbol - the `tty` variable created in edit 0's with statement is directly used in edit 1's conditional check. This creates an immediate, mechanically obvious code-driven prompt where after making edit 0 (which changes how the tty object is configured), edit 1 becomes the natural next step to utilize the new timeout behavior. Both edits can be staged in either order since Python allows referencing variables defined in with statements, and both are part of the same contiguous micro-task of modifying the tty reading logic."
        },
        {
            "sample_idx": 304,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different contexts and different symbols. Edit 0 modifies documentation/docstring example output in the serialize function to show 'is_legacy_optimizer': True in the serialized config. Edit 1 adds a test assertion that checks config['is_legacy_optimizer'] equals True. While both edits involve the same string 'is_legacy_optimizer', they are referencing different things: Edit 0 is updating documentation to reflect what the serialized output looks like, while Edit 1 is testing the actual config object from an optimizer instance. The changed lines don't reference the exact same symbol - one is in documentation showing expected serialization output, the other is testing a live config object. There's no direct code dependency where making one edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 306,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an 'acl' parameter to the __init__ method signature of GCSFeedStorage class. Edit 1 adds a line that assigns this 'acl' parameter to self.acl within the same __init__ method body. Both edits reference the exact same 'acl' symbol - edit 0 introduces it as a parameter and edit 1 uses that parameter in an assignment. This creates an immediate, mechanically obvious code-driven prompt: after adding a parameter to a function signature, the next natural step is often to use that parameter within the function body. Both edits are part of the same micro-task of adding acl functionality to the constructor. Either edit can be staged first without causing parse errors (Python allows unused parameters and references to parameters), making this bi-directional."
        },
        {
            "sample_idx": 307,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different files and involve different types of changes with no shared symbols or code dependencies. Edit 0 adds method calls (self.init_column() and self.separator_line()) to a display method in the curses output module, while Edit 1 removes a blank line from the unicode module. There is no explicit code linkage between the changed lines - they don't reference, assign, call, or import the same symbols. The edits appear to be independent code maintenance tasks rather than part of a single micro-task with direct code dependencies."
        },
        {
            "sample_idx": 305,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds documentation for a 'weights' parameter to the Embedding class docstring, while Edit 1 adds a test method 'test_weights_constructor_arg' that tests the functionality of that same 'weights' parameter. Both edits reference the exact same symbol - the 'weights' parameter of the Embedding class constructor. The documentation change describes the weights parameter's purpose and format, while the test validates that the weights parameter works correctly when passed to the Embedding constructor. This creates a direct code linkage where both edits are part of implementing and validating the same feature parameter. Either edit could be made first, and after making either one, the other becomes a natural next step in the same development task - documenting the parameter and testing its functionality are complementary actions that reference the same symbol."
        },
        {
            "sample_idx": 308,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol 'GlancesPassword'. Edit 0 imports GlancesPassword from glances.core.glances_password, and Edit 1 uses GlancesPassword in a super() call within what appears to be a class definition. This creates a direct import-usage relationship where the changed lines reference the same symbol. In Python, the usage can be written before the import (it would only fail at runtime with a NameError), so neither edit requires the other to be parseable. Both edits can be staged in either order, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 310,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits are adding documentation and parameter definition for the same 'weights' parameter in the Embedding class. Edit 0 adds documentation for the 'weights' parameter in the docstring, while Edit 1 adds the actual 'weights=None' parameter to the __init__ method signature. Both edits reference the exact same symbol (the 'weights' parameter) and are part of a single micro-task of adding a new parameter to the class. Either edit could be made first - the documentation could be added before the parameter is implemented, or the parameter could be added before documenting it. Both are mechanically obvious next steps after the other, making this a bi-directional relationship."
        },
        {
            "sample_idx": 309,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (handling row indexing in backtesting) but they reference completely different symbols and code constructs. Edit 0 adds 'row_index += 1' in the backtesting implementation, while Edit 1 introduces an 'offset' variable in a test function to adjust the calculation of 'removed_candles'. The changed lines do not reference the exact same symbol - 'row_index' in the implementation and 'offset' in the test are different variables in different scopes. While both changes may be addressing the same underlying issue with data indexing, there is no direct code dependency or explicit symbol linkage between the changed lines themselves."
        },
        {
            "sample_idx": 311,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite similar names. Edit 0 removes an import of 'GlancesPassword' from 'glances.core.glances_passwordlist', while Edit 1 adds an import of 'GlancesPassword' from 'glances.core.glances_password'. The key distinction is that these are imports from different modules (glances_passwordlist vs glances_password), meaning they reference different symbols even though they have the same class name. The changed lines do not reference the exact same symbol - one references GlancesPassword from passwordlist module, the other references GlancesPassword from password module. There is no direct code dependency or synchronized substitution between these specific import statements."
        },
        {
            "sample_idx": 312,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new method `add_preheated_report_context` in the Server class, while Edit 1 calls this exact same method on a server instance. The changed lines reference the exact same symbol - the method `add_preheated_report_context`. After defining the method in Edit 0, calling it in Edit 1 becomes a natural next step, and vice versa - if you're adding a call to this method, you need the method to be defined. Both edits can be staged in either order in Python since the call won't be executed until runtime, making this a bi-directional relationship where either edit naturally prompts the other as the immediate next mechanical step."
        },
        {
            "sample_idx": 315,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits add the identical line 'connection.connect()' at the same relative position within their respective functions - right before database operations involving ProxyRecord objects. This appears to be part of a bulk edit pattern where the same connection establishment code is being added to multiple functions that perform database operations. The edits follow the same before\u2192after pattern (adding the connection call) and target the same type of syntactic construct (function bodies performing database operations). This represents a synchronized, uniform substitution that would naturally occur as part of a single refactoring task to ensure database connections are properly established before ProxyRecord operations."
        },
        {
            "sample_idx": 313,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats the arguments of a parser.add_argument() call in main.py to split parameters across multiple lines, while Edit 1 adds a 'separator' parameter to the new_line() method in a different file (glances_curses.py). The changed lines reference entirely different symbols - one involves argument parser configuration and the other involves a method signature for cursor interface functionality. There is no shared symbol, no code dependency, and no structural relationship between reformatting parser arguments and adding a parameter to an unrelated method in a different module."
        },
        {
            "sample_idx": 314,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are completely unrelated. Edit 0 reformats the arguments of a parser.add_argument() call in main.py by splitting the parameters across multiple lines for better readability. Edit 1 removes a blank line in glances_unicode.py. There is no shared symbol, function, variable, or code construct between these edits. They affect entirely different files with different purposes - one is argument parsing configuration and the other is formatting/whitespace cleanup. Neither edit creates any code-driven prompt for the other, and they could be made in any order without any dependency."
        },
        {
            "sample_idx": 316,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a variable `cwd` by assigning it the value `os.path.realpath(os.path.join(settings.PROJECT_ROOT, os.pardir, os.pardir))`. Edit 1 uses this exact same variable `cwd` as a parameter in the `Popen` call. This is a classic definition-usage relationship where both edits reference the exact same symbol `cwd`. After making edit 0 (defining cwd), edit 1 becomes the immediate next step to use that defined variable. Conversely, if edit 1 were made first, it would create an undefined variable that would prompt the definition in edit 0. Since this is Python and referencing an undefined variable is allowed at parse time (only fails at runtime), both edits can be staged in either order, making this bi-directional."
        },
        {
            "sample_idx": 317,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits add identical code (checking for and deleting 'is_legacy_optimizer' from config) to different `from_config` methods in different optimizer classes. While this appears to be part of a bulk refactor applying the same pattern, the edits are in different files, different classes, and different scopes - they reference different symbols despite having the same method name. The changed lines don't reference the exact same symbol, as these are different `from_config` methods in different classes. There's no direct code dependency between these specific methods, and no immediate mechanical prompt from one edit to the other. This is a conceptual/thematic relationship (same cleanup pattern) rather than an explicit code linkage."
        },
        {
            "sample_idx": 319,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 adds a new function `schedule_exists` to the schedule.py module, while Edit 1 changes a parameter in a call to `pause_schedule` function from `str(external_data_source.id)` to just `id`. The changed lines do not reference the same symbol - Edit 0 creates a new function definition while Edit 1 modifies an argument to a different function call. There is no explicit code dependency, import relationship, or synchronized substitution pattern between these changes. They appear to be unrelated modifications happening in different files with different purposes."
        },
        {
            "sample_idx": 318,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 modifies a method call to use `self.acl` as a parameter in the `blob.upload_from_file()` call, while Edit 1 adds a new configuration setting `FEED_STORAGE_GCS_ACL = None`. Although these edits are conceptually related (the configuration setting likely provides the value for the ACL parameter), there is no direct code linkage between the changed lines themselves. The changed line in Edit 0 references `self.acl` (which would be an instance attribute), while Edit 1 adds a module-level configuration constant. These are different symbols - `self.acl` is an instance attribute while `FEED_STORAGE_GCS_ACL` is a configuration setting. The connection between them would require intermediate code (likely in the class constructor or initialization) to link the configuration setting to the instance attribute, but that linkage is not present in either of these edits."
        },
        {
            "sample_idx": 321,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve changes to completely different files and different symbols. Edit 0 modifies the `new_line` method signature in the `_GlancesCurses` class by adding a `separator` parameter. Edit 1 removes a blank line in a different file (`glances_unicode.py`) before the `unicode_message` function definition. There is no explicit code linkage between these changes - they don't reference the same symbol, there's no import-usage relationship, and they're not part of a uniform substitution pattern. The changes are in different files, affect different functions, and have no direct syntactic or structural dependency between them."
        },
        {
            "sample_idx": 320,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits are within the same webui() function and relate to server stopping functionality, but they reference different aspects of the stopping mechanism. Edit 0 adds a conditional check for cmd_opts.add_stop_route and adds a stop route to the app, while Edit 1 adds a print statement when server_command == 'stop'. These are different symbols and different parts of the stopping logic - one is about adding a route conditionally, the other is about logging when a stop command is received. There is no direct code dependency between the changed lines - they don't reference the same symbol, and neither edit creates an immediate mechanical prompt for the other. The relationship is purely conceptual/thematic (both relate to stopping functionality) rather than having explicit code linkage."
        },
        {
            "sample_idx": 322,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are not neighbors because they reference different symbols and have no direct code dependency. Edit 0 changes a hard-coded value to use a parameter 'test_round_allowed' in the __init__ method, while Edit 1 removes the recv method entirely. There is no explicit code linkage between the changed lines - they don't reference the same symbol, and neither edit creates a mechanical prompt for the other. The edits affect different methods within the same class but involve completely different functionality (parameter assignment vs method removal). This is a case of two separate code changes that happen to be in the same file but lack any direct structural or syntactic dependency."
        },
        {
            "sample_idx": 325,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds an import statement for `get_handler_file_from_name` from the lambda_api module. Edit 1 modifies the implementation of the `get_bucket_location_config` function to handle the US East 1 region differently. There is no explicit code linkage between the changed lines - they reference entirely different symbols and serve different purposes. The import added in edit 0 is not used in edit 1, and the function modified in edit 1 has no connection to the imported symbol. These edits could be made in any order without creating any code-driven prompt for the other."
        },
        {
            "sample_idx": 323,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds weights handling functionality to the Embedding class constructor, including building the layer and setting weights when provided. Edit 1 adds a test method that specifically tests this new weights constructor argument functionality by creating Embedding layers with weights parameters and asserting the embeddings are set correctly. The test directly exercises the exact code path added in edit 0 - the weights parameter handling in the constructor. This is a classic production code implementation followed by corresponding test coverage for the same feature, where both edits reference the same 'weights' parameter functionality in the Embedding class."
        },
        {
            "sample_idx": 324,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 changes the class name from 'GlancesPassword' to 'GlancesPasswordList' and makes it inherit from 'GlancesPassword'. Edit 0 imports 'GlancesPasswordList' and aliases it as 'GlancesPassword'. These edits reference the exact same symbols - the changed lines in both edits directly reference 'GlancesPasswordList' and 'GlancesPassword'. Edit 1 creates the new class name that Edit 0 imports, and Edit 0 imports the class that Edit 1 defines. This creates an immediate, mechanically obvious code-driven prompt where either edit naturally leads to the other as the next contiguous action. Both edits can be staged in either order without parser errors (the import would just fail at runtime if the class doesn't exist), making this a bi-directional relationship."
        },
        {
            "sample_idx": 326,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a comment explaining row treatment in the backtesting logic within the main backtesting module. Edit 1 adds an import statement for 'timedelta' in the test file. The changed lines reference completely different code elements - one is adding documentation comments about row processing, the other is importing a datetime utility. There is no shared symbol, no direct code dependency, and no mechanical prompt from one edit to the other. They appear to be separate changes that happen to be in related files (production code vs test code) but have no explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 327,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code dependency. Edit 0 adds an import statement for '__version__' from the current package, while Edit 1 adds a 'user_agent' parameter to a snapshot_download function call. The changed lines do not reference the same symbol - one involves importing '__version__' and the other involves passing a 'user_agent' parameter. There is no explicit code linkage between these changes; they appear to be independent modifications that happen to be in the same file but serve different purposes."
        },
        {
            "sample_idx": 328,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a comment about localhost in the constants.py file, while Edit 1 adds an import statement for a lambda-related function in template_deployer.py. The changed lines reference entirely different symbols and concepts - one is about a localhost constant comment, the other is about importing a lambda handler function. There is no explicit code linkage, shared symbol reference, or structural dependency between these edits. They appear to be separate, independent changes that happen to be part of the same commit but serve different purposes."
        },
        {
            "sample_idx": 329,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve different symbols and different aspects of the code. Edit 0 removes a line that calculates `unet_dtype` from model parameters in the `load_unet_state_dict` function. Edit 1 adds a `dtype` parameter to the `load_unet` function signature. While both edits relate to dtype handling conceptually, they modify different functions (`load_unet_state_dict` vs `load_unet`) and the changed lines do not reference the exact same symbol. The removed `unet_dtype` variable in edit 0 and the added `dtype` parameter in edit 1 are different symbols in different scopes. There is no direct code dependency or explicit linkage between the specific lines being changed."
        },
        {
            "sample_idx": 330,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add an 'is_legacy_optimizer' field to config dictionaries in different optimizer classes' get_config() methods, but they reference different symbols and contexts. Edit 0 adds 'is_legacy_optimizer': False to the _BaseOptimizer class in the experimental optimizer module, while Edit 1 adds 'is_legacy_optimizer': True to the OptimizerV2 class in the v2 optimizer module. Although both edits involve the same field name and appear to be part of a coordinated change to distinguish legacy vs non-legacy optimizers, the changed lines reference different config dictionaries (self vs different classes) and different symbols entirely. This is a case of same field name in different scopes/contexts rather than the exact same symbol being referenced in both edits. The relationship is conceptual/thematic (both related to optimizer legacy status) but lacks direct code dependency or reference to the exact same symbol."
        },
        {
            "sample_idx": 332,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits are adding import statements to the same file, but they are importing completely different modules and symbols. Edit 0 imports 'AWS_REGION_US_EAST_1' from localstack.constants and 's3_listener' from localstack.services.s3. Edit 1 imports 'get_handler_file_from_name' from localstack.services.awslambda.lambda_api. There is no direct code dependency between these imports - they reference entirely different symbols and modules. The changed lines do not reference, assign, call, or import the exact same symbol. While both are import additions that might be part of the same development session, they lack the explicit code linkage required for a neighbour relationship. This is purely coincidental placement of import statements without any mechanical dependency between the specific symbols being imported."
        },
        {
            "sample_idx": 331,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new parameter 'vcs_rev' to the init_env function signature, and Edit 1 uses that exact same parameter by accessing 'env.vcs_rev' in the changed lines. The changed lines in Edit 1 explicitly reference the parameter added in Edit 0. This creates a direct code dependency where adding the parameter naturally prompts its usage, and using the parameter requires it to be defined in the function signature. Both edits reference the exact same symbol (the vcs_rev parameter) and either edit can be made first since Python allows referencing undefined attributes at parse time (would only fail at runtime)."
        },
        {
            "sample_idx": 333,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 adds a logger attribute assignment in the constructor, while Edit 1 modifies an error message string in a different method (gather_endpoints). The changed lines don't reference the same symbol - one involves 'self.logger' and 'JinaLogger', while the other involves a string concatenation for error messaging. There is no explicit code dependency, import relationship, or mirrored substitution pattern between these changes. They appear to be separate improvements to different parts of the same class without any mechanical prompt from one to the other."
        },
        {
            "sample_idx": 334,
            "yi": "0 before 1",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 removes the import line 'from localstack.services.s3 import s3_listener' while Edit 1 adds back the exact same import line 'from localstack.services.s3 import s3_listener'. Both edits reference the exact same symbol (s3_listener from localstack.services.s3). This creates a direct code dependency where removing the import in Edit 0 would make any usage of s3_listener undefined, and adding it back in Edit 1 would restore that symbol. However, since both edits can be staged in either order (removing then adding, or adding then removing), and either edit creates an immediate prompt for the other as the next mechanical step, this is a bi-directional relationship."
        },
        {
            "sample_idx": 335,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file but affect completely different aspects of the code with no direct code linkage. Edit 0 adds two method calls (self.init_column() and self.separator_line()) to the display method. Edit 1 reformats the parameters of a display_plugin call in the __display_header method by splitting them across multiple lines. The changed lines in each edit do not reference, assign, call, or import the same symbols. There is no explicit code dependency between adding init_column/separator_line calls and reformatting display_plugin parameters. This is purely a formatting change alongside a functional change with no mechanical relationship."
        },
        {
            "sample_idx": 337,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the function `unpause_external_data_schedule` from `posthog.warehouse.data_load.service`, while Edit 1 changes the signature of that exact same function by modifying its parameter from `external_data_source: ExternalDataSource` to `id: str`. The import in Edit 0 references the exact same symbol that is being modified in Edit 1. After making either edit, the other becomes the next immediate code-driven step - if you change the function signature, you need to update any imports/usage, and if you import a function with a changed signature, you need the definition to match. Both edits can be staged in either order without parser errors (the import will still work regardless of parameter signature), making this a bi-directional relationship."
        },
        {
            "sample_idx": 336,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits are within the same function `gather_endpoints` and appear to be part of error handling improvements, but they modify different aspects of error handling without any direct code dependency. Edit 0 modifies an existing error message string to be more specific about 'gathering endpoints', while Edit 1 adds a new exception handler block for general exceptions. The changed lines don't reference the same symbol - Edit 0 modifies a string concatenation within an existing exception handler, while Edit 1 adds an entirely new exception handling block. There's no explicit code linkage where one edit creates an immediate, mechanically obvious prompt for the other. They are conceptually related (both improving error handling in the same function) but lack the direct symbol reference or structural dependency required for neighbour classification."
        },
        {
            "sample_idx": 338,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 reformats the arguments of a parser.add_argument() call in main.py, while edit 1 adds an import statement for unicode_message in a different file (glances_curses.py). The changed lines do not reference, assign, call, or import the exact same symbol. There is no explicit code dependency between reformatting argument parameters and adding an import for unicode functionality. These appear to be separate maintenance tasks with no immediate, mechanically obvious prompt from one to the other."
        },
        {
            "sample_idx": 339,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code linkage. Edit 0 adds a command-line argument '--separator' that sets a 'enable_separator' destination, while Edit 1 calls a method 'separator_line()' in the display logic. Although both relate to separator functionality conceptually, the changed lines reference completely different symbols: Edit 0 references the argument parser and 'enable_separator' configuration, while Edit 1 references a 'separator_line' method. There is no explicit code dependency between the argument definition and the method call in the changed lines themselves - they are different symbols that happen to relate to the same feature."
        },
        {
            "sample_idx": 342,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and lack direct code linkage. Edit 0 adds a `use_legacy_optimizer=True` parameter to a call to `optimizers.deserialize()` in the LossScaleOptimizer class. Edit 1 adds logic inside the `deserialize` function to handle an `is_legacy_optimizer` config parameter. While both edits are conceptually related to legacy optimizer handling, the changed lines reference different symbols: Edit 0 references the parameter being passed to the function call, while Edit 1 references a config dictionary key within the function implementation. There is no direct symbol dependency between the specific lines changed - the parameter added in Edit 0 is handled by existing logic in the deserialize function (line 125), not by the new logic added in Edit 1. This is a thematic relationship without explicit code linkage between the exact same symbols in the changed lines."
        },
        {
            "sample_idx": 340,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 changes the function signature of `pause_external_data_schedule` from taking an `ExternalDataSource` parameter to taking a `str` parameter named `id`. Edit 0 calls this exact same function with `str(instance.id)` as an argument. After making edit 1 (the signature change), edit 0 becomes the immediate next step to update the call site to match the new signature. Both edits reference the exact same symbol `pause_external_data_schedule` - one defines it and the other calls it. This is a classic definition-usage relationship where either edit can be made first (both are syntactically valid in either order), but making either edit creates an immediate prompt for the other to maintain consistency."
        },
        {
            "sample_idx": 341,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and contexts. Edit 0 modifies a call to `optimizers.deserialize()` by adding a `use_legacy_optimizer=True` parameter in the LossScaleOptimizer class. Edit 1 adds a test assertion checking `config[\"is_legacy_optimizer\"]` in a completely different test file for OptimizerTest. While both edits relate to legacy optimizer functionality conceptually, the changed lines reference different symbols: Edit 0 references the `use_legacy_optimizer` parameter in a deserialize call, while Edit 1 references an `is_legacy_optimizer` config field in a test assertion. There is no direct code dependency or explicit symbol linkage between these specific changed lines - they are different symbols in different contexts, even though they share similar naming and conceptual purpose."
        },
        {
            "sample_idx": 343,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes the constructor signature of GCSFeedStorage by adding an 'acl' parameter, and Edit 1 updates a test that instantiates GCSFeedStorage to include the new 'acl' parameter. These edits reference the exact same symbol (the GCSFeedStorage constructor) and create a direct code dependency - after adding the parameter to the constructor signature, the test instantiation becomes the immediate next step to maintain code correctness. Both edits can be written and parsed in either order (the test would just have a runtime TypeError if run before the signature change), making this a bi-directional relationship rather than ordered."
        },
        {
            "sample_idx": 347,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the codebase. Edit 0 changes the QaEngineer constructor to use a parameter 'test_round_allowed' instead of a hardcoded value 5, while Edit 1 adds a new parameter 'run_tests' to the startup function signature. Although both edits relate to testing functionality conceptually, the changed lines reference completely different symbols - 'test_round_allowed' in the QaEngineer class versus 'run_tests' in the startup function. There is no direct code dependency, explicit symbol reference, or structural synchronization between these specific changes. The relationship is purely conceptual/thematic rather than based on explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 346,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds the parameter `is_self_hosted_billing` to the function signature of `compute_plan_parameters`, and Edit 1 uses that exact same parameter by passing it as an argument to `get_free_trial_days()` within the same function body. The changed lines reference the exact same symbol - the `is_self_hosted_billing` parameter. After adding the parameter in Edit 0, the natural next step would be to use it in the function body (Edit 1), and conversely, if trying to use the parameter in Edit 1 first, it would create an immediate need to add it to the signature in Edit 0. This is a classic definition-usage relationship within the same function scope, making both edits part of the same uninterrupted micro-task."
        },
        {
            "sample_idx": 344,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve completely different operations in different files with no code-level connection. Edit 0 removes comments from a function definition in numpy/core/_internal.py, while Edit 1 adds a test assertion for duplicate field names in a sort operation in numpy/core/tests/test_multiarray.py. The changed lines reference entirely different symbols and concepts - one involves comment removal from a `_newnames` function, the other involves adding a test for duplicate field handling in sorting. There is no explicit code dependency, shared symbol reference, or structural relationship between these changes. They appear to be independent modifications that happen to be part of the same larger changeset but have no direct mechanical linkage."
        },
        {
            "sample_idx": 345,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add the exact same parameter 'is_self_hosted_billing: bool = False' to two different functions in the same file. While they involve the same parameter name and type, they are adding this parameter to completely different function signatures (compute_plan_parameters and get_free_trial_days) with no direct code dependency between them. The changed lines don't reference the exact same symbol - they are creating new, separate parameters in different function scopes. There's no explicit code linkage where one edit creates an immediate prompt for the other, and no evidence that these functions directly call each other or that one change mechanically requires the other. This appears to be a thematic refactoring to add the same parameter to multiple functions, but without direct symbol linkage between the changed lines."
        },
        {
            "sample_idx": 350,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits demonstrate a classic function rename pattern where the exact same symbol is being modified. Edit 0 renames the function from 'get_vcs_rev_define' to 'get_vcs_rev', and Edit 1 updates the call site to use the new function name 'get_vcs_rev'. The changed lines in both edits reference the exact same function symbol - they are mechanically linked because renaming a function creates an immediate prompt to update all its call sites. Either edit can be made first (the code will parse in both cases, just with a NameError at runtime), making this a bi-directional relationship where each edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 351,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference the same configuration key 'is_legacy_optimizer' but in completely different contexts and different symbols. Edit 0 removes the 'is_legacy_optimizer' key from a config dictionary in the from_config method of _BaseOptimizer class, while Edit 1 adds a test assertion that checks if the 'is_legacy_optimizer' key equals True in a config from a different optimizer (SGD). The changed lines don't reference the exact same symbol - they involve different config dictionaries from different optimizer classes in different files. Edit 0 is handling cleanup of a config parameter during deserialization, while Edit 1 is testing that a config contains that parameter. There's no direct code dependency where making one edit creates an immediate prompt for the other - they're part of different logical flows (config cleanup vs. config testing) and involve different optimizer classes."
        },
        {
            "sample_idx": 349,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are not neighbours in mental flow. Edit 0 adds a new `on_kill` method to the `TrinoOperator` class that handles query cancellation, while Edit 1 modifies a SQL statement in a test file to add 'IF NOT EXISTS' to a CREATE TABLE statement. Although both edits involve the same codebase (Trino provider), they reference completely different symbols and serve different purposes. Edit 0 adds functionality to the operator class itself, while Edit 1 modifies test data. There is no direct code dependency, shared symbol reference, or synchronized pattern between the changed lines. The connection is only thematic (both relate to Trino), which according to the criteria should be labeled as 'no relation'."
        },
        {
            "sample_idx": 348,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a function `_test_error_exc_info()` at the module level, while Edit 1 changes a call from `self._test_error_exc_info()` to `_test_error_exc_info()`. Both edits reference the exact same symbol `_test_error_exc_info` - Edit 0 creates the function definition and Edit 1 updates the call site to use that function. This is a classic definition-usage relationship where making either edit creates an immediate, mechanically obvious prompt for the other. After defining the function in Edit 0, the call in Edit 1 becomes the natural next step to use it. Conversely, after changing the call in Edit 1, the function definition in Edit 0 becomes necessary. Since this is Python, both edits can be parsed and staged in either order (the call before definition would only cause a runtime NameError, not a parse error), making this bi-directional rather than ordered."
        },
        {
            "sample_idx": 354,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an 'acl' parameter to the __init__ method signature of GCSFeedStorage class. Edit 1 uses 'self.acl' in the blob.upload_from_file() call within the same class. This creates a direct code dependency where the acl parameter added in edit 0 needs to be stored as an instance variable (self.acl) to be used in edit 1. The changed lines reference the exact same symbol (the acl parameter/attribute), and making either edit creates an immediate prompt for the other - adding the parameter prompts storing and using it, while using self.acl prompts adding it to the constructor. Both edits can be staged in either order without parser errors, making this a bi-directional relationship."
        },
        {
            "sample_idx": 352,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file but affect completely different aspects of the code with no direct code dependency. Edit 0 reformats a conditional statement involving config options in the `_get_routes` method, while Edit 1 changes a docstring from 'Registers' to 'Register' in the `_add_browser_connection` method. The edits don't reference the same symbols, variables, functions, or have any structural dependency. There is no explicit code linkage between the changed lines - one is a formatting change to a conditional expression, the other is a grammar correction in documentation. Neither edit creates a mechanical prompt for the other."
        },
        {
            "sample_idx": 353,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of GCS feed storage functionality but do not reference the exact same symbol. Edit 0 adds a new configuration setting `FEED_STORAGE_GCS_ACL = None` in the default settings file. Edit 1 modifies a test to pass an `acl` parameter to the `GCSFeedStorage` constructor. While both relate to ACL functionality for GCS feed storage, the changed lines reference different symbols: Edit 0 defines a configuration constant `FEED_STORAGE_GCS_ACL`, while Edit 1 modifies a constructor call by adding an `acl` parameter (which is a local variable in the test, not the same symbol as the configuration setting). There is no direct code dependency between these specific changed lines - they are conceptually related but reference different symbols in different contexts."
        },
        {
            "sample_idx": 355,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not related by any direct code dependency or explicit symbol linkage. Edit 0 adds a class attribute 'query_id' to the TrinoHook class, while Edit 1 adds an import statement for 'TrinoQueryError' from the trino.exceptions module. The changed lines reference completely different symbols - 'query_id' (a class attribute) and 'TrinoQueryError' (an imported exception class). There is no direct code linkage between these symbols, no definition-usage relationship, and no mirrored substitution pattern. While both edits are in Trino-related files and may be part of the same feature development, their only connection is thematic/conceptual rather than an explicit code dependency at the locus of change."
        },
        {
            "sample_idx": 356,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 removes the `unet_dtype` parameter from the `load_unet_state_dict` function, while Edit 1 adds a `dtype=dtype` parameter when calling that same function. These edits reference the exact same function symbol and create a direct code dependency - removing the dtype parameter calculation in the function definition while adding dtype as an explicit parameter in the function call. After making either edit, the other becomes the immediate next mechanical step to maintain code consistency. The changed lines in both edits reference the same `load_unet_state_dict` function symbol, creating an explicit code linkage."
        },
        {
            "sample_idx": 358,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different symbols and contexts. Edit 0 adds a command-line argument '--separator' in the argument parser configuration in main.py, while Edit 1 removes a blank line in the unicode output module. There is no explicit code linkage between the changed lines - they don't reference, assign, call, or import the same symbol. The argument parser configuration and the unicode module formatting are separate concerns with no direct code dependency. The edits reference different symbols in different files and contexts."
        },
        {
            "sample_idx": 357,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of the BaseDeletionTask class. Edit 0 adds initialization of a skip_models attribute in the __init__ method, while Edit 1 adds a call to filter_relations method in the delete_bulk method. While both edits may be conceptually related to filtering functionality, the changed lines do not reference the exact same symbol. Edit 0 references 'skip_models' and Edit 1 references 'filter_relations'. There is no direct code dependency between these specific lines - neither edit creates an immediate, mechanically obvious prompt for the other. The skip_models attribute set in __init__ might eventually be used by filter_relations, but there's no explicit reference to the same symbol in both changed lines."
        },
        {
            "sample_idx": 359,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 is reformatting a function call in the curses output module by splitting arguments across multiple lines, while Edit 1 is removing a blank line in the unicode output module. The edits are in different files, affect different code constructs (function call formatting vs. whitespace), and there is no shared symbol, function, or structural element between them. They appear to be independent code formatting changes with no direct code dependency or linkage."
        },
        {
            "sample_idx": 361,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of the same class but do not have direct code linkage. Edit 0 adds a new method `add_preheated_report_context` that calls `_add_browser_connection`, while Edit 1 changes the docstring of `_add_browser_connection` from 'Registers' to 'Register'. Although Edit 0's new method calls the function whose docstring is modified in Edit 1, the changed lines themselves don't reference the exact same symbol - Edit 0's changed lines contain the method definition and call to `_add_browser_connection`, while Edit 1's changed lines only contain a docstring modification. The relationship is conceptual (both relate to browser connection functionality) rather than a direct code dependency where one edit creates an immediate prompt for the other. The docstring change appears to be a stylistic consistency fix rather than a mechanically required step after adding the new method."
        },
        {
            "sample_idx": 360,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same string literal 'is_legacy_optimizer' but they reference completely different contexts and serve different purposes. Edit 0 adds 'is_legacy_optimizer': False to a test configuration dictionary in a test method, while Edit 1 removes the 'is_legacy_optimizer' key from a config dictionary in the Adagrad optimizer's from_config method. The changed lines do not reference the same symbol - one is adding a key-value pair to a test config, the other is conditionally removing a key from a different config object in a different class and file. There is no direct code dependency between these edits, and they appear to be part of different aspects of handling legacy optimizer configuration rather than forming a mechanically obvious prompt for each other."
        },
        {
            "sample_idx": 362,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits reference the same string key 'is_legacy_optimizer' but in completely different contexts and for different purposes. Edit 0 reads from config['config']['is_legacy_optimizer'] in the deserialize function to determine optimizer type, while Edit 1 deletes 'is_legacy_optimizer' from a config dictionary in the Adagrad class's from_config method. These are different symbols in different scopes - one is a nested dictionary access and the other is a top-level config key. The changed lines don't reference the exact same symbol, and there's no direct code dependency between these two operations. They appear to be part of the same feature (handling legacy optimizer flags) but lack the explicit, immediate code linkage required for neighbour classification."
        },
        {
            "sample_idx": 363,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same configuration key 'is_legacy_optimizer' but in different contexts and files. Edit 1 adds the key to a config dictionary in the get_config method of OptimizerV2 class, while Edit 0 removes the key from a config dictionary in the from_config method of _BaseOptimizer class. However, these are different symbols in different scopes - the 'config' variable in each edit refers to different dictionary objects in different methods of different classes. While they may be conceptually related (one adds a flag, another removes it during deserialization), the changed lines do not reference the exact same symbol. The 'config' in edit 0 and 'config' in edit 1 are different local variables in different methods and classes, making them different symbols despite having the same name."
        },
        {
            "sample_idx": 366,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 modifies display logic in glances_curses.py by adding a conditional check around cloud statistics display, while Edit 1 adds new Unicode character mappings to glances_unicode.py. The changed lines reference entirely different symbols and concepts - one deals with conditional display logic using methods like get_stats_display_width() and display_plugin(), while the other adds dictionary entries for Unicode line characters. There is no shared symbol, no code dependency, and no structural relationship between these changes. They appear to be separate modifications to different parts of the codebase."
        },
        {
            "sample_idx": 364,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a reference to `crawler.settings['FEED_STORAGE_GCS_ACL']` in the changed lines, while Edit 1 defines the setting `FEED_STORAGE_GCS_ACL = None`. These edits reference the exact same symbol (the FEED_STORAGE_GCS_ACL setting). In Python, settings can be accessed even before they are explicitly defined in the default settings file - the settings system will handle undefined keys gracefully at runtime. Both edits can be written and parsed in either order without causing parser-level syntax errors. After making either edit, the other becomes the immediate, mechanically obvious next step to complete the feature implementation. This represents a bi-directional definition-usage relationship where both edits reference the same symbol."
        },
        {
            "sample_idx": 367,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a constant PREHEATED_REPORT_CONTEXT at the module level, while Edit 1 references this exact same constant in a docstring to document that a parameter can accept this value. The changed lines reference the exact same symbol - Edit 0 creates the constant definition and Edit 1 uses it in documentation. After defining the constant in Edit 0, it becomes available for reference in Edit 1's docstring. Since both edits can be parsed and staged in either order (the docstring reference doesn't create a syntax error if the constant isn't defined yet), this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 365,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a 'skip_models' parameter to the __init__ method signature of BaseDeletionTask class. Edit 1 adds 'self.skip_models' to the __repr__ method's return string. These edits reference the exact same symbol (skip_models) within the same class context. After adding the parameter to the constructor, it's natural to include it in the string representation for debugging/logging purposes. Either edit can be made first without causing parse errors - adding the parameter first means the repr will reference an attribute that exists, while adding the repr reference first will simply reference an attribute that doesn't exist yet (which is valid Python syntax, just a potential runtime AttributeError). Both edits are part of the same micro-task of adding skip_models functionality to the class."
        },
        {
            "sample_idx": 368,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts. Edit 0 modifies a function call to `get_free_trial_days()` by adding a `True` parameter in the `remote_server_plans_page` function. Edit 1 adds a new configuration variable `SELF_HOSTING_FREE_TRIAL_DAYS` in the settings file. While both edits are conceptually related to free trial functionality for self-hosted servers, the changed lines reference completely different symbols: Edit 0 references the `get_free_trial_days` function call, while Edit 1 defines a new configuration variable. There is no direct code dependency or explicit linkage between the exact symbols being modified in each edit's changed lines."
        },
        {
            "sample_idx": 369,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits involve handling the 'is_legacy_optimizer' key in configuration dictionaries, but they operate on different symbols in different contexts. Edit 0 removes 'is_legacy_optimizer' from a config parameter in the OptimizerV2.from_config method, while Edit 1 conditionally removes 'is_legacy_optimizer' from a new_config dictionary in a test method. The changed lines reference different variables (config vs new_config['config']) in completely different scopes and files. There is no direct code dependency or explicit symbol linkage between these edits - they are conceptually related as part of the same feature implementation but do not reference the exact same symbol."
        },
        {
            "sample_idx": 370,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (handling animation skipping based on start_at_animation_number) but they reference different symbols and contexts. Edit 0 removes logic from a configuration function that was setting skip_animations based on args.start_at_animation_number, while Edit 1 adds similar logic to a Scene class constructor that sets self.skip_animations based on self.start_at_animation_number. The changed lines reference different symbols: args.start_at_animation_number vs self.start_at_animation_number, and args.skip_animations vs self.skip_animations. These are different symbols in different scopes (function parameter vs instance attributes), even though they serve the same conceptual purpose. There is no direct code dependency between the exact same symbols in the changed lines."
        },
        {
            "sample_idx": 373,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 adds a 'cwd' parameter to the run_subprocess method signature, while Edit 0 adds a 'cwd' argument to a call to that exact same method. The changed lines reference the exact same symbol (run_subprocess method) and the exact same parameter (cwd). After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the parameter to the method signature, you need to update the call site to use it, and vice versa. This is a classic definition-usage relationship where both edits can be staged in either order (no parser error occurs), making it bi-directional."
        },
        {
            "sample_idx": 372,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Edit 0 defines a function `_test_error_exc_info()` at module level, while Edit 1 changes a method call from `self._test_error_exc_info()` to `_test_error_exc_info()`. Although both edits reference functions with the same name `_test_error_exc_info`, they are referencing different symbols: Edit 0 defines a module-level function, while Edit 1 changes from calling an instance method (self._test_error_exc_info) to calling the module-level function. The changed lines reference different symbols - one is a module-level function and the other was originally an instance method. This appears to be a refactoring where an instance method is being replaced by a module-level function, but the edits reference different symbols despite having the same name."
        },
        {
            "sample_idx": 371,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are both within the same method (CFGDenoiser.forward) but they modify completely different aspects of the code and reference different symbols. Edit 0 changes the condition from 'is_cfg_pp' to 'self.need_last_noise_uncond' and optimizes the tensor cloning operation. Edit 1 modifies a function call by adding a multiplication with 'self.cond_scale_miltiplier'. The changed lines in each edit reference entirely different symbols and variables - there is no shared symbol between 'self.need_last_noise_uncond' and 'self.cond_scale_miltiplier', nor between the different operations being performed. While both edits are in the same method, they represent independent changes with no direct code dependency or structural linkage between the specific lines being modified."
        },
        {
            "sample_idx": 374,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits are part of the same test method and work together to test the ACL functionality. Edit 0 adds 'FEED_STORAGE_GCS_ACL': None to the mock settings configuration, while Edit 1 adds an assertion to verify that storage.acl == 'publicRead'. These edits reference different aspects of the same test scenario - one sets up the mock configuration and the other verifies the expected behavior. However, they don't reference the exact same symbol in their changed lines. Edit 0 references the mock settings dictionary key 'FEED_STORAGE_GCS_ACL', while Edit 1 references the storage.acl attribute. While both are related to ACL functionality, the changed lines themselves don't reference the exact same symbol, and there's no direct code dependency where one edit creates an immediate prompt for the other."
        },
        {
            "sample_idx": 376,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code linkage. Edit 0 adds a 'weights' parameter to the Embedding class constructor in the implementation file. Edit 1 removes an entire test method 'test_quantize_on_unbuilt_layer' from the test file, which tests quantization functionality, not the weights parameter. The changed lines do not reference the same symbol - one adds a parameter to __init__, the other removes a test method about quantization. There is no explicit code dependency or synchronized pattern between adding a weights parameter and removing a quantization test. This is purely coincidental editing of the same codebase without mechanical linkage."
        },
        {
            "sample_idx": 375,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a command-line argument '--separator' with destination 'enable_separator' for enabling separator in the UI. Edit 1 adds Unicode character definitions for 'MEDIUM_LINE' and 'LOW_LINE' which appear to be visual separator elements. While both edits relate to UI separators conceptually, they do not reference the exact same symbol. The changed lines in edit 0 create a command-line option 'enable_separator', while the changed lines in edit 1 define Unicode character mappings 'MEDIUM_LINE' and 'LOW_LINE'. There is no direct code dependency where one edit's changed lines reference, assign, call, or import symbols from the other edit's changed lines. The connection is purely conceptual/thematic - both relate to separator functionality but involve different symbols and code constructs."
        },
        {
            "sample_idx": 377,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the codebase. Edit 0 modifies a call to `load_unet_state_dict` by adding a `dtype` parameter in the `load_unet` function in `comfy/sd.py`. Edit 1 adds a `weight_dtype` parameter to the INPUT_TYPES method of the UNETLoader class in `nodes.py`. While both edits are conceptually related to dtype/weight type functionality, the changed lines reference completely different symbols: `load_unet_state_dict` vs `INPUT_TYPES`. There is no direct code dependency between these specific changed lines - they don't reference, assign, call, or import the exact same symbol. The relationship is purely conceptual/thematic rather than creating an immediate, mechanically obvious code-driven prompt for one edit to follow the other."
        },
        {
            "sample_idx": 378,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different types of changes. Edit 0 adds 'schedule_exists' to what appears to be an import list or function parameter list, while Edit 1 changes a parameter from 'str(external_data_source.id)' to 'id' in a function call. The changed lines do not reference the exact same symbol - 'schedule_exists' in edit 0 is unrelated to the parameter change in the pause_schedule call in edit 1. There is no direct code dependency or structural linkage between adding 'schedule_exists' to a list and changing how an ID parameter is passed to pause_schedule. These appear to be separate, unrelated modifications within the same file."
        },
        {
            "sample_idx": 381,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are neighbours because they both involve the exact same GCSFeedStorage class and are part of synchronizing test assertions with implementation changes. Edit 0 modifies the GCSFeedStorage.from_crawler method to accept an additional parameter 'FEED_STORAGE_GCS_ACL', and edit 1 adds a corresponding test assertion to verify that the 'acl' attribute is properly set. The test assertion in edit 1 directly validates the behavior being implemented in edit 0 for the same class. This represents a test-production code synchronization pattern where the implementation change naturally prompts the corresponding test update as the next mechanical step. Both edits can be staged in either order since the test assertion won't cause a parse error if added before the implementation change."
        },
        {
            "sample_idx": 379,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds 'Response' to the import statement from fastapi, while Edit 1 adds a route that calls 'stop_route' function. While both edits are in the same file and both relate to FastAPI functionality, the changed lines reference different symbols. Edit 0 imports 'Response' but Edit 1 references 'stop_route' function and 'app.add_route' method. There is no direct code dependency between importing 'Response' and adding a stop route - the route addition doesn't explicitly use the newly imported 'Response' class in the changed lines. The connection is only conceptual (both relate to FastAPI web functionality) rather than an explicit code linkage where the exact same symbol is referenced in both edits."
        },
        {
            "sample_idx": 382,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution by adding the exact same import statement 'from . import __version__' in two different files. This represents a bulk-edit pattern where the same structural change (adding the same import line) is being applied to multiple files as part of a single, contiguous refactor. The edits target the same type of syntactic construct (import statements) with identical before\u2192after patterns. This creates a mirrored synchronization where either edit can be performed first, and both are part of the same uniform multi-file substitution operation."
        },
        {
            "sample_idx": 380,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a 'cwd' parameter to the run_subprocess method signature, while Edit 1 removes the line that defines the 'cwd' variable and uses the parameter directly in the Popen call. These edits reference the exact same symbol 'cwd' - Edit 0 introduces it as a parameter and Edit 1 removes the local definition to use the parameter instead. This creates a direct code dependency where the parameter added in Edit 0 is being utilized in Edit 1. Both edits can be staged in either order without causing parse errors (the method body referencing 'cwd' is valid regardless of whether it's a parameter or local variable), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step in refactoring the method to accept cwd as a parameter."
        },
        {
            "sample_idx": 383,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits both involve the same magic number 12.5 related to CFG++ scaling, but they reference different symbols and contexts. Edit 0 removes a line that divides cond_scale by 12.5 in the CFGDenoiser.combine_denoised method call, while Edit 1 adds a cond_scale_multiplier assignment using 1/12.5 in a completely different function (ddim_cfgpp). The changed lines don't reference the exact same symbol - one involves a local calculation with cond_scale parameter, the other sets a model attribute. While both are conceptually related to CFG++ scaling refactoring, there's no direct code dependency or explicit symbol linkage between the specific changed lines."
        },
        {
            "sample_idx": 385,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions in different files and do not reference the same symbol. Edit 0 removes a line that calculates `unet_dtype` in the `load_unet_state_dict` function in `comfy/sd.py`. Edit 1 adds a `weight_dtype` parameter to the `load_unet` method in the `UNETLoader` class in `nodes.py`. While both edits relate to data type handling for neural network models, they reference different symbols (`unet_dtype` vs `weight_dtype`) in different scopes and functions. There is no direct code dependency or explicit symbol linkage between the changed lines - they are conceptually related but do not reference the exact same symbol."
        },
        {
            "sample_idx": 384,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the code without direct code linkage. Edit 0 adds an 'acl' parameter to the GCSFeedStorage.__init__ method signature, while Edit 1 adds a 'FEED_STORAGE_GCS_ACL' setting to a test configuration dictionary. Although both relate to ACL functionality conceptually, the changed lines do not reference the exact same symbol - one modifies a constructor parameter list and the other modifies a settings dictionary. The parameter 'acl' in the constructor and the setting 'FEED_STORAGE_GCS_ACL' in the test are different symbols, even though they may be conceptually related. There is no direct, explicit code dependency between these specific changed lines that would make one edit immediately prompt the other as the next mechanical step."
        },
        {
            "sample_idx": 386,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 uses the attribute `self.cond_scale_miltiplier` in a calculation within the CFGDenoiser class's forward method. Edit 1 assigns a value to `model.cond_scale_miltiplier` in a separate function. While both edits reference an attribute with the same name 'cond_scale_miltiplier', they are in different contexts - one is within a class method using 'self' and the other is setting an attribute on a 'model' parameter in a standalone function. Without evidence that these refer to the exact same symbol (i.e., that the 'model' in edit 1 is specifically a CFGDenoiser instance and that this assignment is meant to set the attribute being used in edit 0), these appear to be different symbol references despite having the same attribute name. The edits could be related conceptually but lack the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 387,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an 'acl' parameter assignment in the GCSFeedStorage constructor, while Edit 1 updates a test call to GCSFeedStorage to include the 'acl' parameter. These edits reference the exact same symbol (the GCSFeedStorage constructor) and create a direct code dependency. After adding the acl parameter assignment in the constructor (edit 0), the test call (edit 1) would need to be updated to match the new signature, or vice versa. Both edits can be written and parsed in either order - the constructor can accept the parameter whether the test passes it or not, and the test can pass the parameter whether the constructor uses it or not. This creates a bi-directional relationship where either edit naturally prompts the other as the immediate next step."
        },
        {
            "sample_idx": 389,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no code dependency between them. Edit 0 reformats the arguments of a parser.add_argument() call in glances/main.py, changing the formatting but not the functionality. Edit 1 adds an import statement for unicode_message from glances.outputs.glances_unicode in a different file (glances/outputs/glances_curses.py). The changed lines do not reference the same symbol - one deals with argument parsing configuration while the other adds an import. There is no explicit code linkage, no shared symbol references, and no mechanical dependency where one edit would prompt the other as the next contiguous action."
        },
        {
            "sample_idx": 388,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code linkage. Edit 0 adds a 'weights' parameter to the Embedding class constructor in the main implementation file. Edit 1 removes an entire test method 'test_enable_lora_on_unbuilt_layer' from the test file. The removed test method does not reference the 'weights' parameter being added, nor does the 'weights' parameter addition have any direct relationship to the lora functionality being tested. The changed lines in each edit do not reference, assign, call, or import the same symbol. This is simply two unrelated changes happening to the same class - one adding a parameter to the constructor and another removing a test method for different functionality."
        },
        {
            "sample_idx": 390,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols in different contexts. Edit 0 adds a 'test_round_allowed' parameter to the QaEngineer.__init__ method signature, while Edit 1 adds a 'run_tests' parameter to a call to the 'startup' function. The changed lines reference completely different symbols - 'test_round_allowed' vs 'run_tests' - and there is no direct code dependency or explicit linkage between them. Even though both edits relate to testing functionality conceptually, they modify different functions in different files with different parameter names, making this a purely conceptual relationship rather than a direct code-driven one."
        },
        {
            "sample_idx": 392,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a `self.build()` call to the Embedding class constructor, which ensures the layer is built during initialization. Edit 1 removes a test that specifically checks for an error when trying to enable lora on an unbuilt layer. These edits reference different aspects of the same class but do not reference the exact same symbol in their changed lines. Edit 0 modifies the constructor implementation by adding a build() call, while Edit 1 removes an entire test method. The connection is conceptual (both relate to the building state of Embedding layers) but there is no direct code dependency or reference to the exact same symbol between the changed lines. The test removal appears to be a cleanup after the implementation change made the test obsolete, but this represents a thematic relationship rather than explicit code linkage."
        },
        {
            "sample_idx": 393,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same configuration key 'is_legacy_optimizer' but operate on different symbols and serve different purposes. Edit 1 adds 'is_legacy_optimizer': True to the config dictionary in OptimizerV2.get_config(), while Edit 0 removes the 'is_legacy_optimizer' key from the config in Optimizer.from_config(). Although they both reference the same string literal, they are operating on different config dictionaries in different classes (OptimizerV2 vs Optimizer) and different methods (get_config vs from_config). The changed lines do not reference the exact same symbol - they reference different config dictionary objects in different scopes. This appears to be part of a coordinated feature implementation but lacks direct code dependency between the exact same symbols in the changed lines."
        },
        {
            "sample_idx": 391,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 1 adds an import of `__version__` from the current package, and Edit 0 uses `__version__` in the user_agent dictionary. However, these are in different files (modeling_utils.py vs pipeline_utils.py) and there's no evidence that modeling_utils.py imports from pipeline_utils.py or that they share the same `__version__` symbol. Edit 0 references `__version__` without any visible import in the shown code, suggesting it may already be available in that scope through a different import path. The changed lines reference different symbols - Edit 1 imports `__version__` into pipeline_utils.py's namespace, while Edit 0 uses `__version__` in modeling_utils.py's namespace. These are different symbols despite having the same name, as they exist in different file scopes."
        },
        {
            "sample_idx": 394,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are unrelated. Edit 0 adds a new configuration setting SEND_CELERY_TASK_ERROR_EMAILS to celery/conf.py for controlling email notifications about task errors. Edit 1 modifies the return value in celery/worker.py to return ExcInfo(sys.exc_info()) instead of exc in an exception handling context. While both edits are conceptually related to error handling in Celery, the changed lines reference completely different symbols and there is no direct code dependency between them. The configuration setting added in edit 0 is not referenced, imported, or used in the changed line of edit 1, and vice versa. Neither edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 395,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (adding ACL parameter to GCSFeedStorage) but they reference different symbols and contexts. Edit 0 modifies the constructor signature of GCSFeedStorage class by adding an 'acl' parameter. Edit 1 modifies a mock settings dictionary in a test by adding a 'FEED_STORAGE_GCS_ACL' key. While both changes are conceptually related to the same ACL feature, the changed lines don't reference the exact same symbol - one changes a function parameter list, the other changes a dictionary literal in test configuration. There's no direct code dependency where making one edit creates an immediate, mechanically obvious prompt for the other at the symbol level."
        },
        {
            "sample_idx": 396,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code dependency. Edit 0 adds an import statement for 'JinaLogger' from 'jina.logging.logger'. Edit 1 modifies an error message string within a function, changing the text from 'Communication error with deployment' to 'Communication error while gathering endpoints with deployment'. The changed lines do not reference the same symbol - one involves importing JinaLogger and the other involves modifying a string literal in an error message. There is no explicit code linkage, structural dependency, or synchronized substitution pattern between these edits. They appear to be separate, unrelated changes that happen to be in the same file."
        },
        {
            "sample_idx": 398,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits are part of the same test method and work together to test the same functionality. Edit 0 adds 'FEED_STORAGE_GCS_ACL': 'publicRead' to the test settings dictionary, and Edit 1 adds the corresponding assertion 'assert storage.acl == 'publicRead'' to verify that the ACL setting is properly parsed and stored. This follows the test pattern of: setup test data \u2192 create object \u2192 assert expected behavior. Both edits reference the same concept ('publicRead' ACL value) and are part of testing the same feature (ACL parsing), but they don't reference the exact same symbol in their changed lines. The settings dictionary and the storage.acl attribute are different symbols, even though they're conceptually related in the test flow."
        },
        {
            "sample_idx": 397,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different functions and have no direct code linkage. Edit 0 modifies the internal logic of `load_unet_state_dict` to handle a `dtype` parameter, while Edit 1 modifies a call to `comfy.sd.load_unet` (a different function) to pass a `dtype` parameter. The changed lines reference different symbols - `load_unet_state_dict` vs `load_unet`. Even though both involve dtype handling, there is no explicit code dependency between the exact same symbol in both edits. The relationship is conceptual/thematic rather than based on direct symbol linkage."
        },
        {
            "sample_idx": 399,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and contexts. Edit 0 adds 'is_legacy_optimizer': True to a config dictionary in the OptimizerV2.get_config() method implementation. Edit 1 adds code to pop 'is_legacy_optimizer' from a test config dictionary in a completely different context - a test method that's comparing configurations. While both edits involve the same string 'is_legacy_optimizer', they are operating on different config dictionary objects in different scopes (production code vs test code), and there's no direct code dependency between the changed lines. The test code appears to be handling the removal of this field for comparison purposes, but this is conceptual/thematic linkage rather than explicit code linkage between the exact same symbol."
        },
        {
            "sample_idx": 401,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform the exact same textual substitution pattern: replacing 'for key, _ in X.items():' with 'for key in viewkeys(X):'. They target the same type of syntactic construct (for loop iteration patterns) within the same method (update_views) and appear to be part of a single, contiguous refactoring operation to optimize dictionary key iteration. This is a clear case of bulk-edit synchronization where both edits apply an identical before\u2192after pattern to the same construct type as part of one unified change."
        },
        {
            "sample_idx": 402,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits form a classic function signature change and call-site update pair for the exact same function `get_free_trial_days`. Edit 1 modifies the function signature by adding a parameter `is_self_hosted_billing: bool = False`, while Edit 0 updates the call site to pass this new parameter `get_free_trial_days(is_self_hosted_billing)`. The changed lines in both edits reference the exact same symbol - the `get_free_trial_days` function. After making either edit, the other becomes the immediate, mechanically obvious next step to maintain code consistency. Since Python allows both edits to be parsed and staged in either order (the call with extra argument works due to the default parameter, and the function definition can exist before being called), this is a bi-directional relationship."
        },
        {
            "sample_idx": 400,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 adds a comment to a line calling `self._init_actions([WriteTest])` within the `QaEngineer` class constructor in `metagpt/roles/qa_engineer.py`. Edit 1 adds a `run_tests` parameter to the `startup` function signature in `startup.py`. The changed lines do not reference, assign, call, or import the exact same symbol. While both edits are conceptually related to testing functionality, there is no explicit code dependency or structural relationship between the specific lines being modified. The `_init_actions` method call in the QaEngineer class and the parameter addition to the startup function are entirely separate symbols in different files and contexts."
        },
        {
            "sample_idx": 405,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 removes a line that increments `row_index` and calls `_set_dataframe_max_index` in the backtesting implementation. Edit 1 adds a test assertion that calls `get_analyzed_dataframe` on a different method of the dataprovider. While both edits involve the dataprovider object, they call completely different methods (`_set_dataframe_max_index` vs `get_analyzed_dataframe`) and there is no explicit code linkage between the changed lines. The edits affect different aspects of the dataprovider functionality and would not create an immediate, mechanically obvious prompt for each other. This appears to be coincidental changes to the same general area rather than a direct code dependency."
        },
        {
            "sample_idx": 403,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve different symbols and have no direct code linkage. Edit 0 removes code related to schema checking logic in an external data job workflow, including removal of calls to `aget_schema_by_id` and `schema_model.should_sync` checks. Edit 1 changes a parameter in a `pause_schedule` function call from `str(external_data_source.id)` to just `id` in a different file and function context. The changed lines do not reference the same symbols - they involve completely different functions (`aget_schema_by_id` vs `pause_schedule`), different variables (`schema_model` vs `id`), and different operational contexts (schema validation vs schedule pausing). There is no explicit code dependency or synchronized substitution pattern between these edits."
        },
        {
            "sample_idx": 404,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits are within the same test function and both reference the same variable 'tres' in their changed lines. Edit 0 adds a conditional check 'if tres > 0:' before executing the data slicing operation, while Edit 1 adds logic 'offset = 2 if tres == 0 else 1' that handles the case when tres == 0. These edits are complementary modifications that both handle the tres parameter's value in coordinated ways - one prevents the slicing operation when tres is 0, and the other adjusts the offset calculation based on whether tres is 0. Both changed lines explicitly reference the exact same symbol 'tres' and appear to be part of a single micro-task to handle the tres == 0 case properly in the test. Either edit could be made first, and after making either one, the other becomes a natural next step to complete the coordinated handling of the tres parameter."
        },
        {
            "sample_idx": 408,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different test functions (test_backtest_alternate_buy_sell vs test_backtest_multi_pair) and modify different aspects of the testing code. Edit 0 changes assertions about cached data length and adds validation for the last candle date, while Edit 1 adds a conditional check before slicing data. The edits don't reference the same symbols, variables, or functions - they are working with different local variables (analyzed_df vs data[pair]) and different test scenarios. There is no direct code dependency or structural linkage between the changed lines, only a conceptual relationship as both are testing-related modifications in the same file."
        },
        {
            "sample_idx": 407,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols despite having similar names. Edit 0 calls a function `external_data_workflow_exists()` and assigns its result to a variable named `schedule_exists`. Edit 1 imports a symbol named `schedule_exists` from a different module. The `schedule_exists` variable in edit 0 is a local variable within the update method, while the `schedule_exists` in edit 1 is an imported function/symbol. These are different symbols in different scopes - one is a local variable assignment, the other is an import statement for what appears to be a function. There is no direct code dependency between these changed lines, as they reference entirely different symbols that happen to share the same name."
        },
        {
            "sample_idx": 406,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite the similar naming. Edit 0 adds `self.vcs_rev = vcs_rev` to the `Env` class constructor in `glfw/glfw.py`, referencing a `vcs_rev` parameter that would need to be added to that constructor's signature. Edit 1 adds a `--vcs-rev` command line argument to an argument parser in `setup.py`. While both relate to VCS revision functionality, they reference completely different symbols in different contexts - one is an instance attribute assignment in a class constructor, the other is a command line argument definition. The changed lines do not reference the exact same symbol, and there is no direct code dependency between these specific changes. They are conceptually related but lack the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 410,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are in different files (celery/conf.py and celery/datastructures.py) and involve completely different functionality. Edit 0 adds a new configuration setting SEND_CELERY_TASK_ERROR_EMAILS with documentation, while Edit 1 changes a type check from Exception to ExcInfo in error handling code. The changed lines reference different symbols (SEND_CELERY_TASK_ERROR_EMAILS vs Exception/ExcInfo) and there is no direct code dependency, structural relationship, or synchronized pattern between them. They appear to be independent changes that happen to be part of the same broader development effort but lack any immediate, mechanically obvious code-driven linkage."
        },
        {
            "sample_idx": 409,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different files and different symbols. Edit 0 adds a comment to an existing line in the QaEngineer class's __init__ method, specifically about the _init_actions([WriteTest]) call. Edit 1 adds a new parameter 'run_tests' to the main() function signature in startup.py. There is no direct code dependency between these changes - they don't reference the same symbol, function, class, or variable. The changed lines don't have any explicit linkage where one edit creates an immediate, mechanically obvious prompt for the other. While both edits are conceptually related to testing functionality, this is only a thematic connection, not a direct code dependency as required by the criteria."
        },
        {
            "sample_idx": 411,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a new function `stop_route` that sets `shared.state.server_command = \"stop\"`. Edit 1 adds a print statement inside an existing conditional block that checks `if server_command == \"stop\"`. While both edits relate to the \"stop\" functionality, they don't reference the exact same symbol in their changed lines. Edit 0 assigns to `shared.state.server_command` while Edit 1 checks a local variable `server_command`. These are different symbols (one is an attribute access, the other is a local variable), and there's no direct code dependency between the changed lines themselves. The relationship is conceptual/thematic rather than an explicit code linkage."
        },
        {
            "sample_idx": 414,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits rename parameters in function signatures, but they are changing parameters in completely different functions in different files. Edit 0 changes the parameter name from 'endpoint' to 'email_type' in the function 'one_click_unsubscribe_link', while Edit 1 changes parameter names from 'type' and 'token' to 'email_type' and 'confirmation_key' in the function 'email_unsubscribe'. While both edits happen to introduce a parameter named 'email_type', these are different symbols in different function scopes. There is no direct code dependency between these changed lines - they don't reference, call, or import the exact same symbol. The relationship is purely coincidental naming, not an explicit code linkage."
        },
        {
            "sample_idx": 412,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol `self.tty_fd` in their changed lines. Edit 0 modifies the assignment to `self.tty_fd` in the `__enter__` method, while Edit 1 adds a new method `wait_till_read_available` that uses `self.tty_fd`. Since both edits can be written and parsed in either order (there's no syntax dependency), and both reference the same instance attribute symbol, they form a bi-directional relationship where making either edit creates a natural prompt for the other as part of working with the same `tty_fd` attribute."
        },
        {
            "sample_idx": 413,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a variable `acl = 'publicRead'` and edit 1 uses that exact same variable `acl` in the `predefined_acl=acl` parameter. Both edits are within the same test method and reference the exact same symbol. After adding the variable definition in edit 0, the natural next step would be to use it in the function call (edit 1). Similarly, if modifying the function call to use the acl parameter (edit 1), the variable would need to be defined (edit 0). This is a clear definition-usage relationship within the same scope where both changed lines reference the exact same symbol."
        },
        {
            "sample_idx": 416,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits reference the exact same symbol 'is_legacy_optimizer' in the config dictionary. Edit 0 adds 'is_legacy_optimizer': True to the config in get_config(), while Edit 1 removes 'is_legacy_optimizer' from the config in from_config(). This creates a direct code dependency where the key added in one method needs to be handled/removed in the corresponding deserialization method. Both edits are part of implementing a complete serialization/deserialization cycle for the same configuration key. Either edit can be made first without causing parse errors, but making either edit creates an immediate, mechanically obvious prompt for the other to complete the serialization cycle handling."
        },
        {
            "sample_idx": 418,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite having similar names. Edit 0 removes a line that sets 'preview' in a configuration dictionary within the get_configuration function. Edit 1 adds code that references 'self.start_at_animation_number' in the Scene class constructor. While both edits are related to animation configuration, the changed lines reference completely different symbols - 'preview' in edit 0 and 'self.start_at_animation_number' in edit 1. There is no direct code dependency or reference to the exact same symbol between the changed lines. The relationship is only conceptual/thematic (both relate to animation configuration) but lacks the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 417,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same configuration key 'is_legacy_optimizer' but they are setting and testing different values in completely different contexts. Edit 0 adds 'is_legacy_optimizer': False to the experimental optimizer's config, while Edit 1 tests that the legacy optimizer's config has 'is_legacy_optimizer': True. While both reference the same configuration key name, they are dealing with different optimizer classes (experimental vs legacy) and different expected values. The changed lines don't reference the exact same symbol - they reference the same string key but in different optimizer implementations. This is a case of same name, different contexts, which according to the criteria should be labeled as 'no relation'."
        },
        {
            "sample_idx": 419,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 modifies a call to `pause_external_data_schedule` by changing the argument from `job.pipeline` to `str(job.pipeline.id)`, while Edit 1 adds a new function `schedule_exists` that is unrelated to the `pause_external_data_schedule` function being modified in Edit 0. The changed lines do not reference the same symbol - one modifies an existing function call's argument, while the other defines a completely new function. There is no explicit code linkage between these edits."
        },
        {
            "sample_idx": 422,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours because they reference different symbols despite both involving ACL-related changes. Edit 0 adds 'FEED_STORAGE_GCS_ACL': 'publicRead' to a settings dictionary in the test_parse_settings method, while Edit 1 adds an 'acl' parameter to a GCSFeedStorage constructor call in the test_store method. The changed lines reference different symbols: Edit 0 references a dictionary key 'FEED_STORAGE_GCS_ACL' while Edit 1 references a variable 'acl'. Although both are conceptually related to ACL functionality, there is no direct code dependency or explicit symbol linkage between the exact symbols being modified in each edit's changed lines."
        },
        {
            "sample_idx": 421,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats argument parsing code for command-line options in the main module, splitting a single line into multiple lines for better readability. Edit 1 modifies display logic in the curses output module, adding a conditional check before displaying cloud statistics. The changed lines reference entirely different symbols and code structures - one deals with argument parser configuration while the other handles UI display logic. There is no shared symbol, function, class, or variable between the edits, and no direct code dependency or synchronized pattern. The edits operate in different files, different classes, and different functional domains with no explicit code linkage."
        },
        {
            "sample_idx": 420,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 removes the method `_test_error_exc_info` from the class, while Edit 1 changes a call from `self._test_error_exc_info()` to `_test_error_exc_info()`. These edits reference the exact same symbol and create a direct code dependency. If Edit 0 is applied first (removing the method), then Edit 1's change from instance method call to function call makes sense as the next mechanical step. However, if Edit 1 is applied first, it would create an immediate prompt to either define the function or remove the method definition. Since both edits can be parsed and staged in either order (Edit 1 would just result in a NameError at runtime, not a parse error), and both reference the same symbol with one edit removing the method definition and the other updating its usage, this represents a bi-directional relationship where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "sample_idx": 423,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and serve different purposes. Edit 0 modifies error handling logic in `_newnames` function to check for duplicate field names and references variables like `name` and `seen`. Edit 1 adds an import for `assert_raises_regex` to the test file imports. There is no direct code linkage between the changed lines - they don't reference the same symbols, and there's no immediate mechanical dependency where one edit creates a prompt for the other. While both edits might be part of the same feature development conceptually, the changed lines themselves have no explicit code relationship."
        },
        {
            "sample_idx": 424,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 adds the 'is_legacy_optimizer': True key-value pair to the config dictionary in the get_config() method of the Optimizer class. Edit 0 updates documentation to show that this same 'is_legacy_optimizer': True field now appears in the serialized output. The documentation in edit 0 is showing the expected output format that results from the implementation change in edit 1. Since the get_config() method is what provides the 'config' portion of the serialized output, edit 1 must be implemented first for the documentation in edit 0 to be accurate. However, both edits can be written and parsed independently - the documentation could be updated before or after the implementation without causing syntax errors. This represents a bi-directional relationship where both edits reference the exact same configuration field and either edit naturally prompts the other as the next step in keeping documentation synchronized with implementation."
        },
        {
            "sample_idx": 425,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an import statement 'import os' at the top of the function, while Edit 1 adds a line that uses 'os.path.realpath', 'os.path.join', and 'os.pardir' - all referencing the exact same 'os' module symbol that was imported in Edit 0. This creates a direct import-usage relationship where both edits reference the same symbol. In Python, usage before import is allowed at parse time (would only fail at runtime with NameError), so either edit can be staged first, making this bi-directional. After making either edit, the other becomes the immediate next mechanical step to complete the import-usage pair."
        },
        {
            "sample_idx": 426,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds 'Response' to the import statement from fastapi, and Edit 1 uses that exact same 'Response' symbol in a new function. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. After making the import edit, using Response becomes immediately available, and after adding the usage, the import becomes necessary. Both edits can be staged in either order without parser errors (the usage would only fail at runtime if the import wasn't present), making this a bi-directional relationship according to the Python-specific guidance."
        },
        {
            "sample_idx": 415,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of the GCS feed storage functionality but do not reference the exact same symbol. Edit 0 adds 'self.acl = acl' to the GCSFeedStorage constructor, while Edit 1 adds 'FEED_STORAGE_GCS_ACL': None to a mock settings dictionary in a test. Although both relate to ACL functionality, the changed lines reference different symbols: 'self.acl' (an instance attribute) in edit 0 and 'FEED_STORAGE_GCS_ACL' (a settings key) in edit 1. There is no direct code dependency between these specific changed lines - they are conceptually related but do not create an immediate, mechanically obvious prompt for each other."
        },
        {
            "sample_idx": 427,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a line to assign `self.query_id = cur.stats[\"queryId\"]` in the TrinoHook's run method, which is adding functionality to capture query IDs. Edit 1 modifies a SQL statement in a test file to add 'IF NOT EXISTS' to a CREATE TABLE statement. The changed lines reference entirely different symbols and code constructs - one is adding a Python attribute assignment, the other is modifying SQL syntax. There is no direct code dependency, no shared symbol references, and no mechanical prompt from one edit to the other. They appear to be separate, independent changes with no explicit code linkage between the changed lines."
        },
        {
            "sample_idx": 428,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different files and different symbols despite both mentioning 'from django.conf import settings'. Edit 0 adds an 'import os' statement in devserver.py (the django.conf import is just context), while Edit 1 removes a 'from django.conf import settings' import in http.py. The changed lines reference completely different symbols - 'os' in edit 0 and 'django.conf.settings' in edit 1. There is no direct code dependency, shared symbol reference, or synchronized pattern between these edits. They appear to be independent changes in separate files with no mechanical linkage."
        },
        {
            "sample_idx": 430,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits modify the exact same method call `blob.upload_from_file()` by adding the same parameter `predefined_acl`. Edit 0 changes the implementation in the production code, while Edit 1 updates the corresponding test assertion to match the new method signature. The changed lines in both edits reference the exact same method call with identical parameter additions. This creates a bi-directional relationship where either edit can be made first, but after making one, the other becomes the immediate next step to maintain test-code synchronization. The test assertion must match the implementation for the test to pass, and both edits are part of the same micro-task of adding ACL support to the GCS upload functionality."
        },
        {
            "sample_idx": 429,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different symbols and operations. Edit 0 removes an import of 'aget_schema_by_id' from the external_data_job.py file, while Edit 1 adds a new function definition 'external_data_workflow_exists' in the service.py file. The changed lines reference entirely different symbols - one is removing an import statement for 'aget_schema_by_id' and the other is defining a new function 'external_data_workflow_exists'. There is no direct code dependency, shared symbol reference, or structural relationship between these changes. They appear to be independent modifications in different files affecting different parts of the codebase."
        },
        {
            "sample_idx": 431,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an import for the 'time' module at the top of the file. Edit 1 uses that exact same 'time' module in a new line of code within the queryOutputLength function (specifically 'time.time() - start'). The changed lines reference the exact same symbol - the 'time' module. After adding the import in edit 0, the usage in edit 1 becomes immediately possible. Conversely, if edit 1 were made first without the import, it would result in a NameError at runtime when the code tries to access the undefined 'time' symbol. However, since Python allows referencing undefined symbols at parse time (they only fail at runtime/import time), both edits can be written and staged in either order without causing parser errors. This is a classic import-usage relationship within the same file."
        },
        {
            "sample_idx": 432,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 imports 'ExcInfo' from 'celery.worker' module, while Edit 1 uses 'ExcInfo' in a return statement. However, these edits reference different instances of ExcInfo usage. Edit 0 imports ExcInfo in the datastructures.py file within the TaskProcessQueue class, but there's no evidence in the changed lines that this imported ExcInfo is actually used in the shown code change. Edit 1 uses ExcInfo in worker.py, but this appears to be using an already available ExcInfo (likely from an existing import or definition within that file). The changed lines don't reference the exact same symbol - Edit 0 creates a new import of ExcInfo in datastructures.py, while Edit 1 uses ExcInfo that's already available in worker.py. There's no direct code dependency between these specific changed lines, as they operate on different ExcInfo symbols in different files and contexts."
        },
        {
            "sample_idx": 435,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in completely different files and contexts. Edit 0 adds a comment to the QaEngineer class initialization in metagpt/roles/qa_engineer.py, while Edit 1 modifies a function call in startup.py to add a 'run_tests' parameter. The changed lines reference entirely different symbols - one references WriteTest (an action class) and the other references a startup function call with different parameters. There is no direct code dependency, shared symbol reference, or structural relationship between these changes. They appear to be independent modifications made as part of different aspects of the codebase."
        },
        {
            "sample_idx": 434,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are adding a 'vcs_rev' parameter to different parts of the same build system. Edit 0 adds 'vcs_rev: str = \"\"' as a parameter to the init_env function signature, while Edit 1 adds '--vcs-rev' as a command-line argument option. However, the changed lines do not reference the exact same symbol - one is adding a function parameter and the other is adding a command-line argument parser option. While they are conceptually related (both handling VCS revision functionality), there is no direct code dependency or explicit symbol linkage between the specific lines being changed. The parameter 'vcs_rev' in the function signature and the argument '--vcs-rev' in the parser are different symbols in different scopes, even though they serve the same conceptual purpose."
        },
        {
            "sample_idx": 436,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are in different files and involve different functionality. Edit 0 adds a break condition when no data is read from `tty.tty_fd` in the `send_text.py` file. Edit 1 adds a new method `wait_till_read_available()` to the `TTYIO` class in `utils.py`. While both edits involve TTY operations, the changed lines don't reference the exact same symbol. Edit 0 works with `tty.tty_fd` (where `tty` is likely an instance of `TTYIO`), and Edit 1 adds a method to the `TTYIO` class itself. There's no direct code dependency between these specific changes - they don't reference, assign, call, or import the exact same symbol. The connection is only conceptual (both relate to TTY handling) rather than an explicit code linkage."
        },
        {
            "sample_idx": 433,
            "yi": "bi-directional",
            "pred": "1 before 0",
            "pred_reason": "Edit 0 removes an import of 'GlancesPassword' from glances_passwordlist.py, while Edit 1 changes the class definition in that same file from 'class GlancesPassword(object):' to 'class GlancesPasswordList(GlancesPassword):'. These edits reference the exact same symbol 'GlancesPassword' - Edit 0 removes the import of this class, and Edit 1 modifies the definition of this same class. However, Edit 1 creates a circular inheritance issue (GlancesPasswordList inheriting from GlancesPassword while seemingly replacing it) and the import removal in Edit 0 would need to happen after the class restructuring in Edit 1 is complete. The class definition change must occur before the import can be safely removed, as removing the import first would break any existing references. This represents a definition-usage relationship where the definition change must precede the import removal."
        },
        {
            "sample_idx": 437,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 changes a call to TTYIO() constructor by adding a parameter 'read_with_timeout=False', while Edit 1 adds a new method 'wait_till_read_available' to the TTYIO class. These edits reference different aspects of the TTYIO class - one modifies how the class is instantiated and the other adds a new method. There is no direct code linkage between the changed lines: the constructor call in Edit 0 does not reference the new method being added in Edit 1, and the new method in Edit 1 does not reference the constructor parameter being added in Edit 0. While both edits modify the same TTYIO class, they affect different symbols (constructor vs. a new method) and neither edit creates an immediate, mechanically obvious prompt for the other. The relationship appears to be conceptual/thematic rather than having explicit code dependency between the exact same symbols."
        },
        {
            "sample_idx": 439,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new parameter 'update=True' to the folder_get method signature, and Edit 1 uses that exact same parameter by passing 'update=update' to the pull_path call within the same method body. This creates an immediate, mechanically obvious code dependency - after adding the parameter to the signature, the next natural step is to thread that parameter through to the internal method call. Both edits reference the exact same symbol (the 'update' parameter) and form a contiguous micro-task of parameter threading within the same function. Either edit could be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to complete the parameter threading."
        },
        {
            "sample_idx": 440,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code dependency. Edit 0 modifies a function call to `compute_plan_parameters` by adding an `is_self_hosted_billing` parameter in the `corporate/lib/stripe.py` file. Edit 1 adds a new configuration constant `SELF_HOSTING_FREE_TRIAL_DAYS` in the `zproject/default_settings.py` file. While both edits are conceptually related to self-hosted billing functionality, the changed lines do not reference the same symbol - one is a function call parameter addition and the other is a configuration constant definition. There is no explicit code linkage where one edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 438,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions in different files and do not reference the exact same symbols. Edit 0 modifies an existing debugMsg calculation in __goInference function, while Edit 1 adds new code (start variable, count capture, and debugMsg creation) in the resume function. Although both edits involve similar timing/logging patterns and use similarly named variables (debugMsg, start, count), they are creating or modifying different symbols in different scopes. The debugMsg in edit 0 and the debugMsg in edit 1 are different variables in different functions. There is no direct code dependency where one edit's changed lines reference the exact same symbol as the other edit's changed lines."
        },
        {
            "sample_idx": 441,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds an import of the 'operator' module to glances/compat.py, while Edit 1 modifies an import statement from glances.compat to add 'viewkeys' to the imported symbols. These edits reference completely different symbols - Edit 0 imports the 'operator' module while Edit 1 imports 'viewkeys' from the compat module. There is no direct code dependency or linkage between importing 'operator' and importing 'viewkeys'. The fact that both involve import statements and one file imports from the other file's module does not create a mechanical code-driven prompt between these specific changes. The changed lines reference different symbols entirely."
        },
        {
            "sample_idx": 442,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a class attribute 'query_id = \"\"' to the TrinoHook class, and Edit 1 assigns a value to 'self.query_id' within a method of the same class. Both edits reference the exact same symbol (the query_id attribute of the TrinoHook class). Edit 0 creates the attribute definition, and Edit 1 uses that attribute by assigning to it. This creates an immediate, mechanically obvious code-driven relationship where defining the attribute naturally prompts its usage, and vice versa. Both edits can be staged in either order without causing parse errors - the attribute can be assigned to before being explicitly declared (Python allows dynamic attribute creation), and the declaration can exist before the assignment. This is a classic definition-usage relationship for the same symbol within the same class."
        },
        {
            "sample_idx": 443,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same conceptual change (handling row indexing and candle offset logic in backtesting), but they reference different symbols and contexts. Edit 0 adds a comment about row treatment and signal shifting in the main backtesting logic, while Edit 1 modifies test assertions by introducing an 'offset' variable calculation. The changed lines don't reference the exact same symbol - Edit 0 deals with row indexing in the backtesting loop, while Edit 1 deals with test validation logic using a newly introduced 'offset' variable. Although both relate to the same feature (backtesting row/candle handling), there's no direct code dependency or explicit symbol linkage between the specific lines that were changed."
        },
        {
            "sample_idx": 444,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different functions with no direct code linkage. Edit 0 adds an 'is_self_hosted_billing' parameter to the 'compute_plan_parameters' function signature. Edit 1 modifies a call to 'get_free_trial_days' by adding a boolean argument 'True'. The changed lines reference completely different symbols - one modifies 'compute_plan_parameters' and the other modifies a call to 'get_free_trial_days'. There is no explicit code dependency, import relationship, or synchronized substitution pattern between these changes. While both edits may be conceptually related to self-hosted billing functionality, there is no direct, mechanical code linkage between the exact symbols being modified in each edit."
        },
        {
            "sample_idx": 445,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different files and different code constructs with no shared symbols or dependencies. Edit 0 reformats the arguments of a parser.add_argument() call in glances/main.py, while Edit 1 removes a comment line in glances/outputs/glances_curses.py. There is no explicit code linkage between the changed lines - they don't reference, assign, call, or import the same symbol. The edits are unrelated code maintenance tasks that happen to be part of the same changeset but have no direct syntactic or structural dependency."
        },
        {
            "sample_idx": 446,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they both reference the exact same symbol 'skip_models' within the same function context. Edit 0 adds 'skip_models' as a parameter to the __init__ method signature, and Edit 1 uses that exact same parameter in the method body by assigning it to self.skip_models. This creates an immediate, mechanically obvious code-driven prompt - after adding the parameter in the signature, the natural next step is to use it in the method body, and vice versa. Both edits can be staged in either order without causing parse errors (the parameter can exist without being used, and the usage line references a parameter that could be added). This is a classic parameter addition with immediate usage pattern within the same function scope."
        },
        {
            "sample_idx": 449,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same function `_newnames` but they modify completely different aspects of the code. Edit 0 removes comment lines above the function definition, while Edit 1 adds a new variable assignment `seen = set()` inside the function body. There is no direct code dependency between removing comments and adding a variable declaration - the comments don't reference the `seen` variable, and the `seen` variable doesn't depend on the comments. The edits don't reference the same symbol, and neither edit creates a mechanical prompt for the other. They appear to be separate, independent changes that happen to be in the same function."
        },
        {
            "sample_idx": 447,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits add the exact same key-value pair 'is_legacy_optimizer': True to configuration dictionaries, but they are adding this to different symbols in different contexts. Edit 0 modifies a docstring example showing the output of tf.keras.optimizers.serialize(), while Edit 1 modifies the actual get_config() method implementation in the OptimizerV2 class. Although both involve the same configuration key name, the changed lines reference different symbols - one is documentation text and the other is actual implementation code. There is no direct code dependency between these two locations, and neither edit creates an immediate, mechanically obvious prompt for the other. This appears to be part of a broader feature implementation but lacks the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 448,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve parameter name changes in different contexts that are not directly linked by explicit code dependencies. Edit 0 changes a function parameter from 'endpoint' to 'email_type' in the one_click_unsubscribe_link function. Edit 1 changes URL pattern parameter names from 'type' to 'email_type' and 'token' to 'confirmation_key' in a Django URL configuration. While both edits involve the name 'email_type', they reference different symbols in different scopes - one is a function parameter and the other is a URL pattern parameter. The changed lines do not reference the exact same symbol, and there is no direct code dependency where one edit creates an immediate prompt for the other. The relationship appears to be part of a broader refactoring effort but lacks the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 450,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts. Edit 0 adds a local variable 'cwd' within the devserver function in devserver.py, while Edit 1 adds a 'cwd' parameter to the run_subprocess method signature in http.py. Although both involve identifiers named 'cwd', they are different symbols in different scopes and files. The changed lines do not reference the exact same symbol - one creates a local variable while the other adds a method parameter. There is no direct code dependency or explicit linkage between these specific changed lines."
        },
        {
            "sample_idx": 452,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite having similar names. Edit 0 removes a line that references a 'start' variable within the __goInference function in inject.py, while Edit 1 adds a line that assigns to a 'start' variable within the queryOutputLength function in resume.py. Although both variables have the same name 'start', they are in different functions and different files, making them completely different symbols. The changed lines do not reference the exact same symbol, and there is no direct code dependency or linkage between them. This is purely coincidental naming similarity without any explicit code relationship."
        },
        {
            "sample_idx": 453,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats argument parsing code in main.py by splitting a single-line parser.add_argument() call into multiple lines for better readability. Edit 1 adds a method call to self.separator_line() in a display function within the curses output module. The changed lines reference entirely different symbols - Edit 0 involves parser.add_argument parameters while Edit 1 involves a separator_line method call. There is no shared symbol, no code dependency, and no structural relationship between these changes. They appear to be independent code improvements in different parts of the codebase."
        },
        {
            "sample_idx": 451,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits modify calls to the same function `get_free_trial_days()` by adding the same parameter `is_self_hosted_billing`. This represents a synchronized update pattern where the function signature was changed to accept a new parameter, and all call sites need to be updated accordingly. The edits reference the exact same symbol (the `get_free_trial_days` function) and both are part of the same mechanical refactoring task - updating all callers to pass the new required parameter. Either edit could be made first, and after making either one, the other becomes an immediate, mechanically obvious next step to complete the uniform substitution pattern."
        },
        {
            "sample_idx": 454,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different code elements with no direct code dependency or linkage. Edit 0 reformats the arguments of an `add_argument` call for an IRQ module command-line option in the main.py file, while Edit 1 adds an import statement for `unicode_message` in a different file (glances_curses.py). The changed lines in each edit reference entirely different symbols - one involves argument formatting for 'enable_irq' option, the other involves importing 'unicode_message'. There is no explicit code dependency, no shared symbol references, and no structural synchronization between these edits. They appear to be independent changes that happen to be part of the same codebase but have no mechanical relationship that would make one edit prompt the other as the next immediate step."
        },
        {
            "sample_idx": 455,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 modifies the load_unet_state_dict function to accept and handle a 'dtype' parameter, adding conditional logic to use either the provided dtype or compute it via model_management.unet_dtype(). Edit 1 updates the call site to pass the dtype parameter when calling load_unet_state_dict(). These edits reference the exact same function symbol and create a direct signature-caller relationship where the function signature change in edit 0 enables the parameter passing in edit 1. Either edit can be staged first without causing parse errors - the function call with the new parameter will work even if the function hasn't been updated yet (though it may cause a runtime TypeError), and the function can accept the parameter even if no callers are passing it yet."
        },
        {
            "sample_idx": 456,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the function `external_data_workflow_exists` from `posthog.warehouse.data_load.service`, while Edit 1 defines that exact same function in the service module. The changed lines reference the exact same symbol - Edit 0's import line explicitly references `external_data_workflow_exists` and Edit 1's definition creates that same symbol. After making either edit, the other becomes the immediate next step: if you define the function first, you can then import it; if you import it first, you need to define it to avoid a runtime ImportError. Since Python allows importing undefined symbols at parse time (they only fail at runtime/import time), both edits can be staged in either order, making this a bi-directional relationship."
        },
        {
            "sample_idx": 457,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of the TTYIO class and its usage, but they don't reference the exact same symbol. Edit 0 adds a call to `tty.wait_till_read_available()` method on a TTYIO instance, while Edit 1 adds an `__init__` method to the TTYIO class with a `read_with_timeout` parameter. The changed lines don't reference the same symbol - Edit 0 references a `wait_till_read_available` method while Edit 1 defines constructor parameters. There's no direct code dependency between these specific changes, and they could be implemented independently without one mechanically requiring the other as the immediate next step."
        },
        {
            "sample_idx": 459,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different symbols and have no direct code linkage. Edit 0 removes a `recv` method from the `QaEngineer` class in `metagpt/roles/qa_engineer.py`, while Edit 1 adds a `run_tests` parameter to an `asyncio.run(startup(...))` call in `startup.py`. The changed lines reference entirely different symbols: one involves a method definition removal, the other involves adding a parameter to a function call. There is no explicit code dependency, shared symbol reference, or structural synchronization between these edits. They appear to be part of different aspects of a codebase modification with no immediate, mechanically obvious prompt relationship."
        },
        {
            "sample_idx": 458,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a new parameter 'test_round_allowed=5' to the QaEngineer constructor signature. Edit 1 modifies how QaEngineer is instantiated in the startup function, but the QaEngineer() call in edit 1 does not pass any arguments and therefore does not reference the new parameter added in edit 0. While both edits involve the QaEngineer class, the changed lines do not reference the exact same symbol - edit 0 adds a parameter to the constructor signature, but edit 1's changed lines only show the QaEngineer() instantiation without any parameters. There is no direct code dependency or explicit linkage between the specific changes made in each edit."
        },
        {
            "sample_idx": 461,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different aspects of the 'is_legacy_optimizer' configuration key. Edit 0 removes the key from the config in the from_config method to prevent it from being passed as a constructor argument, while Edit 1 adds a test assertion to verify the key exists in the config returned by get_config(). However, there is no direct code dependency between these specific changed lines - they don't reference the exact same symbol or create an immediate mechanical prompt for each other. The test assertion checks for the presence of the key in get_config() output, while the production code removes it during deserialization in from_config(). These are separate operations on the same configuration key but don't create a direct code linkage where one edit immediately prompts the other as the next contiguous action."
        },
        {
            "sample_idx": 460,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they implement complementary parts of a serialization-deserialization system for the same data field. Edit 0 adds 'is_legacy_optimizer' to the serialized output in the serialize() function, while Edit 1 adds code to read and use that same 'is_legacy_optimizer' field in the deserialize() function. Both edits reference the exact same symbol/key ('is_legacy_optimizer' in the config dictionary) and together form a complete serialization round-trip feature. After making either edit, the other becomes the immediate next step to complete the functionality - serializing without deserializing support or vice versa would create an incomplete feature. This represents a direct code dependency where both changed lines explicitly reference the same dictionary key."
        },
        {
            "sample_idx": 462,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds `__version__` to an import statement in `modeling_flax_utils.py`, while Edit 1 uses `__version__` in a user_agent dictionary in `pipeline_utils.py`. These edits reference different symbols despite having the same name. The `__version__` imported in Edit 0 is scoped to the `modeling_flax_utils.py` module, while the `__version__` used in Edit 1 is in the `pipeline_utils.py` module scope (presumably imported separately or available through a different import). The changed lines do not reference the exact same symbol - they are different symbols with identical names in different scopes/files. There is no direct code dependency between these specific changed lines."
        },
        {
            "sample_idx": 463,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 adds the `run_tests` parameter to the `main` function signature, while Edit 0 uses this `run_tests` parameter in an if statement within the function body. The changed lines reference the exact same symbol - the `run_tests` parameter. After adding the parameter in the signature (Edit 1), using it in the function body (Edit 0) becomes the immediate next step. Conversely, if the usage is added first, the parameter definition becomes immediately necessary. Both edits can be staged in either order without parser errors in Python (the usage would just reference an undefined variable until the parameter is added), making this a bi-directional relationship with explicit code linkage between the same symbol."
        },
        {
            "sample_idx": 464,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 calls the method `tty.wait_till_read_available()` on line 73, while Edit 1 defines this exact same method `wait_till_read_available` in the TTYIO class on line 456. The changed lines reference the exact same symbol - the method being called in Edit 0 is the same method being defined in Edit 1. This creates an immediate, mechanically obvious code-driven dependency where defining the method (Edit 1) and using it (Edit 0) are part of the same contiguous micro-task. In Python, both edits can be parsed and staged in either order since the method call in Edit 0 would only fail at runtime (AttributeError) if Edit 1 hasn't been applied yet, not at parse time. Therefore, either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 467,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports `connection` from `django.db` and Edit 1 uses the imported `connection` symbol by calling `connection.connect()`. This creates an immediate, mechanically obvious code dependency where the import in Edit 0 makes the `connection` symbol available for use in Edit 1. Both edits reference the exact same symbol (`connection`) and represent a classic import-usage pattern within the same file. After making either edit, the other becomes the next logical step to either provide the needed import or use the imported symbol. Since this is Python, both edits can be written and parsed in either order (usage before import would only cause a runtime NameError, not a parse error), making this a bi-directional relationship."
        },
        {
            "sample_idx": 466,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of TTY handling but do not reference the exact same symbol or create a direct code dependency. Edit 0 adds a call to `tty.wait_till_read_available()` method in the send_text.py file, while Edit 1 changes the parameter passed to `open_tty()` from `True` to `self.read_with_timeout` in the utils.py file. The `tty` object in Edit 0 and the `open_tty` function call in Edit 1 are different symbols in different contexts. While both edits may be part of the same feature implementation related to TTY timeout handling, there is no explicit code linkage where the changed lines reference the same symbol, and neither edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 465,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits are calling the same function `get_free_trial_days()` and adding a parameter to it, but they are referencing different call sites of the same function. In edit 0, the function is called with `is_self_hosted_billing` as the parameter, while in edit 1, it's called with the literal `True`. These appear to be part of a coordinated change to update all call sites of `get_free_trial_days()` to include a new parameter, likely after the function signature was changed to require this parameter. This represents a bulk update pattern where multiple call sites of the same function are being updated simultaneously to match a new function signature. Both edits reference the exact same symbol (`get_free_trial_days`) and appear to be part of the same refactoring task to add the new parameter to all call sites."
        },
        {
            "sample_idx": 468,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits add the exact same key-value pair 'is_legacy_optimizer': False to two different contexts. Edit 0 adds it to the actual optimizer's get_config() method implementation, while Edit 1 adds it to a test's expected configuration dictionary. This represents a test-production code synchronization pattern where the test must be updated to match the new configuration structure returned by the production code. Both edits reference the same configuration key and maintain consistency between the implementation and its test expectations. Either edit could be made first since both are syntactically valid independently, but making either edit creates an immediate prompt for the other to maintain test-code synchronization."
        },
        {
            "sample_idx": 469,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different code elements and have no direct code linkage. Edit 0 modifies the parameter unpacking in the `update` function within the `sm3` optimizer implementation, adding `x_shape` to the state tuple. Edit 1 renames and restructures test methods in a test file, splitting `testSM3` into `testSM3Scalar` and `testSM3Vector`. While both edits relate to the SM3 optimizer conceptually, the changed lines reference entirely different symbols - Edit 0 deals with the `state` parameter unpacking in the implementation, while Edit 1 deals with test method names and structure. There is no explicit code dependency where the changed lines reference the same symbol, and no mechanically obvious prompt from one edit to the other. The relationship is purely thematic/conceptual."
        },
        {
            "sample_idx": 471,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different files and involve different types of changes with no code linkage. Edit 0 adds a new function `schedule_exists` to a schedule utility module, while Edit 1 removes some schema-related logic from a data imports workflow function. The changed lines in each edit reference entirely different symbols and concepts - Edit 0 introduces temporal schedule functionality while Edit 1 removes schema synchronization logic. There is no shared symbol, function call, import, or structural dependency between the changes. They appear to be independent modifications serving different purposes in different parts of the codebase."
        },
        {
            "sample_idx": 470,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits handle the 'is_legacy_optimizer' key in configuration dictionaries, but they operate on different symbols and serve different purposes. Edit 0 reads from config['config']['is_legacy_optimizer'] in the deserialize function to determine optimizer type, while Edit 1 removes 'is_legacy_optimizer' from a different config object in the from_config method to clean up the configuration before class instantiation. The changed lines reference different config objects (config['config'] vs config) and different symbols, despite the identical key name. There is no direct code dependency between these operations - they are separate parts of the optimizer deserialization pipeline that happen to both deal with the same configuration key name but in different contexts and scopes."
        },
        {
            "sample_idx": 472,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits involve formatting changes to parser.add_argument() calls in the same file and class, but they affect completely different command-line arguments with different purposes. Edit 0 reformats the '--disable-plugin' argument by splitting its parameters across multiple lines, while Edit 1 adds an entirely new '--separator' argument. The changed lines reference different symbols (disable_plugin vs enable_separator) and there is no direct code dependency, explicit symbol reference, or synchronized pattern between them. These are independent formatting/addition operations that happen to use the same method call structure but don't create any immediate, mechanically obvious prompt for each other."
        },
        {
            "sample_idx": 473,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the code. Edit 0 adds a 'vcs_rev' parameter to the init_env function signature. Edit 1 renames a function from 'get_vcs_rev_define' to 'get_vcs_rev'. While both edits involve VCS-related functionality, the changed lines reference completely different symbols - one is adding a parameter to init_env, the other is renaming a separate function. There is no direct code dependency or explicit linkage between the exact symbols being modified in each edit's changed lines."
        },
        {
            "sample_idx": 474,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Edit 0 defines viewkeys as operator.methodcaller('keys') in the compat.py file, while Edit 1 uses viewkeys(i) in a different file (glances_plugin.py). However, these edits reference different symbols despite having the same name. The viewkeys defined in Edit 0 is a compatibility function in the compat module, while the viewkeys used in Edit 1 appears to be referencing a different symbol (likely imported from elsewhere or expected to be available in that scope). There is no direct import relationship shown between these files, and the changed lines don't reference the exact same symbol. The connection is only conceptual - both relate to dictionary key access compatibility, but they involve different symbols in different scopes."
        },
        {
            "sample_idx": 475,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve imports with similar names but reference completely different symbols. Edit 0 imports 'GlancesPasswordList' from 'glances_passwordlist' module and aliases it as 'GlancesPassword'. Edit 1 imports 'GlancesPassword' from 'glances_password' module. Despite both having 'GlancesPassword' in their import statements, they are importing different symbols from different modules - one is importing a class called 'GlancesPasswordList' (aliased), the other is importing a class called 'GlancesPassword' from a different module entirely. There is no direct code dependency or reference to the exact same symbol between these changed lines. The relationship is purely coincidental naming, not an explicit code linkage."
        },
        {
            "sample_idx": 476,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated at the code level. Edit 0 adds an import statement for 'TrinoQueryError' in the main trino operators module, while Edit 1 modifies a SQL statement in a test file to add 'IF NOT EXISTS' clause to a CREATE TABLE statement. The changed lines reference entirely different symbols and constructs - one is a Python import, the other is a SQL DDL statement. There is no direct code dependency, shared symbol reference, or structural relationship between importing an exception class and modifying a SQL table creation statement. They may both be related to Trino conceptually, but there is no explicit code linkage between the exact symbols being changed."
        },
        {
            "sample_idx": 477,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits are removing test methods from the same test class (EmbeddingTest), but they are removing different, unrelated test methods - one removes 'test_enable_lora_on_unbuilt_layer' and the other removes 'test_quantize_on_unbuilt_layer'. While both methods test similar patterns (operations on unbuilt layers), they test completely different functionality (LoRA vs quantization) and there is no direct code dependency between the changed lines. The methods being removed reference different symbols (enable_lora vs quantize methods) and removing one does not create any immediate, mechanically obvious prompt to remove the other. This appears to be cleanup of multiple unrelated test methods rather than a single contiguous micro-task with explicit code linkage."
        },
        {
            "sample_idx": 478,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts. Edit 0 adds a new configuration setting 'FEED_STORAGE_GCS_ACL = None' to the default settings file, while Edit 1 adds a local variable 'acl = \"publicRead\"' within a test method. Although both relate to ACL (Access Control List) functionality for GCS (Google Cloud Storage), they reference completely different symbols - one is a global configuration constant and the other is a local test variable. There is no direct code dependency between these changed lines, no shared symbol reference, and no immediate mechanical prompt from one edit to the other. The relationship is purely conceptual/thematic (both related to GCS ACL functionality) rather than based on explicit code linkage."
        },
        {
            "sample_idx": 480,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are performing synchronized parameter renaming across different parts of the same URL routing system. Edit 0 changes the variable name from 'endpoint' to 'email_type' in the URL construction, while Edit 1 changes the URL pattern parameter name from 'type' to 'email_type' and 'token' to 'confirmation_key'. Both edits are part of a coordinated refactoring to make parameter names more consistent and descriptive in the unsubscribe URL system. The edits reference the same URL structure ('/accounts/unsubscribe/') and are performing identical renaming patterns as part of a single refactoring task. Either edit can be made first since both the URL generation and URL pattern matching will continue to work regardless of order - this is a bi-directional synchronized substitution."
        },
        {
            "sample_idx": 479,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add comment-constant pairs to the same constants.py file, but they define completely different symbols (LOCALHOST vs AWS_REGION_US_EAST_1) that serve different purposes. Edit 0 adds a localhost hostname constant while Edit 1 adds an AWS region constant. There is no direct code dependency between these symbols - neither edit references, calls, assigns, or imports the symbol defined in the other edit. The only relationship is that they both add constants to the same file, which is purely conceptual/structural rather than an explicit code linkage. According to the criteria, edits that only share conceptual or thematic connections without direct symbol dependencies should be labeled as 'no relation'."
        },
        {
            "sample_idx": 481,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code dependency. Edit 0 adds a new function 'schedule_exists' to posthog/temporal/common/schedule.py, while Edit 1 modifies a parameter in a call to 'unpause_schedule' in posthog/warehouse/data_load/service.py, changing 'str(external_data_source.id)' to 'id'. The changed lines do not reference the same symbols - Edit 0 introduces a new function definition while Edit 1 modifies an argument to an existing function call. There is no explicit code linkage, import relationship, or synchronized substitution pattern between these edits. They appear to be unrelated changes that happen to both involve schedule-related functionality conceptually, but lack the direct symbol reference required for a neighbour relationship."
        },
        {
            "sample_idx": 482,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours because they reference different symbols and serve different purposes. Edit 0 defines a new function `stop_route` that handles HTTP requests and sets `shared.state.server_command = \"stop\"`. Edit 1 adds a print statement inside an existing exception handler that sets a local variable `server_command = \"stop\"`. While both edits involve the concept of 'stopping', they reference different symbols: `shared.state.server_command` (global state) vs `server_command` (local variable). The changed lines do not reference the exact same symbol, and there is no direct code dependency or structural linkage between defining a new route handler and adding logging to an exception handler."
        },
        {
            "sample_idx": 483,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different functions and have no direct code linkage. Edit 0 changes a call to `unpause_external_data_schedule()` by converting the argument from `source` to `str(source.id)`. Edit 1 changes the signature of `pause_external_data_schedule()` by changing the parameter from `external_data_source: ExternalDataSource` to `id: str`. Despite both being related to external data schedule functions, they involve different function symbols (`unpause_external_data_schedule` vs `pause_external_data_schedule`) and there is no explicit code dependency between the changed lines. The relationship is only conceptual/thematic - both are part of what appears to be a refactor to use string IDs instead of objects, but the changed lines don't reference the exact same symbol."
        },
        {
            "sample_idx": 484,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 modifies a docstring parameter description in the `_add_browser_connection` method, changing the type annotation from just `_BrowserWebSocketHandler` to `_BrowserWebSocketHandler or PREHEATED_REPORT_CONTEXT`. Edit 1 reformats a `self.write()` call in the `_DebugHandler.get()` method by breaking it across multiple lines. The edits affect different methods, different symbols, and different types of changes (documentation vs code formatting). There is no shared symbol, no code dependency, and no structural relationship between the changed lines."
        },
        {
            "sample_idx": 485,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different functions. Edit 0 modifies a call to `optimizers.deserialize()` by adding a `use_legacy_optimizer=False` parameter in the `LossScaleOptimizerV3.from_config()` method. Edit 1 modifies a different `from_config()` method in the `_BaseOptimizer` class by adding code to handle an `is_legacy_optimizer` config key. While both edits are conceptually related to legacy optimizer handling, they reference different symbols (`optimizers.deserialize` vs `learning_rate_schedule.deserialize`), occur in different classes and files, and the changed lines don't reference the exact same symbol. The connection is thematic/conceptual rather than a direct code dependency where one edit creates a mechanical prompt for the other."
        },
        {
            "sample_idx": 486,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 imports `__version__` from the current package in `modeling_utils.py`, while Edit 1 uses `__version__` in `pipeline_utils.py` to create a user_agent dictionary. However, these are different symbols despite having the same name. The `__version__` imported in Edit 0 is scoped to `modeling_utils.py`, while the `__version__` used in Edit 1 is in `pipeline_utils.py` and would need to be imported separately in that file. The changed lines reference different symbols in different scopes/files, so there is no direct code dependency between them."
        },
        {
            "sample_idx": 488,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file and class but affect completely different symbols and functionality. Edit 0 adds a 'logger' parameter to the constructor's parameter list, while Edit 1 changes a string literal comparison from 'gateway' to GATEWAY_NAME constant in a completely different method (handle_result). There is no direct code dependency between these changes - the changed lines reference entirely different symbols (a parameter vs. a constant), and neither edit creates an immediate, mechanically obvious prompt for the other. The connection is only conceptual (both are part of gateway functionality improvements) but lacks the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 487,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 adds a line that assigns `cur.stats[\"queryId\"]` to `self.query_id` within the TrinoHook class's run method. Edit 1 adds an import statement for `TrinoQueryError` from the trino.exceptions module in a different file (trino.py operators vs hooks). There is no explicit code dependency between these changes - the query_id assignment does not reference TrinoQueryError, and the TrinoQueryError import does not reference the query_id attribute. The changed lines reference entirely different symbols with no mechanical prompt relationship between them."
        },
        {
            "sample_idx": 489,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes the function signature parameter names from 'type' to 'email_type' and 'token' to 'confirmation_key'. Edit 1 updates the function body to use these renamed parameters. Both edits reference the exact same symbols (the parameters of the email_unsubscribe function). After making edit 0, the function body would reference undefined variables 'type' and 'token', creating an immediate code-driven prompt to update those references to the new parameter names. This is a classic parameter rename pattern where the signature change and body usage updates are mechanically linked and would naturally occur in one contiguous micro-task."
        },
        {
            "sample_idx": 490,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve different aspects of the Embedding layer and do not reference the same symbol or create a direct code dependency. Edit 0 adds an early return check in the build() method of the Embedding class implementation, while Edit 1 adds a new test method for the weights constructor argument. The changed lines do not reference the same symbol - Edit 0 modifies the build() method logic, while Edit 1 creates a completely separate test for the weights parameter functionality. There is no explicit code linkage between adding a built check and testing weights constructor arguments. These are independent changes that happen to be in related files but lack the direct symbol reference or mechanical dependency required for neighbour classification."
        },
        {
            "sample_idx": 491,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 removes an import of 'aget_schema_by_id' from the external_data_job.py file, while Edit 1 adds a new 'update' method to a serializer class in external_data_schema.py. The changed lines do not reference the same symbol - the removed import 'aget_schema_by_id' is not referenced anywhere in the added update method. There is no explicit code dependency, synchronized substitution, or direct symbol relationship between these edits. They appear to be separate changes that happen to both involve external data functionality conceptually, but lack the required direct code linkage at the locus of change."
        },
        {
            "sample_idx": 492,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These edits both define the same three symbols (viewkeys, viewvalues, viewitems) but in different conditional branches of the same file. Edit 0 defines them using 'keys', 'values', 'items' while Edit 1 defines them using 'viewkeys', 'viewvalues', 'viewitems'. This appears to be handling Python 2 vs Python 3 compatibility where different methods are available. However, the changed lines reference different symbols despite having the same names on the left side of assignment - the methodcaller arguments are different ('keys' vs 'viewkeys', etc.). These are different symbols being called, and the assignments create different function objects. There is no direct code dependency between the changed lines themselves - they are alternative implementations for different Python versions in separate conditional blocks. This is a thematic/conceptual relationship (Python compatibility) rather than a direct code linkage where one edit creates an immediate prompt for the other."
        },
        {
            "sample_idx": 495,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports 'connection' from django.db, and Edit 1 uses that exact same imported symbol by calling 'connection.connect()'. This creates a direct import-usage relationship where the changed lines reference the exact same symbol. In Python, the usage can be written before the import (it would only fail at runtime with a NameError), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the functionality."
        },
        {
            "sample_idx": 493,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are thematically related to the same conceptual change (handling incomplete candles in backtesting), but they do not reference the exact same symbol or create a direct code dependency. Edit 0 adds a comment explaining that rows are treated as 'current incomplete candle' in the backtesting logic. Edit 1 updates test assertions and comments to reflect the new expected behavior (199 vs 200 candles, missing 1 candle at start, last candle being incomplete). While both edits are part of the same feature implementation, the changed lines do not reference, assign, call, or import the exact same symbol. The test is verifying the behavior that the code comment describes, but there's no explicit code linkage between the specific lines that were changed - just conceptual/thematic relationship around the incomplete candle handling feature."
        },
        {
            "sample_idx": 494,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural substitution pattern within similar database export functions. They both: 1) Add the exact same line creating `data_interval_end_str` variable with identical datetime formatting logic, 2) Replace a simple `stagle_table_name` assignment with an identical multi-line conditional expression that incorporates the new timestamp variable, 3) Apply the same before\u2192after transformation pattern to the same type of syntactic construct (variable assignment). This represents a bulk-edit/pattern synchronization where both edits are clearly part of a single, contiguous refactoring operation to add timestamp suffixes to staging table names across multiple database export modules. The changes are mechanically identical and would naturally be made together as part of one uninterrupted micro-task."
        },
        {
            "sample_idx": 496,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits do not reference the exact same symbol. Edit 0 changes a call to `get_free_trial_days()` by adding a `False` parameter, while Edit 1 adds a new configuration constant `SELF_HOSTING_FREE_TRIAL_DAYS` that is unrelated to the function call being modified. Although both edits appear to be part of the same feature development (adding self-hosting vs cloud distinction for free trial days), there is no direct code dependency between the changed lines - they reference different symbols (`get_free_trial_days` function vs `SELF_HOSTING_FREE_TRIAL_DAYS` constant). The connection is conceptual/thematic rather than an explicit code linkage where one edit creates an immediate, mechanical prompt for the other."
        },
        {
            "sample_idx": 498,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different symbols and code constructs with no direct relationship. Edit 0 reformats a parser.add_argument() call for a '--disable-plugin' command line argument in the main.py file, while Edit 1 adds a 'separator' parameter to a new_line() method in the curses output module. The changed lines reference entirely different symbols (parser.add_argument vs new_line method), are in different files serving different purposes, and have no explicit code dependency or linkage between them. There is no immediate, mechanically obvious prompt from one edit to the other."
        },
        {
            "sample_idx": 497,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are making changes to different files (celery/conf.py and celery/worker.py) and involve completely different symbols and functionality. Edit 0 adds a configuration setting SEND_CELERY_TASK_ERROR_EMAILS for controlling email notifications of task errors, while Edit 1 adds an ExcInfo class for handling exception information. There is no direct code dependency between the changed lines - they don't reference, assign, call, or import the same symbol. The changed lines in each edit reference entirely different symbols (SEND_CELERY_TASK_ERROR_EMAILS vs ExcInfo class). While both may conceptually relate to error handling in the Celery framework, there is no explicit, immediate code linkage that would make one edit mechanically prompt the other as the next contiguous action."
        },
        {
            "sample_idx": 499,
            "yi": "bi-directional",
            "pred": "0 before 1",
            "pred_reason": "Edit 0 defines two new attributes `cond_scale_miltiplier` and `need_last_noise_uncond` in the CFGDenoiser class constructor. Edit 1 assigns values to these exact same attributes on a model object (which appears to be an instance of CFGDenoiser based on the context). The changed lines in edit 1 reference the exact same symbols that are being initialized in edit 0. This creates a direct code dependency where the attributes must be defined before they can be assigned to, making this a definition-usage relationship for the same symbols."
        },
        {
            "sample_idx": 500,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (handling unbuilt layers in the Embedding class) but they reference different aspects and don't have direct code linkage between the changed lines. Edit 0 adds a `self.build()` call and weight initialization logic to the Embedding class constructor. Edit 1 removes a test that was specifically checking for an error when quantizing an unbuilt layer. While conceptually related (the test removal makes sense because Edit 0 ensures layers are always built), the changed lines don't reference the exact same symbol - Edit 0 modifies the constructor implementation while Edit 1 removes a test method. There's no direct syntactic dependency where one edit's changed lines reference symbols defined or modified in the other edit's changed lines."
        },
        {
            "sample_idx": 501,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are neighbors because they form a synchronized pair for handling the 'is_legacy_optimizer' configuration key. Edit 0 adds 'is_legacy_optimizer': False to the config dictionary in the experimental optimizer's get_config() method, while Edit 1 adds code to remove this same key from the config in the V2 optimizer's from_config() method. Both edits reference the exact same string literal 'is_legacy_optimizer' and work together to ensure this configuration key is properly handled - one adds it during serialization and the other removes it during deserialization to prevent conflicts. This represents a direct code dependency where both edits are part of the same micro-task of implementing proper config handling for the legacy optimizer flag."
        },
        {
            "sample_idx": 503,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are independent changes to different methods within the same class. Edit 0 adds a call to `self.separator_line()` in the `display` method, while Edit 1 reformats the parameters of a `self.display_plugin()` call in the `__display_header` method by splitting them across multiple lines. The changed lines do not reference the exact same symbol - Edit 0 references `separator_line()` and Edit 1 references `display_plugin()`. There is no explicit code dependency, direct symbol linkage, or mirrored substitution pattern between these edits. They appear to be separate code improvements that can be made independently without one creating a mechanical prompt for the other."
        },
        {
            "sample_idx": 502,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits modify the unpacking of the same `state` tuple structure within the same `sm3` function. Edit 0 changes the `update` function to unpack `state` as `x, m, vs, x_shape` (adding `x_shape`), while Edit 1 changes the `get_params` function to unpack the same `state` tuple as `x, _, _, x_shape` (also adding `x_shape`). These edits are synchronizing the state tuple structure across different functions that operate on the exact same state object. Both changed lines reference the same `state` parameter and perform identical structural modifications (adding `x_shape` to the unpacking pattern). This represents a mirrored structural substitution within the same context - both functions need to be updated simultaneously to handle the expanded state tuple format. Either edit can be made first since both are valid Python syntax independently, but making one edit creates an immediate prompt to update the other function to maintain consistency in how the state tuple is handled."
        },
        {
            "sample_idx": 504,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve completely different symbols and code elements. Edit 0 adds 'schedule_exists' to what appears to be an import list or parameter list, while Edit 1 changes the function signature of 'unpause_external_data_schedule' by replacing the parameter type and name from 'external_data_source: ExternalDataSource' to 'id: str'. There is no direct code linkage between the changed lines - they don't reference, assign, call, or import the same symbol. The addition of 'schedule_exists' in edit 0 has no explicit connection to the parameter change in the function signature in edit 1. These appear to be separate modifications that may be conceptually related to the same feature but lack the direct, mechanical code dependency required for a neighbour relationship."
        },
        {
            "sample_idx": 505,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 modifies the `get_params` function within the `sm3` optimizer implementation to handle state unpacking and reshaping with an additional `x_shape` parameter. Edit 1 renames and restructures the `testSM3` method by splitting it into `testSM3Scalar` and `testSM3Vector` test cases. While both edits relate to the SM3 optimizer conceptually, there is no direct code linkage between the changed lines - they don't reference the same symbol, and the test restructuring doesn't create an immediate, mechanically obvious prompt for the implementation change or vice versa. The relationship is purely thematic/conceptual rather than based on explicit code dependencies."
        },
        {
            "sample_idx": 506,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits modify calls to the exact same function `get_free_trial_days()` by adding different boolean arguments. This represents a bulk-edit pattern where the same function signature change is being applied across multiple call sites, but with context-specific parameter values. The edits are part of a single refactoring operation to update all call sites of `get_free_trial_days()` to include a boolean parameter. Since both edits reference the exact same symbol and represent synchronized updates to the same function's call sites, either edit could be made first as part of this refactoring sweep."
        },
        {
            "sample_idx": 507,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 changes a call to `unpause_external_data_schedule(source)` to `unpause_external_data_schedule(str(source.id))`, modifying how the function is called. Edit 1 adds an import statement that includes `unpause_external_data_schedule` among other functions. While both edits involve the same function name `unpause_external_data_schedule`, they reference different aspects: Edit 0 modifies a call site while Edit 1 adds an import. However, the import in Edit 1 is not directly required for Edit 0's call to work - the function was presumably already available through some other import path since the original call `unpause_external_data_schedule(source)` was functional. These edits appear to be part of separate concerns: Edit 0 is fixing a parameter type issue in a function call, while Edit 1 is reorganizing imports. There is no direct code dependency where one edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 509,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a comment about localhost in the constants.py file, while Edit 1 modifies the logic in a CloudFormation template deployer function to handle US East 1 region differently. The changed lines reference entirely different symbols and concepts - one deals with localhost constants, the other with AWS region handling logic. There is no explicit code linkage, shared symbols, or structural dependency between adding a comment about localhost and modifying region-specific bucket location logic."
        },
        {
            "sample_idx": 508,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a new parameter `is_self_hosted_billing` to the `get_free_trial_days()` function and introduces a conditional that references `settings.SELF_HOSTING_FREE_TRIAL_DAYS`. Edit 1 defines the `SELF_HOSTING_FREE_TRIAL_DAYS` setting that is referenced in edit 0. However, these edits reference different symbols - edit 0 references `settings.SELF_HOSTING_FREE_TRIAL_DAYS` (an attribute access) while edit 1 defines `SELF_HOSTING_FREE_TRIAL_DAYS` (a module-level variable). While they are conceptually related and the attribute access will resolve to the module variable, the changed lines themselves don't reference the exact same symbol syntactically. The relationship is more about feature implementation than direct code dependency between the exact same symbols in the changed lines."
        },
        {
            "sample_idx": 511,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a `query_id` attribute to the TrinoHook class by setting `self.query_id = cur.stats[\"queryId\"]`. Edit 1 adds an `on_kill` method to TrinoOperator that accesses this exact same `query_id` attribute via `self.hook.query_id`. The changed lines reference the exact same symbol - the `query_id` attribute of the TrinoHook instance. Edit 0 defines/sets this attribute, and Edit 1 uses it. This creates a direct code dependency where Edit 1's new code relies on the `query_id` attribute that Edit 0 introduces. Both edits can be written and parsed in either order (no syntax errors), but they form a definition-usage pair for the same symbol, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 510,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds code that calls `unpause_external_data_schedule(str(instance.id))` on line 41, while Edit 1 modifies the implementation of the `unpause_external_data_schedule` function by changing how it handles the `schedule_id` parameter. However, these edits reference different symbols despite the function name being the same. Edit 0 calls the function with a string argument, but Edit 1 changes the function's internal implementation to use a variable `id` instead of `str(external_data_source.id)`. The changed lines don't reference the exact same symbol - Edit 0 references the function call site with a specific argument pattern, while Edit 1 references the function's internal parameter handling. There's no direct, explicit code dependency between the specific changed lines themselves."
        },
        {
            "sample_idx": 512,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes the function parameter from 'external_data_source: ExternalDataSource' to 'id: str', and Edit 1 updates the function body to use the new parameter 'id' directly instead of 'external_data_source.id'. Both edits reference the exact same symbol - the parameter of the function 'unpause_external_data_schedule'. This is a classic parameter rename scenario where the signature change and the corresponding body reference update are part of a single micro-task. After making either edit, the other becomes immediately necessary to maintain code consistency and avoid undefined symbol references. The changed lines in both edits reference the same parameter symbol, making this a bi-directional relationship."
        },
        {
            "sample_idx": 513,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and have no direct code linkage. Edit 0 modifies a Popen constructor call by adding a 'cwd' parameter in the devserver command file. Edit 1 removes an import statement for django.conf.settings in the HTTP server service file. While both edits touch files related to server functionality, the changed lines reference completely different symbols - one modifies a Popen call with new parameters, the other removes an unused import. There is no explicit code dependency, shared symbol reference, or structural relationship between these specific changes. They appear to be independent cleanup/modification operations in different parts of the codebase."
        },
        {
            "sample_idx": 514,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits modify the same state tuple structure in the sm3 optimizer function. Edit 0 adds x_shape to the initialization and modifies x0, while edit 1 updates the unpacking of the state tuple to include the new x_shape component. The changed lines reference the exact same state structure - edit 0 adds x_shape to what gets stored in the state, and edit 1 updates the unpacking to handle the modified state tuple that now includes x_shape. This creates a direct code dependency where both edits must be synchronized to maintain the state tuple structure consistency. Either edit can be made first since both are syntactically valid independently, but making one creates an immediate prompt for the other to maintain the state structure integrity."
        },
        {
            "sample_idx": 516,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 removes a comment block above the function definition, while Edit 1 modifies the error handling logic within the function body to distinguish between duplicate and unknown field names. The edits reference completely different parts of the code - one affects documentation/comments and the other affects functional logic. There is no direct code dependency between removing comments and changing error handling behavior, nor do they reference the same symbols. The only connection is that they both involve the same function, but this is merely conceptual proximity rather than explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 515,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits affect completely different aspects of the codebase and reference different symbols. Edit 0 adds a 'query_id' attribute to the TrinoHook class in the hook implementation file. Edit 1 modifies a SQL string in a test file to add 'IF NOT EXISTS' to a CREATE TABLE statement. There is no direct code dependency between these changes - they don't reference the same symbol, and neither edit creates an immediate, mechanically obvious prompt for the other. The changed lines reference entirely different elements: one adds a class attribute, the other modifies a SQL string literal. While both relate to Trino functionality conceptually, this is only a thematic connection, not an explicit code linkage."
        },
        {
            "sample_idx": 517,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 adds a conditional block that calls `mail_admins()` and references `SEND_CELERY_TASK_ERROR_EMAILS` and `ret_value.traceback` in the `TaskProcessQueue.on_ready` method. Edit 1 adds import statements for `sys` and `traceback` modules at the top of a different file (celery/worker.py). While both edits involve error handling functionality conceptually, the changed lines do not reference the exact same symbols - edit 0 references `mail_admins`, `SEND_CELERY_TASK_ERROR_EMAILS`, and `ret_value.traceback`, while edit 1 imports `sys` and `traceback` modules. There is no explicit code dependency between these specific changes, and they appear to be in different files with no direct symbol linkage between the changed lines."
        },
        {
            "sample_idx": 518,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an 'acl' parameter to the blob.upload_from_file() method call in the GCSFeedStorage class implementation. Edit 1 adds an 'acl' parameter to the GCSFeedStorage constructor call in the test. Both edits reference the exact same symbol (the 'acl' parameter) and are part of synchronizing the test code with the production code implementation. The test is being updated to match the new parameter that the production code now expects to use. This creates a bi-directional relationship where either edit could be made first, and after making either edit, the other becomes the immediate next step to maintain consistency between the test and implementation."
        },
        {
            "sample_idx": 519,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same attribute symbol 'cond_scale_miltiplier' on the model object. Edit 1 sets the attribute 'model.cond_scale_miltiplier = 1 / 12.5', and Edit 0 uses this attribute in the calculation 'cond_scale * self.cond_scale_miltiplier'. The changed lines in both edits explicitly reference the same symbol, creating a direct code dependency where setting the attribute in one edit enables its usage in the other. This represents a definition-usage relationship for the exact same symbol, making either edit a natural prompt for the other as part of implementing this scaling feature."
        },
        {
            "sample_idx": 521,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits modify different parts of the same class but do not reference the exact same symbol. Edit 0 adds a 'skip_models' parameter to the __init__ method signature, while Edit 1 adds a call to 'self.filter_relations()' in the delete_bulk method. The changed lines in each edit reference completely different symbols - one references the 'skip_models' parameter and the other references the 'filter_relations' method. There is no direct code dependency between these specific changes, and neither edit creates an immediate, mechanically obvious prompt for the other. While they may be conceptually related as part of implementing a filtering feature, the relationship is thematic rather than based on explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 520,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same 'is_legacy_optimizer' configuration key but in different contexts and different symbols. Edit 0 removes the 'is_legacy_optimizer' key from config in the Adagrad.from_config() method, while Edit 1 adds an assertion checking that 'is_legacy_optimizer' equals True in a test for SGD optimizer. The changed lines reference different config objects in different scopes - one in Adagrad class and one in a test method for SGD. There is no direct code dependency between these specific changed lines, and they don't reference the exact same symbol. The relationship is conceptual (both deal with the same config key name) but not a direct code linkage."
        },
        {
            "sample_idx": 522,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same configuration key 'is_legacy_optimizer' but in different contexts. Edit 0 adds this key to a test configuration dictionary, while Edit 1 adds code to handle and remove this key from a configuration in the from_config method. However, the changed lines reference different symbols - Edit 0 references a test configuration dictionary within a test method, while Edit 1 references a config parameter in a production class method. Although they both involve the same string literal 'is_legacy_optimizer', they are operating on different configuration objects in different scopes (test vs production code). There is no direct code dependency where one edit creates an immediate prompt for the other - the test configuration and the production from_config method are separate symbols despite handling the same conceptual configuration key."
        },
        {
            "sample_idx": 523,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds documentation for a 'weights' parameter in the class docstring, while Edit 1 adds implementation code that handles the 'weights' parameter in what appears to be the constructor/initialization method. Both edits reference the exact same symbol 'weights' - Edit 0 documents it and Edit 1 implements the logic to handle it. This creates a direct code linkage where documenting a parameter and implementing its functionality are part of the same micro-task of adding the weights feature. Either edit could be made first (documentation before implementation or implementation before documentation), and after making either edit, the other becomes the natural next step to complete the feature addition."
        },
        {
            "sample_idx": 525,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits affect completely different parts of the code and reference different symbols. Edit 0 reformats a conditional statement involving config options in the _get_routes method, while Edit 1 updates a docstring parameter type annotation in the _add_browser_connection method. The changed lines do not reference, assign, call, or import the same symbol. There is no explicit code linkage, dependency, or synchronized pattern between these edits - they are simply two separate code improvements that happen to be in the same file."
        },
        {
            "sample_idx": 524,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are not neighbours in mental flow. Edit 0 adds error email functionality when tasks fail in the TaskProcessQueue.on_ready method, while Edit 1 changes the return value from a plain exception to an ExcInfo object in the jail function. Although both edits relate to error handling in Celery, they modify different symbols in different files and contexts. The changed lines do not reference the same symbol - Edit 0 adds calls to SEND_CELERY_TASK_ERROR_EMAILS and mail_admins, while Edit 1 modifies the return statement to use ExcInfo and sys.exc_info(). There is no direct code dependency or explicit linkage between these specific changes, making this a conceptual relationship rather than a mechanical code-driven one."
        },
        {
            "sample_idx": 526,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols despite both involving AWS_REGION_US_EAST_1. Edit 0 assigns the value AWS_REGION_US_EAST_1 to os.environ['DEFAULT_REGION'], while Edit 1 compares a region variable against AWS_REGION_US_EAST_1. The changed lines don't reference the exact same symbol - Edit 0 is about setting a default region environment variable, while Edit 1 is about conditional logic based on region comparison. There's no direct code dependency where making one edit creates an immediate, mechanically obvious prompt for the other. They appear to be part of the same conceptual change (using a constant instead of hardcoded string) but lack explicit code linkage between the changed lines themselves."
        },
        {
            "sample_idx": 527,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are within the same function (run_subprocess) but affect different aspects of the code without direct dependency. Edit 0 adds a 'cwd' parameter to the function signature, while Edit 1 removes an import statement for 'django.conf.settings'. The changed lines reference completely different symbols - one modifies the function parameter list, the other removes an import. There is no explicit code linkage between adding a 'cwd' parameter and removing the django.conf import. Neither edit creates an immediate, mechanically obvious prompt for the other, and they could be made independently without any direct syntactic or structural dependency between the specific changed lines."
        },
        {
            "sample_idx": 529,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits represent a bulk refactoring pattern where a hardcoded string 'us-east-1' is being replaced with a constant AWS_REGION_US_EAST_1. Edit 0 changes the usage of the hardcoded string to use the constant, while Edit 1 adds the import for that constant. However, these are in different files and there's no direct code dependency between the changed lines themselves. Edit 0 uses the constant AWS_REGION_US_EAST_1 but Edit 1 only imports it - the import in Edit 1 doesn't directly enable Edit 0 since they're in different files. While both edits are part of the same refactoring effort to replace hardcoded strings with constants, the changed lines don't reference the exact same symbol in a way that creates immediate mechanical dependency. The import in template_deployer.py doesn't directly affect the usage in config.py."
        },
        {
            "sample_idx": 528,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same configuration key 'is_legacy_optimizer' but they reference it in different contexts and scopes. Edit 0 removes the key from a config dictionary in the from_config method of the optimizer class, while Edit 1 adds the key to a test configuration dictionary in a test method. While both edits involve the same string literal 'is_legacy_optimizer', they are operating on different config dictionaries in different files and different contexts - one in production code handling deserialization, one in test code setting up test data. The changed lines do not reference the exact same symbol or create a direct code dependency between them. This appears to be part of a broader feature implementation where the test is being updated to include the new config key, but there's no immediate, mechanically obvious prompt from one edit to the other."
        },
        {
            "sample_idx": 531,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new key 'is_legacy_optimizer' to the config dictionary in the Optimizer class's get_config method. Edit 1 adds test code that handles this exact same 'is_legacy_optimizer' key by removing it from new_config when it's not present in the original config. The test code directly references and manipulates the same symbol that was added in the production code. This creates a direct code dependency where the test edit is specifically designed to handle the configuration change made in edit 0. Both edits reference the exact same string literal 'is_legacy_optimizer' and are part of synchronized test-production code changes for the same configuration attribute."
        },
        {
            "sample_idx": 532,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 reformats the arguments for a '--disable-plugin' command line option in the argument parser, while Edit 1 adds a new 'separator_line' method to a curses display class. The changed lines don't reference, assign, call, or import any of the same symbols. There is no explicit code dependency between reformatting argument parser code and adding a display method. The only potential connection is that both are part of the same codebase, but this is merely conceptual/thematic rather than a direct code-driven relationship at the locus of change."
        },
        {
            "sample_idx": 530,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits reference the exact same symbol 'self.skip_models' within the same class BaseDeletionTask. Edit 0 adds 'self.skip_models' to the __repr__ method's string formatting, while Edit 1 adds a new method 'filter_relations' that uses 'self.skip_models' in its logic. However, there is no direct code dependency between these specific changed lines - the __repr__ method displaying skip_models and the filter_relations method using skip_models are independent operations. The __repr__ change doesn't create an immediate, mechanically obvious prompt for adding the filter_relations method, nor vice versa. While both reference the same attribute, they serve different purposes (display vs. filtering logic) and neither edit makes the other the next contiguous required action. This appears to be two separate aspects of implementing skip_models functionality rather than a direct code dependency."
        },
        {
            "sample_idx": 533,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a call to `self.separator_line()` in the `glances_curses.py` file within a display method. Edit 1 removes a blank line in the `glances_unicode.py` file. The changed lines reference completely different symbols and files - there is no shared symbol, function, class, or structural element between them. One is adding a method call while the other is removing whitespace. There is no explicit code linkage, dependency, or synchronized pattern between these edits."
        },
        {
            "sample_idx": 536,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits modify calls to the exact same function `get_free_trial_days()`, adding different boolean arguments (False in edit 0, True in edit 1). This represents a synchronized parameter addition pattern where the same function signature change is being applied consistently across multiple call sites. The edits perform structurally identical modifications (adding a boolean parameter) to the same function calls, which would naturally occur as part of a single refactoring task to update all call sites after the function signature was changed. Either edit could be made first, and both reference the exact same symbol `get_free_trial_days`."
        },
        {
            "sample_idx": 535,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 modifies a conditional check in the _wait_previous_and_send method of TopologyGraph._ReqReplyNode class, adding a condition to check if self.name exists in executor_endpoint_mapping. Edit 1 adds a logger parameter to the __init__ method of GatewayRequestHandler class. The changed lines reference completely different symbols (executor_endpoint_mapping vs logger parameter), are in different files, different classes, and different methods. There is no direct code dependency, no shared symbol references, and no mechanically obvious prompt for one edit to follow the other. They appear to be independent changes that happen to be part of the same codebase but have no explicit code linkage between them."
        },
        {
            "sample_idx": 537,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 defines a constant 'PREHEATED_REPORT_CONTEXT' in Server.py, while Edit 1 calls a method 'add_preheated_report_context()' on a server object in bootstrap.py. Although they are conceptually related (both dealing with preheated report context functionality), the changed lines do not reference the exact same symbol - one defines a string constant while the other calls a method. There is no explicit code linkage between the constant definition and the method call in the changed lines themselves."
        },
        {
            "sample_idx": 534,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits demonstrate a clear definition-usage relationship for the exact same symbol. Edit 0 defines the instance attribute `self.cond_scale_miltiplier = 1.0` in the `__init__` method of the CFGDenoiser class. Edit 1 uses this exact same attribute in the `forward` method by referencing `self.cond_scale_miltiplier` in the expression `cond_scale * self.cond_scale_miltiplier`. The changed lines reference the identical symbol - the instance attribute `cond_scale_miltiplier` of the same class. This creates an immediate code dependency where defining the attribute naturally prompts its usage, and using the attribute requires its prior definition. Since both edits can be written and parsed in either order in Python (the usage would only cause a runtime AttributeError if executed before definition), this is a bi-directional relationship."
        },
        {
            "sample_idx": 538,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different files and contexts - one removes a line incrementing row_index in the backtesting engine, while the other adds a conditional check before data slicing in a test function. The changed lines reference completely different symbols (row_index vs tres/data) and there is no direct code dependency, import relationship, or synchronized pattern between them. They appear to be separate bug fixes or improvements without any mechanical code linkage that would make one edit prompt the other as the next immediate step."
        },
        {
            "sample_idx": 540,
            "yi": "1 before 0",
            "pred": "1 before 0",
            "pred_reason": "These edits involve the same line of code being moved from one location to another. Edit 1 removes the line `cwd = os.path.realpath(os.path.join(settings.PROJECT_ROOT, os.pardir, os.pardir))` from the SentryHTTPServer class, while Edit 0 adds the identical line to the devserver function. This appears to be a cut-and-paste refactoring operation where the code is being relocated. The removal must happen before the addition can be meaningful, as this represents moving the cwd calculation from one context to another. The variable `cwd` is still referenced in the return statement in edit 1, so the removal creates a dependency that requires the code to be available elsewhere (added in edit 0)."
        },
        {
            "sample_idx": 542,
            "yi": "bi-directional",
            "pred": "0 before 1",
            "pred_reason": "Edit 0 removes the method `_test_error_exc_info` from the class, while Edit 1 changes a call from `self._test_error_exc_info()` to `_test_error_exc_info()`. Both edits reference the exact same symbol `_test_error_exc_info`. However, Edit 1 cannot function correctly without Edit 0 being applied first - if Edit 1 is applied first, it would call a non-existent function `_test_error_exc_info()` (without `self.`) which would cause a NameError at runtime since no such function exists in the local scope. Edit 0 must be applied first to remove the method, and then Edit 1 changes the call to reference what would presumably be a module-level or imported function. This creates a dependency where Edit 0 enables Edit 1 to work correctly."
        },
        {
            "sample_idx": 541,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits do not reference the same symbol or have direct code linkage. Edit 0 adds an import statement for the 'os' module, while Edit 1 modifies a Popen call to add a 'cwd' parameter. Although the 'cwd' parameter might conceptually be related to os/filesystem operations, the changed lines themselves do not reference the exact same symbol. The import of 'os' in Edit 0 and the addition of 'cwd=cwd' parameter in Edit 1 involve different symbols - 'os' is a module being imported, while 'cwd' is a parameter being passed to Popen. There is no explicit, immediate code dependency where one edit creates a mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 539,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are part of a coordinated change to the `pause_external_data_schedule` function's parameter handling. Edit 0 changes the call site to pass `str(job.pipeline.id)` instead of `job.pipeline`, while Edit 1 changes the function definition to accept a string `id` parameter and use it directly instead of converting `external_data_source.id` to string. The changed lines reference the exact same function symbol `pause_external_data_schedule`, and together they form a signature change with corresponding caller update. This is a bi-directional relationship because either edit can be made first - both are syntactically valid and the linkage becomes apparent once either change is made, prompting the other as the next mechanical step to maintain consistency."
        },
        {
            "sample_idx": 546,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and are not mechanically linked. Edit 0 adds an 'is_self_hosted_billing' parameter to a call to compute_plan_parameters(), while Edit 1 passes an 'is_self_hosted_billing' parameter to get_free_trial_days() within the compute_plan_parameters function. Although both involve the same variable name 'is_self_hosted_billing', the changed lines reference different function calls (compute_plan_parameters vs get_free_trial_days) and different symbols. There is no direct code dependency between these specific changed lines - they are part of separate function calls in different contexts. The connection is only conceptual (both use the same parameter name) rather than representing an explicit, immediate code linkage where one edit creates a mechanical prompt for the other."
        },
        {
            "sample_idx": 545,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 removes a line that increments 'row_index' in the backtesting implementation, while Edit 1 adds an import for 'timedelta' in the test file. There is no explicit dependency between the row_index variable and the timedelta import - they are unrelated code changes that happen to be in the same codebase. The changed lines do not reference the same symbol, and there is no immediate, mechanically obvious prompt from one edit to the other."
        },
        {
            "sample_idx": 543,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits add identical code (checking for and deleting 'is_legacy_optimizer' from config) in the same structural location (from_config methods) within different optimizer classes. This represents a bulk edit pattern where the exact same textual substitution is being applied to the same type of syntactic construct (from_config methods in optimizer classes). Both edits can be applied in either order since they modify different files and classes, and both appear to be part of a single, contiguous refactoring task to remove the legacy optimizer flag handling from multiple optimizer implementations."
        },
        {
            "sample_idx": 544,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol 'dtype' within the same function 'load_unet_state_dict'. Edit 0 adds the 'dtype' parameter to the function signature, and edit 1 uses that same 'dtype' parameter in the function body to conditionally set the unet_dtype. The changed lines in both edits explicitly reference the same parameter symbol. After adding the parameter in edit 0, the natural next step would be to use it in the function body (edit 1), or vice versa - after writing the usage logic, adding the parameter becomes the immediate next required step. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "sample_idx": 547,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are within the same test function but modify completely different aspects of the code. Edit 0 adds a conditional check around data manipulation for a variable 'pair', while Edit 1 adds an assertion that tests the length of analyzed dataframe for a hardcoded 'NXT/BTC' pair. There is no direct code dependency between the changed lines - they don't reference the same symbols, variables, or create any immediate mechanical prompt for one another. The edits are conceptually related (both part of the same test function) but lack the explicit code linkage required for neighbour classification. The conditional check in Edit 0 doesn't create any direct requirement for the assertion in Edit 1, and vice versa."
        },
        {
            "sample_idx": 549,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours. Edit 0 adds a new command-line argument '--add-stop-route' to the argument parser, while Edit 1 removes a print statement about catching KeyboardInterrupt. The changed lines reference completely different symbols and concepts - one is about adding a command-line option for a stop route, the other is about removing a print statement in exception handling. There is no direct code dependency, no shared symbol references, and no mechanical prompt from one edit to the other. They appear to be independent changes that happen to be part of the same codebase but lack any explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 550,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are in different files and contexts - one removes a line incrementing row_index in the main backtesting logic, while the other modifies test calculations for removed candles with an offset variable. While both relate to data indexing/counting in backtesting, the changed lines reference completely different symbols (row_index vs offset/removed_candles) and there is no direct code dependency between them. The edits don't reference the same symbol, and neither creates an immediate mechanical prompt for the other."
        },
        {
            "sample_idx": 548,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 adds a call to 'self.separator_line()' after calling '__display_header()' in the display method. Edit 1 removes a comment ('# Second line (optional)') from within the '__display_header()' method implementation. While both edits are in the same class and edit 0 calls the method that edit 1 modifies, the changed lines themselves do not reference the exact same symbol - edit 0's changed line calls 'separator_line()' while edit 1's changed line is just a comment removal. There is no explicit code linkage between the added separator_line() call and the comment removal, and neither edit creates a mechanical prompt for the other."
        },
        {
            "sample_idx": 551,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution - adding 'from django.db import connection' as an import statement in two different files. This represents a bulk/pattern synchronization where the same import is being added to multiple files as part of what appears to be a single, contiguous refactor. Both edits target the same type of syntactic construct (import statements) with identical before\u2192after patterns (no import \u2192 adding the same import). The edits reference the exact same symbol ('connection' from 'django.db') and appear to be part of a uniform multi-file substitution where the same dependency is being introduced across related service files."
        },
        {
            "sample_idx": 552,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines/assigns the logger attribute (self.logger = logger or JinaLogger(...)) in the __init__ method, while Edit 1 uses that exact same logger attribute (self.logger.error(...)) in the handle_request method. After making Edit 0, the logger is available for use, making Edit 1 a natural next step. After making Edit 1, if the logger wasn't already defined, Edit 0 would be the immediate code-driven requirement. Both edits reference the exact same symbol (self.logger) and either edit can be staged first since Python allows referencing undefined attributes at parse time (only failing at runtime)."
        },
        {
            "sample_idx": 553,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits are adding the same new configuration key 'FEED_STORAGE_GCS_ACL' to dictionary literals within the same test class (GCSFeedStorageTest). Edit 0 adds it to the mock.patch decorator's 'new' parameter dictionary, while edit 1 adds it to the 'settings' dictionary within the test_parse_settings method. This represents a synchronized pattern where the same configuration parameter is being added to related test setup configurations as part of a single, contiguous refactor to support testing the new FEED_STORAGE_GCS_ACL setting. Both edits involve identical structural substitution (adding the same key-value pair to dictionary literals) and are clearly part of the same micro-task of updating test configurations to include the new setting. Either edit could be made first, and after making either one, the other becomes the natural next step to complete the synchronized configuration update."
        },
        {
            "sample_idx": 554,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference the same configuration key 'is_legacy_optimizer' but in different contexts. Edit 0 adds logic to check and use the 'is_legacy_optimizer' key from a config dictionary during deserialization, while Edit 1 adds a test assertion to verify that this key exists and has the value True in an optimizer's config. However, the changed lines reference different symbols - Edit 0 references config['config']['is_legacy_optimizer'] (a nested config structure during deserialization), while Edit 1 references config['is_legacy_optimizer'] (a direct config key from get_config()). These are different data structures and different symbols, even though they involve the same configuration key name. The relationship is conceptual/thematic (both relate to the is_legacy_optimizer feature) rather than involving the exact same symbol reference."
        },
        {
            "sample_idx": 555,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These two edits are bi-directional neighbours because they both reference the exact same symbol 'weight_dtype' and represent a synchronized parameter addition pattern. Edit 0 adds 'weight_dtype' as a required input parameter in the INPUT_TYPES method, while Edit 1 adds the same 'weight_dtype' parameter to the load_unet method signature and implements its usage. Both changed lines explicitly reference the same parameter symbol, and making either edit creates an immediate, mechanically obvious prompt for the other - adding the parameter to INPUT_TYPES requires adding it to the method signature, and vice versa. This is a classic signature synchronization pattern where both edits can be staged in either order (no parse errors) but either naturally prompts the other as the next contiguous action within the same micro-task of adding weight_dtype support to the UNETLoader class."
        },
        {
            "sample_idx": 556,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different functions with no direct code dependency. Edit 0 adds a new function `external_data_workflow_exists` that takes an `id` parameter and calls `schedule_exists`. Edit 1 modifies an existing function `pause_external_data_schedule` by changing a parameter from `str(external_data_source.id)` to `id`. While both edits involve the variable name `id`, they reference different symbols in different scopes - the `id` parameter in the new function is a different symbol from the `id` being used in the modified function. There is no explicit code linkage between these changed lines, and making one edit does not create an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 558,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol 'x_shape' in the same function scope. Edit 0 adds 'x_shape' to the unpacking of the 'state' parameter, while Edit 1 adds 'x_shape' to the return tuple. These edits are part of a single micro-task of adding a new state variable to the function's state handling. The changed lines in both edits explicitly reference the same symbol 'x_shape', and making either edit creates an immediate code-driven prompt for the other to maintain consistency in the state tuple structure. Either edit can be made first without causing parse errors, but after making one, the other becomes the mechanically obvious next step to complete the state variable addition."
        },
        {
            "sample_idx": 559,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 adds a new command-line argument '--vcs-rev' to the argument parser, and Edit 0 modifies code to use 'args.vcs_rev' (which comes from that new argument). The changed lines reference the exact same symbol - the vcs_rev attribute that gets added to the args object. Edit 0's change to use 'args.vcs_rev' creates an immediate code dependency on the argument being defined in Edit 1. However, in Python, accessing an undefined attribute on an args object would only cause a runtime AttributeError, not a parse-time syntax error. Both edits can be written and parsed in either order, so this is a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 557,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits involve changes to code that references the same variable 'is_cfg_pp', but they are making different types of changes. Edit 0 replaces the condition 'is_cfg_pp' with 'self.need_last_noise_uncond' and consolidates two lines into one. Edit 1 removes an entire elif block that checks 'is_cfg_pp'. While both edits involve the same variable name 'is_cfg_pp', they are referencing different instances of this variable in different conditional blocks within the same function. The changes appear to be part of a larger refactoring to remove or replace the 'is_cfg_pp' logic, but there is no direct code dependency between the specific changed lines - one edit changing a condition doesn't create an immediate mechanical prompt for removing a different elif block. The relationship is conceptual/thematic (both removing 'is_cfg_pp' usage) rather than a direct code linkage where one edit creates an immediate prompt for the other."
        },
        {
            "sample_idx": 560,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours. Edit 0 adds an import for 'timedelta' from the datetime module, while Edit 1 modifies calculation logic by introducing an 'offset' variable and changing how 'removed_candles' is computed. Although both edits are in the same test file, there is no direct code linkage between them - the changed lines in Edit 1 do not reference, use, or call the 'timedelta' symbol that was imported in Edit 0. The import appears to be for future use elsewhere in the file, while the calculation change is independent logic modification. Without the exact same symbol being referenced in both edits' changed lines, this is merely coincidental editing in the same file rather than a mechanically driven code dependency."
        },
        {
            "sample_idx": 561,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts. Edit 0 adds a 'cwd' parameter to a Popen call in devserver.py, while Edit 1 removes a line that defines a 'cwd' variable in http.py. Although both involve 'cwd' and Popen calls, they reference different symbols in different files and contexts. The 'cwd' variable being removed in Edit 1 is a different symbol from the 'cwd' parameter being added in Edit 0. There is no direct code dependency or explicit linkage between the changed lines - they don't reference the same symbol, and neither edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 562,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add ACL-related configuration to the same test class (GCSFeedStorageTest), but they reference different symbols and serve different purposes. Edit 0 adds 'FEED_STORAGE_GCS_ACL': 'publicRead' to a settings dictionary in the test_parse_settings method, while Edit 1 adds a local variable acl = 'publicRead' in the test_store method. The changed lines do not reference the exact same symbol - one is a dictionary key-value pair in a settings dict, and the other is a local variable assignment. There is no direct code dependency between these changed lines, and neither edit creates an immediate, mechanically obvious prompt for the other. The relationship is conceptual (both relate to ACL configuration for GCS) but lacks the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 563,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a 'weight_dtype' parameter to the INPUT_TYPES method of UNETLoader class, while Edit 1 modifies the load_unet method to use 'weight_dtype' as an argument to comfy.sd.load_unet(). However, these edits reference different symbols: Edit 0 adds 'weight_dtype' as an input specification in the INPUT_TYPES dictionary, while Edit 1 references 'weight_dtype' as a variable in the load_unet method signature. The load_unet method signature itself is not shown to be modified to accept weight_dtype as a parameter. Without seeing the method signature change that would connect these two edits, they reference different symbols despite having the same name. Edit 1 appears to reference a weight_dtype parameter that should come from the method signature, but that connection is not explicitly shown in the changed lines."
        },
        {
            "sample_idx": 565,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated code changes. Edit 0 changes a docstring from 'Registers' to 'Register' in the _add_browser_connection method. Edit 1 reformats a self.write() call by splitting it across multiple lines in the _DebugHandler class. The changed lines reference entirely different symbols and contexts - one is a docstring modification, the other is a formatting change to a method call. There is no explicit code dependency, no shared symbols being referenced, and no mechanical prompt from one edit to the other. These are independent stylistic improvements that happen to be in the same file but have no direct code linkage."
        },
        {
            "sample_idx": 564,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the traceback module, and Edit 1 uses that exact same traceback module in the ExcInfo class by calling traceback.format_exception(). This creates a direct import-usage relationship where the changed lines reference the exact same symbol. The import in Edit 0 makes the traceback module available for use in Edit 1. While Edit 1 could be written before Edit 0 without causing a parser error (Python allows referencing undefined names), after making either edit, the other becomes the immediate next step to complete the functionality - either importing the needed module or using the imported module."
        },
        {
            "sample_idx": 567,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add the same key 'is_legacy_optimizer' to configuration dictionaries in get_config() methods of different optimizer classes, but they are adding it to completely different classes in different files (experimental optimizer vs legacy optimizer). While this appears to be part of a coordinated change to distinguish between legacy and non-legacy optimizers, the changed lines reference different symbols - different config dictionaries in different class methods. There is no direct code dependency between these specific lines, and neither edit creates an immediate mechanical prompt for the other. This is a thematic/conceptual relationship where both edits serve the same purpose but operate on different symbols."
        },
        {
            "sample_idx": 566,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different aspects of the GlancesPassword class and do not have a direct code dependency. Edit 0 removes an import statement for GlancesPassword from one file, while Edit 1 adds a super() call to the __init__ method of the GlancesPassword class in a different file. The changed lines do not reference the exact same symbol - one affects the import/availability of the class, while the other modifies the internal implementation of the class constructor. There is no immediate, mechanically obvious code-driven prompt between these changes. The removal of an import and the addition of a super() call are conceptually related to the same class but represent different types of modifications without explicit linkage between the changed lines themselves."
        },
        {
            "sample_idx": 568,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite having similar names. Edit 0 adds a function called 'schedule_exists' in the temporal/common/schedule.py file, while Edit 1 uses a variable called 'schedule_exists' that gets its value from calling 'external_data_workflow_exists()' function. The changed lines reference completely different symbols - one is defining a new function with @async_to_sync decorator, the other is assigning the result of a different function call to a local variable. There is no direct code dependency, import relationship, or synchronized pattern between these edits. The similarity in naming is purely coincidental and conceptual, not a direct symbol reference."
        },
        {
            "sample_idx": 570,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file but affect completely different aspects of the code. Edit 0 adds a constant definition (PREHEATED_REPORT_CONTEXT) at the module level, while Edit 1 changes a docstring comment in a method from 'Registers a connected browser to the server' to 'Register a connected browser with the server'. There is no direct code dependency between these changes - the changed lines do not reference the same symbol, and neither edit creates a mechanical prompt for the other. The constant definition has no relationship to the docstring change, and they could be made in any order without affecting each other. This is purely a coincidental pairing of unrelated changes."
        },
        {
            "sample_idx": 569,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours because they reference different symbols and lack direct code linkage. Edit 0 modifies a docstring to mention 'PREHEATED_REPORT_CONTEXT' as a type annotation, while Edit 1 calls a method 'add_preheated_report_context()' on a server object. Although both edits relate to preheated report context functionality, the changed lines reference completely different symbols: one references a type/class name in documentation, the other calls a method. There is no explicit code dependency between the specific lines changed - the docstring change doesn't create a mechanical prompt for the method call, nor vice versa. The relationship is purely conceptual/thematic rather than based on direct symbol reference or structural dependency."
        },
        {
            "sample_idx": 571,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural transformation on calls to the same function `optimizers.deserialize()`. Each edit adds the same `use_legacy_optimizer` parameter (with different boolean values) and reformats the parameter list in the exact same way. This represents a bulk edit pattern where the same syntactic construct (function call) is being modified with the same structural changes across multiple locations. The edits reference the exact same function symbol and apply an identical before\u2192after transformation pattern, making them part of a single, contiguous refactoring operation where either edit could be made first and would naturally prompt the other as the next mechanical step in the same micro-task."
        },
        {
            "sample_idx": 572,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols despite both involving an 'acl' parameter. Edit 0 adds an 'acl' parameter to the GCSFeedStorage.__init__ method signature in the production code. Edit 1 adds an 'acl' variable assignment in a test method. However, the changed lines reference different symbols: Edit 0 references the parameter 'acl' in the constructor signature, while Edit 1 references a local variable 'acl' in the test method scope. These are different symbols in different scopes. There is no direct code dependency or explicit linkage between the exact same symbol in both changed lines. The connection is only conceptual (both relate to ACL functionality) rather than a direct code-driven dependency."
        },
        {
            "sample_idx": 573,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite both relating to database connections. Edit 0 uses `connection.connect()` where `connection` is already available in scope (likely from an existing import in the same file), while Edit 1 adds a new import `from django.db import connection` in a completely different file (delete.py vs create.py). The changed lines reference different connection objects in different files and scopes - they are not the exact same symbol. There is no direct code dependency between these specific changed lines, and no evidence they are part of a synchronized multi-file substitution pattern. The relationship is purely conceptual (both involve database connections) rather than involving explicit code linkage between the same symbol."
        },
        {
            "sample_idx": 574,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits add the same import statement 'from . import __version__' to different files (modeling_flax_utils.py and pipeline_utils.py). While they involve the exact same symbol (__version__) and follow an identical pattern, they are in separate files with no direct code dependency between them. The changed lines don't reference each other - they are independent import additions that happen to import the same symbol. This appears to be a bulk refactoring operation where __version__ is being made available in multiple modules, but the edits themselves don't create a direct mechanical prompt for each other. Each file can independently import __version__ without requiring the other file to do so first."
        },
        {
            "sample_idx": 575,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 removes comment lines from a function definition in numpy/core/_internal.py, while Edit 1 adds an import (assert_raises_regex) to the import statement in numpy/core/tests/test_multiarray.py. The changed lines reference entirely different symbols and contexts - one involves comments around a _newnames function definition, the other involves importing a test assertion function. There is no explicit code linkage, no shared symbols, and no mechanical dependency between removing comments and adding an import. These edits would be part of separate, independent micro-tasks."
        },
        {
            "sample_idx": 576,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new parameter 'weight_dtype' to the function signature and defines a local variable 'weight_dtype' within the function body. Edit 1 uses this exact same 'weight_dtype' variable as an argument in the function call. The changed lines reference the exact same symbol - the 'weight_dtype' variable that is defined in edit 0 and used in edit 1. This creates an immediate, mechanically obvious code dependency where defining the variable in edit 0 makes it available for use in edit 1. Both edits are part of a single micro-task of adding weight_dtype support to the load_unet method. Since this is Python, both edits can be parsed and staged in either order (using an undefined variable only causes a runtime NameError, not a parse error), making this bi-directional."
        },
        {
            "sample_idx": 577,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats a parser.add_argument() call in glances/main.py by splitting the arguments across multiple lines for better readability. Edit 1 removes a comment line ('# Second line (optional)') in glances/outputs/glances_curses.py. The edits affect different files, different classes, different methods, and involve completely different symbols and code constructs. There is no shared symbol, no code dependency, and no structural relationship between reformatting argument parsing code and removing a comment from display logic. The only connection is that both files are part of the same project, which is purely conceptual."
        },
        {
            "sample_idx": 578,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the symbol AWS_REGION_US_EAST_1 from localstack.constants, and Edit 1 uses that exact same imported symbol in a conditional check (region == AWS_REGION_US_EAST_1). The changed lines reference the exact same symbol - Edit 0's changed line imports AWS_REGION_US_EAST_1, and Edit 1's changed lines use AWS_REGION_US_EAST_1. This creates an immediate code-driven linkage where importing the symbol naturally prompts its usage, and using the symbol requires its import. Both edits can be staged in either order since Python allows referencing imported symbols before the import statement is executed (it would only cause a runtime NameError, not a parse error), making this a bi-directional relationship."
        },
        {
            "sample_idx": 580,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a new command-line argument '--separator' to the argument parser in the main.py file, while Edit 1 reformats the display_plugin method call in the curses output module by breaking a long line into multiple lines for better readability. The changed lines reference entirely different symbols and code constructs - one deals with argument parsing configuration and the other with UI display formatting. There is no shared symbol, no code dependency, and no structural relationship between adding a separator argument and reformatting a display call. These edits would be part of different micro-tasks and have no immediate, mechanically obvious code-driven connection."
        },
        {
            "sample_idx": 581,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits are modifying the same method `_add_browser_connection` and both reference the exact same symbol `PREHEATED_REPORT_CONTEXT`. Edit 0 updates the docstring to indicate that the `ws` parameter can now accept `PREHEATED_REPORT_CONTEXT` in addition to `_BrowserWebSocketHandler`. Edit 1 implements the actual logic to handle `PREHEATED_REPORT_CONTEXT` by checking if it exists in `self._report_contexts` and using it if available. The changed lines in both edits directly reference the same symbol `PREHEATED_REPORT_CONTEXT`, creating an immediate code-driven relationship where documenting the new parameter type and implementing the logic to handle that type are part of the same contiguous micro-task. Either edit could be made first without causing parse errors, making this a bi-directional relationship."
        },
        {
            "sample_idx": 583,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the 'sys' module, and Edit 1 uses 'sys.exc_info()' in the changed line. This creates a direct import-usage relationship where both edits reference the exact same symbol 'sys'. After making the import in Edit 0, using sys.exc_info() in Edit 1 becomes the immediate next step that utilizes the imported module. In Python, usage before import would result in a NameError at runtime but both edits can be parsed and staged in either order, making this a bi-directional relationship rather than ordered."
        },
        {
            "sample_idx": 582,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different files and modify different parts of the codebase without any direct code linkage. Edit 0 adds a call to `self.filter_relations(child_relations)` in the BaseDeletionTask class, while Edit 1 adds a `skip_models` parameter to a `deletions.get()` call in a cleanup command. The changed lines do not reference the same symbol, function, parameter, or import. While both edits may be conceptually related to deletion/cleanup functionality, there is no explicit code dependency or structural relationship between the specific lines being changed. The `filter_relations` method call in Edit 0 and the `skip_models` parameter in Edit 1 are different symbols with no direct connection."
        },
        {
            "sample_idx": 584,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 1 adds an import statement 'from . import __version__' which makes the __version__ symbol available in the modeling_utils.py file. Edit 0 uses __version__ in a user_agent dictionary within modeling_flax_utils.py. However, these are two different files and there's no evidence that modeling_flax_utils.py imports from modeling_utils.py or that they reference the exact same __version__ symbol. The __version__ used in edit 0 would need to be imported separately in that file. While both edits involve __version__, they reference different symbols (same name, different scopes/files) and there's no direct code dependency between the changed lines themselves."
        },
        {
            "sample_idx": 586,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a new function `schedule_exists` to a schedule module, while Edit 1 removes an import `aget_schema_by_id` from an external data job module. The changed lines reference entirely different symbols (`schedule_exists` function vs `aget_schema_by_id` import), are in different files with different purposes, and have no explicit code dependency or linkage between them. There is no direct syntactic or structural relationship that would make one edit prompt the other as the next mechanical step."
        },
        {
            "sample_idx": 585,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file and function but modify completely different parts of the code with no direct code dependency. Edit 0 adds a conditional route addition using `cmd_opts.add_stop_route` and `app.add_route()`, while Edit 1 removes a print statement from a KeyboardInterrupt handler. The changed lines reference entirely different symbols and code constructs - one deals with route configuration and the other with exception handling output. There is no explicit code linkage, shared symbol reference, or structural dependency between adding a stop route and removing a print statement. They appear to be independent changes that happen to be in the same function but serve different purposes."
        },
        {
            "sample_idx": 579,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve completely different files and different symbols with no direct code linkage. Edit 0 adds method calls (init_column() and separator_line()) to a display method in the curses output module, while Edit 1 adds Unicode character mappings ('MEDIUM_LINE' and 'LOW_LINE') to a Unicode configuration dictionary. The changed lines reference entirely different symbols - method calls versus dictionary keys - and there is no explicit dependency, import relationship, or synchronized substitution pattern between them. While both may conceptually relate to display formatting, there is no direct code-driven prompt from one edit to the other at the locus of change."
        },
        {
            "sample_idx": 588,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they form a synchronized pair that handles the same configuration key 'is_legacy_optimizer'. Edit 0 adds this key to the config dictionary in get_config(), while Edit 1 removes this same key in from_config() before passing the config to the constructor. Both changed lines explicitly reference the exact same symbol (the string key 'is_legacy_optimizer'), and they implement a complementary serialization/deserialization pattern where one edit naturally prompts the other as the next mechanical step. Either edit can be implemented first since both are syntactically valid independently, but together they form a complete round-trip configuration handling mechanism."
        },
        {
            "sample_idx": 587,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits are part of the same test method and involve adding the same 'acl' parameter to related operations. Edit 0 adds 'acl' to the GCSFeedStorage constructor call, while Edit 1 adds 'predefined_acl=acl' to the mock assertion for the upload operation. These edits are testing the same feature (ACL support) and would naturally be made together as part of updating a single test case to verify that ACL parameters are properly passed through the system. However, the changed lines reference different symbols - one references the GCSFeedStorage constructor and the other references the upload_from_file method assertion. While they're conceptually related and part of the same test update, there's no direct code dependency where one edit creates an immediate mechanical prompt for the other at the symbol level."
        },
        {
            "sample_idx": 589,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different files and modify completely unrelated code sections. Edit 0 adds a condition check 'self.name in executor_endpoint_mapping' to a conditional statement in the topology graph's request handling logic. Edit 1 modifies an error message string to include 'while gathering endpoints' for better clarity. The edits do not reference the same symbols, variables, functions, or have any direct code dependency. They appear to be separate improvements made to different parts of the codebase - one fixing a potential KeyError issue and another improving error message clarity. There is no explicit code linkage, no shared symbols being referenced in the changed lines, and no immediate mechanical prompt from one edit to the other."
        },
        {
            "sample_idx": 591,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits perform identical structural transformations - they take function calls with multiple parameters on a single line and reformat them to have each parameter on its own line. However, they operate on completely different symbols in different files and contexts: Edit 0 modifies a parser.add_argument() call for IRQ module configuration in main.py, while Edit 1 modifies a self.display_plugin() call for uptime display in the curses output module. The changed lines reference entirely different symbols (parser.add_argument vs self.display_plugin) and there is no direct code dependency between them. This is purely a code formatting/style change applied to different parts of the codebase, not a case where making one edit creates a code-driven prompt for the other."
        },
        {
            "sample_idx": 590,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add an identical parameter `dtype=None` to function signatures in the same file. However, these are different functions (`load_unet_state_dict` and `load_unet`) that represent different symbols. While the parameter addition follows the same pattern, there is no explicit code dependency between these specific functions shown in the changed lines - neither function calls the other, and the changed lines don't reference the exact same symbol. This appears to be a bulk refactoring pattern where the same parameter is being added to multiple related functions, but since the changed lines reference different function symbols, this falls under 'no relation' according to the criteria that emphasize the exact same symbol must be referenced in both edits."
        },
        {
            "sample_idx": 593,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different functionality. Edit 0 adds a break condition in a pipe() function within SendText class when data is empty, while Edit 1 adds an __init__ method to the TTYIO class with a read_with_timeout parameter. Although both edits relate to TTY/terminal operations conceptually, the changed lines reference completely different symbols - one references 'data' in a pipe function, the other defines initialization parameters for a TTYIO class. There is no direct code dependency, no shared symbol references, and no mechanical prompt from one edit to the other. The relationship is purely conceptual/thematic rather than based on explicit code linkage."
        },
        {
            "sample_idx": 592,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the codebase. Edit 0 adds a 'preview' key to what appears to be a configuration dictionary in the get_configuration function. Edit 1 adds logic to check 'start_at_animation_number' and conditionally set 'skip_animations' in the Scene class constructor. While both edits may be part of the same feature (animation control), the changed lines reference completely different symbols: 'preview' vs 'start_at_animation_number' and 'skip_animations'. There is no direct code dependency between these specific lines - they don't reference, assign, call, or import the exact same symbol. The connection is only conceptual/thematic (both related to animation configuration), which according to the criteria should be labeled as 'no relation'."
        },
        {
            "sample_idx": 594,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same function `bisection` but in different contexts and files. Edit 0 removes timing code around a `bisection` call in `lib/request/inject.py`, while Edit 1 adds timing code around a different `bisection` call in `lib/utils/resume.py`. Although both edits involve timing measurements for `bisection` calls, they reference different call sites of the same function name in separate files and contexts. The changed lines do not reference the exact same symbol - they are different invocations of `bisection` in different scopes. There is no direct code dependency between these specific changed lines, and no explicit linkage that would make one edit mechanically prompt the other. This appears to be a refactoring where timing code is being moved or reorganized, but the edits operate on different symbols despite involving the same function name."
        },
        {
            "sample_idx": 595,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These edits both add the same key 'is_legacy_optimizer' to configuration dictionaries, but they are adding it to completely different systems and symbols. Edit 0 modifies a docstring example within the serialize() function in the __init__.py file, while Edit 1 adds the key to the actual get_config() method implementation in a different optimizer class in a different file. The changed lines do not reference the exact same symbol - one is documentation text and the other is actual implementation code. There is no direct code dependency or explicit linkage between these specific changed lines, even though they conceptually relate to the same feature. This is a thematic/conceptual relationship rather than a direct code-driven linkage between the same symbol."
        },
        {
            "sample_idx": 596,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 imports the module 'glances.outputs.glances_unicode' (specifically the 'unicode_message' function), while Edit 1 adds new entries to a dictionary within that same module. However, the changed lines reference different symbols - Edit 0 references the 'unicode_message' function in its import statement, while Edit 1 adds new dictionary entries ('MEDIUM_LINE' and 'LOW_LINE') that are not the same symbol being imported. The import statement specifically imports 'unicode_message', not the dictionary being modified in Edit 1. Since the changed lines don't reference the exact same symbol, this is a case of same module but different symbols being affected."
        },
        {
            "sample_idx": 597,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same configuration key 'is_legacy_optimizer' but in different contexts and classes. Edit 0 adds this key to the config dictionary in the experimental optimizer's get_config method, while Edit 1 removes this key from the config dictionary in the legacy optimizer's from_config method. However, these are different symbols in different scopes - one is a string literal being added to a config dict in one class, and another is a string literal being used to check and delete from a config dict in a completely different class. The changed lines don't reference the exact same symbol, and there's no direct code dependency between these specific lines. While they may be conceptually related as part of a broader migration or compatibility feature, there's no immediate, mechanically obvious code-driven prompt from one edit to the other."
        },
        {
            "sample_idx": 599,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 adds a command-line argument '--separator' with destination 'enable_separator' in the argument parser. Edit 1 removes a comment '# Second line (optional)' from a display method in the curses output class. There is no explicit reference to the same symbol between the changed lines - one deals with argument parsing configuration while the other modifies UI display code. The edits may be conceptually related to UI separator functionality, but the changed lines themselves do not reference, assign, call, or import the exact same symbol. This is purely a conceptual/thematic relationship without direct code dependency."
        },
        {
            "sample_idx": 598,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to ACL (Access Control List) functionality in Google Cloud Storage tests, but they reference different aspects of ACL handling. Edit 0 adds an assertion to verify that the storage object has an 'acl' attribute set to 'publicRead' in the settings parsing test. Edit 1 modifies a mock assertion to verify that the upload method is called with a 'predefined_acl' parameter. While both edits involve ACL concepts, they test different parts of the system - one tests attribute parsing/storage, the other tests method call parameters. The changed lines don't reference the exact same symbol or create a direct code dependency between them. They are conceptually related but lack the explicit, mechanical code linkage required for neighbour classification."
        },
        {
            "sample_idx": 600,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different function calls in separate files. Edit 0 adds a `use_legacy_optimizer=True` parameter to an `optimizers.deserialize()` call in the LossScaleOptimizer class. Edit 1 adds code to delete an `is_legacy_optimizer` key from a config dictionary in the _BaseOptimizer class before calling `cls(**config)`. While both edits are conceptually related to legacy optimizer handling, they reference completely different symbols: Edit 0 modifies a call to `optimizers.deserialize()` while Edit 1 modifies config processing in a `from_config` method. The changed lines do not reference the exact same symbol, function call, or variable - they are different code constructs in different files dealing with different aspects of optimizer configuration."
        },
        {
            "sample_idx": 602,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols in different files and contexts. Edit 0 removes code related to schema model checking and sync logic in an external data job file, while Edit 1 adds an import for 'schedule_exists' in a warehouse data load service file. There is no shared symbol, function, class, or variable being referenced between the changed lines. The edits are in different modules (temporal vs warehouse), serve different purposes, and have no direct code dependency or structural relationship."
        },
        {
            "sample_idx": 601,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different types of changes. Edit 0 removes an import of 'aget_schema_by_id' from a temporal data imports file, while Edit 1 changes a parameter from 'str(external_data_source.id)' to 'id' in a warehouse service file's pause_schedule function call. There is no explicit code linkage between the removed import and the parameter change - they reference completely different symbols and perform different operations. The changed lines do not reference, assign, call, or import the exact same symbol. This is purely coincidental that both edits modify code in the same codebase."
        },
        {
            "sample_idx": 603,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of optimizer configuration. Edit 0 adds a 'use_legacy_optimizer=True' parameter to an optimizers.deserialize() function call in the LossScaleOptimizer class. Edit 1 adds an 'is_legacy_optimizer': False key-value pair to what appears to be a test configuration dictionary in a completely different file and context. While both edits relate to legacy optimizer concepts, they reference different symbols (a function parameter vs a dictionary key), are in different files, different classes, and different contexts (production code vs test code). The changed lines do not reference the exact same symbol - one is a function call parameter and the other is a dictionary entry in a test. There is no direct code dependency or synchronized substitution between these specific changes."
        },
        {
            "sample_idx": 604,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits involve the exact same variable `stagle_table_name` within the same function. Edit 0 adds a new definition of `stagle_table_name` with a more complex string formatting that includes a timestamp, while Edit 1 removes the old, simpler definition of the same variable. The changed lines reference the exact same symbol and represent a direct replacement/refactoring of how this variable is defined. This creates an immediate code-driven relationship where both edits are part of the same micro-task of updating the variable definition. Either edit can be applied first without causing parse errors, making this a bi-directional relationship where making either edit naturally prompts the other as the next step to complete the refactoring."
        },
        {
            "sample_idx": 605,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and have no direct code dependency. Edit 0 removes an import of 'aget_schema_by_id' from one file, while Edit 1 changes a function signature by replacing the 'external_data_source' parameter with an 'id' parameter in a completely different file and function. There is no evidence that the changed lines reference the same symbol - 'aget_schema_by_id' and 'unpause_external_data_schedule' are different symbols. The edits appear to be independent refactoring operations with no explicit code linkage between the specific lines being changed."
        },
        {
            "sample_idx": 607,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve completely different symbols and operations. Edit 0 adds documentation for a 'weights' parameter in the Embedding class docstring, while Edit 1 removes an entire test method 'test_quantize_on_unbuilt_layer' that tests quantization functionality. The changed lines reference different symbols - Edit 0 references the 'weights' parameter in documentation, while Edit 1 removes code that references 'layer.quantize()' method. There is no direct code dependency, shared symbol reference, or synchronized pattern between adding parameter documentation and removing a quantization test. These are separate maintenance operations with no explicit code linkage."
        },
        {
            "sample_idx": 606,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits do not reference the exact same symbol in their changed lines. Edit 0 removes a line that checks if 'CFG++' is in the sampler config name and assigns it to `is_cfg_pp`. Edit 1 modifies a function call to `self.combine_denoised` by multiplying `cond_scale` with `self.cond_scale_miltiplier`. While both edits are in the same method and may be conceptually related to CFG processing, the changed lines reference completely different symbols - `is_cfg_pp` and sampler config in edit 0, versus `cond_scale` and `cond_scale_miltiplier` in edit 1. There is no direct code dependency or explicit symbol linkage between the specific lines being changed."
        },
        {
            "sample_idx": 609,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits handle the same configuration key 'is_legacy_optimizer' but in different contexts and for different purposes. Edit 0 reads this key from config['config']['is_legacy_optimizer'] to determine optimizer loading behavior, while Edit 1 removes this key from the config dictionary before passing it to the constructor. However, the changed lines reference different symbols - Edit 0 references config['config']['is_legacy_optimizer'] while Edit 1 references config['is_legacy_optimizer'] (different nesting levels). Additionally, there is no direct code dependency between these specific changed lines - they operate on the same conceptual configuration key but at different points in the deserialization process without one edit creating an immediate, mechanically obvious prompt for the other. The relationship is thematic/conceptual rather than involving explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 611,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they both modify the exact same state tuple structure in the sm3 optimizer function. Edit 0 adds 'x_shape' as a fourth element to the return tuple in the init function, while Edit 1 updates the unpacking of that same state tuple in get_params to handle the new fourth element. The changed lines reference the exact same state structure - one edit extends the tuple and the other edit consumes the extended tuple. After making either edit, the other becomes immediately necessary to maintain consistency of the state tuple structure. Both edits can be written and parsed in either order (no syntax errors), but together they form a synchronized modification of the same data structure."
        },
        {
            "sample_idx": 608,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits involve the exact same line of code being added/modified: `debugMsg = \"performed %d queries in %d seconds\" % (count, int(time.time() - start))`. Edit 0 modifies an existing line to use `int(time.time() - start)` instead of `duration`, while Edit 1 adds the identical line with the same `int(time.time() - start)` pattern. This represents a bulk uniform substitution where the same before\u2192after pattern (replacing `duration` with `int(time.time() - start)`) is being applied to the same type of syntactic construct (debugMsg assignment statements) across multiple locations. Both edits are part of a single refactoring operation to standardize how query duration is calculated and displayed in debug messages."
        },
        {
            "sample_idx": 610,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (is_legacy_optimizer) but they reference different symbols and contexts. Edit 0 adds a hardcoded value 'False' to a config dictionary in one test file, while Edit 1 adds an assertion checking that a config value equals 'True' in a different test file. The changed lines don't reference the exact same symbol - one is setting a literal value in a dictionary, the other is asserting on a config property from a different optimizer instance. They are testing different optimizer types (experimental vs v2) and the 'is_legacy_optimizer' values are even different (False vs True). While both relate to the same conceptual feature, there is no direct code dependency or synchronized substitution between the exact same symbols in the changed lines."
        },
        {
            "sample_idx": 615,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (adding ACL support to GCS feed storage) but they reference different symbols and lack direct code linkage. Edit 0 adds an 'acl' parameter to the GCSFeedStorage.__init__ method signature, while Edit 1 adds a new configuration setting 'FEED_STORAGE_GCS_ACL'. The changed lines do not reference the exact same symbol - one is a parameter in a method signature, the other is a configuration constant. While conceptually related (both support ACL functionality), there is no explicit code dependency between the changed lines themselves. The parameter 'acl' in the constructor and the setting 'FEED_STORAGE_GCS_ACL' are different symbols, even though they serve the same conceptual purpose. This falls under the 'conceptual or feature-based link only' category which should be labeled as 'no relation'."
        },
        {
            "sample_idx": 613,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new parameter 'run_tests' to the startup function signature (implicitly, as we can see it's being used in the conditional 'if run_tests:'). Edit 1 updates the call site to pass the 'run_tests' parameter to the startup function. This is a classic function signature change paired with its corresponding call-site update for the exact same function. The changed lines reference the exact same symbol (the startup function) - one edit modifies the function's parameter usage, and the other edit updates the function call to match. This creates an immediate, mechanically obvious code-driven prompt: after adding the run_tests parameter usage in the function body, the call site must be updated to provide this parameter, or vice versa. Both edits can be staged in either order without causing parser errors (the function call with extra parameter won't cause a syntax error, just a runtime TypeError), making this bi-directional."
        },
        {
            "sample_idx": 612,
            "yi": "bi-directional",
            "pred": "0 before 1",
            "pred_reason": "Edit 0 removes the method `_test_error_exc_info` from the class, while Edit 1 changes a call from `self._test_error_exc_info()` to `_test_error_exc_info()`. These edits reference the exact same symbol and are part of a refactoring operation where the method is being moved from an instance method to what appears to be a module-level function. For this refactoring to work correctly, the method must first be removed from the class (Edit 0) before the call site can be updated to reference it without `self` (Edit 1). If Edit 1 were applied first, the code would fail because `_test_error_exc_info()` would not exist as a module-level function yet. This creates a mechanical dependency where Edit 0 must occur before Edit 1."
        },
        {
            "sample_idx": 614,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol `PREHEATED_REPORT_CONTEXT`. Edit 0 defines this constant at the module level, and edit 1 uses this constant in the `add_preheated_report_context` method. After defining the constant in edit 0, using it in edit 1 becomes a natural next step. Conversely, after writing the usage in edit 1, defining the constant in edit 0 becomes immediately necessary to resolve the undefined symbol. Both edits can be written and parsed in either order in Python (the usage would only cause a NameError at runtime, not a parse error), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 616,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats the arguments of a parser.add_argument() call in glances/main.py by splitting them across multiple lines for better readability. Edit 1 removes a blank line in glances/outputs/glances_unicode.py. The edits affect different files, different code constructs (argument formatting vs whitespace), and there is no shared symbol, function, variable, or any code dependency between them. They are purely independent formatting/cleanup changes with no mechanical relationship."
        },
        {
            "sample_idx": 619,
            "yi": "bi-directional",
            "pred": "1 before 0",
            "pred_reason": "These edits represent a cut-and-paste move operation of the exact same import statement. Edit 1 removes the import 'from glances.core.glances_passwordlist import GlancesPassword' from line 35, while Edit 0 adds the import 'from glances.core.glances_passwordlist import GlancesPasswordList as GlancesPassword' at line 34. This is a relocation where the symbol must be removed from its original position before being added to the new position to avoid duplicate imports. The removal must occur before the insertion to maintain clean code structure."
        },
        {
            "sample_idx": 617,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different functions and do not have a direct code dependency. Edit 0 modifies the signature of `load_unet_state_dict` function by adding a `dtype` parameter, while Edit 1 modifies a call to `comfy.sd.load_unet` function (not `load_unet_state_dict`) by adding a `dtype` parameter. Although both involve adding dtype parameters, they reference completely different symbols - `load_unet_state_dict` vs `load_unet`. The changed lines do not reference the exact same symbol, so there is no explicit code linkage between them. This appears to be a thematic relationship where both edits are part of adding dtype support to different functions, but without direct symbol dependency."
        },
        {
            "sample_idx": 618,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol 'acl' as an attribute of a storage object. Edit 0 adds 'self.acl = acl' in the GCSFeedStorage constructor, while edit 1 adds 'assert storage.acl == 'publicRead'' in the corresponding test. This is a clear test-production code synchronization pattern where the production code adds an attribute and the test code verifies that attribute for the same class. Both changed lines explicitly reference the same 'acl' attribute symbol, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 620,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits add the identical line 'connection.connect()' at the same relative position within two different 'record_exists' functions. While these functions have the same name and similar structure, they are defined in different scopes - one within 'wait_for_dns_records' and another within 'create_managed_proxy'. These are different symbols despite having identical names. The edits appear to be part of a bulk refactoring pattern where the same fix is being applied to multiple similar functions, but since they reference different function symbols in different scopes, they don't create a direct code dependency between each other. According to the criteria, same name in different scopes means different symbols, and without explicit cross-reference between the changed lines, this should be labeled as no relation."
        },
        {
            "sample_idx": 622,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits work together to handle a new 'is_legacy_optimizer' field in optimizer serialization. Edit 0 adds 'is_legacy_optimizer': True to the serialized config output in the docstring example, while Edit 1 adds code to remove this field from the config before creating an optimizer instance in from_config. They reference the exact same field name and form a complementary serialization/deserialization pair where the field is added during serialization and removed during deserialization. Both edits can be implemented in either order since they handle different parts of the process - one affects documentation/output format and the other affects config processing logic."
        },
        {
            "sample_idx": 621,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are conceptually related to the same feature (GCS ACL functionality) but reference different symbols and contexts. Edit 0 adds 'FEED_STORAGE_GCS_ACL': 'publicRead' to a settings dictionary in the test_parse_settings method, while Edit 1 adds predefined_acl=acl parameter to an upload_from_file assertion in the test_store method. The changed lines do not reference the exact same symbol - one references a dictionary key 'FEED_STORAGE_GCS_ACL' and the other references a parameter 'predefined_acl' and variable 'acl'. While both relate to ACL configuration testing, there is no direct code dependency or explicit symbol linkage between the specific changed lines. This is a thematic relationship without mechanical code-driven prompting between the edits."
        },
        {
            "sample_idx": 623,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same function `unpause_external_data_schedule` but they reference different parameters/variables. Edit 0 changes the call site to pass `str(source.id)` instead of `source`, while Edit 1 changes the function body to use `id` instead of `str(external_data_source.id)`. However, the changed lines reference different symbols: Edit 0 references `source` and `source.id`, while Edit 1 references `external_data_source.id` and `id`. Even though they involve the same function, the actual symbols being modified in each edit are different - they are not the exact same symbol being referenced in both changed lines. This appears to be a refactoring where the function signature was changed from accepting an object to accepting an ID string, but the edits don't have direct code linkage between the exact same symbols."
        },
        {
            "sample_idx": 624,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 adds an import for 'TrinoQueryError' from the trino.exceptions module in the operators file. Edit 1 modifies a SQL string in a test file to add 'IF NOT EXISTS' clause to a CREATE TABLE statement. The changed lines reference different symbols - one imports an exception class while the other modifies a SQL string literal. There is no explicit code dependency, no shared symbol reference, and no structural synchronization between these changes. They appear to be independent modifications that happen to involve Trino-related code but lack any direct, mechanical code linkage at the locus of change."
        },
        {
            "sample_idx": 625,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats the arguments of a parser.add_argument() call for the '--enable-irq' option in the main.py file, changing it from a single line to multiple lines for better readability. Edit 1 removes a comment ('# Second line (optional)') from a display method in the curses output module. The edits affect different files, different functionality (argument parsing vs display formatting), and there is no shared symbol, function, class, or any direct code dependency between the changed lines. The only connection is that both are part of the same codebase, which is purely conceptual and does not constitute a code-driven linkage."
        },
        {
            "sample_idx": 626,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve completely different symbols and functionality. Edit 0 adds documentation to the `_newnames` function in `numpy/core/_internal.py`, which is an internal utility function for handling datatype names and ordering. Edit 1 adds a test assertion in `numpy/core/tests/test_multiarray.py` that tests for duplicate field names in sort operations. While both edits relate to ordering concepts, they reference entirely different symbols: `_newnames` function vs `r.sort` method call. The changed lines do not reference, assign, call, or import the exact same symbol. There is no direct code dependency or explicit linkage between the documentation addition and the test assertion - they are conceptually related but involve different parts of the codebase."
        },
        {
            "sample_idx": 627,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 adds a new parameter 'is_self_hosted_billing' to the function signature of 'compute_plan_parameters', and Edit 0 adds that exact same parameter to a call site of 'compute_plan_parameters'. The changed lines reference the exact same symbol - the 'is_self_hosted_billing' parameter of the 'compute_plan_parameters' function. This creates an immediate, mechanically obvious code-driven prompt where adding the parameter to the function signature necessitates updating the call site to provide that parameter, and vice versa. Both edits can be staged in either order without causing parser errors (Python allows function calls with missing parameters and function definitions with unused parameters at parse time), making this a bi-directional relationship."
        },
        {
            "sample_idx": 628,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in completely different files (glances_curses.py vs glances_unicode.py) and affect entirely different code elements. Edit 0 removes a comment line '# Second line (optional)' from a display method in a curses output class, while Edit 1 removes a blank line from a unicode utility file. There is no shared symbol, function, variable, or any explicit code dependency between these changes. The edits don't reference the same symbol, don't have any structural relationship, and are not part of a uniform substitution pattern. They appear to be independent cleanup operations that happen to remove lines but have no mechanical code linkage."
        },
        {
            "sample_idx": 629,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are not neighbours in mental flow. Edit 0 adds a call to `self.separator_line()` in the curses output module, while Edit 1 adds Unicode character definitions ('MEDIUM_LINE' and 'LOW_LINE') to a Unicode character mapping dictionary in a different file. Although both edits might be conceptually related to display formatting or UI improvements, there is no direct code dependency between them. The changed lines do not reference the same symbol - Edit 0 calls a method `separator_line()` while Edit 1 defines Unicode character mappings that are not explicitly referenced in Edit 0's changed line. The connection, if any, is purely conceptual/thematic rather than representing an explicit, immediate code-driven prompt where one edit creates a mechanical need for the other."
        },
        {
            "sample_idx": 630,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts. Edit 0 adds a call to `connection.connect()` in the common.py file, while Edit 1 adds an import statement `from django.db import connection` in the delete.py file. Although both involve the 'connection' symbol, they are in different files and the changed lines reference different aspects - one is importing the connection module while the other is calling a method on an already-available connection object. There is no direct code dependency between these specific changed lines, and they appear to be separate, unrelated modifications to different files. The connection object used in Edit 0 may come from a different import or context than the one being imported in Edit 1."
        },
        {
            "sample_idx": 633,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 adds imports for SEND_CELERY_TASK_ERROR_EMAILS and mail_admins in celery/datastructures.py, while Edit 1 changes a return statement from 'exc' to 'ExcInfo(sys.exc_info())' in celery/worker.py. The changed lines do not reference the same symbols - one edit is adding imports while the other is modifying exception handling logic. There is no explicit code dependency between the specific lines changed, no shared symbol references, and no structural synchronization. While both may conceptually relate to error handling in the Celery framework, they lack the direct, mechanical code linkage required for a neighbor relationship."
        },
        {
            "sample_idx": 632,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits affect different symbols and have no direct code dependency. Edit 0 adds a break condition when `data` is empty in a loop that reads from `tty.tty_fd`. Edit 1 changes the parameter passed to `open_tty()` from `True` to `self.read_with_timeout`. While both edits relate to TTY handling, they reference different symbols: Edit 0 works with the `data` variable and `tty.tty_fd`, while Edit 1 modifies the `open_tty` function call with a different parameter. The changed lines do not reference the exact same symbol, and there is no explicit code linkage between adding a break condition and changing an `open_tty` parameter. The connection is only conceptual/thematic (both relate to TTY operations) rather than a direct code dependency."
        },
        {
            "sample_idx": 634,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits show a classic import-usage pattern for the exact same symbol. Edit 0 adds 'viewkeys' to the import statement from glances.compat, and Edit 1 uses that exact same 'viewkeys' symbol in a function call. The changed lines reference the same symbol - 'viewkeys' - where the import makes the symbol available and the usage consumes it. This creates a direct code dependency where either edit naturally prompts the other as the next mechanical step. In Python, both edits can be staged in either order since the usage would only fail at runtime (not parse time) if the import is missing, making this bi-directional rather than ordered."
        },
        {
            "sample_idx": 631,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are related by their shared reference to the exact same expression: `self.get_stats_display_width(stat_display[\"cloud\"]) != 0`. Edit 0 modifies a line that uses this expression in an `add_space` parameter calculation, while Edit 1 wraps the cloud display logic with a conditional check using the identical expression. Both edits are part of optimizing the cloud display behavior - Edit 0 adjusts spacing based on whether cloud stats will be displayed, and Edit 1 conditionally displays the cloud section only when there are stats to show. The changed lines in both edits reference the same method call with the same parameters, creating a direct code linkage. Either edit could be made first and would prompt the other as a natural next step in this UI optimization. This represents a bi-directional relationship where both edits work together to improve the cloud display logic using the same conditional expression."
        },
        {
            "sample_idx": 636,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a new configuration setting SEND_CELERY_TASK_ERROR_EMAILS to celery/conf.py, while Edit 1 adds an import statement for ExcInfo in celery/datastructures.py. The changed lines reference entirely different symbols - one introduces a configuration variable while the other imports a class. There is no direct code dependency, no shared symbol reference, and no mechanical prompt between these edits. They appear to be separate changes that happen to be part of the same codebase but have no explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 635,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits add identical code (checking for and deleting 'is_legacy_optimizer' from config) to different from_config methods in different optimizer classes. This represents a bulk edit pattern where the same structural change is being applied to multiple similar methods across the codebase. Both edits perform the exact same textual substitution (adding the same if-statement and del operation) and target the same type of syntactic construct (from_config methods). This appears to be part of a single, contiguous refactor to handle legacy optimizer configuration across multiple optimizer implementations."
        },
        {
            "sample_idx": 637,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits modify different parts of the same class but involve different methods and different functionality. Edit 0 adds calls to `self.init_column()` and `self.separator_line()` in the `display` method. Edit 1 modifies logic in the `__display_header` method, adding a conditional check around `self.new_line()` and `self.display_plugin()` calls for the cloud plugin. While both edits involve method calls on the same class instance (`self`), the changed lines reference completely different methods (`init_column`, `separator_line` vs `new_line`, `display_plugin`, `get_stats_display_width`) and serve different purposes in different methods. There is no direct code dependency between the specific symbols being referenced in each edit's changed lines - they are separate UI display operations that happen to be part of the same class but don't create an immediate, mechanically obvious prompt for each other."
        },
        {
            "sample_idx": 638,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 imports 'connection' from django.db in the common.py file, while Edit 1 uses 'connection.connect()' in the delete.py file. However, these are different symbols - the 'connection' imported in common.py is not the same symbol being used in delete.py. The changed lines reference different symbols despite having the same name. Edit 1's usage of 'connection' would need to reference the exact same imported symbol from Edit 0 for them to be neighbors, but there's no evidence that delete.py imports from common.py or uses the same connection symbol. These are different symbols in different scopes/contexts."
        },
        {
            "sample_idx": 639,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions and different aspects of the codebase. Edit 0 modifies a call to `pause_external_data_schedule()` by changing the argument from `job.pipeline` to `str(job.pipeline.id)` in the warehouse tasks module. Edit 1 adds a new function `external_data_workflow_exists()` in the data load service module. While both edits involve external data workflows conceptually, there is no direct code linkage between them - they don't reference the same symbol, function, or variable. The changed lines in each edit operate on completely different functions and there's no immediate, mechanically obvious prompt from one edit to the other. The relationship is purely conceptual/thematic rather than based on explicit code dependencies."
        },
        {
            "sample_idx": 640,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform identical textual substitution on the same type of syntactic construct - changing 'self._test_error_exc_info()' to '_test_error_exc_info()' in method calls within the same test class. This appears to be part of a single, contiguous refactor removing the 'self.' prefix from calls to this helper method. The substitution pattern (before\u2192after) is identical and both target the same construct type (method calls), making this a bulk-edit synchronization pattern where either edit could be made first as part of the same refactoring sweep."
        },
        {
            "sample_idx": 641,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add `start = time.time()` statements to capture the current time, but they are in completely different functions (`queryOutputLength` vs `resume`) and serve different timing measurement purposes. Edit 0 simply adds a timing start point, while Edit 1 adds timing functionality as part of a larger change that includes performance logging with query counts. The changed lines don't reference the same symbol - they are independent timing measurements in separate functions. There is no direct code dependency between these edits, and neither edit creates an immediate, mechanically obvious prompt for the other. The relationship is purely conceptual (both related to performance timing) rather than based on explicit code linkage."
        },
        {
            "sample_idx": 642,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the optimizer configuration system. Edit 0 adds 'is_legacy_optimizer': True to the config dictionary in the v1 optimizer's get_config method, while Edit 1 removes 'is_legacy_optimizer' from the config dictionary in the v2 Adagrad optimizer's from_config method. Although both edits reference the same string key 'is_legacy_optimizer', they are operating on different config dictionaries in different classes (Optimizer vs Adagrad) and different methods (get_config vs from_config). The changed lines do not reference the exact same symbol - they reference different local config variables in different scopes. While these edits may be conceptually related to handling legacy optimizer compatibility, there is no direct code dependency or explicit symbol linkage between the changed lines themselves."
        },
        {
            "sample_idx": 643,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits show a function signature change and its corresponding call-site update for the exact same function `pause_external_data_schedule`. Edit 1 changes the function signature from accepting an `ExternalDataSource` object to accepting a string `id` parameter. Edit 0 updates the call site to pass `str(job.pipeline.id)` instead of `job.pipeline` to match the new signature. Both edits reference the exact same symbol and create an immediate, mechanically obvious code-driven prompt for each other - changing either the function signature or the call site makes updating the other the next contiguous action to maintain code consistency. This is a classic definition-usage relationship where both edits can be staged in either order (no parse errors) but naturally prompt each other."
        },
        {
            "sample_idx": 644,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits add identical code (checking for and deleting 'is_legacy_optimizer' from config) in the same type of method (from_config class methods) across different optimizer classes. This represents a bulk/pattern synchronization where the same structural change is being applied uniformly across multiple similar constructs. The edits perform identical textual substitution (adding the same conditional deletion logic) and target the same type of syntactic construct (from_config methods in optimizer classes). This appears to be part of a single, contiguous refactor to handle legacy optimizer configuration cleanup across the codebase."
        },
        {
            "sample_idx": 645,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 adds a `dtype=None` parameter to the `load_unet` function signature, and Edit 0 modifies the function body to use this new `dtype` parameter with conditional logic (if dtype is None, use the existing logic, else use the provided dtype). The changed lines reference the exact same symbol - the `dtype` parameter. After adding the parameter in the signature (Edit 1), the next immediate, mechanically obvious step is to update the function body to actually use that parameter (Edit 0). Conversely, if you modify the body to reference `dtype` first (Edit 0), you would immediately need to add that parameter to the function signature (Edit 1). Both edits can be parsed and staged in either order in Python - referencing an undefined variable in a function body only causes a runtime error, not a parse error. This is a classic definition-usage pattern where both edits reference the same symbol and either naturally prompts the other as the next step."
        },
        {
            "sample_idx": 646,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different files and functions with no shared symbols or code dependencies. Edit 0 removes code from a function called `check_schedule_activity` in the temporal data imports module, specifically removing lines that check if a schema should sync. Edit 1 adds a new synchronous function `external_data_workflow_exists` in a warehouse data load service module. The changed lines in each edit reference entirely different symbols - edit 0 references `aget_schema_by_id`, `inputs.external_data_schema_id`, `inputs.team_id`, and `schema_model`, while edit 1 references `sync_connect()` and `schedule_exists()`. There is no explicit code linkage, shared symbol references, or structural dependency between these changes. They appear to be part of different refactoring or development tasks with no immediate mechanical prompt from one edit to the other."
        },
        {
            "sample_idx": 648,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file (lib/streamlit/Server.py) but affect completely different methods and functionality. Edit 0 is a simple formatting change to split a long conditional statement across multiple lines in the `_get_routes` method. Edit 1 is a substantial logic change in the `_add_browser_connection` method that adds preheated report context handling. The changed lines in each edit do not reference, assign, call, or import the same symbols. There is no explicit code linkage between the conditional statement about config options in edit 0 and the report context handling logic in edit 1. These are independent changes that happen to be in the same file but serve different purposes and don't create any immediate, mechanically obvious prompt for each other."
        },
        {
            "sample_idx": 647,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts. Edit 0 removes a line that calculates duration using `int(time.time() - start)` in the `__goInference` function in `inject.py`. Edit 1 adds a similar line that calculates duration using `int(time.time() - start)` in the `queryOutputLength` function in `resume.py`. While both edits involve the same code pattern for duration calculation, they reference different `start` variables in different functions and files - these are different symbols despite having the same name. The changed lines don't reference the exact same symbol, and there's no direct code dependency between them. This appears to be a refactoring where duration logging is being moved or reorganized across different functions, but the edits themselves don't create an immediate, mechanically obvious prompt for each other."
        },
        {
            "sample_idx": 649,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 modifies a function call to `unpause_external_data_schedule` by changing its argument from `source` to `str(source.id)`. Edit 1 adds an import of `schedule_exists` to an import list. The changed lines do not reference the same symbol - one is calling `unpause_external_data_schedule` while the other is importing `schedule_exists`. There is no explicit code dependency, no mirrored substitution pattern, and no immediate mechanical prompt from one edit to the other. The connection, if any, would be purely conceptual or thematic rather than based on direct symbol reference."
        },
        {
            "sample_idx": 650,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols despite having similar names. In edit 0, `x_shape = x0.shape` creates a new local variable `x_shape` within the `init` function scope. In edit 1, `return x, m, vs, x_shape` references a variable `x_shape` within the `update` function scope. These are different symbols in different function scopes, even though they have the same name. There is no direct code dependency between the changed lines - the `x_shape` being assigned in `init` is a different symbol from the `x_shape` being returned in `update`. The edits appear to be part of a larger refactoring but lack explicit code linkage between the exact same symbol."
        },
        {
            "sample_idx": 651,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports JinaLogger from jina.logging.logger, and Edit 1 uses JinaLogger in the constructor to create a logger instance. The changed lines reference the exact same symbol - JinaLogger. After importing JinaLogger in Edit 0, it becomes available for use in Edit 1. Conversely, if Edit 1 were made first, it would create an immediate code-driven prompt to import JinaLogger since the symbol would be undefined. This is a classic import-usage relationship within the same file where both edits reference the exact same symbol and either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 652,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 imports the function `pause_external_data_schedule` and Edit 0 calls that exact same function. The import in Edit 1 makes the function available for use, and Edit 0 uses it by calling `pause_external_data_schedule(str(job.pipeline.id))`. This creates a direct definition-usage relationship where both edits reference the exact same symbol. In Python, imports can be added after usage since undefined references only cause runtime NameError (not parse errors), making either edit possible first. After making either edit, the other becomes the immediate next step to complete the linkage."
        },
        {
            "sample_idx": 653,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbors in mental flow. Edit 0 adds an `is_self_hosted_billing` parameter to a call to `compute_plan_parameters()`, while Edit 1 adds an `is_self_hosted_billing` parameter to the `get_free_trial_days()` function definition. Although both edits involve the same parameter name, they reference completely different symbols - one is modifying a call to `compute_plan_parameters` and the other is modifying the signature of `get_free_trial_days`. There is no direct code dependency or linkage between these specific changed lines. The fact that both use a parameter with the same name is coincidental - they are different symbols in different contexts with no explicit reference relationship between the changed lines themselves."
        },
        {
            "sample_idx": 654,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different aspects of VCS revision handling. Edit 0 renames a function from 'get_vcs_rev_define' to 'get_vcs_rev', while Edit 1 adds a command-line argument '--vcs-rev'. Although both relate to VCS revision functionality conceptually, the changed lines reference different symbols - Edit 0 changes a function definition while Edit 1 adds an argument parser option. There is no direct code dependency where the changed lines reference the exact same symbol, and no explicit linkage between the function rename and the argument addition that would make one edit mechanically prompt the other as the immediate next step."
        },
        {
            "sample_idx": 657,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the optimizer system. Edit 0 adds a 'use_legacy_optimizer=True' parameter to a call to optimizers.deserialize() in the LossScaleOptimizer class. Edit 1 adds an 'is_legacy_optimizer': True entry to a config dictionary in the Optimizer class's get_config() method. While both relate to legacy optimizer handling, the changed lines reference completely different symbols: one is a parameter in a deserialize call, the other is a dictionary entry in a config method. There is no direct code dependency between these specific changed lines - they don't reference the same symbol, function, or variable. The relationship is purely conceptual/thematic around legacy optimizer support, which according to the criteria should be labeled as 'no relation'."
        },
        {
            "sample_idx": 655,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and have no direct code dependency. Edit 0 adds a new function `schedule_exists` to the schedule.py module, while Edit 1 changes the parameter signature of `pause_external_data_schedule` function in a different file (service.py), changing from `external_data_source: ExternalDataSource` to `id: str`. The changed lines reference completely different symbols - one defines a new function while the other modifies an existing function's parameter. There is no explicit code linkage, import relationship, or synchronized substitution pattern between these edits. They appear to be separate changes that happen to be related to scheduling functionality conceptually, but lack the direct symbol reference or mechanical dependency required for neighbour classification."
        },
        {
            "sample_idx": 656,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 imports `connection` from `django.db` in the create.py file, while Edit 1 uses `connection.connect()` in the delete.py file. However, these edits reference different symbols despite having similar names. The `connection` imported in create.py is a different symbol from the `connection` used in delete.py (which appears to be used without a corresponding import in that file). Since the changed lines reference different symbols in different files and scopes, and there is no direct code dependency between the exact same symbol, this falls under the 'same name, different symbols' case which should be labeled as 'no relation'."
        },
        {
            "sample_idx": 658,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines the symbol 'viewkeys' by adding it to the glances/compat.py module, while Edit 1 imports that exact same symbol 'viewkeys' from glances.compat. This creates a definition-usage relationship where both edits reference the exact same fully qualified symbol. In Python, imports can be written before their definitions are present (resulting in only a runtime ImportError, not a parse error), so either edit can be staged first. After making either edit, the other becomes the immediate, mechanically obvious next step to complete the definition-import pair."
        },
        {
            "sample_idx": 660,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file and class but modify completely different aspects of the code. Edit 0 adds documentation for a 'weights' parameter in what appears to be a docstring or parameter description section. Edit 1 adds an early return check 'if self.built: return' in the build() method implementation. There is no direct code dependency between these changes - the documentation change doesn't reference any symbol that the build method change affects, and vice versa. The changed lines reference different symbols and serve different purposes (documentation vs. implementation logic). While both edits are part of the same class, they lack the explicit, immediate code linkage required for neighbour classification."
        },
        {
            "sample_idx": 659,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different files and different symbols. Edit 0 modifies the display logic for cloud statistics in the curses output module, specifically changing how the cloud plugin is displayed by adding a conditional check and restructuring the display flow. Edit 1 simply removes a blank line in the unicode output module before a function definition. There is no shared symbol, function, variable, or structural element between these edits. The changed lines reference entirely different code constructs - one deals with display logic and plugin rendering, the other is a whitespace formatting change. There is no explicit code dependency, no mirrored substitution pattern, and no direct syntactic relationship between the changes."
        },
        {
            "sample_idx": 661,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits apply an identical structural transformation pattern to similar code constructs. Each edit: (1) adds the same line to create `data_interval_end_str` using identical datetime formatting logic, and (2) modifies the stage table name assignment to incorporate this timestamp suffix using the same pattern. The edits target analogous functions (`insert_into_bigquery_activity` vs `insert_into_postgres_activity`) and apply the exact same before\u2192after substitution pattern to the same type of syntactic construct (stage table name generation). This represents a bulk-edit/pattern synchronization scenario where both edits are part of a single, contiguous refactor to add timestamp suffixes to stage table names across different database export functions. Either edit could be made first, and after making either one, the other becomes the immediate next step to complete the uniform pattern application."
        },
        {
            "sample_idx": 662,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits modify different aspects of the same __init__ method in the QaEngineer class, but they do not reference the same symbol or create a direct code dependency. Edit 0 adds a new parameter 'test_round_allowed=5' to the method signature, while Edit 1 adds a comment to an existing line that calls self._init_actions([WriteTest]). The changed lines in each edit reference completely different elements: Edit 0 modifies the parameter list, while Edit 1 modifies a method call and adds a comment. There is no explicit code linkage between the new parameter and the commented line - they are separate, independent changes to the same method. The new parameter is not referenced in the commented line, and the commented line does not use or depend on the new parameter. This is a case of two edits affecting the same method but without direct symbol reference or structural dependency between the changed lines themselves."
        },
        {
            "sample_idx": 663,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits affect completely different parts of the codebase and reference different symbols. Edit 0 reformats the '--enable-irq' argument definition in the argument parser within glances/main.py, while Edit 1 adds a separator line call in the display method of glances/outputs/glances_curses.py. There is no shared symbol, function, class, or variable between the changed lines. The edits are in different files, different classes, and serve different purposes - one is a code formatting change for argument parsing, the other adds display functionality. There is no explicit code dependency, import relationship, or structural synchronization between these changes."
        },
        {
            "sample_idx": 665,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours because they reference different symbols despite both involving '__version__'. Edit 0 imports '__version__' in the modeling_flax_utils.py file, while Edit 1 uses '__version__' in the modeling_utils.py file. However, the '__version__' symbol in Edit 1's changed lines refers to a symbol that must already be imported or available in that file's scope - there's no indication that Edit 1 depends on the import added in Edit 0. These are different files with separate import contexts, and the '__version__' usage in Edit 1 could refer to an existing import in that file. Without evidence that both edits reference the exact same symbol or that Edit 1's usage depends on Edit 0's import, this appears to be a case of same-named symbols in different scopes rather than a direct code dependency."
        },
        {
            "sample_idx": 664,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 creates a variable `seen = set()` and Edit 1 uses that exact same variable `seen` in two places: checking `if name in seen:` and calling `seen.add(name)`. The changed lines in Edit 1 explicitly reference the same symbol `seen` that is defined in Edit 0's changed line. This creates an immediate, mechanically obvious code dependency - after adding the `seen` variable definition, the natural next step is to use it for duplicate detection logic. Both edits are within the same function and form a single micro-task of adding duplicate field name detection. Either edit could be staged first (the usage would cause a runtime NameError but not a parse error in Python), making this bi-directional."
        },
        {
            "sample_idx": 667,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a comment about localhost in the constants.py file, while Edit 1 removes import statements for s3_listener and lambda_api from template_deployer.py. The changed lines reference entirely different symbols and code elements - one is adding a comment about LOCALHOST constant, the other is removing imports for S3 and Lambda services. There is no shared symbol, no code dependency, and no mechanical prompt from one edit to the other. They appear to be separate maintenance tasks with no direct code linkage."
        },
        {
            "sample_idx": 666,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes the function signature of `get_free_trial_days()` by adding a new parameter `is_self_hosted_billing: bool = False`. Edit 1 updates a call site of the exact same function `get_free_trial_days()` to pass the new parameter value `False`. These edits reference the exact same symbol and have an explicit code dependency - after changing the function signature in edit 0, the call site in edit 1 becomes the immediate next step to update the caller to work with the new signature. Both edits can be staged in either order since the new parameter has a default value, making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 668,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 adds a 'query_id' attribute to the TrinoHook class in the main implementation file. Edit 1 modifies a SQL string in a test file by adding 'IF NOT EXISTS' to a CREATE TABLE statement. The changed lines do not reference the same symbol - one is adding a class attribute while the other is modifying SQL syntax. There is no explicit code dependency, import relationship, or structural synchronization between these changes. They appear to be independent modifications that happen to both relate to Trino functionality conceptually, but lack the direct symbol reference or mechanical code linkage required for a neighbor relationship."
        },
        {
            "sample_idx": 669,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and code contexts. Edit 0 modifies the formatting of a command-line argument parser for the '--enable-irq' option in the main.py file, while Edit 1 adds method calls (init_column() and separator_line()) to a display function in the curses output module. There is no explicit code linkage between the changed lines - they don't reference, assign, call, or import the same symbol. The edits affect different files, different classes, different methods, and involve completely different functionality (argument parsing vs display formatting). This is purely a conceptual coincidence that both edits might be part of the same development session, but there is no direct, mechanical code dependency between the specific lines being changed."
        },
        {
            "sample_idx": 670,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same dictionary key 'is_legacy_optimizer' but operate on different symbols in different contexts. Edit 1 adds the key to a config dictionary in the get_config method of optimizer_v1.py, while Edit 0 removes that key from a config dictionary in the from_config method of optimizer_experimental/optimizer.py. Although they reference the same string literal, they are operating on different config dictionary instances in different classes and files. The changed lines don't reference the exact same symbol - they reference different local 'config' variables in separate scopes. This appears to be a coordinated feature implementation where legacy optimizers are marked and that marking is cleaned up during deserialization, but there's no direct code dependency between the specific changed lines themselves."
        },
        {
            "sample_idx": 671,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are not neighbours because they reference different aspects of the Embedding layer without direct code linkage. Edit 0 adds documentation for a 'weights' parameter in the Embedding class docstring, while Edit 1 removes a test method 'test_enable_lora_on_unbuilt_layer' that tests LoRA functionality. The changed lines do not reference the same symbol - one is adding parameter documentation and the other is removing a test method. There is no explicit code dependency where making one edit creates an immediate, mechanically obvious prompt for the other. The connection is only thematic (both relate to the Embedding layer) rather than involving the exact same symbol being referenced, assigned, called, or imported in both changed lines."
        },
        {
            "sample_idx": 672,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol within the same function scope. Edit 0 changes the parameter name from 'endpoint' to 'email_type' in the function signature, and Edit 1 updates the usage of that same parameter within the function body from 'endpoint' to 'email_type'. This is a classic parameter rename scenario where the changed lines in both edits reference the exact same symbol (the parameter of the one_click_unsubscribe_link function). After making either edit, the other becomes the immediate, mechanically obvious next step to maintain code consistency and avoid undefined variable references. Both edits can be staged in either order since Python allows parameter names and their usage to be inconsistent at parse time (only causing issues at runtime)."
        },
        {
            "sample_idx": 674,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 initializes the instance attribute `self.skip_models` in the `__init__` method, while Edit 1 defines a new method `filter_relations` that references this exact same attribute `self.skip_models` in two places (lines 63 and 67). The changed lines in Edit 1 directly reference the attribute that was just defined in Edit 0. This creates an immediate code dependency where the attribute must be initialized before it can be used. However, since both edits can be written and parsed in either order (Python allows referencing undefined attributes at parse time, only failing at runtime), and making either edit creates an immediate prompt for the other as the next logical step in implementing the skip_models functionality, this is a bi-directional relationship."
        },
        {
            "sample_idx": 673,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are in different files and contexts with no direct code linkage. Edit 0 adds a comment explaining how row indexing works in the backtesting logic, while Edit 1 adds a test assertion checking dataframe lengths. The edits don't reference the same symbols, variables, functions, or have any explicit code dependency. Edit 0 modifies the backtest method implementation with documentation, while Edit 1 adds an assertion in a test function. There is no immediate, mechanically obvious prompt from one edit to the other - they are conceptually related to backtesting but lack the required direct symbol linkage or structural dependency."
        },
        {
            "sample_idx": 675,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a new method `filter_relations` to the `BaseDeletionTask` class that uses `self.skip_models` to filter child relations. Edit 1 adds a `skip_models` parameter to a deletion operation call. While both edits involve the concept of 'skip_models', they reference different symbols in different contexts. Edit 0 defines a method that uses `self.skip_models` as an instance attribute, while Edit 1 passes `skip_models` as a parameter to a function call. These are different symbols (instance attribute vs parameter) in different scopes (class method vs function call), and there is no direct code dependency between the changed lines themselves. The connection is conceptual/thematic rather than an explicit code linkage."
        },
        {
            "sample_idx": 676,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "Both edits add the exact same line 'connection.connect()' in similar contexts within different functions across different files. While this appears to be part of a uniform pattern or refactoring effort to add connection establishment calls, the edits reference different 'connection' objects in different scopes/contexts. The changed lines do not reference the exact same symbol - they reference different connection objects that happen to have the same name but exist in different function scopes and files. According to the criteria, symbols with identical names in different scopes are different symbols, and without explicit cross-reference between the exact same symbol in both changed lines, this should be labeled as no relation despite the identical textual change."
        },
        {
            "sample_idx": 677,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports GATEWAY_NAME from jina.helper, and Edit 1 uses GATEWAY_NAME to replace the hardcoded string 'gateway'. The changed lines reference the exact same symbol (GATEWAY_NAME) - Edit 0 makes it available via import, and Edit 1 uses that imported symbol. This creates an immediate code dependency where the import enables the usage. In Python, the usage can be written before the import (it would only fail at runtime with a NameError), so both edits can be staged in either order, making this bi-directional."
        },
        {
            "sample_idx": 678,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code linkage. Edit 0 modifies a call to `optimizers.deserialize()` by adding a `use_legacy_optimizer=False` parameter in the LossScaleOptimizerV3 class. Edit 1 adds a test assertion checking that `config[\"is_legacy_optimizer\"]` equals `True` in an SGD optimizer test. While both edits involve legacy optimizer concepts, they reference completely different symbols: Edit 0 calls `optimizers.deserialize()` with a parameter, while Edit 1 accesses a config dictionary key. The changed lines do not reference the exact same symbol, function, or variable. This is a conceptual/thematic relationship without explicit code dependency between the specific symbols being modified."
        },
        {
            "sample_idx": 679,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add calls to `self.separator_line()` in different locations within the same `display` method of the `_GlancesCurses` class. While both edits involve the same method name `separator_line()`, they are adding calls to this method in different locations within the same function for what appears to be UI formatting purposes. The edits don't reference the exact same symbol in a definition-usage relationship, nor do they represent a synchronized pattern substitution of the same construct type. Edit 0 adds a separator line after the header display, while Edit 1 adds a separator line (along with `init_column()`) after the top display. These are independent UI formatting additions that happen to use the same method but serve different structural purposes in the display flow. There is no direct code dependency between the changed lines - neither edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 680,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new method `separator_line` in the `_GlancesCurses` class, and Edit 1 calls that exact same method `separator_line()` on `self`. The changed lines reference the exact same symbol - the `separator_line` method. After defining the method in Edit 0, calling it in Edit 1 becomes a natural next step, and conversely, if the call site exists, defining the method becomes immediately necessary. Both edits can be written and parsed in either order (Python allows calling undefined methods at parse time, only failing at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 681,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and contexts. Edit 0 adds a `skip_models` parameter to the `BaseDeletionTask.__init__` method constructor, while Edit 1 adds a `skip_models` argument to a `deletions.get()` function call in a different file. Although both use the name 'skip_models', they are referencing different symbols - one is a parameter in a constructor, the other is an argument to a separate function call. There is no direct code dependency between these changed lines, and no evidence that the exact same symbol is being referenced in both edits. The relationship appears to be conceptual (both related to skipping models in deletion operations) rather than an explicit code linkage."
        },
        {
            "sample_idx": 682,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural substitution pattern: they replace direct calls to `get_vcs_rev_define()` with a pattern that first checks for a cached VCS revision value and only calls `get_vcs_rev()` if needed. Edit 0 uses `env.vcs_rev` while edit 1 uses `args.vcs_rev`, but both follow the same before\u2192after transformation pattern (direct function call \u2192 cached value check + fallback). This represents a uniform refactoring sweep applying the same optimization pattern to multiple locations that use VCS revision information. Both edits target the same type of syntactic construct (VCS revision retrieval) with identical substitution logic, making them part of a single, contiguous refactoring task where either could be applied first as part of the same optimization sweep."
        },
        {
            "sample_idx": 683,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits add identical code (checking for 'is_legacy_optimizer' in config and deleting it if present) to the from_config method of different optimizer classes. Edit 0 modifies the Adagrad class which inherits from OptimizerV2 (modified in Edit 1). This represents a bulk edit pattern where the same structural change is being applied to multiple related classes in the same codebase. Both edits perform an identical textual substitution (adding the same if-block and del statement) and target the same type of syntactic construct (from_config class methods in optimizer classes). This appears to be part of a single, contiguous refactor to handle legacy optimizer configuration across the optimizer hierarchy."
        },
        {
            "sample_idx": 684,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits occur in the same method (on_ready) within the same conditional block (if self.done_msg), but they reference completely different symbols and serve different purposes. Edit 0 imports 'ExcInfo' from celery.worker, while Edit 1 adds email functionality using 'SEND_CELERY_TASK_ERROR_EMAILS' and 'mail_admins'. The changed lines do not reference the exact same symbol - Edit 0 references 'ExcInfo' and Edit 1 references 'SEND_CELERY_TASK_ERROR_EMAILS' and 'mail_admins'. There is no direct code dependency between importing ExcInfo and adding email functionality. While both edits are part of error handling in the same method, they are conceptually related rather than having explicit code linkage where one edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 685,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 adds a command-line argument '--separator' with destination 'enable_separator' in the argument parser. Edit 1 adds a 'separator' parameter to the new_line() method signature in a different class and file. While both involve the concept of 'separator', they are different symbols in different scopes - one is a command-line argument configuration and the other is a method parameter. The changed lines do not reference the exact same symbol, and there is no explicit code linkage between the argument parser configuration and the method parameter addition."
        },
        {
            "sample_idx": 686,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 removes code that calls `aget_schema_by_id` and checks `schema_model.should_sync` within a function in the temporal data imports module. Edit 1 adds imports for workflow-related functions (`external_data_workflow_exists`, `sync_external_data_job_workflow`, etc.) in a different API module. The changed lines do not reference, assign, call, or import the exact same symbol. While both edits relate to external data schemas conceptually, there is no explicit, immediate code dependency or synchronized substitution between the specific symbols being modified in each edit."
        },
        {
            "sample_idx": 687,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are both within the same function `_newnames` but they modify different parts of the function without any direct code dependency between them. Edit 0 adds a docstring at the beginning of the function, while Edit 1 adds a variable assignment (`seen = set()`) in the middle of the function logic. The changed lines do not reference the same symbol - one adds documentation while the other introduces a new variable. There is no explicit code linkage where one edit creates an immediate, mechanically obvious prompt for the other. Both edits can be made independently in either order without creating syntax errors or requiring the other edit to be present first. This appears to be two separate improvements to the same function rather than a single micro-task with dependent changes."
        },
        {
            "sample_idx": 688,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 modifies the __repr__ method to include skip_models in the string representation, while Edit 1 adds a call to filter_relations() in the delete_bulk method. Although both edits relate to the same class (BaseDeletionTask) and may be part of adding skip_models functionality, the changed lines themselves do not reference the exact same symbol. Edit 0 references self.skip_models in a string formatting context, while Edit 1 calls self.filter_relations() method. There is no direct code dependency between these specific changed lines - neither edit creates an immediate, mechanically obvious prompt for the other. The connection is conceptual (both related to filtering/skipping functionality) rather than an explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 689,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they implement a synchronized feature where the exact same configuration key 'is_legacy_optimizer' is being added to the optimizer's config in edit 1 and then consumed/checked in the deserialize function in edit 0. Edit 1 adds the 'is_legacy_optimizer' key to the config dictionary, while edit 0 adds logic to check for and use this exact same key. Both edits reference the same configuration key string literal 'is_legacy_optimizer' and work together to implement a complete feature - the ability to preserve and use the legacy optimizer flag during serialization/deserialization. Either edit could be implemented first without causing parse errors, but after implementing either one, the other becomes the immediate next step to complete the functionality."
        },
        {
            "sample_idx": 691,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 changes a string literal 'us-east-1' to use a constant AWS_REGION_US_EAST_1 in config.py, while Edit 1 adds a comment about localhost in constants.py. The changed lines don't reference, assign, call, or import the same symbol. There is no explicit code dependency, mirrored substitution pattern, or structural relationship between these edits. They appear to be separate, unrelated changes that happen to be in the same codebase."
        },
        {
            "sample_idx": 690,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the same string key 'is_legacy_optimizer' but reference it in completely different contexts and files. Edit 0 adds this key to a test configuration dictionary in a test file, while Edit 1 removes this key from a config dictionary in the actual optimizer implementation. While both edits handle the same configuration key name, they are operating on different config dictionaries in different scopes - one is test data and the other is production deserialization logic. There is no direct code dependency between these specific changed lines, and neither edit creates an immediate, mechanically obvious prompt for the other. The relationship is conceptual (both handle the same config key) rather than a direct symbol reference or structural dependency."
        },
        {
            "sample_idx": 692,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits modify different parts of the same Embedding class but do not reference the same symbol or create a direct code dependency. Edit 0 adds a 'weights' parameter to the __init__ method signature, while Edit 1 adds an early return condition in the build method using 'self.built'. The changed lines reference completely different symbols - 'weights' parameter vs 'self.built' attribute. There is no explicit code linkage where one edit creates an immediate, mechanically obvious prompt for the other. While both edits are part of the same class, they represent independent modifications without direct symbol reference between the changed lines."
        },
        {
            "sample_idx": 693,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours because they reference different symbols despite similar naming patterns. Edit 0 changes the usage of a parameter from 'external_data_source.id' to 'id' within the pause_external_data_schedule function, while Edit 1 changes the parameter signature of a completely different function (unpause_external_data_schedule) from 'external_data_source: ExternalDataSource' to 'id: str'. The changed lines do not reference the exact same symbol - Edit 0 is within the pause function and Edit 1 is within the unpause function. While both edits appear to be part of the same refactoring pattern (changing from ExternalDataSource parameter to string id parameter), they affect different functions and different symbols, so there is no direct code dependency or explicit linkage between the exact same symbol in both changed lines."
        },
        {
            "sample_idx": 694,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and contexts. Edit 0 modifies the `from_config` method in `optimizer_v1.py` to remove the 'is_legacy_optimizer' key from the config dictionary. Edit 1 adds a test assertion in `optimizer_v2_test.py` that checks if the 'is_legacy_optimizer' key equals True in a config. While both edits involve the same string literal 'is_legacy_optimizer', they are operating on different symbols in different contexts - one is modifying the v1 optimizer's config handling, the other is testing v2 optimizer behavior. The changed lines don't reference the exact same symbol or create a direct code dependency between them. This appears to be part of a broader feature implementation but lacks the explicit, immediate code linkage required for neighbor classification."
        },
        {
            "sample_idx": 695,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the CFGDenoiser class. Edit 0 adds two new instance attributes (cond_scale_miltiplier and need_last_noise_uncond) in the __init__ method. Edit 1 removes code related to CFG++ processing in the forward method, specifically removing an elif branch that handles is_cfg_pp condition and uses cond_scale/12.5. While both edits are in the same class, the changed lines do not reference the exact same symbols - edit 0 introduces new attributes while edit 1 removes conditional logic with different variables (cond_scale parameter usage vs new instance attributes). There is no direct code dependency or structural linkage between the specific lines being changed."
        },
        {
            "sample_idx": 698,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits add identical code (`if \"is_legacy_optimizer\" in config: del config[\"is_legacy_optimizer\"]`) to the `from_config` method in two different optimizer classes. This represents a bulk/pattern synchronization where the same structural change (removing the same config key) is being applied to the same type of syntactic construct (both are `from_config` methods in optimizer classes). The edits perform an identical code addition pattern and target the same type of method signature, making this a synchronized multi-file substitution that would naturally occur as part of a single, contiguous refactor operation."
        },
        {
            "sample_idx": 696,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats the '--enable-irq' argument definition in the argument parser by splitting it across multiple lines for better readability. Edit 1 modifies the display logic for cloud statistics in the curses output module by adding a conditional check before displaying the cloud plugin. The changed lines reference entirely different symbols and functionality - one deals with command-line argument formatting while the other deals with display rendering logic. There is no direct code dependency, shared symbol reference, or structural synchronization between these edits. They appear to be independent code improvements in different parts of the codebase."
        },
        {
            "sample_idx": 697,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an 'acl' parameter to the __init__ method signature of GCSFeedStorage class. Edit 1 updates the from_crawler method to pass the new 'acl' parameter when calling the constructor (cls()). These edits reference the exact same constructor - the changed lines in both edits involve the same __init__ method of the same class. After adding the parameter to __init__, the from_crawler method call becomes syntactically incorrect and needs to be updated to match the new signature. Conversely, if the call site is updated first to pass 3 arguments, the __init__ method needs to accept that third parameter. Both edits can be written and parsed in either order (Python allows mismatched argument counts at parse time, only failing at runtime), making this a bi-directional relationship where either edit naturally prompts the other as the immediate next step."
        },
        {
            "sample_idx": 699,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits reference the exact same symbol - the `new_line` method of the `_GlancesCurses` class. Edit 0 changes the method signature by adding a `separator=False` parameter, while Edit 1 modifies a call site that uses this method. However, both edits can be staged in either order without causing parser errors. The call site in Edit 1 doesn't pass any arguments to `new_line()`, so it will work with both the old signature (no parameters) and the new signature (with default parameter). Since both edits reference the same symbol and either can be applied first while maintaining syntactic validity, this is a bi-directional relationship."
        },
        {
            "sample_idx": 700,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different types of operations. Edit 0 removes an import of 'aget_schema_by_id' from one file, while Edit 1 adds imports of completely different functions ('external_data_workflow_exists', 'sync_external_data_job_workflow', 'pause_external_data_schedule', 'unpause_external_data_schedule') to a different file. The changed lines reference entirely different symbols - there is no overlap between 'aget_schema_by_id' and the four functions being imported in Edit 1. There is no direct code dependency, no mirrored substitution pattern, and no explicit linkage between the exact same symbols in both edits. The connection, if any, would be purely conceptual or thematic (both involving external data functionality), which according to the criteria should be labeled as 'no relation'."
        },
        {
            "sample_idx": 701,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are both updating test assertions related to cached data length calculations in backtesting tests, but they are in completely different test functions (test_backtest_alternate_buy_sell vs test_backtest_multi_pair) and reference different symbols and variables. Edit 0 changes the expected length from 200 to 199 and works with 'UNITTEST/BTC' pair data, while Edit 1 introduces an offset variable calculation and works with a parameterized pair variable. The changed lines don't reference the same symbols - they use different dataframes, different pairs, different calculation logic, and different expected values. While both are conceptually related to backtesting data length validation, there is no direct code dependency or explicit symbol linkage between the changed lines themselves."
        },
        {
            "sample_idx": 702,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 changes the method signature of `folder_get` by adding an `update=True` parameter, while Edit 0 calls this exact same method with the new parameter `update=False`. The changed lines reference the exact same symbol - the `folder_get` method of `self.engine_storage`. After making the signature change in Edit 1, the call in Edit 0 becomes the immediate next step to utilize the new parameter. Conversely, after adding the parameter usage in Edit 0, updating the method signature in Edit 1 becomes the mechanically required next step to make the code work. Both edits can be written and parsed in either order (the call with the extra parameter would just cause a runtime TypeError if the signature hasn't been updated yet, but no parse-time syntax error), making this a bi-directional relationship."
        },
        {
            "sample_idx": 703,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a command-line argument '--separator' with destination 'enable_separator' to the argument parser. Edit 1 adds a method 'separator_line' that checks 'self.args.enable_separator' to conditionally display a separator line in the UI. The changed lines reference the exact same symbol: the 'enable_separator' attribute that is defined in edit 0 and used in edit 1. This creates an immediate code dependency where adding the argument parser option naturally prompts the implementation of the feature that uses that option, and vice versa - implementing a feature that checks for an argument naturally prompts adding that argument to the parser. Both edits can be staged in either order without parse errors, making this a bi-directional relationship."
        },
        {
            "sample_idx": 704,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the 'operator' module, and Edit 1 uses that exact same 'operator' module by calling operator.methodcaller() three times in the added lines. This creates a direct import-usage relationship where both edits reference the exact same symbol (the operator module). After making either edit, the other becomes the next mechanically obvious step - if you import operator, you need to use it, and if you try to use operator.methodcaller(), you need the import. Since this is Python, referencing an undefined module would only cause a runtime NameError, not a parse-time syntax error, so both edits can be written and parsed in either order."
        },
        {
            "sample_idx": 705,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol 'dtype' within the same function. Edit 0 adds the 'dtype' parameter to the function signature, and Edit 1 uses that same parameter by passing it to the load_unet_state_dict call. This creates an immediate, mechanically obvious code-driven prompt - after adding the parameter to the signature, the natural next step is to use it in the function body. Both edits can be staged in either order without causing parser errors (the parameter can be added without being used, and it can be referenced in the call before being added to the signature), making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action."
        },
        {
            "sample_idx": 706,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add new methods to the same TTYIO class, but they are independent additions that don't reference each other. Edit 0 adds an __init__ method with a read_with_timeout parameter, while Edit 1 adds a wait_till_read_available method that uses select to check for available reads. There is no explicit code linkage between these methods - the changed lines don't reference the same symbols, and neither edit creates a direct, mechanically obvious prompt for the other. The wait_till_read_available method doesn't use the read_with_timeout attribute from the __init__ method, and there's no direct dependency or synchronized pattern between them. They are conceptually related (both deal with reading/timeouts) but lack the explicit code dependency required for neighbour classification."
        },
        {
            "sample_idx": 707,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different aspects of optimizer serialization/deserialization but do not reference the exact same symbol or create direct code dependencies. Edit 0 adds a 'use_legacy_optimizer=False' parameter to a deserialize call in the loss scale optimizer, while Edit 1 modifies documentation to show 'is_legacy_optimizer': True in serialized output. Although both relate to legacy optimizer handling, the changed lines reference different symbols ('use_legacy_optimizer' vs 'is_legacy_optimizer') and serve different purposes (deserialization parameter vs serialized output field). There is no direct code linkage where making one edit creates an immediate, mechanically obvious prompt for the other - they are conceptually related but operationally independent changes."
        },
        {
            "sample_idx": 709,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports the 'connection' symbol from django.db, and Edit 1 uses that exact same 'connection' symbol by calling connection.connect(). This is a classic import-usage pattern where the changed lines reference the exact same symbol. After adding the import in Edit 0, using connection.connect() in Edit 1 becomes the immediate, mechanically obvious next step. Both edits can be staged in either order since Python allows referencing undefined symbols at parse time (only failing at runtime), making this bi-directional rather than ordered."
        },
        {
            "sample_idx": 708,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different types of changes. Edit 0 adds a new method `separator_line` to the `_GlancesCurses` class, which includes a call to `unicode_message('MEDIUM_LINE', self.args)`. Edit 1 removes a blank line before the definition of the `unicode_message` function in a different file. While edit 0's new method does call the `unicode_message` function that edit 1 affects, the changes themselves don't create a direct code dependency - edit 0 is calling an existing function, and edit 1 is just formatting cleanup (removing whitespace) around that function's definition. The changed lines don't reference the exact same symbol in a way that creates an immediate, mechanical prompt for one edit after the other. Edit 0 can be made without any dependency on edit 1's whitespace change, and edit 1 is purely cosmetic formatting that doesn't affect the functionality that edit 0 relies on."
        },
        {
            "sample_idx": 710,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and contexts. Edit 0 adds an 'acl' parameter to the GCSFeedStorage.__init__ method signature in the production code. Edit 1 modifies a test assertion to include a 'predefined_acl=acl' parameter in a blob_mock.upload_from_file call. While both involve ACL functionality, they are not referencing the same symbol - one is adding a parameter to a constructor, the other is modifying a mock assertion call. The 'acl' in the constructor parameter and the 'acl' in the test assertion are different symbols in different scopes. There is no direct code dependency where making one edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 711,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code linkage. Edit 0 adds a 'skip_models' parameter to the __init__ method signature, while Edit 1 adds a call to 'self.filter_relations()' in the delete_bulk method. The changed lines do not reference the same symbol - one is adding a parameter and the other is adding a method call. There is no explicit code dependency between the __init__ parameter addition and the filter_relations method call in the changed lines themselves. While they may be conceptually related (the skip_models parameter might be used by filter_relations), the actual changed lines reference completely different symbols and neither edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 712,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different symbols and code constructs. Edit 0 reformats the arguments of a parser.add_argument() call for the '--enable-irq' command line option in the main.py file. Edit 1 adds a 'separator' parameter to the new_line() method in the curses output module. There is no shared symbol, function, variable, or code dependency between these changes. The changed lines reference entirely different symbols (parser.add_argument vs new_line method signature) in different files and different contexts. This is purely a formatting change in one case and a method signature change in another, with no explicit code linkage between them."
        },
        {
            "sample_idx": 714,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 assigns a value to the instance attribute `self.acl` in the constructor, and Edit 1 references that exact same attribute `self.acl` in the `_store_in_thread` method. The changed lines reference the exact same symbol (the instance attribute `acl`). After making either edit, the other becomes the next immediate, code-driven step - if you add the attribute assignment without using it, or if you try to use an attribute that hasn't been assigned, there's a direct dependency. This is a classic definition-usage pattern within the same class where both edits reference the exact same symbol."
        },
        {
            "sample_idx": 715,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 reformats the arguments for '--enable-plugin' option in the argument parser, while Edit 1 adds a new method 'separator_line' that references 'self.args.enable_separator'. Although both edits involve argument-related functionality, they reference different symbols ('enable_plugin' vs 'enable_separator') and are in different files with different purposes. The changed lines do not reference, assign, call, or import the exact same symbol. There is no explicit code dependency or synchronized substitution pattern between these edits."
        },
        {
            "sample_idx": 713,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 reformats the arguments of a `parser.add_argument()` call in the main.py file, breaking a single line into multiple lines for better readability. Edit 1 adds two method calls (`self.init_column()` and `self.separator_line()`) to a display method in a different file (glances_curses.py). There is no shared symbol, function, variable, or any direct code dependency between these edits. The changed lines reference completely different symbols and serve different purposes - one is about argument parsing formatting, the other is about display functionality. There is no explicit code linkage that would make one edit prompt the other as the next mechanical step."
        },
        {
            "sample_idx": 717,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern: changing 'self._test_error_exc_info()' to '_test_error_exc_info()' in method calls. This is a uniform refactoring operation that removes 'self.' from the same method name across multiple locations within the same test class. Both changed lines reference the exact same symbol (_test_error_exc_info) and apply the identical before\u2192after substitution pattern to the same type of syntactic construct (method calls). This represents a single, contiguous refactoring task where either edit naturally prompts the other as part of the same search-and-replace operation."
        },
        {
            "sample_idx": 716,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts with no direct code linkage. Edit 0 adds a variable assignment using `settings.PROJECT_ROOT` in the devserver command, while Edit 1 removes an import of `settings` from django.conf in a different file's HTTP server class. Although both involve 'settings', they reference different symbols: Edit 0 uses `settings.PROJECT_ROOT` (likely from sentry's settings) while Edit 1 removes `from django.conf import settings`. The changed lines don't reference the exact same symbol, and there's no immediate mechanical dependency between adding a cwd calculation and removing a Django settings import."
        },
        {
            "sample_idx": 718,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new function `_test_error_exc_info()` at the module level, while Edit 1 changes a method call from `self._test_error_exc_info()` to `_test_error_exc_info()` within a test method. The changed lines reference the exact same symbol `_test_error_exc_info` - Edit 0 creates the function definition and Edit 1 updates the usage to call this newly defined function instead of the previous method call. This represents a definition-usage relationship where both edits reference the same symbol, making either edit prompt the other as the next mechanical step. In Python, both edits can be written and parsed in either order (the function call would just result in a runtime NameError if the definition isn't present), so this is bi-directional rather than ordered."
        },
        {
            "sample_idx": 719,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern within the same class and method context. Both add the exact same line 'child_relations = self.filter_relations(child_relations)' immediately after a 'child_relations = self.get_child_relations...' assignment and before an 'if child_relations:' check. This represents a uniform, synchronized code change where the same filtering logic is being applied to child_relations in two different code paths within the same method. The edits target the same type of syntactic construct (variable assignment) with identical before\u2192after patterns, making this a clear case of bulk-edit synchronization that would naturally occur in a single, contiguous refactoring session."
        },
        {
            "sample_idx": 720,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they both reference the exact same configuration key 'is_legacy_optimizer'. Edit 0 adds this key to the serialized output in the docstring example, while Edit 1 handles the removal of this same key during deserialization. Both edits are part of implementing a synchronized configuration mechanism where the serialization process includes 'is_legacy_optimizer' and the deserialization process removes it. Either edit could be implemented first - adding the key to serialization or handling its removal during deserialization - and after making either edit, the other becomes the immediate next step to complete the synchronized configuration handling. The changed lines in both edits explicitly reference the same configuration key symbol."
        },
        {
            "sample_idx": 721,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve changes to function signatures and call sites, but they are for different functions. Edit 0 changes a call to `pause_external_data_schedule()` by modifying the argument from `job.pipeline` to `str(job.pipeline.id)`. Edit 1 changes the signature of a different function `unpause_external_data_schedule()` by changing the parameter from `external_data_source: ExternalDataSource` to `id: str`. While both edits appear to be part of a similar refactoring pattern (changing from object parameters to string ID parameters), they reference different symbols - `pause_external_data_schedule` vs `unpause_external_data_schedule`. The changed lines do not reference the exact same symbol, so there is no direct code dependency between them."
        },
        {
            "sample_idx": 722,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural and textual transformation on the same type of syntactic construct. They both: (1) add the exact same line `data_interval_end_str = dt.datetime.fromisoformat(inputs.data_interval_end).strftime(\"%Y-%m-%d_%H-%M-%S\")`, (2) transform the `stagle_table_name` assignment from a simple f-string to a multi-line conditional expression with the same pattern, and (3) incorporate `data_interval_end_str` into the stage table name in an identical way. This represents a uniform, synchronized refactoring pattern applied to the same type of code construct (stage table name generation logic) across two similar batch export functions. The identical before\u2192after pattern and construct type makes this a clear case of bulk-edit synchronization that would naturally occur in a single, contiguous refactoring session."
        },
        {
            "sample_idx": 723,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits modify the `stagle_table_name` assignment in different files (postgres_batch_export.py and snowflake_batch_export.py), but they are making different types of changes to different symbols in different contexts. Edit 0 enhances the staging table name by adding a timestamp suffix using `data_interval_end_str`, while Edit 1 appears to be removing or modifying the same line but in a completely different function and file. Although both edits involve variables with the same name (`stagle_table_name`), they are different symbols in different scopes (different functions in different files). There is no direct code dependency between these changes - neither edit references the exact same symbol as the other. The relationship is purely conceptual/thematic (both relate to staging table naming) rather than involving explicit code linkage between the same symbols."
        },
        {
            "sample_idx": 726,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours because they reference different symbols and lack direct code linkage. Edit 0 modifies the load_unet_state_dict function to handle a 'dtype' parameter by adding conditional logic, while Edit 1 adds a 'weight_dtype' parameter to the INPUT_TYPES method of the UNETLoader class. Although both edits relate to dtype handling conceptually, the changed lines reference different symbols ('dtype' vs 'weight_dtype') in different functions and contexts. There is no explicit code dependency where one edit creates an immediate, mechanically obvious prompt for the other - they are separate modifications that happen to share a thematic relationship around data type handling."
        },
        {
            "sample_idx": 724,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts. Edit 0 modifies the `from_crawler` method in the production code `GCSFeedStorage` class to add a third parameter `crawler.settings['FEED_STORAGE_GCS_ACL']` to the `cls()` constructor call. Edit 1 modifies a test settings dictionary in `GCSFeedStorageTest` to add the key-value pair `'FEED_STORAGE_GCS_ACL': 'publicRead'`. While both edits reference the same setting name 'FEED_STORAGE_GCS_ACL', the changed lines reference different symbols: one references `crawler.settings['FEED_STORAGE_GCS_ACL']` (a settings lookup) and the other references a dictionary literal key `'FEED_STORAGE_GCS_ACL'` in a test setup. These are different symbols in different contexts, and there's no direct code dependency between the changed lines themselves - the test would still parse and run regardless of the order of these edits."
        },
        {
            "sample_idx": 725,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds an early return check `if self.built: return` to the Embedding layer's build method, which changes the behavior when the layer is already built. Edit 1 removes a test that was specifically checking for an error when enabling LoRA on an unbuilt layer. While both edits relate to the Embedding layer and the concept of 'built' state, they reference different aspects of the layer's behavior and don't have a direct code dependency. The changed lines don't reference the exact same symbol - edit 0 modifies the build method's logic while edit 1 removes a test method entirely. The test removal appears to be cleanup after a behavior change, but there's no explicit code linkage between the specific lines being changed."
        },
        {
            "sample_idx": 727,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits perform identical structural formatting changes - they take function calls that have multiple arguments on a single line and split them into multiple lines with one argument per line. However, they operate on completely different symbols in different files and contexts: Edit 0 modifies a parser.add_argument() call in glances/main.py, while Edit 1 modifies a self.display_plugin() call in glances/outputs/glances_curses.py. While both follow the same formatting pattern (single line to multi-line argument formatting), there is no direct code dependency, symbol reference, or explicit linkage between the changed lines. The relationship is purely stylistic/formatting-based rather than involving the exact same symbol or creating a code-driven prompt for the other edit."
        },
        {
            "sample_idx": 729,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directionally related because they both reference the exact same configuration key 'is_legacy_optimizer'. Edit 1 adds this key to the configuration with value False in the get_config method, while Edit 0 reads and uses this same key from the config in the deserialize function. The changed lines in both edits explicitly reference the same symbol/key ('is_legacy_optimizer'), creating a direct code dependency where the configuration produced by one edit is consumed by the other. This represents a producer-consumer relationship for the same configuration parameter, making either edit naturally prompt the other as the next mechanical step in implementing this feature."
        },
        {
            "sample_idx": 728,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a new configuration setting `SEND_CELERY_TASK_ERROR_EMAILS` to the conf.py file, while Edit 1 adds import statements for `sys` and `traceback` modules to the worker.py file. The changed lines in each edit do not reference the same symbols - Edit 0 introduces a new configuration variable and references `settings`, while Edit 1 only adds import statements for standard library modules. There is no direct code dependency, no shared symbol references, and no structural relationship between these changes. They appear to be part of different development tasks with no immediate, mechanically obvious connection between them."
        },
        {
            "sample_idx": 730,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols despite appearing related. Edit 0 modifies the get_config() method in the Optimizer class in optimizer_v1.py, adding an 'is_legacy_optimizer' key to the config dictionary. Edit 1 adds a test assertion in optimizer_v2_test.py that checks for the same key name. However, the test is in the optimizer_v2 test file and is testing an SGD optimizer instance, not the v1 Optimizer class that was modified in edit 0. The changed lines reference different symbols - one modifies the v1 Optimizer.get_config() method, while the other tests a different optimizer's config (likely v2 SGD). Even though they both involve the same key name 'is_legacy_optimizer', they are testing different optimizer implementations and thus different symbols."
        },
        {
            "sample_idx": 731,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern: changing 'self._test_error_exc_info()' to '_test_error_exc_info()' in method calls. This is a uniform refactoring operation that removes the 'self.' prefix from calls to the same helper method across multiple locations in the same test class. Both changed lines reference the exact same function symbol (_test_error_exc_info) and represent the same type of syntactic construct (method calls). This appears to be part of a single, contiguous refactor operation where the helper method is being changed from an instance method to a module-level function or static method. Either edit could be made first as both are mechanically identical substitutions that would naturally be performed together in one sweep."
        },
        {
            "sample_idx": 732,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different symbols in different files with no code dependency between them. Edit 0 removes a `recv` method from the `QaEngineer` class in `metagpt/roles/qa_engineer.py`, while Edit 1 adds a `run_tests` parameter to the `startup` function in `startup.py`. The changed lines do not reference, assign, call, or import the same symbol. There is no explicit code linkage, structural dependency, or synchronized pattern between removing a method and adding a parameter to an unrelated function. The only potential connection is conceptual (both relate to testing functionality), but conceptual relationships without direct code dependencies are explicitly labeled as 'no relation' according to the criteria."
        },
        {
            "sample_idx": 733,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits call the same function `pause_external_data_schedule` and both change the argument from an object to `str(object.id)`. Edit 0 changes `pause_external_data_schedule(job.pipeline)` to `pause_external_data_schedule(str(job.pipeline.id))`, while edit 1 includes a call to `pause_external_data_schedule(str(instance.id))`. However, these are calls to the same function in different files and contexts, but they don't reference the exact same symbol or create a direct code dependency between the changed lines themselves. The edits appear to be part of a bulk refactoring to standardize the argument type passed to `pause_external_data_schedule`, but the changed lines don't create an immediate, mechanically obvious prompt for each other. They are conceptually related as part of the same refactoring effort, but there's no explicit code linkage where one edit's changed lines directly reference what the other edit changes."
        },
        {
            "sample_idx": 734,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits both add the 'is_legacy_optimizer' field to optimizer configuration dictionaries, but they reference different symbols and contexts. Edit 0 modifies documentation showing SGD optimizer serialization output with 'is_legacy_optimizer': True, while Edit 1 adds 'is_legacy_optimizer': False to a test configuration dictionary for experimental optimizers. The changed lines don't reference the exact same symbol - they are adding the same field name to different configuration contexts (legacy vs experimental optimizers). This appears to be part of a broader feature implementation to distinguish optimizer types, but the edits lack direct code dependency or synchronized substitution of the exact same symbol."
        },
        {
            "sample_idx": 735,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 changes the signature of the `new_line` method by adding a `separator` parameter. Edit 1 adds calls to `init_column()` and `separator_line()` methods in a different method (`display`). The changed lines in each edit reference entirely different symbols - edit 0 modifies the `new_line` method signature while edit 1 calls `init_column` and `separator_line` methods. There is no explicit code dependency between these changes, no shared symbol references, and no immediate mechanical prompt from one edit to the other. While they may be conceptually related to display functionality, this falls under thematic linkage which does not qualify as a neighbor relationship according to the criteria."
        },
        {
            "sample_idx": 736,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits involve adding the exact same parameter 'run_tests' to the same function 'main'. Edit 0 adds 'run_tests' to the function signature, while Edit 1 adds 'run_tests' to the function call within the same function body. This creates a direct code dependency where the parameter added to the signature in Edit 0 is immediately referenced in the function call in Edit 1. Both edits reference the exact same symbol (the run_tests parameter) and either edit naturally prompts the other as the next mechanical step - adding a parameter to a signature creates an immediate need to pass that parameter in calls, and vice versa. This is a classic definition-usage relationship within the same function scope."
        },
        {
            "sample_idx": 737,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits modify user_agent dictionaries by adding the same key-value pair '\"diffusers\": __version__', but they are in completely different contexts and classes. Edit 0 modifies a user_agent dictionary in FlaxModelMixin.from_pretrained(), while Edit 1 creates a new user_agent dictionary in DiffusionPipeline.from_pretrained(). These are different symbols (different user_agent variables in different scopes) despite having the same name. The edits appear to be part of a bulk refactoring to add version information to user_agent dictionaries across the codebase, but they don't reference the exact same symbol - they are separate variables in different classes and methods. While they follow a similar pattern, there is no direct code dependency or explicit linkage between the changed lines themselves."
        },
        {
            "sample_idx": 738,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an import statement for the 'time' module at the top of the file. Edit 1 uses the 'time' module in multiple places within the resume function - calling time.time() to get timestamps and calculate elapsed time. This is a classic import-usage relationship where the changed lines in both edits reference the exact same symbol 'time'. After adding the import in edit 0, edit 1 becomes the natural next step to use the imported module. Conversely, edit 1 cannot function without the import from edit 0, but both edits can be written and parsed in either order (the usage would just result in a runtime NameError if executed before the import). Since this is Python and the usage would only fail at runtime, not at parse time, this is a bi-directional relationship."
        },
        {
            "sample_idx": 739,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes the signature of the `new_line` method by adding a `separator` parameter. Edit 1 adds a new `separator_line` method that calls `self.new_line()` on line 540. Both edits reference the exact same symbol - the `new_line` method of the same class. After making edit 0 (signature change), the call in edit 1 becomes the immediate next step to utilize the new functionality. After making edit 1 (adding the caller), updating the signature in edit 0 becomes the natural next step to support the new usage pattern. This is a classic definition-usage relationship where both edits can be staged in either order (the call without parameters will still work with the new signature due to the default parameter), making it bi-directional."
        },
        {
            "sample_idx": 740,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file but modify completely different parts of the code with no direct relationship. Edit 0 modifies the `_add_browser_connection` method to add logic for handling preheated report contexts, while Edit 1 is a simple formatting change that adds line breaks to a `self.write()` call in the `_DebugHandler.get()` method. The changed lines reference entirely different symbols and code constructs - one deals with report context management and the other with HTML output formatting. There is no explicit code linkage, shared symbols, or structural dependency between these edits. They appear to be independent changes that could be made in any order without affecting each other."
        },
        {
            "sample_idx": 741,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts without direct code linkage. Edit 0 adds a 'use_legacy_optimizer=False' parameter to an 'optimizers.deserialize()' call in the LossScaleOptimizerV3 class. Edit 1 adds an 'is_legacy_optimizer': False entry to what appears to be a test configuration dictionary in a completely different test file. While both relate to legacy optimizer configuration conceptually, the changed lines reference different symbols - one is a function parameter 'use_legacy_optimizer' and the other is a dictionary key 'is_legacy_optimizer'. There is no explicit code dependency between these specific changed lines, no shared symbol reference, and they appear to be in unrelated contexts (production code vs test configuration). The relationship is purely conceptual/thematic rather than based on direct code linkage."
        },
        {
            "sample_idx": 742,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a function named 'stop_route' and Edit 1 references that exact same function symbol 'stop_route' in an app.add_route call. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. After defining the stop_route function in Edit 0, adding the route that uses it in Edit 1 becomes the immediate, mechanically obvious next step. Both edits can be written and parsed in either order (Python allows referencing undefined symbols at parse time), making this bi-directional rather than ordered."
        },
        {
            "sample_idx": 743,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits do not reference the same symbol or have any direct code dependency. Edit 0 removes a line that assigns a boolean variable 'is_cfg_pp' based on checking if 'CFG++' is in the sampler config name. Edit 1 modifies a function call parameter by multiplying 'cond_scale' with 'self.cond_scale_miltiplier'. While both edits are in the same method and both involve conditional logic related to CFG (Classifier-Free Guidance), they operate on completely different variables and code constructs. The removed 'is_cfg_pp' variable in edit 0 has no relationship to the 'cond_scale' parameter modification in edit 1. There is no explicit symbol linkage, no structural dependency, and no mirrored substitution pattern between these changes."
        },
        {
            "sample_idx": 745,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve different functions and different symbols. Edit 0 adds an 'is_self_hosted_billing' parameter to a call to 'compute_plan_parameters()', while Edit 1 adds a parameter 'False' to a call to 'get_free_trial_days()'. The changed lines reference completely different function symbols - 'compute_plan_parameters' vs 'get_free_trial_days'. There is no explicit code linkage between these symbols, and no direct dependency where one edit creates an immediate prompt for the other. The edits appear to be separate parameter additions to unrelated function calls in different files and contexts."
        },
        {
            "sample_idx": 744,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code linkage. Edit 0 imports the function `pause_external_data_schedule` from the service module, while Edit 1 modifies the implementation of that same function by changing a parameter reference from `str(external_data_source.id)` to `id`. However, the changed lines do not reference the exact same symbol - Edit 0's changed lines reference the import of the function name, while Edit 1's changed lines reference different parameter symbols (`external_data_source.id` vs `id`). There is no immediate, mechanically obvious code-driven prompt between these specific changes. The import in Edit 0 does not create a direct dependency on the parameter change in Edit 1, and vice versa. This is a case where both edits relate to the same function conceptually, but the actual changed lines reference different symbols."
        },
        {
            "sample_idx": 746,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits involve the exact same symbol 'skip_animations' but represent different approaches to handling it. Edit 0 adds 'skip_animations': args.skip_animations to directly pass through the argument value, while Edit 1 removes code that was computing skip_animations as a derived value based on multiple conditions (args.skip_animations OR args.start_at_animation_number). This appears to be a refactoring where the logic for determining skip_animations is being simplified from a computed value to a direct pass-through. However, the edits reference the same symbol and represent alternative implementations - either could be applied first and the other would be a natural follow-up to complete the refactoring. The changed lines in both edits explicitly reference the same 'skip_animations' symbol in the config dictionary."
        },
        {
            "sample_idx": 749,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions with the same name 'load_unet' but they are different symbols in different scopes. Edit 0 modifies a module-level function `load_unet` in comfy/sd.py by adding a `dtype` parameter to a call to `load_unet_state_dict`. Edit 1 modifies a method `load_unet` within the `UNETLoader` class in nodes.py by adding a `weight_dtype` parameter to the method signature. While both edits involve functions named 'load_unet', they reference completely different symbols - one is a standalone function and the other is a class method. The changed lines do not reference the exact same symbol, and there is no direct code dependency between these two different functions."
        },
        {
            "sample_idx": 747,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new method `add_preheated_report_context()` that calls `self._add_browser_connection(PREHEATED_REPORT_CONTEXT)` on line 190. Edit 1 updates the docstring of the `_add_browser_connection` method to reflect that it can now accept `PREHEATED_REPORT_CONTEXT` as a parameter type in addition to `_BrowserWebSocketHandler`. Both edits reference the exact same method `_add_browser_connection` - edit 0 calls it with the new parameter type, and edit 1 documents this new usage. This creates a direct code linkage where either edit naturally prompts the other: adding the new caller suggests updating the documentation, and updating the documentation to mention the new parameter type suggests there should be code that uses it. Both edits can be made in either order without causing parse errors."
        },
        {
            "sample_idx": 750,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 removes the import statement 'from django.conf import settings' while Edit 1 removes a line that uses 'settings.PROJECT_ROOT'. These edits reference the exact same symbol 'settings' - Edit 0 removes the import that makes the 'settings' symbol available, while Edit 1 removes the usage of that same 'settings' symbol. However, since this is Python, both edits can be written and parsed in either order (removing the usage before the import, or removing the import before the usage). The usage removal would only cause a NameError at runtime if executed, but both edits can be staged independently. After making either edit, the other becomes the immediate next mechanical step to complete the removal of the settings dependency."
        },
        {
            "sample_idx": 748,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits demonstrate a classic function signature change paired with a call-site update for the exact same function. Edit 1 modifies the `get_free_trial_days` function signature by adding an `is_self_hosted_billing` parameter with a default value, while Edit 0 updates the call site to pass this new parameter. Both edits reference the exact same symbol (`get_free_trial_days`) in their changed lines. Since the parameter has a default value in the function definition, either edit can be staged first without causing a parse error - the call site can be updated before the signature change (it will use the default), or the signature can be changed before updating the call site (the call will still work with the default). This creates an immediate, mechanically obvious code-driven prompt where making either edit naturally leads to the other as the next contiguous action within the same micro-task of adding the new parameter functionality."
        },
        {
            "sample_idx": 751,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural transformation: they add a `data_interval_end_str` variable that formats a datetime string, and then incorporate this variable into the stage table name construction. The pattern is exactly the same - adding the same datetime formatting logic and modifying the stage table name assignment to include the formatted timestamp. This represents a uniform, synchronized multi-file substitution where the same before\u2192after pattern is applied to the same type of syntactic construct (stage table name generation) across different batch export implementations. Both edits can be applied in either order as they modify independent files and functions."
        },
        {
            "sample_idx": 754,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits operate on completely different parts of the codebase and involve different types of changes. Edit 0 reformats the formatting of a command-line argument parser for the '--enable-irq' option in the main module, while Edit 1 adds new Unicode character mappings ('MEDIUM_LINE' and 'LOW_LINE') to a Unicode output configuration dictionary. There is no shared symbol, no code dependency, and no structural relationship between these changes. The edits reference entirely different symbols and serve different purposes - one is a formatting change to argument parsing, the other adds display character definitions. Neither edit creates any code-driven prompt for the other."
        },
        {
            "sample_idx": 752,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they both reference the exact same dictionary key 'is_legacy_optimizer' in the same class context. Edit 0 adds this key to the config dictionary in the get_config() method, while Edit 1 removes this key from the config dictionary in the from_config() method before passing it to the constructor. This creates a direct code dependency where the key added in get_config() needs to be cleaned up in from_config() to prevent it from being passed as an unexpected parameter. Both edits are part of the same micro-task of handling the 'is_legacy_optimizer' configuration parameter, and either edit naturally prompts the other as the next mechanical step - if you add the key to the config output, you need to remove it from the config input, and vice versa."
        },
        {
            "sample_idx": 753,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines the symbol 'viewkeys' by adding it to the glances/compat.py module, while Edit 1 imports that exact same symbol 'viewkeys' from glances.compat in a different file. This creates a definition-usage relationship where both edits reference the exact same fully qualified symbol (glances.compat.viewkeys). In Python, imports can be written before their definitions are present since this only causes a runtime ImportError, not a parse-time syntax error. Either edit can be staged first, and after making either edit, the other becomes the immediate next step to complete the definition-usage pair. This fits the bi-directional pattern for cross-file definition-usage of the same symbol."
        },
        {
            "sample_idx": 755,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbours because they both reference the exact same symbol that is being renamed. Edit 0 renames the function from 'get_vcs_rev_define' to 'get_vcs_rev', and Edit 1 updates the call site to use the new function name 'get_vcs_rev' instead of the old 'get_vcs_rev_define'. The changed lines in both edits reference the same function symbol - one edit changes the definition and the other updates the usage. This creates an immediate, mechanically obvious code-driven prompt: after renaming the function, the call site must be updated to use the new name, and vice versa. Either edit can be made first since both are syntactically valid in Python (the call to a non-existent function would only fail at runtime, not at parse time)."
        },
        {
            "sample_idx": 757,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols in different files. Edit 0 imports functions from posthog.warehouse.data_load.service (external_data_workflow_exists, sync_external_data_job_workflow, pause_external_data_schedule, unpause_external_data_schedule), while Edit 1 adds 'schedule_exists' to an import list in the service.py file itself. The changed lines reference completely different symbols - Edit 0 references external_data_* functions while Edit 1 references 'schedule_exists'. There is no direct code linkage between the exact same symbols in both edits, only a conceptual relationship that both involve import statements in the same codebase."
        },
        {
            "sample_idx": 758,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines the instance attribute `self.need_last_noise_uncond = False` in the `__init__` method, while Edit 1 uses this exact same attribute in a conditional statement `if self.need_last_noise_uncond:` within the `forward` method. Both edits reference the exact same symbol (`self.need_last_noise_uncond`) and appear to be part of introducing a new control mechanism for when to store the last noise unconditioned value. The definition in `__init__` creates the immediate, mechanically obvious prompt to use this attribute elsewhere in the class, and the usage in `forward` represents that natural next step. Since Python allows referencing instance attributes before they are defined (would only cause AttributeError at runtime), either edit can be staged first, making this a bi-directional relationship."
        },
        {
            "sample_idx": 756,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 introduces a variable 'offset' and uses it to calculate 'removed_candles' with the formula 'len(data[pair]) - offset - backtesting.strategy.startup_candle_count'. Edit 1 adds an assertion that uses a very similar calculation pattern: 'len(data['NXT/BTC']) - 2 - backtesting.strategy.startup_candle_count'. While both edits involve similar calculation patterns and are in the same test function, they don't reference the exact same symbol. Edit 0 defines and uses the 'offset' variable and modifies the 'removed_candles' calculation, while Edit 1 creates a new assertion with a hardcoded value of '2' instead of using the 'offset' variable. The changed lines don't reference the same symbol - Edit 1 could have used the 'offset' variable but chose to hardcode '2' instead. This suggests they are related conceptually (both implementing similar calculation logic) but don't have direct code linkage through the exact same symbol."
        },
        {
            "sample_idx": 759,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 imports 'connection' from django.db in the common.py file, while Edit 1 uses 'connection.connect()' in the create.py file. However, these are different symbols - the 'connection' imported in common.py is not the same symbol being used in create.py. The changed lines reference different symbols despite having the same name. Edit 1's usage of 'connection' would need to have an import statement in create.py or reference the connection from common.py to establish a direct code linkage. Without evidence that create.py imports from common.py or that both edits reference the exact same symbol, this is merely a case of same-named identifiers in different scopes."
        },
        {
            "sample_idx": 760,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits modify two different function signatures by adding parameters, but they reference completely different symbols. Edit 0 adds a 'dtype' parameter to the 'load_unet_state_dict' function in comfy/sd.py, while Edit 1 adds a 'weight_dtype' parameter to the 'load_unet' method in the UNETLoader class in nodes.py. Although both edits involve adding type-related parameters to loading functions, the changed lines reference different symbols (different functions in different files and classes). There is no direct code dependency between these specific functions - they are different symbols despite having conceptually similar purposes. The relationship is purely thematic/conceptual rather than involving explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 761,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a new setting 'FEED_STORAGE_GCS_ACL = None' to the default settings file. Edit 1 adds the same setting key 'FEED_STORAGE_GCS_ACL' to a mock settings dictionary in a test. Both edits reference the exact same setting symbol 'FEED_STORAGE_GCS_ACL'. After adding the setting to default_settings.py, it becomes mechanically necessary to update the test mock to include this new setting to maintain test consistency. This represents a definition-usage relationship where the same symbol is being defined in one edit and referenced/used in another edit's changed lines. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship."
        },
        {
            "sample_idx": 763,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are in the same function and appear to be part of the same logical change involving row processing and indexing, but they do not reference the exact same symbol or create a direct code dependency. Edit 0 adds a comment above the line that assigns `row = data[pair][row_index]`, while Edit 1 removes the line `row_index += 1`. Although both edits relate to row processing logic and the `row_index` variable is involved in both contexts, the changed lines themselves do not reference the exact same symbol - Edit 0's changed lines are comment additions that don't reference any symbols, while Edit 1's changed line references `row_index` in an increment operation. There is no immediate, mechanically obvious code-driven prompt from one edit to the other. The relationship is conceptual (both relate to row processing logic) rather than based on explicit code linkage between the exact same symbols in the changed lines."
        },
        {
            "sample_idx": 764,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 imports 'ExcInfo' from celery.worker, and edit 1 uses that exact same imported symbol 'ExcInfo' in an isinstance check. After making edit 0 (the import), edit 1 becomes the immediate next step to use the newly imported symbol. After making edit 1 (the usage), edit 0 becomes necessary to provide the import. Both edits reference the exact same symbol 'ExcInfo' and create a direct import-usage dependency within the same file and function context."
        },
        {
            "sample_idx": 765,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines the function 'viewkeys' by assigning it to 'operator.methodcaller('keys')', and Edit 1 uses this exact same 'viewkeys' function in its changed line. The changed line in Edit 1 calls 'viewkeys(self.get_raw())' which directly references the symbol defined in Edit 0. This creates an immediate code dependency where after defining viewkeys in Edit 0, using it in Edit 1 becomes a natural next step, or vice versa. Both edits reference the exact same symbol 'viewkeys' and either edit can be staged first since Python allows referencing undefined names at parse time (only failing at runtime)."
        },
        {
            "sample_idx": 762,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 changes a method call from `self._test_error_exc_info()` to `_test_error_exc_info()`, removing the `self.` prefix to reference a module-level function instead of an instance method. Edit 1 removes the definition of the `_test_error_exc_info` function entirely. After edit 1 is applied, the call in edit 0 would reference a non-existent function, creating an immediate code-driven prompt to either restore the function definition or change the call. The changed lines reference the exact same symbol (`_test_error_exc_info` function), and removing the definition creates a direct dependency where the usage becomes invalid. However, since edit 0 can be applied regardless of whether the function exists (it would just cause a NameError at runtime, not a parse error), and edit 1 can be applied regardless of whether there are calls to the function, both edits can be staged in either order. The relationship is bi-directional because either edit creates an immediate prompt for the other as the next logical step."
        },
        {
            "sample_idx": 766,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits are updating calls to the same function `get_free_trial_days()` to include a new parameter. Edit 0 changes the call from `get_free_trial_days()` to `get_free_trial_days(is_self_hosted_billing)`, while edit 1 changes the call from `get_free_trial_days()` to `get_free_trial_days(False)`. Both edits reference the exact same symbol (the `get_free_trial_days` function) and are part of a uniform substitution pattern where the function signature has been changed to require a parameter, necessitating updates to all call sites. This is a bulk-edit pattern where both edits perform the same type of structural change (adding a parameter to function calls) for the same function. Either edit can be made first since both are valid syntactically, and both are part of the same refactoring task to update all callers of the modified function."
        },
        {
            "sample_idx": 767,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 introduces a new variable `x_shape` by assigning it the value `x0.shape`, and edit 1 uses that exact same variable `x_shape` in the return statement. The changed lines reference the exact same symbol - the variable `x_shape` defined in edit 0 and used in edit 1. After making edit 0, the natural next step would be to use the newly created `x_shape` variable, which edit 1 does. However, edit 1 could also be written first (adding `x_shape` to the return statement) and then edit 0 could define it - both edits can be parsed and staged in either order, with only a runtime NameError if `x_shape` is used before being defined. This represents a definition-usage relationship within the same function scope in Python, which is bi-directional according to the criteria."
        },
        {
            "sample_idx": 768,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different print statements in what appears to be different conditional branches of the same function. Edit 0 adds a print statement for when server_command == 'stop', while Edit 1 removes a print statement that appears to be in a KeyboardInterrupt handler (based on the message content and surrounding comment). Although both involve print statements with similar stopping-related messages, they reference different string literals and serve different purposes in different code paths. There is no direct code dependency between these specific changed lines - they don't reference the same symbol, variable, or function. The relationship is only thematic (both relate to stopping/shutdown messages) rather than having explicit code linkage."
        },
        {
            "sample_idx": 769,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite having similar variable name changes. Edit 0 changes the variable name from 'endpoint' to 'email_type' in the one_click_unsubscribe_link function in notifications.py. Edit 1 changes the variable name from 'type' to 'email_type' and 'token' to 'confirmation_key' in the email_unsubscribe function in unsubscribe.py. While both edits involve renaming variables to 'email_type', they are operating on different symbols in different functions and files. The 'email_type' variable in edit 0 is a different symbol from the 'email_type' variable in edit 1 - they exist in different scopes and contexts. There is no direct code dependency or reference between the exact same symbols in the changed lines."
        },
        {
            "sample_idx": 771,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different files and different symbols with no direct code linkage. Edit 0 removes a comment line in glances_curses.py within a display method, while Edit 1 adds two new Unicode character mappings ('MEDIUM_LINE' and 'LOW_LINE') to a dictionary in glances_unicode.py. The changed lines do not reference, assign, call, or import the exact same symbol. There is no explicit code dependency between removing a comment and adding Unicode character definitions. While both edits may be part of the same feature development conceptually, there is no immediate, mechanically obvious code-driven prompt linking these specific changes."
        },
        {
            "sample_idx": 770,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds a new function `stop_route` that sets `shared.state.server_command = \"stop\"`, while Edit 1 removes a print statement about catching KeyboardInterrupt. These edits involve completely different code constructs - one adds a route handler function and the other removes a print statement. There is no direct code dependency between them, no shared symbols being referenced, and no explicit linkage between the changed lines. The only potential connection is conceptual (both relate to stopping functionality), but the changed lines themselves reference different elements and there is no mechanical prompt from one edit to the other."
        },
        {
            "sample_idx": 772,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 changes the signature of the `new_line` method by adding a `separator` parameter. Edit 1 adds a call to `self.separator_line()` method. Despite both being related to line/separator functionality conceptually, the changed lines reference completely different symbols: `new_line` vs `separator_line`. There is no explicit code linkage where one edit creates an immediate, mechanically obvious prompt for the other. The `separator_line` method call in edit 1 is not calling the modified `new_line` method from edit 0, so there is no definition-usage relationship between the exact same symbol."
        },
        {
            "sample_idx": 773,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an 'update=False' parameter to a call to 'folder_get', while Edit 1 modifies the 'folder_get' method definition to accept and pass through an 'update' parameter. These edits reference the exact same method symbol - the 'folder_get' method of HandlerStorage class. Edit 0 changes the call site to include the new parameter, and Edit 1 changes the method signature and implementation to handle that parameter. This creates an immediate, mechanically obvious code dependency where making either edit prompts the need for the other to maintain code consistency. Both edits can be staged in either order without causing parse errors (the call site can have the extra parameter before the method accepts it, and the method can accept the parameter before any call site uses it), making this a bi-directional relationship."
        },
        {
            "sample_idx": 776,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different parts of the same class but reference completely different symbols and functionality. Edit 0 adds a new method `separator_line` to the `_GlancesCurses` class, while Edit 1 removes a comment line from the `__display_header` method. The changed lines in each edit do not reference the same symbol, function, variable, or any shared code element. Edit 0 introduces new functionality for drawing separator lines, while Edit 1 is a simple comment removal in a different method. There is no explicit code dependency, no shared symbol references, and no structural synchronization between these changes. They appear to be independent modifications that happen to be in the same class but serve different purposes."
        },
        {
            "sample_idx": 774,
            "yi": "0 before 1",
            "pred": "0 before 1",
            "pred_reason": "This is a cut-and-paste move operation where the exact same import statement 'from localstack.services.awslambda.lambda_api import get_handler_file_from_name' is being removed from one location (line 9 in edit 0) and added to another location (after line 12 in edit 1) within the same file. For this type of relocation to work correctly, the import must first be removed from its original position before being added to the new position, otherwise there would be a duplicate import. This creates a mechanical dependency where edit 0 (removal) must occur before edit 1 (addition)."
        },
        {
            "sample_idx": 777,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines the symbol 'viewkeys' by creating a variable assignment 'viewkeys = operator.methodcaller('viewkeys')', while Edit 1 uses that exact same symbol 'viewkeys' in a function call 'viewkeys(self.get_raw())'. The changed lines reference the exact same symbol - the viewkeys function that is being defined in one edit and called in the other. This creates a definition-usage relationship where either edit can be staged first (the usage would result in a runtime NameError but not a parse error in Python), making this a bi-directional relationship where making either edit creates an immediate prompt for the other as the next logical step."
        },
        {
            "sample_idx": 775,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 removes code that checks `schema_model.should_sync` in the `check_schedule_activity` function, while Edit 1 adds an `update` method that handles `should_sync` logic in a different class (`ExternalDataSchema`). Although both edits involve the `should_sync` attribute conceptually, they operate on different objects in different contexts - Edit 0 works with a `schema_model` variable within a workflow function, while Edit 1 works with `validated_data` and `instance` within a serializer update method. The changed lines do not reference the exact same symbol, and there is no immediate, mechanically obvious code-driven prompt between them. This is a conceptual/thematic relationship around should_sync functionality, but lacks the explicit code linkage required for neighbour classification."
        },
        {
            "sample_idx": 778,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 adds an import for the 'operator' module in glances/compat.py, while Edit 1 uses a function called 'viewkeys()' in glances/plugins/glances_plugin.py. These edits reference completely different symbols - the 'operator' module versus a 'viewkeys' function. There is no direct code linkage between the imported 'operator' module and the usage of 'viewkeys()'. The changed lines do not reference, assign, call, or import the exact same symbol. While both edits might be part of the same feature or refactoring effort, they lack the explicit, immediate code dependency required for neighbour classification."
        },
        {
            "sample_idx": 781,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These edits show a function signature change and corresponding call-site update for the exact same function. Edit 0 modifies the call to `load_unet_state_dict` within the `load_unet` function to add a `dtype` parameter. Edit 1 modifies the call to `comfy.sd.load_unet` to pass the `dtype` parameter. However, looking more carefully, these are changes to different function calls - Edit 0 changes a call to `load_unet_state_dict` while Edit 1 changes a call to `load_unet`. The changed lines reference different symbols (`load_unet_state_dict` vs `comfy.sd.load_unet`), even though Edit 1's call is to the function that contains Edit 0's change. Since the changed lines don't reference the exact same symbol, this is not a direct code dependency relationship."
        },
        {
            "sample_idx": 780,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits add the identical line 'connection.connect()' at the same relative position within similar function structures (both are nested functions that operate on proxy records). This represents a bulk/pattern synchronization where the same code change is being applied to multiple similar functions as part of a single refactoring task. The edits involve identical textual substitution (adding the same line) to the same type of syntactic construct (nested functions with similar purposes). Either edit could be made first, and after making one, the other would be the natural next step to maintain consistency across the codebase."
        },
        {
            "sample_idx": 779,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve completely different symbols and contexts. Edit 0 adds documentation to the `_newnames` function in `numpy/core/_internal.py`, while Edit 1 adds an import (`assert_raises_regex`) to the import statement in `numpy/core/tests/test_multiarray.py`. The changed lines reference entirely different symbols - one is adding a docstring to a specific function, the other is importing a testing utility. There is no direct code dependency, shared symbol reference, or structural relationship between adding documentation to `_newnames` and importing `assert_raises_regex`. These edits serve different purposes in different files with no mechanical linkage."
        },
        {
            "sample_idx": 782,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 adds a comment explaining that 'Buy / sell signals are shifted by 1 to compensate for this' and Edit 1 adds the actual code 'row_index += 1' that implements the increment. While both edits relate to the same concept of shifting/incrementing by 1, they do not reference the exact same symbol in their changed lines. Edit 0 only adds a comment (no executable code referencing any symbol), while Edit 1 modifies the row_index variable. The comment in Edit 0 does not create a direct, mechanically obvious code-driven prompt for Edit 1 - it's explanatory documentation rather than a code dependency. There is no explicit code linkage between the changed lines themselves, only a conceptual relationship about the shifting behavior."
        },
        {
            "sample_idx": 785,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols despite having similar names. Edit 0 imports 'GlancesPasswordList' and aliases it as 'GlancesPassword', while Edit 1 modifies the '__init__' method of a class that is already named 'GlancesPassword'. The changed lines reference completely different symbols: Edit 0 references the imported class 'GlancesPasswordList', while Edit 1 references the existing 'GlancesPassword' class and adds a super() call. There is no direct code dependency or explicit linkage between these specific changed lines - they are working with different symbols in different contexts."
        },
        {
            "sample_idx": 784,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new function `schedule_exists` with parameter `schedule_id`, and edit 1 calls that exact same function `schedule_exists` with the `schedule_id` parameter. This creates a direct definition-usage relationship where the changed lines reference the exact same symbol. In Python, both edits can be parsed and staged in either order (the usage would only fail at runtime if the definition isn't available), making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 783,
            "yi": "no relation",
            "pred": "1 before 0",
            "pred_reason": "Edit 1 removes the local definition of 'cwd' from the run_subprocess method, while Edit 0 adds 'cwd=cwd' as a parameter to the call to run_subprocess(). This creates a direct code dependency where Edit 0 references a parameter 'cwd' that would be undefined after Edit 1 removes the local cwd variable. Edit 1 must occur before Edit 0 because Edit 1 appears to be changing run_subprocess to accept cwd as a parameter (removing the local definition), and Edit 0 is updating the call site to pass cwd as an argument. If Edit 0 were applied first, it would pass a cwd parameter to a method that doesn't accept it, and if Edit 1 were applied first without Edit 0, the cwd variable would be undefined in the Popen call."
        },
        {
            "sample_idx": 787,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve parameter name changes in two different functions in different files. Edit 0 changes the parameter name from 'endpoint' to 'email_type' in the one_click_unsubscribe_link function, while Edit 1 changes variable references from 'type' to 'email_type' and 'token' to 'confirmation_key' in the email_unsubscribe function. Although both edits involve the name 'email_type', they are referencing different symbols - one is a parameter in one function, and the other is a variable in a completely different function. The changed lines do not reference the exact same symbol, and there is no direct code dependency between these two functions based on the edits shown. This appears to be part of a broader refactoring to standardize parameter naming, but the edits themselves don't create immediate, mechanically obvious prompts for each other."
        },
        {
            "sample_idx": 786,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve completely different symbols and have no direct code linkage. Edit 0 removes a `recv` method from the `QaEngineer` class in `metagpt/roles/qa_engineer.py`, while Edit 1 adds a `run_tests` parameter to the `main` function in `startup.py`. The changed lines reference entirely different symbols - the `recv` method in one case and the `main` function signature in another. There is no explicit code dependency, import relationship, or synchronized substitution pattern between these edits. They appear to be independent changes that happen to both relate to testing functionality conceptually, but lack any direct, mechanical code linkage at the locus of change."
        },
        {
            "sample_idx": 788,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in different files and affect completely different code contexts. Edit 0 modifies a conditional check in a method that handles request/reply node logic, specifically adding a check for 'self.name in executor_endpoint_mapping'. Edit 1 adds a logger initialization line in a different class constructor in a different file. The changed lines do not reference the same symbol, function, class, or any shared code element. There is no direct code dependency, import relationship, or structural linkage between these edits. They appear to be separate, unrelated changes that happen to be part of the same codebase but do not create any immediate, mechanically obvious prompt for one another."
        },
        {
            "sample_idx": 789,
            "yi": "1 before 0",
            "pred": "1 before 0",
            "pred_reason": "Edit 0 adds a print statement 'Caught KeyboardInterrupt, stopping...' at line 369, while Edit 1 removes the exact same print statement from line 365. These edits reference the exact same line of code - one adds it and the other removes it. This appears to be a cut-and-paste move operation where the print statement is being relocated from one position in the KeyboardInterrupt handling code to another position. Since Edit 1 removes the statement and Edit 0 adds it (likely at a different location in the same exception handler), this represents moving the same code element. For a move operation, the removal must logically occur before the addition to avoid duplication."
        },
        {
            "sample_idx": 790,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 changes a docstring comment in the `_add_browser_connection` method of the `Server` class, while Edit 1 adds a method call `server.add_preheated_report_context()` in a different file's `run` function. The changed lines reference completely different symbols and operations - one is a documentation change to a private method, the other is adding functionality to a server initialization routine. There is no explicit code linkage, no shared symbol references, and no direct dependency between these changes. They appear to be part of different development tasks."
        },
        {
            "sample_idx": 791,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different code contexts. Edit 0 adds a new function `schedule_exists` to the schedule.py file, while Edit 1 changes the parameter signature of an existing function `unpause_external_data_schedule` in a different file (service.py). The changed lines reference completely different symbols - one defines a new function with its own parameters, while the other modifies the parameter list of an unrelated function. There is no direct code dependency, no shared symbol references, and no structural synchronization between these changes. They appear to be separate modifications that happen to both involve scheduling-related code conceptually, but lack any explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 792,
            "yi": "1 before 0",
            "pred": "1 before 0",
            "pred_reason": "This is a cut-and-paste move operation where the exact same function `_test_error_exc_info()` is being removed from one location (lines 287-291) and added to another location (lines 17-21) within the same file. The function definition is identical in both edits. This creates a direct dependency where the removal must occur before the addition to avoid having duplicate function definitions, which would cause a syntax/parsing issue. The second edit cannot be properly staged until the first edit removes the original definition."
        },
        {
            "sample_idx": 793,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code dependency. Edit 0 modifies the return statement of the `update` function within `sm3` in the optimizers module, adding `x_shape` to the returned tuple. Edit 1 renames and restructures test methods in the test file, splitting `testSM3` into `testSM3Scalar` and `testSM3Vector`. While both edits relate to the SM3 optimizer conceptually, the changed lines reference entirely different symbols - Edit 0 changes a return statement in the implementation, while Edit 1 changes test method names and structure. There is no explicit code linkage where the exact same symbol is referenced in both edits' changed lines. The connection is purely thematic/conceptual rather than a direct code dependency."
        },
        {
            "sample_idx": 796,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve the QaEngineer class but in completely different contexts and without any direct code linkage. Edit 0 adds a comment to the _init_actions call within the QaEngineer class definition, while Edit 1 restructures how QaEngineer is instantiated in a startup function - moving it from the initial hire list to a conditional hire block. The changed lines do not reference the exact same symbol or create any immediate mechanical dependency between them. Edit 0 modifies the internal implementation of QaEngineer, while Edit 1 modifies how QaEngineer instances are created in an unrelated function. There is no explicit code dependency, shared symbol reference, or synchronized pattern between these changes - they are conceptually related to the same class but represent independent modifications."
        },
        {
            "sample_idx": 794,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different aspects of the same system but do not have direct code linkage. Edit 0 modifies the __repr__ method of BaseDeletionTask to include skip_models in the string representation, while Edit 1 adds a skip_models parameter to a deletions.get() call. Although both involve the skip_models concept, the changed lines reference different symbols: Edit 0 references self.skip_models (an attribute access within the __repr__ method), while Edit 1 creates a new skip_models parameter in a function call. There is no direct syntactic dependency between these specific changed lines - neither edit creates an immediate, mechanically obvious prompt for the other. The connection is conceptual (both relate to skip_models functionality) rather than a direct code dependency where the exact same symbol is referenced in both changed lines."
        },
        {
            "sample_idx": 795,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (GCS ACL support) but do not have direct code linkage between the changed lines. Edit 0 adds a new configuration setting FEED_STORAGE_GCS_ACL in the default settings file, while Edit 1 updates a test assertion to include a predefined_acl parameter. The changed lines reference different symbols: Edit 0 defines a configuration constant, while Edit 1 modifies a mock assertion call. There is no explicit reference to the same symbol in both changed lines - the test assertion references a parameter 'acl' (likely a local variable) while the settings file defines 'FEED_STORAGE_GCS_ACL'. Even though they are conceptually related (both part of implementing GCS ACL functionality), the relationship is thematic rather than having direct code dependency between the exact same symbols in the changed lines."
        },
        {
            "sample_idx": 799,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts with no direct code linkage. Edit 0 adds a parameter 'is_self_hosted_billing' to a function signature in stripe.py, while Edit 1 adds a configuration setting 'SELF_HOSTING_FREE_TRIAL_DAYS' in default_settings.py. Although both relate to self-hosting functionality conceptually, the changed lines reference completely different symbols - one is a function parameter and the other is a configuration constant. There is no explicit code dependency where the changed lines reference, assign, call, or import the exact same symbol. The relationship is purely thematic/conceptual rather than having direct, mechanically obvious code linkage."
        },
        {
            "sample_idx": 797,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits are adding new key-value pairs to what appears to be the same dictionary within the same function `get_configuration(args)`. Edit 0 adds `'skip_animations': args.skip_animations` at line 304, and Edit 1 adds `'preview': not write_file` at line 307. While both edits are part of building the same dictionary structure and likely part of the same feature addition or configuration enhancement, there is no direct code dependency between the changed lines themselves. Neither edit references the same symbol - they add different keys with different values. The edits don't create an immediate, mechanically obvious prompt for each other, and either could be staged independently without creating parsing issues or direct symbol dependencies. This is a case of conceptual/thematic relationship (both adding configuration options) rather than explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 798,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits show a clear structural dependency where edit 0 changes the return signature of the update function to include an additional x_shape parameter, and edit 1 updates the get_params function to destructure this new 4-tuple format. The changed lines reference the exact same state tuple structure - edit 0 modifies what gets packed into the state tuple, and edit 1 modifies how that same state tuple gets unpacked. After making edit 0, the get_params function would fail at runtime due to a ValueError (too many values to unpack) when trying to destructure a 4-tuple with only 3 variables. While this is a runtime error rather than a parse error in Python, both edits reference the exact same state structure and making either edit creates an immediate, mechanically obvious prompt for the other to maintain consistency in the tuple packing/unpacking pattern."
        },
        {
            "sample_idx": 800,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 changes how duration is calculated in the debugMsg line by replacing 'duration' with 'int(time.time() - start)' in the __goInference function. Edit 1 adds a 'start = time.time()' line in a completely different function (queryOutputLength) in a different file. While both edits involve timing functionality and the variable name 'start', they reference different symbols in different scopes - the 'start' variable in edit 0's changed line refers to a variable that should exist in the __goInference function context, while edit 1 creates a new 'start' variable in the queryOutputLength function. The changed lines do not reference the exact same symbol, and there is no direct code dependency between these specific changes. This appears to be part of a broader refactoring to improve timing calculations across multiple functions, but the edits themselves lack the immediate, mechanically obvious code linkage required for neighbour classification."
        },
        {
            "sample_idx": 801,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds 'schedule_exists' to an import list, while Edit 1 defines a new function 'external_data_workflow_exists' that calls the exact same 'schedule_exists' symbol. This creates a direct import-usage relationship where both edits reference the same symbol. After making either edit, the other becomes the immediate next step - importing schedule_exists makes it available for use, and using schedule_exists requires it to be imported. Since this is Python, both edits can be parsed and staged in either order (the usage would only fail at runtime if the import is missing), making this a bi-directional relationship rather than ordered."
        },
        {
            "sample_idx": 802,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add parameters to function signatures, but they are adding different parameters to completely unrelated functions in different files. Edit 0 adds 'test_round_allowed=5' to the QaEngineer.__init__ method, while Edit 1 adds 'run_tests: bool = False' to the startup function. These are different symbols (different functions) and there is no direct code dependency, reference, or synchronized pattern between them. The parameters have different names and purposes, and the functions serve different roles in the codebase. This is purely coincidental that both edits involve parameter additions - there is no explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 803,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural transformation: converting single-line parser.add_argument() calls into multi-line format by splitting the parameters across separate lines. This is a uniform formatting/style change applied to the same type of syntactic construct (parser.add_argument calls) with the exact same before\u2192after pattern. Both edits are part of a single, contiguous code formatting refactor that could be applied in either order as part of the same micro-task."
        },
        {
            "sample_idx": 804,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of optimizer handling. Edit 0 adds a 'use_legacy_optimizer=False' parameter to a call to optimizers.deserialize() in the LossScaleOptimizerV3 class. Edit 1 adds an 'is_legacy_optimizer': True key-value pair to a config dictionary in the Optimizer class's get_config() method. While both edits relate to legacy optimizer handling conceptually, the changed lines reference different symbols: Edit 0 modifies a function call with a 'use_legacy_optimizer' parameter, while Edit 1 modifies a config dictionary with an 'is_legacy_optimizer' key. There is no direct code dependency between these specific changed lines - they don't reference the same symbol, function, or variable. The relationship is purely conceptual/thematic around legacy optimizer configuration, which according to the criteria should be labeled as 'no relation'."
        },
        {
            "sample_idx": 805,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and serve different purposes. Edit 0 adds imports for SEND_CELERY_TASK_ERROR_EMAILS and mail_admins at the module level, while Edit 1 adds an import for ExcInfo from celery.worker inside a method. The changed lines reference completely different symbols (SEND_CELERY_TASK_ERROR_EMAILS/mail_admins vs ExcInfo) and there is no direct code dependency between them. They appear to be separate import additions for different functionality rather than part of a single mechanically-driven task."
        },
        {
            "sample_idx": 806,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 modifies a call to `unpause_external_data_schedule` by changing its argument from `source` to `str(source.id)`. Edit 1 adds a new function `schedule_exists` in a different file. The changed lines do not reference the same symbol - edit 0 calls `unpause_external_data_schedule` while edit 1 defines `schedule_exists`. There is no explicit code linkage between these edits, and neither edit creates an immediate, mechanically obvious prompt for the other. They appear to be separate changes that happen to be in the same codebase but lack the direct symbol reference required for neighbour classification."
        },
        {
            "sample_idx": 808,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are both formatting changes that split long lines to improve code readability, but they operate on completely different symbols and code contexts. Edit 0 reformats a conditional expression involving config.get_option() calls in the _get_routes method, while Edit 1 reformats a self.write() method call in the _DebugHandler class. The changed lines reference entirely different symbols (config.get_option vs self.write) and there is no direct code dependency, shared symbol reference, or synchronized substitution pattern between them. They are independent formatting improvements that happen to follow similar line-splitting patterns but lack any explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 807,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and have no direct code linkage. Edit 0 adds an 'import os' statement in the devserver function in devserver.py, while Edit 1 adds a 'cwd=None' parameter to the run_subprocess method in the SentryHTTPServer class in http.py. The changed lines do not reference, assign, call, or import the exact same symbol. There is no explicit code dependency between adding an os import and adding a cwd parameter to an unrelated method in a different file and class. The connection, if any, would be purely conceptual (both might relate to file system operations) but there is no direct, mechanical code-driven prompt from one edit to the other."
        },
        {
            "sample_idx": 809,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical textual substitution pattern: changing 'get_free_trial_days()' to 'get_free_trial_days(True)' in function call contexts. They target the same type of syntactic construct (function calls with the same name) and represent a uniform refactoring operation where the same parameter is being added to multiple calls of the same function. This is a clear case of bulk-edit pattern synchronization where both edits reference the exact same symbol 'get_free_trial_days' and apply the identical before\u2192after transformation. Either edit could be made first, and after making one, the other would be the natural next step to complete the uniform refactoring."
        },
        {
            "sample_idx": 811,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 defines the constant AWS_REGION_US_EAST_1 in constants.py, while Edit 0 imports/uses that exact same symbol in config.py by adding it to an import statement. This creates a direct definition-usage relationship where both edits reference the exact same symbol. In Python, imports can be written before the symbol is defined (resulting in a runtime ImportError rather than a parse error), so either edit can be staged first. After making either edit, the other becomes the immediate next step to complete the definition-usage pair."
        },
        {
            "sample_idx": 810,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 1 adds an 'update' parameter to the pull_path method signature with a default value of True, while Edit 0 passes update=False to a method call (folder_get) that likely uses pull_path internally. However, the changed lines reference different symbols - Edit 0 references 'folder_get' method while Edit 1 references 'pull_path' method. Even though these methods may be related in the call chain, the actual changed lines do not reference the exact same symbol. The connection is through internal implementation details rather than direct symbol reference in the changed lines themselves."
        },
        {
            "sample_idx": 812,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural and textual substitution pattern. They both add the exact same two lines of code: (1) creating a `data_interval_end_str` variable using the same datetime formatting logic, and (2) modifying the `stagle_table_name` assignment to include this timestamp suffix in the same conditional pattern. The changes are syntactically identical and target the same type of construct (variable assignments within similar batch export functions). This represents a bulk edit or synchronized refactoring where the same code pattern is being applied across multiple related files as part of a single, contiguous development task. Both edits can be made in either order since they are independent additions to separate files."
        },
        {
            "sample_idx": 815,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are not neighbours in mental flow. Edit 0 adds a call to `self.filter_relations(child_relations)` in the `delete_bulk` method of `BaseDeletionTask`, while Edit 1 adds a `skip_models` parameter to a `deletions.get()` call in a cleanup command. Although both edits are conceptually related to deletion/cleanup functionality, the changed lines do not reference the exact same symbol. Edit 0 references a `filter_relations` method, while Edit 1 references a `skip_models` parameter. There is no direct code dependency or synchronized substitution between these specific changes - they are separate modifications that happen to be part of the same broader feature but lack explicit code linkage at the locus of change."
        },
        {
            "sample_idx": 813,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits modify the same function's state tuple structure in a coordinated way. Edit 0 changes the return statement in the `init` function to return a 4-tuple by adding `x_shape`, while Edit 1 updates the unpacking of that same state tuple in the `update` function to expect the new 4-tuple format by adding `x_shape` to the unpacking. Both edits reference the exact same `state` data structure - one modifies how it's created and the other modifies how it's consumed. This creates an immediate code dependency where changing the tuple structure in `init` mechanically requires updating the corresponding unpacking in `update` to maintain consistency. Either edit can be made first since Python allows tuple unpacking mismatches at parse time (they only fail at runtime), making this a bi-directional relationship."
        },
        {
            "sample_idx": 814,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol 'acl' within the same test method. Edit 0 defines/assigns the variable 'acl = 'publicRead'' and edit 1 uses that same variable as a parameter 'acl' in the GCSFeedStorage constructor call. This creates an immediate, mechanically obvious code dependency where defining the acl variable naturally prompts its usage in the constructor call as part of a single micro-task of updating the test to include ACL functionality. The changed lines in both edits explicitly reference the same symbol, making this a bi-directional relationship where either edit could be made first and would prompt the other as the next logical step."
        },
        {
            "sample_idx": 816,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits reference the exact same symbol 'JinaLogger' - edit 0 imports JinaLogger from jina.logging.logger, and edit 1 adds a parameter with type annotation JinaLogger to the __init__ method. After importing JinaLogger in edit 0, it becomes available for use as a type annotation in edit 1. Conversely, if edit 1 were made first, the type annotation would reference an undefined symbol until the import in edit 0 is added. However, in Python, type annotations are not evaluated at parse time, so both edits can be written and parsed in either order - the undefined type annotation would only cause issues during type checking or runtime evaluation, not parsing. This makes it a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 817,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and contexts. Edit 0 adds a 'cwd' parameter to a Popen constructor call in the devserver command, while Edit 1 adds a 'cwd' parameter to the run_subprocess method signature in the SentryHTTPServer class. Although both involve a 'cwd' parameter, they reference completely different symbols - one is a parameter being passed to Popen, the other is a parameter being added to a method signature. The changed lines do not reference the exact same symbol, and there is no direct code dependency between these two locations. This appears to be a thematic change (adding cwd support in multiple places) rather than a direct code linkage."
        },
        {
            "sample_idx": 818,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (GCS ACL support) but they reference different symbols and contexts. Edit 0 adds 'FEED_STORAGE_GCS_ACL': None to a mock configuration dictionary in test_parse_settings method. Edit 1 modifies a test assertion in test_store method to include predefined_acl=acl parameter. While both are part of implementing ACL functionality, the changed lines don't reference the exact same symbol - one modifies a configuration mock while the other modifies a method call assertion. There's no direct code dependency where making one edit creates an immediate, mechanically obvious prompt for the other. They are conceptually related but lack explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 820,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 modifies the GCSFeedStorage.from_crawler method to accept an additional parameter 'FEED_STORAGE_GCS_ACL' from crawler.settings. Edit 1 updates a test mock to include this same setting 'FEED_STORAGE_GCS_ACL'. Both edits reference the exact same symbol ('FEED_STORAGE_GCS_ACL') and appear to be part of the same development session where a new setting is being added to the production code and the corresponding test is being updated to mock that setting. The test edit ensures the mock provides the setting that the production code now expects. This creates a bi-directional relationship where either edit prompts the other as the next mechanical step - adding the setting usage requires updating the test mock, and vice versa."
        },
        {
            "sample_idx": 819,
            "yi": "no relation",
            "pred": "0 before 1",
            "pred_reason": "Edit 0 changes a method call from `self._test_error_exc_info()` to `_test_error_exc_info()`, removing the `self.` prefix to reference a module-level function instead of an instance method. Edit 1 removes the definition of the `_test_error_exc_info` function entirely. These edits reference the exact same symbol (`_test_error_exc_info`) but in opposite directions - edit 0 creates a dependency on the function while edit 1 removes it. If edit 1 is applied first (removing the function), then edit 0 would fail with a NameError at runtime when the function is called. If edit 0 is applied first, it creates an immediate code-driven prompt to define the missing function. However, since edit 1 removes rather than defines the function, this appears to be a refactoring where the function call is being changed and the function definition is being removed, suggesting edit 0 should occur before edit 1 to avoid referencing a non-existent function."
        },
        {
            "sample_idx": 822,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits modify two different functions with the same name 'load_unet' but they are different symbols in different scopes. Edit 0 modifies a standalone function 'load_unet' in comfy/sd.py, while Edit 1 modifies a method 'load_unet' within the UNETLoader class in nodes.py. Although both edits add similar parameter functionality (dtype/weight_dtype), the changed lines reference completely different symbols - one is a module-level function and the other is a class method. There is no direct code dependency or explicit linkage between these two different symbols, despite their identical names."
        },
        {
            "sample_idx": 823,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits involve different symbols and different types of changes with no direct code linkage. Edit 0 modifies the signature of the `new_line` method by adding a `separator` parameter. Edit 1 reformats the arguments in a call to `display_plugin` method by splitting them across multiple lines for readability. The changed lines in each edit reference completely different symbols - `new_line` method signature vs `display_plugin` method call with `stat_display` arguments. There is no explicit code dependency, no shared symbol reference, and no structural synchronization between these changes. They appear to be independent code improvements that happen to be in the same file."
        },
        {
            "sample_idx": 821,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are both modifying argument parser configurations in the same file and class, but they involve completely different arguments and different types of changes. Edit 0 reformats the existing '--enable-irq' argument by splitting its parameters across multiple lines for better readability. Edit 1 adds an entirely new argument '--separator'/'--enable-separator' with its own distinct parameters. The changed lines reference different argument names ('enable_irq' vs 'enable_separator'), different destinations, and different help text. There is no direct code dependency between these edits - neither edit creates a prompt for the other, and they can be applied independently in any order. While both are part of argument parser setup, this represents only a conceptual/thematic relationship, not an explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 824,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 adds an import statement for 'unicode_message' from the glances_unicode module. Edit 1 adds method calls to 'self.init_column()' and 'self.separator_line()' within the display method. The changed lines in each edit reference entirely different symbols - the import references 'unicode_message' while the method calls reference 'init_column' and 'separator_line'. There is no explicit code dependency between importing 'unicode_message' and calling these display-related methods. The connection, if any, would be purely conceptual (both related to display functionality) rather than a direct, mechanical code dependency where one edit creates an immediate prompt for the other."
        },
        {
            "sample_idx": 825,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 modifies a function call to `unpause_external_data_schedule` by changing its argument from `source` to `str(source.id)`, while Edit 1 removes an import of `aget_schema_by_id` from a different file. The changed lines do not reference the same symbol - one involves `unpause_external_data_schedule` and the other involves `aget_schema_by_id`. There is no explicit code dependency, no mirrored substitution pattern, and no immediate mechanical prompt between these changes. They appear to be independent code modifications that may be part of a larger refactoring but lack the direct symbol linkage required for neighbor classification."
        },
        {
            "sample_idx": 827,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 adds a command-line argument '--add-stop-route' to enable a stop route functionality, while Edit 1 adds a print statement when a server stop command is executed. Although both relate to server stopping functionality conceptually, they do not reference the same symbol or have direct code linkage. The changed lines reference completely different elements: Edit 0 references the argument parser and a new '--add-stop-route' option, while Edit 1 references a print statement in response to a 'stop' command. There is no explicit code dependency between these specific changed lines - they are part of the same feature but operate independently without one creating an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 826,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits perform an identical structural transformation on the same type of syntactic construct. Edit 0 reformats the '--disable-plugin' parser.add_argument() call by splitting the single-line parameter list into multiple lines, and Edit 1 applies the exact same formatting pattern to the '--enable-plugin' parser.add_argument() call. This is a clear case of bulk-edit/pattern synchronization where both edits use the same before\u2192after pattern (single-line parameter list \u2192 multi-line parameter list) on the same construct type (parser.add_argument calls). Both edits are part of a single, contiguous code formatting refactor and either could be applied first, with the other naturally following as part of the same uniform formatting sweep."
        },
        {
            "sample_idx": 828,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file but affect completely different parts of the code with no direct code linkage. Edit 0 adds exception handling with logging in the `gather_endpoints` function, while Edit 1 replaces a hardcoded string 'gateway' with a constant `GATEWAY_NAME` in the `_handle_result` function. The changed lines reference different symbols and serve different purposes - one is about error handling and the other is about using a constant instead of a magic string. There is no explicit code dependency, shared symbol reference, or structural synchronization between these changes. They appear to be independent improvements made to different parts of the same class."
        },
        {
            "sample_idx": 829,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are unrelated. Edit 0 changes a function call argument from `job.pipeline` to `str(job.pipeline.id)` in the `pause_external_data_schedule` function call. Edit 1 adds an import `schedule_exists` to an import list. The changed lines reference completely different symbols - one modifies an argument to `pause_external_data_schedule`, while the other adds a new import `schedule_exists`. There is no direct code dependency, no shared symbol reference, and no mechanical prompt between these edits. They appear to be separate changes that happen to be in the same codebase but have no explicit code linkage."
        },
        {
            "sample_idx": 831,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are in the same file (lib/streamlit/Server.py) and both modify the Server class, but they affect completely different parts of the code with no direct code dependency. Edit 0 reformats a conditional statement in the `_get_routes` method, while Edit 1 adds a new method `add_preheated_report_context`. The changed lines do not reference, assign, call, or import the same symbol. There is no explicit code linkage between the conditional formatting change and the addition of a new method - they are separate, independent modifications that happen to be in the same class. The relationship is purely coincidental (same file/class) rather than mechanically driven by code dependencies."
        },
        {
            "sample_idx": 830,
            "yi": "bi-directional",
            "pred": "0 before 1",
            "pred_reason": "Edit 1 changes the `from_crawler` method to pass three arguments to the `cls()` constructor call (uri, project_id, and acl), but Edit 0 shows the `__init__` method only accepts two parameters (uri, project_id) while trying to assign `self.acl = acl`. This creates a direct signature mismatch - Edit 1's call site expects a constructor that accepts an `acl` parameter, but the current `__init__` signature doesn't have it. For Edit 1 to work correctly, the `__init__` method must first be updated to accept the `acl` parameter (as shown in Edit 0). If Edit 1 were applied first, it would cause a TypeError at runtime due to passing too many arguments to `__init__`. The changed lines reference the exact same constructor symbol - Edit 0 modifies the signature and Edit 1 modifies the call site."
        },
        {
            "sample_idx": 833,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits add print statements to different parts of the same function's control flow - one in a KeyboardInterrupt exception handler and another in a conditional block that checks for stop commands. While both are conceptually related to server stopping functionality and may be part of the same debugging/logging enhancement, there is no direct code dependency between the changed lines. Neither edit references the same symbol, creates a syntactic dependency, or forms a mechanically obvious prompt for the other. The print statements are independent additions that don't reference, assign, call, or import the exact same symbol. This is purely a thematic/conceptual relationship without explicit code linkage."
        },
        {
            "sample_idx": 834,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 defines a new symbol SEND_CELERY_TASK_ERROR_EMAILS in celery/conf.py, while Edit 1 imports that exact same symbol from celery.conf in celery/datastructures.py. The changed lines reference the exact same fully qualified symbol. After making either edit, the other becomes the immediate, mechanically obvious next step - if you define the symbol first, you'd naturally import it where needed; if you add the import first, you'd need to define the symbol to avoid a runtime ImportError. Both edits can be written and parsed in either order (Python allows importing undefined symbols, causing only a runtime error), so this is bi-directional rather than ordered."
        },
        {
            "sample_idx": 835,
            "yi": "0 before 1",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. Edit 0 adds a line incrementing row_index in the backtesting implementation, while Edit 1 updates test assertions and expectations about dataframe length and candle dates. Although both edits are related to backtesting functionality and the test changes may be validating behavior affected by the implementation change, there is no direct code linkage between the changed lines. The changed lines in edit 0 reference 'row_index' variable, while the changed lines in edit 1 reference 'analyzed_df', 'len(analyzed_df)', and 'expected_last_candle_date' - these are different symbols. The connection is only conceptual/thematic (both relate to backtesting behavior) rather than an explicit, immediate code dependency where the exact same symbol is referenced in both edits."
        },
        {
            "sample_idx": 832,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds an import statement 'import time' at the module level, and Edit 1 uses 'time.time()' in the queryOutputLength function. This is a classic import-usage pattern where the imported module 'time' in edit 0 is the exact same symbol being referenced in edit 1's 'time.time()' call. In Python, you can reference a module before importing it (it will only fail at runtime with a NameError), so both edits can be written and parsed in either order. However, there is a clear code dependency where the changed lines reference the exact same symbol 'time', making this a bi-directional relationship where either edit naturally prompts the other as the next mechanical step."
        },
        {
            "sample_idx": 837,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits involve calls to the `unpause_external_data_schedule` function, but they are in different files and different contexts. Edit 0 modifies an existing call to change the argument from `source` to `str(source.id)` in the warehouse.py file. Edit 1 adds a new method that includes a call to `unpause_external_data_schedule(str(instance.id))` in the external_data_schema.py file. While both edits involve the same function name and both pass string-converted IDs as arguments, they reference different call sites and different symbols (source.id vs instance.id). The changed lines do not reference the exact same symbol - they are separate, unrelated calls to the same function in different contexts. There is no direct code dependency between these specific call sites, and making one edit does not create an immediate, mechanical prompt for the other."
        },
        {
            "sample_idx": 838,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different contexts. Edit 0 adds a 'use_legacy_optimizer=False' parameter to an optimizers.deserialize() call in the LossScaleOptimizerV3 class. Edit 1 adds logic to handle an 'is_legacy_optimizer' field in optimizer configuration testing. While both edits relate to legacy optimizer handling, they reference different symbols: edit 0 references the 'use_legacy_optimizer' parameter of the deserialize function, while edit 1 references the 'is_legacy_optimizer' configuration field. The changed lines do not reference the exact same symbol, and there is no direct code dependency between these specific changes - they are conceptually related but operate on different parts of the codebase without explicit linkage."
        },
        {
            "sample_idx": 836,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds AWS_REGION_US_EAST_1 to an import statement in localstack/config.py, while Edit 1 uses AWS_REGION_US_EAST_1 in a conditional check within the get_bucket_location_config function in a different file. This follows the classic import-usage pattern where the symbol AWS_REGION_US_EAST_1 is being imported in one edit and then used in another edit. However, since these are cross-file edits (different files) and there's no indication this is part of the same development session or immediate definition-usage, this would normally be 'no relation'. But looking more closely, Edit 0 is importing an existing symbol (AWS_REGION_US_EAST_1) from constants, making it available, and Edit 1 is using that exact same symbol. Since both edits reference the exact same symbol and appear to be part of implementing the same feature (handling US East 1 region special case), and the import makes the symbol available for use, this creates a bi-directional relationship where either edit could prompt the other as the next step."
        },
        {
            "sample_idx": 839,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These edits are part of a coordinated change to handle the 'is_legacy_optimizer' configuration parameter across the optimizer serialization system. Edit 0 adds 'is_legacy_optimizer': True to the serialization output documentation example, while Edit 1 adds code to remove this same parameter during deserialization in the from_config method. However, the changed lines reference different aspects of the same configuration key - one shows it being added to serialized output, the other removes it during deserialization. While they are clearly part of the same feature implementation, the changed lines don't reference the exact same symbol or create a direct code dependency between them. The documentation change in Edit 0 doesn't create an immediate, mechanically obvious prompt for the config cleanup in Edit 1, and vice versa. This is more of a coordinated feature implementation rather than edits with explicit code linkage between the changed lines themselves."
        },
        {
            "sample_idx": 840,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits are bi-directional neighbors because they both reference the exact same symbol 'is_legacy_optimizer' in their changed lines and represent complementary operations in a serialization/deserialization pair. Edit 0 adds 'is_legacy_optimizer': True to the serialized config output, while Edit 1 removes 'is_legacy_optimizer' from the config during deserialization. This creates an immediate, mechanically obvious code-driven relationship where either edit naturally prompts the other as the next contiguous action - if you add a field to serialization, you need to handle it in deserialization, and vice versa. Both edits can be staged in either order without causing parse errors, making this a bi-directional relationship rather than ordered."
        },
        {
            "sample_idx": 842,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits both add an identical parameter 'update=True' to method signatures in different classes (FileStorage.pull_path and HandlerStorage.folder_get). However, the changed lines reference different symbols - they are different methods in different classes. While they follow the same pattern of adding the same parameter name with the same default value, there is no direct code dependency or explicit linkage between these specific symbols. The methods are in different files and classes, and there's no indication that one method calls the other or that they reference the exact same symbol. This appears to be a conceptual refactoring pattern applied to similar methods, but without direct code linkage between the exact same symbols."
        },
        {
            "sample_idx": 843,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different functions and different symbols. Edit 0 adds a new function `external_data_workflow_exists` that takes an `id: str` parameter. Edit 1 changes the parameter of an existing function `pause_external_data_schedule` from `external_data_source: ExternalDataSource` to `id: str`. While both edits involve `id: str` parameters, they are in completely different functions and there is no direct code dependency between them. The changed lines do not reference the same symbol - one is adding a new function definition and the other is modifying a different function's signature. There is no explicit code linkage that would make one edit mechanically prompt the other as the next immediate step. This appears to be part of a broader refactoring to standardize parameter types, but that represents a conceptual/thematic relationship rather than a direct code dependency."
        },
        {
            "sample_idx": 841,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits appear to be part of a coordinated refactoring where the return type is being changed from Exception to ExcInfo. Edit 1 changes the return statement to return ExcInfo(sys.exc_info()) instead of exc, and Edit 0 changes the type check from isinstance(ret_value, Exception) to isinstance(ret_value, ExcInfo). However, while both edits involve ExcInfo, they reference different symbols in different contexts - one is changing what gets returned from the jail function, and the other is changing how return values are checked in a completely different class method. The changed lines don't reference the exact same symbol, and there's no direct code dependency where making one edit creates an immediate mechanical prompt for the other. These are separate parts of a broader refactoring but don't have the direct code linkage required for neighbor classification."
        },
        {
            "sample_idx": 844,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol 'test_round_allowed'. Edit 0 adds 'test_round_allowed' as a parameter to the __init__ method signature, while Edit 1 uses that same parameter to assign to self.test_round_allowed instead of the hard-coded value 5. The changed lines in both edits explicitly reference the same symbol. After adding the parameter in the signature (Edit 0), the natural next step is to use that parameter in the method body (Edit 1), or vice versa. Both edits can be staged in either order without causing parse errors - this is a parameter definition and usage within the same function scope, which creates a bi-directional relationship where either edit naturally prompts the other as the immediate next mechanical step."
        },
        {
            "sample_idx": 845,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds `assert_raises_regex` to the import statement at the top of the file, while Edit 1 uses that exact same `assert_raises_regex` symbol in a test method. This creates a direct definition-usage relationship where the imported symbol in Edit 0 is the exact same symbol being called in Edit 1. In Python, both edits can be staged in either order since using an undefined symbol only causes a runtime NameError, not a parse-time syntax error. After making either edit, the other becomes the immediate, mechanically obvious next step to complete the import-usage pair."
        },
        {
            "sample_idx": 846,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Both edits are adding the same parameter 'cwd=cwd' to different function calls within the same function context. Edit 0 adds 'cwd=cwd' to a Popen constructor call, while Edit 1 adds 'cwd=cwd' to a run_subprocess method call. However, these are different symbols being called (Popen vs run_subprocess) and there is no direct code dependency between the changed lines - neither edit creates an immediate, mechanically obvious prompt for the other. The relationship is conceptual (both adding the same parameter for similar functionality) rather than based on explicit code linkage between the exact same symbols. The changed lines reference different function calls entirely."
        },
        {
            "sample_idx": 847,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 1 defines the constant AWS_REGION_US_EAST_1 = 'us-east-1' in constants.py, while Edit 0 references this exact same symbol by replacing the hardcoded string 'us-east-1' with AWS_REGION_US_EAST_1 in config.py. This creates a definition-usage relationship where both edits reference the exact same symbol. In Python, the usage in Edit 0 can be written and parsed even before the constant is defined (it would only cause a NameError at runtime/import time, not a parse-time syntax error). Since either edit can be staged first and both reference the same symbol, making either edit creates an immediate prompt for the other as the next contiguous action to complete the refactoring from hardcoded string to named constant."
        },
        {
            "sample_idx": 848,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are not neighbours in mental flow. While both edits relate to optimizer configuration handling, they reference different symbols and serve different purposes. Edit 0 adds a 'use_legacy_optimizer=False' parameter to an 'optimizers.deserialize()' call in the LossScaleOptimizerV3 class. Edit 1 removes an 'is_legacy_optimizer' key from a config dictionary in the Adagrad class's from_config method. Although both involve legacy optimizer handling, the changed lines reference different symbols: 'use_legacy_optimizer' (a parameter) in edit 0 and 'is_legacy_optimizer' (a config key) in edit 1. There is no direct code dependency between these specific changed lines - they are in different files, different classes, and involve different aspects of the optimizer system. The connection is purely conceptual/thematic rather than an explicit code linkage where one edit creates an immediate, mechanically obvious prompt for the other."
        },
        {
            "sample_idx": 849,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (adding ACL support to GCS feed storage) but they reference different symbols and contexts. Edit 0 modifies the implementation by adding a `predefined_acl=self.acl` parameter to the `upload_from_file` method call. Edit 1 modifies test settings by adding a 'FEED_STORAGE_GCS_ACL' configuration. While both are part of implementing ACL functionality, the changed lines don't reference the exact same symbol - one references `self.acl` in the implementation and the other references a settings dictionary key. There's no direct code dependency where making one edit creates an immediate, mechanically obvious prompt for the other. The relationship is conceptual/thematic rather than having explicit code linkage between the exact same symbols."
        },
        {
            "sample_idx": 850,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are not neighbours in mental flow. Edit 0 adds a command-line argument '--add-stop-route' to the argument parser, while Edit 1 adds a print statement when a KeyboardInterrupt is caught. Although both edits are related to stopping/terminating functionality conceptually, there is no direct code linkage between the changed lines. The changed lines do not reference, assign, call, or import the exact same symbol. Edit 0 introduces a new argument parser option, while Edit 1 modifies exception handling behavior. They are part of the same feature (stop functionality) but lack the explicit, immediate code dependency required for neighbour classification."
        },
        {
            "sample_idx": 851,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits are completely unrelated. Edit 0 adds a new method `add_preheated_report_context` to the Server class, which creates a fake browser connection and handles script rerun requests. Edit 1 reformats a write statement in the _DebugHandler class by splitting it across multiple lines for better readability. The changed lines in each edit reference completely different symbols and code constructs - one adds a new method definition while the other modifies formatting of an existing method call. There is no explicit code linkage, shared symbols, or structural dependency between these changes. They appear to be separate, independent modifications made to different parts of the codebase."
        },
        {
            "sample_idx": 853,
            "yi": "bi-directional",
            "pred": "no relation",
            "pred_reason": "These two edits are adjacent code changes within the same method (`__display_header`) but they modify completely different aspects of the code. Edit 0 reformats a function call by splitting its arguments across multiple lines, while Edit 1 removes a comment line. There is no explicit code linkage between the changed lines - they don't reference the same symbol, there's no definition-usage relationship, and they're not part of a uniform substitution pattern. The only connection is that they happen to be physically adjacent in the same method, which is purely positional/contextual rather than a direct code dependency. Neither edit creates a mechanical prompt for the other - reformatting function arguments doesn't require removing an unrelated comment, and vice versa."
        },
        {
            "sample_idx": 852,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits are related to the same feature (adding ACL support to GCS feed storage) but they reference different code elements and serve different purposes. Edit 0 modifies the actual implementation by adding a `predefined_acl=self.acl` parameter to the `upload_from_file` method call. Edit 1 modifies a test configuration mock by adding 'FEED_STORAGE_GCS_ACL': None to the mocked settings. While both edits are part of implementing ACL functionality, the changed lines do not reference the exact same symbol - one is a method call parameter and the other is a mock configuration setting. There is no direct, explicit code dependency between the specific lines changed, and neither edit creates an immediate, mechanically obvious prompt for the other. The relationship is conceptual/thematic rather than based on direct symbol linkage."
        },
        {
            "sample_idx": 854,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits implement the exact same pattern of adding a timestamp-based suffix to staging table names. They both: (1) create a `data_interval_end_str` variable using identical code (`dt.datetime.fromisoformat(inputs.data_interval_end).strftime(\"%Y-%m-%d_%H-%M-%S\")`), and (2) modify the staging table name logic to include this timestamp suffix using nearly identical conditional expressions. This represents a bulk-edit pattern where the same structural substitution is being applied to the same type of syntactic construct (staging table name generation) across multiple files. The changes follow an identical before\u2192after pattern and target the same construct type, making this a synchronized refactoring operation that would naturally occur as part of a single, contiguous micro-task."
        },
        {
            "sample_idx": 855,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits reference the exact same symbol `__version__`. Edit 0 adds `__version__` to the import statement, making it available for use in the module. Edit 1 uses this newly imported `__version__` symbol in the user_agent dictionary. This creates a direct definition-usage relationship where the import in edit 0 makes the symbol available for the usage in edit 1. Since this is Python, the usage can be written before the import (it would only fail at runtime with a NameError), so both edits can be staged in either order, making this bi-directional. The changed lines reference the exact same symbol and create an immediate code-driven relationship where making either edit prompts the other as the next logical step."
        },
        {
            "sample_idx": 858,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols in different contexts. Edit 0 changes a hardcoded value to use a parameter 'test_round_allowed' in the QaEngineer class constructor, while Edit 1 adds a 'run_tests' parameter to the main function in a different file. The changed lines reference completely different symbols ('test_round_allowed' vs 'run_tests') and there is no direct code dependency, explicit reference, or synchronized substitution pattern between them. They appear to be separate parameter additions to unrelated functions, which falls under the 'no relation' category according to the criteria."
        },
        {
            "sample_idx": 856,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Edit 0 adds a 'dtype' parameter with default value None to the load_unet_state_dict function signature. Edit 1 updates a call site of the exact same function to pass the dtype parameter. The changed lines in both edits reference the exact same symbol 'load_unet_state_dict' and the same parameter 'dtype'. After making either edit, the other becomes the immediate next step to maintain code consistency - if you add the parameter to the signature, you need to update call sites to use it, and vice versa. Both edits can be staged in either order without causing parse errors (the call site update would just pass an unused argument if done first, and the signature change would just add an unused parameter if done first). This is a classic function signature change paired with call-site update pattern."
        },
        {
            "sample_idx": 857,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "These edits represent a parameter refactoring within the same function. Edit 0 changes the function parameter from 'external_data_source: ExternalDataSource' to 'id: str', and Edit 1 updates the function body to use the new parameter 'id' instead of 'external_data_source.id'. Both edits reference the exact same symbol context - the parameter of the pause_external_data_schedule function. This creates an immediate, mechanically obvious code-driven prompt: after changing the parameter signature, the function body must be updated to use the new parameter name, or vice versa. Both edits can be staged in either order without causing parse errors (the function would just have mismatched parameter usage until both changes are applied), making this a bi-directional relationship where either edit naturally prompts the other as the next contiguous action within the same micro-task."
        },
        {
            "sample_idx": 859,
            "yi": "no relation",
            "pred": "bi-directional",
            "pred_reason": "Both edits are updating calls to the same function `get_free_trial_days()` to include a parameter. Edit 0 changes the call from `get_free_trial_days()` to `get_free_trial_days(is_self_hosted_billing)` and Edit 1 changes the call from `get_free_trial_days()` to `get_free_trial_days(True)`. This represents a bulk-edit pattern where the same function signature change is being applied consistently across multiple call sites. Both edits perform an identical structural substitution (adding a parameter to the same function call) and are clearly part of a single, contiguous refactor to update the function signature throughout the codebase. The changed lines in both edits reference the exact same symbol `get_free_trial_days` and apply the same type of modification."
        },
        {
            "sample_idx": 860,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and have no direct code linkage. Edit 0 adds a 'separator' parameter to the 'new_line' method in the _GlancesCurses class, while Edit 1 adds Unicode character mappings ('MEDIUM_LINE' and 'LOW_LINE') to a dictionary in a different file. The changed lines do not reference, assign, call, or import the same symbol. There is no explicit code dependency between adding a parameter to a method and adding entries to a Unicode character mapping dictionary. While both might be conceptually related to display formatting, there is no immediate, mechanically obvious code-driven prompt between these changes."
        },
        {
            "sample_idx": 863,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "Edit 0 imports 'connection' from django.db in the common.py file, while Edit 1 uses 'connection.connect()' in the create.py file. However, these are different symbols - the 'connection' imported in common.py is not the same symbol as the 'connection' used in create.py. The changed lines reference different symbols despite having the same name. Edit 1's usage of 'connection' would need to either import it directly in create.py or import it from common.py to establish a direct code linkage. Since there's no explicit import relationship or cross-reference between the exact same symbol in both changed lines, this is conceptual linkage only."
        },
        {
            "sample_idx": 861,
            "yi": "bi-directional",
            "pred": "bi-directional",
            "pred_reason": "Both edits follow an identical pattern of modification: they both change calls to the `bisection` function to capture an additional return value (`count`), add timing logic with `start = time.time()`, and add identical debug logging statements with the same format string. The edits represent a synchronized refactoring where the same debugging/monitoring enhancement is being applied to multiple `bisection` call sites. This is a bulk-edit pattern where identical structural substitutions are being made to the same type of syntactic construct (function calls and their surrounding context). Both edits can be applied in either order since they modify different functions and don't depend on each other syntactically."
        },
        {
            "sample_idx": 862,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits do not reference the same symbol or have direct code linkage. Edit 0 modifies a call to `unpause_external_data_schedule` by changing its argument from `source` to `str(source.id)`. Edit 1 adds a new function definition `external_data_workflow_exists` that calls `schedule_exists`. While both edits involve string IDs and are in the warehouse module, they operate on different functions (`unpause_external_data_schedule` vs `external_data_workflow_exists`) and there is no direct code dependency between the changed lines. The connection is only thematic/conceptual rather than an explicit code linkage."
        },
        {
            "sample_idx": 865,
            "yi": "0 before 1",
            "pred": "0 before 1",
            "pred_reason": "These edits represent a simple repositioning of the same line of code within the same dictionary structure. Edit 0 removes the line '\"preview\": not write_file,' from line 305, while Edit 1 adds the exact same line at line 307. This is a classic cut-and-paste move operation where the line must first be removed from its original position before it can be added to the new position. The removal must occur before the relocation to avoid duplication, making this an ordered relationship where Edit 0 must happen before Edit 1."
        },
        {
            "sample_idx": 867,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols despite similar names. Edit 0 adds a 'vcs_rev' parameter to an Env constructor call, while Edit 1 renames the function 'get_vcs_rev_define' to 'get_vcs_rev'. Although both edits relate to VCS revision functionality, the changed lines reference different symbols - one references a variable 'vcs_rev' being passed as a parameter, and the other references the function name 'get_vcs_rev_define'/'get_vcs_rev'. There is no direct code dependency between these specific changed lines, and no explicit reference to the exact same symbol in both edits."
        },
        {
            "sample_idx": 866,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These two edits reference completely different symbols and serve different purposes. Edit 0 adds `__version__` to an import statement in `modeling_flax_utils.py`, while Edit 1 adds a `user_agent` parameter to a `snapshot_download` function call in `pipeline_utils.py`. There is no direct code dependency, shared symbol reference, or structural relationship between importing `__version__` and adding a `user_agent` parameter to an unrelated function call. The edits affect different files, different functions, and different symbols with no explicit code linkage between the changed lines."
        },
        {
            "sample_idx": 864,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits involve different symbols and different aspects of the GCS functionality. Edit 0 modifies the `from_crawler` class method in the production code to add a new parameter `FEED_STORAGE_GCS_ACL` to the constructor call. Edit 1 modifies a test assertion for the `upload_from_file` method call to include a `predefined_acl` parameter. While both edits are conceptually related to adding ACL functionality to GCS feed storage, they reference completely different symbols: Edit 0 changes a constructor call in `from_crawler`, while Edit 1 changes a mock assertion for `upload_from_file`. The changed lines do not reference the exact same symbol, function, or method. There is no direct code dependency between the `from_crawler` method modification and the `upload_from_file` assertion modification - they are different parts of the GCS implementation that happen to be part of the same feature addition."
        },
        {
            "sample_idx": 868,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code linkage. Edit 0 changes a call to `run_subprocess()` by adding a `cwd` parameter argument, while Edit 1 removes an import statement (`from django.conf import settings`) from within the `run_subprocess` method definition. Although both edits involve the same method (`run_subprocess`), the changed lines themselves reference completely different symbols - Edit 0 references the method call with a new parameter, while Edit 1 references an import statement for `django.conf.settings`. There is no explicit code dependency between adding a `cwd` parameter and removing a Django settings import. The connection is only conceptual (both relate to the same method) but lacks the direct symbol linkage required for neighbour classification."
        },
        {
            "sample_idx": 870,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference different symbols and have no direct code dependency. Edit 0 adds an import for 'timedelta' from the datetime module, while Edit 1 adds an assertion that tests backtesting functionality with hardcoded values. The changed lines do not reference the same symbol - Edit 0 introduces 'timedelta' but Edit 1 does not use 'timedelta' anywhere in its changed lines. Edit 1 uses existing symbols like 'backtesting', 'len', 'data', etc. that are already available in the test context. There is no explicit code linkage between importing 'timedelta' and adding this specific test assertion. The relationship, if any, is purely conceptual (both are part of test code) but lacks the direct symbol reference required for neighbour classification."
        },
        {
            "sample_idx": 869,
            "yi": "no relation",
            "pred": "no relation",
            "pred_reason": "These edits reference completely different symbols and serve different purposes. Edit 0 adds imports for SEND_CELERY_TASK_ERROR_EMAILS and mail_admins at the top of the file, while Edit 1 changes a type check from Exception to ExcInfo in a method implementation. The changed lines in each edit do not reference the same symbols - the imports in Edit 0 (SEND_CELERY_TASK_ERROR_EMAILS, mail_admins) are entirely different from the type names in Edit 1 (Exception vs ExcInfo). There is no direct code dependency or explicit linkage between these changes, just conceptual relation to error handling functionality."
        }
    ]
}